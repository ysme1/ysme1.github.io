
<!DOCTYPE html><html lang="zh-CN">

<head>
  <meta charset="utf-8">
  <meta name="hexo-theme" content="https://github.com/xaoxuu/hexo-theme-stellar/tree/1.27.0" theme-name="Stellar" theme-version="1.27.0">
  
  <meta name="generator" content="Hexo 7.1.1">
  <meta http-equiv='x-dns-prefetch-control' content='on' />
  
  <meta name="renderer" content="webkit">
  <meta name="force-rendering" content="webkit">
  <meta http-equiv="X-UA-Compatible" content="IE=Edge,chrome=1">
  <meta name="HandheldFriendly" content="True" >
  <meta name="apple-mobile-web-app-capable" content="yes">
  <meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1">
  <meta name="theme-color" content="#f8f8f8">
  
  <title>Blog</title>

  
    <meta name="description" content="一. 前言  上文分析了内存再用户态的结构体mm_struct及各个区域映射的vm_area_struct以及32位和64位的内核态结构体，本文将基于这些结构来分析Linux的内存管理系统。内存管理系统包括虚拟内存和物理内存的分页以及虚拟内存和物理内存的映射。本文将介绍分页机制，而映射则在下文中说明。本文首先简单介绍SMP和NUMA系统，然后对物理内存的节点、区域、页结构进行分析，在此基础上剖析伙">
<meta property="og:type" content="article">
<meta property="og:title" content="Blog">
<meta property="og:url" content="https://vcloud.ysme.top/2024/04/05/linux-docs/%E5%86%85%E5%AD%98%E7%AE%A1%E7%90%86/%E5%86%85%E5%AD%98%E7%AE%A1%E7%90%86%E4%B9%8B%E5%88%86%E9%A1%B5/index.html">
<meta property="og:site_name" content="Blog">
<meta property="og:description" content="一. 前言  上文分析了内存再用户态的结构体mm_struct及各个区域映射的vm_area_struct以及32位和64位的内核态结构体，本文将基于这些结构来分析Linux的内存管理系统。内存管理系统包括虚拟内存和物理内存的分页以及虚拟内存和物理内存的映射。本文将介绍分页机制，而映射则在下文中说明。本文首先简单介绍SMP和NUMA系统，然后对物理内存的节点、区域、页结构进行分析，在此基础上剖析伙">
<meta property="og:locale" content="zh_CN">
<meta property="og:image" content="https://user-images.githubusercontent.com/87457873/128138153-fce61fa0-babc-41b5-8670-a255ba315b71.png">
<meta property="og:image" content="https://user-images.githubusercontent.com/87457873/128138199-9b16c394-17e9-40b7-a048-c1e68dfb5af0.png">
<meta property="og:image" content="https://user-images.githubusercontent.com/87457873/128138240-53ab750c-c854-4dfa-9575-152c5f82e8a7.png">
<meta property="og:image" content="https://user-images.githubusercontent.com/87457873/128138262-402a29f4-5e94-459e-95b8-1af3d8dce0f6.png">
<meta property="article:published_time" content="2024-04-05T11:10:12.963Z">
<meta property="article:modified_time" content="2024-04-05T11:10:12.963Z">
<meta property="article:author" content="ysme">
<meta name="twitter:card" content="summary">
<meta name="twitter:image" content="https://user-images.githubusercontent.com/87457873/128138153-fce61fa0-babc-41b5-8670-a255ba315b71.png">
  
  
  
  

  <!-- feed -->
  

  <link rel="stylesheet" href="/css/main.css?v=1.27.0">

  

  

  
</head>
<body>

<div class="l_body s:aa content tech" id="start" layout="post" ><aside class="l_left"><div class="leftbar-container">


<header class="header"><div class="logo-wrap"><a class="avatar" href="/about/"><div class="bg" style="opacity:0;background-image:url(https://gcore.jsdelivr.net/gh/cdn-x/placeholder@1.0.12/avatar/round/rainbow64@3x.webp);"></div><img no-lazy class="avatar" src="undefined" onerror="javascript:this.classList.add('error');this.src='https://gcore.jsdelivr.net/gh/cdn-x/placeholder@1.0.12/image/2659360.svg';"></a><a class="title" href="/"><div class="main" ff="title">Blog</div></a></div></header>

<div class="nav-area">
<div class="search-wrapper" id="search-wrapper"><form class="search-form"><a class="search-button" onclick="document.getElementById(&quot;search-input&quot;).focus();"><svg t="1705074644177" viewBox="0 0 1025 1024" version="1.1" xmlns="http://www.w3.org/2000/svg" p-id="1560" width="200" height="200"><path d="M1008.839137 935.96571L792.364903 719.491476a56.783488 56.783488 0 0 0-80.152866 0 358.53545 358.53545 0 1 1 100.857314-335.166073 362.840335 362.840335 0 0 1-3.689902 170.145468 51.248635 51.248635 0 1 0 99.217358 26.444296 462.057693 462.057693 0 1 0-158.255785 242.303546l185.930047 185.725053a51.248635 51.248635 0 0 0 72.568068 0 51.248635 51.248635 0 0 0 0-72.978056z" p-id="1561"></path><path d="M616.479587 615.969233a50.428657 50.428657 0 0 0-61.498362-5.534852 174.655348 174.655348 0 0 1-177.525271 3.484907 49.403684 49.403684 0 0 0-58.833433 6.76482l-3.074918 2.869923a49.403684 49.403684 0 0 0 8.609771 78.10292 277.767601 277.767601 0 0 0 286.992355-5.739847 49.403684 49.403684 0 0 0 8.404776-76.667958z" p-id="1562"></path></svg></a><input type="text" class="search-input" id="search-input" placeholder="站内搜索"></form><div id="search-result"></div><div class="search-no-result">没有找到内容！</div></div>


<nav class="menu dis-select"></nav>
</div>
<div class="widgets">


<widget class="widget-wrapper post-list"><div class="widget-header dis-select"><span class="name">最近更新</span></div><div class="widget-body fs14"><a class="item title" href="/2023/01/15/linux-docs/%E8%BF%9B%E7%A8%8B%E7%AE%A1%E7%90%86/Linux%E5%86%85%E6%A0%B8%E8%BF%9B%E7%A8%8B%E7%AE%A1%E7%90%86%E5%B9%B6%E5%8F%91%E5%90%8C%E6%AD%A5%E4%B8%8E%E5%8E%9F%E5%AD%90%E6%93%8D%E4%BD%9C/"><span class="title">Linux内核进程管理并发同步与原子操作</span></a><a class="item title" href="/2023/01/15/linux-docs/%E8%BF%9B%E7%A8%8B%E7%AE%A1%E7%90%86/Linux%E5%86%85%E6%A0%B8%E8%BF%9B%E7%A8%8B%E7%AE%A1%E7%90%86%E8%BF%9B%E7%A8%8B%E4%BC%98%E5%85%88%E7%BA%A7/"><span class="title">Linux内核进程管理进程优先级</span></a><a class="item title" href="/2023/01/15/linux-docs/%E8%BF%9B%E7%A8%8B%E7%AE%A1%E7%90%86/Linux%E5%86%85%E6%A0%B8%E8%BF%9B%E7%A8%8B%E8%BF%B0%E7%AC%A6%E5%92%8C%E8%BF%9B%E7%A8%8B%E7%8A%B6%E6%80%81/"><span class="title">Linux内核进程述符和进程状态</span></a><a class="item title" href="/2023/01/15/linux-docs/%E8%BF%9B%E7%A8%8B%E7%AE%A1%E7%90%86/Linux%E5%86%85%E6%A0%B8%E8%BF%9B%E7%A8%8B%E8%B0%83%E5%BA%A6O(1)%E8%B0%83%E5%BA%A6%E7%AE%97%E6%B3%95/"><span class="title">Linux内核进程调度O(1)调度算法</span></a><a class="item title" href="/2023/01/15/linux-docs/%E8%BF%9B%E7%A8%8B%E7%AE%A1%E7%90%86/Linux%E5%86%85%E6%A0%B8%E8%BF%9B%E7%A8%8B%E9%97%B4%E9%80%9A%E4%BF%A1-%E7%AE%A1%E9%81%93/"><span class="title">Linux内核进程间通信-管道</span></a><a class="item title" href="/2023/01/15/linux-docs/%E8%BF%9B%E7%A8%8B%E7%AE%A1%E7%90%86/Linux%E8%BF%9B%E7%A8%8B%E3%80%81%E7%BA%BF%E7%A8%8B%E3%80%81%E8%B0%83%E5%BA%A6(%E4%B8%80)/"><span class="title">Linux进程、线程、调度(一)</span></a><a class="item title" href="/2023/01/15/linux-docs/%E8%BF%9B%E7%A8%8B%E7%AE%A1%E7%90%86/Linux%E8%BF%9B%E7%A8%8B%E3%80%81%E7%BA%BF%E7%A8%8B%E3%80%81%E8%B0%83%E5%BA%A6(%E4%B8%89)/"><span class="title">Linux进程、线程、调度(三)</span></a><a class="item title" href="/2023/01/15/linux-docs/%E8%BF%9B%E7%A8%8B%E7%AE%A1%E7%90%86/Linux%E8%BF%9B%E7%A8%8B%E3%80%81%E7%BA%BF%E7%A8%8B%E3%80%81%E8%B0%83%E5%BA%A6(%E4%BA%8C)/"><span class="title">Linux进程、线程、调度(二)</span></a><a class="item title" href="/2023/01/15/linux-docs/%E8%BF%9B%E7%A8%8B%E7%AE%A1%E7%90%86/Linux%E8%BF%9B%E7%A8%8B%E3%80%81%E7%BA%BF%E7%A8%8B%E3%80%81%E8%B0%83%E5%BA%A6(%E5%9B%9B)/"><span class="title">Linux进程、线程、调度(四)</span></a><a class="item title" href="/2023/01/15/linux-docs/%E8%BF%9B%E7%A8%8B%E7%AE%A1%E7%90%86/Linux%E8%BF%9B%E7%A8%8B%E7%8A%B6%E6%80%81%E6%80%BB%E7%BB%93/"><span class="title">Linux进程状态总结</span></a></div></widget>
</div>

</div></aside><div class="l_main" id="main">





<div class="article banner top">
  <div class="content">
    <div class="top bread-nav footnote"><div class="left"><div class="flex-row" id="breadcrumb"><a class="cap breadcrumb" href="/">主页</a>
<span class="sep"></span><a class="cap breadcrumb" href="/">文章</a></div>
<div class="flex-row" id="post-meta"><span class="text created">发布于：<time datetime="2024-04-05T11:10:12.963Z">2024-04-05</time></span><span class="sep updated"></span><span class="text updated">更新于：<time datetime="2024-04-05T11:10:12.963Z">2024-04-05</time></span></div></div></div>
    
  </div>
  </div><article class="md-text content"><h2 id="一-前言"><a href="#一-前言" class="headerlink" title="一. 前言"></a>一. 前言</h2><p>  上文分析了内存再用户态的结构体mm_struct及各个区域映射的vm_area_struct以及32位和64位的内核态结构体，本文将基于这些结构来分析Linux的内存管理系统。内存管理系统包括虚拟内存和物理内存的分页以及虚拟内存和物理内存的映射。本文将介绍分页机制，而映射则在下文中说明。本文首先简单介绍SMP和NUMA系统，然后对物理内存的节点、区域、页结构进行分析，在此基础上剖析伙伴系统和Slub Allocator的实现原理，最后介绍页面交换。</p>
<h2 id="二-内存模型"><a href="#二-内存模型" class="headerlink" title="二. 内存模型"></a>二. 内存模型</h2><p>  在计算机的发展历程中，内存模型经历了平坦内存模型、SMP和NUMA三种架构。</p>
<ul>
<li>平坦内存模型(Flat Memory Model)，又称线性内存模型，在这种模式下，采取连续的物理地址和页，所以非常容易根据地址获取页号，反之亦然。此种布局非常简单，而且是线性增长，利于使用。但是随着内存需求的增大、进程数的变多、为了安全考虑，这种模型渐渐地无法满足要求。</li>
<li>对称多处理 SMP(Symmetric MultiProcessing)，是一种多处理器的电脑硬件架构，在对称多处理架构下，每个处理器的地位都是平等的，对资源的使用权限相同。现代多数的多处理器系统都采用对称多处理架构。在这个系统中，拥有超过一个以上的处理器，这些处理器都连接到同一个共享的主存上，并由单一操作系统来控制。在对称多处理系统上，在操作系统的支持下，无论进程是处于用户空间，或是内核态，都可以分配到任何一个处理器上运行。因此，进程可以在不同的处理器间移动，达到负载平衡，使系统的效率提升。</li>
<li>非均衡访存模型 NUMA(Non-Uniform Memory Access)。在这种模式下，内存不是一整块。每个 CPU 都有自己的本地内存，CPU 访问本地内存不用过总线，因而速度要快很多，每个 CPU 和内存在一起，称为一个 NUMA 节点。但是，在本地内存不足的情况下，每个 CPU 都可以去另外的 NUMA 节点申请内存，这个时候访问延时就会比较长。</li>
</ul>
<p><img class="lazy" src="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII=" data-src="https://user-images.githubusercontent.com/87457873/128138153-fce61fa0-babc-41b5-8670-a255ba315b71.png" alt="image"></p>
<h2 id="三-节点、区域和页"><a href="#三-节点、区域和页" class="headerlink" title="三. 节点、区域和页"></a>三. 节点、区域和页</h2><h3 id="3-1-节点"><a href="#3-1-节点" class="headerlink" title="3.1 节点"></a>3.1 节点</h3><p>  这里主要分析NUMA模型。我们将内存分为多个节点对应多个CPU，每个节点再被分成一个一个的区域，每个区域有多个页面。由于页需要全局唯一定位，页还是需要有全局唯一的页号的。但是由于物理内存不是连起来的了，因此页号也就不再连续了。于是内存模型就变成了非连续内存模型。NUMA节点对应的结构为pglist_data，主要包括</p>
<ul>
<li>节点ID node_id</li>
<li>节点区域相关：node_zones，node_zonelists，nr_zones</li>
<li>节点的页数组：node_mam_map</li>
<li>节点的起始页号：node_start_pfn</li>
<li>节点中包含不连续的物理内存地址页数：node_spanned_pages</li>
<li>可用的物理页面数目：node_present_pates</li>
<li>页面回收、交换相关：kswapd_wait，kswapd，kswapd_order，kswapd_failures，kswapd_classzone_idx<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * On NUMA machines, each NUMA node would have a pg_data_t to describe</span></span><br><span class="line"><span class="comment"> * it&#x27;s memory layout. On UMA machines there is a single pglist_data which</span></span><br><span class="line"><span class="comment"> * describes the whole memory.</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * Memory statistics and page replacement data structures are maintained on a</span></span><br><span class="line"><span class="comment"> * per-zone basis.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">pglist_data</span> &#123;</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">zone</span> <span class="title">node_zones</span>[<span class="title">MAX_NR_ZONES</span>];</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">zonelist</span> <span class="title">node_zonelists</span>[<span class="title">MAX_ZONELISTS</span>];</span></span><br><span class="line">    <span class="type">int</span> nr_zones;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">page</span> *<span class="title">node_mem_map</span>;</span>    </span><br><span class="line">    <span class="type">unsigned</span> <span class="type">long</span> node_start_pfn;</span><br><span class="line">    <span class="type">unsigned</span> <span class="type">long</span> node_present_pages; <span class="comment">/* total number of physical pages */</span></span><br><span class="line">    <span class="type">unsigned</span> <span class="type">long</span> node_spanned_pages; <span class="comment">/* total size of physical page range, including holes */</span></span><br><span class="line">    <span class="type">int</span> node_id;</span><br><span class="line">    <span class="type">wait_queue_head_t</span> kswapd_wait;</span><br><span class="line">    <span class="type">wait_queue_head_t</span> pfmemalloc_wait;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">task_struct</span> *<span class="title">kswapd</span>;</span>	<span class="comment">/* Protected by mem_hotplug_begin/end() */</span></span><br><span class="line">    <span class="type">int</span> kswapd_order;</span><br><span class="line">    <span class="class"><span class="keyword">enum</span> <span class="title">zone_type</span> <span class="title">kswapd_classzone_idx</span>;</span></span><br><span class="line">    <span class="type">int</span> kswapd_failures;		<span class="comment">/* Number of &#x27;reclaimed == 0&#x27; runs */</span></span><br><span class="line">......</span><br><span class="line">&#125; <span class="type">pg_data_t</span>;</span><br></pre></td></tr></table></figure></li>
</ul>
<h3 id="3-2-区域"><a href="#3-2-区域" class="headerlink" title="3.2 区域"></a>3.2 区域</h3><p>每个节点可分成一个个的区域，node_zones存储了这些区域，node_zonelist以链表形式存储备用节点和它的内存区域的情况，nr_zones表示区域总数。区域的类型有如下几种，在上节中已简单提过，这里详细说明。</p>
<ul>
<li><p>ZONE_DMA 是指可用于作 DMA（Direct Memory Access，直接内存存取）的内存。DMA 是这样一种机制：要把外设的数据读入内存或把内存的数据传送到外设，原来都要通过 CPU 控制完成，但是这会占用 CPU，影响 CPU 处理其他事情，所以有了 DMA 模式。CPU 只需向 DMA 控制器下达指令，让 DMA 控制器来处理数据的传送，数据传送完毕再把信息反馈给 CPU，这样就可以解放 CPU。对于 64 位系统，有两个 DMA 区域。除了上面说的 ZONE_DMA，还有 ZONE_DMA32。</p>
</li>
<li><p>ZONE_NORMAL 是直接映射区，即内核态前896M空间</p>
</li>
<li><p>ZONE_HIGHMEM 是高端内存区，对于 32 位系统来说超过 896M 的地方，对于 64 位没必要有的一段区域。</p>
</li>
<li><p>ZONE_MOVABLE 是可移动区域，通过将物理内存划分为可移动分配区域和不可移动分配区域来避免内存碎片。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">enum</span> <span class="title">zone_type</span> &#123;</span></span><br><span class="line"><span class="meta">#<span class="keyword">ifdef</span> CONFIG_ZONE_DMA</span></span><br><span class="line">    ZONE_DMA,</span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">ifdef</span> CONFIG_ZONE_DMA32</span></span><br><span class="line">    ZONE_DMA32,</span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line">    ZONE_NORMAL,</span><br><span class="line"><span class="meta">#<span class="keyword">ifdef</span> CONFIG_HIGHMEM</span></span><br><span class="line">    ZONE_HIGHMEM,</span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line">    ZONE_MOVABLE,</span><br><span class="line">    __MAX_NR_ZONES</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>区域的实现数据结构为zone，主要包括</p>
</li>
<li><p>区域初始页zone_start_pfn</p>
</li>
<li><p>区域总共跨多少页 spanned_pages</p>
</li>
<li><p>区域在物理内存中真实存在的页数present_pages</p>
</li>
<li><p>区域被伙伴系统管理的所有页数managed_pages</p>
</li>
<li><p>冷热页区分per_cpu_pagest：如果一个页被加载到 CPU 高速缓存里面，这就是一个热页（Hot Page），CPU 读起来速度会快很多，如果没有就是冷页（Cold Page）。由于每个 CPU 都有自己的高速缓存，因而 per_cpu_pageset 也是每个 CPU 一个。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">zone</span> &#123;</span></span><br><span class="line">......</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">pglist_data</span>	*<span class="title">zone_pgdat</span>;</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">per_cpu_pageset</span> __<span class="title">percpu</span> *<span class="title">pageset</span>;</span></span><br><span class="line">......</span><br><span class="line">    <span class="comment">/* zone_start_pfn == zone_start_paddr &gt;&gt; PAGE_SHIFT */</span></span><br><span class="line">    <span class="type">unsigned</span> <span class="type">long</span>		zone_start_pfn;</span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">     * spanned_pages is the total pages spanned by the zone, including</span></span><br><span class="line"><span class="comment">     * holes, which is calculated as:</span></span><br><span class="line"><span class="comment">     * 	spanned_pages = zone_end_pfn - zone_start_pfn;</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * present_pages is physical pages existing within the zone, which</span></span><br><span class="line"><span class="comment">     * is calculated as:</span></span><br><span class="line"><span class="comment">     *	present_pages = spanned_pages - absent_pages(pages in holes);</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * managed_pages is present pages managed by the buddy system, which</span></span><br><span class="line"><span class="comment">     * is calculated as (reserved_pages includes pages allocated by the</span></span><br><span class="line"><span class="comment">     * bootmem allocator):</span></span><br><span class="line"><span class="comment">     *	managed_pages = present_pages - reserved_pages;</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * So present_pages may be used by memory hotplug or memory power</span></span><br><span class="line"><span class="comment">     * management logic to figure out unmanaged pages by checking</span></span><br><span class="line"><span class="comment">     * (present_pages - managed_pages). And managed_pages should be used</span></span><br><span class="line"><span class="comment">     * by page allocator and vm scanner to calculate all kinds of watermarks</span></span><br><span class="line"><span class="comment">     * and thresholds.</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * Locking rules:</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * zone_start_pfn and spanned_pages are protected by span_seqlock.</span></span><br><span class="line"><span class="comment">     * It is a seqlock because it has to be read outside of zone-&gt;lock,</span></span><br><span class="line"><span class="comment">     * and it is done in the main allocator path.  But, it is written</span></span><br><span class="line"><span class="comment">     * quite infrequently.</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * The span_seq lock is declared along with zone-&gt;lock because it is</span></span><br><span class="line"><span class="comment">     * frequently read in proximity to zone-&gt;lock.  It&#x27;s good to</span></span><br><span class="line"><span class="comment">     * give them a chance of being in the same cacheline.</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * Write access to present_pages at runtime should be protected by</span></span><br><span class="line"><span class="comment">     * mem_hotplug_begin/end(). Any reader who can&#x27;t tolerant drift of</span></span><br><span class="line"><span class="comment">     * present_pages should get_online_mems() to get a stable value.</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="type">atomic_long_t</span>		managed_pages;</span><br><span class="line">    <span class="type">unsigned</span> <span class="type">long</span>		spanned_pages;</span><br><span class="line">    <span class="type">unsigned</span> <span class="type">long</span>		present_pages;</span><br><span class="line">    <span class="type">const</span> <span class="type">char</span>		*name;</span><br><span class="line">......</span><br><span class="line">    <span class="type">int</span> initialized;</span><br><span class="line">    <span class="comment">/* Write-intensive fields used from the page allocator */</span></span><br><span class="line">    ZONE_PADDING(_pad1_)</span><br><span class="line">    <span class="comment">/* free areas of different sizes */</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">free_area</span>	<span class="title">free_area</span>[<span class="title">MAX_ORDER</span>];</span></span><br><span class="line">    <span class="comment">/* zone flags, see below */</span></span><br><span class="line">    <span class="type">unsigned</span> <span class="type">long</span>		flags;</span><br><span class="line">    <span class="comment">/* Primarily protects free_area */</span></span><br><span class="line">    <span class="type">spinlock_t</span>		lock;</span><br><span class="line">    <span class="comment">/* Write-intensive fields used by compaction and vmstats. */</span></span><br><span class="line">    ZONE_PADDING(_pad2_)</span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">     * When free pages are below this point, additional steps are taken</span></span><br><span class="line"><span class="comment">     * when reading the number of free pages to avoid per-cpu counter</span></span><br><span class="line"><span class="comment">     * drift allowing watermarks to be breached</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="type">unsigned</span> <span class="type">long</span> percpu_drift_mark;</span><br><span class="line">......</span><br><span class="line">    <span class="type">bool</span>			contiguous;</span><br><span class="line">    ZONE_PADDING(_pad3_)</span><br><span class="line">    <span class="comment">/* Zone statistics */</span></span><br><span class="line">    <span class="type">atomic_long_t</span>		vm_stat[NR_VM_ZONE_STAT_ITEMS];</span><br><span class="line">    <span class="type">atomic_long_t</span>		vm_numa_stat[NR_VM_NUMA_STAT_ITEMS];</span><br><span class="line">&#125; ____cacheline_internodealigned_in_smp;</span><br></pre></td></tr></table></figure></li>
</ul>
<h3 id="3-3-页"><a href="#3-3-页" class="headerlink" title="3.3 页"></a>3.3 页</h3><p>每个区域有很多个页，现在让我们将目光投向页的结构page。页中使用了大量的联合，其原因在于页有着多种不同的使用方式。</p>
<ul>
<li>整页使用方式。在前面介绍过，该种情况也存在两种页，一种是直接映射虚拟地址空间的匿名页（Anonymous Page），另一种则是用于关联文件、然后再和虚拟地址空间建立映射的页，称之为内存映射文件（Memory-mapped File）。对于该种模式，会使用联合里的以下变量<ul>
<li>struct address_space *mapping ：用于内存映射，如果是匿名页，最低位为 1；如果是映射文件，最低位为 0</li>
<li>pgoff_t index ：映射区的偏移量</li>
<li>atomic_t _mapcount：指向该页的页表数</li>
<li>struct list_head lru ：表示这一页应该在一个链表上，例如这个页面被换出，就在换出页的链表中；</li>
<li>compound 相关的变量用于复合页（Compound Page），就是将物理上连续的两个或多个页看成一个独立的大页。</li>
</ul>
</li>
<li>小块内存使用方式。在很多情况下，我们只需要使用少量内存，因此采用了slab allocator技术用于分配小块内存slab。它的基本原理是从内存管理模块申请一整块页，然后划分成多个小块的存储池，用复杂的队列来维护这些小块的状态（状态包括：被分配了 &#x2F; 被放回池子 &#x2F; 应该被回收）。也正是因为 slab allocator 对于队列的维护过于复杂，后来就有了一种不使用队列的分配器 slub allocator，但是里面还是用了很多 带有slab的API ，因为它保留了 slab 的用户接口，可以看成 slab allocator 的另一种实现。该种模式会使用联合里的以下变量<ul>
<li>s_mem ：正在使用的 slab 的第一个对象</li>
<li>freelist ：池子中的空闲对象</li>
<li>rcu_head ：需要释放的列表</li>
</ul>
</li>
<li>小块内存分配器slob，非常简单，常用于小型嵌入式系统</li>
</ul>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">page</span> &#123;</span></span><br><span class="line">    <span class="type">unsigned</span> <span class="type">long</span> flags;		<span class="comment">/* Atomic flags, some possibly updated asynchronously */</span></span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">     * Five words (20/40 bytes) are available in this union.</span></span><br><span class="line"><span class="comment">     * WARNING: bit 0 of the first word is used for PageTail(). That</span></span><br><span class="line"><span class="comment">     * means the other users of this union MUST NOT use the bit to</span></span><br><span class="line"><span class="comment">     * avoid collision and false-positive PageTail().</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="class"><span class="keyword">union</span> &#123;</span></span><br><span class="line">        <span class="class"><span class="keyword">struct</span> &#123;</span>	<span class="comment">/* Page cache and anonymous pages */</span></span><br><span class="line">            <span class="comment">/**</span></span><br><span class="line"><span class="comment">             * @lru: Pageout list, eg. active_list protected by</span></span><br><span class="line"><span class="comment">             * pgdat-&gt;lru_lock.  Sometimes used as a generic list</span></span><br><span class="line"><span class="comment">             * by the page owner.</span></span><br><span class="line"><span class="comment">             */</span></span><br><span class="line">            <span class="class"><span class="keyword">struct</span> <span class="title">list_head</span> <span class="title">lru</span>;</span></span><br><span class="line">            <span class="comment">/* See page-flags.h for PAGE_MAPPING_FLAGS */</span></span><br><span class="line">            <span class="class"><span class="keyword">struct</span> <span class="title">address_space</span> *<span class="title">mapping</span>;</span></span><br><span class="line">            <span class="type">pgoff_t</span> index;		<span class="comment">/* Our offset within mapping. */</span></span><br><span class="line">            <span class="comment">/**</span></span><br><span class="line"><span class="comment">             * @private: Mapping-private opaque data.</span></span><br><span class="line"><span class="comment">             * Usually used for buffer_heads if PagePrivate.</span></span><br><span class="line"><span class="comment">             * Used for swp_entry_t if PageSwapCache.</span></span><br><span class="line"><span class="comment">             * Indicates order in the buddy system if PageBuddy.</span></span><br><span class="line"><span class="comment">             */</span></span><br><span class="line">            <span class="type">unsigned</span> <span class="type">long</span> private;</span><br><span class="line">        &#125;;</span><br><span class="line">        <span class="class"><span class="keyword">struct</span> &#123;</span>	<span class="comment">/* page_pool used by netstack */</span></span><br><span class="line">            <span class="comment">/**</span></span><br><span class="line"><span class="comment">             * @dma_addr: might require a 64-bit value even on</span></span><br><span class="line"><span class="comment">             * 32-bit architectures.</span></span><br><span class="line"><span class="comment">             */</span></span><br><span class="line">            <span class="type">dma_addr_t</span> dma_addr;</span><br><span class="line">        &#125;;</span><br><span class="line">        <span class="class"><span class="keyword">struct</span> &#123;</span>	<span class="comment">/* slab, slob and slub */</span></span><br><span class="line">            <span class="class"><span class="keyword">union</span> &#123;</span></span><br><span class="line">                <span class="class"><span class="keyword">struct</span> <span class="title">list_head</span> <span class="title">slab_list</span>;</span>	<span class="comment">/* uses lru */</span></span><br><span class="line">                <span class="class"><span class="keyword">struct</span> &#123;</span>	<span class="comment">/* Partial pages */</span></span><br><span class="line">                    <span class="class"><span class="keyword">struct</span> <span class="title">page</span> *<span class="title">next</span>;</span></span><br><span class="line">......</span><br><span class="line">                &#125;;</span><br><span class="line">            &#125;;</span><br><span class="line">            <span class="class"><span class="keyword">struct</span> <span class="title">kmem_cache</span> *<span class="title">slab_cache</span>;</span> <span class="comment">/* not slob */</span></span><br><span class="line">            <span class="comment">/* Double-word boundary */</span></span><br><span class="line">            <span class="type">void</span> *freelist;		<span class="comment">/* first free object */</span></span><br><span class="line">            <span class="class"><span class="keyword">union</span> &#123;</span></span><br><span class="line">                <span class="type">void</span> *s_mem;	<span class="comment">/* slab: first object */</span></span><br><span class="line">                <span class="type">unsigned</span> <span class="type">long</span> counters;		<span class="comment">/* SLUB */</span></span><br><span class="line">                <span class="class"><span class="keyword">struct</span> &#123;</span>			<span class="comment">/* SLUB */</span></span><br><span class="line">                    <span class="type">unsigned</span> inuse:<span class="number">16</span>;</span><br><span class="line">                    <span class="type">unsigned</span> objects:<span class="number">15</span>;</span><br><span class="line">                    <span class="type">unsigned</span> frozen:<span class="number">1</span>;</span><br><span class="line">                &#125;;</span><br><span class="line">            &#125;;</span><br><span class="line">        &#125;;</span><br><span class="line">......</span><br><span class="line">        <span class="class"><span class="keyword">struct</span> &#123;</span>	<span class="comment">/* ZONE_DEVICE pages */</span></span><br><span class="line">            <span class="comment">/** @pgmap: Points to the hosting device page map. */</span></span><br><span class="line">            <span class="class"><span class="keyword">struct</span> <span class="title">dev_pagemap</span> *<span class="title">pgmap</span>;</span></span><br><span class="line">            <span class="type">unsigned</span> <span class="type">long</span> hmm_data;</span><br><span class="line">            <span class="type">unsigned</span> <span class="type">long</span> _zd_pad_1;	<span class="comment">/* uses mapping */</span></span><br><span class="line">        &#125;;</span><br><span class="line">        <span class="comment">/** @rcu_head: You can use this to free a page by RCU. */</span></span><br><span class="line">        <span class="class"><span class="keyword">struct</span> <span class="title">rcu_head</span> <span class="title">rcu_head</span>;</span></span><br><span class="line">    &#125;;</span><br><span class="line">......</span><br><span class="line">&#125; _struct_page_alignment;</span><br></pre></td></tr></table></figure>
<h2 id="四-用户态页的分配"><a href="#四-用户态页的分配" class="headerlink" title="四. 用户态页的分配"></a>四. 用户态页的分配</h2><p>  在上节中我们介绍了页按大小分配大致有伙伴系统和小块内存分配的slub分配。本节就这两种展开讨论。</p>
<h3 id="4-1-伙伴系统"><a href="#4-1-伙伴系统" class="headerlink" title="4.1 伙伴系统"></a>4.1 伙伴系统</h3><p>  对于要分配比较大的内存，例如到分配页级别的，可以使用伙伴系统（Buddy System）。伙伴分配机制可以归纳如下。</p>
<ul>
<li>采取多个链表将空闲页组织起来，每个链表中的节点包含的页块数目不同，即第i个链表中的每个节点拥有2^i个页。</li>
<li>当向内核请求分配 (2^(i-1)，2^i]数目的页块时，按照 2^i 页块请求处理，并将其分裂。</li>
<li>如果对应的页块链表中没有空闲页块，那我们就在更大的页块链表中去找，并对其进行分裂。如请求128个页，如果128页块链表无空闲则请求256链表，并将其分裂为两个128链表。</li>
</ul>
<p>  源码实现于alloc_pages()中，传参的定义如注释中所示，order表示分配2的order次方个页，gfp_mask表示分配区域，主要有</p>
<ul>
<li>GFP_USER：用于一个用户进程希望通过内存映射的方式访问某些硬件的缓存，例如显卡缓存</li>
<li>GFP_KERNEL：用于内核中分配页，主要分配 ZONE_NORMAL 区域，也即直接映射区</li>
<li>GFP_HIGHMEM：用于分配高端内存区域</li>
<li>GFP_FS：用于文件映射区</li>
<li>GFP_ATOMIC：表示该页内容不会进入休眠</li>
</ul>
<p>  这里涉及到了一种加快内存速度的技术：交叉存取技术（interleaved memory）。该存储方式会将存储体分为多个模块，每个模块类似于负载均衡逐个写入，这样当前字节被刷新时，可以不影响下一个字节的访问。交叉存储主要补偿DRAM等存储器相对较慢的读写速度。读或写每一个内存块，都需要等待内存块给出ready信号，才能读写下一字节。交叉存储将连续信息分散到各个块中，读写时可以同时等待多个内存块给出ready信号，从而提高了读写的速度。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">static</span> <span class="keyword">inline</span> <span class="keyword">struct</span> page *</span><br><span class="line"><span class="title function_">alloc_pages</span><span class="params">(<span class="type">gfp_t</span> gfp_mask, <span class="type">unsigned</span> <span class="type">int</span> order)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">return</span> alloc_pages_current(gfp_mask, order);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 	alloc_pages_current - Allocate pages.</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> *	@gfp:</span></span><br><span class="line"><span class="comment"> *		    %GFP_USER   user allocation,</span></span><br><span class="line"><span class="comment"> *      	%GFP_KERNEL kernel allocation,</span></span><br><span class="line"><span class="comment"> *      	%GFP_HIGHMEM highmem allocation,</span></span><br><span class="line"><span class="comment"> *      	%GFP_FS     don&#x27;t call back into a file system.</span></span><br><span class="line"><span class="comment"> *      	%GFP_ATOMIC don&#x27;t sleep.</span></span><br><span class="line"><span class="comment"> *	@order: Power of two of allocation size in pages. 0 is a single page.</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> *	Allocate a page from the kernel page pool.  When not in</span></span><br><span class="line"><span class="comment"> *	interrupt context and apply the current process NUMA policy.</span></span><br><span class="line"><span class="comment"> *	Returns NULL when no page can be allocated.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">struct</span> page *<span class="title function_">alloc_pages_current</span><span class="params">(<span class="type">gfp_t</span> gfp, <span class="type">unsigned</span> order)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">mempolicy</span> *<span class="title">pol</span> =</span> &amp;default_policy;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">page</span> *<span class="title">page</span>;</span></span><br><span class="line">    <span class="keyword">if</span> (!in_interrupt() &amp;&amp; !(gfp &amp; __GFP_THISNODE))</span><br><span class="line">        pol = get_task_policy(current);</span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">     * No reference counting needed for current-&gt;mempolicy</span></span><br><span class="line"><span class="comment">     * nor system default_policy</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">if</span> (pol-&gt;mode == MPOL_INTERLEAVE)</span><br><span class="line">        page = alloc_page_interleave(gfp, order, interleave_nodes(pol));</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">        page = __alloc_pages_nodemask(gfp, order,</span><br><span class="line">                policy_node(gfp, pol, numa_node_id()),</span><br><span class="line">                policy_nodemask(gfp, pol));</span><br><span class="line">    <span class="keyword">return</span> page;</span><br><span class="line">&#125;</span><br><span class="line">EXPORT_SYMBOL(alloc_pages_current);</span><br><span class="line">````</span><br><span class="line">  交叉存取的alloc_page_interleave()函数实际上通过调用__alloc_page()最终也会调用__alloc_pages_nodemask()函数来实现分配。__alloc_pages_nodemask()是伙伴系统的核心方法，它会调用 get_page_from_freelist()在一个循环中轮询区域，先看当前节点的 zone，如果找不到空闲页则再看备用节点的 zone，直到找到为止。</span><br><span class="line">```c</span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * This is the &#x27;heart&#x27; of the zoned buddy allocator.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">page</span> *</span></span><br><span class="line"><span class="class">__<span class="title">alloc_pages_nodemask</span>(<span class="title">gfp_t</span> <span class="title">gfp_mask</span>, <span class="title">unsigned</span> <span class="title">int</span> <span class="title">order</span>, <span class="title">int</span> <span class="title">preferred_nid</span>,</span></span><br><span class="line"><span class="class">                            <span class="title">nodemask_t</span> *<span class="title">nodemask</span>)</span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">page</span> *<span class="title">page</span>;</span></span><br><span class="line">    <span class="type">unsigned</span> <span class="type">int</span> alloc_flags = ALLOC_WMARK_LOW;</span><br><span class="line">    <span class="type">gfp_t</span> alloc_mask; <span class="comment">/* The gfp_t that was actually used for allocation */</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">alloc_context</span> <span class="title">ac</span> =</span> &#123; &#125;;</span><br><span class="line">......</span><br><span class="line">    gfp_mask &amp;= gfp_allowed_mask;</span><br><span class="line">    alloc_mask = gfp_mask;</span><br><span class="line">    <span class="keyword">if</span> (!prepare_alloc_pages(gfp_mask, order, preferred_nid, nodemask, &amp;ac, &amp;alloc_mask, &amp;alloc_flags))</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">    finalise_ac(gfp_mask, &amp;ac);</span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">     * Forbid the first pass from falling back to types that fragment</span></span><br><span class="line"><span class="comment">     * memory until all local zones are considered.</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    alloc_flags |= alloc_flags_nofragment(ac.preferred_zoneref-&gt;zone, gfp_mask);</span><br><span class="line">    <span class="comment">/* First allocation attempt */</span></span><br><span class="line">    page = get_page_from_freelist(alloc_mask, order, alloc_flags, &amp;ac);</span><br><span class="line">......</span><br><span class="line">&#125;</span><br><span class="line">EXPORT_SYMBOL(__alloc_pages_nodemask);</span><br></pre></td></tr></table></figure>
<p>  get_page_from_freelist()函数如下所示，主要调用rmqueue()找寻合适大小的队列，并取出页面。通过rmqueue()-&gt;__rmqueue()-&gt;__rmqueue_smallest()最终来到__rmqueue_smallest()函数</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * get_page_from_freelist goes through the zonelist trying to allocate</span></span><br><span class="line"><span class="comment"> * a page.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="type">static</span> <span class="keyword">struct</span> page *</span><br><span class="line"><span class="title function_">get_page_from_freelist</span><span class="params">(<span class="type">gfp_t</span> gfp_mask, <span class="type">unsigned</span> <span class="type">int</span> order, <span class="type">int</span> alloc_flags,</span></span><br><span class="line"><span class="params">                        <span class="type">const</span> <span class="keyword">struct</span> alloc_context *ac)</span></span><br><span class="line">&#123;	</span><br><span class="line">......</span><br><span class="line">    for_next_zone_zonelist_nodemask(zone, z, ac-&gt;zonelist, ac-&gt;high_zoneidx,</span><br><span class="line">                                ac-&gt;nodemask) &#123;</span><br><span class="line">......</span><br><span class="line">        page = rmqueue(ac-&gt;preferred_zoneref-&gt;zone, zone, order,</span><br><span class="line">                gfp_mask, alloc_flags, ac-&gt;migratetype);</span><br><span class="line">        <span class="keyword">if</span> (page) &#123;</span><br><span class="line">            prep_new_page(page, order, gfp_mask, alloc_flags);</span><br><span class="line">            <span class="comment">/*</span></span><br><span class="line"><span class="comment">             * If this is a high-order atomic allocation then check</span></span><br><span class="line"><span class="comment">             * if the pageblock should be reserved for the future</span></span><br><span class="line"><span class="comment">             */</span></span><br><span class="line">            <span class="keyword">if</span> (unlikely(order &amp;&amp; (alloc_flags &amp; ALLOC_HARDER)))</span><br><span class="line">                reserve_highatomic_pageblock(page, zone, order);</span><br><span class="line">            <span class="keyword">return</span> page;</span><br><span class="line">        &#125; </span><br><span class="line">......</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>  在__rmqueue_smallest()中，实现了伙伴系统的找寻逻辑。从当前的order开始循环，如果page为空则order++，否则从当前链表lru中删除该页块，通过expand()函数将该区域剩余页块分配到其他对应的order链表中，最后返回该页块。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * Go through the free lists for the given migratetype and remove</span></span><br><span class="line"><span class="comment"> * the smallest available page from the freelists</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="type">static</span> __always_inline</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">page</span> *__<span class="title">rmqueue_smallest</span>(<span class="keyword">struct</span> <span class="title">zone</span> *<span class="title">zone</span>, <span class="title">unsigned</span> <span class="title">int</span> <span class="title">order</span>,</span></span><br><span class="line"><span class="class">                        <span class="title">int</span> <span class="title">migratetype</span>)</span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    <span class="type">unsigned</span> <span class="type">int</span> current_order;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">free_area</span> *<span class="title">area</span>;</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">page</span> *<span class="title">page</span>;</span></span><br><span class="line">    <span class="comment">/* Find a page of the appropriate size in the preferred list */</span></span><br><span class="line">    <span class="keyword">for</span> (current_order = order; current_order &lt; MAX_ORDER; ++current_order) &#123;</span><br><span class="line">        area = &amp;(zone-&gt;free_area[current_order]);</span><br><span class="line">        page = list_first_entry_or_null(&amp;area-&gt;free_list[migratetype],</span><br><span class="line">                            <span class="keyword">struct</span> page, lru);</span><br><span class="line">        <span class="keyword">if</span> (!page)</span><br><span class="line">            <span class="keyword">continue</span>;</span><br><span class="line">        list_del(&amp;page-&gt;lru);</span><br><span class="line">        rmv_page_order(page);</span><br><span class="line">        area-&gt;nr_free--;</span><br><span class="line">        expand(zone, page, order, current_order, area, migratetype);</span><br><span class="line">        set_pcppage_migratetype(page, migratetype);</span><br><span class="line">        <span class="keyword">return</span> page;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">&#125;</span><br><span class="line">  expand()函数中将页块区域前移，size右移即除<span class="number">2</span>，然后使用list_add加入链表之中</span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * The order of subdivision here is critical for the IO subsystem.</span></span><br><span class="line"><span class="comment"> * Please do not alter this order without good reasons and regression</span></span><br><span class="line"><span class="comment"> * testing. Specifically, as large blocks of memory are subdivided,</span></span><br><span class="line"><span class="comment"> * the order in which smaller blocks are delivered depends on the order</span></span><br><span class="line"><span class="comment"> * they&#x27;re subdivided in this function. This is the primary factor</span></span><br><span class="line"><span class="comment"> * influencing the order in which pages are delivered to the IO</span></span><br><span class="line"><span class="comment"> * subsystem according to empirical testing, and this is also justified</span></span><br><span class="line"><span class="comment"> * by considering the behavior of a buddy system containing a single</span></span><br><span class="line"><span class="comment"> * large block of memory acted on by a series of small allocations.</span></span><br><span class="line"><span class="comment"> * This behavior is a critical factor in sglist merging&#x27;s success.</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * -- nyc</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="type">static</span> <span class="keyword">inline</span> <span class="type">void</span> <span class="title function_">expand</span><span class="params">(<span class="keyword">struct</span> zone *zone, <span class="keyword">struct</span> page *page,</span></span><br><span class="line"><span class="params">    <span class="type">int</span> low, <span class="type">int</span> high, <span class="keyword">struct</span> free_area *area,</span></span><br><span class="line"><span class="params">    <span class="type">int</span> migratetype)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">unsigned</span> <span class="type">long</span> size = <span class="number">1</span> &lt;&lt; high;</span><br><span class="line">    <span class="keyword">while</span> (high &gt; low) &#123;</span><br><span class="line">        area--;</span><br><span class="line">        high--;</span><br><span class="line">        size &gt;&gt;= <span class="number">1</span>;</span><br><span class="line">        VM_BUG_ON_PAGE(bad_range(zone, &amp;page[size]), &amp;page[size]);</span><br><span class="line">        <span class="comment">/*</span></span><br><span class="line"><span class="comment">         * Mark as guard pages (or page), that will allow to</span></span><br><span class="line"><span class="comment">         * merge back to allocator when buddy will be freed.</span></span><br><span class="line"><span class="comment">         * Corresponding page table entries will not be touched,</span></span><br><span class="line"><span class="comment">         * pages will stay not present in virtual address space</span></span><br><span class="line"><span class="comment">         */</span></span><br><span class="line">        <span class="keyword">if</span> (set_page_guard(zone, &amp;page[size], high, migratetype))</span><br><span class="line">            <span class="keyword">continue</span>;</span><br><span class="line">        list_add(&amp;page[size].lru, &amp;area-&gt;free_list[migratetype]);</span><br><span class="line">        area-&gt;nr_free++;</span><br><span class="line">        set_page_order(&amp;page[size], high);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>最后以一张结构图作为总结</p>
<p><img class="lazy" src="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII=" data-src="https://user-images.githubusercontent.com/87457873/128138199-9b16c394-17e9-40b7-a048-c1e68dfb5af0.png" alt="image"></p>
<h3 id="4-2-slub-allocator"><a href="#4-2-slub-allocator" class="headerlink" title="4.2 slub allocator"></a>4.2 slub allocator</h3><p>  任务task_struct在派生时，会调用alloc_task_struct_node()分配task_struct对象，其底层调用kmem_cache_alloc_node()函数在task_struct的缓存区域kmem_cache *task_struct_cachep分配内存。在系统初始化的时候，task_struct_cachep 会被 kmem_cache_create() 函数创建。这个函数专门用于分配 task_struct 对象的缓存。这个缓存区的名字就叫 task_struct。</p>
<p>  缓存区中每一块的大小正好等于 task_struct 的大小，也即 arch_task_struct_size。有了这个缓存区，每次创建 task_struct 的时候，先调用 kmem_cache_alloc_node()函数在缓存里面看看有没有直接可用的。当一个进程结束，task_struct 也不用直接被销毁，而是调用kmem_cache_free()放回到缓存中。这样，新进程创建的时候，我们就可以直接用现成的缓存中的 task_struct 了，从而加快了申请、释放速度。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">static</span> <span class="class"><span class="keyword">struct</span> <span class="title">kmem_cache</span> *<span class="title">task_struct_cachep</span>;</span></span><br><span class="line"></span><br><span class="line">task_struct_cachep = kmem_cache_create(<span class="string">&quot;task_struct&quot;</span>,</span><br><span class="line">      arch_task_struct_size, align,</span><br><span class="line">      SLAB_PANIC|SLAB_NOTRACK|SLAB_ACCOUNT, <span class="literal">NULL</span>);</span><br><span class="line"></span><br><span class="line"><span class="type">static</span> <span class="keyword">inline</span> <span class="keyword">struct</span> task_struct *<span class="title function_">alloc_task_struct_node</span><span class="params">(<span class="type">int</span> node)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">return</span> kmem_cache_alloc_node(task_struct_cachep, GFP_KERNEL, node);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">static</span> <span class="keyword">inline</span> <span class="type">void</span> <span class="title function_">free_task_struct</span><span class="params">(<span class="keyword">struct</span> task_struct *tsk)</span></span><br><span class="line">&#123;</span><br><span class="line">    kmem_cache_free(task_struct_cachep, tsk);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>  下面分析一下缓冲区kmem_cache结构体。</p>
<ul>
<li><p>kmem_cached_cpu和kmem_cached_node：每个NUMA节点都对应一个，分别是缓存分配的fast path和slow path。每次分配的时候，要先从 kmem_cache_cpu 进行分配。如果 kmem_cache_cpu 里面没有空闲的块，那就到 kmem_cache_node 中进行分配；如果还是没有空闲的块，才去伙伴系统分配新的页。</p>
</li>
<li><p>size，object_size和offset：通过链表list_head，所有的小内存块会联系起来存放在缓冲区，用于task_struct、mm_struct、fs_struct等申请小内存块，object_size表示某内存块的大小，size表示该内存块加上指针的总大小，offset表示下一个空闲内存块的指针的偏移量。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * Slab cache management.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">kmem_cache</span> &#123;</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">kmem_cache_cpu</span> __<span class="title">percpu</span> *<span class="title">cpu_slab</span>;</span></span><br><span class="line">    <span class="comment">/* Used for retrieving partial slabs, etc. */</span></span><br><span class="line">    <span class="type">slab_flags_t</span> flags;</span><br><span class="line">    <span class="type">unsigned</span> <span class="type">long</span> min_partial;</span><br><span class="line">    <span class="type">unsigned</span> <span class="type">int</span> size;	<span class="comment">/* The size of an object including metadata */</span></span><br><span class="line">    <span class="type">unsigned</span> <span class="type">int</span> object_size;<span class="comment">/* The size of an object without metadata */</span></span><br><span class="line">    <span class="type">unsigned</span> <span class="type">int</span> offset;	<span class="comment">/* Free pointer offset */</span></span><br><span class="line"><span class="meta">#<span class="keyword">ifdef</span> CONFIG_SLUB_CPU_PARTIAL</span></span><br><span class="line">    <span class="comment">/* Number of per cpu partial objects to keep around */</span></span><br><span class="line">    <span class="type">unsigned</span> <span class="type">int</span> cpu_partial;</span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">kmem_cache_order_objects</span> <span class="title">oo</span>;</span></span><br><span class="line">    <span class="comment">/* Allocation and freeing of slabs */</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">kmem_cache_order_objects</span> <span class="title">max</span>;</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">kmem_cache_order_objects</span> <span class="title">min</span>;</span></span><br><span class="line">    <span class="type">gfp_t</span> allocflags;	<span class="comment">/* gfp flags to use on each alloc */</span></span><br><span class="line">    <span class="type">int</span> refcount;		<span class="comment">/* Refcount for slab cache destroy */</span></span><br><span class="line">    <span class="type">void</span> (*ctor)(<span class="type">void</span> *);</span><br><span class="line">    <span class="type">unsigned</span> <span class="type">int</span> inuse;		<span class="comment">/* Offset to metadata */</span></span><br><span class="line">    <span class="type">unsigned</span> <span class="type">int</span> align;		<span class="comment">/* Alignment */</span></span><br><span class="line">    <span class="type">unsigned</span> <span class="type">int</span> red_left_pad;	<span class="comment">/* Left redzone padding size */</span></span><br><span class="line">    <span class="type">const</span> <span class="type">char</span> *name;	<span class="comment">/* Name (only for display!) */</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">list_head</span> <span class="title">list</span>;</span>	<span class="comment">/* List of slab caches */</span></span><br><span class="line">......</span><br><span class="line">    <span class="type">unsigned</span> <span class="type">int</span> useroffset;	<span class="comment">/* Usercopy region offset */</span></span><br><span class="line">    <span class="type">unsigned</span> <span class="type">int</span> usersize;		<span class="comment">/* Usercopy region size */</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">kmem_cache_node</span> *<span class="title">node</span>[<span class="title">MAX_NUMNODES</span>];</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>  首先来看看快分配方式kmem_cached_cpu，该结构体中page指向内存页块的第一页，freelist指向下一个可用的内存页块，partial表示部分被分配部分为空的页，该项为备用项，仅当page满了才会在partial中寻找，而partial本身指向的是kmem_cached_node中的partial链表。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">kmem_cache_cpu</span> &#123;</span></span><br><span class="line">    <span class="type">void</span> **freelist;	<span class="comment">/* Pointer to next available object */</span></span><br><span class="line">    <span class="type">unsigned</span> <span class="type">long</span> tid;	<span class="comment">/* Globally unique transaction id */</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">page</span> *<span class="title">page</span>;</span>	<span class="comment">/* The slab from which we are allocating */</span></span><br><span class="line"><span class="meta">#<span class="keyword">ifdef</span> CONFIG_SLUB_CPU_PARTIAL</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">page</span> *<span class="title">partial</span>;</span>	<span class="comment">/* Partially allocated frozen slabs */</span></span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">ifdef</span> CONFIG_SLUB_STATS</span></span><br><span class="line">    <span class="type">unsigned</span> stat[NR_SLUB_STAT_ITEMS];</span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>  kmem_cached_node结构体中也有类似的成员变量，但是相较之下会有更多详细信息，如slab链表总长度、空闲内存块的数量等等。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * The slab lists for all objects.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">kmem_cache_node</span> &#123;</span></span><br><span class="line">    <span class="type">spinlock_t</span> list_lock;</span><br><span class="line"><span class="meta">#<span class="keyword">ifdef</span> CONFIG_SLAB</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">list_head</span> <span class="title">slabs_partial</span>;</span>	<span class="comment">/* partial list first, better asm code */</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">list_head</span> <span class="title">slabs_full</span>;</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">list_head</span> <span class="title">slabs_free</span>;</span></span><br><span class="line">    <span class="type">unsigned</span> <span class="type">long</span> total_slabs;	<span class="comment">/* length of all slab lists */</span></span><br><span class="line">    <span class="type">unsigned</span> <span class="type">long</span> free_slabs;	<span class="comment">/* length of free slab list only */</span></span><br><span class="line">    <span class="type">unsigned</span> <span class="type">long</span> free_objects;</span><br><span class="line">    <span class="type">unsigned</span> <span class="type">int</span> free_limit;</span><br><span class="line">    <span class="type">unsigned</span> <span class="type">int</span> colour_next;	<span class="comment">/* Per-node cache coloring */</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">array_cache</span> *<span class="title">shared</span>;</span>	<span class="comment">/* shared per node */</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">alien_cache</span> **<span class="title">alien</span>;</span>	<span class="comment">/* on other nodes */</span></span><br><span class="line">    <span class="type">unsigned</span> <span class="type">long</span> next_reap;	<span class="comment">/* updated without locking */</span></span><br><span class="line">    <span class="type">int</span> free_touched;		<span class="comment">/* updated without locking */</span></span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">ifdef</span> CONFIG_SLUB</span></span><br><span class="line">    <span class="type">unsigned</span> <span class="type">long</span> nr_partial;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">list_head</span> <span class="title">partial</span>;</span></span><br><span class="line">......</span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>  下面回到缓冲区的分配函数kmem_cache_alloc_node()和释放函数kmem_cache_free。分配函数kmem_cache_alloc_node()实际调用slab_alloc_node()。从这里可以看出快通道和慢通道的处理逻辑。</p>
</li>
<li><p>快通道：尝试取出kmem_cache_cpu cpu_slab的freelist，如果有空闲则返回，否则进入慢通道</p>
</li>
<li><p>慢通道：调用__slab_alloc()分配新的内存块</p>
</li>
</ul>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * Inlined fastpath so that allocation functions (kmalloc, kmem_cache_alloc)</span></span><br><span class="line"><span class="comment"> * have the fastpath folded into their functions. So no function call</span></span><br><span class="line"><span class="comment"> * overhead for requests that can be satisfied on the fastpath.</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * The fastpath works by first checking if the lockless freelist can be used.</span></span><br><span class="line"><span class="comment"> * If not then __slab_alloc is called for slow processing.</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * Otherwise we can simply pick the next object from the lockless free list.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="type">static</span> __always_inline <span class="type">void</span> *<span class="title function_">slab_alloc_node</span><span class="params">(<span class="keyword">struct</span> kmem_cache *s,</span></span><br><span class="line"><span class="params">        <span class="type">gfp_t</span> gfpflags, <span class="type">int</span> node, <span class="type">unsigned</span> <span class="type">long</span> addr)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">void</span> *object;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">kmem_cache_cpu</span> *<span class="title">c</span>;</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">page</span> *<span class="title">page</span>;</span></span><br><span class="line">    <span class="type">unsigned</span> <span class="type">long</span> tid;</span><br><span class="line">    s = slab_pre_alloc_hook(s, gfpflags);</span><br><span class="line">    <span class="keyword">if</span> (!s)</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">redo:</span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">     * Must read kmem_cache cpu data via this cpu ptr. Preemption is</span></span><br><span class="line"><span class="comment">     * enabled. We may switch back and forth between cpus while</span></span><br><span class="line"><span class="comment">     * reading from one cpu area. That does not matter as long</span></span><br><span class="line"><span class="comment">     * as we end up on the original cpu again when doing the cmpxchg.</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * We should guarantee that tid and kmem_cache are retrieved on</span></span><br><span class="line"><span class="comment">     * the same cpu. It could be different if CONFIG_PREEMPT so we need</span></span><br><span class="line"><span class="comment">     * to check if it is matched or not.</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">do</span> &#123;</span><br><span class="line">        tid = this_cpu_read(s-&gt;cpu_slab-&gt;tid);</span><br><span class="line">        c = raw_cpu_ptr(s-&gt;cpu_slab);</span><br><span class="line">    &#125; <span class="keyword">while</span> (IS_ENABLED(CONFIG_PREEMPT) &amp;&amp;</span><br><span class="line">         unlikely(tid != READ_ONCE(c-&gt;tid)));</span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">     * Irqless object alloc/free algorithm used here depends on sequence</span></span><br><span class="line"><span class="comment">     * of fetching cpu_slab&#x27;s data. tid should be fetched before anything</span></span><br><span class="line"><span class="comment">     * on c to guarantee that object and page associated with previous tid</span></span><br><span class="line"><span class="comment">     * won&#x27;t be used with current tid. If we fetch tid first, object and</span></span><br><span class="line"><span class="comment">     * page could be one associated with next tid and our alloc/free</span></span><br><span class="line"><span class="comment">     * request will be failed. In this case, we will retry. So, no problem.</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    barrier();</span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">     * The transaction ids are globally unique per cpu and per operation on</span></span><br><span class="line"><span class="comment">     * a per cpu queue. Thus they can be guarantee that the cmpxchg_double</span></span><br><span class="line"><span class="comment">     * occurs on the right processor and that there was no operation on the</span></span><br><span class="line"><span class="comment">     * linked list in between.</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    object = c-&gt;freelist;</span><br><span class="line">    page = c-&gt;page;</span><br><span class="line">    <span class="keyword">if</span> (unlikely(!object || !node_match(page, node))) &#123;</span><br><span class="line">        object = __slab_alloc(s, gfpflags, node, addr, c);</span><br><span class="line">        stat(s, ALLOC_SLOWPATH);</span><br><span class="line">    &#125;</span><br><span class="line">......</span><br><span class="line">    <span class="keyword">return</span> object;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>  __slab_alloc()主要逻辑如下</p>
<ul>
<li>在此尝试kmem_cache_cpu中的freelist是否可用，因为当前进程可能被中断，等回到该进程继续执行时可能已经有了空闲内存块可以直接使用了，因此先检查一下</li>
<li>跳转到new_slab标签，检查kmem_cache_cpu中的paritial，如果partial不为空则将kmem_cache_cpu中的page替换为partial，跳转至redo标签再次尝试分配</li>
<li>依然失败，则调用new_slab_objects()分配新内存块</li>
</ul>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * Slow path. The lockless freelist is empty or we need to perform</span></span><br><span class="line"><span class="comment"> * debugging duties.</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * Processing is still very fast if new objects have been freed to the</span></span><br><span class="line"><span class="comment"> * regular freelist. In that case we simply take over the regular freelist</span></span><br><span class="line"><span class="comment"> * as the lockless freelist and zap the regular freelist.</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * If that is not working then we fall back to the partial lists. We take the</span></span><br><span class="line"><span class="comment"> * first element of the freelist as the object to allocate now and move the</span></span><br><span class="line"><span class="comment"> * rest of the freelist to the lockless freelist.</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * And if we were unable to get a new slab from the partial slab lists then</span></span><br><span class="line"><span class="comment"> * we need to allocate a new slab. This is the slowest path since it involves</span></span><br><span class="line"><span class="comment"> * a call to the page allocator and the setup of a new slab.</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * Version of __slab_alloc to use when we know that interrupts are</span></span><br><span class="line"><span class="comment"> * already disabled (which is the case for bulk allocation).</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="type">static</span> <span class="type">void</span> *___slab_alloc(<span class="keyword">struct</span> kmem_cache *s, <span class="type">gfp_t</span> gfpflags, <span class="type">int</span> node,</span><br><span class="line">              <span class="type">unsigned</span> <span class="type">long</span> addr, <span class="keyword">struct</span> kmem_cache_cpu *c)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">void</span> *freelist;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">page</span> *<span class="title">page</span>;</span></span><br><span class="line">    page = c-&gt;page;</span><br><span class="line">    <span class="keyword">if</span> (!page)</span><br><span class="line">        <span class="keyword">goto</span> new_slab;</span><br><span class="line">redo:</span><br><span class="line">    <span class="keyword">if</span> (unlikely(!node_match(page, node))) &#123;</span><br><span class="line">        <span class="type">int</span> searchnode = node;</span><br><span class="line">        <span class="keyword">if</span> (node != NUMA_NO_NODE &amp;&amp; !node_present_pages(node))</span><br><span class="line">            searchnode = node_to_mem_node(node);</span><br><span class="line">        <span class="keyword">if</span> (unlikely(!node_match(page, searchnode))) &#123;</span><br><span class="line">            stat(s, ALLOC_NODE_MISMATCH);</span><br><span class="line">            deactivate_slab(s, page, c-&gt;freelist, c);</span><br><span class="line">            <span class="keyword">goto</span> new_slab;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">     * By rights, we should be searching for a slab page that was</span></span><br><span class="line"><span class="comment">     * PFMEMALLOC but right now, we are losing the pfmemalloc</span></span><br><span class="line"><span class="comment">     * information when the page leaves the per-cpu allocator</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">if</span> (unlikely(!pfmemalloc_match(page, gfpflags))) &#123;</span><br><span class="line">        deactivate_slab(s, page, c-&gt;freelist, c);</span><br><span class="line">        <span class="keyword">goto</span> new_slab;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">/* must check again c-&gt;freelist in case of cpu migration or IRQ */</span></span><br><span class="line">    freelist = c-&gt;freelist;</span><br><span class="line">    <span class="keyword">if</span> (freelist)</span><br><span class="line">        <span class="keyword">goto</span> load_freelist;</span><br><span class="line">    freelist = get_freelist(s, page);</span><br><span class="line">    <span class="keyword">if</span> (!freelist) &#123;</span><br><span class="line">        c-&gt;page = <span class="literal">NULL</span>;</span><br><span class="line">        stat(s, DEACTIVATE_BYPASS);</span><br><span class="line">        <span class="keyword">goto</span> new_slab;</span><br><span class="line">    &#125;</span><br><span class="line">    stat(s, ALLOC_REFILL);</span><br><span class="line">load_freelist:</span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">     * freelist is pointing to the list of objects to be used.</span></span><br><span class="line"><span class="comment">     * page is pointing to the page from which the objects are obtained.</span></span><br><span class="line"><span class="comment">     * That page must be frozen for per cpu allocations to work.</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    VM_BUG_ON(!c-&gt;page-&gt;frozen);</span><br><span class="line">    c-&gt;freelist = get_freepointer(s, freelist);</span><br><span class="line">    c-&gt;tid = next_tid(c-&gt;tid);</span><br><span class="line">    <span class="keyword">return</span> freelist;</span><br><span class="line">new_slab:</span><br><span class="line">    <span class="keyword">if</span> (slub_percpu_partial(c)) &#123;</span><br><span class="line">        page = c-&gt;page = slub_percpu_partial(c);</span><br><span class="line">        slub_set_percpu_partial(c, page);</span><br><span class="line">        stat(s, CPU_PARTIAL_ALLOC);</span><br><span class="line">        <span class="keyword">goto</span> redo;</span><br><span class="line">    &#125;</span><br><span class="line">    freelist = new_slab_objects(s, gfpflags, node, &amp;c);</span><br><span class="line">    <span class="keyword">if</span> (unlikely(!freelist)) &#123;</span><br><span class="line">        slab_out_of_memory(s, gfpflags, node);</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    page = c-&gt;page;</span><br><span class="line">    <span class="keyword">if</span> (likely(!kmem_cache_debug(s) &amp;&amp; pfmemalloc_match(page, gfpflags)))</span><br><span class="line">        <span class="keyword">goto</span> load_freelist;</span><br><span class="line">    <span class="comment">/* Only entered in the debug case */</span></span><br><span class="line">    <span class="keyword">if</span> (kmem_cache_debug(s) &amp;&amp;</span><br><span class="line">            !alloc_debug_processing(s, page, freelist, addr))</span><br><span class="line">        <span class="keyword">goto</span> new_slab;	<span class="comment">/* Slab failed checks. Next slab needed */</span></span><br><span class="line">    deactivate_slab(s, page, get_freepointer(s, freelist), c);</span><br><span class="line">    <span class="keyword">return</span> freelist;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>  new_slab_objects()函数逻辑如下</p>
<ul>
<li>调用get_partial()函数，根据node找到对应的kmem_cache_node然后调用get_partial_node()分配内存块。实际分配通过acquire_slab()函数完成，该函数会分配完成返回内存块指针并保存在freelist中，从 kmem_cache_node 的 partial 链表中拿下一大块内存来，并且将 freelist，也就是第一块空闲的缓存块赋值给 t。并且当第一轮循环的时候，将 kmem_cache_cpu 的 page 指向取下来的这一大块内存，返回的 object 就是这块内存里面的第一个缓存块 t。如果 kmem_cache_cpu 也有一个 partial，就会进行第二轮，再次取下一大块内存来，这次调用 put_cpu_partial()，放到 kmem_cache_cpu 的 partial 里面。如果 kmem_cache_node 里面也没有空闲的内存，这就说明原来分配的页里面都放满了，执行下一步。</li>
<li>调用new_slab()函数，向伙伴系统请求2^order个page，将请求的page构建成一个slab。分配的时候，要按 kmem_cache_order_objects 里面的 order 来。如果第一次分配不成功，说明内存已经很紧张了，那就换成 min 版本的 kmem_cache_order_objects。其调用链为new_slab()-&gt;allocate_slab()-&gt;alloc_slab_page()-&gt;__alloc_pages_node()-&gt;__alloc_pages()-&gt;__alloc_pages_nodemask()，从这里回到了伙伴系统，可见上文对该函数的分析。</li>
</ul>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">static</span> <span class="keyword">inline</span> <span class="type">void</span> *<span class="title function_">new_slab_objects</span><span class="params">(<span class="keyword">struct</span> kmem_cache *s, <span class="type">gfp_t</span> flags,</span></span><br><span class="line"><span class="params">            <span class="type">int</span> node, <span class="keyword">struct</span> kmem_cache_cpu **pc)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">void</span> *freelist;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">kmem_cache_cpu</span> *<span class="title">c</span> =</span> *pc;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">page</span> *<span class="title">page</span>;</span></span><br><span class="line">    WARN_ON_ONCE(s-&gt;ctor &amp;&amp; (flags &amp; __GFP_ZERO));</span><br><span class="line">    freelist = get_partial(s, flags, node, c);</span><br><span class="line">    <span class="keyword">if</span> (freelist)</span><br><span class="line">        <span class="keyword">return</span> freelist;</span><br><span class="line">    page = new_slab(s, flags, node);</span><br><span class="line">    <span class="keyword">if</span> (page) &#123;</span><br><span class="line">        c = raw_cpu_ptr(s-&gt;cpu_slab);</span><br><span class="line">        <span class="keyword">if</span> (c-&gt;page)</span><br><span class="line">            flush_slab(s, c);</span><br><span class="line">        <span class="comment">/*</span></span><br><span class="line"><span class="comment">         * No other reference to the page yet so we can</span></span><br><span class="line"><span class="comment">         * muck around with it freely without cmpxchg</span></span><br><span class="line"><span class="comment">         */</span></span><br><span class="line">        freelist = page-&gt;freelist;</span><br><span class="line">        page-&gt;freelist = <span class="literal">NULL</span>;</span><br><span class="line">        stat(s, ALLOC_SLAB);</span><br><span class="line">        c-&gt;page = page;</span><br><span class="line">        *pc = c;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> freelist;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>  至此，页的分配就介绍完了。简单概括就是伙伴系统将多个连续页面整合为页块以供大规模使用，slub allocator将从伙伴系统申请的大块切成小块，放在缓存，并分配给其他系统。物理内存分页之后，通过page_address()-&gt;lowmem_page_address()-&gt;page_to_virt()调用链转化为虚拟地址以使用。</p>
<h2 id="五-内核页表"><a href="#五-内核页表" class="headerlink" title="五. 内核页表"></a>五. 内核页表</h2><p>  内核态的页表在系统初始化的时候就需要创建，而非可以等到用的时候再创建页并映射。在 arch&#x2F;x86&#x2F;include&#x2F;asm&#x2F;pgtable_64.h有如下定义</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">extern</span> <span class="type">p4d_t</span> level4_kernel_pgt[<span class="number">512</span>];</span><br><span class="line"><span class="keyword">extern</span> <span class="type">p4d_t</span> level4_ident_pgt[<span class="number">512</span>];</span><br><span class="line"><span class="keyword">extern</span> <span class="type">pud_t</span> level3_kernel_pgt[<span class="number">512</span>];</span><br><span class="line"><span class="keyword">extern</span> <span class="type">pud_t</span> level3_ident_pgt[<span class="number">512</span>];</span><br><span class="line"><span class="keyword">extern</span> <span class="type">pmd_t</span> level2_kernel_pgt[<span class="number">512</span>];</span><br><span class="line"><span class="keyword">extern</span> <span class="type">pmd_t</span> level2_fixmap_pgt[<span class="number">512</span>];</span><br><span class="line"><span class="keyword">extern</span> <span class="type">pmd_t</span> level2_ident_pgt[<span class="number">512</span>];</span><br><span class="line"><span class="keyword">extern</span> <span class="type">pte_t</span> level1_fixmap_pgt[<span class="number">512</span> * FIXMAP_PMD_NUM];</span><br><span class="line"><span class="keyword">extern</span> <span class="type">pgd_t</span> init_top_pgt[];</span><br><span class="line"><span class="meta">#<span class="keyword">define</span> swapper_pg_dir init_top_pgt</span></span><br></pre></td></tr></table></figure>
<p>  其中swapper_pg_dir 指向内核最顶级的目录 pgd，同时出现的还有几个页表目录，其中 XXX_ident_pgt 对应的是直接映射区，XXX_kernel_pgt 对应的是内核代码区，XXX_fixmap_pgt 对应的是固定映射区。</p>
<p>  初始化的位置位于arch\x86\kernel\head_64.S，以全局变量的方式保存。这里quad 表示声明了一项的内容，org表示跳到了某个位置。</p>
<p>  init_top_pgt是内核页的顶级目录，首先将其指向level3_ident_pgt，即直接映射区页表的三级目录。前文中有说过直接映射区物理内存和虚拟内存通过减去偏移量实现，即__START_KERNEL_map，虚拟地址空间的内核代码段的起始地址。通过这种方式，我们得到了其对应的物理地址。接着我们通过PGD_PAGE_OFFSET偏移量和PGD_START_KERNEL偏移量进行两次跳转，其中PGD_PAGE_OFFSET对应__PAGE_OFFSET_BASE，即虚拟地址空间里面内核的起始地址。第二项则指向__START_KERNEL_map，即虚拟地址空间里面内核代码段的起始地址。其他代码也是同理，最终形成如下表所示的整个页表项的初始化工作。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br></pre></td><td class="code"><pre><span class="line">__INITDATA</span><br><span class="line"></span><br><span class="line"><span class="title function_">NEXT_PAGE</span><span class="params">(init_top_pgt)</span></span><br><span class="line">  .quad   level3_ident_pgt - __START_KERNEL_map + _KERNPG_TABLE</span><br><span class="line">  .org    init_top_pgt + PGD_PAGE_OFFSET*8, 0</span><br><span class="line">  .quad   level3_ident_pgt - __START_KERNEL_map + _KERNPG_TABLE</span><br><span class="line">  .org    init_top_pgt + PGD_START_KERNEL*8, 0</span><br><span class="line">  <span class="comment">/* (2^48-(2*1024*1024*1024))/(2^39) = 511 */</span></span><br><span class="line">  .quad   level3_kernel_pgt - __START_KERNEL_map + _PAGE_TABLE</span><br><span class="line"></span><br><span class="line"><span class="title function_">NEXT_PAGE</span><span class="params">(level3_ident_pgt)</span></span><br><span class="line">  .quad  level2_ident_pgt - __START_KERNEL_map + _KERNPG_TABLE</span><br><span class="line">  .fill  511, 8, 0</span><br><span class="line"><span class="title function_">NEXT_PAGE</span><span class="params">(level2_ident_pgt)</span></span><br><span class="line">  <span class="comment">/* Since I easily can, map the first 1G.</span></span><br><span class="line"><span class="comment">   * Don&#x27;t set NX because code runs from these pages.</span></span><br><span class="line"><span class="comment">   */</span></span><br><span class="line">  <span class="title function_">PMDS</span><span class="params">(<span class="number">0</span>, __PAGE_KERNEL_IDENT_LARGE_EXEC, PTRS_PER_PMD)</span></span><br><span class="line"></span><br><span class="line"><span class="title function_">NEXT_PAGE</span><span class="params">(level3_kernel_pgt)</span></span><br><span class="line">  .fill  L3_START_KERNEL,8,0</span><br><span class="line">  <span class="comment">/* (2^48-(2*1024*1024*1024)-((2^39)*511))/(2^30) = 510 */</span></span><br><span class="line">  .quad  level2_kernel_pgt - __START_KERNEL_map + _KERNPG_TABLE</span><br><span class="line">  .quad  level2_fixmap_pgt - __START_KERNEL_map + _PAGE_TABLE</span><br><span class="line"></span><br><span class="line"><span class="title function_">NEXT_PAGE</span><span class="params">(level2_kernel_pgt)</span></span><br><span class="line">  <span class="comment">/*</span></span><br><span class="line"><span class="comment">   * 512 MB kernel mapping. We spend a full page on this pagetable</span></span><br><span class="line"><span class="comment">   * anyway.</span></span><br><span class="line"><span class="comment">   *</span></span><br><span class="line"><span class="comment">   * The kernel code+data+bss must not be bigger than that.</span></span><br><span class="line"><span class="comment">   *</span></span><br><span class="line"><span class="comment">   * (<span class="doctag">NOTE:</span> at +512MB starts the module area, see MODULES_VADDR.</span></span><br><span class="line"><span class="comment">   *  If you want to increase this then increase MODULES_VADDR</span></span><br><span class="line"><span class="comment">   *  too.)</span></span><br><span class="line"><span class="comment">   */</span></span><br><span class="line">  <span class="title function_">PMDS</span><span class="params">(<span class="number">0</span>, __PAGE_KERNEL_LARGE_EXEC,</span></span><br><span class="line"><span class="params">    KERNEL_IMAGE_SIZE/PMD_SIZE)</span></span><br><span class="line"></span><br><span class="line"><span class="title function_">NEXT_PAGE</span><span class="params">(level2_fixmap_pgt)</span></span><br><span class="line">  .fill  506,8,0</span><br><span class="line">  .quad  level1_fixmap_pgt - __START_KERNEL_map + _PAGE_TABLE</span><br><span class="line">  <span class="comment">/* 8MB reserved for vsyscalls + a 2MB hole = 4 + 1 entries */</span></span><br><span class="line">  .fill  5,8,0</span><br><span class="line"></span><br><span class="line"><span class="title function_">NEXT_PAGE</span><span class="params">(level1_fixmap_pgt)</span></span><br><span class="line">  .fill  51</span><br><span class="line">  </span><br><span class="line">PGD_PAGE_OFFSET = pgd_index(__PAGE_OFFSET_BASE)</span><br><span class="line">PGD_START_KERNEL = pgd_index(__START_KERNEL_map)</span><br><span class="line">L3_START_KERNEL = pud_index(__START_KERNEL_map)</span><br></pre></td></tr></table></figure>

<p><img class="lazy" src="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII=" data-src="https://user-images.githubusercontent.com/87457873/128138240-53ab750c-c854-4dfa-9575-152c5f82e8a7.png" alt="image"></p>
<p>内核页表定义完了，一开始这里面的页表能够覆盖的内存范围比较小。例如内核代码区 512M，直接映射区 1G。这个时候，其实只要能够映射基本的内核代码和数据结构就可以了。可以看出里面还空着很多项，可以用于将来映射巨大的内核虚拟地址空间，等用到的时候再进行映射。如果是用户态进程页表，会有 mm_struct 指向进程顶级目录 pgd，对于内核来讲，也定义了一个 mm_struct，指向 swapper_pg_dir。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">mm_struct</span> <span class="title">init_mm</span> =</span> &#123;</span><br><span class="line">    .mm_rb    = RB_ROOT,</span><br><span class="line">    .pgd    = swapper_pg_dir,</span><br><span class="line">    .mm_users  = ATOMIC_INIT(<span class="number">2</span>),</span><br><span class="line">    .mm_count  = ATOMIC_INIT(<span class="number">1</span>),</span><br><span class="line">    .mmap_sem  = __RWSEM_INITIALIZER(init_mm.mmap_sem),</span><br><span class="line">    .page_table_lock =  __SPIN_LOCK_UNLOCKED(init_mm.page_table_lock),</span><br><span class="line">    .mmlist    = LIST_HEAD_INIT(init_mm.mmlist),</span><br><span class="line">    .user_ns  = &amp;init_user_ns,</span><br><span class="line">    INIT_MM_CONTEXT(init_mm)</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>  内核页表的初始化工作会在系统启动时，start_kernel()通过调用setup_arch()完成。load_cr3(swapper_pg_dir) 说明内核页表要开始起作用了，并且刷新了 TLB，初始化 init_mm 的成员变量，最重要的就是 init_mem_mapping()，通过调用链init_mem_mapping()-&gt;init_memory_mapping()-&gt;kernel_physical_mapping_init()最终通过 __va 将物理地址转换为虚拟地址，然后再创建虚拟地址和物理地址的映射页表。__va和__pa本身可以直接完成物理地址和虚拟地址的转换，但是CPU在保护模式下访问虚拟地址需要通过CR3寄存器，因此必须完成该映射页表的创建工作。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span> __init <span class="title function_">setup_arch</span><span class="params">(<span class="type">char</span> **cmdline_p)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">     * copy kernel address range established so far and switch</span></span><br><span class="line"><span class="comment">     * to the proper swapper page table</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    clone_pgd_range(swapper_pg_dir     + KERNEL_PGD_BOUNDARY,</span><br><span class="line">        initial_page_table + KERNEL_PGD_BOUNDARY,</span><br><span class="line">        KERNEL_PGD_PTRS);</span><br><span class="line"></span><br><span class="line">    load_cr3(swapper_pg_dir);</span><br><span class="line">    __flush_tlb_all();</span><br><span class="line">......</span><br><span class="line">    init_mm.start_code = (<span class="type">unsigned</span> <span class="type">long</span>) _text;</span><br><span class="line">    init_mm.end_code = (<span class="type">unsigned</span> <span class="type">long</span>) _etext;</span><br><span class="line">    init_mm.end_data = (<span class="type">unsigned</span> <span class="type">long</span>) _edata;</span><br><span class="line">    init_mm.brk = _brk_end;</span><br><span class="line">......</span><br><span class="line">    init_mem_mapping();</span><br><span class="line">......</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="六-页面交换"><a href="#六-页面交换" class="headerlink" title="六. 页面交换"></a>六. 页面交换</h2><p>  由于虚拟内存是远大于物理内存的，在物理内存中加载所有的虚拟内存页显然是异想天开，因此我们必须要有页面的交换。和CPU调度相似，页的交换也包括主动的交换和被动的交换。</p>
<ul>
<li><p>被动页面回收：当分配内存的时候发现物理内存不够用了，则尝试回收。如申请页面会调用get_page_from_freelist()，该函数会通过调用链get_page_from_freelist()-&gt;node_reclaim()-&gt;__node_reclaim()-&gt;shrink_node()尝试是否可以对当前的内存节点执行换出操作，从而腾出空</p>
</li>
<li><p>主动页面管理：在内核中，内核线程kswapd0即负责该部分的功能。下面详细展开分析一下该部分功能。</p>
<p>为了衡量内存的使用情况，kswapd0 定义了三个内存阈值（watermark，也称为水位），分别是页最小阈值（pages_min）、页低阈值（pages_low）和页高阈值（pages_high）。剩余内存，则使用 pages_free 表示。</p>
</li>
</ul>
<p><img class="lazy" src="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII=" data-src="https://user-images.githubusercontent.com/87457873/128138262-402a29f4-5e94-459e-95b8-1af3d8dce0f6.png" alt="image"></p>
<p>kswapd0 定期扫描内存的使用情况，并根据剩余内存落在这三个阈值的空间位置，进行内存的回收操作。</p>
<ul>
<li><p>剩余内存小于页最小阈值，说明进程可用内存都耗尽了，只有内核才可以分配内存。</p>
</li>
<li><p>剩余内存落在页最小阈值和页低阈值中间，说明内存压力比较大，剩余内存不多了。这时 kswapd0 会执行内存回收，直到剩余内存大于高阈值为止。</p>
</li>
<li><p>剩余内存落在页低阈值和页高阈值中间，说明内存有一定压力，但还可以满足新内存请求。</p>
</li>
<li><p>剩余内存大于页高阈值，说明剩余内存比较多，没有内存压力。</p>
<p>一旦剩余内存小于页低阈值，就会触发内存的回收。这个页低阈值，其实可以通过内核选项 &#x2F;proc&#x2F;sys&#x2F;vm&#x2F;min_free_kbytes 来间接设置。min_free_kbytes 设置了页最小阈值，而其他两个阈值，都是根据页最小阈值计算生成的，计算方法如下 ：</p>
</li>
</ul>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">pages_low = pages_min*<span class="number">5</span>/<span class="number">4</span></span><br><span class="line">pages_high = pages_min*<span class="number">3</span>/<span class="number">2</span></span><br></pre></td></tr></table></figure>
<p>  如下所示为kswapd()源码，核心调用链为balance_pgdat()-&gt;kswapd_shrink_node()-&gt;shrink_node()，所以被动回收和主动管理最后殊途同归，回到了同样的函数shrink_node()。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * The background pageout daemon, started as a kernel thread</span></span><br><span class="line"><span class="comment"> * from the init process.</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * This basically trickles out pages so that we have _some_</span></span><br><span class="line"><span class="comment"> * free memory available even if there is no other activity</span></span><br><span class="line"><span class="comment"> * that frees anything up. This is needed for things like routing</span></span><br><span class="line"><span class="comment"> * etc, where we otherwise might have all activity going on in</span></span><br><span class="line"><span class="comment"> * asynchronous contexts that cannot page things out.</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * If there are applications that are active memory-allocators</span></span><br><span class="line"><span class="comment"> * (most normal use), this basically shouldn&#x27;t matter.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="type">static</span> <span class="type">int</span> <span class="title function_">kswapd</span><span class="params">(<span class="type">void</span> *p)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">unsigned</span> <span class="type">int</span> alloc_order, reclaim_order;</span><br><span class="line">    <span class="type">unsigned</span> <span class="type">int</span> classzone_idx = MAX_NR_ZONES - <span class="number">1</span>;</span><br><span class="line">    <span class="type">pg_data_t</span> *pgdat = (<span class="type">pg_data_t</span>*)p;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">task_struct</span> *<span class="title">tsk</span> =</span> current;</span><br><span class="line">......</span><br><span class="line">    <span class="keyword">for</span> ( ; ; ) &#123;</span><br><span class="line">......</span><br><span class="line">kswapd_try_sleep:</span><br><span class="line">        kswapd_try_to_sleep(pgdat, alloc_order, reclaim_order,</span><br><span class="line">                    classzone_idx);</span><br><span class="line">......</span><br><span class="line">        <span class="comment">/*</span></span><br><span class="line"><span class="comment">         * Reclaim begins at the requested order but if a high-order</span></span><br><span class="line"><span class="comment">         * reclaim fails then kswapd falls back to reclaiming for</span></span><br><span class="line"><span class="comment">         * order-0. If that happens, kswapd will consider sleeping</span></span><br><span class="line"><span class="comment">         * for the order it finished reclaiming at (reclaim_order)</span></span><br><span class="line"><span class="comment">         * but kcompactd is woken to compact for the original</span></span><br><span class="line"><span class="comment">         * request (alloc_order).</span></span><br><span class="line"><span class="comment">         */</span></span><br><span class="line">        trace_mm_vmscan_kswapd_wake(pgdat-&gt;node_id, classzone_idx,</span><br><span class="line">                        alloc_order);</span><br><span class="line">        reclaim_order = balance_pgdat(pgdat, alloc_order, classzone_idx);</span><br><span class="line">......</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>  shrink_node()实际调用shrink_node_memcg()。这里面有个 LRU 列表，所有的页面都被挂在 LRU 列表中。LRU 也就是最近最少使用。这个列表里面会按照活跃程度进行排序，这样就容易把不怎么用的内存页拿出来做处理。内存页总共分两类，一类是匿名页，和虚拟地址空间进行关联；一类是内存映射，不但和虚拟地址空间关联，还和文件管理关联。它们每一类都有两个列表，一个是 active，一个是 inactive。顾名思义，active 就是比较活跃的，inactive 就是不怎么活跃的。这两个里面的页会变化，过一段时间，活跃的可能变为不活跃，不活跃的可能变为活跃。如果要换出内存，那就是从不活跃的列表中找出最不活跃的，换出到硬盘上。</p>
<p>  shrink_list() 会先缩减活跃页面列表，再压缩不活跃的页面列表。对于不活跃列表的缩减，shrink_inactive_list() 就需要对页面进行回收；对于匿名页来讲，需要分配 swap()，将内存页写入文件系统；对于内存映射关联了文件的，我们需要将在内存中对于文件的修改写回到文件中。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * This is a basic per-node page freer.  Used by both kswapd and direct reclaim.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="type">static</span> <span class="type">void</span> <span class="title function_">shrink_node_memcg</span><span class="params">(<span class="keyword">struct</span> pglist_data *pgdat, <span class="keyword">struct</span> mem_cgroup *memcg,</span></span><br><span class="line"><span class="params">                  <span class="keyword">struct</span> scan_control *sc, <span class="type">unsigned</span> <span class="type">long</span> *lru_pages)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">lruvec</span> *<span class="title">lruvec</span> =</span> mem_cgroup_lruvec(pgdat, memcg);</span><br><span class="line">    <span class="type">unsigned</span> <span class="type">long</span> nr[NR_LRU_LISTS];</span><br><span class="line">    <span class="type">unsigned</span> <span class="type">long</span> targets[NR_LRU_LISTS];</span><br><span class="line">    <span class="type">unsigned</span> <span class="type">long</span> nr_to_scan;</span><br><span class="line">    <span class="class"><span class="keyword">enum</span> <span class="title">lru_list</span> <span class="title">lru</span>;</span></span><br><span class="line">......</span><br><span class="line">    <span class="keyword">while</span> (nr[LRU_INACTIVE_ANON] || nr[LRU_ACTIVE_FILE] ||</span><br><span class="line">                    nr[LRU_INACTIVE_FILE]) &#123;</span><br><span class="line">        <span class="type">unsigned</span> <span class="type">long</span> nr_anon, nr_file, percentage;</span><br><span class="line">        <span class="type">unsigned</span> <span class="type">long</span> nr_scanned;</span><br><span class="line">        for_each_evictable_lru(lru) &#123;</span><br><span class="line">            <span class="keyword">if</span> (nr[lru]) &#123;</span><br><span class="line">                nr_to_scan = min(nr[lru], SWAP_CLUSTER_MAX);</span><br><span class="line">                nr[lru] -= nr_to_scan;</span><br><span class="line">                nr_reclaimed += shrink_list(lru, nr_to_scan,</span><br><span class="line">                                lruvec, memcg, sc);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">......</span><br><span class="line">&#125;</span><br><span class="line">    </span><br><span class="line"><span class="class"><span class="keyword">enum</span> <span class="title">lru_list</span> &#123;</span></span><br><span class="line">  LRU_INACTIVE_ANON = LRU_BASE,</span><br><span class="line">  LRU_ACTIVE_ANON = LRU_BASE + LRU_ACTIVE,</span><br><span class="line">  LRU_INACTIVE_FILE = LRU_BASE + LRU_FILE,</span><br><span class="line">  LRU_ACTIVE_FILE = LRU_BASE + LRU_FILE + LRU_ACTIVE,</span><br><span class="line">  LRU_UNEVICTABLE,</span><br><span class="line">  NR_LRU_LISTS</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> for_each_evictable_lru(lru) for (lru = 0; lru &lt;= LRU_ACTIVE_FILE; lru++)</span></span><br><span class="line"></span><br><span class="line"><span class="type">static</span> <span class="type">unsigned</span> <span class="type">long</span> <span class="title function_">shrink_list</span><span class="params">(<span class="keyword">enum</span> lru_list lru, <span class="type">unsigned</span> <span class="type">long</span> nr_to_scan,</span></span><br><span class="line"><span class="params">                 <span class="keyword">struct</span> lruvec *lruvec, <span class="keyword">struct</span> mem_cgroup *memcg,</span></span><br><span class="line"><span class="params">                 <span class="keyword">struct</span> scan_control *sc)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">if</span> (is_active_lru(lru)) &#123;</span><br><span class="line">        <span class="keyword">if</span> (inactive_list_is_low(lruvec, is_file_lru(lru),</span><br><span class="line">                     memcg, sc, <span class="literal">true</span>))</span><br><span class="line">            shrink_active_list(nr_to_scan, lruvec, sc, lru);</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> shrink_inactive_list(nr_to_scan, lruvec, sc, lru);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="七-总结"><a href="#七-总结" class="headerlink" title="七. 总结"></a>七. 总结</h2><p>  内存管理可谓非常复杂，本文较为详尽的介绍了内存管理中分页和页的分配相关内容，下文将继续介绍物理内存和虚拟内存的映射。</p>

<div class="article-footer fs14">
    <section id="license">
      <div class="header"><span>许可协议</span></div>
      <div class="body"><p>本文采用 <a target="_blank" rel="noopener" href="https://creativecommons.org/licenses/by-nc-sa/4.0/">署名-非商业性使用-相同方式共享 4.0 国际</a> 许可协议，转载请注明出处。</p>
</div>
    </section>
    </div>
</article>
<div class="related-wrap" id="read-next"><section class="body"><div class="item" id="prev"><div class="note">较新文章</div><a href="/2024/04/05/linux-docs/%E5%86%85%E5%AD%98%E7%AE%A1%E7%90%86/%E5%86%85%E5%AD%98%E7%9A%84%E5%8A%A8%E6%80%81%E7%94%B3%E8%AF%B7%E5%92%8C%E9%87%8A%E6%94%BE/">2024-04-05</a></div><div class="item" id="next"><div class="note">较早文章</div><a href="/2024/04/05/linux-docs/%E5%86%85%E5%AD%98%E7%AE%A1%E7%90%86/%E5%A4%9A%E6%A0%B8%E5%BF%83Linux%E5%86%85%E6%A0%B8%E8%B7%AF%E5%BE%84%E4%BC%98%E5%8C%96%E7%9A%84%E4%B8%8D%E4%BA%8C%E6%B3%95%E9%97%A8%E4%B9%8B-slab%E4%B8%8E%E4%BC%99%E4%BC%B4%E7%B3%BB%E7%BB%9F/">2024-04-05</a></div></section></div>






<footer class="page-footer footnote"><hr><div class="text"><p>本站由 <a href="/">ysme</a> 使用 <a target="_blank" rel="noopener" href="https://github.com/xaoxuu/hexo-theme-stellar/tree/1.27.0">Stellar 1.27.0</a> 主题创建。<br>本博客所有文章除特别声明外，均采用 <a target="_blank" rel="noopener" href="https://creativecommons.org/licenses/by-nc-sa/4.0/">CC BY-NC-SA 4.0</a> 许可协议，转载请注明出处。</p>
</div></footer>
<div class="main-mask" onclick="sidebar.dismiss()"></div></div><aside class="l_right">
<div class="widgets">



<widget class="widget-wrapper toc" id="data-toc" collapse="false"><div class="widget-header dis-select"><span class="name">本文目录</span><a class="cap-action" onclick="sidebar.toggleTOC()" ><svg xmlns="http://www.w3.org/2000/svg" width="32" height="32" viewBox="0 0 24 24"><path fill="none" stroke="currentColor" stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M10 6h11m-11 6h11m-11 6h11M4 6h1v4m-1 0h2m0 8H4c0-1 2-2 2-3s-1-1.5-2-1"/></svg></a></div><div class="widget-body"><ol class="toc"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%B8%80-%E5%89%8D%E8%A8%80"><span class="toc-text">一. 前言</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%BA%8C-%E5%86%85%E5%AD%98%E6%A8%A1%E5%9E%8B"><span class="toc-text">二. 内存模型</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%B8%89-%E8%8A%82%E7%82%B9%E3%80%81%E5%8C%BA%E5%9F%9F%E5%92%8C%E9%A1%B5"><span class="toc-text">三. 节点、区域和页</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#3-1-%E8%8A%82%E7%82%B9"><span class="toc-text">3.1 节点</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#3-2-%E5%8C%BA%E5%9F%9F"><span class="toc-text">3.2 区域</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#3-3-%E9%A1%B5"><span class="toc-text">3.3 页</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%9B%9B-%E7%94%A8%E6%88%B7%E6%80%81%E9%A1%B5%E7%9A%84%E5%88%86%E9%85%8D"><span class="toc-text">四. 用户态页的分配</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#4-1-%E4%BC%99%E4%BC%B4%E7%B3%BB%E7%BB%9F"><span class="toc-text">4.1 伙伴系统</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#4-2-slub-allocator"><span class="toc-text">4.2 slub allocator</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%BA%94-%E5%86%85%E6%A0%B8%E9%A1%B5%E8%A1%A8"><span class="toc-text">五. 内核页表</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%85%AD-%E9%A1%B5%E9%9D%A2%E4%BA%A4%E6%8D%A2"><span class="toc-text">六. 页面交换</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%B8%83-%E6%80%BB%E7%BB%93"><span class="toc-text">七. 总结</span></a></li></ol></div><div class="widget-footer">

<a class="top" onclick="util.scrollTop()"><svg xmlns="http://www.w3.org/2000/svg" width="32" height="32" viewBox="0 0 24 24"><g fill="none" stroke="currentColor" stroke-width="1.5"><path d="M2 12c0-4.714 0-7.071 1.464-8.536C4.93 2 7.286 2 12 2c4.714 0 7.071 0 8.535 1.464C22 4.93 22 7.286 22 12c0 4.714 0 7.071-1.465 8.535C19.072 22 16.714 22 12 22s-7.071 0-8.536-1.465C2 19.072 2 16.714 2 12Z"/><path stroke-linecap="round" stroke-linejoin="round" d="m9 15.5l3-3l3 3m-6-4l3-3l3 3"/></g></svg><span>回到顶部</span></a></div></widget>
</div></aside><div class='float-panel blur'>
  <button type='button' style='display:none' class='laptop-only rightbar-toggle mobile' onclick='sidebar.rightbar()'>
    <svg xmlns="http://www.w3.org/2000/svg" width="32" height="32" viewBox="0 0 24 24"><path fill="none" stroke="currentColor" stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M10 6h11m-11 6h11m-11 6h11M4 6h1v4m-1 0h2m0 8H4c0-1 2-2 2-3s-1-1.5-2-1"/></svg>
  </button>
  <button type='button' style='display:none' class='mobile-only leftbar-toggle mobile' onclick='sidebar.leftbar()'>
    <svg xmlns="http://www.w3.org/2000/svg" width="32" height="32" viewBox="0 0 24 24"><g fill="none" stroke="currentColor" stroke-width="1.5"><path d="M2 11c0-3.771 0-5.657 1.172-6.828C4.343 3 6.229 3 10 3h4c3.771 0 5.657 0 6.828 1.172C22 5.343 22 7.229 22 11v2c0 3.771 0 5.657-1.172 6.828C19.657 21 17.771 21 14 21h-4c-3.771 0-5.657 0-6.828-1.172C2 18.657 2 16.771 2 13z"/><path id="sep" stroke-linecap="round" d="M5.5 10h6m-5 4h4m4.5 7V3"/></g></svg>
  </button>
</div>
</div><div class="scripts">
<script type="text/javascript">
  const ctx = {
    date_suffix: {
      just: `刚刚`,
      min: `分钟前`,
      hour: `小时前`,
      day: `天前`,
    },
    root : `/`,
  };

  // required plugins (only load if needs)
  if (`local_search`) {
    ctx.search = {};
    ctx.search.service = `local_search`;
    if (ctx.search.service == 'local_search') {
      let service_obj = Object.assign({}, `{"field":"all","path":"/search.json","content":true,"sort":"-date"}`);
      ctx.search[ctx.search.service] = service_obj;
    }
  }
  const def = {
    avatar: `https://gcore.jsdelivr.net/gh/cdn-x/placeholder@1.0.12/avatar/round/3442075.svg`,
    cover: `https://gcore.jsdelivr.net/gh/cdn-x/placeholder@1.0.12/cover/76b86c0226ffd.svg`,
  };
  const deps = {
    jquery: `https://cdn.bootcdn.net/ajax/libs/jquery/3.7.1/jquery.min.js`,
    marked: `https://cdn.bootcdn.net/ajax/libs/marked/4.0.18/marked.min.js`
  }
  

</script>

<script type="text/javascript">
  const utils = {
    // 懒加载 css https://github.com/filamentgroup/loadCSS
    css: (href, before, media, attributes) => {
      var doc = window.document;
      var ss = doc.createElement("link");
      var ref;
      if (before) {
        ref = before;
      } else {
        var refs = (doc.body || doc.getElementsByTagName("head")[0]).childNodes;
        ref = refs[refs.length - 1];
      }
      var sheets = doc.styleSheets;
      if (attributes) {
        for (var attributeName in attributes) {
          if (attributes.hasOwnProperty(attributeName)) {
            ss.setAttribute(attributeName, attributes[attributeName]);
          }
        }
      }
      ss.rel = "stylesheet";
      ss.href = href;
      ss.media = "only x";
      function ready(cb) {
        if (doc.body) {
          return cb();
        }
        setTimeout(function () {
          ready(cb);
        });
      }
      ready(function () {
        ref.parentNode.insertBefore(ss, before ? ref : ref.nextSibling);
      });
      var onloadcssdefined = function (cb) {
        var resolvedHref = ss.href;
        var i = sheets.length;
        while (i--) {
          if (sheets[i].href === resolvedHref) {
            return cb();
          }
        }
        setTimeout(function () {
          onloadcssdefined(cb);
        });
      };
      function loadCB() {
        if (ss.addEventListener) {
          ss.removeEventListener("load", loadCB);
        }
        ss.media = media || "all";
      }
      if (ss.addEventListener) {
        ss.addEventListener("load", loadCB);
      }
      ss.onloadcssdefined = onloadcssdefined;
      onloadcssdefined(loadCB);
      return ss;
    },

    js: (src, opt) => new Promise((resolve, reject) => {
      var script = document.createElement('script');
      if (src.startsWith('/')){
        src = ctx.root + src.substring(1);
      }
      script.src = src;
      if (opt) {
        for (let key of Object.keys(opt)) {
          script[key] = opt[key]
        }
      } else {
        // 默认异步，如果需要同步，第二个参数传入 {} 即可
        script.async = true
      }
      script.onerror = reject
      script.onload = script.onreadystatechange = function() {
        const loadState = this.readyState
        if (loadState && loadState !== 'loaded' && loadState !== 'complete') return
        script.onload = script.onreadystatechange = null
        resolve()
      }
      document.head.appendChild(script)
    }),

    jq: (fn) => {
      if (typeof jQuery === 'undefined') {
        utils.js(deps.jquery).then(fn)
      } else {
        fn()
      }
    },
    
    onLoading: (el) => {
      if (el) {
        $(el).append('<div class="loading-wrap"><svg xmlns="http://www.w3.org/2000/svg" width="2em" height="2em" preserveAspectRatio="xMidYMid meet" viewBox="0 0 24 24"><g fill="none" stroke="currentColor" stroke-linecap="round" stroke-width="2"><path stroke-dasharray="60" stroke-dashoffset="60" stroke-opacity=".3" d="M12 3C16.9706 3 21 7.02944 21 12C21 16.9706 16.9706 21 12 21C7.02944 21 3 16.9706 3 12C3 7.02944 7.02944 3 12 3Z"><animate fill="freeze" attributeName="stroke-dashoffset" dur="1.3s" values="60;0"/></path><path stroke-dasharray="15" stroke-dashoffset="15" d="M12 3C16.9706 3 21 7.02944 21 12"><animate fill="freeze" attributeName="stroke-dashoffset" dur="0.3s" values="15;0"/><animateTransform attributeName="transform" dur="1.5s" repeatCount="indefinite" type="rotate" values="0 12 12;360 12 12"/></path></g></svg></div>');
      }
    },
    onLoadSuccess: (el) => {
      if (el) {
        $(el).find('.loading-wrap').remove();
      }
    },
    onLoadFailure: (el) => {
      if (el) {
        $(el).find('.loading-wrap svg').remove();
        $(el).find('.loading-wrap').append('<svg xmlns="http://www.w3.org/2000/svg" width="2em" height="2em" preserveAspectRatio="xMidYMid meet" viewBox="0 0 24 24"><g fill="none" stroke="currentColor" stroke-linecap="round" stroke-linejoin="round" stroke-width="2"><path stroke-dasharray="60" stroke-dashoffset="60" d="M12 3L21 20H3L12 3Z"><animate fill="freeze" attributeName="stroke-dashoffset" dur="0.5s" values="60;0"/></path><path stroke-dasharray="6" stroke-dashoffset="6" d="M12 10V14"><animate fill="freeze" attributeName="stroke-dashoffset" begin="0.6s" dur="0.2s" values="6;0"/></path></g><circle cx="12" cy="17" r="1" fill="currentColor" fill-opacity="0"><animate fill="freeze" attributeName="fill-opacity" begin="0.8s" dur="0.4s" values="0;1"/></circle></svg>');
        $(el).find('.loading-wrap').addClass('error');
      }
    },
    request: (el, url, callback, onFailure) => {
      let retryTimes = 3;
      utils.onLoading(el);
      function req() {
        return new Promise((resolve, reject) => {
          let status = 0; // 0 等待 1 完成 2 超时
          let timer = setTimeout(() => {
            if (status === 0) {
              status = 2;
              timer = null;
              reject('请求超时');
              if (retryTimes == 0) {
                onFailure();
              }
            }
          }, 5000);
          fetch(url).then(function(response) {
            if (status !== 2) {
              clearTimeout(timer);
              resolve(response);
              timer = null;
              status = 1;
            }
            if (response.ok) {
              return response.json();
            }
            throw new Error('Network response was not ok.');
          }).then(function(data) {
            retryTimes = 0;
            utils.onLoadSuccess(el);
            callback(data);
          }).catch(function(error) {
            if (retryTimes > 0) {
              retryTimes -= 1;
              setTimeout(() => {
                req();
              }, 5000);
            } else {
              utils.onLoadFailure(el);
              onFailure();
            }
          });
        });
      }
      req();
    },
  };
</script>

<script>
  const sidebar = {
    leftbar: () => {
      if (l_body) {
        l_body.toggleAttribute('leftbar');
        l_body.removeAttribute('rightbar');
      }
    },
    rightbar: () => {
      if (l_body) {
        l_body.toggleAttribute('rightbar');
        l_body.removeAttribute('leftbar');
      }
    },
    dismiss: () => {
      if (l_body) {
        l_body.removeAttribute('leftbar');
        l_body.removeAttribute('rightbar');
      }
    },
    toggleTOC: () => {
      document.querySelector('#data-toc').classList.toggle('collapse');
    }
  }
</script>

<!-- required -->
<script src="/js/main.js?v=1.27.0" async></script>

<!-- optional -->



<script defer>
  window.addEventListener('DOMContentLoaded', (event) => {
    ctx.services = Object.assign({}, JSON.parse(`{"mdrender":{"js":"/js/services/mdrender.js"},"siteinfo":{"js":"/js/services/siteinfo.js","api":null},"ghinfo":{"js":"/js/services/ghinfo.js"},"sites":{"js":"/js/services/sites.js"},"friends":{"js":"/js/services/friends.js"},"timeline":{"js":"/js/services/timeline.js"},"fcircle":{"js":"/js/services/fcircle.js"},"weibo":{"js":"/js/services/weibo.js"},"memos":{"js":"/js/services/memos.js"}}`));
    for (let id of Object.keys(ctx.services)) {
      const js = ctx.services[id].js;
      if (id == 'siteinfo') {
        ctx.cardlinks = document.querySelectorAll('a.link-card[cardlink]');
        if (ctx.cardlinks?.length > 0) {
          utils.js(js, { defer: true }).then(function () {
            setCardLink(ctx.cardlinks);
          });
        }
      } else {
        const els = document.getElementsByClassName(`ds-${id}`);
        if (els?.length > 0) {
          utils.jq(() => {
            if (id == 'timeline' || 'memos' || 'marked') {
              utils.js(deps.marked).then(function () {
                utils.js(js, { defer: true });
              });
            } else {
              utils.js(js, { defer: true });
            }
          });
        }
      }
    }
  });
</script>

<script>
  window.addEventListener('DOMContentLoaded', (event) => {
    ctx.search = {
      path: `/search.json`,
    }
    utils.js('/js/search/local-search.js', { defer: true });
  });
</script><script>
  window.FPConfig = {
    delay: 0,
    ignoreKeywords: [],
    maxRPS: 5,
    hoverDelay: 25
  };
</script>
<script defer src="https://cdn.bootcdn.net/ajax/libs/flying-pages/2.1.2/flying-pages.min.js"></script><script defer src="https://cdn.bootcdn.net/ajax/libs/vanilla-lazyload/17.8.4/lazyload.min.js"></script>
<script>
  // https://www.npmjs.com/package/vanilla-lazyload
  // Set the options globally
  // to make LazyLoad self-initialize
  window.lazyLoadOptions = {
    elements_selector: ".lazy",
  };
  // Listen to the initialization event
  // and get the instance of LazyLoad
  window.addEventListener(
    "LazyLoad::Initialized",
    function (event) {
      window.lazyLoadInstance = event.detail.instance;
    },
    false
  );
  document.addEventListener('DOMContentLoaded', function () {
    window.lazyLoadInstance?.update();
  });
</script><script>
  ctx.fancybox = {
    selector: `.timenode p>img`,
    css: `https://cdn.bootcdn.net/ajax/libs/fancyapps-ui/5.0.22/fancybox/fancybox.min.css`,
    js: `https://cdn.bootcdn.net/ajax/libs/fancyapps-ui/5.0.22/fancybox/fancybox.umd.min.js`
  };
  var selector = '[data-fancybox]:not(.error)';
  if (ctx.fancybox.selector) {
    selector += `, ${ctx.fancybox.selector}`
  }
  var needFancybox = document.querySelectorAll(selector).length !== 0;
  if (!needFancybox) {
    const els = document.getElementsByClassName('ds-memos');
    if (els != undefined && els.length > 0) {
      needFancybox = true;
    }
  }
  if (needFancybox) {
    utils.css(ctx.fancybox.css);
    utils.js(ctx.fancybox.js, { defer: true }).then(function () {
      Fancybox.bind(selector, {
        hideScrollbar: false,
        Thumbs: {
          autoStart: false,
        },
        caption: (fancybox, slide) => {
          return slide.triggerEl.alt || null
        }
      });
    })
  }
</script><script>
  window.addEventListener('DOMContentLoaded', (event) => {
    const swiper_api = document.getElementById('swiper-api');
    if (swiper_api != undefined) {
      utils.css(`https://unpkg.com/swiper@10.3.1/swiper-bundle.min.css`);
      utils.js(`https://unpkg.com/swiper@10.3.1/swiper-bundle.min.js`, { defer: true }).then(function () {
        const effect = swiper_api.getAttribute('effect') || '';
        var swiper = new Swiper('.swiper#swiper-api', {
          slidesPerView: 'auto',
          spaceBetween: 8,
          centeredSlides: true,
          effect: effect,
          loop: true,
          pagination: {
            el: '.swiper-pagination',
            clickable: true,
          },
          navigation: {
            nextEl: '.swiper-button-next',
            prevEl: '.swiper-button-prev',
          },
        });
      })
    }
  });
</script><script>
  document.addEventListener('DOMContentLoaded', function () {
    window.codeElements = document.querySelectorAll('.code');
    if (window.codeElements.length > 0) {
      ctx.copycode = {
        default_text: `Copy`,
        success_text: `Copied`,
        toast: `复制成功`,
      };
      utils.js('/js/plugins/copycode.js');
    }
  });
</script>


<!-- inject -->

</div></body></html>
