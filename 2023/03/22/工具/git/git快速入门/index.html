<!DOCTYPE html><html lang="zh-CN" data-theme="light"><head><meta charset="UTF-8"><meta http-equiv="X-UA-Compatible" content="IE=edge"><meta name="viewport" content="width=device-width, initial-scale=1.0,viewport-fit=cover"><title>Git 快速入门指南 | Blog</title><meta name="author" content="ysme"><meta name="copyright" content="ysme"><meta name="format-detection" content="telephone=no"><meta name="theme-color" content="#ffffff"><meta name="description" content="列表 init add status diff show log difftool apply cherry-pick merge rebase commit reset stash worktree revert clone remote fetch pull push branch checkout restore tag rerere bisect blame clean ~和^  init">
<meta property="og:type" content="article">
<meta property="og:title" content="Git 快速入门指南">
<meta property="og:url" content="https://vcloud.ysme.top/2023/03/22/%E5%B7%A5%E5%85%B7/git/git%E5%BF%AB%E9%80%9F%E5%85%A5%E9%97%A8/index.html">
<meta property="og:site_name" content="Blog">
<meta property="og:description" content="列表 init add status diff show log difftool apply cherry-pick merge rebase commit reset stash worktree revert clone remote fetch pull push branch checkout restore tag rerere bisect blame clean ~和^  init">
<meta property="og:locale" content="zh_CN">
<meta property="og:image" content="https://randomimage.ysme.top/">
<meta property="article:published_time" content="2023-03-22T01:13:37.000Z">
<meta property="article:modified_time" content="2024-10-28T08:31:33.244Z">
<meta property="article:author" content="ysme">
<meta property="article:tag" content="Git 快速入门">
<meta name="twitter:card" content="summary">
<meta name="twitter:image" content="https://randomimage.ysme.top/"><link rel="shortcut icon" href="/img/favicon.png"><link rel="canonical" href="https://vcloud.ysme.top/2023/03/22/%E5%B7%A5%E5%85%B7/git/git%E5%BF%AB%E9%80%9F%E5%85%A5%E9%97%A8/index.html"><link rel="preconnect" href="//cdn.jsdelivr.net"/><link rel="preconnect" href="//busuanzi.ibruce.info"/><link rel="stylesheet" href="/css/index.css?v=4.13.0"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fortawesome/fontawesome-free@6.5.1/css/all.min.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fancyapps/ui@5.0.33/dist/fancybox/fancybox.min.css" media="print" onload="this.media='all'"><script>const GLOBAL_CONFIG = {
  root: '/',
  algolia: undefined,
  localSearch: {"path":"/search.xml","preload":false,"top_n_per_article":1,"unescape":false,"languages":{"hits_empty":"找不到您查询的内容：${query}","hits_stats":"共找到 ${hits} 篇文章"}},
  translate: undefined,
  noticeOutdate: undefined,
  highlight: {"plugin":"highlight.js","highlightCopy":true,"highlightLang":true,"highlightHeightLimit":200},
  copy: {
    success: '复制成功',
    error: '复制错误',
    noSupport: '浏览器不支持'
  },
  relativeDate: {
    homepage: false,
    post: false
  },
  runtime: '',
  dateSuffix: {
    just: '刚刚',
    min: '分钟前',
    hour: '小时前',
    day: '天前',
    month: '个月前'
  },
  copyright: undefined,
  lightbox: 'fancybox',
  Snackbar: undefined,
  infinitegrid: {
    js: 'https://cdn.jsdelivr.net/npm/@egjs/infinitegrid@4.11.1/dist/infinitegrid.min.js',
    buttonText: '加载更多'
  },
  isPhotoFigcaption: false,
  islazyload: false,
  isAnchor: false,
  percent: {
    toc: true,
    rightside: false,
  },
  autoDarkmode: false
}</script><script id="config-diff">var GLOBAL_CONFIG_SITE = {
  title: 'Git 快速入门指南',
  isPost: true,
  isHome: false,
  isHighlightShrink: false,
  isToc: true,
  postUpdate: '2024-10-28 16:31:33'
}</script><script>(win=>{
      win.saveToLocal = {
        set: (key, value, ttl) => {
          if (ttl === 0) return
          const now = Date.now()
          const expiry = now + ttl * 86400000
          const item = {
            value,
            expiry
          }
          localStorage.setItem(key, JSON.stringify(item))
        },
      
        get: key => {
          const itemStr = localStorage.getItem(key)
      
          if (!itemStr) {
            return undefined
          }
          const item = JSON.parse(itemStr)
          const now = Date.now()
      
          if (now > item.expiry) {
            localStorage.removeItem(key)
            return undefined
          }
          return item.value
        }
      }
    
      win.getScript = (url, attr = {}) => new Promise((resolve, reject) => {
        const script = document.createElement('script')
        script.src = url
        script.async = true
        script.onerror = reject
        script.onload = script.onreadystatechange = function() {
          const loadState = this.readyState
          if (loadState && loadState !== 'loaded' && loadState !== 'complete') return
          script.onload = script.onreadystatechange = null
          resolve()
        }

        Object.keys(attr).forEach(key => {
          script.setAttribute(key, attr[key])
        })

        document.head.appendChild(script)
      })
    
      win.getCSS = (url, id = false) => new Promise((resolve, reject) => {
        const link = document.createElement('link')
        link.rel = 'stylesheet'
        link.href = url
        if (id) link.id = id
        link.onerror = reject
        link.onload = link.onreadystatechange = function() {
          const loadState = this.readyState
          if (loadState && loadState !== 'loaded' && loadState !== 'complete') return
          link.onload = link.onreadystatechange = null
          resolve()
        }
        document.head.appendChild(link)
      })
    
      win.activateDarkMode = () => {
        document.documentElement.setAttribute('data-theme', 'dark')
        if (document.querySelector('meta[name="theme-color"]') !== null) {
          document.querySelector('meta[name="theme-color"]').setAttribute('content', '#0d0d0d')
        }
      }
      win.activateLightMode = () => {
        document.documentElement.setAttribute('data-theme', 'light')
        if (document.querySelector('meta[name="theme-color"]') !== null) {
          document.querySelector('meta[name="theme-color"]').setAttribute('content', '#ffffff')
        }
      }
      const t = saveToLocal.get('theme')
    
        if (t === 'dark') activateDarkMode()
        else if (t === 'light') activateLightMode()
      
      const asideStatus = saveToLocal.get('aside-status')
      if (asideStatus !== undefined) {
        if (asideStatus === 'hide') {
          document.documentElement.classList.add('hide-aside')
        } else {
          document.documentElement.classList.remove('hide-aside')
        }
      }
    
      const detectApple = () => {
        if(/iPad|iPhone|iPod|Macintosh/.test(navigator.userAgent)){
          document.documentElement.classList.add('apple')
        }
      }
      detectApple()
    })(window)</script><meta name="generator" content="Hexo 7.1.1"></head><body><div id="sidebar"><div id="menu-mask"></div><div id="sidebar-menus"><div class="avatar-img is-center"><img src="/img/avatar.jpg" onerror="onerror=null;src='/img/friend_404.gif'" alt="avatar"/></div><div class="sidebar-site-data site-data is-center"><a href="/archives/"><div class="headline">文章</div><div class="length-num">131</div></a><a href="/tags/"><div class="headline">标签</div><div class="length-num">5</div></a><a href="/categories/"><div class="headline">分类</div><div class="length-num">10</div></a></div><hr class="custom-hr"/><div class="menus_items"><div class="menus_item"><a class="site-page" href="/"><i class="fa-fw fas fa-home"></i><span> Home</span></a></div><div class="menus_item"><a class="site-page" href="/archives/"><i class="fa-fw fas fa-archive"></i><span> Archives</span></a></div><div class="menus_item"><a class="site-page" href="/tags/"><i class="fa-fw fas fa-tags"></i><span> Tags</span></a></div><div class="menus_item"><a class="site-page" href="/categories/"><i class="fa-fw fas fa-folder-open"></i><span> Categories</span></a></div><div class="menus_item"><a class="site-page group" href="javascript:void(0);"><i class="fa-fw fas fa-list"></i><span> List</span><i class="fas fa-chevron-down"></i></a><ul class="menus_item_child"><li><a class="site-page child" href="/music/"><i class="fa-fw fas fa-music"></i><span> Music</span></a></li><li><a class="site-page child" href="/movies/"><i class="fa-fw fas fa-video"></i><span> Movie</span></a></li></ul></div><div class="menus_item"><a class="site-page" href="/link/"><i class="fa-fw fas fa-link"></i><span> Link</span></a></div><div class="menus_item"><a class="site-page" href="/about/"><i class="fa-fw fas fa-heart"></i><span> About</span></a></div></div></div></div><div class="post" id="body-wrap"><header class="post-bg" id="page-header" style="background-image: url('https://randomimage.ysme.top/')"><nav id="nav"><span id="blog-info"><a href="/" title="Blog"><span class="site-name">Blog</span></a></span><div id="menus"><div id="search-button"><a class="site-page social-icon search" href="javascript:void(0);"><i class="fas fa-search fa-fw"></i><span> 搜索</span></a></div><div class="menus_items"><div class="menus_item"><a class="site-page" href="/"><i class="fa-fw fas fa-home"></i><span> Home</span></a></div><div class="menus_item"><a class="site-page" href="/archives/"><i class="fa-fw fas fa-archive"></i><span> Archives</span></a></div><div class="menus_item"><a class="site-page" href="/tags/"><i class="fa-fw fas fa-tags"></i><span> Tags</span></a></div><div class="menus_item"><a class="site-page" href="/categories/"><i class="fa-fw fas fa-folder-open"></i><span> Categories</span></a></div><div class="menus_item"><a class="site-page group" href="javascript:void(0);"><i class="fa-fw fas fa-list"></i><span> List</span><i class="fas fa-chevron-down"></i></a><ul class="menus_item_child"><li><a class="site-page child" href="/music/"><i class="fa-fw fas fa-music"></i><span> Music</span></a></li><li><a class="site-page child" href="/movies/"><i class="fa-fw fas fa-video"></i><span> Movie</span></a></li></ul></div><div class="menus_item"><a class="site-page" href="/link/"><i class="fa-fw fas fa-link"></i><span> Link</span></a></div><div class="menus_item"><a class="site-page" href="/about/"><i class="fa-fw fas fa-heart"></i><span> About</span></a></div></div><div id="toggle-menu"><a class="site-page" href="javascript:void(0);"><i class="fas fa-bars fa-fw"></i></a></div></div></nav><div id="post-info"><h1 class="post-title">Git 快速入门指南</h1><div id="post-meta"><div class="meta-firstline"><span class="post-meta-date"><i class="far fa-calendar-alt fa-fw post-meta-icon"></i><span class="post-meta-label">发表于</span><time class="post-meta-date-created" datetime="2023-03-22T01:13:37.000Z" title="发表于 2023-03-22 09:13:37">2023-03-22</time><span class="post-meta-separator">|</span><i class="fas fa-history fa-fw post-meta-icon"></i><span class="post-meta-label">更新于</span><time class="post-meta-date-updated" datetime="2024-10-28T08:31:33.244Z" title="更新于 2024-10-28 16:31:33">2024-10-28</time></span><span class="post-meta-categories"><span class="post-meta-separator">|</span><i class="fas fa-inbox fa-fw post-meta-icon"></i><a class="post-meta-categories" href="/categories/%E5%B7%A5%E5%85%B7/">工具</a><i class="fas fa-angle-right post-meta-separator"></i><i class="fas fa-inbox fa-fw post-meta-icon"></i><a class="post-meta-categories" href="/categories/%E5%B7%A5%E5%85%B7/Git/">Git</a></span></div><div class="meta-secondline"><span class="post-meta-separator">|</span><span class="post-meta-pv-cv" id="" data-flag-title="Git 快速入门指南"><i class="far fa-eye fa-fw post-meta-icon"></i><span class="post-meta-label">阅读量:</span><span id="busuanzi_value_page_pv"><i class="fa-solid fa-spinner fa-spin"></i></span></span></div></div></div></header><main class="layout" id="content-inner"><div id="post"><article class="post-content" id="article-container"><h4 id="列表"><a href="#列表" class="headerlink" title="列表"></a>列表</h4><ul>
<li><a href="#init">init</a></li>
<li><a href="#add">add</a></li>
<li><a href="#status">status</a></li>
<li><a href="#diff">diff</a></li>
<li><a href="#show">show</a></li>
<li><a href="#log">log</a></li>
<li><a href="#difftool">difftool</a></li>
<li><a href="#apply">apply</a></li>
<li><a href="#cherry-pick">cherry-pick</a></li>
<li><a href="#merge">merge</a></li>
<li><a href="#rebase">rebase</a></li>
<li><a href="#commit">commit</a></li>
<li><a href="#reset">reset</a></li>
<li><a href="#stash">stash</a></li>
<li><a href="#worktree">worktree</a></li>
<li><a href="#revert">revert</a></li>
<li><a href="#clone">clone</a></li>
<li><a href="#remote">remote</a></li>
<li><a href="#fetch">fetch</a></li>
<li><a href="#pull">pull</a></li>
<li><a href="#push">push</a></li>
<li><a href="#branch">branch</a></li>
<li><a href="#checkout">checkout</a></li>
<li><a href="#restore">restore</a></li>
<li><a href="#tag">tag</a></li>
<li><a href="#rerere">rerere</a></li>
<li><a href="#bisect">bisect</a></li>
<li><a href="#blame">blame</a></li>
<li><a href="#clean">clean</a></li>
<li><a href="#%E5%92%8C">~和^</a></li>
</ul>
<h2 id="init"><a href="#init" class="headerlink" title="init"></a>init</h2><p>创建一个空的Git仓库或重新<a target="_blank" rel="noopener" href="https://so.csdn.net/so/search?q=%E5%88%9D%E5%A7%8B%E5%8C%96&spm=1001.2101.3001.7020">初始化</a>已有仓库<br>该命令创建一个空的Git存储库 - 本质上是一个 .git 目录，其中包含 objects、<a target="_blank" rel="noopener" href="https://so.csdn.net/so/search?q=refs&spm=1001.2101.3001.7020">refs</a>&#x2F;heads、refs&#x2F;tags 和模板文件的子目录。将创建一个没有任何提交的初始分支，还将创建一个引用master分支 HEAD 的初始 HEAD 文件。<br>如果设置了 $GIT_DIR 环境变量，则会指定一个路径，而不是 .&#x2F;.git 作为版本库的基础。<br>如果通过 $GIT_OBJECT_DIRECTORY 环境变量指定了对象存储目录，那么 sha1 目录就会在其下创建；否则，就会使用默认的 $GIT_DIR&#x2F;objects 目录。<br>在现有版本库中运行 git init 是安全的。它不会覆盖已有的内容。重新运行 git init 的主要原因是为了拾取新添加的模板（或者如果给定了 –separate-git-dir 则是为了将仓库移到另一个地方）。<br><code>--bare</code>创建裸仓库。如果未设置 GIT_DIR 环境，则将其设置为当前工作目录。<br><code>--object-format=&lt;format&gt;</code>指定存储库的对象格式（哈希算法）。有效值为 sha1 和（如果启用）sha256。sha1 是默认值。<br><code>--template=&lt;template-directory&gt;</code>指定要使用模板的目录，默认模板目录：&#x2F;usr&#x2F;share&#x2F;git-core&#x2F;templates。模板目录中名称不以点开头的文件和目录将在创建后复制到 $GIT_DIR 中。默认模板目录包括一些目录结构、建议的 “排除模式” 和示例钩子文件；默认情况下，所有示例钩子都是禁用的。要启用其中一个示例钩子，可移除其 .sample 后缀，重命名该示例钩子。<br><code>[-b &lt;branch-name&gt; | --initial-branch=&lt;branch-name&gt;]</code>在新创建的仓库中为初始分支指定名称。如果没有指定，则使用默认名称：master。</p>
<pre><code>git init /* 初始化目录的版本控制，当前目录创建一个名为.git的子目录 */
git init demo /* 指定目录完成创建 */
</code></pre>
<h2 id="add"><a href="#add" class="headerlink" title="add"></a>add</h2><p>该命令使用工作树中的当前内容更新索引，为下一次提交做好准备。它通常会将现有路径的当前内容作为一个整体添加到索引中，但也可以通过一些选项，在添加内容时只应用对工作树文件所做的部分修改，或删除工作树中已不存在的路径。<br><code>[--interactive | -i]</code>以交互方式将工作树中修改过的内容添加到索引中。可以提供可选的路径参数，将操作限制在工作树的子集。详情请参阅 “交互模式”。<br><code>[--patch | -p]</code>交互地在索引和工作树之间选择补丁块并将它们添加到索引中。这让用户有机会在将修改后的内容添加到索引之前查看差异。这实际上是运行 <code>add --interactive</code> 命令，但绕过了初始命令菜单，直接跳转到 patch 子命令。<br><code>[--update | -u]</code>只更新索引中已匹配 <code>&lt;pathspec&gt;</code> 的条目。这将删除和修改索引条目以匹配工作树，但不会添加新文件。如果使用 -u 选项时没有给出 <code>&lt;pathspec&gt;</code>，则会更新整个工作树中的所有跟踪文件（旧版本的 Git 将更新限制在当前目录及其子目录）。<br><code>[-A |--all |all | --no-ignore-removal]</code><br>不仅在工作树中有与 匹配的文件的地方更新索引，而且在索引中已有条目的地方也更新索引。这将添加、修改和删除索引条目，以匹配工作树。如果在使用 -A 选项时没有 ，则会更新整个工作树中的所有文件（旧版本的 Git 将更新限制在当前目录及其子目录）。<br><code>[--]</code>–此选项可用于分离命令行选项和文件列表（当文件名可能被误认为命令行选项时非常有用）。</p>
<pre><code>git add hello.c /* 将仓库中hello.c添加至暂存区 */
git add . /* 添加当前目录及其子目录下所有文件到暂存区 */
git add -u /* 所有修改，删除的文件加入暂存区 */
git add -A /* 本地修改，删除，新增文件都加入暂存区 */
</code></pre>
<h2 id="status"><a href="#status" class="headerlink" title="status"></a>status</h2><p>显示索引文件和当前 HEAD 提交之间存在差异的路径、工作树和索引文件之间存在差异的路径，以及工作树中未被 Git 跟踪（也未被 gitignore忽略）的路径。<br><code>[-s | --short]</code>以简短的形式给出输出。<br><code>--show-stash</code>显示当前藏匿的条目数量。<br><code>[-v | --verbose]</code>除了显示被修改的文件名外，还显示要已暂存将要提交的文本更改（即类似于 git diff –cached 的输出）。如果<code>-v</code>被指定了两次，那么还显示工作树中尚未暂存的更改（即类似 git diff 的输出）。</p>
<pre><code>git status /* 检查当前文件状态 */
git status -s  /* 简洁的方式查看文件状态 */
</code></pre>
<h2 id="diff"><a href="#diff" class="headerlink" title="diff"></a>diff</h2><p>显示工作树和索引或树之间的变化，索引和树之间的变化，两个树之间的变化，合并产生的变化，两个blob对象之间的变化，或者磁盘上两个文件之间的变化。<br><code>git diff [&lt;options&gt;] [--] [&lt;path&gt;…​]</code>该表单用于查看相对于索引（下一次提交的暂存区域）所做的更改。换句话说，这些差异就是你可以告诉 Git 进一步添加到索引中但尚未添加的内容。您可以使用 <code>git-add</code> 来暂存这些改动。<br><code>git diff [&lt;options&gt;] --cached [--merge-base] [&lt;commit&gt;] [--] [&lt;path&gt;…​]</code>此表单用于查看相对于命名的 <code>&lt;commit&gt;</code> 下次提交的暂存更改。通常情况下，您希望与最新提交进行比较，因此如果您没有给出 <code>&lt;commit&gt;</code>，它就会默认为 HEAD。如果 HEAD 不存在（例如未出生的分支），也没有给出 <code>&lt;commit&gt;</code>，则会显示所有已暂存的变更。<code>--staged</code> 是 <code>--cached</code> 的同义词。<br>如果给出 <code>--merge-base</code>，则不使用 <code>&lt;commit&gt;</code>，而使用 <code>&lt;commit&gt;</code> 和 HEAD 的合并基数。 <code>git diff --cached --merge-base A</code> 等同于 <code>git diff --cached $(git merge-base A HEAD)</code>。<br><code>git diff [&lt;options&gt;] [--merge-base] &lt;commit&gt; [--] [&lt;path&gt;…​]</code>这个表格是用来查看你的工作树中相对于命名为的修改。 您可以使用 HEAD 来与最新的提交进行比较，或者使用分支名称来与不同分支的顶端进行比较。<br>如果给出 <code>--merge-base</code>，则不使用 <code>&lt;commit&gt;</code>，而使用 <code>&lt;commit&gt;</code> 和 HEAD 的合并基数。 <code>git diff --cached --merge-base A</code> 等同于 <code>git diff --cached $(git merge-base A HEAD)</code>。<br><code>git diff [&lt;options&gt;] &lt;commit&gt;..&lt;commit&gt; [--] [&lt;path&gt;…​]</code>这与早先用于查看两个任意 之间的更改的形式（不带 …）是同义的。如果省略一侧的 ，其效果与使用 HEAD 相同。<br><code>git diff [&lt;options&gt;] &lt;blob&gt; &lt;blob&gt;</code>这种形式是为了查看两个blob对象的原始内容之间的差异。<br><code>-p | -u | --patch</code>生成补丁。 这是默认设置。<br><code>-s | --no-patch</code>抑制差异（diff）工具的所有输出。 对于默认显示补丁的 <code>git show</code> 等命令，可以压制其输出，或在别名中取消命令行中的 <code>--patch、--stat</code> 等选项的效果。<br><code>U&lt;n&gt; | --unified=&lt;n&gt;</code>生成带有 <code>&lt;n&gt;</code> 行上下文的差异，而不是通常的 <code>3</code> 行。暗含 <code>--patch</code> 选项。<br><code>--output=&lt;file&gt;</code>输出到一个特定的文件，而不是标准输出。<br><code>--stat[=&lt;width&gt;[,&lt;name-width&gt;[,&lt;count&gt;]]]</code>生成差异统计（diffstat）。默认情况下，文件名部分将使用尽可能多的空间，其余空间用于图表部分。最大宽度默认为终端宽度，如果未连接终端，则为 80 列，可以用 <code>&lt;width&gt;</code>改写。文件名部分的宽度可以通过在逗号后添加宽度 <code>&lt;name-width&gt;</code> 或设置 <code>diff.statNameWidth=&lt;width&gt;</code> 来限制。图形部分的宽度可以通过使用 <code>--stat-graph-width=&lt;width&gt;</code> 或设置 <code>diff.statGraphWidth=&lt;width&gt;</code> 来限制。使用 <code>--stat</code> 或 <code>--stat-graph-width</code> 会影响所有生成统计图的命令，而设置 <code>diff.statNameWidth 或 diff.statGraphWidth</code> 不会影响 <code>git format-patch</code>。通过给出第三个参数 <code>&lt;count&gt;</code>，可以将输出限制在前 <code>&lt;count&gt;</code> 行，如果行数更多，则在后面加上<code>...</code>。<br>这些参数也可以通过 <code>--stat-width=&lt;width&gt;</code>, <code>--stat-name-width=&lt;name-width&gt;</code> 和 <code>--stat-count=&lt;count&gt;</code> 单独设置。<br><code>--numstat</code>与 <code>--stat</code> 类似，但会以十进制形式显示添加和删除的行数，并且路径名不带缩写，使其对机器更友好。对于二进制文件，会输出两个”-“，而不是 0 0。<br><code>ignore-space-at-eol</code>忽略行尾空格的变化。<br><code>ignore-space-change</code>忽略空格数量的变化。这会忽略行尾的空格，并认为包含一个或多个空格字符的其他序列都是等同的。<br><code>ignore-all-space</code>比较行时忽略空格。即使一行有空格而另一行没有空格，也会忽略差异。<br><code>--ignore-cr-at-eol</code>在进行比较时，忽略行末的回车。<br><code>--full-index</code>在生成补丁格式输出时，在 “索引 “行显示完整的图像前和图像后 blob 对象名称，而不是显示前几个字符。<br><code>--binary</code>除了 <code>--full-index</code> 之外，还输出二进制差异，可以用 <code>git-apply</code> 应用。意味着 <code>--patch</code>。<br><code>-S&lt;string&gt;</code>查找改变文件中指定字符串出现次数（即增加&#x2F;删除）的差异。供脚本编写者使用。<br>当您要查找一个精确的代码块（如结构体），并想了解该代码块自首次出现以来的历史时，该功能非常有用：通过 <code>-S</code> 选项迭代，将原文件中的感兴趣的块显示出，并继续进行，直到获得该块的第一个版本。二进制文件也会被搜索到。<br><code>-G&lt;regex&gt;</code>查找补丁文本中包含符合 <code>&lt;regex&gt;</code> 的添加&#x2F;删除行的差异。<br>为了说明 <code>-S&lt;regex&gt; --pickaxe-regex</code> 和 <code>-G&lt;regex&gt;</code> 之间的区别，请考虑同一文件中包含以下差异的提交：</p>
<pre><code>git diff  /* 默认情况下workspace与index的差别 */
git diff --cached /* index和当前分支最新的提交（HEAD）比较 */
git diff HEAD /* workspace和当前分支最新的提交（HEAD）比较 */
git diff --stat=200 HEAD^ /* 显示与上次提交已更改文件的名称和行数，并指定文件名显示宽度 */
git diff origin/master /* 本地master分支与origin/master分支比较，一般在fetch后用 */
/* git diff可以传递Git refs以提交到diff。一些示例引用是、HEAD、标签和分支名称 */
git diff branch1 other-feature-branch /* 两个分支差异 */
git diff main new_branch ./diff_test.txt /* 跨分支比较特定文件，后跟文件路径 */
git diff -p --output=a.diff /* 生成补丁，-p是默认的，可不加；--output=file，也可用重定向&quot;&gt;&quot; */
</code></pre>
<h2 id="show"><a href="#show" class="headerlink" title="show"></a>show</h2><p>显示各种类型（blobs, trees, tags and commits）一个或多个对象<br><code>git show [&lt;options&gt;] [&lt;object&gt;…​]</code></p>
<pre><code>git show commit /* 显示特定提交中更改的代码 */
git show stash@&#123;0&#125; /* 查看一个 stash 中的内容 */
git show commit  --stat /* 显示差异文件的统计 */
</code></pre>
<h2 id="log"><a href="#log" class="headerlink" title="log"></a>log</h2><p>查看历史提交记录</p>
<pre><code>git log /* 查看提交记录 */
git log --stat /* 查看每次提交的文件变更 */
git log -p /* 显示每次提交所引入的差异（按补丁的格式输出 */
git log --pretty=oneline /* 精简输出来显示日志，每个提交放在一行显示*/
git log --pretty=--graph /* ASCII 图形显示分支与合并历史 */
git log --pretty=fuller /* 更完整的格式显示 */
git log --author=&quot;abc&quot; /* 显示指定的作者的提交 */
git log --committer=&quot;abc&quot; /* 显示指定的提交者的提交 */
git log --after=&quot;2020.01.01 00:00:00&quot; --before=&quot;2020.01.03 00:00:00&quot;/* 显示指定时间段的提交 */
git log &lt;since&gt;..&lt;until&gt; /* 显示在&lt;since&gt;和&lt;until&gt;之间发生的提交 */
git log -S &quot;function&quot; /* 显示添加或删除内容当中有function字符串的提交 */
git log --grep &quot;socket&quot; /* 显示提交说明中包含socket字符串的提交 */
git log --reverse /* 以相反的顺序输出要显示的提交 */
git log --format=fuller /* 以更全的方式显示log */
</code></pre>
<h2 id="difftool"><a href="#difftool" class="headerlink" title="difftool"></a>difftool</h2><p>difftool是git版本管理工具中的一个内容差异比较器，通过参数设置可以配置调用其它可视化工具</p>
<pre><code>git difftool --tool-help /* 查看支持的git diff的插件*/
git mergetool --tool-help /* 查看支持的git merge插件 */
git difftool t bc4 /* 以指定工具对比 */
git config --global merge.tool bc4 /* mergetool 的默认工具配置成 bc4 */
/* 指定了工具 bc4 的调用路径和参数 依次代表本地修改，被合并分支修改，两端未修改前版本文件，最终合并导出的文本文件 */
git config --global mergetool.bc4.cmd &#39;\&quot;D:\Beyond Compare 4\BComp.exe\&quot; &quot;$LOCAL&quot; &quot;$REMOTE&quot; &quot;$BASE&quot; &quot;$MERGED&quot;&#39;
 /* 设置为 true 表示信任软件的返回码，并依据返回码确定合并是否成功，如果设置成 false 就会在合并完成后问你是否解决完冲突*/
git config --global mergetool.bc4.trustExitCode true
git config --global mergetool.keepBackup false /* 指定在合并完成后删除调用 git mergetool 是产生 *.orig 备份文件 */
git config --global diff.tool bc4
/* $LOCAL和$REMOTE的顺序控制，即左窗格显示哪个文件，右窗格显示哪个文件 */
git config --global difftool.bc4.cmd &#39;&quot;D:\Beyond Compare 4\BComp.exe&quot; &quot;$LOCAL&quot; &quot;$REMOTE&quot;&#39;
git config --global difftool.prompt false /* 每次使用git difftool时会有二次提示，设置可以取消 */
git config --global difftool.trustExitCode true
tips：注意不是&quot;BCompare.exe&quot;这个东西，BCompare.exe 是主程序，BComp.exe 用在版本控制工具中更加优秀
git difftool /* 提交时查看差异修改了什么 */
git mergetool /* 合并时冲突修改 */
</code></pre>
<h2 id="apply"><a href="#apply" class="headerlink" title="apply"></a>apply</h2><p>将修补程序应用于文件或索引，此命令应用修补程序，但不创建提交，推荐使用<code>git-am</code>从<code>git-format-patch</code>生成的补丁或通过电子邮件接收的补丁创建提交。</p>
<pre><code>git apply a.diff --check /* 检测补丁是否适用于当前工作区或索引并检测错误 */
git apply -p1 a.diff /* 应用该补丁， -p1表示忽略/标识的前导目录，与patch -p1 &lt; a.diff 命令几乎相同 */
git apply --cached -p1 a.diff /* 修补程序仅应用于索引 */
</code></pre>
<h2 id="cherry-pick"><a href="#cherry-pick" class="headerlink" title="cherry-pick"></a>cherry-pick</h2><p>遴选，它可以在当前分支应用其他已经存在的 commit 修改，并对每一个合并过来的 commit 产生一个新的提交记录（commit hash）。<br>cherry-pick 的一些常用配置项:<br><code>-n, --no-commit</code> 只更新工作区和暂存区。不产生新的提交<br><code>-x</code> 在提交信息末尾追加一行（cherry picked from commit…）方便以后查到这个提交是如何产生的<br><code>-m parent-number, --mainline parent-number</code> 如果原始分支是一个合并节点，那么 cherry-pick 默认会失败，因为不知道应该采用哪个分支的代码变动。 -m 配置项告诉 git 应该采用哪个分支分变动，parent-number 代表原始提交的父分支编号<br><code>git cherry-pick -m 1 &lt;commit&gt;</code><br>一般1号父分支是接受变动分支（the branch being merged into），2号父分支是作为变动来源的分支（the branch being merged from)</p>
<pre><code>git cherry-pick &lt;commit&gt; /* 指定任何本地分支上的某个存在的提交 */
git cherry-pick &lt;commit1&gt; &lt;commit2&gt; /* 多个不连续的提交，提交之间用空格相隔 */
git cherry-pick &lt;start-commit&gt;..&lt;end-commit&gt; /* 连续的提交（左开右闭），使用`..`注意中间没有任何空格 */
git cherry-pick &lt;branchName&gt; /* 会将指定分支的最后一次提交应用到当前分支 */
/* 转移另一个代码库的提交 */
/* 其实 cherry-pick 的奥义就是，只要是在一个.git仓库管理下的本地代码，任何提交都可以被应用到任何可访问的本地分支，哪怕是跨代码库：*/
git remote add repo2 git@xxx.git /* 添加另一个代码库 */
git fetch repo2 /* 抓取新代码库到本地 */
git log repo2/master /* 查看新代码库master分支的提交记录 */
git cherry-pick &lt;commitInRepo2&gt; /* 将新的代码库的某个提交应用到当前分支（跨代码库的合并） */
</code></pre>
<h2 id="merge"><a href="#merge" class="headerlink" title="merge"></a>merge</h2><p>将两个或多个分叉历史合并在一起，最常见用于组合两个分支。</p>
<pre><code>git merge debug /* 将 debug 分支合并到当前分支 */
git merge debug fixup /* 合并分支 debug 和 fixup 到当前分支之上 */
git merge --no-commit debug /* 合并分支 debug 到当前分支，但是不自动创建新提交，快进是合并不适用 */
git merge --no-ff debug /* 非快进式合并，产生合并提交  */
git merge -Xours debug /* 不用手动解决冲突，在那个分支（debug）上所有其他非冲突的改动都可以被成功地合并入，有冲突的区别，选择特定的一边（当前分支）并忽略另外一边（debug分支）*/

如果想要做类似的事情但是甚至并不想让 Git 尝试合并另外一边的修改， 有一个更严格的选项，它是 “ours”
合并 策略。 这与 “ours” recursive 合并选项不同
git merge -s ours debug /* 这本质上会做一次假的合并。 它会记录一个以两边分支作为父结点的新合并提交，但是它甚至根本不关注你正合并入的分支。 它只会简单地把当前分支的代码当作合并结果记录下来 */
git merge -s theirs debug /* 用 debug 的修改作为合并策略 */
</code></pre>
<h2 id="rebase"><a href="#rebase" class="headerlink" title="rebase"></a>rebase</h2><p>变基是将一系列提交移动或组合到新的基础提交的过程，变基的主要原因是保持线性项目历史记录。</p>
<pre><code>git rebase &lt;base&gt; /* 将当前分支重定向到 &lt;base&gt;，&lt;base&gt; 可以是提交 ID、分支名、标签，或者 HEAD 的相对引用，然后获取当前分支中的提交，并将它们应用于分支的头部 */
git rebase -i &lt;base&gt; /* 以交互方式将当前分支重设为&lt;base&gt;的基础。启动编辑器，输入 命令，说明如何将每个提交转移到新的分支 */
git rebase --interactive &lt;base&gt; /* 交互式变基 */
 git rebase --onto &lt;newbase&gt; &lt;oldbase&gt; /* 类似于切片变基，以newbase为新的基点，将以oldbase基点的下一个提交到该分支的顶端 */
git rebase master debug /* 以master分支为基点应用debug分支的提交（这样写不必在变基前签出debug分支） */
git rebase --onto=&lt;new_base&gt; &lt;old_base&gt; [&lt;branch&gt;]
git rebase --onto=&lt;new_base&gt; &lt;old_base&gt; /* 如果现在是在分支上，可以省略 */
git rebase &lt;new_old_base&gt; /* 如果new_base与old_base相同，我们可以省略--onto参数 */
(事实上，&lt;old_base&gt;是我们用来比较分支的东西。如果它是一个分支，那么 git 就会寻找一个共同的祖先（参见 --fork-point）；如果它是当前分支上的一个提交，就会使用之后的提交；如果它是一个与当前分支没有共同祖先的提交，就会使用当前分支的所有提交。&lt;new_base&gt;也可以是一个提交。因此，举例来说，git rebase --onto HEAD~ HEAD 会把旧基地 HEAD 和当前 HEAD 之间的提交放在 HEAD~ 的上面，有效地删除了最后一个提交）。
</code></pre>
<p><code>git rebase branch</code></p>
<pre><code>           Before                           After
    A---B---C---F---G (branch)        A---B---C---F---G (branch)
             \                                         \
              D---E (HEAD)                              D---E (HEAD)
</code></pre>
<p><code>git rebase --onto F D</code> 将父级为D的HEAD的可达提交重置于F之上</p>
<pre><code>          Before                           After
    A---B---C---F---G (branch)        A---B---C---F---G (branch)
             \                                     \
              D---E---H---I (HEAD)                  E---H---I (HEAD)
</code></pre>
<p><code>git rebase --onto B E</code> 删除一些提交时不要交互式变基</p>
<pre><code>          Before                       After
    A---B---C---E---F (HEAD)        A---B---F (HEAD)
</code></pre>
<p><a target="_blank" rel="noopener" href="https://so.csdn.net/so/search?q=git%20rebase&spm=1001.2101.3001.7020">git rebase</a> –onto有3个参数<br>git rebase –onto 可以在精度方面更进一步。事实上，它允许您在另一个提交的基础上重设一个任意范围的提交<br><code>git rebase --onto F D H</code> 把 E–H 的切片放在 F 的上面，忽略 HEAD 当前指向的位置</p>
<pre><code>          Before                                     After
    A---B---C---F---G (branch)                A---B---C---F---G (branch)
             \                                             \
              D---E---H---I (HEAD)                          E---H (HEAD)
</code></pre>
<p>git rebase时产生冲突标记</p>
<pre><code>&lt;&lt;&lt;&lt;&lt;&lt;&lt; - ||||||| /* 变动来源的分支的修改 */
||||||| - ======= /* 基线 */
======= - &gt;&gt;&gt;&gt;&gt;&gt;&gt; /* 接受变动分支的修改 */
</code></pre>
<h2 id="commit"><a href="#commit" class="headerlink" title="commit"></a>commit</h2><p>提交暂存的更改到仓库</p>
<pre><code>git commit /* 默认编辑器打开，提示添加一条新的提交消息 */
git commit -m &#39;first commit&#39; /* 将所有暂存的文件提交至仓库 */
git comm --allow-empty /* 创建空提交 */
git commit --amend / 使用当前暂存的修改更新之前的提交，并提供一个新的提交消息 */
git commit --amend --date=&quot;$(date -R)&quot; /* 将commit的时间改为当前时间 */
</code></pre>
<h2 id="reset"><a href="#reset" class="headerlink" title="reset"></a>reset</h2><p>重置当前HEAD到指定的状态</p>
<pre><code>git reset --hard HEAD^ /* HEAD和branch切换到上一条commit，且工作区和暂存区也重置为上一次commit状态 */
git reset --hard /* 工作区和暂存区重置为HEAD新位置，branch和HEAD也切换 */
git reset --soft HEAD^ /* HEAD切换到HEAD^,工作区不改变，暂存区不改变 */
git reset --mixed /* git reset缺省默认，重置暂存区，工作区不改变，更改引用 */
git reset HEAD filename /* 将文件filename撤出暂存区，相当于对命令git add filename的反向操作 */
git reset --merge ORIG_HEAD /* 移除当前分支中所有在最近一次合并中引入的提交，保留工作树尚未添加的更改 */
</code></pre>
<p>重置命令的一个用途就是修改引用（如master）的游标，重置命令的时候没有使用任何参数对所要重置的分支名进行设置，这是因为重置命名实际上所针对的是头指针HEAD，之所以没有改变HEAD的内容是因为HEAD指向了一个引用<code>refs/heads/master</code>,所以重置命令体现为分支“游标”的变更，HEAD本身一直指向的是<code>refs/heads/master</code>，并没有在重置时改变。</p>
<h2 id="stash"><a href="#stash" class="headerlink" title="stash"></a>stash</h2><p>将本地修改保存到一个新的 stash 条目，并将其回滚到 HEAD（工作树和索引中）。 部分是可选的，它给出了描述和储藏状态。</p>
<pre><code>git stash push /* 保存当前工作区和暂存区未提交的改动，最新保存的永远都是stash@&#123;0&#125;，回到干净目录，push可省略 */
git stash save message /* 保存备注的信息（已弃用）改用 git stash push */
git stash push -m message /* 代替 save */
git stash push -k /* 所有已添加到索引中的更改将保持不变，将所有其他改动保存到储藏室中 */
git stash push --staged /* 仅存储当前暂存的更改。这与基本的 git commit 类似，只是将状态提交到储藏库，而不是当前分支 */
git stash push [--] &lt;pathspec&gt;…​ /* 部分存储，指定缓存哪些路径文件 */
git stash push work/bsp/ -m message /* 存储work/bsp/目录下的文件，不符合路径规范的文件不存储 */
git stash list /* 列出存储的stash */
git stash pop /* 从最近存储的进度(stash@&#123;0&#125;)进行恢复将其应用到当前并从储藏列表移除，但当前工作区要与暂存区保持一致 */
git stash pop stash@&#123;0&#125; /* 恢复指定索引的进度 */
git stash drop stash@&#123;0&#125; /* 从储藏条目列表中删除一个单一的储藏条目 */
git stash clear /* 删除所有储藏条目列表 */
git stash show -p stash@&#123;1&#125; /* 以补丁形式查看指定的暂存 */
</code></pre>
<h2 id="worktree"><a href="#worktree" class="headerlink" title="worktree"></a>worktree</h2><p>一个 git 仓库可以支持多个工作树，允许你一次签出多个分支。用git worktree添加一个新的工作树与版本库相关联，同时添加额外的元数据，以区分该工作树与同一版本库中的其他工作树。工作树，连同这些元数据，被称为 “工作树”。</p>
<p>这个新的工作树被称为 “链接工作树”，而不是由 git-init 或 git-clone 准备的 “主工作树”。一个版本库有一个主工作树（如果它不是一个裸版本库）和零个或多个链接工作树。当你用完一个链接的工作树后，用 git worktree remove 删除它。</p>
<p>在其最简单的形式中，git worktree add 会自动创建一个新的分支，其名称是 的最后一个组成部分，如果你计划在一个新的主题上工作，这很方便。例如，git worktree add …&#x2F;hotfix 创建了新的分支 hotfix，并在路径 …&#x2F;hotfix 处检查。如果要在新的工作树中处理现有的分支，可以使用 git worktree add 。另一方面，如果你只是打算做一些实验性的修改，或者在不影响现有开发的情况下进行测试，创建一个不与任何分支相关联的废弃工作树往往很方便。例如，git worktree add -d 在与当前分支相同的提交处创建一个带有分离的 HEAD 的新工作树。</p>
<p>如果没有使用 git worktree remove 就删除了工作树，那么它相关的管理文件，即驻留在仓库中的文件，最终会被自动删除（见 gc.worktreePruneExpire in git-config），或者你可以在主工作树或任何链接工作树中运行 git worktree prune 来清理任何过时的管理文件。</p>
<p>假如我们正在dev开发分支进行工作，这个时候遇到紧急情况，我们需要在master分支工作，暂停在dev分支的工作，但在dev分支工作还没做完，我们不想产生新的提交，除了使用<code>stash</code>，还可以使用<code>worktree</code>，创建新工作树链接到当前存储库，从而实现签出多个分支</p>
<pre><code>git worktree add path commit /* 在 &lt;path&gt; 创建一个工作树，并将 &lt;commit-ish&gt; 签出到其中。新的工作树被链接到当前的版本库，共享除每个工作树文件（如 HEAD、索引等）之外的一切 */

如果 &lt;commit-ish&gt; 是一个分支名（称其为 &lt;branch&gt;），并且没有找到，也没有使用 -b、-B 或 --detach，但在恰好一个远程（称其为 &lt;remote&gt;）中确实存在一个名称匹配的跟踪分支，则视作等同于：
git worktree add --track -b &lt;branch&gt; &lt;path&gt; &lt;remote&gt;/&lt;branch&gt;
如果 &lt;commit-ish&gt; 被省略，而且既没有使用 -b 也没有使用 --detach，那么为了方便起见，新的工作树将与一个以 $(basename &lt;path&gt;) 命名的分支（称之为 &lt;branch&gt;）相关联。如果 &lt;branch&gt; 不存在，就会自动创建一个基于 HEAD 的新分支，就像给出 -b &lt;branch&gt; 一样。

git worktree add -b emergency-fix ../temp master /* 创建一个名为 emergency-fix 的新分支，如果 &lt;commit-ish&gt; 被省略，它默认为 HEAD。默认情况下，如果一个新的分支已经存在，-b 会拒绝创建它，-B 覆盖这一保护措施，将 &lt;new-branch&gt; 重置为 &lt;commit-ish&gt;*/

git worktree remove ../temp /* 删除工作树 */
git woektree list /* 列出工作树，首先列出主工作树，在列出worktree链接的工作树 */
</code></pre>
<h2 id="revert"><a href="#revert" class="headerlink" title="revert"></a>revert</h2><p>本地分支中使用<code>git reset</code>很方便，但是这种“改写历史”的方法对大家一起使用的远程分支是无效的，<code>revert</code>是用来撤销一个指定提交的操作，<code>revert</code>之后就可以把你的更改推送到远程仓库</p>
<pre><code>git revert &lt;commit&gt; /* 产生一个新提交，新的提交相当于撤销&lt;commit&gt;这个提交 */
git revert HEAD~3..HEAD~1 /* 将HEAD~2到HEAD~1的两次提交的改动还原，并连续创建（弹出提交消息框）HEAD~1和HEAD~2的提交 */
git revert -n HEAD~3..HEAD~1 /* 作用同上，但不创建任何包含还原改动的提交。还原只会修改工作区和索引 */
</code></pre>
<h2 id="clone"><a href="#clone" class="headerlink" title="clone"></a>clone</h2><p><code>git clone &lt;repository&gt; &lt;directory&gt;</code>将<code>&lt;repository&gt;</code>指向的版本库创建一个克隆到<code>&lt;directory&gt;</code>目录，<code>&lt;directory&gt;</code>相当于克隆版本库的工作区，文件都会检出，版本库位于工作区下的<code>.git</code>目录中。它通常会自动地创建一个跟踪origin&#x2F;master的master分支，<code>git clone</code>实际上是一个封装了其他几个命令的命令。 它创建了一个名为“linux”的新目录，切换到新的目录，然后<code>git init</code>来初始化一个空的Git仓库， 然后为你指定的URL添加一个（默认名称为origin的）远程仓库（git remote add），再针对远程仓库执行<code>git fetch</code>，最后通过<code>git checkout</code>将远程仓库的最新提交检出到本地的工作目录</p>
<pre><code>git clone https://github.com/torvalds/linux.git /* 没有指定目录，存储库最后一级的目录名去掉后缀作为新克隆的目录名 */
</code></pre>
<h2 id="remote"><a href="#remote" class="headerlink" title="remote"></a>remote</h2><p>管理远程仓库，将一个远程连接加入到仓库中时，必须为它分配一个别名。默认情况下，这个别名是 <code>origin</code>。<br><code>git remote add &lt;name&gt; &lt;URL&gt;</code><br>为位于 <code>&lt;URL&gt;</code> 的版本库添加名为 <code>&lt;name&gt;</code> 的远程。然后就可以使用 <code>git fetch &lt;name&gt;</code> 命令来创建和更新远程跟踪分支 <code>&lt;name&gt;/&lt;branch&gt;</code>。</p>
<pre><code>git remote /* 列出本地已添加的远程仓库 */
git remote -v /* 列出本地已添加的远程仓库并显示url(--verbose) */
git remote add &lt;name&gt; &lt;url&gt; / * 创建一个连接到远程软件仓库的新连接。添加远程仓库后、 可以在其他命令中使用 &lt;name&gt; 作为 &lt;url&gt; 的快捷方式 */
git remote add origin https://github.com/torvalds/linux.git /* 在config添加一个指向远程仓库的引用 */
git remote rm origin /* 删除名为 origin 的远程。远程的所有远程跟踪分支和配置设置都会被删除 */
git remote -v update --prune origin /* 获取远程仓更新，并清理所有过时的远程跟踪分支 */
git remote show /* 显示远程仓库名 */
git remote show origin /* 连接origin远程仓库检查远程仓库所有分支和本地分支关联情况，这个命令列出了当你在特定的分支上执行 git push 会自动地推送到哪一个远程分支。 它也同样地列出了哪些 远程分支不在你的本地，哪些远程分支已经从服务器上移除了， 还有当你执行 git pull 时哪些本地分支可以与它跟踪的远程分支自动合并。 */
git remote update /* 关联多个远程仓全部更新，相当于每个远程仓执行git fetch */
git remote rename origin new_name /* 将origin远程仓重命名new_name */
git remote set-url origin &lt;NEW_URL&gt; /* 重设origin远程仓的地址 */
git remote set-url --push origin &lt;NEW_URL&gt; /* 给git push设置origin远程仓的url地址 */
git show-ref /* 查看全部本地引用 */
</code></pre>
<h2 id="fetch"><a href="#fetch" class="headerlink" title="fetch"></a>fetch</h2><p>访问远程仓库，从中获取本地版本库没有的数据。 执行完成后拥有那个远程仓库中所有分支的引用，可以随时合并或查看。本地远程分支列表不会自动更新，<code>fetch</code>命令可以更新，但如果远程仓库有删除的分支，那么在更新时本地远程分支列表并不会将其删除。</p>
<pre><code>git fetch &lt;remote&gt; &lt;branch&gt; /* 从 仓库 抓取特定的 &lt;branch&gt;。不使用&lt;branch&gt; 来获取所有远程参考  */
git fetch origin /* 获取更新的列表和所有远程分支的内容，远程分支列表不会自动更新 */
</code></pre>
<p><code>git fetch origin</code>操作时使用的默认引用表达式，fetch参数相当于执行了<code>git fetch origin +refs/heads/*:refs/remotes/origin/*</code>命令<code>+</code>号告诉Git即使在不能快进的情况下也要（强制）更新引用。引用表达式中使用了通配符，冒号前面的含有通配符的引用指的是远程版本库的所有分支（远程库上所有的以refs&#x2F;heads&#x2F;开头的引用），冒号后面的引用含义是复制到本地的远程分支目录（本地的refs&#x2F;remotes&#x2F;origin开头的引用）中。<br>注意：<code>git fetch</code>命令只会将数据下载到的本地仓库——它并不会自动合并或修改当前的工作，必须手动将其合并。</p>
<h2 id="pull"><a href="#pull" class="headerlink" title="pull"></a>pull</h2><p>拉取后合并</p>
<pre><code>git pull /* 在一个跟踪分支上输入 git pull，Git 能自动地识别去哪个服务器上抓取、合并到哪个分支 */
git pull --rebase /* 通过变基来更新自己的本地分支，默认merge */
git pull --rebase &lt;remote&gt;/* 获取当前分支的远程副本，并将其重定为本地副本。使用 git rebase 代替 merge 来整合分支 */
git pull upstream master:tgmaster /* 将 upstream 远程版本的 master 分支合并到本地的 tgmaster 分支 */
git pull &lt;remote&gt; /* 获取当前分支的指定远程副本，并立即将其合并到本地副本中 */
</code></pre>
<blockquote>
<ul>
<li>如果为当前分支设置了，即由配置branch..remote给出了远程版本库代号，则不带参数执行:command:<code>git pull</code>相当于执行了:command:<code>git pull &lt;remote&gt;</code>。</li>
<li>如果没有为当前分支设置，则不带参数执行:command:<code>git pull</code>相当于执行了:command:<code>git pull origin</code>。</li>
<li>要获取的远程版本库的URL地址由remote..url给出。</li>
<li>如果为注册的远程版本库设置了fetch参数，即通过remote..fetch配置了一个引用表达式，则使用该引用表达式执行获取操作。</li>
<li>接下来要确定合并的分支。如果设定了branch..merge，则对其设定的分支执行合并，否则报错退出。</li>
</ul>
</blockquote>
<h2 id="push"><a href="#push" class="headerlink" title="push"></a>push</h2><p><code>[--no-verify] [&lt;repository&gt; [&lt;refspec&gt;…​]]</code><br>切换 pre-push 钩子。 默认是 –verify，给钩子一个机会来阻止推送。 如果使用 –no-verify，钩子会被完全绕过。</p>
<p>当命令行没有用 <code>&lt;repository&gt;</code> 参数指定推送位置时，会参考当前分支的 <code>branch.*.remote</code>配置来决定推送位置。 如果配置丢失，则默认为 <code>origin</code>。<br>当命令行没有用 <code>&lt;refspec&gt;...</code> 参数或 <code>--all、--mirror、--tags</code> 选项指定推送内容时，命令通过查阅 <code>remote.*.push</code> 配置找到默认的 <code>&lt;refspec&gt;</code>，如果没有找到，则以 <code>push.default</code> 配置决定推送内容。<br>当命令行和配置都没有指定推送的内容时，将使用默认行为，这与 <code>push.default</code> 的 simple 值相对应：当前分支被推送到相应的上游分支，但作为一项安全措施，如果上游分支的名称与本地分支不一致，推送将被中止。</p>
<p>指定用哪个源对象更新哪个目标引用。<code>&lt;refspec&gt;</code> 参数的格式是一个可选的加号 <code>+</code>，后面是源对象 <code>&lt;src&gt;</code>，后面是冒号 <code>:</code> ，后面是目标引用 <code>&lt;dst&gt;</code>。<br><code>+</code>等同于<code>--force</code>，通常情况下，命令会拒绝更新一个不属于用来覆盖它的本地引用祖先的远程引用，这个标志禁用了这些检查。例：<code>git push origin +master</code>，强制推送到 <code>master</code> 分支。<br><code>&lt;src&gt;</code> 通常是你想推送的分支的名字，但它可以是任何任意的“SHA-1 表达式”，比如 <code>master~4</code> 或 <code>HEAD</code>。<br><code>&lt;dst&gt;</code> 远程仓库的哪个引用被这个推送更新。这里不能使用任意的表达式，必须命名一个实际的引用。</p>
<p><code>git push origin :experimental</code>在 <code>origin</code> 仓库（例如<code>refs/heads/experimental</code>）中找到一个与 <code>experimental</code> 相匹配的引用，并将其删除。<br>推送一个空的 <code>&lt;src&gt;</code> 允许你从远程版本库中删除 <code>&lt;dst&gt;</code> 的引用。除非配置或钩子禁止，否则在引用规范中没有前面的 <code>+</code> (或 <code>--force</code>) ，删除总是被接受的。</p>
<pre><code>git push
</code></pre>
<p>如果 <code>git push [&lt;repository&gt;]</code> 没有任何 <code>&lt;refspec&gt;</code> 参数被设置用 <code>remote.&lt;repository&gt;.push</code> 配置变量更新目的地 <code>&lt;src&gt;</code> 的某个引用，则<code>:&lt;dst&gt;</code> 部分可以省略 —— 这样的推送将更新 <code>&lt;src&gt;</code> 通常更新的引用，命令行上没有任何 <code>&lt;refspec&gt;</code>。 否则，缺少 <code>:&lt;dst&gt;</code> 意味着更新与 <code>&lt;src&gt;</code> 相同的引用。</p>
<blockquote>
<ul>
<li>如果为当前分支设置了，即由配置branch..remote给出了远程版本库代号，则不带参数执行:command:<code>git push</code>相当于执行了:command:<code>git push &lt;remote&gt;</code>。</li>
<li>如果没有为当前分支设置，则不带参数执行:command:<code>git push</code>相当于执行了:command:<code>git push origin</code>。</li>
<li>要推送的远程版本库的URL地址由remote..pushurl给出。如果没有配置，则使用remote..url配置的URL地址。</li>
<li>如果为注册的远程版本库设置了push参数，即通过remote..push配置了一个引用表达式，则使用该引用表达式执行推送。</li>
<li>否则使用“:”作为引用表达式。该表达式的含义是同名分支推送，即对所有在远程版本库有同名分支的本地分支执行推送。<br>这也就是为什么在一个本地新建分支中执行:command:<code>git push</code>推送操作不会推送也不会报错的原因，因为远程不存在同名分支，所以根本就没有对该分支执行推送，而推送的是其他分支（如果远程版本库有同名分支的话）。</li>
</ul>
</blockquote>
<pre><code>git push &lt;remote&gt; &lt;branch&gt; /* 推送&lt;branch&gt;分支到&lt;remote&gt;远程仓，以及必要的提交和对象。如果远程仓库不存在，则在远程仓库中创建&lt;branch&gt;命名分支 */
git push &lt;remote&gt; --all /* 将所有本地分支推送到指定的远程分支 */
git push origin new_branch /* 将new_branch分支推送到origin服务器， 并创建new_branch分支，但不会建立跟踪*/
git push --set-upstream remote_name local_branch remote_branch /* 将本地分支local_branch的副本推送至远程仓remote_name，并设置跟踪上游分支remote_branch */
git push -u origin master /* 上条命令简写，将master 支推送到origin远程仓，本地分支master跟踪远程分支master */
git push origin --delete serverfix /* 删除一个远程分支， 从服务器上删除serverfix分支 */
</code></pre>
<h2 id="branch"><a href="#branch" class="headerlink" title="branch"></a>branch</h2><p>Git 中的分支本质上是一个指向某个特定提交的命名可变指针</p>
<pre><code>git branch /* 显示本地分支列表，当前分支用星号 “*” 标识出来 */
git branch -r /* 显示远程分支(--remotes) */
git branch -a /* 显示所有分支(--all) */
git branch -v /* 查看每一个分支的最后一次提交 */
git branch -vv /* 查看所有分支，正在跟踪哪个远程分支与本地分支是否是领先、落后或是都有，需要先fetch */
git branch develop  /* 基于当前头指针（HEAD）指向的提交，创建一个develop分支 */
git branch bugfix ab1afef /* 基于提交ab1afef创建bugfix分支 */
git branch -d hotfix /* 删除分支。该分支必须完全合并到其上游分支中，如果没有使用 --track 或 --set-upstream-to 设置上游，则在合在HEAD中 */
git branch -D hotfix /* 强制删除hotfix分支，即使hotfix 支没有合并到上游分支 */
git branch | grep &#39;^feature/&#39; | xargs git branch -d /* 除所有以feature/开头的分支，可以使用 */
git branch -d -r origin/branch_name /* 删除删除远程跟踪的分支branch_name，下一次的 &quot;fetch &quot;或 &quot;pull &quot;会再次创建它 */
git branch -m &lt;oldbranch&gt; &lt;newbranch&gt; /* 重命名分支 */
git branch -f master HEAD~3 /* -f 选项让分支指向另一个提交，将master分支强制移动到HEAD的第3级父提交 */
git branch --merged /* 查看哪些分支已经合并到当前分支 */
git branch --no-merged /* 查看所有包含未合并工作的分支 */
git branch --no-merged master /* 尚未合并到master的分支 */
git branch (--set-upstream-to=&lt;upstream&gt; | -u &lt;upstream&gt;) [&lt;branchname&gt;] /* 设置 &lt;branchname&gt; 的跟踪信息，使 &lt;upstream&gt; 被视为 &lt;branchname&gt; 的上游分支。如果没有指定 &lt;branchname&gt;，则默认为当前分支 */
git branch -u origin/serverfix /* 设置或修改已有的本地分支serverfix跟踪一个刚刚拉取下来的远程分支 */
git branch [--track[=(direct|inherit)] &lt;branchname&gt; [&lt;start-point&gt;]
/* -t、--track 或 --track=direct 表示使用起点分支本身作为上游;--track=inherit 表示复制起点分支的上游配置 */
git reflog show --date=iso bugfix /* 指定bugfix分支的历次更改记录,最下面一条的时间即是分支创建时间 */
git branch --contains commit /* 列出所有包含指定提交对象的分支 */
</code></pre>
<h2 id="checkout"><a href="#checkout" class="headerlink" title="checkout"></a>checkout</h2><p>检出命令，改变HEAD本身</p>
<pre><code>git checkout /* 汇总显示工作区、暂存区与HEAD的差异 */
git checkout branch -- filename /* 暂存区和工作区中的filename文件被branch所指向的提交的filename文件直接覆盖 */
git checkout -- test.c /* 暂存区的test.c文件覆盖工作区的test.c文件 */
git checkout . /* 取消所有本地的修改（相对于暂存区），相当于将暂存区的所有文件直接覆盖工作区 */
git checkout ab1afef  test.c /* 用指定提交ab1afef中的文件覆盖暂存区和工作区中对应的文件 */
git checkout develop  /* 换到一个已存在的develop分支 */
git checkout -b hotfix /* 建立一个hotfix分支并切换 */
git checkout -b serverfix origin/serverfix /* 基于远程分支创建本地跟踪分支serverfix ，并且起点位于origin/serverfix */
git checkout -b sf origin/serverfix /* 基于远程分支创建本地跟踪分支sf，并且起点位于origin/serverfix */
git checkout --track origin/serverfix /* 基于远程分支创建本地跟踪分支serverfix ，并且起点位于origin/serverfix */
git checkout --conflict=merge hello.rb /* 重新恢复到冲突时候的文件状态 */
</code></pre>
<h2 id="restore"><a href="#restore" class="headerlink" title="restore"></a>restore</h2><p>用还原源中的某些内容还原工作树中的指定路径。如果跟踪到的路径在还原源中并不存在，它将被移除以匹配还原源。<br>使用 <code>--staged --worktree</code> 同时恢复工作树和索引，如果两个选项都未指定，默认情况下会还原工作树，指定<code>--staged</code> 只还原索引。指定两者则同时还原两者。<br>默认情况下，如果给了<code>--staged</code>，内容将从<code>HEAD</code>恢复，否则从索引恢复。使用<code>--source</code>来恢复不同的提交。</p>
<pre><code>git restore --staged hello.c /* 恢复索引中的文件以匹配 HEAD 中的版本，工作区不变 */
git restore --source=HEAD --staged --worktree hello.c /* 同时恢复索引和工作树（这与使用 git-checkout[1]相同）*/
git restore &#39;*.c&#39; /* 恢复所有的C源文件，使之与索引中的版本一致 */
</code></pre>
<h2 id="tag"><a href="#tag" class="headerlink" title="tag"></a>tag</h2><p>有没有什么可以永远指向某个提交记录的标识呢，比如软件发布新的大版本，或者是修正一些重要的 Bug或是增加了某些新特性，有没有比分支更好的可以永远指向这些提交的方法呢，<code>tag</code>永久地将某个特定的提交命名为里程碑，然后就可以像分支一样引用了。更难得的是，它们并不会随着新的提交而移动。你也不能切换到某个标签上面进行修改提交，它就像是提交树上的一个锚点，标识了某个特定的位置。<br>远程版本库中的里程碑同步到本地版本库，会使用同样的名称，而不会像分支那样移动到另外的命名空间（远程分支）中，推送时，默认不会将本地创建的里程碑带入远程版本库，这样可以避免远程版本库上里程碑的泛滥。<br>Git 支持两种里程碑（标签）：轻量里程碑（lightweight）与附注里程碑（annotated）</p>
<pre><code>git tag &lt;tagname&gt; [&lt;commit&gt;] /* 创建轻量级里程碑 */
git tag -a &lt;tagname&gt; [&lt;commit&gt;] /* 创建带说明的里程碑 */
git tag -m &lt;msg&gt; &lt;tagname&gt; [&lt;commit&gt;] /* 直接通过-m参数提供里程碑创建说明 */
git tag /* 列出所有标签 */
git show tag /* 输出所有带标签提交的详细信息 */
</code></pre>
<p>创建里程碑需要输入里程碑的名字<code>&lt;tagname&gt;</code>和一个可选的提交ID<code>&lt;commit&gt;</code>。如果没有提供提交ID，则基于头指针HEAD创建里程碑。</p>
<h2 id="rerere"><a href="#rerere" class="headerlink" title="rerere"></a>rerere</h2><p>git rerere 功能是一个隐藏的功能。 正如它的名字，重新使用记录的解决方案（reuse recorded resolution）：会记住文件冲突时用户的解决方案，当再次出现同样冲突时自动解决。</p>
<pre><code>git config --global rerere.enabled true /* 全局配置，冲突的解决会被记录下来以便以后再遇到时自动复用 */
git config --global rerere.enabled fasle /* 关闭重新使用记录的解决方案的配置，防止一些冲突没被发现 */
git checkout --conflict=merge file_path /* 文件恢复到未自动解决冲突时的状态 */
git rerere /* 恢复未解决冲突的状态后，又想用回之前的合并冲突策略 */
git merge --rerere-autoupdate /* 自动解决一个文件时，并没有把它标记为已解决（例如用git add），允许rerere机制用自动冲突解决的结果来更新索引 */
git rebase --no-rerere-autoupdate /* git rerere有rerere.autoupdate配置，但没有办法从命令行中取消它；不会停止自动重用已记录的决议，在用单独的git add将结果提交给索引之前，可以仔细检查rerere的工作，并抓住潜在的错误合并 */
</code></pre>
<h2 id="bisect"><a href="#bisect" class="headerlink" title="bisect"></a>bisect</h2><p>使用二分搜索查找引入错误的提交<br>第一个<code>git bisect</code>子命令是<code>git bisect start</code>来开始搜索。然后必须设置边界以限制提交空间。通常的做法是给出一个 “坏”提交和至少一个 “好”提交。可以像这样在调用<code>git bisect start</code>时传递它们：</p>
<pre><code>git bisect start [BAD [GOOD...]]
或 git bisect bad [COMMIT]
和 git bisect good [COMMIT...]
在搜索的每一步，用户都必须测试当前的提交，并分别使用上文所述的 &quot;git bisect good&quot; 或 &quot;git bisect bad&quot; 命令说它是 &quot;好 &quot;还是 &quot;坏&quot;。
&quot;git bisect&quot; 最终会找到第一个坏提交：git show HEAD 可以看到提交的内容
git bisect reset /* 回到我们开始二分前所在的分支 */
</code></pre>
<h2 id="blame"><a href="#blame" class="headerlink" title="blame"></a>blame</h2><p>查询文件历史版本信息<br><code>-L</code>选项将限制行范围</p>
<pre><code>git blame -L 40,60 file1.c /* 第40-60行修改的记录 */
git blame -L 40,+21 file1.c /* 从第40行开始的21行修改的记录 */
</code></pre>
<h2 id="clean"><a href="#clean" class="headerlink" title="clean"></a>clean</h2><p>从当前目录开始，通过递归删除不在版本控制之下的文件来清理工作区,clean 后，删除的文件无法找回。<br>通常情况下，只有 Git 未知的文件会被删除，但如果指定了 -x 选项，被忽略的文件也会被删除。例如，这对删除所有构建产品很有用。<br>如果给出任何可选的<code>&lt;路径规范&gt;…​</code>参数，只有那些与路径规范相匹配的路径会受到影响。<br><code>-d</code><br>通常，当没有指定 &lt;路径规范&gt; 时，git clean 不会递归到未追踪的目录，以避免删除太多。 指定 -d 可以让它也递归到这些目录。 如果指定了&lt;路径规范&gt;，-d 就不重要了；所有符合指定路径的未追踪文件（–force 下提到的嵌套的 git 目录除外）将被删除。<br><code>-f 或 --force</code><br>如果 Git 配置变量 clean.requireForce 没有设置为 false，git clean 将拒绝删除文件或目录，除非给出 -f 或 -i。 除非给出第二个 -f，否则 Git 将拒绝修改未跟踪的嵌套 git 仓库（有.git子目录的目录）。<br><code>-i</code><br>显示会做什么，并以交互方式清理文件。</p>
<pre><code>git clean -f -d /* git clean -fd 移除工作目录中所有未追踪的文件以及空的子目录 */ 
</code></pre>
<h2 id="和"><a href="#和" class="headerlink" title="~和^"></a>~和^</h2><pre><code>~2 表示沿着commit树向上搜索两层，并获得该层的第一个commit（如果该层有多个commit的话）
^2 表示获得某个commit的第2个父commit（merge两个分支后产生的merge commit就拥有两个父commit）
</code></pre>
</article><div class="post-copyright"><div class="post-copyright__author"><span class="post-copyright-meta"><i class="fas fa-circle-user fa-fw"></i>文章作者: </span><span class="post-copyright-info"><a href="https://vcloud.ysme.top">ysme</a></span></div><div class="post-copyright__type"><span class="post-copyright-meta"><i class="fas fa-square-arrow-up-right fa-fw"></i>文章链接: </span><span class="post-copyright-info"><a href="https://vcloud.ysme.top/2023/03/22/%E5%B7%A5%E5%85%B7/git/git%E5%BF%AB%E9%80%9F%E5%85%A5%E9%97%A8/">https://vcloud.ysme.top/2023/03/22/%E5%B7%A5%E5%85%B7/git/git%E5%BF%AB%E9%80%9F%E5%85%A5%E9%97%A8/</a></span></div><div class="post-copyright__notice"><span class="post-copyright-meta"><i class="fas fa-circle-exclamation fa-fw"></i>版权声明: </span><span class="post-copyright-info">本博客所有文章除特别声明外，均采用 <a href="https://creativecommons.org/licenses/by-nc-sa/4.0/" target="_blank">CC BY-NC-SA 4.0</a> 许可协议。转载请注明来自 <a href="https://vcloud.ysme.top" target="_blank">Blog</a>！</span></div></div><div class="tag_share"><div class="post-meta__tag-list"><a class="post-meta__tags" href="/tags/Git-%E5%BF%AB%E9%80%9F%E5%85%A5%E9%97%A8/">Git 快速入门</a></div><div class="post_share"><div class="social-share" data-image="https://randomimage.ysme.top/" data-sites="facebook,twitter,wechat,weibo,qq"></div><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/butterfly-extsrc@1.1.3/sharejs/dist/css/share.min.css" media="print" onload="this.media='all'"><script src="https://cdn.jsdelivr.net/npm/butterfly-extsrc@1.1.3/sharejs/dist/js/social-share.min.js" defer></script></div></div><nav class="pagination-post" id="pagination"><div class="prev-post pull-left"><a href="/2024/10/22/%E5%B5%8C%E5%85%A5%E5%BC%8F/%E5%B5%8C%E5%85%A5%E5%BC%8F%E8%BD%AF%E4%BB%B6%E5%91%BD%E5%90%8D%E5%B8%B8%E7%94%A8%E8%8B%B1%E6%96%87%E9%9B%86/" title="嵌入式软件命名常用英文集"><img class="cover" src="https://randomimage.ysme.top/" onerror="onerror=null;src='/img/404.jpg'" alt="cover of previous post"><div class="pagination-info"><div class="label">上一篇</div><div class="prev_info">嵌入式软件命名常用英文集</div></div></a></div><div class="next-post pull-right"><a href="/2023/01/15/linux-docs/30%E5%88%86%E9%92%9F%E5%AD%A6%E4%BC%9A%E7%BC%96%E8%AF%91linux%E5%86%85%E6%A0%B8/" title="Linux 30分钟学会编译linux内核"><img class="cover" src="https://pic2.zhimg.com/80/v2-99c76217f4575d98a9001a4fd8c1681d_720w.webp" onerror="onerror=null;src='/img/404.jpg'" alt="cover of next post"><div class="pagination-info"><div class="label">下一篇</div><div class="next_info">Linux 30分钟学会编译linux内核</div></div></a></div></nav></div><div class="aside-content" id="aside-content"><div class="card-widget card-info"><div class="is-center"><div class="avatar-img"><img src="/img/avatar.jpg" onerror="this.onerror=null;this.src='/img/friend_404.gif'" alt="avatar"/></div><div class="author-info__name">ysme</div><div class="author-info__description">嘻嘻哈哈。</div></div><div class="card-info-data site-data is-center"><a href="/archives/"><div class="headline">文章</div><div class="length-num">131</div></a><a href="/tags/"><div class="headline">标签</div><div class="length-num">5</div></a><a href="/categories/"><div class="headline">分类</div><div class="length-num">10</div></a></div><a id="card-info-btn" target="_blank" rel="noopener" href="https://github.com/ysme1"><i class="fab fa-github"></i><span>Follow Me</span></a><div class="card-info-social-icons is-center"><a class="social-icon" href="https://github.com/ysme1" target="_blank" title="Github"><i class="fab fa-github" style="color: #24292e;"></i></a><a class="social-icon" href="mailto:zys1395740068@gmail.com" target="_blank" title="Email"><i class="fas fa-envelope" style="color: #4a7dbe;"></i></a></div></div><div class="card-widget card-announcement"><div class="item-headline"><i class="fas fa-bullhorn fa-shake"></i><span>公告</span></div><div class="announcement_content">This is my Blog</div></div><div class="sticky_layout"><div class="card-widget" id="card-toc"><div class="item-headline"><i class="fas fa-stream"></i><span>目录</span><span class="toc-percentage"></span></div><div class="toc-content"><ol class="toc"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%88%97%E8%A1%A8"><span class="toc-number">1.</span> <span class="toc-text">列表</span></a></li></ol></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#init"><span class="toc-number"></span> <span class="toc-text">init</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#add"><span class="toc-number"></span> <span class="toc-text">add</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#status"><span class="toc-number"></span> <span class="toc-text">status</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#diff"><span class="toc-number"></span> <span class="toc-text">diff</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#show"><span class="toc-number"></span> <span class="toc-text">show</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#log"><span class="toc-number"></span> <span class="toc-text">log</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#difftool"><span class="toc-number"></span> <span class="toc-text">difftool</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#apply"><span class="toc-number"></span> <span class="toc-text">apply</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#cherry-pick"><span class="toc-number"></span> <span class="toc-text">cherry-pick</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#merge"><span class="toc-number"></span> <span class="toc-text">merge</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#rebase"><span class="toc-number"></span> <span class="toc-text">rebase</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#commit"><span class="toc-number"></span> <span class="toc-text">commit</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#reset"><span class="toc-number"></span> <span class="toc-text">reset</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#stash"><span class="toc-number"></span> <span class="toc-text">stash</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#worktree"><span class="toc-number"></span> <span class="toc-text">worktree</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#revert"><span class="toc-number"></span> <span class="toc-text">revert</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#clone"><span class="toc-number"></span> <span class="toc-text">clone</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#remote"><span class="toc-number"></span> <span class="toc-text">remote</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#fetch"><span class="toc-number"></span> <span class="toc-text">fetch</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#pull"><span class="toc-number"></span> <span class="toc-text">pull</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#push"><span class="toc-number"></span> <span class="toc-text">push</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#branch"><span class="toc-number"></span> <span class="toc-text">branch</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#checkout"><span class="toc-number"></span> <span class="toc-text">checkout</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#restore"><span class="toc-number"></span> <span class="toc-text">restore</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#tag"><span class="toc-number"></span> <span class="toc-text">tag</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#rerere"><span class="toc-number"></span> <span class="toc-text">rerere</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#bisect"><span class="toc-number"></span> <span class="toc-text">bisect</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#blame"><span class="toc-number"></span> <span class="toc-text">blame</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#clean"><span class="toc-number"></span> <span class="toc-text">clean</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%92%8C"><span class="toc-number"></span> <span class="toc-text">~和^</span></a></div></div><div class="card-widget card-recent-post"><div class="item-headline"><i class="fas fa-history"></i><span>最新文章</span></div><div class="aside-list"><div class="aside-list-item"><a class="thumbnail" href="/2024/10/22/%E5%B5%8C%E5%85%A5%E5%BC%8F/%E5%B5%8C%E5%85%A5%E5%BC%8F%E8%BD%AF%E4%BB%B6%E5%91%BD%E5%90%8D%E5%B8%B8%E7%94%A8%E8%8B%B1%E6%96%87%E9%9B%86/" title="嵌入式软件命名常用英文集"><img src="https://randomimage.ysme.top/" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="嵌入式软件命名常用英文集"/></a><div class="content"><a class="title" href="/2024/10/22/%E5%B5%8C%E5%85%A5%E5%BC%8F/%E5%B5%8C%E5%85%A5%E5%BC%8F%E8%BD%AF%E4%BB%B6%E5%91%BD%E5%90%8D%E5%B8%B8%E7%94%A8%E8%8B%B1%E6%96%87%E9%9B%86/" title="嵌入式软件命名常用英文集">嵌入式软件命名常用英文集</a><time datetime="2024-10-22T06:13:37.000Z" title="发表于 2024-10-22 14:13:37">2024-10-22</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/2023/03/22/%E5%B7%A5%E5%85%B7/git/git%E5%BF%AB%E9%80%9F%E5%85%A5%E9%97%A8/" title="Git 快速入门指南"><img src="https://randomimage.ysme.top/" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="Git 快速入门指南"/></a><div class="content"><a class="title" href="/2023/03/22/%E5%B7%A5%E5%85%B7/git/git%E5%BF%AB%E9%80%9F%E5%85%A5%E9%97%A8/" title="Git 快速入门指南">Git 快速入门指南</a><time datetime="2023-03-22T01:13:37.000Z" title="发表于 2023-03-22 09:13:37">2023-03-22</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/2023/01/15/linux-docs/30%E5%88%86%E9%92%9F%E5%AD%A6%E4%BC%9A%E7%BC%96%E8%AF%91linux%E5%86%85%E6%A0%B8/" title="Linux 30分钟学会编译linux内核"><img src="https://pic2.zhimg.com/80/v2-99c76217f4575d98a9001a4fd8c1681d_720w.webp" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="Linux 30分钟学会编译linux内核"/></a><div class="content"><a class="title" href="/2023/01/15/linux-docs/30%E5%88%86%E9%92%9F%E5%AD%A6%E4%BC%9A%E7%BC%96%E8%AF%91linux%E5%86%85%E6%A0%B8/" title="Linux 30分钟学会编译linux内核">Linux 30分钟学会编译linux内核</a><time datetime="2023-01-15T01:13:37.000Z" title="发表于 2023-01-15 09:13:37">2023-01-15</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/2023/01/15/linux-docs/Linux%20IO%20%E4%B9%8B%20IO%E4%B8%8E%E7%BD%91%E7%BB%9C%E6%A8%A1%E5%9E%8B/" title="Linux IO 之 IO与网络模型"><img src="https://user-images.githubusercontent.com/87457873/127649604-761ead2e-8c72-4876-a52f-8310f3c3b49c.png" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="Linux IO 之 IO与网络模型"/></a><div class="content"><a class="title" href="/2023/01/15/linux-docs/Linux%20IO%20%E4%B9%8B%20IO%E4%B8%8E%E7%BD%91%E7%BB%9C%E6%A8%A1%E5%9E%8B/" title="Linux IO 之 IO与网络模型">Linux IO 之 IO与网络模型</a><time datetime="2023-01-15T01:13:37.000Z" title="发表于 2023-01-15 09:13:37">2023-01-15</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/2023/01/15/linux-docs/Linux%20Kernel%E5%86%85%E6%A0%B8%E6%95%B4%E4%BD%93%E6%9E%B6%E6%9E%84(%E5%9B%BE%E6%96%87%E8%AF%A6%E8%A7%A3)/" title="Linux Kernel内核整体架构(图文详解)"><img src="https://pic2.zhimg.com/80/v2-93cd0f1a4abbdfeb4af71202535fe4f9_720w.webp" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="Linux Kernel内核整体架构(图文详解)"/></a><div class="content"><a class="title" href="/2023/01/15/linux-docs/Linux%20Kernel%E5%86%85%E6%A0%B8%E6%95%B4%E4%BD%93%E6%9E%B6%E6%9E%84(%E5%9B%BE%E6%96%87%E8%AF%A6%E8%A7%A3)/" title="Linux Kernel内核整体架构(图文详解)">Linux Kernel内核整体架构(图文详解)</a><time datetime="2023-01-15T01:13:37.000Z" title="发表于 2023-01-15 09:13:37">2023-01-15</time></div></div></div></div></div></div></main><footer id="footer"><div id="footer-wrap"><div class="copyright">&copy;2020 - 2024 By ysme</div><div class="framework-info"><span>框架 </span><a target="_blank" rel="noopener" href="https://hexo.io">Hexo</a><span class="footer-separator">|</span><span>主题 </span><a target="_blank" rel="noopener" href="https://github.com/jerryc127/hexo-theme-butterfly">Butterfly</a></div><div class="footer_custom_text"><a target="_blank" rel="noopener" href="https://beian.miit.gov.cn/#/Integrated/recordQuery"><img class="icp-icon" src=https://beian.mps.gov.cn/img/logo01.dd7ff50e.png><span>浙ICP备2021036292号</span></a></div></div></footer></div><div id="rightside"><div id="rightside-config-hide"><button id="readmode" type="button" title="阅读模式"><i class="fas fa-book-open"></i></button><button id="darkmode" type="button" title="浅色和深色模式转换"><i class="fas fa-adjust"></i></button><button id="hide-aside-btn" type="button" title="单栏和双栏切换"><i class="fas fa-arrows-alt-h"></i></button></div><div id="rightside-config-show"><button id="rightside-config" type="button" title="设置"><i class="fas fa-cog fa-spin"></i></button><button class="close" id="mobile-toc-button" type="button" title="目录"><i class="fas fa-list-ul"></i></button><button id="go-up" type="button" title="回到顶部"><span class="scroll-percent"></span><i class="fas fa-arrow-up"></i></button></div></div><div><script src="/js/utils.js?v=4.13.0"></script><script src="/js/main.js?v=4.13.0"></script><script src="https://cdn.jsdelivr.net/npm/@fancyapps/ui@5.0.33/dist/fancybox/fancybox.umd.min.js"></script><div class="js-pjax"></div><script async data-pjax src="//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script><div id="local-search"><div class="search-dialog"><nav class="search-nav"><span class="search-dialog-title">搜索</span><span id="loading-status"></span><button class="search-close-button"><i class="fas fa-times"></i></button></nav><div class="is-center" id="loading-database"><i class="fas fa-spinner fa-pulse"></i><span>  数据库加载中</span></div><div class="search-wrap"><div id="local-search-input"><div class="local-search-box"><input class="local-search-box--input" placeholder="搜索文章" type="text"/></div></div><hr/><div id="local-search-results"></div><div id="local-search-stats-wrap"></div></div></div><div id="search-mask"></div><script src="/js/search/local-search.js?v=4.13.0"></script></div></div></body></html>