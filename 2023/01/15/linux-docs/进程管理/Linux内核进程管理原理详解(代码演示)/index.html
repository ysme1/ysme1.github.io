
<!DOCTYPE html><html lang="zh-CN">

<head>
  <meta charset="utf-8">
  <meta name="hexo-theme" content="https://github.com/xaoxuu/hexo-theme-stellar/tree/1.27.0" theme-name="Stellar" theme-version="1.27.0">
  
  <meta name="generator" content="Hexo 7.1.1">
  <meta http-equiv='x-dns-prefetch-control' content='on' />
  
  <meta name="renderer" content="webkit">
  <meta name="force-rendering" content="webkit">
  <meta http-equiv="X-UA-Compatible" content="IE=Edge,chrome=1">
  <meta name="HandheldFriendly" content="True" >
  <meta name="apple-mobile-web-app-capable" content="yes">
  <meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1">
  <meta name="theme-color" content="#f8f8f8">
  
  <title>Linux内核进程管理原理详解(代码演示) - Blog</title>

  
    <meta name="description" content="前言：Linux内核里大部分都是C语言。建议先看《Linux内核设计与实现(Linux Kernel Development)》,Robert Love，也就是LKD。  Linux是一种动态系统，能够适应不断变化的计算需求。Linux计算需求的表现是以进程的通用抽象为中心的。进程可以是短期的（从命令行执行的一个命令），也可以是长期的（一种网络服务）。因此，对进程及其调度进行一般管理就显得极为重">
<meta property="og:type" content="article">
<meta property="og:title" content="Linux内核进程管理原理详解(代码演示)">
<meta property="og:url" content="https://vcloud.ysme.top/2023/01/15/linux-docs/%E8%BF%9B%E7%A8%8B%E7%AE%A1%E7%90%86/Linux%E5%86%85%E6%A0%B8%E8%BF%9B%E7%A8%8B%E7%AE%A1%E7%90%86%E5%8E%9F%E7%90%86%E8%AF%A6%E8%A7%A3(%E4%BB%A3%E7%A0%81%E6%BC%94%E7%A4%BA)/index.html">
<meta property="og:site_name" content="Blog">
<meta property="og:description" content="前言：Linux内核里大部分都是C语言。建议先看《Linux内核设计与实现(Linux Kernel Development)》,Robert Love，也就是LKD。  Linux是一种动态系统，能够适应不断变化的计算需求。Linux计算需求的表现是以进程的通用抽象为中心的。进程可以是短期的（从命令行执行的一个命令），也可以是长期的（一种网络服务）。因此，对进程及其调度进行一般管理就显得极为重">
<meta property="og:locale" content="zh_CN">
<meta property="og:image" content="https://pic4.zhimg.com/v2-8ab27fddbeee6271cbad74129d3467a3_b.jpg">
<meta property="og:image" content="https://pic2.zhimg.com/v2-3c5e230e7cf07cefad9b856ae3dd2c6d_b.jpg">
<meta property="article:published_time" content="2023-01-15T01:13:37.000Z">
<meta property="article:modified_time" content="2024-04-05T12:59:49.940Z">
<meta property="article:author" content="ysme">
<meta property="article:tag" content="Linux">
<meta name="twitter:card" content="summary_large_image">
<meta name="twitter:image" content="https://pic4.zhimg.com/v2-8ab27fddbeee6271cbad74129d3467a3_b.jpg">
  
  
  
  <meta name="keywords" content="Linux">

  <!-- feed -->
  

  <link rel="stylesheet" href="/css/main.css?v=1.27.0">

  

  

  
</head>
<body>

<div class="l_body s:aa content tech" id="start" layout="post" ><aside class="l_left"><div class="leftbar-container">


<header class="header"><div class="logo-wrap"><a class="avatar" href="/about/"><div class="bg" style="opacity:0;background-image:url(https://gcore.jsdelivr.net/gh/cdn-x/placeholder@1.0.12/avatar/round/rainbow64@3x.webp);"></div><img no-lazy class="avatar" src="undefined" onerror="javascript:this.classList.add('error');this.src='https://gcore.jsdelivr.net/gh/cdn-x/placeholder@1.0.12/image/2659360.svg';"></a><a class="title" href="/"><div class="main" ff="title">Blog</div></a></div></header>

<div class="nav-area">
<div class="search-wrapper" id="search-wrapper"><form class="search-form"><a class="search-button" onclick="document.getElementById(&quot;search-input&quot;).focus();"><svg t="1705074644177" viewBox="0 0 1025 1024" version="1.1" xmlns="http://www.w3.org/2000/svg" p-id="1560" width="200" height="200"><path d="M1008.839137 935.96571L792.364903 719.491476a56.783488 56.783488 0 0 0-80.152866 0 358.53545 358.53545 0 1 1 100.857314-335.166073 362.840335 362.840335 0 0 1-3.689902 170.145468 51.248635 51.248635 0 1 0 99.217358 26.444296 462.057693 462.057693 0 1 0-158.255785 242.303546l185.930047 185.725053a51.248635 51.248635 0 0 0 72.568068 0 51.248635 51.248635 0 0 0 0-72.978056z" p-id="1561"></path><path d="M616.479587 615.969233a50.428657 50.428657 0 0 0-61.498362-5.534852 174.655348 174.655348 0 0 1-177.525271 3.484907 49.403684 49.403684 0 0 0-58.833433 6.76482l-3.074918 2.869923a49.403684 49.403684 0 0 0 8.609771 78.10292 277.767601 277.767601 0 0 0 286.992355-5.739847 49.403684 49.403684 0 0 0 8.404776-76.667958z" p-id="1562"></path></svg></a><input type="text" class="search-input" id="search-input" placeholder="站内搜索"></form><div id="search-result"></div><div class="search-no-result">没有找到内容！</div></div>


<nav class="menu dis-select"></nav>
</div>
<div class="widgets">


<widget class="widget-wrapper post-list"><div class="widget-header dis-select"><span class="name">最近更新</span></div><div class="widget-body fs14"><a class="item title" href="/2023/01/15/linux-docs/%E8%BF%9B%E7%A8%8B%E7%AE%A1%E7%90%86/Linux%E5%86%85%E6%A0%B8%E8%BF%9B%E7%A8%8B%E8%BF%B0%E7%AC%A6%E5%92%8C%E8%BF%9B%E7%A8%8B%E7%8A%B6%E6%80%81/"><span class="title">Linux内核进程述符和进程状态</span></a><a class="item title" href="/2023/01/15/linux-docs/%E8%BF%9B%E7%A8%8B%E7%AE%A1%E7%90%86/Linux%E5%86%85%E6%A0%B8%E8%BF%9B%E7%A8%8B%E9%97%B4%E9%80%9A%E4%BF%A1-%E7%AE%A1%E9%81%93/"><span class="title">Linux内核进程间通信-管道</span></a><a class="item title" href="/2023/01/15/linux-docs/%E8%BF%9B%E7%A8%8B%E7%AE%A1%E7%90%86/Linux%E8%BF%9B%E7%A8%8B%E3%80%81%E7%BA%BF%E7%A8%8B%E3%80%81%E8%B0%83%E5%BA%A6(%E4%B8%80)/"><span class="title">Linux进程、线程、调度(一)</span></a><a class="item title" href="/2023/01/15/linux-docs/%E8%BF%9B%E7%A8%8B%E7%AE%A1%E7%90%86/Linux%E8%BF%9B%E7%A8%8B%E3%80%81%E7%BA%BF%E7%A8%8B%E3%80%81%E8%B0%83%E5%BA%A6(%E4%B8%89)/"><span class="title">Linux进程、线程、调度(三)</span></a><a class="item title" href="/2023/01/15/linux-docs/%E8%BF%9B%E7%A8%8B%E7%AE%A1%E7%90%86/Linux%E8%BF%9B%E7%A8%8B%E3%80%81%E7%BA%BF%E7%A8%8B%E3%80%81%E8%B0%83%E5%BA%A6(%E4%BA%8C)/"><span class="title">Linux进程、线程、调度(二)</span></a><a class="item title" href="/2023/01/15/linux-docs/%E8%BF%9B%E7%A8%8B%E7%AE%A1%E7%90%86/Linux%E8%BF%9B%E7%A8%8B%E3%80%81%E7%BA%BF%E7%A8%8B%E3%80%81%E8%B0%83%E5%BA%A6(%E5%9B%9B)/"><span class="title">Linux进程、线程、调度(四)</span></a><a class="item title" href="/2023/01/15/linux-docs/%E8%BF%9B%E7%A8%8B%E7%AE%A1%E7%90%86/Linux%E8%BF%9B%E7%A8%8B%E7%8A%B6%E6%80%81%E6%80%BB%E7%BB%93/"><span class="title">Linux进程状态总结</span></a><a class="item title" href="/2023/01/15/linux-docs/%E8%BF%9B%E7%A8%8B%E7%AE%A1%E7%90%86/%E4%B8%80%E6%96%87%E5%B8%A6%E4%BD%A0%EF%BC%8C%E5%BD%BB%E5%BA%95%E4%BA%86%E8%A7%A3%EF%BC%8C%E9%9B%B6%E6%8B%B7%E8%B4%9DZero-Copy%E6%8A%80%E6%9C%AF/"><span class="title">一文带你，彻底了解，零拷贝Zero-Copy技术</span></a><a class="item title" href="/2023/01/15/linux-docs/%E8%BF%9B%E7%A8%8B%E7%AE%A1%E7%90%86/%E4%BB%BB%E5%8A%A1%E8%B0%83%E5%BA%A6/"><span class="title">任务调度</span></a><a class="item title" href="/2023/01/15/linux-docs/%E8%BF%9B%E7%A8%8B%E7%AE%A1%E7%90%86/%E8%BF%9B%E7%A8%8B%E3%80%81%E7%BA%BF%E7%A8%8B%E7%9A%84%E5%88%9B%E5%BB%BA%E5%92%8C%E6%B4%BE%E7%94%9F/"><span class="title">进程、线程的创建和派生</span></a></div></widget>
</div>
<footer class="footer dis-select"><div class="social-wrap"><a class="social" href="/" rel="noopener noreferrer"><img class="lazy" src="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII=" data-src="https://gcore.jsdelivr.net/gh/cdn-x/placeholder@1.0.12/social/08a41b181ce68.svg"/></a><a class="social" href="/" rel="noopener noreferrer"><img class="lazy" src="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII=" data-src="https://gcore.jsdelivr.net/gh/cdn-x/placeholder@1.0.12/social/3845874.svg"/></a><a class="social" href="/" rel="noopener noreferrer"><img class="lazy" src="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII=" data-src="https://gcore.jsdelivr.net/gh/cdn-x/placeholder@1.0.12/social/3616429.svg"/></a><a class="social" href="/about/#comments" rel="noopener noreferrer"><img class="lazy" src="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII=" data-src="https://gcore.jsdelivr.net/gh/cdn-x/placeholder@1.0.12/social/942ebbf1a4b91.svg"/></a></div></footer>
</div></aside><div class="l_main" id="main">





<div class="article banner top">
  <div class="content">
    <div class="top bread-nav footnote"><div class="left"><div class="flex-row" id="breadcrumb"><a class="cap breadcrumb" href="/">主页</a>
<span class="sep"></span><a class="cap breadcrumb" href="/">文章</a><span class="sep"></span><a class="cap breadcrumb-link" href="/categories/linux-doc-%E8%BF%9B%E7%A8%8B%E7%AE%A1%E7%90%86/">linux-doc 进程管理</a></div>
<div class="flex-row" id="post-meta"><span class="text created">发布于：<time datetime="2023-01-15T01:13:37.000Z">2023-01-15</time></span><span class="sep updated"></span><span class="text updated">更新于：<time datetime="2024-04-05T12:59:49.940Z">2024-04-05</time></span></div></div></div>
    
    <div class="bottom only-title">
      
      <div class="text-area">
        <h1 class="text title"><span>Linux内核进程管理原理详解(代码演示)</span></h1>
        
      </div>
    </div>
    
  </div>
  </div><article class="md-text content"><blockquote>
<p><strong>前言：</strong>Linux内核里大部分都是C语言。建议先看《Linux内核设计与实现(Linux Kernel Development)》,Robert Love，也就是LKD。</p>
</blockquote>
<p>Linux是一种动态系统，能够适应不断变化的计算需求。Linux计算需求的表现是以进程的通用抽象为中心的。进程可以是短期的（从命令行执行的一个命令），也可以是长期的（一种网络服务）。因此，对进程及其调度进行一般管理就显得极为重要。</p>
<p>在用户空间，进程是由进程标识符（PID）表示的。从用户的角度来看，一个 PID 是一个数字值，可惟一标识一个进程。一个 PID 在进程的整个生命期间不会更改，但 PID 可以在进程销毁后被重新使用，所以对它们进行缓存并不见得总是理想的。在用户空间，创建进程可以采用几种方式。可以 执行一个程序（这会导致新进程的创建），也可以 在程序内，调用一个 fork或 exec 系统调用。fork调用会导致创建一个子进程，而exec调用则会用新程序代替当前进程上下文。这里将对这几种方法进行讨论以便您能很好地理解它们的工作原理。</p>
<p>这里将按照下面的顺序展开对进程的介绍，首先展示进程的内核表示以及它们是如何在内核内被管理的，然后来看看进程创建和调度的各种方式（在一个或多个处理器上），最后介绍进程的销毁。内核的版本为2.6.32.45。</p>
<h2 id="1，进程描述符"><a href="#1，进程描述符" class="headerlink" title="1，进程描述符"></a>1，<strong>进程描述符</strong></h2><p>在Linux内核内，进程是由相当大的一个称为 task_struct 的结构表示的。此结构包含所有表示此进程所必需的数据，此外，还包含了大量的其他数据用来统计（accounting）和维护与其他进程的关系（如父和子）。task_struct 位于 .&#x2F;<a href="https://link.zhihu.com/?target=http://lib.csdn.net/base/linux">linux</a>&#x2F;include&#x2F;<a href="https://link.zhihu.com/?target=https://so.csdn.net/so/search?from=pc_blog_highlight&q=linux">linux</a>&#x2F;sched.h（注意.&#x2F;linux&#x2F;指向内核源代码树）。</p>
<p><strong>下面是task_struct结构：</strong></p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">struct</span> <span class="title class_">task_struct</span> &#123;  </span><br><span class="line">     <span class="keyword">volatile</span> <span class="type">long</span> state;    <span class="comment">/* -1 不可运行, 0 可运行, &gt;0 已停止 */</span>  </span><br><span class="line">     <span class="type">void</span> *stack;            <span class="comment">/* 堆栈 */</span>  </span><br><span class="line">     <span class="type">atomic_t</span> usage;  </span><br><span class="line">     <span class="type">unsigned</span> <span class="type">int</span> flags; <span class="comment">/* 一组标志 */</span>  </span><br><span class="line">     <span class="type">unsigned</span> <span class="type">int</span> ptrace;  </span><br><span class="line">     <span class="comment">/* ...  */</span>  </span><br><span class="line">   </span><br><span class="line">     <span class="type">int</span> prio, static_prio, normal_prio;  <span class="comment">/* 优先级  */</span>  </span><br><span class="line">    <span class="comment">/* ...  */</span>  </span><br><span class="line">  </span><br><span class="line">    <span class="keyword">struct</span> <span class="title class_">list_head</span> tasks;  <span class="comment">/* 执行的线程（可以有很多）  */</span>  </span><br><span class="line">    <span class="keyword">struct</span> <span class="title class_">plist_node</span> pushable_tasks;  </span><br><span class="line">  </span><br><span class="line">    <span class="keyword">struct</span> <span class="title class_">mm_struct</span> *mm, *active_mm;   <span class="comment">/* 内存页（进程地址空间）  */</span>  </span><br><span class="line">  </span><br><span class="line">    <span class="comment">/* 进行状态 */</span>  </span><br><span class="line">    <span class="type">int</span> exit_state;  </span><br><span class="line">    <span class="type">int</span> exit_code, exit_signal;  </span><br><span class="line">    <span class="type">int</span> pdeath_signal;  <span class="comment">/*  当父进程死亡时要发送的信号  */</span>  </span><br></pre></td></tr></table></figure>



<p><span style="font-family: Arial, Helvetica, sans-serif;"><em>&#x2F;* … *&#x2F;</em> </span></p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line">    <span class="type">pid_t</span> pid;  <span class="comment">/* 进程号 */</span>  </span><br><span class="line">    <span class="type">pid_t</span> tgid;  </span><br><span class="line"> </span><br><span class="line">    <span class="comment">/* ... */</span>  </span><br><span class="line">    <span class="keyword">struct</span> <span class="title class_">task_struct</span> *real_parent; <span class="comment">/* 实际父进程real parent process */</span>  </span><br><span class="line">    <span class="keyword">struct</span> <span class="title class_">task_struct</span> *parent; <span class="comment">/* SIGCHLD的接受者，由wait4()报告 */</span>  </span><br><span class="line">    <span class="keyword">struct</span> <span class="title class_">list_head</span> children;  <span class="comment">/* 子进程列表 */</span>  </span><br><span class="line">    <span class="keyword">struct</span> <span class="title class_">list_head</span> sibling;   <span class="comment">/* 兄弟进程列表 */</span>  </span><br><span class="line">    <span class="keyword">struct</span> <span class="title class_">task_struct</span> *group_leader;   <span class="comment">/* 线程组的leader */</span>  </span><br><span class="line">    <span class="comment">/* ... */</span>  </span><br><span class="line">  </span><br><span class="line">    <span class="type">char</span> comm[TASK_COMM_LEN]; <span class="comment">/* 可执行程序的名称（不包含路径） */</span>  </span><br><span class="line">    <span class="comment">/* 文件系统信息 */</span>  </span><br><span class="line">    <span class="type">int</span> link_count, total_link_count;  </span><br><span class="line">    <span class="comment">/* ... */</span>  </span><br><span class="line">  </span><br><span class="line">    <span class="comment">/* 特定CPU架构的状态 */</span>  </span><br><span class="line">    <span class="keyword">struct</span> <span class="title class_">thread_struct</span> thread;  </span><br><span class="line">   <span class="comment">/* 进程当前所在的目录描述 */</span>  </span><br><span class="line">     <span class="keyword">struct</span> <span class="title class_">fs_struct</span> *fs;  </span><br><span class="line">    <span class="comment">/* 打开的文件描述信息 */</span>  </span><br><span class="line">    <span class="keyword">struct</span> <span class="title class_">files_struct</span> *files;  </span><br><span class="line">    <span class="comment">/* ... */</span>  </span><br><span class="line">&#125;;  </span><br></pre></td></tr></table></figure>

<p>在task_struct结构中，可以看到几个预料之中的项，比如执行的状态、堆栈、一组标志、父进程、执行的线程（可以有很多）以及开放文件。state 变量是一些表明任务状态的比特位。最常见的状态有：TASK_RUNNING 表示进程正在运行，或是排在运行队列中正要运行；TASK_INTERRUPTIBLE 表示进程正在休眠、TASK_UNINTERRUPTIBLE表示进程正在休眠但不能叫醒；TASK_STOPPED 表示进程停止等等。这些标志的完整列表可以在 .&#x2F;linux&#x2F;include&#x2F;linux&#x2F;sched.h 内找到。</p>
<p>flags 定义了很多指示符，表明进程是否正在被创建（PF_STARTING）或退出（PF_EXITING），或是进程当前是否在分配内存（PF_MEMALLOC）。可执行程序的名称（不包含路径）占用 comm（命令）字段。每个进程都会被赋予优先级（称为 static_prio），但进程的实际优先级是基于加载以及其他几个因素动态决定的。优先级值越低，实际的优先级越高。tasks字段提供了链接列表的能力。它包含一个 prev 指针（指向前一个任务）和一个 next 指针（指向下一个任务）。</p>
<p>进程的地址空间由mm 和 active_mm 字段表示。mm代表的是进程的内存描述符，而 active_mm 则是前一个进程的内存描述符（为改进上下文切换时间的一种优化）。thread_struct thread结构则用来标识进程的存储状态，此元素依赖于Linux在其上运行的特定架构。例如对于x86架构，在.&#x2F;linux&#x2F;arch&#x2F;x86&#x2F;include&#x2F;asm&#x2F;processor.h的thread_struct结构中可以找到该进程自执行上下文切换后的存储（硬件注册表、程序计数器等）。</p>
<p><strong>代码如下：</strong></p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">struct</span> <span class="title class_">thread_struct</span> &#123;</span><br><span class="line">	<span class="comment">/* Cached TLS descriptors: */</span></span><br><span class="line">	<span class="keyword">struct</span> <span class="title class_">desc_struct</span>	tls_array[GDT_ENTRY_TLS_ENTRIES];</span><br><span class="line">	<span class="type">unsigned</span> <span class="type">long</span>		sp0;</span><br><span class="line">	<span class="type">unsigned</span> <span class="type">long</span>		sp;</span><br><span class="line"><span class="meta">#<span class="keyword">ifdef</span> CONFIG_X86_32</span></span><br><span class="line">	<span class="type">unsigned</span> <span class="type">long</span>		sysenter_cs;</span><br><span class="line"><span class="meta">#<span class="keyword">else</span></span></span><br><span class="line">	<span class="type">unsigned</span> <span class="type">long</span>		usersp;	<span class="comment">/* Copy from PDA */</span></span><br><span class="line">	<span class="type">unsigned</span> <span class="type">short</span>		es;</span><br><span class="line">	<span class="type">unsigned</span> <span class="type">short</span>		ds;</span><br><span class="line">	<span class="type">unsigned</span> <span class="type">short</span>		fsindex;</span><br><span class="line">	<span class="type">unsigned</span> <span class="type">short</span>		gsindex;</span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">ifdef</span> CONFIG_X86_32</span></span><br><span class="line">	<span class="type">unsigned</span> <span class="type">long</span>		ip;</span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line">	<span class="comment">/* ... */</span></span><br><span class="line"><span class="meta">#<span class="keyword">ifdef</span> CONFIG_X86_32</span></span><br><span class="line">	<span class="comment">/* Virtual 86 mode info */</span></span><br><span class="line">	<span class="keyword">struct</span> <span class="title class_">vm86_struct</span> __user *vm86_info;</span><br><span class="line">	<span class="type">unsigned</span> <span class="type">long</span>		screen_bitmap;</span><br><span class="line">	<span class="type">unsigned</span> <span class="type">long</span>		v86flags;</span><br><span class="line">	<span class="type">unsigned</span> <span class="type">long</span>		v86mask;</span><br><span class="line">	<span class="type">unsigned</span> <span class="type">long</span>		saved_sp0;</span><br><span class="line">	<span class="type">unsigned</span> <span class="type">int</span>		saved_fs;</span><br><span class="line">	<span class="type">unsigned</span> <span class="type">int</span>		saved_gs;</span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line">	<span class="comment">/* IO permissions: */</span></span><br><span class="line">	<span class="type">unsigned</span> <span class="type">long</span>		*io_bitmap_ptr;</span><br><span class="line">	<span class="type">unsigned</span> <span class="type">long</span>		iopl;</span><br><span class="line">	<span class="comment">/* Max allowed port in the bitmap, in bytes: */</span></span><br><span class="line">	<span class="type">unsigned</span>		io_bitmap_max;</span><br><span class="line"><span class="comment">/* MSR_IA32_DEBUGCTLMSR value to switch in if TIF_DEBUGCTLMSR is set.  */</span></span><br><span class="line">	<span class="type">unsigned</span> <span class="type">long</span>	debugctlmsr;</span><br><span class="line">	<span class="comment">/* Debug Store context; see asm/ds.h */</span></span><br><span class="line">	<span class="keyword">struct</span> <span class="title class_">ds_context</span>	*ds_ctx;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h2 id="2，进程管理"><a href="#2，进程管理" class="headerlink" title="2，进程管理"></a>2，进程管理</h2><p>在很多情况下，进程都是动态创建并由一个动态分配的 task_struct 表示。一个例外是init 进程本身，它总是存在并由一个静态分配的task_struct表示，参看.&#x2F;linux&#x2F;arch&#x2F;x86&#x2F;kernel&#x2F;init_task.c。</p>
<p><strong>代码如下：</strong></p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">static</span> <span class="keyword">struct</span> <span class="title class_">signal_struct</span> init_signals = <span class="built_in">INIT_SIGNALS</span>(init_signals);</span><br><span class="line"><span class="type">static</span> <span class="keyword">struct</span> <span class="title class_">sighand_struct</span> init_sighand = <span class="built_in">INIT_SIGHAND</span>(init_sighand);</span><br><span class="line"> </span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * 初始化线程结构</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">union</span> <span class="title class_">thread_union</span> init_thread_union __init_task_data =</span><br><span class="line">	&#123; <span class="built_in">INIT_THREAD_INFO</span>(init_task) &#125;;</span><br><span class="line"> </span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * 初始化init进程的结构。所有其他进程的结构将由fork.c中的slabs来分配</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">task_struct</span> init_task = <span class="built_in">INIT_TASK</span>(init_task);</span><br><span class="line"><span class="built_in">EXPORT_SYMBOL</span>(init_task);</span><br><span class="line"> </span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * per-CPU TSS segments. </span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="built_in">DEFINE_PER_CPU_SHARED_ALIGNED</span>(<span class="keyword">struct</span> tss_struct, init_tss) = INIT_TSS;</span><br></pre></td></tr></table></figure>

<p>注意进程虽然都是动态分配的，但还是需要考虑最大进程数。在内核内最大进程数是由一个称为max_threads的符号表示的，它可以在 .&#x2F;linux&#x2F;kernel&#x2F;fork.c 内找到。可以通过&#x2F;proc&#x2F;sys&#x2F;kernel&#x2F;threads-max 的 proc 文件系统从用户空间更改此值。</p>
<p>Linux 内所有进程的分配有两种方式。第一种方式是通过一个哈希表，由PID 值进行哈希计算得到；第二种方式是通过双链循环表。循环表非常适合于对任务列表进行迭代。由于列表是循环的，没有头或尾；但是由于 init_task 总是存在，所以可以将其用作继续向前迭代的一个锚点。让我们来看一个遍历当前任务集的例子。任务列表无法从用户空间访问，但该问题很容易解决，方法是以模块形式向内核内插入代码。下面给出一个很简单的程序，它会迭代任务列表并会提供有关每个任务的少量信息（name、pid和 parent 名）。注意，在这里，此模块使用 printk 来发出结果。要查看具体的结果，可以通过 cat 实用工具（或实时的 tail -f&#x2F;var&#x2F;log&#x2F;messages）查看 &#x2F;var&#x2F;log&#x2F;messages 文件。next_task函数是 sched.h 内的一个宏，它简化了任务列表的迭代（返回下一个任务的 task_struct 引用）。</p>
<p><strong>如下：</strong></p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">define</span> next_task(p) \</span></span><br><span class="line"><span class="meta">	list_entry_rcu((p)-&gt;tasks.next, struct task_struct, tasks)</span></span><br></pre></td></tr></table></figure>

<p><strong>查询任务列表信息的简单内核模块：</strong></p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">&lt;pre name=<span class="string">&quot;code&quot;</span> <span class="keyword">class</span>=<span class="string">&quot;cpp&quot;</span>&gt;<span class="meta">#<span class="keyword">include</span> <span class="string">&lt;linux/kernel.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;linux/module.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;linux/sched.h&gt;</span></span></span><br><span class="line"> </span><br><span class="line"><span class="type">int</span> <span class="built_in">init_module</span>(<span class="type">void</span>)</span><br><span class="line">&#123;</span><br><span class="line">	<span class="comment">/* Set up the anchor point */</span></span><br><span class="line">	<span class="keyword">struct</span> task_struct *task=&amp;init_task;</span><br><span class="line">	<span class="comment">/* Walk through the task list, until we hit the init_task again */</span></span><br><span class="line">	<span class="keyword">do</span> &#123;</span><br><span class="line">		<span class="built_in">printk</span>(KERN_INFO <span class="string">&quot;=== %s [%d] parent %s\n&quot;</span>,</span><br><span class="line">			task-&gt;comm,task-&gt;pid,task-&gt;parent-&gt;comm);</span><br><span class="line">	&#125; <span class="keyword">while</span>((task=<span class="built_in">next_task</span>(task))!=&amp;init_task);</span><br><span class="line">	</span><br><span class="line">	<span class="built_in">printk</span>(KERN_INFO <span class="string">&quot;Current task is %s [%d]\n&quot;</span>, current-&gt;comm,current-&gt;pid);</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">cleanup_module</span><span class="params">(<span class="type">void</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>编译此模块的Makefile文件如下：</strong></p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">obj-m += procsview.o</span><br><span class="line"> </span><br><span class="line">KDIR := /lib/modules/$(shell uname -r)/build</span><br><span class="line">PWD := $(shell pwd)</span><br><span class="line"> </span><br><span class="line"><span class="keyword">default</span>:</span><br><span class="line">	$(MAKE) -C $(KDIR) SUBDIRS=$(PWD) modules</span><br></pre></td></tr></table></figure>

<p>在编译后，可以用insmod procsview.ko 插入模块对象，也可以用 rmmod procsview 删除它。插入后，&#x2F;var&#x2F;log&#x2F;messages可显示输出，如下所示。从中可以看到，这里有一个空闲任务（称为 swapper）和init 任务（pid 1）。</p>
<blockquote>
<p>Dec 28 23:18:16 ubuntu kernel: [12128.910863]&#x3D;&#x3D;&#x3D; swapper [0] parent swapper<br>Dec 28 23:18:16 ubuntu kernel: [12128.910934]&#x3D;&#x3D;&#x3D; init [1] parent swapper<br>Dec 28 23:18:16 ubuntu kernel: [12128.910945]&#x3D;&#x3D;&#x3D; kthreadd [2] parent swapper<br>Dec 28 23:18:16 ubuntu kernel: [12128.910953]&#x3D;&#x3D;&#x3D; migration&#x2F;0 [3] parent kthreadd<br>……<br>Dec 28 23:24:12 ubuntu kernel: [12485.295015]Current task is insmod [6051]</p>
</blockquote>
<p>Linux 维护一个称为current的宏，标识当前正在运行的进程（类型是 task_struct）。模块尾部的那行prink用于输出当前进程的运行命令及进程号。注意到当前的任务是 insmod，这是因为 init_module 函数是在insmod 命令执行的上下文运行的。current 符号实际指的是一个函数（get_current），可在一个与 arch 有关的头部中找到它。比如 .&#x2F;linux&#x2F;arch&#x2F;x86&#x2F;include&#x2F;asm&#x2F;current.h，<strong>如下：</strong></p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;linux/compiler.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;asm/percpu.h&gt;</span></span></span><br><span class="line"> </span><br><span class="line"><span class="meta">#<span class="keyword">ifndef</span> __ASSEMBLY__</span></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">task_struct</span>;</span><br><span class="line"> </span><br><span class="line"><span class="built_in">DECLARE_PER_CPU</span>(<span class="keyword">struct</span> task_struct *, current_task);</span><br><span class="line"> </span><br><span class="line"><span class="type">static</span> __always_inline <span class="keyword">struct</span> <span class="title class_">task_struct</span> *<span class="built_in">get_current</span>(<span class="type">void</span>)</span><br><span class="line">&#123;</span><br><span class="line">	<span class="keyword">return</span> <span class="built_in">percpu_read_stable</span>(current_task);</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"><span class="meta">#<span class="keyword">define</span> current get_current()</span></span><br><span class="line"> </span><br><span class="line"><span class="meta">#<span class="keyword">endif</span> <span class="comment">/* __ASSEMBLY__ */</span></span></span><br><span class="line"> </span><br><span class="line"><span class="meta">#<span class="keyword">endif</span> <span class="comment">/* _ASM_X86_CURRENT_H */</span></span></span><br></pre></td></tr></table></figure>

<h2 id="3，进程创建"><a href="#3，进程创建" class="headerlink" title="3，进程创建"></a>3，<strong>进程创建</strong></h2><p>用户空间内可以通过执行一个程序、或者在程序内调用fork（或exec）系统调用来创建进程，fork调用会导致创建一个子进程，而exec调用则会用新程序代替当前进程上下文。一个新进程的诞生还可以分别通过vfork()和clone()。fork、vfork和clone三个用户态函数均由libc库提供，它们分别会调用Linux内核提供的同名系统调用fork,vfork和clone。下面以fork系统调用为例来介绍。</p>
<p>传统的创建一个新进程的方式是子进程拷贝父进程所有资源，这无疑使得进程的创建效率低，因为子进程需要拷贝父进程的整个地址空间。更糟糕的是，如果子进程创建后又立马去执行exec族函数，那么刚刚才从父进程那里拷贝的地址空间又要被清除以便装入新的进程映像。为了解决这个问题，<strong>内核中提供了上述三种不同的系统调用。</strong></p>
<ol>
<li>内核采用写时复制技术对传统的fork函数进行了下面的优化。即子进程创建后，父子以只读的方式共享父进程的资源（并不包括父进程的页表项）。当子进程需要修改进程地址空间的某一页时，才为子进程复制该页。采用这样的技术可以避免对父进程中某些数据不必要的复制。</li>
<li>使用vfork函数创建的子进程会完全共享父进程的地址空间，甚至是父进程的页表项。父子进程任意一方对任何数据的修改使得另一方都可以感知到。为了使得双方不受这种影响，vfork函数创建了子进程后，父进程便被阻塞直至子进程调用了exec()或exit()。由于现在fork函数引入了写时复制技术，在不考虑复制父进程页表项的情况下，vfork函数几乎不会被使用。</li>
<li>clone函数创建子进程时灵活度比较大，因为它可以通过传递不同的clone标志参数来选择性的复制父进程的资源。</li>
</ol>
<p>大部分系统调用对应的例程都被命名为 sys_* 并提供某些初始功能以实现调用（例如错误检查或用户空间的行为），实际的工作常常会委派给另外一个名为 do_* 的函数。</p>
<p>在.&#x2F;linux&#x2F;include&#x2F;asm-generic&#x2F;unistd.h中记录了所有的系统调用号及名称。注意fork实现与体系结构相关，对32位的x86系统会使用.&#x2F;linux&#x2F;arch&#x2F;x86&#x2F;include&#x2F;asm&#x2F;unistd_32.h中的定义，fork系统调用编号为2。</p>
<p><strong>fork系统调用在unistd.h中的宏关联如下：</strong></p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">define</span> __NR_fork 1079</span></span><br><span class="line"><span class="meta">#<span class="keyword">ifdef</span> CONFIG_MMU</span></span><br><span class="line">__SYSCALL(__NR_fork, sys_fork)</span><br><span class="line"><span class="meta">#<span class="keyword">else</span></span></span><br><span class="line">__SYSCALL(__NR_fork, sys_ni_syscall)</span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br></pre></td></tr></table></figure>

<p><strong>在unistd_32.h中的调用号关联为：</strong> #define __NR_fork 2</p>
<p>在很多情况下，用户空间任务和内核任务的底层机制是一致的。系统调用fork、vfork和clone在内核中对应的服务例程分别为sys_fork()，sys_vfork()和sys_clone()。它们最终都会依赖于一个名为do_fork 的函数来创建新进程。例如在创建内核线程时，内核会调用一个名为 kernel_thread 的函数（对32位系统）参见.&#x2F;linux&#x2F;arch&#x2F;x86&#x2F;kernel&#x2F;process_32.c，注意process.c是包含32&#x2F;64bit都适用的代码，process_32.c是特定于32位架构，process_64.c是特定于64位架构），此函数执行某些初始化后会调用 do_fork。创建用户空间进程的情况与此类似。在用户空间，一个程序会调用fork，通过int $0x80之类的软中断会导致对名为sys_fork的内核函数的系统调用（参见 .&#x2F;linux&#x2F;arch&#x2F;x86&#x2F;kernel&#x2F;process_32.c），如下：</p>
<figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">int sys_fork(struct pt_regs *regs)</span><br><span class="line">&#123;</span><br><span class="line">	return do_fork(SIGCHLD, regs-&gt;sp, regs, 0, NULL, NULL);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>最终都是直接调用do_fork。进程创建的函数层次结构如下图：</strong></p>
<p><img class="lazy" src="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII=" data-src="https://pic4.zhimg.com/v2-8ab27fddbeee6271cbad74129d3467a3_b.jpg" alt="动图封面"></p>
<p>进程创建的函数层次结构</p>
<p>从图中可以看到 do_fork 是进程创建的基础。可以在 .&#x2F;linux&#x2F;kernel&#x2F;fork.c 内找到 do_fork 函数（以及合作函数 copy_process）。</p>
<p>当用户态的进程调用一个系统调用时，CPU切换到内核态并开始执行一个内核函数。在X86体系中，可以通过两种不同的方式进入系统调用：执行int $0×80汇编命令和执行sysenter汇编命令。后者是Intel在Pentium II中引入的指令，内核从2.6版本开始支持这条命令。这里将集中讨论以int $0×80方式进入系统调用的过程。</p>
<p>通过int $0×80方式调用系统调用实际上是用户进程产生一个中断向量号为0×80的软中断。当用户态fork()调用发生时，用户态进程会保存调用号以及参数，然后发出int $0×80指令，陷入0x80中断。CPU将从用户态切换到内核态并开始执行system_call()。这个函数是通过汇编命令来实现的，它是0×80号软中断对应的中断处理程序。对于所有系统调用来说，它们都必须先进入system_call()，也就是所谓的系统调用处理程序。再通过系统调用号跳转到具体的系统调用服务例程处。32位x86系统的系统调用处理程序在.&#x2F;linux&#x2F;arch&#x2F;x86&#x2F;kernel&#x2F;entry_32.S中，代码如下：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br></pre></td><td class="code"><pre><span class="line">.macro SAVE_ALL</span><br><span class="line">	cld</span><br><span class="line">	PUSH_GS</span><br><span class="line">	pushl %fs</span><br><span class="line">	CFI_ADJUST_CFA_OFFSET <span class="number">4</span></span><br><span class="line">	<span class="comment">/*CFI_REL_OFFSET fs, 0;*/</span></span><br><span class="line">	pushl %es</span><br><span class="line">	CFI_ADJUST_CFA_OFFSET <span class="number">4</span></span><br><span class="line">	<span class="comment">/*CFI_REL_OFFSET es, 0;*/</span></span><br><span class="line">	pushl %ds</span><br><span class="line">	CFI_ADJUST_CFA_OFFSET <span class="number">4</span></span><br><span class="line">	<span class="comment">/*CFI_REL_OFFSET ds, 0;*/</span></span><br><span class="line">	pushl %eax</span><br><span class="line">	CFI_ADJUST_CFA_OFFSET <span class="number">4</span></span><br><span class="line">	CFI_REL_OFFSET eax, <span class="number">0</span></span><br><span class="line">	pushl %ebp</span><br><span class="line">	CFI_ADJUST_CFA_OFFSET <span class="number">4</span></span><br><span class="line">	CFI_REL_OFFSET ebp, <span class="number">0</span></span><br><span class="line">	pushl %edi</span><br><span class="line">	CFI_ADJUST_CFA_OFFSET <span class="number">4</span></span><br><span class="line">	CFI_REL_OFFSET edi, <span class="number">0</span></span><br><span class="line">	pushl %esi</span><br><span class="line">	CFI_ADJUST_CFA_OFFSET <span class="number">4</span></span><br><span class="line">	CFI_REL_OFFSET esi, <span class="number">0</span></span><br><span class="line">	pushl %edx</span><br><span class="line">	CFI_ADJUST_CFA_OFFSET <span class="number">4</span></span><br><span class="line">	CFI_REL_OFFSET edx, <span class="number">0</span></span><br><span class="line">	pushl %ecx</span><br><span class="line">	CFI_ADJUST_CFA_OFFSET <span class="number">4</span></span><br><span class="line">	CFI_REL_OFFSET ecx, <span class="number">0</span></span><br><span class="line">	pushl %ebx</span><br><span class="line">	CFI_ADJUST_CFA_OFFSET <span class="number">4</span></span><br><span class="line">	CFI_REL_OFFSET ebx, <span class="number">0</span></span><br><span class="line">	movl $(__USER_DS), %edx</span><br><span class="line">	movl %edx, %ds</span><br><span class="line">	movl %edx, %es</span><br><span class="line">	movl $(__KERNEL_PERCPU), %edx</span><br><span class="line">	movl %edx, %fs</span><br><span class="line">	SET_KERNEL_GS %edx</span><br><span class="line">.endm</span><br><span class="line"><span class="comment">/* ... */</span></span><br><span class="line"><span class="built_in">ENTRY</span>(system_call)</span><br><span class="line">	RING0_INT_FRAME			# 无论如何不能进入用户空间</span><br><span class="line">	pushl %eax			# 将保存的系统调用编号压入栈中</span><br><span class="line">	CFI_ADJUST_CFA_OFFSET <span class="number">4</span></span><br><span class="line">	<span class="function">SAVE_ALL</span></span><br><span class="line"><span class="function">	<span class="title">GET_THREAD_INFO</span><span class="params">(%ebp)</span></span></span><br><span class="line"><span class="function">					# 检测进程是否被跟踪</span></span><br><span class="line"><span class="function">	testl $_TIF_WORK_SYSCALL_ENTRY,<span class="title">TI_flags</span><span class="params">(%ebp)</span></span></span><br><span class="line"><span class="function">	jnz syscall_trace_entry</span></span><br><span class="line"><span class="function">	cmpl $<span class="params">(nr_syscalls)</span>, %eax</span></span><br><span class="line"><span class="function">	jae syscall_badsys</span></span><br><span class="line"><span class="function">syscall_call:</span></span><br><span class="line"><span class="function">	call *sys_call_table(,%eax,<span class="number">4</span>)	# 跳入对应服务例程</span></span><br><span class="line"><span class="function">	movl %eax,PT_EAX(%esp)		# 保存进程的返回值</span></span><br><span class="line"><span class="function">syscall_exit:</span></span><br><span class="line"><span class="function">	LOCKDEP_SYS_EXIT</span></span><br><span class="line"><span class="function">	DISABLE_INTERRUPTS(CLBR_ANY)	# 不要忘了在中断返回前关闭中断</span></span><br><span class="line"><span class="function">	TRACE_IRQS_OFF</span></span><br><span class="line"><span class="function">	movl TI_flags(%ebp), %ecx</span></span><br><span class="line"><span class="function">	testl $_TIF_ALLWORK_MASK, %ecx	# current-&gt;work</span></span><br><span class="line"><span class="function">	jne syscall_exit_work</span></span><br><span class="line"><span class="function">restore_all:</span></span><br><span class="line"><span class="function">	TRACE_IRQS_IRET</span></span><br><span class="line"><span class="function">restore_all_notrace:</span></span><br><span class="line"><span class="function">	movl PT_EFLAGS(%esp), %eax	# mix EFLAGS, SS and CS</span></span><br><span class="line"><span class="function">	# Warning: PT_OLDSS(%esp) contains the wrong/random values if we</span></span><br><span class="line"><span class="function">	# are returning to the kernel.</span></span><br><span class="line"><span class="function">	# See comments in process.c:copy_thread() for details.</span></span><br><span class="line"><span class="function">	movb PT_OLDSS(%esp), %ah</span></span><br><span class="line"><span class="function">	movb PT_CS(%esp), %al</span></span><br><span class="line"><span class="function">	andl $(X86_EFLAGS_VM | (SEGMENT_TI_MASK &lt;&lt; <span class="number">8</span>) | SEGMENT_RPL_MASK), %eax</span></span><br><span class="line"><span class="function">	cmpl $((SEGMENT_LDT &lt;&lt; <span class="number">8</span>) | USER_RPL), %eax</span></span><br><span class="line"><span class="function">	CFI_REMEMBER_STATE</span></span><br><span class="line"><span class="function">	je ldt_ss			# returning to user-space with LDT SS</span></span><br><span class="line"><span class="function">restore_nocheck:</span></span><br><span class="line"><span class="function">	RESTORE_REGS <span class="number">4</span>			# skip orig_eax/error_code</span></span><br><span class="line"><span class="function">	CFI_ADJUST_CFA_OFFSET <span class="number">-4</span></span></span><br><span class="line"><span class="function">irq_return:</span></span><br><span class="line"><span class="function">	INTERRUPT_RETURN</span></span><br><span class="line"><span class="function">.section .fixup,<span class="string">&quot;ax&quot;</span></span></span><br></pre></td></tr></table></figure>

<p><strong>分析：</strong></p>
<p>（1）在system_call函数执行之前，CPU控制单元已经将eflags、cs、eip、ss和esp寄存器的值自动保存到该进程对应的内核栈中。随之，在 system_call内部首先将存储在eax寄存器中的系统调用号压入栈中。接着执行SAVE_ALL宏。该宏在栈中保存接下来的系统调用可能要用到的所有CPU寄存器。</p>
<p>（2）通过GET_THREAD_INFO宏获得当前进程的thread_inof结构的地址；再检测当前进程是否被其他进程所跟踪(例如调试一个程序时，被调试的程序就处于被跟踪状态)，也就是thread_info结构中flag字段的_TIF_ALLWORK_MASK被置1。如果发生被跟踪的情况则转向syscall_trace_entry标记的处理命令处。</p>
<p>（3）对用户态进程传递过来的系统调用号的合法性进行检查。如果不合法则跳入到syscall_badsys标记的命令处。</p>
<p>（4）如果系统调用好合法，则根据系统调用号查找.&#x2F;linux&#x2F;arch&#x2F;x86&#x2F;kernel&#x2F;syscall_table_32.S中的系统调用表sys_call_table，找到相应的函数入口点，跳入sys_fork这个服务例程当中。由于 sys_call_table表的表项占4字节，因此获得服务例程指针的具体方法是将由eax保存的系统调用号乘以4再与sys_call_table表的基址相加。</p>
<p><strong>syscall_table_32.S中的代码如下：</strong></p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">ENTRY</span>(sys_call_table)</span><br><span class="line">	.<span class="type">long</span> sys_restart_syscall	<span class="comment">/* 0 - old &quot;setup()&quot; system call, used for restarting */</span></span><br><span class="line">	.<span class="type">long</span> sys_exit</span><br><span class="line">	.<span class="type">long</span> ptregs_fork</span><br><span class="line">	.<span class="type">long</span> sys_read</span><br><span class="line">	.<span class="type">long</span> sys_write</span><br><span class="line">	.<span class="type">long</span> sys_open		<span class="comment">/* 5 */</span></span><br><span class="line">	.<span class="type">long</span> sys_close</span><br><span class="line">	<span class="comment">/* ... */</span></span><br></pre></td></tr></table></figure>

<p>sys_call_table是系统调用多路分解表，使用 eax 中提供的索引来确定要调用该表中的哪个系统调用。</p>
<p>（5）当系统调用服务例程结束时，从eax寄存器中获得当前进程的的返回值，并把这个返回值存放在曾保存用户态eax寄存器值的那个栈单元的位置上。这样，用户态进程就可以在eax寄存器中找到系统调用的返回码。</p>
<p>经过的调用链为fork()—&gt;int$0×80软中断—&gt;ENTRY(system_call)—&gt;ENTRY(sys_call_table)—&gt;sys_fork()—&gt;do_fork()。实际上fork、vfork和clone三个系统调最终都是调用do_fork()。只不过在调用时所传递的参数有所不同，而参数的不同正好导致了子进程与父进程之间对资源的共享程度不同。因此，分析do_fork()成为我们的首要任务。在进入do_fork函数进行分析之前，很有必要了解一下它的参数。</p>
<p>clone_flags：该标志位的4个字节分为两部分。最低的一个字节为子进程结束时发送给父进程的信号代码，通常为SIGCHLD；剩余的三个字节则是各种clone标志的组合（本文所涉及的标志含义详见下表），也就是若干个标志之间的或运算。通过 clone标志可以有选择的对父进程的资源进行复制。</p>
<p><strong>本文所涉及到的clone标志详见下表：</strong></p>
<p><img class="lazy" src="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII=" data-src="https://pic2.zhimg.com/v2-3c5e230e7cf07cefad9b856ae3dd2c6d_b.jpg" alt="动图封面"></p>
<ul>
<li><strong>stack_start：</strong>子进程用户态堆栈的地址。</li>
<li><strong>regs：</strong>指向pt_regs结构体的指针。当系统发生系统调用，即用户进程从用户态切换到内核态时，该结构体保存通用寄存器中的值，并被存放于内核态的堆栈中。</li>
<li><strong>stack_size：</strong>未被使用，通常被赋值为0。</li>
<li><strong>parent_tidptr：</strong>父进程在用户态下pid的地址，该参数在CLONE_PARENT_SETTID标志被设定时有意义。</li>
<li><strong>child_tidptr：</strong>子进程在用户态下pid的地址，该参数在CLONE_CHILD_SETTID标志被设定时有意义。</li>
<li>do_fork函数在.&#x2F;linux&#x2F;kernel&#x2F;fork.c中，主要工作就是复制原来的进程成为另一个新的进程，它完成了整个进程创建中的大部分工作。</li>
</ul>
<p><strong>代码如下：</strong></p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">long</span> <span class="title">do_fork</span><span class="params">(<span class="type">unsigned</span> <span class="type">long</span> clone_flags,</span></span></span><br><span class="line"><span class="params"><span class="function">	      <span class="type">unsigned</span> <span class="type">long</span> stack_start,</span></span></span><br><span class="line"><span class="params"><span class="function">	      <span class="keyword">struct</span> pt_regs *regs,</span></span></span><br><span class="line"><span class="params"><span class="function">	      <span class="type">unsigned</span> <span class="type">long</span> stack_size,</span></span></span><br><span class="line"><span class="params"><span class="function">	      <span class="type">int</span> __user *parent_tidptr,</span></span></span><br><span class="line"><span class="params"><span class="function">	      <span class="type">int</span> __user *child_tidptr)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">struct</span> <span class="title class_">task_struct</span> *p;</span><br><span class="line">	<span class="type">int</span> trace = <span class="number">0</span>;</span><br><span class="line">	<span class="type">long</span> nr;</span><br><span class="line"> </span><br><span class="line">	<span class="comment">/*</span></span><br><span class="line"><span class="comment">	 * 做一些预先的参数和权限检查</span></span><br><span class="line"><span class="comment">	 */</span></span><br><span class="line">	<span class="keyword">if</span> (clone_flags &amp; CLONE_NEWUSER) &#123;</span><br><span class="line">		<span class="keyword">if</span> (clone_flags &amp; CLONE_THREAD)</span><br><span class="line">			<span class="keyword">return</span> -EINVAL;</span><br><span class="line">		<span class="comment">/* 希望当用户名称被支持时，这里的检查可去掉</span></span><br><span class="line"><span class="comment">		 */</span></span><br><span class="line">		<span class="keyword">if</span> (!<span class="built_in">capable</span>(CAP_SYS_ADMIN) || !<span class="built_in">capable</span>(CAP_SETUID) ||</span><br><span class="line">				!<span class="built_in">capable</span>(CAP_SETGID))</span><br><span class="line">			<span class="keyword">return</span> -EPERM;</span><br><span class="line">	&#125;</span><br><span class="line"> </span><br><span class="line">	<span class="comment">/*</span></span><br><span class="line"><span class="comment">	 * 希望在2.6.26之后这些标志能实现循环</span></span><br><span class="line"><span class="comment">	 */</span></span><br><span class="line">	<span class="keyword">if</span> (<span class="built_in">unlikely</span>(clone_flags &amp; CLONE_STOPPED)) &#123;</span><br><span class="line">		<span class="type">static</span> <span class="type">int</span> __read_mostly count = <span class="number">100</span>;</span><br><span class="line"> </span><br><span class="line">		<span class="keyword">if</span> (count &gt; <span class="number">0</span> &amp;&amp; <span class="built_in">printk_ratelimit</span>()) &#123;</span><br><span class="line">			<span class="type">char</span> comm[TASK_COMM_LEN];</span><br><span class="line"> </span><br><span class="line">			count--;</span><br><span class="line">			<span class="built_in">printk</span>(KERN_INFO <span class="string">&quot;fork(): process `%s&#x27; used deprecated &quot;</span></span><br><span class="line">					<span class="string">&quot;clone flags 0x%lx\n&quot;</span>,</span><br><span class="line">				<span class="built_in">get_task_comm</span>(comm, current),</span><br><span class="line">				clone_flags &amp; CLONE_STOPPED);</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line"> </span><br><span class="line">	<span class="comment">/*</span></span><br><span class="line"><span class="comment">	 * 当从kernel_thread调用本do_fork时，不使用跟踪</span></span><br><span class="line"><span class="comment">	 */</span></span><br><span class="line">	<span class="keyword">if</span> (<span class="built_in">likely</span>(<span class="built_in">user_mode</span>(regs)))	<span class="comment">/* 如果从用户态进入本调用，则使用跟踪 */</span></span><br><span class="line">		trace = <span class="built_in">tracehook_prepare_clone</span>(clone_flags);</span><br><span class="line"> </span><br><span class="line">	p = <span class="built_in">copy_process</span>(clone_flags, stack_start, regs, stack_size,</span><br><span class="line">			 child_tidptr, <span class="literal">NULL</span>, trace);</span><br><span class="line">	<span class="comment">/*</span></span><br><span class="line"><span class="comment">	 * 在唤醒新线程之前做下面的工作，因为新线程唤醒后本线程指针会变成无效（如果退出很快的话）</span></span><br><span class="line"><span class="comment">	 */</span></span><br><span class="line">	<span class="keyword">if</span> (!<span class="built_in">IS_ERR</span>(p)) &#123;</span><br><span class="line">		<span class="keyword">struct</span> <span class="title class_">completion</span> vfork;</span><br><span class="line"> </span><br><span class="line">		<span class="built_in">trace_sched_process_fork</span>(current, p);</span><br><span class="line"> </span><br><span class="line">		nr = <span class="built_in">task_pid_vnr</span>(p);</span><br><span class="line"> </span><br><span class="line">		<span class="keyword">if</span> (clone_flags &amp; CLONE_PARENT_SETTID)</span><br><span class="line">			<span class="built_in">put_user</span>(nr, parent_tidptr);</span><br><span class="line"> </span><br><span class="line">		<span class="keyword">if</span> (clone_flags &amp; CLONE_VFORK) &#123;</span><br><span class="line">			p-&gt;vfork_done = &amp;vfork;</span><br><span class="line">			<span class="built_in">init_completion</span>(&amp;vfork);</span><br><span class="line">		&#125;</span><br><span class="line"> </span><br><span class="line">		<span class="built_in">audit_finish_fork</span>(p);</span><br><span class="line">		<span class="built_in">tracehook_report_clone</span>(regs, clone_flags, nr, p);</span><br><span class="line"> </span><br><span class="line">		<span class="comment">/*</span></span><br><span class="line"><span class="comment">		 * 我们在创建时设置PF_STARTING，以防止跟踪进程想使用这个标志来区分一个完全活着的进程</span></span><br><span class="line"><span class="comment">		 * 和一个还没有获得trackhook_report_clone()的进程。现在我们清除它并且设置子进程运行</span></span><br><span class="line"><span class="comment">		 */</span></span><br><span class="line">		p-&gt;flags &amp;= ~PF_STARTING;</span><br><span class="line"> </span><br><span class="line">		<span class="keyword">if</span> (<span class="built_in">unlikely</span>(clone_flags &amp; CLONE_STOPPED)) &#123;</span><br><span class="line">			<span class="comment">/*</span></span><br><span class="line"><span class="comment">			 * 我们将立刻启动一个即时的SIGSTOP</span></span><br><span class="line"><span class="comment">			 */</span></span><br><span class="line">			<span class="built_in">sigaddset</span>(&amp;p-&gt;pending.signal, SIGSTOP);</span><br><span class="line">			<span class="built_in">set_tsk_thread_flag</span>(p, TIF_SIGPENDING);</span><br><span class="line">			__set_task_state(p, TASK_STOPPED);</span><br><span class="line">		&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">			<span class="built_in">wake_up_new_task</span>(p, clone_flags);</span><br><span class="line">		&#125;</span><br><span class="line"> </span><br><span class="line">		<span class="built_in">tracehook_report_clone_complete</span>(trace, regs,</span><br><span class="line">						clone_flags, nr, p);</span><br><span class="line"> </span><br><span class="line">		<span class="keyword">if</span> (clone_flags &amp; CLONE_VFORK) &#123;</span><br><span class="line">			<span class="built_in">freezer_do_not_count</span>();</span><br><span class="line">			<span class="built_in">wait_for_completion</span>(&amp;vfork);</span><br><span class="line">			<span class="built_in">freezer_count</span>();</span><br><span class="line">			<span class="built_in">tracehook_report_vfork_done</span>(p, nr);</span><br><span class="line">		&#125;</span><br><span class="line">	&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">		nr = <span class="built_in">PTR_ERR</span>(p);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> nr;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>（1）在一开始，该函数定义了一个task_struct类型的指针p，用来接收即将为新进程（子进程）所分配的进程描述符。trace表示跟踪状态，nr表示新进程的pid。接着做一些预先的参数和权限检查。</p>
<p>（2）接下来检查clone_flags是否设置了CLONE_STOPPED标志。如果设置了，则做相应处理，打印消息说明进程已过时。通常这样的情况很少发生，因此在判断时使用了unlikely修饰符。使用该修饰符的判断语句执行结果与普通判断语句相同，只不过在执行效率上有所不同。正如该单词的含义所表示的那样，当前进程很少为停止状态。因此，编译器尽量不会把if内的语句与当前语句之前的代码编译在一起，以增加cache的命中率。与此相反，likely修饰符则表示所修饰的代码很可能发生。tracehook_prepare_clone用于设置子进程是否被跟踪。所谓跟踪，最常见的例子就是处于调试状态下的进程被debugger进程所跟踪。进程的ptrace字段非0说明debugger程序正在跟踪它。如果调用是从用户态进来的（而不从kernel_thread进来的），且当前进程（父进程）被另外一个进程所跟踪，那么子进程也要设置为被跟踪，并且将跟踪标志CLONE_PTRACE加入标志变量clone_flags中。如果父进程不被跟踪，则子进程也不会被跟踪，设置好后返回trace。</p>
<p>（3）接下来的这条语句要做的是整个创建过程中最核心的工作：通过copy_process()创建子进程的描述符，分配pid，并创建子进程执行时所需的其他数据结构，最终则会返回这个创建好的进程描述符p。该函数中的参数意义与do_fork函数相同。注意原来内核中为子进程分配pid的工作是在do_fork中完成，现在新的内核已经移到copy_process中了。</p>
<p>（4）如果copy_process函数执行成功，那么将继续执行if(!IS_ERR(p))部分。首先定义了一个完成量vfork，用task_pid_vnr(p)从p中获取新进程的pid。如果clone_flags包含CLONE_VFORK标志，那么将进程描述符中的vfork_done字段指向这个完成量，之后再对vfork完成量进行初始化。完成量的作用是，直到任务A发出信号通知任务B发生了某个特定事件时，任务B才会开始执行，否则任务B一直等待。我们知道，如果使用vfork系统调用来创建子进程，那么必然是子进程先执行。究其原因就是此处vfork完成量所起到的作用。当子进程调用exec函数或退出时就向父进程发出信号，此时父进程才会被唤醒，否则一直等待。此处的代码只是对完成量进行初始化，具体的阻塞语句则在后面的代码中有所体现。</p>
<p>（5）如果子进程被跟踪或者设置了CLONE_STOPPED标志，那么通过sigaddset函数为子进程增加挂起信号，并将子进程的状态设置为TASK_STOPPED。signal对应一个unsignedlong类型的变量，该变量的每个位分别对应一种信号。具体的操作是将SIGSTOP信号所对应的那一位置1。如果子进程并未设置CLONE_STOPPED标志，那么通过wake_up_new_task将进程放到运行队列上，从而让调度器进行调度运行。wake_up_new_task()在.&#x2F;linux&#x2F;kernel&#x2F;sched.c中，用于唤醒第一次新创建的进程，它将为新进程做一些初始的必须的调度器统计操作，然后把进程放到运行队列中。一旦当然正在运行的进程时间片用完（通过时钟tick中断来控制），就会调用schedule()，从而进行进程调度。</p>
<p><strong>代码如下：</strong></p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">wake_up_new_task</span><span class="params">(<span class="keyword">struct</span> task_struct *p, <span class="type">unsigned</span> <span class="type">long</span> clone_flags)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="type">unsigned</span> <span class="type">long</span> flags;</span><br><span class="line">	<span class="keyword">struct</span> <span class="title class_">rq</span> *rq;</span><br><span class="line">	<span class="type">int</span> cpu = <span class="built_in">get_cpu</span>();</span><br><span class="line"> </span><br><span class="line"><span class="meta">#<span class="keyword">ifdef</span> CONFIG_SMP</span></span><br><span class="line">	rq = <span class="built_in">task_rq_lock</span>(p, &amp;flags);</span><br><span class="line">	p-&gt;state = TASK_WAKING;</span><br><span class="line"> </span><br><span class="line">	<span class="comment">/*</span></span><br><span class="line"><span class="comment">	 * Fork balancing, do it here and not earlier because:</span></span><br><span class="line"><span class="comment">	 *  - cpus_allowed can change in the fork path</span></span><br><span class="line"><span class="comment">	 *  - any previously selected cpu might disappear through hotplug</span></span><br><span class="line"><span class="comment">	 *</span></span><br><span class="line"><span class="comment">	 * We set TASK_WAKING so that select_task_rq() can drop rq-&gt;lock</span></span><br><span class="line"><span class="comment">	 * without people poking at -&gt;cpus_allowed.</span></span><br><span class="line"><span class="comment">	 */</span></span><br><span class="line">	cpu = <span class="built_in">select_task_rq</span>(rq, p, SD_BALANCE_FORK, <span class="number">0</span>);</span><br><span class="line">	<span class="built_in">set_task_cpu</span>(p, cpu);</span><br><span class="line"> </span><br><span class="line">	p-&gt;state = TASK_RUNNING;</span><br><span class="line">	<span class="built_in">task_rq_unlock</span>(rq, &amp;flags);</span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line"> </span><br><span class="line">	rq = <span class="built_in">task_rq_lock</span>(p, &amp;flags);</span><br><span class="line">	<span class="built_in">update_rq_clock</span>(rq);</span><br><span class="line">	<span class="built_in">activate_task</span>(rq, p, <span class="number">0</span>);</span><br><span class="line">	<span class="built_in">trace_sched_wakeup_new</span>(rq, p, <span class="number">1</span>);</span><br><span class="line">	<span class="built_in">check_preempt_curr</span>(rq, p, WF_FORK);</span><br><span class="line"><span class="meta">#<span class="keyword">ifdef</span> CONFIG_SMP</span></span><br><span class="line">	<span class="keyword">if</span> (p-&gt;sched_class-&gt;task_woken)</span><br><span class="line">		p-&gt;sched_class-&gt;<span class="built_in">task_woken</span>(rq, p);</span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line">	<span class="built_in">task_rq_unlock</span>(rq, &amp;flags);</span><br><span class="line">	<span class="built_in">put_cpu</span>();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这里先用get_cpu()获取CPU，如果是对称多处理系统（SMP），先设置我为TASK_WAKING状态，由于有多个CPU（每个CPU上都有一个运行队列），需要进行负载均衡，选择一个最佳CPU并设置我使用这个CPU，然后设置我为TASK_RUNNING状态。这段操作是互斥的，因此需要加锁。注意TASK_RUNNING并不表示进程一定正在运行，无论进程是否正在占用CPU，只要具备运行条件，都处于该状态。 Linux把处于该状态的所有PCB组织成一个可运行队列run_queue，调度程序从这个队列中选择进程运行。事实上，Linux是将就绪态和运行态合并为了一种状态。然后用.&#x2F;linux&#x2F;kernel&#x2F;sched.c:activate_task()把当前进程插入到对应CPU的runqueue上，最终完成入队的函数是active_task()—&gt;enqueue_task()，其中核心代码行为：p-&gt;sched_class-&gt;enqueue_task(rq, p,wakeup, head);sched_class在.&#x2F;linux&#x2F;include&#x2F;linux&#x2F;sched.h中，是调度器一系列操作的面向对象抽象，这个类包括进程入队、出队、进程运行、进程切换等接口，用于完成对进程的调度运行。</p>
<p>（6）tracehook_report_clone_complete函数用于在进程复制快要完成时报告跟踪情况。如果父进程被跟踪，则将子进程的pid赋值给父进程的进程描述符的pstrace_message字段，并向父进程的父进程发送SIGCHLD信号。</p>
<p>（7）如果CLONE_VFORK标志被设置，则通过wait操作将父进程阻塞，直至子进程调用exec函数或者退出。</p>
<p>（8）如果copy_process()在执行的时候发生错误，则先释放已分配的pid，再根据PTR_ERR()的返回值得到错误代码，保存于nr中。</p>
<hr>
<p>版权声明：本文为知乎博主「玩转Linux内核」的原创文章，遵循CC 4.0 BY-SA版权协议，转载请附上原文出处链接及本声明。<br>原文链接：<a target="_blank" rel="noopener" href="https://zhuanlan.zhihu.com/p/425886322">https://zhuanlan.zhihu.com/p/425886322</a></p>

<div class="article-footer fs14">
    <section id="license">
      <div class="header"><span>许可协议</span></div>
      <div class="body"><p>本文采用 <a target="_blank" rel="noopener" href="https://creativecommons.org/licenses/by-nc-sa/4.0/">署名-非商业性使用-相同方式共享 4.0 国际</a> 许可协议，转载请注明出处。</p>
</div>
    </section>
    </div>
</article>
<div class="related-wrap" id="read-next"><section class="body"><div class="item" id="prev"><div class="note">较新文章</div><a href="/2023/01/15/linux-docs/%E8%BF%9B%E7%A8%8B%E7%AE%A1%E7%90%86/Linux%E5%86%85%E6%A0%B8%E8%BF%9B%E7%A8%8B%E7%AE%A1%E7%90%86%E5%87%A0%E7%A7%8D%E8%BF%9B%E7%A8%8B%E7%8A%B6%E6%80%81/">Linux内核进程管理几种进程状态</a></div><div class="item" id="next"><div class="note">较早文章</div><a href="/2023/01/15/linux-docs/%E8%BF%9B%E7%A8%8B%E7%AE%A1%E7%90%86/Linux%E5%86%85%E6%A0%B8%E8%BF%9B%E7%A8%8B%E7%AE%A1%E7%90%86%E5%B9%B6%E5%8F%91%E5%90%8C%E6%AD%A5%E4%B8%8E%E5%8E%9F%E5%AD%90%E6%93%8D%E4%BD%9C/">Linux内核进程管理并发同步与原子操作</a></div></section></div>






<footer class="page-footer footnote"><hr><div class="sitemap"><div class="sitemap-group"><span class="fs15">博客</span><a href="/">近期</a><a href="/">分类</a><a href="/">标签</a><a href="/">归档</a></div><div class="sitemap-group"><span class="fs15">项目</span><a href="/">开源库</a></div><div class="sitemap-group"><span class="fs15">社交</span><a href="/">友链</a><a href="/">留言板</a></div><div class="sitemap-group"><span class="fs15">更多</span><a href="/">关于本站</a><a href="/">GitHub</a></div></div><div class="text"><p>本站由 <a href="/">ysme</a> 使用 <a target="_blank" rel="noopener" href="https://github.com/xaoxuu/hexo-theme-stellar/tree/1.27.0">Stellar 1.27.0</a> 主题创建。<br>本博客所有文章除特别声明外，均采用 <a target="_blank" rel="noopener" href="https://creativecommons.org/licenses/by-nc-sa/4.0/">CC BY-NC-SA 4.0</a> 许可协议，转载请注明出处。</p>
</div></footer>
<div class="main-mask" onclick="sidebar.dismiss()"></div></div><aside class="l_right">
<div class="widgets">



<widget class="widget-wrapper toc" id="data-toc" collapse="false"><div class="widget-header dis-select"><span class="name">本文目录</span><a class="cap-action" onclick="sidebar.toggleTOC()" ><svg xmlns="http://www.w3.org/2000/svg" width="32" height="32" viewBox="0 0 24 24"><path fill="none" stroke="currentColor" stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M10 6h11m-11 6h11m-11 6h11M4 6h1v4m-1 0h2m0 8H4c0-1 2-2 2-3s-1-1.5-2-1"/></svg></a></div><div class="widget-body"><ol class="toc"><li class="toc-item toc-level-2"><a class="toc-link" href="#1%EF%BC%8C%E8%BF%9B%E7%A8%8B%E6%8F%8F%E8%BF%B0%E7%AC%A6"><span class="toc-text">1，进程描述符</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#2%EF%BC%8C%E8%BF%9B%E7%A8%8B%E7%AE%A1%E7%90%86"><span class="toc-text">2，进程管理</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#3%EF%BC%8C%E8%BF%9B%E7%A8%8B%E5%88%9B%E5%BB%BA"><span class="toc-text">3，进程创建</span></a></li></ol></div><div class="widget-footer">

<a class="top" onclick="util.scrollTop()"><svg xmlns="http://www.w3.org/2000/svg" width="32" height="32" viewBox="0 0 24 24"><g fill="none" stroke="currentColor" stroke-width="1.5"><path d="M2 12c0-4.714 0-7.071 1.464-8.536C4.93 2 7.286 2 12 2c4.714 0 7.071 0 8.535 1.464C22 4.93 22 7.286 22 12c0 4.714 0 7.071-1.465 8.535C19.072 22 16.714 22 12 22s-7.071 0-8.536-1.465C2 19.072 2 16.714 2 12Z"/><path stroke-linecap="round" stroke-linejoin="round" d="m9 15.5l3-3l3 3m-6-4l3-3l3 3"/></g></svg><span>回到顶部</span></a></div></widget>
</div></aside><div class='float-panel blur'>
  <button type='button' style='display:none' class='laptop-only rightbar-toggle mobile' onclick='sidebar.rightbar()'>
    <svg xmlns="http://www.w3.org/2000/svg" width="32" height="32" viewBox="0 0 24 24"><path fill="none" stroke="currentColor" stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M10 6h11m-11 6h11m-11 6h11M4 6h1v4m-1 0h2m0 8H4c0-1 2-2 2-3s-1-1.5-2-1"/></svg>
  </button>
  <button type='button' style='display:none' class='mobile-only leftbar-toggle mobile' onclick='sidebar.leftbar()'>
    <svg xmlns="http://www.w3.org/2000/svg" width="32" height="32" viewBox="0 0 24 24"><g fill="none" stroke="currentColor" stroke-width="1.5"><path d="M2 11c0-3.771 0-5.657 1.172-6.828C4.343 3 6.229 3 10 3h4c3.771 0 5.657 0 6.828 1.172C22 5.343 22 7.229 22 11v2c0 3.771 0 5.657-1.172 6.828C19.657 21 17.771 21 14 21h-4c-3.771 0-5.657 0-6.828-1.172C2 18.657 2 16.771 2 13z"/><path id="sep" stroke-linecap="round" d="M5.5 10h6m-5 4h4m4.5 7V3"/></g></svg>
  </button>
</div>
</div><div class="scripts">
<script type="text/javascript">
  const ctx = {
    date_suffix: {
      just: `刚刚`,
      min: `分钟前`,
      hour: `小时前`,
      day: `天前`,
    },
    root : `/`,
  };

  // required plugins (only load if needs)
  if (`local_search`) {
    ctx.search = {};
    ctx.search.service = `local_search`;
    if (ctx.search.service == 'local_search') {
      let service_obj = Object.assign({}, `{"field":"all","path":"/search.json","content":true,"sort":"-date"}`);
      ctx.search[ctx.search.service] = service_obj;
    }
  }
  const def = {
    avatar: `https://gcore.jsdelivr.net/gh/cdn-x/placeholder@1.0.12/avatar/round/3442075.svg`,
    cover: `https://gcore.jsdelivr.net/gh/cdn-x/placeholder@1.0.12/cover/76b86c0226ffd.svg`,
  };
  const deps = {
    jquery: `https://cdn.bootcdn.net/ajax/libs/jquery/3.7.1/jquery.min.js`,
    marked: `https://cdn.bootcdn.net/ajax/libs/marked/4.0.18/marked.min.js`
  }
  

</script>

<script type="text/javascript">
  const utils = {
    // 懒加载 css https://github.com/filamentgroup/loadCSS
    css: (href, before, media, attributes) => {
      var doc = window.document;
      var ss = doc.createElement("link");
      var ref;
      if (before) {
        ref = before;
      } else {
        var refs = (doc.body || doc.getElementsByTagName("head")[0]).childNodes;
        ref = refs[refs.length - 1];
      }
      var sheets = doc.styleSheets;
      if (attributes) {
        for (var attributeName in attributes) {
          if (attributes.hasOwnProperty(attributeName)) {
            ss.setAttribute(attributeName, attributes[attributeName]);
          }
        }
      }
      ss.rel = "stylesheet";
      ss.href = href;
      ss.media = "only x";
      function ready(cb) {
        if (doc.body) {
          return cb();
        }
        setTimeout(function () {
          ready(cb);
        });
      }
      ready(function () {
        ref.parentNode.insertBefore(ss, before ? ref : ref.nextSibling);
      });
      var onloadcssdefined = function (cb) {
        var resolvedHref = ss.href;
        var i = sheets.length;
        while (i--) {
          if (sheets[i].href === resolvedHref) {
            return cb();
          }
        }
        setTimeout(function () {
          onloadcssdefined(cb);
        });
      };
      function loadCB() {
        if (ss.addEventListener) {
          ss.removeEventListener("load", loadCB);
        }
        ss.media = media || "all";
      }
      if (ss.addEventListener) {
        ss.addEventListener("load", loadCB);
      }
      ss.onloadcssdefined = onloadcssdefined;
      onloadcssdefined(loadCB);
      return ss;
    },

    js: (src, opt) => new Promise((resolve, reject) => {
      var script = document.createElement('script');
      if (src.startsWith('/')){
        src = ctx.root + src.substring(1);
      }
      script.src = src;
      if (opt) {
        for (let key of Object.keys(opt)) {
          script[key] = opt[key]
        }
      } else {
        // 默认异步，如果需要同步，第二个参数传入 {} 即可
        script.async = true
      }
      script.onerror = reject
      script.onload = script.onreadystatechange = function() {
        const loadState = this.readyState
        if (loadState && loadState !== 'loaded' && loadState !== 'complete') return
        script.onload = script.onreadystatechange = null
        resolve()
      }
      document.head.appendChild(script)
    }),

    jq: (fn) => {
      if (typeof jQuery === 'undefined') {
        utils.js(deps.jquery).then(fn)
      } else {
        fn()
      }
    },
    
    onLoading: (el) => {
      if (el) {
        $(el).append('<div class="loading-wrap"><svg xmlns="http://www.w3.org/2000/svg" width="2em" height="2em" preserveAspectRatio="xMidYMid meet" viewBox="0 0 24 24"><g fill="none" stroke="currentColor" stroke-linecap="round" stroke-width="2"><path stroke-dasharray="60" stroke-dashoffset="60" stroke-opacity=".3" d="M12 3C16.9706 3 21 7.02944 21 12C21 16.9706 16.9706 21 12 21C7.02944 21 3 16.9706 3 12C3 7.02944 7.02944 3 12 3Z"><animate fill="freeze" attributeName="stroke-dashoffset" dur="1.3s" values="60;0"/></path><path stroke-dasharray="15" stroke-dashoffset="15" d="M12 3C16.9706 3 21 7.02944 21 12"><animate fill="freeze" attributeName="stroke-dashoffset" dur="0.3s" values="15;0"/><animateTransform attributeName="transform" dur="1.5s" repeatCount="indefinite" type="rotate" values="0 12 12;360 12 12"/></path></g></svg></div>');
      }
    },
    onLoadSuccess: (el) => {
      if (el) {
        $(el).find('.loading-wrap').remove();
      }
    },
    onLoadFailure: (el) => {
      if (el) {
        $(el).find('.loading-wrap svg').remove();
        $(el).find('.loading-wrap').append('<svg xmlns="http://www.w3.org/2000/svg" width="2em" height="2em" preserveAspectRatio="xMidYMid meet" viewBox="0 0 24 24"><g fill="none" stroke="currentColor" stroke-linecap="round" stroke-linejoin="round" stroke-width="2"><path stroke-dasharray="60" stroke-dashoffset="60" d="M12 3L21 20H3L12 3Z"><animate fill="freeze" attributeName="stroke-dashoffset" dur="0.5s" values="60;0"/></path><path stroke-dasharray="6" stroke-dashoffset="6" d="M12 10V14"><animate fill="freeze" attributeName="stroke-dashoffset" begin="0.6s" dur="0.2s" values="6;0"/></path></g><circle cx="12" cy="17" r="1" fill="currentColor" fill-opacity="0"><animate fill="freeze" attributeName="fill-opacity" begin="0.8s" dur="0.4s" values="0;1"/></circle></svg>');
        $(el).find('.loading-wrap').addClass('error');
      }
    },
    request: (el, url, callback, onFailure) => {
      let retryTimes = 3;
      utils.onLoading(el);
      function req() {
        return new Promise((resolve, reject) => {
          let status = 0; // 0 等待 1 完成 2 超时
          let timer = setTimeout(() => {
            if (status === 0) {
              status = 2;
              timer = null;
              reject('请求超时');
              if (retryTimes == 0) {
                onFailure();
              }
            }
          }, 5000);
          fetch(url).then(function(response) {
            if (status !== 2) {
              clearTimeout(timer);
              resolve(response);
              timer = null;
              status = 1;
            }
            if (response.ok) {
              return response.json();
            }
            throw new Error('Network response was not ok.');
          }).then(function(data) {
            retryTimes = 0;
            utils.onLoadSuccess(el);
            callback(data);
          }).catch(function(error) {
            if (retryTimes > 0) {
              retryTimes -= 1;
              setTimeout(() => {
                req();
              }, 5000);
            } else {
              utils.onLoadFailure(el);
              onFailure();
            }
          });
        });
      }
      req();
    },
  };
</script>

<script>
  const sidebar = {
    leftbar: () => {
      if (l_body) {
        l_body.toggleAttribute('leftbar');
        l_body.removeAttribute('rightbar');
      }
    },
    rightbar: () => {
      if (l_body) {
        l_body.toggleAttribute('rightbar');
        l_body.removeAttribute('leftbar');
      }
    },
    dismiss: () => {
      if (l_body) {
        l_body.removeAttribute('leftbar');
        l_body.removeAttribute('rightbar');
      }
    },
    toggleTOC: () => {
      document.querySelector('#data-toc').classList.toggle('collapse');
    }
  }
</script>

<!-- required -->
<script src="/js/main.js?v=1.27.0" async></script>

<!-- optional -->



<script defer>
  window.addEventListener('DOMContentLoaded', (event) => {
    ctx.services = Object.assign({}, JSON.parse(`{"mdrender":{"js":"/js/services/mdrender.js"},"siteinfo":{"js":"/js/services/siteinfo.js","api":null},"ghinfo":{"js":"/js/services/ghinfo.js"},"sites":{"js":"/js/services/sites.js"},"friends":{"js":"/js/services/friends.js"},"timeline":{"js":"/js/services/timeline.js"},"fcircle":{"js":"/js/services/fcircle.js"},"weibo":{"js":"/js/services/weibo.js"},"memos":{"js":"/js/services/memos.js"}}`));
    for (let id of Object.keys(ctx.services)) {
      const js = ctx.services[id].js;
      if (id == 'siteinfo') {
        ctx.cardlinks = document.querySelectorAll('a.link-card[cardlink]');
        if (ctx.cardlinks?.length > 0) {
          utils.js(js, { defer: true }).then(function () {
            setCardLink(ctx.cardlinks);
          });
        }
      } else {
        const els = document.getElementsByClassName(`ds-${id}`);
        if (els?.length > 0) {
          utils.jq(() => {
            if (id == 'timeline' || 'memos' || 'marked') {
              utils.js(deps.marked).then(function () {
                utils.js(js, { defer: true });
              });
            } else {
              utils.js(js, { defer: true });
            }
          });
        }
      }
    }
  });
</script>

<script>
  window.addEventListener('DOMContentLoaded', (event) => {
    ctx.search = {
      path: `/search.json`,
    }
    utils.js('/js/search/local-search.js', { defer: true });
  });
</script><script>
  window.FPConfig = {
    delay: 0,
    ignoreKeywords: [],
    maxRPS: 5,
    hoverDelay: 25
  };
</script>
<script defer src="https://cdn.bootcdn.net/ajax/libs/flying-pages/2.1.2/flying-pages.min.js"></script><script defer src="https://cdn.bootcdn.net/ajax/libs/vanilla-lazyload/17.8.4/lazyload.min.js"></script>
<script>
  // https://www.npmjs.com/package/vanilla-lazyload
  // Set the options globally
  // to make LazyLoad self-initialize
  window.lazyLoadOptions = {
    elements_selector: ".lazy",
  };
  // Listen to the initialization event
  // and get the instance of LazyLoad
  window.addEventListener(
    "LazyLoad::Initialized",
    function (event) {
      window.lazyLoadInstance = event.detail.instance;
    },
    false
  );
  document.addEventListener('DOMContentLoaded', function () {
    window.lazyLoadInstance?.update();
  });
</script><script>
  ctx.fancybox = {
    selector: `.timenode p>img`,
    css: `https://cdn.bootcdn.net/ajax/libs/fancyapps-ui/5.0.22/fancybox/fancybox.min.css`,
    js: `https://cdn.bootcdn.net/ajax/libs/fancyapps-ui/5.0.22/fancybox/fancybox.umd.min.js`
  };
  var selector = '[data-fancybox]:not(.error)';
  if (ctx.fancybox.selector) {
    selector += `, ${ctx.fancybox.selector}`
  }
  var needFancybox = document.querySelectorAll(selector).length !== 0;
  if (!needFancybox) {
    const els = document.getElementsByClassName('ds-memos');
    if (els != undefined && els.length > 0) {
      needFancybox = true;
    }
  }
  if (needFancybox) {
    utils.css(ctx.fancybox.css);
    utils.js(ctx.fancybox.js, { defer: true }).then(function () {
      Fancybox.bind(selector, {
        hideScrollbar: false,
        Thumbs: {
          autoStart: false,
        },
        caption: (fancybox, slide) => {
          return slide.triggerEl.alt || null
        }
      });
    })
  }
</script><script>
  window.addEventListener('DOMContentLoaded', (event) => {
    const swiper_api = document.getElementById('swiper-api');
    if (swiper_api != undefined) {
      utils.css(`https://unpkg.com/swiper@10.3.1/swiper-bundle.min.css`);
      utils.js(`https://unpkg.com/swiper@10.3.1/swiper-bundle.min.js`, { defer: true }).then(function () {
        const effect = swiper_api.getAttribute('effect') || '';
        var swiper = new Swiper('.swiper#swiper-api', {
          slidesPerView: 'auto',
          spaceBetween: 8,
          centeredSlides: true,
          effect: effect,
          loop: true,
          pagination: {
            el: '.swiper-pagination',
            clickable: true,
          },
          navigation: {
            nextEl: '.swiper-button-next',
            prevEl: '.swiper-button-prev',
          },
        });
      })
    }
  });
</script><script>
  document.addEventListener('DOMContentLoaded', function () {
    window.codeElements = document.querySelectorAll('.code');
    if (window.codeElements.length > 0) {
      ctx.copycode = {
        default_text: `Copy`,
        success_text: `Copied`,
        toast: `复制成功`,
      };
      utils.js('/js/plugins/copycode.js');
    }
  });
</script>


<!-- inject -->

</div></body></html>
