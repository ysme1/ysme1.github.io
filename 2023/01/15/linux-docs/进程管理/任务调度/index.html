
<!DOCTYPE html><html lang="zh-CN">

<head>
  <meta charset="utf-8">
  <meta name="hexo-theme" content="https://github.com/xaoxuu/hexo-theme-stellar/tree/1.27.0" theme-name="Stellar" theme-version="1.27.0">
  
  <meta name="generator" content="Hexo 7.1.1">
  <meta http-equiv='x-dns-prefetch-control' content='on' />
  
  <meta name="renderer" content="webkit">
  <meta name="force-rendering" content="webkit">
  <meta http-equiv="X-UA-Compatible" content="IE=Edge,chrome=1">
  <meta name="HandheldFriendly" content="True" >
  <meta name="apple-mobile-web-app-capable" content="yes">
  <meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1">
  <meta name="theme-color" content="#f8f8f8">
  
  <title>任务调度 - Blog</title>

  
    <meta name="description" content="一. 前言  在前文中，我们分析了内核中进程和线程的统一结构体task_struct，并分析进程、线程的创建和派生的过程。在本文中，我们会对任务间调度进行详细剖析，了解其原理和整个执行过程。由此，进程、线程部分的大体框架就算是介绍完了。本节主要分为三个部分：Linux内核中常见的调度策略，调度的基本结构体以及调度发生的整个流程。下面将详细展开说明。 二. 调度策略  Linux 作为一个多任务操作">
<meta property="og:type" content="article">
<meta property="og:title" content="任务调度">
<meta property="og:url" content="https://vcloud.ysme.top/2023/01/15/linux-docs/%E8%BF%9B%E7%A8%8B%E7%AE%A1%E7%90%86/%E4%BB%BB%E5%8A%A1%E8%B0%83%E5%BA%A6/index.html">
<meta property="og:site_name" content="Blog">
<meta property="og:description" content="一. 前言  在前文中，我们分析了内核中进程和线程的统一结构体task_struct，并分析进程、线程的创建和派生的过程。在本文中，我们会对任务间调度进行详细剖析，了解其原理和整个执行过程。由此，进程、线程部分的大体框架就算是介绍完了。本节主要分为三个部分：Linux内核中常见的调度策略，调度的基本结构体以及调度发生的整个流程。下面将详细展开说明。 二. 调度策略  Linux 作为一个多任务操作">
<meta property="og:locale" content="zh_CN">
<meta property="article:published_time" content="2023-01-15T01:13:37.000Z">
<meta property="article:modified_time" content="2024-04-05T12:59:49.944Z">
<meta property="article:author" content="ysme">
<meta property="article:tag" content="Linux">
<meta name="twitter:card" content="summary_large_image">
  
  
  
  <meta name="keywords" content="Linux">

  <!-- feed -->
  

  <link rel="stylesheet" href="/css/main.css?v=1.27.0">

  

  

  
</head>
<body>

<div class="l_body s:aa content tech" id="start" layout="post" ><aside class="l_left"><div class="leftbar-container">


<header class="header"><div class="logo-wrap"><a class="avatar" href="/about/"><div class="bg" style="opacity:0;background-image:url(https://gcore.jsdelivr.net/gh/cdn-x/placeholder@1.0.12/avatar/round/rainbow64@3x.webp);"></div><img no-lazy class="avatar" src="undefined" onerror="javascript:this.classList.add('error');this.src='https://gcore.jsdelivr.net/gh/cdn-x/placeholder@1.0.12/image/2659360.svg';"></a><a class="title" href="/"><div class="main" ff="title">Blog</div></a></div></header>

<div class="nav-area">
<div class="search-wrapper" id="search-wrapper"><form class="search-form"><a class="search-button" onclick="document.getElementById(&quot;search-input&quot;).focus();"><svg t="1705074644177" viewBox="0 0 1025 1024" version="1.1" xmlns="http://www.w3.org/2000/svg" p-id="1560" width="200" height="200"><path d="M1008.839137 935.96571L792.364903 719.491476a56.783488 56.783488 0 0 0-80.152866 0 358.53545 358.53545 0 1 1 100.857314-335.166073 362.840335 362.840335 0 0 1-3.689902 170.145468 51.248635 51.248635 0 1 0 99.217358 26.444296 462.057693 462.057693 0 1 0-158.255785 242.303546l185.930047 185.725053a51.248635 51.248635 0 0 0 72.568068 0 51.248635 51.248635 0 0 0 0-72.978056z" p-id="1561"></path><path d="M616.479587 615.969233a50.428657 50.428657 0 0 0-61.498362-5.534852 174.655348 174.655348 0 0 1-177.525271 3.484907 49.403684 49.403684 0 0 0-58.833433 6.76482l-3.074918 2.869923a49.403684 49.403684 0 0 0 8.609771 78.10292 277.767601 277.767601 0 0 0 286.992355-5.739847 49.403684 49.403684 0 0 0 8.404776-76.667958z" p-id="1562"></path></svg></a><input type="text" class="search-input" id="search-input" placeholder="站内搜索"></form><div id="search-result"></div><div class="search-no-result">没有找到内容！</div></div>


<nav class="menu dis-select"></nav>
</div>
<div class="widgets">


<widget class="widget-wrapper post-list"><div class="widget-header dis-select"><span class="name">最近更新</span></div><div class="widget-body fs14"><a class="item title" href="/2023/01/15/linux-docs/%E8%BF%9B%E7%A8%8B%E7%AE%A1%E7%90%86/Linux%E5%86%85%E6%A0%B8%E8%BF%9B%E7%A8%8B%E8%BF%B0%E7%AC%A6%E5%92%8C%E8%BF%9B%E7%A8%8B%E7%8A%B6%E6%80%81/"><span class="title">Linux内核进程述符和进程状态</span></a><a class="item title" href="/2023/01/15/linux-docs/%E8%BF%9B%E7%A8%8B%E7%AE%A1%E7%90%86/Linux%E5%86%85%E6%A0%B8%E8%BF%9B%E7%A8%8B%E9%97%B4%E9%80%9A%E4%BF%A1-%E7%AE%A1%E9%81%93/"><span class="title">Linux内核进程间通信-管道</span></a><a class="item title" href="/2023/01/15/linux-docs/%E8%BF%9B%E7%A8%8B%E7%AE%A1%E7%90%86/Linux%E8%BF%9B%E7%A8%8B%E3%80%81%E7%BA%BF%E7%A8%8B%E3%80%81%E8%B0%83%E5%BA%A6(%E4%B8%80)/"><span class="title">Linux进程、线程、调度(一)</span></a><a class="item title" href="/2023/01/15/linux-docs/%E8%BF%9B%E7%A8%8B%E7%AE%A1%E7%90%86/Linux%E8%BF%9B%E7%A8%8B%E3%80%81%E7%BA%BF%E7%A8%8B%E3%80%81%E8%B0%83%E5%BA%A6(%E4%B8%89)/"><span class="title">Linux进程、线程、调度(三)</span></a><a class="item title" href="/2023/01/15/linux-docs/%E8%BF%9B%E7%A8%8B%E7%AE%A1%E7%90%86/Linux%E8%BF%9B%E7%A8%8B%E3%80%81%E7%BA%BF%E7%A8%8B%E3%80%81%E8%B0%83%E5%BA%A6(%E4%BA%8C)/"><span class="title">Linux进程、线程、调度(二)</span></a><a class="item title" href="/2023/01/15/linux-docs/%E8%BF%9B%E7%A8%8B%E7%AE%A1%E7%90%86/Linux%E8%BF%9B%E7%A8%8B%E3%80%81%E7%BA%BF%E7%A8%8B%E3%80%81%E8%B0%83%E5%BA%A6(%E5%9B%9B)/"><span class="title">Linux进程、线程、调度(四)</span></a><a class="item title" href="/2023/01/15/linux-docs/%E8%BF%9B%E7%A8%8B%E7%AE%A1%E7%90%86/Linux%E8%BF%9B%E7%A8%8B%E7%8A%B6%E6%80%81%E6%80%BB%E7%BB%93/"><span class="title">Linux进程状态总结</span></a><a class="item title" href="/2023/01/15/linux-docs/%E8%BF%9B%E7%A8%8B%E7%AE%A1%E7%90%86/%E4%B8%80%E6%96%87%E5%B8%A6%E4%BD%A0%EF%BC%8C%E5%BD%BB%E5%BA%95%E4%BA%86%E8%A7%A3%EF%BC%8C%E9%9B%B6%E6%8B%B7%E8%B4%9DZero-Copy%E6%8A%80%E6%9C%AF/"><span class="title">一文带你，彻底了解，零拷贝Zero-Copy技术</span></a><a class="item title" href="/2023/01/15/linux-docs/%E8%BF%9B%E7%A8%8B%E7%AE%A1%E7%90%86/%E4%BB%BB%E5%8A%A1%E8%B0%83%E5%BA%A6/"><span class="title">任务调度</span></a><a class="item title" href="/2023/01/15/linux-docs/%E8%BF%9B%E7%A8%8B%E7%AE%A1%E7%90%86/%E8%BF%9B%E7%A8%8B%E3%80%81%E7%BA%BF%E7%A8%8B%E7%9A%84%E5%88%9B%E5%BB%BA%E5%92%8C%E6%B4%BE%E7%94%9F/"><span class="title">进程、线程的创建和派生</span></a></div></widget>
</div>
<footer class="footer dis-select"><div class="social-wrap"><a class="social" href="/" rel="noopener noreferrer"><img class="lazy" src="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII=" data-src="https://gcore.jsdelivr.net/gh/cdn-x/placeholder@1.0.12/social/08a41b181ce68.svg"/></a><a class="social" href="/" rel="noopener noreferrer"><img class="lazy" src="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII=" data-src="https://gcore.jsdelivr.net/gh/cdn-x/placeholder@1.0.12/social/3845874.svg"/></a><a class="social" href="/" rel="noopener noreferrer"><img class="lazy" src="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII=" data-src="https://gcore.jsdelivr.net/gh/cdn-x/placeholder@1.0.12/social/3616429.svg"/></a><a class="social" href="/about/#comments" rel="noopener noreferrer"><img class="lazy" src="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII=" data-src="https://gcore.jsdelivr.net/gh/cdn-x/placeholder@1.0.12/social/942ebbf1a4b91.svg"/></a></div></footer>
</div></aside><div class="l_main" id="main">





<div class="article banner top">
  <div class="content">
    <div class="top bread-nav footnote"><div class="left"><div class="flex-row" id="breadcrumb"><a class="cap breadcrumb" href="/">主页</a>
<span class="sep"></span><a class="cap breadcrumb" href="/">文章</a><span class="sep"></span><a class="cap breadcrumb-link" href="/categories/linux-doc-%E8%BF%9B%E7%A8%8B%E7%AE%A1%E7%90%86/">linux-doc 进程管理</a></div>
<div class="flex-row" id="post-meta"><span class="text created">发布于：<time datetime="2023-01-15T01:13:37.000Z">2023-01-15</time></span><span class="sep updated"></span><span class="text updated">更新于：<time datetime="2024-04-05T12:59:49.944Z">2024-04-05</time></span></div></div></div>
    
    <div class="bottom only-title">
      
      <div class="text-area">
        <h1 class="text title"><span>任务调度</span></h1>
        
      </div>
    </div>
    
  </div>
  </div><article class="md-text content"><h2 id="一-前言"><a href="#一-前言" class="headerlink" title="一. 前言"></a>一. 前言</h2><p>  在前文中，我们分析了内核中进程和线程的统一结构体task_struct，并分析进程、线程的创建和派生的过程。在本文中，我们会对任务间调度进行详细剖析，了解其原理和整个执行过程。由此，进程、线程部分的大体框架就算是介绍完了。本节主要分为三个部分：Linux内核中常见的调度策略，调度的基本结构体以及调度发生的整个流程。下面将详细展开说明。</p>
<h2 id="二-调度策略"><a href="#二-调度策略" class="headerlink" title="二. 调度策略"></a>二. 调度策略</h2><p>  Linux 作为一个多任务操作系统，将每个 CPU 的时间划分为很短的时间片，再通过调度器轮流分配给各个任务使用，因此造成多任务同时运行的错觉。为了维护 CPU 时间，Linux 通过事先定义的节拍率（内核中表示为 HZ），触发时间中断，并使用全局变量 Jiffies 记录了开机以来的节拍数。每发生一次时间中断，Jiffies 的值就加 1。节拍率 HZ 是内核的可配选项，可以设置为 100、250、1000 等。不同的系统可能设置不同数值，以通过查询 &#x2F;boot&#x2F;config 内核选项来查看它的配置值。</p>
<p>  Linux的调度策略主要分为实时任务和普通任务。实时任务需求尽快返回结果，而普通任务则没有较高的要求。在前文中我们提到了task_struct中调度策略相应的变量为policy，调度优先级有prio, static_prio, normal_prio, rt_priority几个。优先级其实就是一个数值，对于实时进程，优先级的范围是 0～99；对于普通进程，优先级的范围是 100～139。数值越小，优先级越高。</p>
<h3 id="2-1-实时调度策略"><a href="#2-1-实时调度策略" class="headerlink" title="2.1 实时调度策略"></a>2.1 实时调度策略</h3><p>  实时调度策略主要包括以下几种</p>
<ul>
<li>SCHED_FIFO：先来先出型策略，顾名思义相同优先级的情况下先到先得</li>
<li>SCHED_RR：轮询策略，注重公平性，相同优先级的任务会使用相同的时间片轮流执行</li>
<li>SCHED_DEADLINE：根据任务结束时间来进行调度，即将结束的拥有较高的优先级</li>
</ul>
<h3 id="2-2-普通调度策略"><a href="#2-2-普通调度策略" class="headerlink" title="2.2 普通调度策略"></a>2.2 普通调度策略</h3><p>  普通调度策略主要包括以下几种</p>
<ul>
<li>SCHED_NORMAL：普通任务</li>
<li>SCHED_BATCH：后台任务，优先级较低</li>
<li>SCHED_IDLE：空闲时间才会跑的任务</li>
<li>CFS：完全公平调度策略，较为特殊的一种策略。CFS 会为每一个任务安排一个虚拟运行时间 vruntime。如果一个任务在运行，随着一个个 CPU时钟tick 的到来，任务的 vruntime 将不断增大，而没有得到执行的任务的 vruntime 不变。由此，当调度的时候，vruntime较小的就拥有较高的优先级。 vruntime的实际计算方式和权重相关，由此保证了优先级高的按比例拥有更多的执行时间，从而达到完全公平。</li>
</ul>
<h2 id="三-调度相关的结构体"><a href="#三-调度相关的结构体" class="headerlink" title="三. 调度相关的结构体"></a>三. 调度相关的结构体</h2><p>  首先，我们需要一个结构体去执行调度策略，即sched_class。该类有几种实现</p>
<ul>
<li><p>stop_sched_class 优先级最高的任务会使用这种策略，会中断所有其他线程，且不会被其他任务打断；</p>
</li>
<li><p>dl_sched_class 就对应上面的 deadline 调度策略；</p>
</li>
<li><p>rt_sched_class 就对应 RR 算法或者 FIFO 算法的调度策略，具体调度策略由进程的 task_struct-&gt;policy 指定；</p>
</li>
<li><p>fair_sched_class 就是普通进程的调度策略；</p>
</li>
<li><p>idle_sched_class 就是空闲进程的调度策略。</p>
<p>其次，我们需要一个调度结构体来集合调度信息，用于调度，即sched_entity，主要有</p>
</li>
<li><p>struct sched_entity se：普通任务调度实体</p>
</li>
<li><p>struct sched_rt_entity rt：实时调度实体</p>
</li>
<li><p>struct sched_dl_entity dl：DEADLINE调度实体</p>
</li>
</ul>
<p>  普通任务调度实体源码如下，这里面包含了 vruntime 和权重 load_weight，以及对于运行时间的统计。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">sched_entity</span> &#123;</span></span><br><span class="line">    <span class="comment">/* For load-balancing: */</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">load_weight</span>		<span class="title">load</span>;</span></span><br><span class="line">    <span class="type">unsigned</span> <span class="type">long</span>			runnable_weight;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">rb_node</span>			<span class="title">run_node</span>;</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">list_head</span>		<span class="title">group_node</span>;</span></span><br><span class="line">    <span class="type">unsigned</span> <span class="type">int</span>			on_rq;</span><br><span class="line">    u64				exec_start;</span><br><span class="line">    u64				sum_exec_runtime;</span><br><span class="line">    u64				vruntime;</span><br><span class="line">    u64				prev_sum_exec_runtime;</span><br><span class="line">    u64				nr_migrations;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">sched_statistics</span>		<span class="title">statistics</span>;</span></span><br><span class="line"><span class="meta">#<span class="keyword">ifdef</span> CONFIG_FAIR_GROUP_SCHED</span></span><br><span class="line">    <span class="type">int</span>				depth;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">sched_entity</span>		*<span class="title">parent</span>;</span></span><br><span class="line">    <span class="comment">/* rq on which this entity is (to be) queued: */</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">cfs_rq</span>			*<span class="title">cfs_rq</span>;</span></span><br><span class="line">    <span class="comment">/* rq &quot;owned&quot; by this entity/group: */</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">cfs_rq</span>			*<span class="title">my_q</span>;</span></span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">ifdef</span> CONFIG_SMP</span></span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">     * Per entity load average tracking.</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * Put into separate cache line so it does not</span></span><br><span class="line"><span class="comment">     * collide with read-mostly values above.</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">sched_avg</span>		<span class="title">avg</span>;</span></span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>  在调度时，多个任务调度实体会首先区分是实时任务还是普通任务，然后通过以时间为顺序的红黑树结构组合起来，vruntime 最小的在树的左侧，vruntime最多的在树的右侧。以CFS策略为例，则会选择红黑树最左边的叶子节点作为下一个将获得 CPU 的任务。而这颗红黑树，我们称之为运行时队列（run queue），即struct rq。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * This is the main, per-CPU runqueue data structure.</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * Locking rule: those places that want to lock multiple runqueues</span></span><br><span class="line"><span class="comment"> * (such as the load balancing or the thread migration code), lock</span></span><br><span class="line"><span class="comment"> * acquire operations must be ordered by ascending &amp;runqueue.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">rq</span> &#123;</span></span><br><span class="line">    <span class="comment">/* runqueue lock: */</span></span><br><span class="line">    <span class="type">raw_spinlock_t</span>		lock;</span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">     * nr_running and cpu_load should be in the same cacheline because</span></span><br><span class="line"><span class="comment">     * remote CPUs use both these fields when doing load calculation.</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="type">unsigned</span> <span class="type">int</span>		nr_running;</span><br><span class="line">......</span><br><span class="line">    <span class="meta">#<span class="keyword">define</span> CPU_LOAD_IDX_MAX 5</span></span><br><span class="line">    <span class="type">unsigned</span> <span class="type">long</span>		cpu_load[CPU_LOAD_IDX_MAX];</span><br><span class="line">......</span><br><span class="line">    <span class="comment">/* capture load from *all* tasks on this CPU: */</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">load_weight</span>	<span class="title">load</span>;</span></span><br><span class="line">    <span class="type">unsigned</span> <span class="type">long</span>		nr_load_updates;</span><br><span class="line">    u64			nr_switches;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">cfs_rq</span>		<span class="title">cfs</span>;</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">rt_rq</span>		<span class="title">rt</span>;</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">dl_rq</span>		<span class="title">dl</span>;</span></span><br><span class="line">......</span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">     * This is part of a global counter where only the total sum</span></span><br><span class="line"><span class="comment">     * over all CPUs matters. A task can increase this counter on</span></span><br><span class="line"><span class="comment">     * one CPU and if it got migrated afterwards it may decrease</span></span><br><span class="line"><span class="comment">     * it on another CPU. Always updated under the runqueue lock:</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="type">unsigned</span> <span class="type">long</span>		nr_uninterruptible;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">task_struct</span>	*<span class="title">curr</span>;</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">task_struct</span>	*<span class="title">idle</span>;</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">task_struct</span>	*<span class="title">stop</span>;</span></span><br><span class="line">    <span class="type">unsigned</span> <span class="type">long</span>		next_balance;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">mm_struct</span>	*<span class="title">prev_mm</span>;</span></span><br><span class="line">    <span class="type">unsigned</span> <span class="type">int</span>		clock_update_flags;</span><br><span class="line">    u64			clock;</span><br><span class="line">    <span class="comment">/* Ensure that all clocks are in the same cache line */</span></span><br><span class="line">    u64			clock_task ____cacheline_aligned;</span><br><span class="line">    u64			clock_pelt;</span><br><span class="line">    <span class="type">unsigned</span> <span class="type">long</span>		lost_idle_time;</span><br><span class="line">    <span class="type">atomic_t</span>		nr_iowait;</span><br><span class="line">......</span><br><span class="line">    <span class="comment">/* calc_load related fields */</span></span><br><span class="line">    <span class="type">unsigned</span> <span class="type">long</span>		calc_load_update;</span><br><span class="line">    <span class="type">long</span>			calc_load_active;</span><br><span class="line">......</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>  其中包含结构体cfs_rq，其定义如下，主要是CFS调度相关的结构体，主要有权值相关变量、vruntime相关变量以及红黑树指针，其中结构体rb_root_cached即为红黑树的节点</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* CFS-related fields in a runqueue */</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">cfs_rq</span> &#123;</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">load_weight</span>	<span class="title">load</span>;</span></span><br><span class="line">    <span class="type">unsigned</span> <span class="type">long</span>		runnable_weight;</span><br><span class="line">    <span class="type">unsigned</span> <span class="type">int</span>		nr_running;</span><br><span class="line">    <span class="type">unsigned</span> <span class="type">int</span>		h_nr_running;</span><br><span class="line">    u64			exec_clock;</span><br><span class="line">    u64			min_vruntime;</span><br><span class="line"><span class="meta">#<span class="keyword">ifndef</span> CONFIG_64BIT</span></span><br><span class="line">    u64			min_vruntime_copy;</span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">rb_root_cached</span>	<span class="title">tasks_timeline</span>;</span></span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">     * &#x27;curr&#x27; points to currently running entity on this cfs_rq.</span></span><br><span class="line"><span class="comment">     * It is set to NULL otherwise (i.e when none are currently running).</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">sched_entity</span>	*<span class="title">curr</span>;</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">sched_entity</span>	*<span class="title">next</span>;</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">sched_entity</span>	*<span class="title">last</span>;</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">sched_entity</span>	*<span class="title">skip</span>;</span></span><br><span class="line">......</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>  对结构体dl_rq有类似的定义，运行队列由红黑树结构体构成，并按照deadline策略进行管理</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* Deadline class&#x27; related fields in a runqueue */</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">dl_rq</span> &#123;</span></span><br><span class="line">    <span class="comment">/* runqueue is an rbtree, ordered by deadline */</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">rb_root_cached</span>	<span class="title">root</span>;</span></span><br><span class="line">    <span class="type">unsigned</span> <span class="type">long</span>		dl_nr_running;</span><br><span class="line"><span class="meta">#<span class="keyword">ifdef</span> CONFIG_SMP</span></span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">     * Deadline values of the currently executing and the</span></span><br><span class="line"><span class="comment">     * earliest ready task on this rq. Caching these facilitates</span></span><br><span class="line"><span class="comment">     * the decision whether or not a ready but not running task</span></span><br><span class="line"><span class="comment">     * should migrate somewhere else.</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> &#123;</span></span><br><span class="line">        u64		curr;</span><br><span class="line">        u64		next;</span><br><span class="line">    &#125; earliest_dl;</span><br><span class="line">    <span class="type">unsigned</span> <span class="type">long</span>		dl_nr_migratory;</span><br><span class="line">    <span class="type">int</span>			overloaded;</span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">     * Tasks on this rq that can be pushed away. They are kept in</span></span><br><span class="line"><span class="comment">     * an rb-tree, ordered by tasks&#x27; deadlines, with caching</span></span><br><span class="line"><span class="comment">     * of the leftmost (earliest deadline) element.</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">rb_root_cached</span>	<span class="title">pushable_dl_tasks_root</span>;</span></span><br><span class="line"><span class="meta">#<span class="keyword">else</span></span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">dl_bw</span>		<span class="title">dl_bw</span>;</span></span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">     * &quot;Active utilization&quot; for this runqueue: increased when a</span></span><br><span class="line"><span class="comment">     * task wakes up (becomes TASK_RUNNING) and decreased when a</span></span><br><span class="line"><span class="comment">     * task blocks</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    u64			running_bw;</span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">     * Utilization of the tasks &quot;assigned&quot; to this runqueue (including</span></span><br><span class="line"><span class="comment">     * the tasks that are in runqueue and the tasks that executed on this</span></span><br><span class="line"><span class="comment">     * CPU and blocked). Increased when a task moves to this runqueue, and</span></span><br><span class="line"><span class="comment">     * decreased when the task moves away (migrates, changes scheduling</span></span><br><span class="line"><span class="comment">     * policy, or terminates).</span></span><br><span class="line"><span class="comment">     * This is needed to compute the &quot;inactive utilization&quot; for the</span></span><br><span class="line"><span class="comment">     * runqueue (inactive utilization = this_bw - running_bw).</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    u64			this_bw;</span><br><span class="line">    u64			extra_bw;</span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">     * Inverse of the fraction of CPU utilization that can be reclaimed</span></span><br><span class="line"><span class="comment">     * by the GRUB algorithm.</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    u64			bw_ratio;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>  对于实施队列相应的rt_rq则有所不同，并没有用红黑树实现。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* Real-Time classes&#x27; related field in a runqueue: */</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">rt_rq</span> &#123;</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">rt_prio_array</span>	<span class="title">active</span>;</span></span><br><span class="line">    <span class="type">unsigned</span> <span class="type">int</span>		rt_nr_running;</span><br><span class="line">    <span class="type">unsigned</span> <span class="type">int</span>		rr_nr_running;</span><br><span class="line"><span class="meta">#<span class="keyword">if</span> defined CONFIG_SMP || defined CONFIG_RT_GROUP_SCHED</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> &#123;</span></span><br><span class="line">        <span class="type">int</span>		curr; <span class="comment">/* highest queued rt task prio */</span></span><br><span class="line"><span class="meta">#<span class="keyword">ifdef</span> CONFIG_SMP</span></span><br><span class="line">        <span class="type">int</span>		next; <span class="comment">/* next highest */</span></span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line">    &#125; highest_prio;</span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">ifdef</span> CONFIG_SMP</span></span><br><span class="line">    <span class="type">unsigned</span> <span class="type">long</span>		rt_nr_migratory;</span><br><span class="line">    <span class="type">unsigned</span> <span class="type">long</span>		rt_nr_total;</span><br><span class="line">    <span class="type">int</span>			overloaded;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">plist_head</span>	<span class="title">pushable_tasks</span>;</span></span><br><span class="line"><span class="meta">#<span class="keyword">endif</span> <span class="comment">/* CONFIG_SMP */</span></span></span><br><span class="line">    <span class="type">int</span>			rt_queued;</span><br><span class="line">    <span class="type">int</span>			rt_throttled;</span><br><span class="line">    u64			rt_time;</span><br><span class="line">    u64			rt_runtime;</span><br><span class="line">    <span class="comment">/* Nests inside the rq lock: */</span></span><br><span class="line">    <span class="type">raw_spinlock_t</span>		rt_runtime_lock;</span><br><span class="line"><span class="meta">#<span class="keyword">ifdef</span> CONFIG_RT_GROUP_SCHED</span></span><br><span class="line">    <span class="type">unsigned</span> <span class="type">long</span>		rt_nr_boosted;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">rq</span>		*<span class="title">rq</span>;</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">task_group</span>	*<span class="title">tg</span>;</span></span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>  下面再看看调度类sched_class，该类以函数指针的形式定义了诸多队列操作，如</p>
<ul>
<li>enqueue_task 向就绪队列中添加一个任务，当某个任务进入可运行状态时，调用这个函数；</li>
<li>dequeue_task 将一个任务从就绪队列中删除；</li>
<li>yield_task将主动放弃CPU；</li>
<li>yield_to_task主动放弃CPU并执行指定的task_struct；</li>
<li>check_preempt_curr检查当前任务是否可被强占；</li>
<li>pick_next_task 选择接下来要运行的任务；</li>
<li>put_prev_task 用另一个进程代替当前运行的任务；</li>
<li>set_curr_task 用于修改调度策略；</li>
<li>task_tick 每次周期性时钟到的时候，这个函数被调用，可能触发调度。</li>
<li>task_dead:进程结束时调用</li>
<li>switched_from、switched_to:进程改变调度器时使用</li>
<li>prio_changed:改变进程优先级</li>
</ul>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">sched_class</span> &#123;</span></span><br><span class="line">    <span class="type">const</span> <span class="class"><span class="keyword">struct</span> <span class="title">sched_class</span> *<span class="title">next</span>;</span></span><br><span class="line">    <span class="type">void</span> (*enqueue_task) (<span class="keyword">struct</span> rq *rq, <span class="keyword">struct</span> task_struct *p, <span class="type">int</span> flags);</span><br><span class="line">    <span class="type">void</span> (*dequeue_task) (<span class="keyword">struct</span> rq *rq, <span class="keyword">struct</span> task_struct *p, <span class="type">int</span> flags);</span><br><span class="line">    <span class="type">void</span> (*yield_task)   (<span class="keyword">struct</span> rq *rq);</span><br><span class="line">    <span class="type">bool</span> (*yield_to_task)(<span class="keyword">struct</span> rq *rq, <span class="keyword">struct</span> task_struct *p, <span class="type">bool</span> preempt);</span><br><span class="line">    <span class="type">void</span> (*check_preempt_curr)(<span class="keyword">struct</span> rq *rq, <span class="keyword">struct</span> task_struct *p, <span class="type">int</span> flags);</span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">     * It is the responsibility of the pick_next_task() method that will</span></span><br><span class="line"><span class="comment">     * return the next task to call put_prev_task() on the @prev task or</span></span><br><span class="line"><span class="comment">     * something equivalent.</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * May return RETRY_TASK when it finds a higher prio class has runnable</span></span><br><span class="line"><span class="comment">     * tasks.</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">task_struct</span> * (*<span class="title">pick_next_task</span>)(<span class="keyword">struct</span> <span class="title">rq</span> *<span class="title">rq</span>,</span></span><br><span class="line"><span class="class">                           <span class="keyword">struct</span> <span class="title">task_struct</span> *<span class="title">prev</span>,</span></span><br><span class="line"><span class="class">                    *        <span class="keyword">struct</span> <span class="title">rq_flags</span> *<span class="title">rf</span>);</span></span><br><span class="line">    <span class="type">void</span> (*put_prev_task)(<span class="keyword">struct</span> rq *rq, <span class="keyword">struct</span> task_struct *p);</span><br><span class="line">......</span><br><span class="line">    <span class="type">void</span> (*set_curr_task)(<span class="keyword">struct</span> rq *rq);</span><br><span class="line">    <span class="type">void</span> (*task_tick)(<span class="keyword">struct</span> rq *rq, <span class="keyword">struct</span> task_struct *p, <span class="type">int</span> queued);</span><br><span class="line">    <span class="type">void</span> (*task_fork)(<span class="keyword">struct</span> task_struct *p);</span><br><span class="line">    <span class="type">void</span> (*task_dead)(<span class="keyword">struct</span> task_struct *p);</span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">     * The switched_from() call is allowed to drop rq-&gt;lock, therefore we</span></span><br><span class="line"><span class="comment">     * cannot assume the switched_from/switched_to pair is serliazed by</span></span><br><span class="line"><span class="comment">     * rq-&gt;lock. They are however serialized by p-&gt;pi_lock.</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="type">void</span> (*switched_from)(<span class="keyword">struct</span> rq *this_rq, <span class="keyword">struct</span> task_struct *task);</span><br><span class="line">    <span class="type">void</span> (*switched_to)  (<span class="keyword">struct</span> rq *this_rq, <span class="keyword">struct</span> task_struct *task);</span><br><span class="line">    <span class="type">void</span> (*prio_changed) (<span class="keyword">struct</span> rq *this_rq, <span class="keyword">struct</span> task_struct *task,</span><br><span class="line">                  <span class="type">int</span> oldprio);</span><br><span class="line">    <span class="type">unsigned</span> <span class="title function_">int</span> <span class="params">(*get_rr_interval)</span><span class="params">(<span class="keyword">struct</span> rq *rq,</span></span><br><span class="line"><span class="params">                    <span class="keyword">struct</span> task_struct *task)</span>;</span><br><span class="line">    <span class="type">void</span> (*update_curr)(<span class="keyword">struct</span> rq *rq);</span><br><span class="line"><span class="meta">#<span class="keyword">define</span> TASK_SET_GROUP		0</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> TASK_MOVE_GROUP		1</span></span><br><span class="line">......</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>  调度类分为下面几种：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">extern</span> <span class="type">const</span> <span class="class"><span class="keyword">struct</span> <span class="title">sched_class</span> <span class="title">stop_sched_class</span>;</span></span><br><span class="line"><span class="keyword">extern</span> <span class="type">const</span> <span class="class"><span class="keyword">struct</span> <span class="title">sched_class</span> <span class="title">dl_sched_class</span>;</span></span><br><span class="line"><span class="keyword">extern</span> <span class="type">const</span> <span class="class"><span class="keyword">struct</span> <span class="title">sched_class</span> <span class="title">rt_sched_class</span>;</span></span><br><span class="line"><span class="keyword">extern</span> <span class="type">const</span> <span class="class"><span class="keyword">struct</span> <span class="title">sched_class</span> <span class="title">fair_sched_class</span>;</span></span><br><span class="line"><span class="keyword">extern</span> <span class="type">const</span> <span class="class"><span class="keyword">struct</span> <span class="title">sched_class</span> <span class="title">idle_sched_class</span>;</span></span><br></pre></td></tr></table></figure>
<p>  队列操作中函数指针指向不同策略队列的实际执行函数函数，在linux&#x2F;kernel&#x2F;sched&#x2F;目录下，fair.c、idle.c、rt.c等文件对不同类型的策略实现了不同的函数，如fair.c中定义了</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * All the scheduling class methods:</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="type">const</span> <span class="class"><span class="keyword">struct</span> <span class="title">sched_class</span> <span class="title">fair_sched_class</span> =</span> &#123;</span><br><span class="line">    .next			    = &amp;idle_sched_class,</span><br><span class="line">    .enqueue_task		= enqueue_task_fair,</span><br><span class="line">    .dequeue_task		= dequeue_task_fair,</span><br><span class="line">    .yield_task		    = yield_task_fair,</span><br><span class="line">    .yield_to_task		= yield_to_task_fair,</span><br><span class="line">    .check_preempt_curr	 = check_preempt_wakeup,</span><br><span class="line">    .pick_next_task		 = pick_next_task_fair,</span><br><span class="line">    .put_prev_task		 = put_prev_task_fair,</span><br><span class="line">......</span><br><span class="line">    .set_curr_task       = set_curr_task_fair,</span><br><span class="line">    .task_tick		    = task_tick_fair,</span><br><span class="line">    .task_fork		    = task_fork_fair,</span><br><span class="line">    .prio_changed		= prio_changed_fair,</span><br><span class="line">    .switched_from		= switched_from_fair,</span><br><span class="line">    .switched_to		= switched_to_fair,</span><br><span class="line">    .get_rr_interval	= get_rr_interval_fair,</span><br><span class="line">    .update_curr		= update_curr_fair,</span><br><span class="line">......</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>以选择下一个任务为例，CFS对应的是pick_next_task_fair，而rt_rq对应的则是pick_next_task_rt，等等。</p>
<p>  由此，我们来总结一下：</p>
<ul>
<li>每个CPU都有一个struct rq结构体，里面会有着cfs_rq, rt_rq等一系列队列</li>
<li>每个队列由一个红黑树组织，红黑树里每一个节点为一个任务实体sched_entity</li>
<li>每一个任务实体sched_entity对应于一个任务task_struct</li>
<li>在task_struct中对应的sched_class会根据不同策略申明不同的对应处理函数，处理实际的调度工作</li>
</ul>
<h2 id="四-调度流程"><a href="#四-调度流程" class="headerlink" title="四. 调度流程"></a>四. 调度流程</h2><p>  有了上述的基本策略和基本调度结构体，我们可以形成大致的骨架，下面就是需要核心的调度流程将其拼凑成一个整体，实现调度系统。调度分为两种，主动调度和抢占式调度。</p>
<ul>
<li>主动调度即任务执行一定时间以后主动让出CPU，通过调度策略选择合适的下一个任务执行。</li>
<li>抢占式调度即任务执行中收到了其他任务的中断，由此停止执行并切换至下一个任务。</li>
</ul>
<h3 id="4-1-主动调度"><a href="#4-1-主动调度" class="headerlink" title="4.1 主动调度"></a>4.1 主动调度</h3><p>  说到调用，逃不过核心函数schedule()。其中sched_submit_work()函数完成当前任务的收尾工作，以避免出现如死锁或者IO中断等情况。之后首先禁止抢占式调度的发生，然后调用__schedule()函数完成调度，之后重新打开抢占式调度，如果需要重新调度则会一直重复该过程，否则结束函数。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">asmlinkage __visible <span class="type">void</span> __sched <span class="title function_">schedule</span><span class="params">(<span class="type">void</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">task_struct</span> *<span class="title">tsk</span> =</span> current;</span><br><span class="line">    sched_submit_work(tsk);</span><br><span class="line">    <span class="keyword">do</span> &#123;</span><br><span class="line">        preempt_disable();</span><br><span class="line">        __schedule(<span class="literal">false</span>);</span><br><span class="line">        sched_preempt_enable_no_resched();</span><br><span class="line">    &#125; <span class="keyword">while</span> (need_resched());</span><br><span class="line">&#125;</span><br><span class="line">EXPORT_SYMBOL(schedule);</span><br></pre></td></tr></table></figure>
<p>而__schedule()函数则是实际的核心调度函数，该函数主要操作包括选取下一进程和进行上下文切换，而上下文切换又包括用户态空间切换和内核态的切换。具体的解释可以参照英文源码注释以及中文对各个步骤的注释。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * __schedule() is the main scheduler function.</span></span><br><span class="line"><span class="comment"> * The main means of driving the scheduler and thus entering this function are:</span></span><br><span class="line"><span class="comment"> *   1. Explicit blocking: mutex, semaphore, waitqueue, etc.</span></span><br><span class="line"><span class="comment"> *   2. TIF_NEED_RESCHED flag is checked on interrupt and userspace return</span></span><br><span class="line"><span class="comment"> *      paths. For example, see arch/x86/entry_64.S.</span></span><br><span class="line"><span class="comment"> *      To drive preemption between tasks, the scheduler sets the flag in timer</span></span><br><span class="line"><span class="comment"> *      interrupt handler scheduler_tick().</span></span><br><span class="line"><span class="comment"> *   3. Wakeups don&#x27;t really cause entry into schedule(). They add a</span></span><br><span class="line"><span class="comment"> *      task to the run-queue and that&#x27;s it.</span></span><br><span class="line"><span class="comment"> *      Now, if the new task added to the run-queue preempts the current</span></span><br><span class="line"><span class="comment"> *      task, then the wakeup sets TIF_NEED_RESCHED and schedule() gets</span></span><br><span class="line"><span class="comment"> *      called on the nearest possible occasion:</span></span><br><span class="line"><span class="comment"> *       - If the kernel is preemptible (CONFIG_PREEMPT=y):</span></span><br><span class="line"><span class="comment"> *         - in syscall or exception context, at the next outmost</span></span><br><span class="line"><span class="comment"> *           preempt_enable(). (this might be as soon as the wake_up()&#x27;s</span></span><br><span class="line"><span class="comment"> *           spin_unlock()!)</span></span><br><span class="line"><span class="comment"> *         - in IRQ context, return from interrupt-handler to</span></span><br><span class="line"><span class="comment"> *           preemptible context</span></span><br><span class="line"><span class="comment"> *       - If the kernel is not preemptible (CONFIG_PREEMPT is not set)</span></span><br><span class="line"><span class="comment"> *         then at the next:</span></span><br><span class="line"><span class="comment"> *          - cond_resched() call</span></span><br><span class="line"><span class="comment"> *          - explicit schedule() call</span></span><br><span class="line"><span class="comment"> *          - return from syscall or exception to user-space</span></span><br><span class="line"><span class="comment"> *          - return from interrupt-handler to user-space</span></span><br><span class="line"><span class="comment"> * WARNING: must be called with preemption disabled!</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="type">static</span> <span class="type">void</span> __sched notrace __schedule(<span class="type">bool</span> preempt)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">task_struct</span> *<span class="title">prev</span>, *<span class="title">next</span>;</span></span><br><span class="line">    <span class="type">unsigned</span> <span class="type">long</span> *switch_count;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">rq_flags</span> <span class="title">rf</span>;</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">rq</span> *<span class="title">rq</span>;</span></span><br><span class="line">    <span class="type">int</span> cpu;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//从当前的CPU中取出任务队列rq，prev赋值为当前任务</span></span><br><span class="line">    cpu = smp_processor_id();</span><br><span class="line">    rq = cpu_rq(cpu);</span><br><span class="line">    prev = rq-&gt;curr;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//检测当前任务是否可以调度</span></span><br><span class="line">    schedule_debug(prev);</span><br><span class="line">    <span class="keyword">if</span> (sched_feat(HRTICK))</span><br><span class="line">        hrtick_clear(rq);</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//禁止中断，RCU抢占关闭，队列加锁，SMP加锁</span></span><br><span class="line">    local_irq_disable();</span><br><span class="line">    rcu_note_context_switch(preempt);</span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">     * Make sure that signal_pending_state()-&gt;signal_pending() below</span></span><br><span class="line"><span class="comment">     * can&#x27;t be reordered with __set_current_state(TASK_INTERRUPTIBLE)</span></span><br><span class="line"><span class="comment">     * done by the caller to avoid the race with signal_wake_up().</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * The membarrier system call requires a full memory barrier</span></span><br><span class="line"><span class="comment">     * after coming from user-space, before storing to rq-&gt;curr.</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    rq_lock(rq, &amp;rf);</span><br><span class="line">    smp_mb__after_spinlock();</span><br><span class="line">    </span><br><span class="line">    <span class="comment">/* Promote REQ to ACT */</span></span><br><span class="line">    rq-&gt;clock_update_flags &lt;&lt;= <span class="number">1</span>;</span><br><span class="line">    update_rq_clock(rq);</span><br><span class="line">    switch_count = &amp;prev-&gt;nivcsw;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">if</span> (!preempt &amp;&amp; prev-&gt;state) &#123;</span><br><span class="line">        <span class="comment">//不可中断的任务则继续执行</span></span><br><span class="line">        <span class="keyword">if</span> (signal_pending_state(prev-&gt;state, prev)) &#123;</span><br><span class="line">            prev-&gt;state = TASK_RUNNING;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="comment">//当前任务从队列rq中出队，on_rq设置为0，如果存在I/O未完成则延时完成</span></span><br><span class="line">            deactivate_task(rq, prev, DEQUEUE_SLEEP | DEQUEUE_NOCLOCK);</span><br><span class="line">            prev-&gt;on_rq = <span class="number">0</span>;</span><br><span class="line">            <span class="keyword">if</span> (prev-&gt;in_iowait) &#123;</span><br><span class="line">                <span class="type">atomic_inc</span>(&amp;rq-&gt;nr_iowait);</span><br><span class="line">                delayacct_blkio_start();</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">/* 唤醒睡眠进程</span></span><br><span class="line"><span class="comment">             * If a worker went to sleep, notify and ask workqueue</span></span><br><span class="line"><span class="comment">             * whether it wants to wake up a task to maintain</span></span><br><span class="line"><span class="comment">             * concurrency.</span></span><br><span class="line"><span class="comment">             */</span></span><br><span class="line">            <span class="keyword">if</span> (prev-&gt;flags &amp; PF_WQ_WORKER) &#123;</span><br><span class="line">                <span class="class"><span class="keyword">struct</span> <span class="title">task_struct</span> *<span class="title">to_wakeup</span>;</span></span><br><span class="line">                to_wakeup = wq_worker_sleeping(prev);</span><br><span class="line">                <span class="keyword">if</span> (to_wakeup)</span><br><span class="line">                    try_to_wake_up_local(to_wakeup, &amp;rf);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        switch_count = &amp;prev-&gt;nvcsw;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 调用pick_next_task获取下一个任务，赋值给next</span></span><br><span class="line">    next = pick_next_task(rq, prev, &amp;rf);</span><br><span class="line">    clear_tsk_need_resched(prev);</span><br><span class="line">    clear_preempt_need_resched();</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 如果产生了任务切换，则需要切换上下文</span></span><br><span class="line">    <span class="keyword">if</span> (likely(prev != next)) &#123;</span><br><span class="line">        rq-&gt;nr_switches++;</span><br><span class="line">        rq-&gt;curr = next;</span><br><span class="line">        <span class="comment">/*</span></span><br><span class="line"><span class="comment">         * The membarrier system call requires each architecture</span></span><br><span class="line"><span class="comment">         * to have a full memory barrier after updating</span></span><br><span class="line"><span class="comment">         * rq-&gt;curr, before returning to user-space.</span></span><br><span class="line"><span class="comment">         *</span></span><br><span class="line"><span class="comment">         * Here are the schemes providing that barrier on the</span></span><br><span class="line"><span class="comment">         * various architectures:</span></span><br><span class="line"><span class="comment">         * - mm ? switch_mm() : mmdrop() for x86, s390, sparc, PowerPC.</span></span><br><span class="line"><span class="comment">         *   switch_mm() rely on membarrier_arch_switch_mm() on PowerPC.</span></span><br><span class="line"><span class="comment">         * - finish_lock_switch() for weakly-ordered</span></span><br><span class="line"><span class="comment">         *   architectures where spin_unlock is a full barrier,</span></span><br><span class="line"><span class="comment">         * - switch_to() for arm64 (weakly-ordered, spin_unlock</span></span><br><span class="line"><span class="comment">         *   is a RELEASE barrier),</span></span><br><span class="line"><span class="comment">         */</span></span><br><span class="line">        ++*switch_count;</span><br><span class="line">        trace_sched_switch(preempt, prev, next);</span><br><span class="line">        <span class="comment">/* Also unlocks the rq: */</span></span><br><span class="line">        rq = context_switch(rq, prev, next, &amp;rf);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="comment">// 清除标记位，重开中断</span></span><br><span class="line">        rq-&gt;clock_update_flags &amp;= ~(RQCF_ACT_SKIP|RQCF_REQ_SKIP);</span><br><span class="line">        rq_unlock_irq(rq, &amp;rf);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//队列自平衡：红黑树平衡操作</span></span><br><span class="line">    balance_callback(rq);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>  其中核心函数是获取下一个任务的pick_next_task()以及上下文切换的context_switch()，下面详细展开剖析。首先看看pick_next_task()，该函数会根据调度策略分类，调用该类对应的调度函数选择下一个任务实体。根据前文分析我们知道，最终是在不同的红黑树上选择最左节点作为下一个任务实体并返回。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * Pick up the highest-prio task:</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="type">static</span> <span class="keyword">inline</span> <span class="keyword">struct</span> task_struct *</span><br><span class="line"><span class="title function_">pick_next_task</span><span class="params">(<span class="keyword">struct</span> rq *rq, <span class="keyword">struct</span> task_struct *prev, <span class="keyword">struct</span> rq_flags *rf)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">const</span> <span class="class"><span class="keyword">struct</span> <span class="title">sched_class</span> *<span class="keyword">class</span>;</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">task_struct</span> *<span class="title">p</span>;</span></span><br><span class="line">    <span class="comment">/* 这里做了一个优化：如果是普通调度策略则直接调用fair_sched_class中的pick_next_task</span></span><br><span class="line"><span class="comment">     * Optimization: we know that if all tasks are in the fair class we can</span></span><br><span class="line"><span class="comment">     * call that function directly, but only if the @prev task wasn&#x27;t of a</span></span><br><span class="line"><span class="comment">     * higher scheduling class, because otherwise those loose the</span></span><br><span class="line"><span class="comment">     * opportunity to pull in more work from other CPUs.</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">if</span> (likely((prev-&gt;sched_class == &amp;idle_sched_class ||</span><br><span class="line">            prev-&gt;sched_class == &amp;fair_sched_class) &amp;&amp;</span><br><span class="line">           rq-&gt;nr_running == rq-&gt;cfs.h_nr_running)) &#123;</span><br><span class="line">        p = fair_sched_class.pick_next_task(rq, prev, rf);</span><br><span class="line">        <span class="keyword">if</span> (unlikely(p == RETRY_TASK))</span><br><span class="line">            <span class="keyword">goto</span> again;</span><br><span class="line">        <span class="comment">/* Assumes fair_sched_class-&gt;next == idle_sched_class */</span></span><br><span class="line">        <span class="keyword">if</span> (unlikely(!p))</span><br><span class="line">            p = idle_sched_class.pick_next_task(rq, prev, rf);</span><br><span class="line">        <span class="keyword">return</span> p;</span><br><span class="line">    &#125;</span><br><span class="line">again:</span><br><span class="line">    <span class="comment">//依次调用类中的选择函数，如果正确选择到下一个任务则返回</span></span><br><span class="line">    for_each_class(class) &#123;</span><br><span class="line">        p = class-&gt;pick_next_task(rq, prev, rf);</span><br><span class="line">        <span class="keyword">if</span> (p) &#123;</span><br><span class="line">            <span class="keyword">if</span> (unlikely(p == RETRY_TASK))</span><br><span class="line">                <span class="keyword">goto</span> again;</span><br><span class="line">            <span class="keyword">return</span> p;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">/* The idle class should always have a runnable task: */</span></span><br><span class="line">    BUG();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>  下面来看看上下文切换。上下文切换主要干两件事情，一是切换任务空间，也即虚拟内存；二是切换寄存器和 CPU 上下文。关于任务空间的切换放在内存部分的文章中详细介绍，这里先按下不表，通过任务空间切换实际完成了用户态的上下文切换工作。下面我们重点看一下内核态切换，即寄存器和CPU上下文的切换。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * context_switch - switch to the new MM and the new thread&#x27;s register state.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="type">static</span> __always_inline <span class="keyword">struct</span> rq *</span><br><span class="line"><span class="title function_">context_switch</span><span class="params">(<span class="keyword">struct</span> rq *rq, <span class="keyword">struct</span> task_struct *prev,</span></span><br><span class="line"><span class="params">           <span class="keyword">struct</span> task_struct *next, <span class="keyword">struct</span> rq_flags *rf)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">mm_struct</span> *<span class="title">mm</span>, *<span class="title">oldmm</span>;</span></span><br><span class="line">    prepare_task_switch(rq, prev, next);</span><br><span class="line">    mm = next-&gt;mm;</span><br><span class="line">    oldmm = prev-&gt;active_mm;</span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">     * For paravirt, this is coupled with an exit in switch_to to</span></span><br><span class="line"><span class="comment">     * combine the page table reload and the switch backend into</span></span><br><span class="line"><span class="comment">     * one hypercall.</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    arch_start_context_switch(prev);</span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">     * If mm is non-NULL, we pass through switch_mm(). If mm is</span></span><br><span class="line"><span class="comment">     * NULL, we will pass through mmdrop() in finish_task_switch().</span></span><br><span class="line"><span class="comment">     * Both of these contain the full memory barrier required by</span></span><br><span class="line"><span class="comment">     * membarrier after storing to rq-&gt;curr, before returning to</span></span><br><span class="line"><span class="comment">     * user-space.</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">if</span> (!mm) &#123;</span><br><span class="line">        next-&gt;active_mm = oldmm;</span><br><span class="line">        mmgrab(oldmm);</span><br><span class="line">        enter_lazy_tlb(oldmm, next);</span><br><span class="line">    &#125; <span class="keyword">else</span></span><br><span class="line">        switch_mm_irqs_off(oldmm, mm, next);</span><br><span class="line">    <span class="keyword">if</span> (!prev-&gt;mm) &#123;</span><br><span class="line">        prev-&gt;active_mm = <span class="literal">NULL</span>;</span><br><span class="line">        rq-&gt;prev_mm = oldmm;</span><br><span class="line">    &#125;</span><br><span class="line">    rq-&gt;clock_update_flags &amp;= ~(RQCF_ACT_SKIP|RQCF_REQ_SKIP);</span><br><span class="line">    prepare_lock_switch(rq, next, rf);</span><br><span class="line">    <span class="comment">/* Here we just switch the register state and the stack. */</span></span><br><span class="line">    switch_to(prev, next, prev);</span><br><span class="line">    <span class="comment">//barrier 语句是一个编译器指令，用于保证 switch_to 和 finish_task_switch 的执行顺序不会因为编译阶段优化而改变</span></span><br><span class="line">    barrier();</span><br><span class="line">    <span class="keyword">return</span> finish_task_switch(prev);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>  switch_to()就是寄存器和栈的切换，它调用到了 __switch_to_asm。这是一段汇编代码，主要用于栈的切换， 其中32位使用esp作为栈顶指针，64位使用rsp，其他部分代码一致。通过该段汇编代码我们完成了栈顶指针的切换，并调用__switch_to完成最终TSS的切换。注意switch_to中其实是有三个变量，分别是prev, next, last，而实际在使用时，我们会对last也赋值为prev。这里的设计意图需要结合一个例子来说明。假设有ABC三个任务，从A调度到B，B到C，最后C回到A，我们假设仅保存prev和next，则流程如下</p>
<ul>
<li>A保存内核栈和寄存器，切换至B，此时prev &#x3D; A, next &#x3D; B，该状态会保存在栈里，等下次调用A的时候再恢复。然后调用B的finish_task_switch()继续执行下去，返回B的队列rq，</li>
<li>B保存内核栈和寄存器，切换至C</li>
<li>C保存内核栈和寄存器，切换至A。A从barrier()开始运行，而A从步骤1中保存的prev &#x3D; A, next &#x3D; B则完美的避开了C，丢失了C的信息。因此last指针的重要性就出现了。在执行完__switch_to_asm后，A的内核栈和寄存器重新覆盖了prev和next，但是我们通过返回值提供了C的内存地址，保存在last中，在finish_task_switch中完成清理工作。</li>
</ul>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">define</span> switch_to(prev, next, last)			      \</span></span><br><span class="line"><span class="meta">do &#123;									       \</span></span><br><span class="line"><span class="meta">    prepare_switch_to(next);					\</span></span><br><span class="line"><span class="meta">                                               \</span></span><br><span class="line"><span class="meta">    ((last) = __switch_to_asm((prev), (next)));	  \</span></span><br><span class="line"><span class="meta">&#125; while (0)</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * %eax: prev task</span></span><br><span class="line"><span class="comment"> * %edx: next task</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line">ENTRY(__switch_to_asm)</span><br><span class="line">......</span><br><span class="line">  <span class="comment">/* switch stack */</span></span><br><span class="line">  movl  %esp, TASK_threadsp(%eax)</span><br><span class="line">  movl  <span class="title function_">TASK_threadsp</span><span class="params">(%edx)</span>, %esp</span><br><span class="line">......</span><br><span class="line">  jmp  __switch_to</span><br><span class="line"><span class="title function_">END</span><span class="params">(__switch_to_asm)</span></span><br></pre></td></tr></table></figure>
<p>  最终调用__switch_to()函数。该函数中涉及到一个结构体TSS(Task State Segment)，该结构体存放了所有的寄存器。另外还有一个特殊的寄存器TR（Task Register）会指向TSS，我们通过更改TR的值，会触发硬件保存CPU所有寄存器在当前TSS，并从新的TSS读取寄存器的值加载入CPU，从而完成一次硬中断带来的上下文切换工作。系统初始化的时候，会调用 cpu_init()给每一个 CPU 关联一个 TSS，然后将 TR 指向这个 TSS，然后在操作系统的运行过程中，TR 就不切换了，永远指向这个 TSS。当修改TR的值得时候，则为任务调度。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> *	switch_to(x,y) should switch tasks from x to y.</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * We fsave/fwait so that an exception goes off at the right time</span></span><br><span class="line"><span class="comment"> * (as a call from the fsave or fwait in effect) rather than to</span></span><br><span class="line"><span class="comment"> * the wrong process. Lazy FP saving no longer makes any sense</span></span><br><span class="line"><span class="comment"> * with modern CPU&#x27;s, and this simplifies a lot of things (SMP</span></span><br><span class="line"><span class="comment"> * and UP become the same).</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * NOTE! We used to use the x86 hardware context switching. The</span></span><br><span class="line"><span class="comment"> * reason for not using it any more becomes apparent when you</span></span><br><span class="line"><span class="comment"> * try to recover gracefully from saved state that is no longer</span></span><br><span class="line"><span class="comment"> * valid (stale segment register values in particular). With the</span></span><br><span class="line"><span class="comment"> * hardware task-switch, there is no way to fix up bad state in</span></span><br><span class="line"><span class="comment"> * a reasonable manner.</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * The fact that Intel documents the hardware task-switching to</span></span><br><span class="line"><span class="comment"> * be slow is a fairly red herring - this code is not noticeably</span></span><br><span class="line"><span class="comment"> * faster. However, there _is_ some room for improvement here,</span></span><br><span class="line"><span class="comment"> * so the performance issues may eventually be a valid point.</span></span><br><span class="line"><span class="comment"> * More important, however, is the fact that this allows us much</span></span><br><span class="line"><span class="comment"> * more flexibility.</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * The return value (in %ax) will be the &quot;prev&quot; task after</span></span><br><span class="line"><span class="comment"> * the task-switch, and shows up in ret_from_fork in entry.S,</span></span><br><span class="line"><span class="comment"> * for example.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line">__visible __notrace_funcgraph <span class="class"><span class="keyword">struct</span> <span class="title">task_struct</span> *</span></span><br><span class="line"><span class="class">__<span class="title">switch_to</span>(<span class="keyword">struct</span> <span class="title">task_struct</span> *<span class="title">prev_p</span>, <span class="keyword">struct</span> <span class="title">task_struct</span> *<span class="title">next_p</span>)</span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">thread_struct</span> *<span class="title">prev</span> =</span> &amp;prev_p-&gt;thread,</span><br><span class="line">                 *next = &amp;next_p-&gt;thread;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">fpu</span> *<span class="title">prev_fpu</span> =</span> &amp;prev-&gt;fpu;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">fpu</span> *<span class="title">next_fpu</span> =</span> &amp;next-&gt;fpu;</span><br><span class="line">    <span class="type">int</span> cpu = smp_processor_id();</span><br><span class="line">    <span class="comment">/* never put a printk in __switch_to... printk() calls wake_up*() indirectly */</span></span><br><span class="line">    switch_fpu_prepare(prev_fpu, cpu);</span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">     * Save away %gs. No need to save %fs, as it was saved on the</span></span><br><span class="line"><span class="comment">     * stack on entry.  No need to save %es and %ds, as those are</span></span><br><span class="line"><span class="comment">     * always kernel segments while inside the kernel.  Doing this</span></span><br><span class="line"><span class="comment">     * before setting the new TLS descriptors avoids the situation</span></span><br><span class="line"><span class="comment">     * where we temporarily have non-reloadable segments in %fs</span></span><br><span class="line"><span class="comment">     * and %gs.  This could be an issue if the NMI handler ever</span></span><br><span class="line"><span class="comment">     * used %fs or %gs (it does not today), or if the kernel is</span></span><br><span class="line"><span class="comment">     * running inside of a hypervisor layer.</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    lazy_save_gs(prev-&gt;gs);</span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">     * Load the per-thread Thread-Local Storage descriptor.</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    load_TLS(next, cpu);</span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">     * Restore IOPL if needed.  In normal use, the flags restore</span></span><br><span class="line"><span class="comment">     * in the switch assembly will handle this.  But if the kernel</span></span><br><span class="line"><span class="comment">     * is running virtualized at a non-zero CPL, the popf will</span></span><br><span class="line"><span class="comment">     * not restore flags, so it must be done in a separate step.</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">if</span> (get_kernel_rpl() &amp;&amp; unlikely(prev-&gt;iopl != next-&gt;iopl))</span><br><span class="line">        set_iopl_mask(next-&gt;iopl);</span><br><span class="line">    switch_to_extra(prev_p, next_p);</span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">     * Leave lazy mode, flushing any hypercalls made here.</span></span><br><span class="line"><span class="comment">     * This must be done before restoring TLS segments so</span></span><br><span class="line"><span class="comment">     * the GDT and LDT are properly updated, and must be</span></span><br><span class="line"><span class="comment">     * done before fpu__restore(), so the TS bit is up</span></span><br><span class="line"><span class="comment">     * to date.</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    arch_end_context_switch(next_p);</span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">     * Reload esp0 and cpu_current_top_of_stack.  This changes</span></span><br><span class="line"><span class="comment">     * current_thread_info().  Refresh the SYSENTER configuration in</span></span><br><span class="line"><span class="comment">     * case prev or next is vm86.</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    update_task_stack(next_p);</span><br><span class="line">    refresh_sysenter_cs(next);</span><br><span class="line">    this_cpu_write(cpu_current_top_of_stack,</span><br><span class="line">               (<span class="type">unsigned</span> <span class="type">long</span>)task_stack_page(next_p) +</span><br><span class="line">               THREAD_SIZE);</span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">     * Restore %gs if needed (which is common)</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">if</span> (prev-&gt;gs | next-&gt;gs)</span><br><span class="line">        lazy_load_gs(next-&gt;gs);</span><br><span class="line">    switch_fpu_finish(next_fpu, cpu);</span><br><span class="line">    this_cpu_write(current_task, next_p);</span><br><span class="line">    <span class="comment">/* Load the Intel cache allocation PQR MSR. */</span></span><br><span class="line">    resctrl_sched_in();</span><br><span class="line">    <span class="keyword">return</span> prev_p;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>  在完成了switch_to()的内核态切换后，还有一个重要的函数finish_task_switch()负责善后清理工作。在前面介绍switch_to三个参数的时候我们已经说明了使用last的重要性。而这里为何让prev和last均赋值为prev，是因为prev在后面没有需要用到，所以节省了一个指针空间来存储last。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * finish_task_switch - clean up after a task-switch</span></span><br><span class="line"><span class="comment"> * @prev: the thread we just switched away from.</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * finish_task_switch must be called after the context switch, paired</span></span><br><span class="line"><span class="comment"> * with a prepare_task_switch call before the context switch.</span></span><br><span class="line"><span class="comment"> * finish_task_switch will reconcile locking set up by prepare_task_switch,</span></span><br><span class="line"><span class="comment"> * and do any other architecture-specific cleanup actions.</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * Note that we may have delayed dropping an mm in context_switch(). If</span></span><br><span class="line"><span class="comment"> * so, we finish that here outside of the runqueue lock. (Doing it</span></span><br><span class="line"><span class="comment"> * with the lock held can cause deadlocks; see schedule() for</span></span><br><span class="line"><span class="comment"> * details.)</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * The context switch have flipped the stack from under us and restored the</span></span><br><span class="line"><span class="comment"> * local variables which were saved when this task called schedule() in the</span></span><br><span class="line"><span class="comment"> * past. prev == current is still correct but we need to recalculate this_rq</span></span><br><span class="line"><span class="comment"> * because prev may have moved to another CPU.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="type">static</span> <span class="keyword">struct</span> rq *<span class="title function_">finish_task_switch</span><span class="params">(<span class="keyword">struct</span> task_struct *prev)</span></span><br><span class="line">    __<span class="title function_">releases</span><span class="params">(rq-&gt;lock)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">rq</span> *<span class="title">rq</span> =</span> this_rq();</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">mm_struct</span> *<span class="title">mm</span> =</span> rq-&gt;prev_mm;</span><br><span class="line">    <span class="type">long</span> prev_state;</span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">     * The previous task will have left us with a preempt_count of 2</span></span><br><span class="line"><span class="comment">     * because it left us after:</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     *	schedule()</span></span><br><span class="line"><span class="comment">     *	  preempt_disable();			// 1</span></span><br><span class="line"><span class="comment">     *	  __schedule()</span></span><br><span class="line"><span class="comment">     *	    raw_spin_lock_irq(&amp;rq-&gt;lock)	// 2</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * Also, see FORK_PREEMPT_COUNT.</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">if</span> (WARN_ONCE(preempt_count() != <span class="number">2</span>*PREEMPT_DISABLE_OFFSET,</span><br><span class="line">              <span class="string">&quot;corrupted preempt_count: %s/%d/0x%x\n&quot;</span>,</span><br><span class="line">              current-&gt;comm, current-&gt;pid, preempt_count()))</span><br><span class="line">        preempt_count_set(FORK_PREEMPT_COUNT);</span><br><span class="line">    rq-&gt;prev_mm = <span class="literal">NULL</span>;</span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">     * A task struct has one reference for the use as &quot;current&quot;.</span></span><br><span class="line"><span class="comment">     * If a task dies, then it sets TASK_DEAD in tsk-&gt;state and calls</span></span><br><span class="line"><span class="comment">     * schedule one last time. The schedule call will never return, and</span></span><br><span class="line"><span class="comment">     * the scheduled task must drop that reference.</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * We must observe prev-&gt;state before clearing prev-&gt;on_cpu (in</span></span><br><span class="line"><span class="comment">     * finish_task), otherwise a concurrent wakeup can get prev</span></span><br><span class="line"><span class="comment">     * running on another CPU and we could rave with its RUNNING -&gt; DEAD</span></span><br><span class="line"><span class="comment">     * transition, resulting in a double drop.</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    prev_state = prev-&gt;state;</span><br><span class="line">    vtime_task_switch(prev);</span><br><span class="line">    perf_event_task_sched_in(prev, current);</span><br><span class="line">    finish_task(prev);</span><br><span class="line">    finish_lock_switch(rq);</span><br><span class="line">    finish_arch_post_lock_switch();</span><br><span class="line">    kcov_finish_switch(current);</span><br><span class="line">    fire_sched_in_preempt_notifiers(current);</span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">     * When switching through a kernel thread, the loop in</span></span><br><span class="line"><span class="comment">     * membarrier_&#123;private,global&#125;_expedited() may have observed that</span></span><br><span class="line"><span class="comment">     * kernel thread and not issued an IPI. It is therefore possible to</span></span><br><span class="line"><span class="comment">     * schedule between user-&gt;kernel-&gt;user threads without passing though</span></span><br><span class="line"><span class="comment">     * switch_mm(). Membarrier requires a barrier after storing to</span></span><br><span class="line"><span class="comment">     * rq-&gt;curr, before returning to userspace, so provide them here:</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * - a full memory barrier for &#123;PRIVATE,GLOBAL&#125;_EXPEDITED, implicitly</span></span><br><span class="line"><span class="comment">     *   provided by mmdrop(),</span></span><br><span class="line"><span class="comment">     * - a sync_core for SYNC_CORE.</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">if</span> (mm) &#123;</span><br><span class="line">        membarrier_mm_sync_core_before_usermode(mm);</span><br><span class="line">        mmdrop(mm);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (unlikely(prev_state == TASK_DEAD)) &#123;</span><br><span class="line">        <span class="keyword">if</span> (prev-&gt;sched_class-&gt;task_dead)</span><br><span class="line">            prev-&gt;sched_class-&gt;task_dead(prev);</span><br><span class="line">        <span class="comment">/*</span></span><br><span class="line"><span class="comment">         * Remove function-return probe instances associated with this</span></span><br><span class="line"><span class="comment">         * task and put them back on the free list.</span></span><br><span class="line"><span class="comment">         */</span></span><br><span class="line">        kprobe_flush_task(prev);</span><br><span class="line">        <span class="comment">/* Task is done with its stack. */</span></span><br><span class="line">        put_task_stack(prev);</span><br><span class="line">        put_task_struct(prev);</span><br><span class="line">    &#125;</span><br><span class="line">    tick_nohz_task_switch();</span><br><span class="line">    <span class="keyword">return</span> rq;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>  至此，我们完成了内核态的切换工作，也完成了整个主动调度的过程。</p>
<h3 id="4-2-抢占式调度"><a href="#4-2-抢占式调度" class="headerlink" title="4.2 抢占式调度"></a>4.2 抢占式调度</h3><p>  抢占式调度通常发生在两种情况下。一种是某任务执行时间过长，另一种是当某任务被唤醒的时候。首先看看任务执行时间过长的情况。</p>
<h4 id="4-2-1-任务运行时间检测"><a href="#4-2-1-任务运行时间检测" class="headerlink" title="4.2.1 任务运行时间检测"></a>4.2.1 任务运行时间检测</h4><p>  该情况需要衡量一个任务的执行时间长短，执行时间过长则发起抢占。在计算机里面有一个时钟，会过一段时间触发一次时钟中断，通知操作系统时间又过去一个时钟周期，通过这种方式可以查看是否是需要抢占的时间点。</p>
<p>  时钟中断处理函数会调用scheduler_tick()。该函数首先取出当前CPU，并由此获取对应的运行队列rq和当前任务curr。接着调用该任务的调度类sched_class对应的task_tick()函数进行时间事件处理。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * This function gets called by the timer code, with HZ frequency.</span></span><br><span class="line"><span class="comment"> * We call it with interrupts disabled.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">scheduler_tick</span><span class="params">(<span class="type">void</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">int</span> cpu = smp_processor_id();</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">rq</span> *<span class="title">rq</span> =</span> cpu_rq(cpu);</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">task_struct</span> *<span class="title">curr</span> =</span> rq-&gt;curr;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">rq_flags</span> <span class="title">rf</span>;</span></span><br><span class="line">    sched_clock_tick();</span><br><span class="line">    rq_lock(rq, &amp;rf);</span><br><span class="line">    update_rq_clock(rq);</span><br><span class="line">    curr-&gt;sched_class-&gt;task_tick(rq, curr, <span class="number">0</span>);</span><br><span class="line">    cpu_load_update_active(rq);</span><br><span class="line">    calc_global_load_tick(rq);</span><br><span class="line">    psi_task_tick(rq);</span><br><span class="line">    rq_unlock(rq, &amp;rf);</span><br><span class="line">    perf_event_task_tick();</span><br><span class="line">......</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>  以普通任务队列为例，对应的调度类为fair_sched_class，对应的时钟处理函数为task_tick_fair()，该函数会获取当前的调度实体和运行队列，并调用entity_tick()函数更新时间。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * scheduler tick hitting a task of our scheduling class.</span></span><br><span class="line"><span class="comment"> * <span class="doctag">NOTE:</span> This function can be called remotely by the tick offload that</span></span><br><span class="line"><span class="comment"> * goes along full dynticks. Therefore no local assumption can be made</span></span><br><span class="line"><span class="comment"> * and everything must be accessed through the @rq and @curr passed in</span></span><br><span class="line"><span class="comment"> * parameters.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="type">static</span> <span class="type">void</span> <span class="title function_">task_tick_fair</span><span class="params">(<span class="keyword">struct</span> rq *rq, <span class="keyword">struct</span> task_struct *curr, <span class="type">int</span> queued)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">cfs_rq</span> *<span class="title">cfs_rq</span>;</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">sched_entity</span> *<span class="title">se</span> =</span> &amp;curr-&gt;se;</span><br><span class="line">    for_each_sched_entity(se) &#123;</span><br><span class="line">        cfs_rq = cfs_rq_of(se);</span><br><span class="line">        entity_tick(cfs_rq, se, queued);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (static_branch_unlikely(&amp;sched_numa_balancing))</span><br><span class="line">        task_tick_numa(rq, curr);</span><br><span class="line">    update_misfit_status(curr, rq);</span><br><span class="line">    update_overutilized_status(task_rq(curr));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>  在entity_tick()中，首先会调用update_curr()更新当前任务的vruntime，然后调用check_preempt_tick()检测现在是否可以发起抢占。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">static</span> <span class="type">void</span></span><br><span class="line"><span class="title function_">entity_tick</span><span class="params">(<span class="keyword">struct</span> cfs_rq *cfs_rq, <span class="keyword">struct</span> sched_entity *curr, <span class="type">int</span> queued)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">     * Update run-time statistics of the &#x27;current&#x27;.</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    update_curr(cfs_rq);</span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">     * Ensure that runnable average is periodically updated.</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    update_load_avg(cfs_rq, curr, UPDATE_TG);</span><br><span class="line">    update_cfs_group(curr);</span><br><span class="line">......</span><br><span class="line">    <span class="keyword">if</span> (cfs_rq-&gt;nr_running &gt; <span class="number">1</span>)</span><br><span class="line">        check_preempt_tick(cfs_rq, curr);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>  check_preempt_tick() 先是调用 sched_slice() 函数计算出一个调度周期中该任务运行的实际时间 ideal_runtime。sum_exec_runtime 指任务总共执行的实际时间，prev_sum_exec_runtime 指上次该进程被调度时已经占用的实际时间，所以 sum_exec_runtime - prev_sum_exec_runtime 就是这次调度占用实际时间。如果这个时间大于 ideal_runtime，则应该被抢占了。除了这个条件之外，还会通过 __pick_first_entity 取出红黑树中最小的进程。如果当前进程的 vruntime 大于红黑树中最小的进程的 vruntime，且差值大于 ideal_runtime，也应该被抢占了。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * Preempt the current task with a newly woken task if needed:</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="type">static</span> <span class="type">void</span></span><br><span class="line"><span class="title function_">check_preempt_tick</span><span class="params">(<span class="keyword">struct</span> cfs_rq *cfs_rq, <span class="keyword">struct</span> sched_entity *curr)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">unsigned</span> <span class="type">long</span> ideal_runtime, delta_exec;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">sched_entity</span> *<span class="title">se</span>;</span></span><br><span class="line">    s64 delta;</span><br><span class="line">    ideal_runtime = sched_slice(cfs_rq, curr);</span><br><span class="line">    delta_exec = curr-&gt;sum_exec_runtime - curr-&gt;prev_sum_exec_runtime;</span><br><span class="line">    <span class="keyword">if</span> (delta_exec &gt; ideal_runtime) &#123;</span><br><span class="line">        resched_curr(rq_of(cfs_rq));</span><br><span class="line">        <span class="comment">/*</span></span><br><span class="line"><span class="comment">         * The current task ran long enough, ensure it doesn&#x27;t get</span></span><br><span class="line"><span class="comment">         * re-elected due to buddy favours.</span></span><br><span class="line"><span class="comment">         */</span></span><br><span class="line">        clear_buddies(cfs_rq, curr);</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">     * Ensure that a task that missed wakeup preemption by a</span></span><br><span class="line"><span class="comment">     * narrow margin doesn&#x27;t have to wait for a full slice.</span></span><br><span class="line"><span class="comment">     * This also mitigates buddy induced latencies under load.</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">if</span> (delta_exec &lt; sysctl_sched_min_granularity)</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    se = __pick_first_entity(cfs_rq);</span><br><span class="line">    delta = curr-&gt;vruntime - se-&gt;vruntime;</span><br><span class="line">    <span class="keyword">if</span> (delta &lt; <span class="number">0</span>)</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    <span class="keyword">if</span> (delta &gt; ideal_runtime)</span><br><span class="line">        resched_curr(rq_of(cfs_rq));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>  如果确认需要被抢占，则会调用resched_curr()函数，该函数会调用set_tsk_need_resched()标记该任务为_TIF_NEED_RESCHED，即该任务应该被抢占。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * resched_curr - mark rq&#x27;s current task &#x27;to be rescheduled now&#x27;.</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * On UP this means the setting of the need_resched flag, on SMP it</span></span><br><span class="line"><span class="comment"> * might also involve a cross-CPU call to trigger the scheduler on</span></span><br><span class="line"><span class="comment"> * the target CPU.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">resched_curr</span><span class="params">(<span class="keyword">struct</span> rq *rq)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">task_struct</span> *<span class="title">curr</span> =</span> rq-&gt;curr;</span><br><span class="line">    <span class="type">int</span> cpu;</span><br><span class="line">.......</span><br><span class="line">    cpu = cpu_of(rq);</span><br><span class="line">    <span class="keyword">if</span> (cpu == smp_processor_id()) &#123;</span><br><span class="line">        set_tsk_need_resched(curr);</span><br><span class="line">        set_preempt_need_resched();</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (set_nr_and_not_polling(curr))</span><br><span class="line">        smp_send_reschedule(cpu);</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">        trace_sched_wake_idle_without_ipi(cpu);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="4-2-2-任务唤醒情况"><a href="#4-2-2-任务唤醒情况" class="headerlink" title="4.2.2 任务唤醒情况"></a>4.2.2 任务唤醒情况</h4><p>  某些任务会因为中断而唤醒，如当 I&#x2F;O 到来的时候，I&#x2F;O进程往往会被唤醒。在这种时候，如果被唤醒的任务优先级高于 CPU 上的当前任务，就会触发抢占。try_to_wake_up() 调用 ttwu_queue() 将这个唤醒的任务添加到队列当中。ttwu_queue() 再调用 ttwu_do_activate() 激活这个任务。ttwu_do_activate() 调用 ttwu_do_wakeup()。这里面调用了 check_preempt_curr() 检查是否应该发生抢占。如果应该发生抢占，也不是直接踢走当前进程，而是将当前进程标记为应该被抢占。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">static</span> <span class="type">void</span> <span class="title function_">ttwu_do_wakeup</span><span class="params">(<span class="keyword">struct</span> rq *rq, <span class="keyword">struct</span> task_struct *p, <span class="type">int</span> wake_flags,</span></span><br><span class="line"><span class="params">         <span class="keyword">struct</span> rq_flags *rf)</span></span><br><span class="line">&#123;</span><br><span class="line">  check_preempt_curr(rq, p, wake_flags);</span><br><span class="line">  p-&gt;state = TASK_RUNNING;</span><br><span class="line">  trace_sched_wakeup(p);</span><br></pre></td></tr></table></figure>
<h4 id="4-2-3-抢占的发生"><a href="#4-2-3-抢占的发生" class="headerlink" title="4.2.3 抢占的发生"></a>4.2.3 抢占的发生</h4><p>由前面的分析，我们知道了不论是是当前任务执行时间过长还是新任务唤醒，我们均会对现在的任务标记位_TIF_NEED_RESCUED，下面分析实际抢占的发生。真正的抢占还需要一个特定的时机让正在运行中的进程有机会调用一下 __schedule()函数，发起真正的调度。</p>
<p>实际上会调用__schedule()函数共有以下几个时机</p>
<p>从系统调用返回用户态：以64位为例，系统调用的链路为do_syscall_64-&gt;syscall_return_slowpath-&gt;prepare_exit_to_usermode-&gt;exit_to_usermode_loop。在exit_to_usermode_loop中，会检测是否为_TIF_NEED_RESCHED，如果是则调用__schedule()</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">static</span> <span class="type">void</span> <span class="title function_">exit_to_usermode_loop</span><span class="params">(<span class="keyword">struct</span> pt_regs *regs, u32 cached_flags)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">while</span> (<span class="literal">true</span>) &#123;</span><br><span class="line">        <span class="comment">/* We have work to do. */</span></span><br><span class="line">        local_irq_enable();</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (cached_flags &amp; _TIF_NEED_RESCHED)</span><br><span class="line">          schedule();</span><br><span class="line">......</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure>
<p>内核态启动：内核态的执行中，被抢占的时机一般发生在 preempt_enable() 中。在内核态的执行中，有的操作是不能被中断的，所以在进行这些操作之前，总是先调用 preempt_disable() 关闭抢占，当再次打开的时候，就是一次内核态代码被抢占的机会。preempt_enable() 会调用 preempt_count_dec_and_test()，判断 preempt_count 和 TIF_NEED_RESCHED 是否可以被抢占。如果可以，就调用 preempt_schedule-&gt;preempt_schedule_common-&gt;__schedule 进行调度。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">define</span> preempt_enable() \</span></span><br><span class="line"><span class="meta">do &#123; \</span></span><br><span class="line"><span class="meta">  <span class="keyword">if</span> (unlikely(preempt_count_dec_and_test())) \</span></span><br><span class="line"><span class="meta">    __preempt_schedule(); \</span></span><br><span class="line"><span class="meta">&#125; while (0)</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> preempt_count_dec_and_test() \</span></span><br><span class="line"><span class="meta">(&#123; preempt_count_sub(1); should_resched(0); &#125;)</span></span><br><span class="line"></span><br><span class="line"><span class="type">static</span> __always_inline <span class="type">bool</span> <span class="title function_">should_resched</span><span class="params">(<span class="type">int</span> preempt_offset)</span></span><br><span class="line">&#123;</span><br><span class="line">  <span class="keyword">return</span> unlikely(preempt_count() == preempt_offset &amp;&amp;</span><br><span class="line">      tif_need_resched());</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> tif_need_resched() test_thread_flag(TIF_NEED_RESCHED)</span></span><br><span class="line"></span><br><span class="line"><span class="type">static</span> <span class="type">void</span> __sched notrace <span class="title function_">preempt_schedule_common</span><span class="params">(<span class="type">void</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">  <span class="keyword">do</span> &#123;</span><br><span class="line">......</span><br><span class="line">    __schedule(<span class="literal">true</span>);</span><br><span class="line">......</span><br><span class="line">  &#125; <span class="keyword">while</span> (need_resched())</span><br></pre></td></tr></table></figure>

<ul>
<li>从中断返回内核态&#x2F;用户态：中断处理调用的是 do_IRQ 函数，中断完毕后分为两种情况，一个是返回用户态，一个是返回内核态。<ul>
<li>返回用户态会调用 prepare_exit_to_usermode()，最终调用 exit_to_usermode_loop()</li>
<li>返回内核态会调用preempt_schedule_irq()，最终调用__schedule()</li>
</ul>
</li>
</ul>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line">common_interrupt:</span><br><span class="line">        ASM_CLAC</span><br><span class="line">        addq    $<span class="number">-0x80</span>, (%rsp) </span><br><span class="line">        interrupt do_IRQ</span><br><span class="line">ret_from_intr:</span><br><span class="line">        popq    %rsp</span><br><span class="line">        testb   $<span class="number">3</span>, CS(%rsp)</span><br><span class="line">        jz      retint_kernel</span><br><span class="line"><span class="comment">/* Interrupt came from user space */</span></span><br><span class="line">GLOBAL(retint_user)</span><br><span class="line">        mov     %rsp,%rdi</span><br><span class="line">        call    prepare_exit_to_usermode</span><br><span class="line">        TRACE_IRQS_IRETQ</span><br><span class="line">        SWAPGS</span><br><span class="line">        jmp     restore_regs_and_iret</span><br><span class="line"><span class="comment">/* Returning to kernel space */</span></span><br><span class="line">retint_kernel:</span><br><span class="line"><span class="meta">#<span class="keyword">ifdef</span> CONFIG_PREEMPT</span></span><br><span class="line">        bt      $<span class="number">9</span>, EFLAGS(%rsp)  </span><br><span class="line">        jnc     <span class="number">1f</span></span><br><span class="line"><span class="number">0</span>:      cmpl    $<span class="number">0</span>, PER_CPU_VAR(__preempt_count)</span><br><span class="line">        jnz     <span class="number">1f</span></span><br><span class="line">        call    preempt_schedule_irq</span><br><span class="line">        jmp     <span class="number">0b</span></span><br></pre></td></tr></table></figure>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">asmlinkage __visible <span class="type">void</span> __sched <span class="title function_">preempt_schedule_irq</span><span class="params">(<span class="type">void</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">......</span><br><span class="line">  <span class="keyword">do</span> &#123;</span><br><span class="line">    preempt_disable();</span><br><span class="line">    local_irq_enable();</span><br><span class="line">    __schedule(<span class="literal">true</span>);</span><br><span class="line">    local_irq_disable();</span><br><span class="line">    sched_preempt_enable_no_resched();</span><br><span class="line">  &#125; <span class="keyword">while</span> (need_resched());</span><br><span class="line">......</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="五-总结"><a href="#五-总结" class="headerlink" title="五. 总结"></a>五. 总结</h2><p>  <br>  本文分析了任务调度的策略、结构体以及整个调度流程，其中关于内存上下文切换的部分尚未详细叙述，留待内存部分展开剖析。</p>
<h2 id="源码资料"><a href="#源码资料" class="headerlink" title="源码资料"></a>源码资料</h2><p>1、<a target="_blank" rel="noopener" href="https://code.woboq.org/linux/linux/kernel/sched/">调度相关结构体及函数实现</a></p>
<p>2、<a target="_blank" rel="noopener" href="https://code.woboq.org/linux/linux/kernel/sched/core.c.html#__schedule">schedule核心函数</a></p>

<div class="article-footer fs14">
    <section id="license">
      <div class="header"><span>许可协议</span></div>
      <div class="body"><p>本文采用 <a target="_blank" rel="noopener" href="https://creativecommons.org/licenses/by-nc-sa/4.0/">署名-非商业性使用-相同方式共享 4.0 国际</a> 许可协议，转载请注明出处。</p>
</div>
    </section>
    </div>
</article>
<div class="related-wrap" id="read-next"><section class="body"><div class="item" id="prev"><div class="note">较新文章</div><a href="/2023/01/15/linux-docs/%E8%BF%9B%E7%A8%8B%E7%AE%A1%E7%90%86/%E4%B8%80%E6%96%87%E5%B8%A6%E4%BD%A0%EF%BC%8C%E5%BD%BB%E5%BA%95%E4%BA%86%E8%A7%A3%EF%BC%8C%E9%9B%B6%E6%8B%B7%E8%B4%9DZero-Copy%E6%8A%80%E6%9C%AF/">一文带你，彻底了解，零拷贝Zero-Copy技术</a></div><div class="item" id="next"><div class="note">较早文章</div><a href="/2023/01/15/linux-docs/%E8%BF%9B%E7%A8%8B%E7%AE%A1%E7%90%86/%E8%BF%9B%E7%A8%8B%E3%80%81%E7%BA%BF%E7%A8%8B%E7%9A%84%E5%88%9B%E5%BB%BA%E5%92%8C%E6%B4%BE%E7%94%9F/">进程、线程的创建和派生</a></div></section></div>






<footer class="page-footer footnote"><hr><div class="sitemap"><div class="sitemap-group"><span class="fs15">博客</span><a href="/">近期</a><a href="/">分类</a><a href="/">标签</a><a href="/">归档</a></div><div class="sitemap-group"><span class="fs15">项目</span><a href="/">开源库</a></div><div class="sitemap-group"><span class="fs15">社交</span><a href="/">友链</a><a href="/">留言板</a></div><div class="sitemap-group"><span class="fs15">更多</span><a href="/">关于本站</a><a href="/">GitHub</a></div></div><div class="text"><p>本站由 <a href="/">ysme</a> 使用 <a target="_blank" rel="noopener" href="https://github.com/xaoxuu/hexo-theme-stellar/tree/1.27.0">Stellar 1.27.0</a> 主题创建。<br>本博客所有文章除特别声明外，均采用 <a target="_blank" rel="noopener" href="https://creativecommons.org/licenses/by-nc-sa/4.0/">CC BY-NC-SA 4.0</a> 许可协议，转载请注明出处。</p>
</div></footer>
<div class="main-mask" onclick="sidebar.dismiss()"></div></div><aside class="l_right">
<div class="widgets">



<widget class="widget-wrapper toc" id="data-toc" collapse="false"><div class="widget-header dis-select"><span class="name">本文目录</span><a class="cap-action" onclick="sidebar.toggleTOC()" ><svg xmlns="http://www.w3.org/2000/svg" width="32" height="32" viewBox="0 0 24 24"><path fill="none" stroke="currentColor" stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M10 6h11m-11 6h11m-11 6h11M4 6h1v4m-1 0h2m0 8H4c0-1 2-2 2-3s-1-1.5-2-1"/></svg></a></div><div class="widget-body"><ol class="toc"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%B8%80-%E5%89%8D%E8%A8%80"><span class="toc-text">一. 前言</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%BA%8C-%E8%B0%83%E5%BA%A6%E7%AD%96%E7%95%A5"><span class="toc-text">二. 调度策略</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#2-1-%E5%AE%9E%E6%97%B6%E8%B0%83%E5%BA%A6%E7%AD%96%E7%95%A5"><span class="toc-text">2.1 实时调度策略</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#2-2-%E6%99%AE%E9%80%9A%E8%B0%83%E5%BA%A6%E7%AD%96%E7%95%A5"><span class="toc-text">2.2 普通调度策略</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%B8%89-%E8%B0%83%E5%BA%A6%E7%9B%B8%E5%85%B3%E7%9A%84%E7%BB%93%E6%9E%84%E4%BD%93"><span class="toc-text">三. 调度相关的结构体</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%9B%9B-%E8%B0%83%E5%BA%A6%E6%B5%81%E7%A8%8B"><span class="toc-text">四. 调度流程</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#4-1-%E4%B8%BB%E5%8A%A8%E8%B0%83%E5%BA%A6"><span class="toc-text">4.1 主动调度</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#4-2-%E6%8A%A2%E5%8D%A0%E5%BC%8F%E8%B0%83%E5%BA%A6"><span class="toc-text">4.2 抢占式调度</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#4-2-1-%E4%BB%BB%E5%8A%A1%E8%BF%90%E8%A1%8C%E6%97%B6%E9%97%B4%E6%A3%80%E6%B5%8B"><span class="toc-text">4.2.1 任务运行时间检测</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#4-2-2-%E4%BB%BB%E5%8A%A1%E5%94%A4%E9%86%92%E6%83%85%E5%86%B5"><span class="toc-text">4.2.2 任务唤醒情况</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#4-2-3-%E6%8A%A2%E5%8D%A0%E7%9A%84%E5%8F%91%E7%94%9F"><span class="toc-text">4.2.3 抢占的发生</span></a></li></ol></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%BA%94-%E6%80%BB%E7%BB%93"><span class="toc-text">五. 总结</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%BA%90%E7%A0%81%E8%B5%84%E6%96%99"><span class="toc-text">源码资料</span></a></li></ol></div><div class="widget-footer">

<a class="top" onclick="util.scrollTop()"><svg xmlns="http://www.w3.org/2000/svg" width="32" height="32" viewBox="0 0 24 24"><g fill="none" stroke="currentColor" stroke-width="1.5"><path d="M2 12c0-4.714 0-7.071 1.464-8.536C4.93 2 7.286 2 12 2c4.714 0 7.071 0 8.535 1.464C22 4.93 22 7.286 22 12c0 4.714 0 7.071-1.465 8.535C19.072 22 16.714 22 12 22s-7.071 0-8.536-1.465C2 19.072 2 16.714 2 12Z"/><path stroke-linecap="round" stroke-linejoin="round" d="m9 15.5l3-3l3 3m-6-4l3-3l3 3"/></g></svg><span>回到顶部</span></a></div></widget>
</div></aside><div class='float-panel blur'>
  <button type='button' style='display:none' class='laptop-only rightbar-toggle mobile' onclick='sidebar.rightbar()'>
    <svg xmlns="http://www.w3.org/2000/svg" width="32" height="32" viewBox="0 0 24 24"><path fill="none" stroke="currentColor" stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M10 6h11m-11 6h11m-11 6h11M4 6h1v4m-1 0h2m0 8H4c0-1 2-2 2-3s-1-1.5-2-1"/></svg>
  </button>
  <button type='button' style='display:none' class='mobile-only leftbar-toggle mobile' onclick='sidebar.leftbar()'>
    <svg xmlns="http://www.w3.org/2000/svg" width="32" height="32" viewBox="0 0 24 24"><g fill="none" stroke="currentColor" stroke-width="1.5"><path d="M2 11c0-3.771 0-5.657 1.172-6.828C4.343 3 6.229 3 10 3h4c3.771 0 5.657 0 6.828 1.172C22 5.343 22 7.229 22 11v2c0 3.771 0 5.657-1.172 6.828C19.657 21 17.771 21 14 21h-4c-3.771 0-5.657 0-6.828-1.172C2 18.657 2 16.771 2 13z"/><path id="sep" stroke-linecap="round" d="M5.5 10h6m-5 4h4m4.5 7V3"/></g></svg>
  </button>
</div>
</div><div class="scripts">
<script type="text/javascript">
  const ctx = {
    date_suffix: {
      just: `刚刚`,
      min: `分钟前`,
      hour: `小时前`,
      day: `天前`,
    },
    root : `/`,
  };

  // required plugins (only load if needs)
  if (`local_search`) {
    ctx.search = {};
    ctx.search.service = `local_search`;
    if (ctx.search.service == 'local_search') {
      let service_obj = Object.assign({}, `{"field":"all","path":"/search.json","content":true,"sort":"-date"}`);
      ctx.search[ctx.search.service] = service_obj;
    }
  }
  const def = {
    avatar: `https://gcore.jsdelivr.net/gh/cdn-x/placeholder@1.0.12/avatar/round/3442075.svg`,
    cover: `https://gcore.jsdelivr.net/gh/cdn-x/placeholder@1.0.12/cover/76b86c0226ffd.svg`,
  };
  const deps = {
    jquery: `https://cdn.bootcdn.net/ajax/libs/jquery/3.7.1/jquery.min.js`,
    marked: `https://cdn.bootcdn.net/ajax/libs/marked/4.0.18/marked.min.js`
  }
  

</script>

<script type="text/javascript">
  const utils = {
    // 懒加载 css https://github.com/filamentgroup/loadCSS
    css: (href, before, media, attributes) => {
      var doc = window.document;
      var ss = doc.createElement("link");
      var ref;
      if (before) {
        ref = before;
      } else {
        var refs = (doc.body || doc.getElementsByTagName("head")[0]).childNodes;
        ref = refs[refs.length - 1];
      }
      var sheets = doc.styleSheets;
      if (attributes) {
        for (var attributeName in attributes) {
          if (attributes.hasOwnProperty(attributeName)) {
            ss.setAttribute(attributeName, attributes[attributeName]);
          }
        }
      }
      ss.rel = "stylesheet";
      ss.href = href;
      ss.media = "only x";
      function ready(cb) {
        if (doc.body) {
          return cb();
        }
        setTimeout(function () {
          ready(cb);
        });
      }
      ready(function () {
        ref.parentNode.insertBefore(ss, before ? ref : ref.nextSibling);
      });
      var onloadcssdefined = function (cb) {
        var resolvedHref = ss.href;
        var i = sheets.length;
        while (i--) {
          if (sheets[i].href === resolvedHref) {
            return cb();
          }
        }
        setTimeout(function () {
          onloadcssdefined(cb);
        });
      };
      function loadCB() {
        if (ss.addEventListener) {
          ss.removeEventListener("load", loadCB);
        }
        ss.media = media || "all";
      }
      if (ss.addEventListener) {
        ss.addEventListener("load", loadCB);
      }
      ss.onloadcssdefined = onloadcssdefined;
      onloadcssdefined(loadCB);
      return ss;
    },

    js: (src, opt) => new Promise((resolve, reject) => {
      var script = document.createElement('script');
      if (src.startsWith('/')){
        src = ctx.root + src.substring(1);
      }
      script.src = src;
      if (opt) {
        for (let key of Object.keys(opt)) {
          script[key] = opt[key]
        }
      } else {
        // 默认异步，如果需要同步，第二个参数传入 {} 即可
        script.async = true
      }
      script.onerror = reject
      script.onload = script.onreadystatechange = function() {
        const loadState = this.readyState
        if (loadState && loadState !== 'loaded' && loadState !== 'complete') return
        script.onload = script.onreadystatechange = null
        resolve()
      }
      document.head.appendChild(script)
    }),

    jq: (fn) => {
      if (typeof jQuery === 'undefined') {
        utils.js(deps.jquery).then(fn)
      } else {
        fn()
      }
    },
    
    onLoading: (el) => {
      if (el) {
        $(el).append('<div class="loading-wrap"><svg xmlns="http://www.w3.org/2000/svg" width="2em" height="2em" preserveAspectRatio="xMidYMid meet" viewBox="0 0 24 24"><g fill="none" stroke="currentColor" stroke-linecap="round" stroke-width="2"><path stroke-dasharray="60" stroke-dashoffset="60" stroke-opacity=".3" d="M12 3C16.9706 3 21 7.02944 21 12C21 16.9706 16.9706 21 12 21C7.02944 21 3 16.9706 3 12C3 7.02944 7.02944 3 12 3Z"><animate fill="freeze" attributeName="stroke-dashoffset" dur="1.3s" values="60;0"/></path><path stroke-dasharray="15" stroke-dashoffset="15" d="M12 3C16.9706 3 21 7.02944 21 12"><animate fill="freeze" attributeName="stroke-dashoffset" dur="0.3s" values="15;0"/><animateTransform attributeName="transform" dur="1.5s" repeatCount="indefinite" type="rotate" values="0 12 12;360 12 12"/></path></g></svg></div>');
      }
    },
    onLoadSuccess: (el) => {
      if (el) {
        $(el).find('.loading-wrap').remove();
      }
    },
    onLoadFailure: (el) => {
      if (el) {
        $(el).find('.loading-wrap svg').remove();
        $(el).find('.loading-wrap').append('<svg xmlns="http://www.w3.org/2000/svg" width="2em" height="2em" preserveAspectRatio="xMidYMid meet" viewBox="0 0 24 24"><g fill="none" stroke="currentColor" stroke-linecap="round" stroke-linejoin="round" stroke-width="2"><path stroke-dasharray="60" stroke-dashoffset="60" d="M12 3L21 20H3L12 3Z"><animate fill="freeze" attributeName="stroke-dashoffset" dur="0.5s" values="60;0"/></path><path stroke-dasharray="6" stroke-dashoffset="6" d="M12 10V14"><animate fill="freeze" attributeName="stroke-dashoffset" begin="0.6s" dur="0.2s" values="6;0"/></path></g><circle cx="12" cy="17" r="1" fill="currentColor" fill-opacity="0"><animate fill="freeze" attributeName="fill-opacity" begin="0.8s" dur="0.4s" values="0;1"/></circle></svg>');
        $(el).find('.loading-wrap').addClass('error');
      }
    },
    request: (el, url, callback, onFailure) => {
      let retryTimes = 3;
      utils.onLoading(el);
      function req() {
        return new Promise((resolve, reject) => {
          let status = 0; // 0 等待 1 完成 2 超时
          let timer = setTimeout(() => {
            if (status === 0) {
              status = 2;
              timer = null;
              reject('请求超时');
              if (retryTimes == 0) {
                onFailure();
              }
            }
          }, 5000);
          fetch(url).then(function(response) {
            if (status !== 2) {
              clearTimeout(timer);
              resolve(response);
              timer = null;
              status = 1;
            }
            if (response.ok) {
              return response.json();
            }
            throw new Error('Network response was not ok.');
          }).then(function(data) {
            retryTimes = 0;
            utils.onLoadSuccess(el);
            callback(data);
          }).catch(function(error) {
            if (retryTimes > 0) {
              retryTimes -= 1;
              setTimeout(() => {
                req();
              }, 5000);
            } else {
              utils.onLoadFailure(el);
              onFailure();
            }
          });
        });
      }
      req();
    },
  };
</script>

<script>
  const sidebar = {
    leftbar: () => {
      if (l_body) {
        l_body.toggleAttribute('leftbar');
        l_body.removeAttribute('rightbar');
      }
    },
    rightbar: () => {
      if (l_body) {
        l_body.toggleAttribute('rightbar');
        l_body.removeAttribute('leftbar');
      }
    },
    dismiss: () => {
      if (l_body) {
        l_body.removeAttribute('leftbar');
        l_body.removeAttribute('rightbar');
      }
    },
    toggleTOC: () => {
      document.querySelector('#data-toc').classList.toggle('collapse');
    }
  }
</script>

<!-- required -->
<script src="/js/main.js?v=1.27.0" async></script>

<!-- optional -->



<script defer>
  window.addEventListener('DOMContentLoaded', (event) => {
    ctx.services = Object.assign({}, JSON.parse(`{"mdrender":{"js":"/js/services/mdrender.js"},"siteinfo":{"js":"/js/services/siteinfo.js","api":null},"ghinfo":{"js":"/js/services/ghinfo.js"},"sites":{"js":"/js/services/sites.js"},"friends":{"js":"/js/services/friends.js"},"timeline":{"js":"/js/services/timeline.js"},"fcircle":{"js":"/js/services/fcircle.js"},"weibo":{"js":"/js/services/weibo.js"},"memos":{"js":"/js/services/memos.js"}}`));
    for (let id of Object.keys(ctx.services)) {
      const js = ctx.services[id].js;
      if (id == 'siteinfo') {
        ctx.cardlinks = document.querySelectorAll('a.link-card[cardlink]');
        if (ctx.cardlinks?.length > 0) {
          utils.js(js, { defer: true }).then(function () {
            setCardLink(ctx.cardlinks);
          });
        }
      } else {
        const els = document.getElementsByClassName(`ds-${id}`);
        if (els?.length > 0) {
          utils.jq(() => {
            if (id == 'timeline' || 'memos' || 'marked') {
              utils.js(deps.marked).then(function () {
                utils.js(js, { defer: true });
              });
            } else {
              utils.js(js, { defer: true });
            }
          });
        }
      }
    }
  });
</script>

<script>
  window.addEventListener('DOMContentLoaded', (event) => {
    ctx.search = {
      path: `/search.json`,
    }
    utils.js('/js/search/local-search.js', { defer: true });
  });
</script><script>
  window.FPConfig = {
    delay: 0,
    ignoreKeywords: [],
    maxRPS: 5,
    hoverDelay: 25
  };
</script>
<script defer src="https://cdn.bootcdn.net/ajax/libs/flying-pages/2.1.2/flying-pages.min.js"></script><script defer src="https://cdn.bootcdn.net/ajax/libs/vanilla-lazyload/17.8.4/lazyload.min.js"></script>
<script>
  // https://www.npmjs.com/package/vanilla-lazyload
  // Set the options globally
  // to make LazyLoad self-initialize
  window.lazyLoadOptions = {
    elements_selector: ".lazy",
  };
  // Listen to the initialization event
  // and get the instance of LazyLoad
  window.addEventListener(
    "LazyLoad::Initialized",
    function (event) {
      window.lazyLoadInstance = event.detail.instance;
    },
    false
  );
  document.addEventListener('DOMContentLoaded', function () {
    window.lazyLoadInstance?.update();
  });
</script><script>
  ctx.fancybox = {
    selector: `.timenode p>img`,
    css: `https://cdn.bootcdn.net/ajax/libs/fancyapps-ui/5.0.22/fancybox/fancybox.min.css`,
    js: `https://cdn.bootcdn.net/ajax/libs/fancyapps-ui/5.0.22/fancybox/fancybox.umd.min.js`
  };
  var selector = '[data-fancybox]:not(.error)';
  if (ctx.fancybox.selector) {
    selector += `, ${ctx.fancybox.selector}`
  }
  var needFancybox = document.querySelectorAll(selector).length !== 0;
  if (!needFancybox) {
    const els = document.getElementsByClassName('ds-memos');
    if (els != undefined && els.length > 0) {
      needFancybox = true;
    }
  }
  if (needFancybox) {
    utils.css(ctx.fancybox.css);
    utils.js(ctx.fancybox.js, { defer: true }).then(function () {
      Fancybox.bind(selector, {
        hideScrollbar: false,
        Thumbs: {
          autoStart: false,
        },
        caption: (fancybox, slide) => {
          return slide.triggerEl.alt || null
        }
      });
    })
  }
</script><script>
  window.addEventListener('DOMContentLoaded', (event) => {
    const swiper_api = document.getElementById('swiper-api');
    if (swiper_api != undefined) {
      utils.css(`https://unpkg.com/swiper@10.3.1/swiper-bundle.min.css`);
      utils.js(`https://unpkg.com/swiper@10.3.1/swiper-bundle.min.js`, { defer: true }).then(function () {
        const effect = swiper_api.getAttribute('effect') || '';
        var swiper = new Swiper('.swiper#swiper-api', {
          slidesPerView: 'auto',
          spaceBetween: 8,
          centeredSlides: true,
          effect: effect,
          loop: true,
          pagination: {
            el: '.swiper-pagination',
            clickable: true,
          },
          navigation: {
            nextEl: '.swiper-button-next',
            prevEl: '.swiper-button-prev',
          },
        });
      })
    }
  });
</script><script>
  document.addEventListener('DOMContentLoaded', function () {
    window.codeElements = document.querySelectorAll('.code');
    if (window.codeElements.length > 0) {
      ctx.copycode = {
        default_text: `Copy`,
        success_text: `Copied`,
        toast: `复制成功`,
      };
      utils.js('/js/plugins/copycode.js');
    }
  });
</script>


<!-- inject -->

</div></body></html>
