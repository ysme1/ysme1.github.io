<!DOCTYPE html><html lang="zh-CN" data-theme="light"><head><meta charset="UTF-8"><meta http-equiv="X-UA-Compatible" content="IE=edge"><meta name="viewport" content="width=device-width, initial-scale=1.0,viewport-fit=cover"><title>进程、线程的创建和派生 | Blog</title><meta name="author" content="ysme"><meta name="copyright" content="ysme"><meta name="format-detection" content="telephone=no"><meta name="theme-color" content="#ffffff"><meta name="description" content="一. 前言  在前文中，我们分析了内核中进程和线程的统一结构体task_struct，本文将继续分析进程、线程的创建和派生的过程。首先介绍如何将一个程序编辑为执行文件最后成为进程执行，然后会介绍线程的执行，最后会分析如何通过已有的进程、线程实现多进程、多线程。因为进程和线程有诸多相似之处，也有一些不同之处，因此本文会对比进程和线程来加深理解和记忆。 二. 进程的创建以C语言为例，我们在Linux下">
<meta property="og:type" content="article">
<meta property="og:title" content="进程、线程的创建和派生">
<meta property="og:url" content="https://vcloud.ysme.top/2023/01/15/linux-docs/%E8%BF%9B%E7%A8%8B%E7%AE%A1%E7%90%86/%E8%BF%9B%E7%A8%8B%E3%80%81%E7%BA%BF%E7%A8%8B%E7%9A%84%E5%88%9B%E5%BB%BA%E5%92%8C%E6%B4%BE%E7%94%9F/index.html">
<meta property="og:site_name" content="Blog">
<meta property="og:description" content="一. 前言  在前文中，我们分析了内核中进程和线程的统一结构体task_struct，本文将继续分析进程、线程的创建和派生的过程。首先介绍如何将一个程序编辑为执行文件最后成为进程执行，然后会介绍线程的执行，最后会分析如何通过已有的进程、线程实现多进程、多线程。因为进程和线程有诸多相似之处，也有一些不同之处，因此本文会对比进程和线程来加深理解和记忆。 二. 进程的创建以C语言为例，我们在Linux下">
<meta property="og:locale" content="zh_CN">
<meta property="og:image" content="https://user-images.githubusercontent.com/87457873/128132712-dfe308a8-728b-4948-9e8e-f7563484355e.png">
<meta property="article:published_time" content="2023-01-15T01:13:37.000Z">
<meta property="article:modified_time" content="2024-08-28T08:42:33.708Z">
<meta property="article:author" content="ysme">
<meta property="article:tag" content="Linux">
<meta name="twitter:card" content="summary">
<meta name="twitter:image" content="https://user-images.githubusercontent.com/87457873/128132712-dfe308a8-728b-4948-9e8e-f7563484355e.png"><link rel="shortcut icon" href="/img/favicon.png"><link rel="canonical" href="https://vcloud.ysme.top/2023/01/15/linux-docs/%E8%BF%9B%E7%A8%8B%E7%AE%A1%E7%90%86/%E8%BF%9B%E7%A8%8B%E3%80%81%E7%BA%BF%E7%A8%8B%E7%9A%84%E5%88%9B%E5%BB%BA%E5%92%8C%E6%B4%BE%E7%94%9F/index.html"><link rel="preconnect" href="//cdn.jsdelivr.net"/><link rel="preconnect" href="//busuanzi.ibruce.info"/><link rel="stylesheet" href="/css/index.css?v=4.13.0"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fortawesome/fontawesome-free@6.5.1/css/all.min.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fancyapps/ui@5.0.33/dist/fancybox/fancybox.min.css" media="print" onload="this.media='all'"><script>const GLOBAL_CONFIG = {
  root: '/',
  algolia: undefined,
  localSearch: {"path":"/search.xml","preload":false,"top_n_per_article":1,"unescape":false,"languages":{"hits_empty":"找不到您查询的内容：${query}","hits_stats":"共找到 ${hits} 篇文章"}},
  translate: undefined,
  noticeOutdate: undefined,
  highlight: {"plugin":"highlight.js","highlightCopy":true,"highlightLang":true,"highlightHeightLimit":200},
  copy: {
    success: '复制成功',
    error: '复制错误',
    noSupport: '浏览器不支持'
  },
  relativeDate: {
    homepage: false,
    post: false
  },
  runtime: '',
  dateSuffix: {
    just: '刚刚',
    min: '分钟前',
    hour: '小时前',
    day: '天前',
    month: '个月前'
  },
  copyright: undefined,
  lightbox: 'fancybox',
  Snackbar: undefined,
  infinitegrid: {
    js: 'https://cdn.jsdelivr.net/npm/@egjs/infinitegrid@4.11.1/dist/infinitegrid.min.js',
    buttonText: '加载更多'
  },
  isPhotoFigcaption: false,
  islazyload: false,
  isAnchor: false,
  percent: {
    toc: true,
    rightside: false,
  },
  autoDarkmode: false
}</script><script id="config-diff">var GLOBAL_CONFIG_SITE = {
  title: '进程、线程的创建和派生',
  isPost: true,
  isHome: false,
  isHighlightShrink: false,
  isToc: true,
  postUpdate: '2024-08-28 16:42:33'
}</script><script>(win=>{
      win.saveToLocal = {
        set: (key, value, ttl) => {
          if (ttl === 0) return
          const now = Date.now()
          const expiry = now + ttl * 86400000
          const item = {
            value,
            expiry
          }
          localStorage.setItem(key, JSON.stringify(item))
        },
      
        get: key => {
          const itemStr = localStorage.getItem(key)
      
          if (!itemStr) {
            return undefined
          }
          const item = JSON.parse(itemStr)
          const now = Date.now()
      
          if (now > item.expiry) {
            localStorage.removeItem(key)
            return undefined
          }
          return item.value
        }
      }
    
      win.getScript = (url, attr = {}) => new Promise((resolve, reject) => {
        const script = document.createElement('script')
        script.src = url
        script.async = true
        script.onerror = reject
        script.onload = script.onreadystatechange = function() {
          const loadState = this.readyState
          if (loadState && loadState !== 'loaded' && loadState !== 'complete') return
          script.onload = script.onreadystatechange = null
          resolve()
        }

        Object.keys(attr).forEach(key => {
          script.setAttribute(key, attr[key])
        })

        document.head.appendChild(script)
      })
    
      win.getCSS = (url, id = false) => new Promise((resolve, reject) => {
        const link = document.createElement('link')
        link.rel = 'stylesheet'
        link.href = url
        if (id) link.id = id
        link.onerror = reject
        link.onload = link.onreadystatechange = function() {
          const loadState = this.readyState
          if (loadState && loadState !== 'loaded' && loadState !== 'complete') return
          link.onload = link.onreadystatechange = null
          resolve()
        }
        document.head.appendChild(link)
      })
    
      win.activateDarkMode = () => {
        document.documentElement.setAttribute('data-theme', 'dark')
        if (document.querySelector('meta[name="theme-color"]') !== null) {
          document.querySelector('meta[name="theme-color"]').setAttribute('content', '#0d0d0d')
        }
      }
      win.activateLightMode = () => {
        document.documentElement.setAttribute('data-theme', 'light')
        if (document.querySelector('meta[name="theme-color"]') !== null) {
          document.querySelector('meta[name="theme-color"]').setAttribute('content', '#ffffff')
        }
      }
      const t = saveToLocal.get('theme')
    
        if (t === 'dark') activateDarkMode()
        else if (t === 'light') activateLightMode()
      
      const asideStatus = saveToLocal.get('aside-status')
      if (asideStatus !== undefined) {
        if (asideStatus === 'hide') {
          document.documentElement.classList.add('hide-aside')
        } else {
          document.documentElement.classList.remove('hide-aside')
        }
      }
    
      const detectApple = () => {
        if(/iPad|iPhone|iPod|Macintosh/.test(navigator.userAgent)){
          document.documentElement.classList.add('apple')
        }
      }
      detectApple()
    })(window)</script><meta name="generator" content="Hexo 7.1.1"></head><body><div id="sidebar"><div id="menu-mask"></div><div id="sidebar-menus"><div class="avatar-img is-center"><img src="/img/avatar.jpg" onerror="onerror=null;src='/img/friend_404.gif'" alt="avatar"/></div><div class="sidebar-site-data site-data is-center"><a href="/archives/"><div class="headline">文章</div><div class="length-num">130</div></a><a href="/tags/"><div class="headline">标签</div><div class="length-num">4</div></a><a href="/categories/"><div class="headline">分类</div><div class="length-num">10</div></a></div><hr class="custom-hr"/><div class="menus_items"><div class="menus_item"><a class="site-page" href="/"><i class="fa-fw fas fa-home"></i><span> Home</span></a></div><div class="menus_item"><a class="site-page" href="/archives/"><i class="fa-fw fas fa-archive"></i><span> Archives</span></a></div><div class="menus_item"><a class="site-page" href="/tags/"><i class="fa-fw fas fa-tags"></i><span> Tags</span></a></div><div class="menus_item"><a class="site-page" href="/categories/"><i class="fa-fw fas fa-folder-open"></i><span> Categories</span></a></div><div class="menus_item"><a class="site-page group" href="javascript:void(0);"><i class="fa-fw fas fa-list"></i><span> List</span><i class="fas fa-chevron-down"></i></a><ul class="menus_item_child"><li><a class="site-page child" href="/music/"><i class="fa-fw fas fa-music"></i><span> Music</span></a></li><li><a class="site-page child" href="/movies/"><i class="fa-fw fas fa-video"></i><span> Movie</span></a></li></ul></div><div class="menus_item"><a class="site-page" href="/link/"><i class="fa-fw fas fa-link"></i><span> Link</span></a></div><div class="menus_item"><a class="site-page" href="/about/"><i class="fa-fw fas fa-heart"></i><span> About</span></a></div></div></div></div><div class="post" id="body-wrap"><header class="post-bg" id="page-header" style="background-image: url('https://user-images.githubusercontent.com/87457873/128132712-dfe308a8-728b-4948-9e8e-f7563484355e.png')"><nav id="nav"><span id="blog-info"><a href="/" title="Blog"><span class="site-name">Blog</span></a></span><div id="menus"><div id="search-button"><a class="site-page social-icon search" href="javascript:void(0);"><i class="fas fa-search fa-fw"></i><span> 搜索</span></a></div><div class="menus_items"><div class="menus_item"><a class="site-page" href="/"><i class="fa-fw fas fa-home"></i><span> Home</span></a></div><div class="menus_item"><a class="site-page" href="/archives/"><i class="fa-fw fas fa-archive"></i><span> Archives</span></a></div><div class="menus_item"><a class="site-page" href="/tags/"><i class="fa-fw fas fa-tags"></i><span> Tags</span></a></div><div class="menus_item"><a class="site-page" href="/categories/"><i class="fa-fw fas fa-folder-open"></i><span> Categories</span></a></div><div class="menus_item"><a class="site-page group" href="javascript:void(0);"><i class="fa-fw fas fa-list"></i><span> List</span><i class="fas fa-chevron-down"></i></a><ul class="menus_item_child"><li><a class="site-page child" href="/music/"><i class="fa-fw fas fa-music"></i><span> Music</span></a></li><li><a class="site-page child" href="/movies/"><i class="fa-fw fas fa-video"></i><span> Movie</span></a></li></ul></div><div class="menus_item"><a class="site-page" href="/link/"><i class="fa-fw fas fa-link"></i><span> Link</span></a></div><div class="menus_item"><a class="site-page" href="/about/"><i class="fa-fw fas fa-heart"></i><span> About</span></a></div></div><div id="toggle-menu"><a class="site-page" href="javascript:void(0);"><i class="fas fa-bars fa-fw"></i></a></div></div></nav><div id="post-info"><h1 class="post-title">进程、线程的创建和派生</h1><div id="post-meta"><div class="meta-firstline"><span class="post-meta-date"><i class="far fa-calendar-alt fa-fw post-meta-icon"></i><span class="post-meta-label">发表于</span><time class="post-meta-date-created" datetime="2023-01-15T01:13:37.000Z" title="发表于 2023-01-15 09:13:37">2023-01-15</time><span class="post-meta-separator">|</span><i class="fas fa-history fa-fw post-meta-icon"></i><span class="post-meta-label">更新于</span><time class="post-meta-date-updated" datetime="2024-08-28T08:42:33.708Z" title="更新于 2024-08-28 16:42:33">2024-08-28</time></span><span class="post-meta-categories"><span class="post-meta-separator">|</span><i class="fas fa-inbox fa-fw post-meta-icon"></i><a class="post-meta-categories" href="/categories/linux-doc-%E8%BF%9B%E7%A8%8B%E7%AE%A1%E7%90%86/">linux-doc 进程管理</a></span></div><div class="meta-secondline"><span class="post-meta-separator">|</span><span class="post-meta-pv-cv" id="" data-flag-title="进程、线程的创建和派生"><i class="far fa-eye fa-fw post-meta-icon"></i><span class="post-meta-label">阅读量:</span><span id="busuanzi_value_page_pv"><i class="fa-solid fa-spinner fa-spin"></i></span></span></div></div></div></header><main class="layout" id="content-inner"><div id="post"><article class="post-content" id="article-container"><h2 id="一-前言"><a href="#一-前言" class="headerlink" title="一. 前言"></a>一. 前言</h2><p>  在前文中，我们分析了内核中进程和线程的统一结构体task_struct，本文将继续分析进程、线程的创建和派生的过程。首先介绍如何将一个程序编辑为执行文件最后成为进程执行，然后会介绍线程的执行，最后会分析如何通过已有的进程、线程实现多进程、多线程。因为进程和线程有诸多相似之处，也有一些不同之处，因此本文会对比进程和线程来加深理解和记忆。</p>
<h2 id="二-进程的创建"><a href="#二-进程的创建" class="headerlink" title="二. 进程的创建"></a>二. 进程的创建</h2><p>以C语言为例，我们在Linux下编写C语言代码，然后通过gcc编译和链接生成可执行文件后直接执行即可完成一个进程的创建和工作。下面将详细展开介绍这个创建进程的过程。在 Linux 下面，二进制的程序也要有严格的格式，这个格式我们称为 ELF（Executable and Linkable Format，可执行与可链接格式）。这个格式可以根据编译的结果不同，分为不同的格式。主要包括</p>
<p>1、可重定位的对象文件(Relocatable file)</p>
<p>由汇编器汇编生成的 .o 文件</p>
<p>2、可执行的对象文件(Executable file)</p>
<p>可执行应用程序</p>
<p>3、可被共享的对象文件(Shared object file)</p>
<p>动态库文件，也即 .so 文件</p>
<p>下面在进程创建过程中会详细说明三种文件。</p>
<h3 id="2-1-编译"><a href="#2-1-编译" class="headerlink" title="2. 1 编译"></a>2. 1 编译</h3><p>写完C程序后第一步就是程序编译（其实还有IDE的预编译，那些属于编辑器操作这里不表）。编译指令如下所示</p>
<pre><code>gcc -c -fPIC xxxx.c
</code></pre>
<p>-c表示编译、汇编指定的源文件，不进行链接。-fPIC表示生成与位置无关（Position-Independent Code）代码，即采用相对地址而非绝对地址，从而满足共享库加载需求。在编译的时候，先做预处理工作，例如将头文件嵌入到正文中，将定义的宏展开，然后就是真正的编译过程，最终编译成为.o 文件，这就是 ELF 的第一种类型，可重定位文件（Relocatable File）。之所以叫做可重定位文件，是因为对于编译好的代码和变量，将来加载到内存里面的时候，都是要加载到一定位置的。比如说，调用一个函数，其实就是跳到这个函数所在的代码位置执行；再比如修改一个全局变量，也是要到变量的位置那里去修改。但是现在这个时候，还是.o 文件，不是一个可以直接运行的程序，这里面只是部分代码片段。因此.o 里面的位置是不确定的，但是必须是可重新定位的以适应需求。</p>
<p><img src="https://user-images.githubusercontent.com/87457873/128132712-dfe308a8-728b-4948-9e8e-f7563484355e.png" alt="image"></p>
<p>ELF 文件的头是用于描述整个文件的。这个文件格式在内核中有定义，分别为 struct elf32_hdr 和struct elf64_hdr。其他各个section作用如下所示</p>
<ul>
<li>.text：放编译好的二进制可执行代码</li>
<li>.rodata：只读数据，例如字符串常量、const 的变量</li>
<li>.data：已经初始化好的全局变量</li>
<li>.bss：未初始化全局变量，运行时会置 0</li>
<li>.symtab：符号表，记录的则是函数和变量</li>
<li>.rel.text： .text部分的重定位表</li>
<li>.rel.data：.data部分的重定位表</li>
<li>.strtab：字符串表、字符串常量和变量名</li>
</ul>
<p>这些节的元数据信息也需要有一个地方保存，就是最后的节头部表（Section Header Table）。在这个表里面，每一个 section 都有一项，在代码里面也有定义 struct elf32_shdr和struct elf64_shdr。在 ELF 的头里面，有描述这个文件的节头部表的位置，有多少个表项等等信息。</p>
<h3 id="2-2-链接"><a href="#2-2-链接" class="headerlink" title="2.2 链接"></a>2.2 链接</h3><p>链接分为静态链接和动态链接。静态链接库会和目标文件通过链接生成一个可执行文件，而动态链接则会通过链接形成动态连接器，在可执行文件执行的时候动态的选择并加载其中的部分或全部函数。二者的各自优缺点如下所示</p>
<ul>
<li><strong>静态链接库的优点</strong></li>
</ul>
<p>(1) 代码装载速度快，执行速度略比动态链接库快；</p>
<p>(2) 只需保证在开发者的计算机中有正确的.LIB文件，在以二进制形式发布程序时不需考虑在用户的计算机上.LIB文件是否存在及版本问题，可避免DLL地狱等问题。</p>
<ul>
<li><strong>静态链接库的缺点</strong></li>
</ul>
<p>使用静态链接生成的可执行文件体积较大，包含相同的公共代码，造成浪费</p>
<ul>
<li><strong>动态链接库的优点</strong></li>
</ul>
<p>(1) 更加节省内存并减少页面交换；</p>
<p>(2) DLL文件与EXE文件独立，只要输出接口不变（即名称、参数、返回值类型和调用约定不变），更换DLL文件不会对EXE文件造成任何影响，因而极大地提高了可维护性和可扩展性；</p>
<p>(3) 不同编程语言编写的程序只要按照函数调用约定就可以调用同一个DLL函数；</p>
<p>(4)适用于大规模的软件开发，使开发过程独立、耦合度小，便于不同开发者和开发组织之间进行开发和测试。</p>
<ul>
<li><strong>动态链接库的缺点</strong></li>
</ul>
<p>使用动态链接库的应用程序不是自完备的，它依赖的DLL模块也要存在，如果使用载入时动态链接，程序启动时发现DLL不存在，系统将终止程序并给出错误信息。而使用运行时动态链接，系统不会终止，但由于DLL中的导出函数不可用，程序会加载失败；速度比静态链接慢。当某个模块更新后，如果新模块与旧的模块不兼容，那么那些需要该模块才能运行的软件均无法执行。这在早期Windows中很常见。</p>
<p>下面分别介绍静态链接和动态链接</p>
<h4 id="2-2-1-静态链接"><a href="#2-2-1-静态链接" class="headerlink" title="2.2.1 静态链接"></a>2.2.1 静态链接</h4><p>静态链接库.a文件（Archives）的执行指令如下</p>
<pre><code>ar cr libXXX.a XXX.o XXXX.o
</code></pre>
<p>  <br>  当需要使用该静态库的时候，会将.o文件从.a文件中依次抽取并链接到程序中，指令如下</p>
<pre><code>gcc -o XXXX XXX.O -L. -lsXXX
</code></pre>
<p>-L表示在当前目录下找.a 文件，-lsXXXX会自动补全文件名，比如加前缀 lib，后缀.a，变成libXXX.a，找到这个.a文件后，将里面的 XXXX.o 取出来，和 XXX.o 做一个链接，形成二进制执行文件XXXX。在这里，重定位会从.o中抽取函数并和.a中的文件抽取的函数进行合并，找到实际的调用位置，形成最终的可执行文件(Executable file)，即ELF的第二种格式文件。</p>
<p><img src="https://user-images.githubusercontent.com/87457873/128132775-685e8de3-396a-432d-8d9b-15f2b5fba643.png" alt="image"></p>
<p>对比ELF第一种格式可重定位文件，这里可执行文件略去了重定位表相关段落。此处将ELF文件分为了代码段、数据段和不加载到内存中的部分，并加上了段头表（Segment Header Table）用以记录管理，在代码中定义为struct elf32_phdr和 struct elf64_phdr，这里面除了有对于段的描述之外，最重要的是 p_vaddr，这个是这个段加载到内存的虚拟地址。这部分会在内存篇章详细介绍。</p>
<h4 id="2-2-2-动态链接"><a href="#2-2-2-动态链接" class="headerlink" title="2.2.2 动态链接"></a>2.2.2 动态链接</h4><p>动态链接库（Shared Libraries)的作用主要是为了解决静态链接大量使用会造成空间浪费的问题，因此这里设计成了可以被多个程序共享的形式，其执行命令如下</p>
<pre><code>gcc -shared -fPIC -o libXXX.so XXX.o
</code></pre>
<p>当一个动态链接库被链接到一个程序文件中的时候，最后的程序文件并不包括动态链接库中的代码，而仅仅包括对动态链接库的引用，并且不保存动态链接库的全路径，仅仅保存动态链接库的名称。</p>
<pre><code>gcc -o XXX XXX.O -L. -lXXX
</code></pre>
<p>当运行这个程序的时候，首先寻找动态链接库，然后加载它。默认情况下，系统在 &#x2F;lib 和&#x2F;usr&#x2F;lib 文件夹下寻找动态链接库。如果找不到就会报错，我们可以设定 LD_LIBRARY_PATH环境变量，程序运行时会在此环境变量指定的文件夹下寻找动态链接库。动态链接库，就是 ELF 的第三种类型，共享对象文件（Shared Object）。</p>
<p>动态链接的ELF相对于静态链接主要多了以下部分</p>
<ul>
<li>.interp段，里面是ld-linux.so，负责运行时的链接动作</li>
<li>.plt（Procedure Linkage Table），过程链接表</li>
<li>.got.plt（Global Offset Table），全局偏移量表</li>
</ul>
<p>当程序编译时，会对每个函数在PLT中建立新的项，如PLT[n]，而动态库中则存有该函数的实际地址，记为GOT[m]。整体寻址过程如下所示</p>
<ul>
<li>PLT[n]向GOT[m]寻求地址</li>
<li>GOT[m]初始并无地址，需要采取以下方式获取地址<ul>
<li>回调PLT[0]</li>
<li>PLT[0]调用GOT[2]，即ld-linux.so</li>
<li>ld-linux.so查找所需函数实际地址并存放在GOT[m]中</li>
</ul>
</li>
</ul>
<p>由此，我们建立了PLT[n]到GOT[m]的对应关系，从而实现了动态链接。</p>
<h3 id="2-3-加载运行"><a href="#2-3-加载运行" class="headerlink" title="2.3 加载运行"></a>2.3 加载运行</h3><p>完成了上述的编译、汇编、链接，我们最终形成了可执行文件，并加载运行。在内核中，有这样一个数据结构，用来定义加载二进制文件的方法。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">linux_binfmt</span> &#123;</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">list_head</span> <span class="title">lh</span>;</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">module</span> *<span class="title">module</span>;</span></span><br><span class="line">    <span class="type">int</span> (*load_binary)(<span class="keyword">struct</span> linux_binprm *);</span><br><span class="line">    <span class="type">int</span> (*load_shlib)(<span class="keyword">struct</span> file *);</span><br><span class="line">    <span class="type">int</span> (*core_dump)(<span class="keyword">struct</span> coredump_params *cprm);</span><br><span class="line">    <span class="type">unsigned</span> <span class="type">long</span> min_coredump;     <span class="comment">/* minimal dump size */</span></span><br><span class="line">&#125; __randomize_layout;</span><br></pre></td></tr></table></figure>
<p>对于ELF文件格式，其对应实现为</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">static</span> <span class="class"><span class="keyword">struct</span> <span class="title">linux_binfmt</span> <span class="title">elf_format</span> =</span> &#123;</span><br><span class="line">    .module         = THIS_MODULE,</span><br><span class="line">    .load_binary    = load_elf_binary,</span><br><span class="line">    .load_shlib     = load_elf_library,</span><br><span class="line">    .core_dump      = elf_core_dump,</span><br><span class="line">    .min_coredump   = ELF_EXEC_PAGESIZE,</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>其中加载的函数指针指向的函数和内核镜像加载是同一份函数，实际上通过exec函数完成调用。exec 比较特殊，它是一组函数：</p>
<ul>
<li>包含 p 的函数（execvp, execlp）会在 PATH 路径下面寻找程序；不包含 p 的函数需要输入程序的全路径；</li>
<li>包含 v 的函数（execv, execvp, execve）以数组的形式接收参数；</li>
<li>包含 l 的函数（execl, execlp, execle）以列表的形式接收参数；</li>
<li>包含 e 的函数（execve, execle）以数组的形式接收环境变量。</li>
</ul>
<p>当我们通过shell运行可执行文件或者通过fork派生子类，均是通过该类函数实现加载。</p>
<h2 id="三-线程的创建之用户态"><a href="#三-线程的创建之用户态" class="headerlink" title="三. 线程的创建之用户态"></a>三. 线程的创建之用户态</h2><p>线程的创建对应的函数是pthread_create()，线程不是一个完全由内核实现的机制，它是由内核态和用户态合作完成的。pthread_create()不是一个系统调用，是 Glibc 库的一个函数，所以我们还要从 Glibc 说起。但是在开始之前，我们先要提一下，线程的创建到了内核态和进程的派生会使用同一个函数：__do_fork()，这也很容易理解，因为对内核态来说，线程和进程是同样的task_struct结构体。本节介绍线程在用户态的创建，而内核态的创建则会和进程的派生放在一起说明。</p>
<p>在Glibc的ntpl&#x2F;pthread_create.c中定义了__pthread_create_2_1()函数，该函数主要进行了以下操作</p>
<p>处理线程的属性参数。例如前面写程序的时候，我们设置的线程栈大小。如果没有传入线程属性，就取默认值。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">const</span> <span class="class"><span class="keyword">struct</span> <span class="title">pthread_attr</span> *<span class="title">iattr</span> =</span> (<span class="keyword">struct</span> pthread_attr *) attr;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">pthread_attr</span> <span class="title">default_attr</span>;</span></span><br><span class="line"><span class="comment">//c11 thrd_create</span></span><br><span class="line"><span class="type">bool</span> c11 = (attr == ATTR_C11_THREAD);</span><br><span class="line"><span class="keyword">if</span> (iattr == <span class="literal">NULL</span> || c11)</span><br><span class="line">&#123;</span><br><span class="line">  ......</span><br><span class="line">    iattr = &amp;default_attr;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>就像在内核里每一个进程或者线程都有一个 task_struct 结构，在用户态也有一个用于维护线程的结构，就是这个 pthread 结构。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">pthread</span> *<span class="title">pd</span> =</span> <span class="literal">NULL</span>;</span><br></pre></td></tr></table></figure>
<p>凡是涉及函数的调用，都要使用到栈。每个线程也有自己的栈，接下来就是创建线程栈了。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> err = ALLOCATE_STACK (iattr, &amp;pd);</span><br></pre></td></tr></table></figure>
<p>ALLOCATE_STACK 是一个宏，对应的函数allocate_stack()主要做了以下这些事情：</p>
<ul>
<li>如果在线程属性里面设置过栈的大小，则取出属性值；</li>
<li>为了防止栈的访问越界在栈的末尾添加一块空间 guardsize，一旦访问到这里就会报错；</li>
<li>线程栈是在进程的堆里面创建的。如果一个进程不断地创建和删除线程，我们不可能不断地去申请和清除线程栈使用的内存块，这样就需要有一个缓存。get_cached_stack 就是根据计算出来的 size 大小，看一看已经有的缓存中，有没有已经能够满足条件的。如果缓存里面没有，就需要调用__mmap创建一块新的缓存，系统调用那一节我们讲过，如果要在堆里面 malloc 一块内存，比较大的话，用__mmap；</li>
<li>线程栈也是自顶向下生长的，每个线程要有一个pthread 结构，这个结构也是放在栈的空间里面的。在栈底的位置，其实是地址最高位；</li>
<li>计算出guard内存的位置，调用 setup_stack_prot 设置这块内存的是受保护的；</li>
<li>填充pthread 这个结构里面的成员变量 stackblock、stackblock_size、guardsize、specific。这里的 specific 是用于存放Thread Specific Data 的，也即属于线程的全局变量；</li>
<li>将这个线程栈放到 stack_used 链表中，其实管理线程栈总共有两个链表，一个是 stack_used，也就是这个栈正被使用；另一个是stack_cache，就是上面说的，一旦线程结束，先缓存起来，不释放，等有其他的线程创建的时候，给其他的线程用。</li>
</ul>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta"># <span class="keyword">define</span> ALLOCATE_STACK(attr, pd) allocate_stack (attr, pd, &amp;stackaddr)</span></span><br><span class="line"><span class="type">static</span> <span class="type">int</span></span><br><span class="line"><span class="title function_">allocate_stack</span> <span class="params">(<span class="type">const</span> <span class="keyword">struct</span> pthread_attr *attr, <span class="keyword">struct</span> pthread **pdp,</span></span><br><span class="line"><span class="params">                ALLOCATE_STACK_PARMS)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">pthread</span> *<span class="title">pd</span>;</span></span><br><span class="line">    <span class="type">size_t</span> size;</span><br><span class="line">    <span class="type">size_t</span> pagesize_m1 = __getpagesize () - <span class="number">1</span>;</span><br><span class="line">......</span><br><span class="line">    <span class="comment">/* Get the stack size from the attribute if it is set.  Otherwise we</span></span><br><span class="line"><span class="comment">       use the default we determined at start time.  */</span></span><br><span class="line">    <span class="keyword">if</span> (attr-&gt;stacksize != <span class="number">0</span>)</span><br><span class="line">        size = attr-&gt;stacksize;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">    &#123;</span><br><span class="line">        lll_lock (__default_pthread_attr_lock, LLL_PRIVATE);</span><br><span class="line">        size = __default_pthread_attr.stacksize;</span><br><span class="line">        lll_unlock (__default_pthread_attr_lock, LLL_PRIVATE);</span><br><span class="line">    &#125;</span><br><span class="line">......</span><br><span class="line">    <span class="comment">/* Allocate some anonymous memory.  If possible use the cache.  */</span></span><br><span class="line">    <span class="type">size_t</span> guardsize;</span><br><span class="line">    <span class="type">void</span> *mem;</span><br><span class="line">    <span class="type">const</span> <span class="type">int</span> prot = (PROT_READ | PROT_WRITE</span><br><span class="line">                   | ((GL(dl_stack_flags) &amp; PF_X) ? PROT_EXEC : <span class="number">0</span>));</span><br><span class="line">    <span class="comment">/* Adjust the stack size for alignment.  */</span></span><br><span class="line">    size &amp;= ~__static_tls_align_m1;</span><br><span class="line">    <span class="comment">/* Make sure the size of the stack is enough for the guard and</span></span><br><span class="line"><span class="comment">       eventually the thread descriptor.  */</span></span><br><span class="line">    guardsize = (attr-&gt;guardsize + pagesize_m1) &amp; ~pagesize_m1;</span><br><span class="line">    size += guardsize;</span><br><span class="line">......    </span><br><span class="line">    <span class="comment">/* Try to get a stack from the cache.  */</span>  </span><br><span class="line">    pd = get_cached_stack (&amp;size, &amp;mem);</span><br><span class="line">    <span class="keyword">if</span> (pd == <span class="literal">NULL</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">/* If a guard page is required, avoid committing memory by first</span></span><br><span class="line"><span class="comment">           allocate with PROT_NONE and then reserve with required permission</span></span><br><span class="line"><span class="comment">           excluding the guard page.  */</span></span><br><span class="line">        mem = __mmap (<span class="literal">NULL</span>, size, (guardsize == <span class="number">0</span>) ? prot : PROT_NONE,</span><br><span class="line">        MAP_PRIVATE | MAP_ANONYMOUS | MAP_STACK, <span class="number">-1</span>, <span class="number">0</span>);</span><br><span class="line">        <span class="comment">/* Place the thread descriptor at the end of the stack.  */</span></span><br><span class="line"><span class="meta">#<span class="keyword">if</span> TLS_TCB_AT_TP</span></span><br><span class="line">        pd = (<span class="keyword">struct</span> pthread *) ((<span class="type">char</span> *) mem + size) - <span class="number">1</span>;</span><br><span class="line"><span class="meta">#<span class="keyword">elif</span> TLS_DTV_AT_TP</span></span><br><span class="line">        pd = (<span class="keyword">struct</span> pthread *) ((((<span class="type">uintptr_t</span>) mem + size - __static_tls_size) &amp; ~__static_tls_align_m1) - TLS_PRE_TCB_SIZE);</span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line">        <span class="comment">/* Now mprotect the required region excluding the guard area. */</span></span><br><span class="line">        <span class="type">char</span> *guard = guard_position (mem, size, guardsize, pd, pagesize_m1);</span><br><span class="line">        setup_stack_prot (mem, size, guard, guardsize, prot);</span><br><span class="line">        pd-&gt;stackblock = mem;</span><br><span class="line">        pd-&gt;stackblock_size = size;</span><br><span class="line">        pd-&gt;guardsize = guardsize;</span><br><span class="line">        pd-&gt;specific[<span class="number">0</span>] = pd-&gt;specific_1stblock;</span><br><span class="line">        <span class="comment">/* And add to the list of stacks in use.  */</span></span><br><span class="line">        stack_list_add (&amp;pd-&gt;<span class="built_in">list</span>, &amp;stack_used);</span><br><span class="line">    &#125;</span><br><span class="line">  </span><br><span class="line">    *pdp = pd;</span><br><span class="line">    <span class="type">void</span> *stacktop;</span><br><span class="line"><span class="meta"># <span class="keyword">if</span> TLS_TCB_AT_TP</span></span><br><span class="line">    <span class="comment">/* The stack begins before the TCB and the static TLS block.  */</span></span><br><span class="line">    stacktop = ((<span class="type">char</span> *) (pd + <span class="number">1</span>) - __static_tls_size);</span><br><span class="line"><span class="meta"># <span class="keyword">elif</span> TLS_DTV_AT_TP</span></span><br><span class="line">    stacktop = (<span class="type">char</span> *) (pd - <span class="number">1</span>);</span><br><span class="line"><span class="meta"># <span class="keyword">endif</span></span></span><br><span class="line">    *<span class="built_in">stack</span> = stacktop;</span><br><span class="line">...... </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="四-线程的内核态创建及进程的派生"><a href="#四-线程的内核态创建及进程的派生" class="headerlink" title="四. 线程的内核态创建及进程的派生"></a>四. 线程的内核态创建及进程的派生</h2><p>多进程是一种常见的程序实现方式，采用的系统调用为fork()函数。前文中已经详细叙述了系统调用的整个过程，对于fork()来说，最终会在系统调用表中查找到对应的系统调用sys_fork完成子进程的生成，而sys_fork 会调用 _do_fork()。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">SYSCALL_DEFINE0(fork)</span><br><span class="line">&#123;</span><br><span class="line">......</span><br><span class="line">    <span class="keyword">return</span> _do_fork(SIGCHLD, <span class="number">0</span>, <span class="number">0</span>, <span class="literal">NULL</span>, <span class="literal">NULL</span>, <span class="number">0</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>关于__do_fork()先按下不表，再接着看看线程。我们接着pthread_create ()看。其实有了用户态的栈，接着需要解决的就是用户态的程序从哪里开始运行的问题。start_routine() 就是给线程的函数，start_routine()， 参数 arg，以及调度策略都要赋值给 pthread。接下来 __nptl_nthreads 加一，说明又多了一个线程。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">pd-&gt;start_routine = start_routine;</span><br><span class="line">pd-&gt;arg = arg;</span><br><span class="line">pd-&gt;schedpolicy = self-&gt;schedpolicy;</span><br><span class="line">pd-&gt;schedparam = self-&gt;schedparam;</span><br><span class="line"><span class="comment">/* Pass the descriptor to the caller.  */</span></span><br><span class="line">*newthread = (<span class="type">pthread_t</span>) pd;</span><br><span class="line">atomic_increment (&amp;__nptl_nthreads);</span><br><span class="line">retval = create_thread (pd, iattr, &amp;stopped_start, STACK_VARIABLES_ARGS, &amp;thread_ran);</span><br></pre></td></tr></table></figure>
<p>真正创建线程的是调用 create_thread() 函数，这个函数定义如下。同时，这里还规定了当完成了内核态线程创建后回调的位置：start_thread()。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">static</span> <span class="type">int</span></span><br><span class="line"><span class="title function_">create_thread</span> <span class="params">(<span class="keyword">struct</span> pthread *pd, <span class="type">const</span> <span class="keyword">struct</span> pthread_attr *attr,</span></span><br><span class="line"><span class="params"><span class="type">bool</span> *stopped_start, STACK_VARIABLES_PARMS, <span class="type">bool</span> *thread_ran)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">const</span> <span class="type">int</span> clone_flags = (CLONE_VM | CLONE_FS | CLONE_FILES | CLONE_SYSVSEM | CLONE_SIGHAND | CLONE_THREAD | CLONE_SETTLS | CLONE_PARENT_SETTID | CLONE_CHILD_CLEARTID | <span class="number">0</span>);</span><br><span class="line">    ARCH_CLONE (&amp;start_thread, STACK_VARIABLES_ARGS, clone_flags, pd, &amp;pd-&gt;tid, tp, &amp;pd-&gt;tid)；</span><br><span class="line">    <span class="comment">/* It&#x27;s started now, so if we fail below, we&#x27;ll have to cancel it</span></span><br><span class="line"><span class="comment">       and let it clean itself up.  */</span></span><br><span class="line">    *thread_ran = <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>在 start_thread() 入口函数中，才真正的调用用户提供的函数，在用户的函数执行完毕之后，会释放这个线程相关的数据。例如，线程本地数据 thread_local variables，线程数目也减一。如果这是最后一个线程了，就直接退出进程，另外 __free_tcb() 用于释放 pthread。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">define</span> START_THREAD_DEFN \</span></span><br><span class="line"><span class="meta">  static int __attribute__ ((noreturn)) start_thread (void *arg)</span></span><br><span class="line"></span><br><span class="line">START_THREAD_DEFN</span><br><span class="line">&#123;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">pthread</span> *<span class="title">pd</span> =</span> START_THREAD_SELF;</span><br><span class="line">    <span class="comment">/* Run the code the user provided.  */</span></span><br><span class="line">    THREAD_SETMEM (pd, result, pd-&gt;start_routine (pd-&gt;arg));</span><br><span class="line">    <span class="comment">/* Call destructors for the thread_local TLS variables.  */</span></span><br><span class="line">    <span class="comment">/* Run the destructor for the thread-local data.  */</span></span><br><span class="line">    __nptl_deallocate_tsd ();</span><br><span class="line">    <span class="keyword">if</span> (__glibc_unlikely (atomic_decrement_and_test (&amp;__nptl_nthreads)))</span><br><span class="line">        <span class="comment">/* This was the last thread.  */</span></span><br><span class="line">        <span class="built_in">exit</span> (<span class="number">0</span>);</span><br><span class="line">    __free_tcb (pd);</span><br><span class="line">    __exit_thread ();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>__free_tcb ()会调用 __deallocate_stack()来释放整个线程栈，这个线程栈要从当前使用线程栈的列表 stack_used 中拿下来，放到缓存的线程栈列表 stack_cache中，从而结束了线程的生命周期。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span></span><br><span class="line">internal_function</span><br><span class="line">__free_tcb (<span class="keyword">struct</span> pthread *pd)</span><br><span class="line">&#123;</span><br><span class="line">    ......</span><br><span class="line">    __deallocate_stack (pd);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span></span><br><span class="line">internal_function</span><br><span class="line">__deallocate_stack (<span class="keyword">struct</span> pthread *pd)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">/* Remove the thread from the list of threads with user defined</span></span><br><span class="line"><span class="comment">       stacks.  */</span></span><br><span class="line">    stack_list_del (&amp;pd-&gt;<span class="built_in">list</span>);</span><br><span class="line">    <span class="comment">/* Not much to do.  Just free the mmap()ed memory.  Note that we do</span></span><br><span class="line"><span class="comment">       not reset the &#x27;used&#x27; flag in the &#x27;tid&#x27; field.  This is done by</span></span><br><span class="line"><span class="comment">       the kernel.  If no thread has been created yet this field is</span></span><br><span class="line"><span class="comment">       still zero.  */</span></span><br><span class="line">    <span class="keyword">if</span> (__glibc_likely (! pd-&gt;user_stack))</span><br><span class="line">        (<span class="type">void</span>) queue_stack (pd);</span><br><span class="line">&#125;</span><br><span class="line">  ARCH_CLONE其实调用的是 __clone()。</span><br><span class="line"></span><br><span class="line"><span class="meta"># <span class="keyword">define</span> ARCH_CLONE __clone</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/* The userland implementation is:</span></span><br><span class="line"><span class="comment">   int clone (int (*fn)(void *arg), void *child_stack, int flags, void *arg),</span></span><br><span class="line"><span class="comment">   the kernel entry is:</span></span><br><span class="line"><span class="comment">   int clone (long flags, void *child_stack).</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">   The parameters are passed in register and on the stack from userland:</span></span><br><span class="line"><span class="comment">   rdi: fn</span></span><br><span class="line"><span class="comment">   rsi: child_stack</span></span><br><span class="line"><span class="comment">   rdx: flags</span></span><br><span class="line"><span class="comment">   rcx: arg</span></span><br><span class="line"><span class="comment">   r8d: TID field in parent</span></span><br><span class="line"><span class="comment">   r9d: thread pointer</span></span><br><span class="line"><span class="comment">%esp+8: TID field in child</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">   The kernel expects:</span></span><br><span class="line"><span class="comment">   rax: system call number</span></span><br><span class="line"><span class="comment">   rdi: flags</span></span><br><span class="line"><span class="comment">   rsi: child_stack</span></span><br><span class="line"><span class="comment">   rdx: TID field in parent</span></span><br><span class="line"><span class="comment">   r10: TID field in child</span></span><br><span class="line"><span class="comment">   r8:  thread pointer  */</span></span><br><span class="line">    .text</span><br><span class="line"><span class="title function_">ENTRY</span> <span class="params">(__clone)</span></span><br><span class="line">    movq    $-EINVAL,%rax</span><br><span class="line">......</span><br><span class="line">    <span class="comment">/* Insert the argument onto the new stack.  */</span></span><br><span class="line">    subq    $16,%rsi</span><br><span class="line">    movq    %rcx,8<span class="params">(%rsi)</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">/* Save the function pointer.  It will be popped off in the</span></span><br><span class="line"><span class="comment">       child in the ebx frobbing below.  */</span></span><br><span class="line">    movq    %rdi,0<span class="params">(%rsi)</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">/* Do the system call.  */</span></span><br><span class="line">    movq    %rdx, %rdi</span><br><span class="line">    movq    %r8, %rdx</span><br><span class="line">    movq    %r9, %r8</span><br><span class="line">    mov     8<span class="params">(%rsp)</span>, %R10_LP</span><br><span class="line">    movl    $<span class="title function_">SYS_ify</span><span class="params">(clone)</span>,%eax</span><br><span class="line">......</span><br><span class="line">    syscall</span><br><span class="line">......</span><br><span class="line"><span class="title function_">PSEUDO_END</span> <span class="params">(__clone)</span></span><br></pre></td></tr></table></figure>
<p>内核中的clone()定义如下。如果在进程的主线程里面调用其他系统调用，当前用户态的栈是指向整个进程的栈，栈顶指针也是指向进程的栈，指令指针也是指向进程的主线程的代码。此时此刻执行到这里，调用 clone的时候，用户态的栈、栈顶指针、指令指针和其他系统调用一样，都是指向主线程的。但是对于线程来说，这些都要变。因为我们希望当 clone 这个系统调用成功的时候，除了内核里面有这个线程对应的 task_struct，当系统调用返回到用户态的时候，用户态的栈应该是线程的栈，栈顶指针应该指向线程的栈，指令指针应该指向线程将要执行的那个函数。所以这些都需要我们自己做，将线程要执行的函数的参数和指令的位置都压到栈里面，当从内核返回，从栈里弹出来的时候，就从这个函数开始，带着这些参数执行下去。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">SYSCALL_DEFINE5(clone, <span class="type">unsigned</span> <span class="type">long</span>, clone_flags, <span class="type">unsigned</span> <span class="type">long</span>, newsp,</span><br><span class="line">     <span class="type">int</span> __user *, parent_tidptr,</span><br><span class="line">     <span class="type">int</span> __user *, child_tidptr,</span><br><span class="line">     <span class="type">unsigned</span> <span class="type">long</span>, tls)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">return</span> _do_fork(clone_flags, newsp, <span class="number">0</span>, parent_tidptr, child_tidptr, tls);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>线程和进程到了这里殊途同归，进入了同一个函数__do_fork()工作。其源码如下所示，主要工作包括复制结构copy_process()和唤醒新进程wak_up_new()两部分。其中线程会根据create_thread()函数中的clone_flags完成上文所述的栈顶指针和指令指针的切换，以及一些线程和进程的微妙区别。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">long</span> _do_fork(<span class="type">unsigned</span> <span class="type">long</span> clone_flags,</span><br><span class="line">        <span class="type">unsigned</span> <span class="type">long</span> stack_start,</span><br><span class="line">        <span class="type">unsigned</span> <span class="type">long</span> stack_size,</span><br><span class="line">        <span class="type">int</span> __user *parent_tidptr,</span><br><span class="line">        <span class="type">int</span> __user *child_tidptr,</span><br><span class="line">        <span class="type">unsigned</span> <span class="type">long</span> tls)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">task_struct</span> *<span class="title">p</span>;</span></span><br><span class="line">    <span class="type">int</span> trace = <span class="number">0</span>;</span><br><span class="line">    <span class="type">long</span> nr;</span><br><span class="line"></span><br><span class="line">......</span><br><span class="line">    p = copy_process(clone_flags, stack_start, stack_size,</span><br><span class="line">       child_tidptr, <span class="literal">NULL</span>, trace, tls, NUMA_NO_NODE);</span><br><span class="line">......</span><br><span class="line">    <span class="keyword">if</span> (IS_ERR(p))</span><br><span class="line">        <span class="keyword">return</span> PTR_ERR(p);</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">pid</span> *<span class="title">pid</span>;</span></span><br><span class="line">    pid = get_task_pid(p, PIDTYPE_PID);</span><br><span class="line">    nr = pid_vnr(pid);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (clone_flags &amp; CLONE_PARENT_SETTID)</span><br><span class="line">        put_user(nr, parent_tidptr);</span><br><span class="line">    <span class="keyword">if</span> (clone_flags &amp; CLONE_VFORK) &#123;</span><br><span class="line">        p-&gt;vfork_done = &amp;vfork;</span><br><span class="line">        init_completion(&amp;vfork);</span><br><span class="line">        get_task_struct(p);</span><br><span class="line">    &#125;</span><br><span class="line">    wake_up_new_task(p);</span><br><span class="line">......</span><br><span class="line">    put_pid(pid);</span><br><span class="line">    <span class="keyword">return</span> nr;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h3 id="4-1-任务结构体复制"><a href="#4-1-任务结构体复制" class="headerlink" title="4.1 任务结构体复制"></a>4.1 任务结构体复制</h3><p>  <br>如下所示为copy_process()函数源码精简版，task_struct结构复杂也注定了复制过程的复杂性，因此此处省略了很多，仅保留了各个部分的主要调用函数</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">static</span> __latent_entropy <span class="keyword">struct</span> task_struct *<span class="title function_">copy_process</span><span class="params">(</span></span><br><span class="line"><span class="params">          <span class="type">unsigned</span> <span class="type">long</span> clone_flags,</span></span><br><span class="line"><span class="params">          <span class="type">unsigned</span> <span class="type">long</span> stack_start,</span></span><br><span class="line"><span class="params">          <span class="type">unsigned</span> <span class="type">long</span> stack_size,</span></span><br><span class="line"><span class="params">          <span class="type">int</span> __user *child_tidptr,</span></span><br><span class="line"><span class="params">          <span class="keyword">struct</span> pid *pid,</span></span><br><span class="line"><span class="params">          <span class="type">int</span> trace,</span></span><br><span class="line"><span class="params">          <span class="type">unsigned</span> <span class="type">long</span> tls,</span></span><br><span class="line"><span class="params">          <span class="type">int</span> node)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">int</span> retval;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">task_struct</span> *<span class="title">p</span>;</span></span><br><span class="line">......</span><br><span class="line">    <span class="comment">//分配task_struct结构</span></span><br><span class="line">    p = dup_task_struct(current, node);  </span><br><span class="line">......</span><br><span class="line">    <span class="comment">//权限处理</span></span><br><span class="line">    retval = copy_creds(p, clone_flags);</span><br><span class="line">......</span><br><span class="line">    <span class="comment">//设置调度相关变量</span></span><br><span class="line">    retval = sched_fork(clone_flags, p);    </span><br><span class="line">......</span><br><span class="line">    <span class="comment">//初始化文件和文件系统相关变量</span></span><br><span class="line">    retval = copy_files(clone_flags, p);</span><br><span class="line">    retval = copy_fs(clone_flags, p);  </span><br><span class="line">......</span><br><span class="line">    <span class="comment">//初始化信号相关变量</span></span><br><span class="line">    init_sigpending(&amp;p-&gt;pending);</span><br><span class="line">    retval = copy_sighand(clone_flags, p);</span><br><span class="line">    retval = copy_signal(clone_flags, p);  </span><br><span class="line">......</span><br><span class="line">    <span class="comment">//拷贝进程内存空间</span></span><br><span class="line">    retval = copy_mm(clone_flags, p);</span><br><span class="line">...... </span><br><span class="line">    <span class="comment">//初始化亲缘关系变量</span></span><br><span class="line">    INIT_LIST_HEAD(&amp;p-&gt;children);</span><br><span class="line">    INIT_LIST_HEAD(&amp;p-&gt;sibling);</span><br><span class="line">......</span><br><span class="line">    <span class="comment">//建立亲缘关系</span></span><br><span class="line">    <span class="comment">//源码放在后面说明  </span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>1、copy_process()首先调用了dup_task_struct()分配task_struct结构，dup_task_struct() 主要做了下面几件事情：</p>
<ul>
<li>调用 alloc_task_struct_node 分配一个 task_struct结构；</li>
<li>调用 alloc_thread_stack_node 来创建内核栈，这里面调用 __vmalloc_node_range 分配一个连续的 THREAD_SIZE 的内存空间，赋值给 task_struct 的 void *stack成员变量；</li>
<li>调用 arch_dup_task_struct(struct task_struct *dst, struct task_struct *src)，将 task_struct 进行复制，其实就是调用 memcpy；</li>
<li>调用setup_thread_stack设置 thread_info。</li>
</ul>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">static</span> <span class="keyword">struct</span> task_struct *<span class="title function_">dup_task_struct</span><span class="params">(<span class="keyword">struct</span> task_struct *orig, <span class="type">int</span> node)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">task_struct</span> *<span class="title">tsk</span>;</span></span><br><span class="line">    <span class="type">unsigned</span> <span class="type">long</span> *<span class="built_in">stack</span>;</span><br><span class="line">......</span><br><span class="line">    tsk = alloc_task_struct_node(node);</span><br><span class="line">    <span class="keyword">if</span> (!tsk)</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">stack</span> = alloc_thread_stack_node(tsk, node);</span><br><span class="line">    <span class="keyword">if</span> (!<span class="built_in">stack</span>)</span><br><span class="line">        <span class="keyword">goto</span> free_tsk; </span><br><span class="line">    <span class="keyword">if</span> (memcg_charge_kernel_stack(tsk))</span><br><span class="line">        <span class="keyword">goto</span> free_stack;</span><br><span class="line"></span><br><span class="line">    stack_vm_area = task_stack_vm_area(tsk);</span><br><span class="line"></span><br><span class="line">    err = arch_dup_task_struct(tsk, orig);</span><br><span class="line">......    </span><br><span class="line">    setup_thread_stack(tsk, orig);</span><br><span class="line">......    </span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>2、接着，调用copy_creds处理权限相关内容</p>
<ul>
<li>调用prepare_creds，准备一个新的 struct cred *new。如何准备呢？其实还是从内存中分配一个新的 struct cred结构，然后调用 memcpy 复制一份父进程的 cred；</li>
<li>接着 p-&gt;cred &#x3D; p-&gt;real_cred &#x3D; get_cred(new)，将新进程的“我能操作谁”和“谁能操作我”两个权限都指向新的 cred。</li>
</ul>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * Copy credentials for the new process created by fork()</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * We share if we can, but under some circumstances we have to generate a new</span></span><br><span class="line"><span class="comment"> * set.</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * The new process gets the current process&#x27;s subjective credentials as its</span></span><br><span class="line"><span class="comment"> * objective and subjective credentials</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="type">int</span> <span class="title function_">copy_creds</span><span class="params">(<span class="keyword">struct</span> task_struct *p, <span class="type">unsigned</span> <span class="type">long</span> clone_flags)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">cred</span> *<span class="title">new</span>;</span></span><br><span class="line">    <span class="type">int</span> ret;</span><br><span class="line">......</span><br><span class="line">    new = prepare_creds();</span><br><span class="line">    <span class="keyword">if</span> (!new)</span><br><span class="line">        <span class="keyword">return</span> -ENOMEM;</span><br><span class="line">......</span><br><span class="line">    <span class="type">atomic_inc</span>(&amp;new-&gt;user-&gt;processes);</span><br><span class="line">    p-&gt;cred = p-&gt;real_cred = get_cred(new);</span><br><span class="line">    alter_cred_subscribers(new, <span class="number">2</span>);</span><br><span class="line">    validate_creds(new);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>3、设置调度相关的变量。该部分源码先不展示，会在进程调度中详细介绍。sched_fork主要做了下面几件事情：</p>
<ul>
<li>调用__sched_fork，在这里面将on_rq设为 0，初始化sched_entity，将里面的 exec_start、sum_exec_runtime、prev_sum_exec_runtime、vruntime 都设为 0。这几个变量涉及进程的实际运行时间和虚拟运行时间。是否到时间应该被调度了，就靠它们几个；</li>
<li>设置进程的状态 p-&gt;state &#x3D; TASK_NEW；</li>
<li>初始化优先级 prio、normal_prio、static_prio；</li>
<li>设置调度类，如果是普通进程，就设置为 p-&gt;sched_class &#x3D; &amp;fair_sched_class；</li>
<li>调用调度类的 task_fork 函数，对于 CFS 来讲，就是调用 task_fork_fair。在这个函数里，先调用 update_curr，对于当前的进程进行统计量更新，然后把子进程和父进程的 vruntime 设成一样，最后调用 place_entity，初始化 sched_entity。这里有一个变量 sysctl_sched_child_runs_first，可以设置父进程和子进程谁先运行。如果设置了子进程先运行，即便两个进程的 vruntime 一样，也要把子进程的 sched_entity 放在前面，然后调用 resched_curr，标记当前运行的进程 TIF_NEED_RESCHED，也就是说，把父进程设置为应该被调度，这样下次调度的时候，父进程会被子进程抢占。</li>
</ul>
<p>4、初始化文件和文件系统相关变量</p>
<ul>
<li>copy_files 主要用于复制一个任务打开的文件信息。<ul>
<li>对于进程来说，这些信息用一个结构 files_struct 来维护，每个打开的文件都有一个文件描述符。在 copy_files 函数里面调用 dup_fd，在这里面会创建一个新的 files_struct，然后将所有的文件描述符数组 fdtable 拷贝一份。</li>
<li>对于线程来说，由于设置了CLONE_FILES 标识位变成将原来的files_struct 引用计数加一，并不会拷贝文件。</li>
</ul>
</li>
</ul>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">static</span> <span class="type">int</span> <span class="title function_">copy_files</span><span class="params">(<span class="type">unsigned</span> <span class="type">long</span> clone_flags, <span class="keyword">struct</span> task_struct *tsk)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">files_struct</span> *<span class="title">oldf</span>, *<span class="title">newf</span>;</span></span><br><span class="line">    <span class="type">int</span> error = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">    * A background process may not have any files ...</span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line">    oldf = current-&gt;files;</span><br><span class="line">    <span class="keyword">if</span> (!oldf)</span><br><span class="line">        <span class="keyword">goto</span> out;</span><br><span class="line">    <span class="keyword">if</span> (clone_flags &amp; CLONE_FILES) &#123;</span><br><span class="line">        <span class="type">atomic_inc</span>(&amp;oldf-&gt;count);</span><br><span class="line">        <span class="keyword">goto</span> out;</span><br><span class="line">    &#125;</span><br><span class="line">    newf = dup_fd(oldf, &amp;error);</span><br><span class="line">    <span class="keyword">if</span> (!newf)</span><br><span class="line">        <span class="keyword">goto</span> out;</span><br><span class="line"></span><br><span class="line">    tsk-&gt;files = newf;</span><br><span class="line">    error = <span class="number">0</span>;</span><br><span class="line">out:</span><br><span class="line">    <span class="keyword">return</span> error;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ul>
<li>copy_fs 主要用于复制一个任务的目录信息。<ul>
<li>对于进程来说，这些信息用一个结构 fs_struct 来维护。一个进程有自己的根目录和根文件系统 root，也有当前目录 pwd 和当前目录的文件系统，都在 fs_struct 里面维护。copy_fs 函数里面调用 copy_fs_struct，创建一个新的 fs_struct，并复制原来进程的 fs_struct。</li>
<li>对于线程来说，由于设置了CLONE_FS 标识位变成将原来的fs_struct 的用户数加一，并不会拷贝文件系统结构。</li>
</ul>
</li>
</ul>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">static</span> <span class="type">int</span> <span class="title function_">copy_fs</span><span class="params">(<span class="type">unsigned</span> <span class="type">long</span> clone_flags, <span class="keyword">struct</span> task_struct *tsk)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">fs_struct</span> *<span class="title">fs</span> =</span> current-&gt;fs;</span><br><span class="line">    <span class="keyword">if</span> (clone_flags &amp; CLONE_FS) &#123;</span><br><span class="line">        <span class="comment">/* tsk-&gt;fs is already what we want */</span></span><br><span class="line">        spin_lock(&amp;fs-&gt;lock);</span><br><span class="line">        <span class="keyword">if</span> (fs-&gt;in_exec) &#123;</span><br><span class="line">            spin_unlock(&amp;fs-&gt;lock);</span><br><span class="line">            <span class="keyword">return</span> -EAGAIN;</span><br><span class="line">        &#125;</span><br><span class="line">        fs-&gt;users++;</span><br><span class="line">        spin_unlock(&amp;fs-&gt;lock);</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    tsk-&gt;fs = copy_fs_struct(fs);</span><br><span class="line">    <span class="keyword">if</span> (!tsk-&gt;fs)</span><br><span class="line">        <span class="keyword">return</span> -ENOMEM;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>5、初始化信号相关变量</p>
<ul>
<li>整个进程里的所有线程共享一个shared_pending，这也是一个信号列表，是发给整个进程的，哪个线程处理都一样。由此我们可以做到发给进程的信号虽然可以被一个线程处理，但是影响范围应该是整个进程的。例如，kill 一个进程，则所有线程都要被干掉。如果一个信号是发给一个线程的 pthread_kill，则应该只有线程能够收到。</li>
<li>copy_sighand<ul>
<li>对于进程来说，会分配一个新的 sighand_struct。这里最主要的是维护信号处理函数，在 copy_sighand 里面会调用 memcpy，将信号处理函数 sighand-&gt;action 从父进程复制到子进程。</li>
<li>对于线程来说，由于设计了CLONE_SIGHAND标记位，会对引用计数加一并退出，没有分配新的信号变量。</li>
</ul>
</li>
</ul>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">static</span> <span class="type">int</span> <span class="title function_">copy_sighand</span><span class="params">(<span class="type">unsigned</span> <span class="type">long</span> clone_flags, <span class="keyword">struct</span> task_struct *tsk)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">sighand_struct</span> *<span class="title">sig</span>;</span></span><br><span class="line">    <span class="keyword">if</span> (clone_flags &amp; CLONE_SIGHAND) &#123;</span><br><span class="line">        refcount_inc(&amp;current-&gt;sighand-&gt;count);</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    sig = kmem_cache_alloc(sighand_cachep, GFP_KERNEL);</span><br><span class="line">    rcu_assign_pointer(tsk-&gt;sighand, sig);</span><br><span class="line">    <span class="keyword">if</span> (!sig)</span><br><span class="line">        <span class="keyword">return</span> -ENOMEM;</span><br><span class="line">    refcount_set(&amp;sig-&gt;count, <span class="number">1</span>);</span><br><span class="line">    spin_lock_irq(&amp;current-&gt;sighand-&gt;siglock);</span><br><span class="line">    <span class="built_in">memcpy</span>(sig-&gt;action, current-&gt;sighand-&gt;action, <span class="keyword">sizeof</span>(sig-&gt;action));</span><br><span class="line">    spin_unlock_irq(&amp;current-&gt;sighand-&gt;siglock);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>init_sigpending 和 copy_signal 用于初始化信号结构体，并且复制用于维护发给这个进程的信号的数据结构。copy_signal 函数会分配一个新的 signal_struct，并进行初始化。对于线程来说也是直接退出并未复制。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">static</span> <span class="type">int</span> <span class="title function_">copy_signal</span><span class="params">(<span class="type">unsigned</span> <span class="type">long</span> clone_flags, <span class="keyword">struct</span> task_struct *tsk)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">signal_struct</span> *<span class="title">sig</span>;</span></span><br><span class="line">    <span class="keyword">if</span> (clone_flags &amp; CLONE_THREAD)</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    sig = kmem_cache_zalloc(signal_cachep, GFP_KERNEL);</span><br><span class="line">......</span><br><span class="line">    <span class="comment">/* list_add(thread_node, thread_head) without INIT_LIST_HEAD() */</span></span><br><span class="line">    sig-&gt;thread_head = (<span class="keyword">struct</span> list_head)LIST_HEAD_INIT(tsk-&gt;thread_node);</span><br><span class="line">    tsk-&gt;thread_node = (<span class="keyword">struct</span> list_head)LIST_HEAD_INIT(sig-&gt;thread_head);</span><br><span class="line">    init_waitqueue_head(&amp;sig-&gt;wait_chldexit);</span><br><span class="line">    sig-&gt;curr_target = tsk;</span><br><span class="line">    init_sigpending(&amp;sig-&gt;shared_pending);</span><br><span class="line">    INIT_HLIST_HEAD(&amp;sig-&gt;multiprocess);</span><br><span class="line">    seqlock_init(&amp;sig-&gt;stats_lock);</span><br><span class="line">    prev_cputime_init(&amp;sig-&gt;prev_cputime);</span><br><span class="line">......</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>6、复制进程内存空间</p>
<ul>
<li>进程都有自己的内存空间，用 mm_struct 结构来表示。copy_mm() 函数中调用 dup_mm()，分配一个新的 mm_struct 结构，调用 memcpy 复制这个结构。dup_mmap() 用于复制内存空间中内存映射的部分。前面讲系统调用的时候，我们说过，mmap 可以分配大块的内存，其实 mmap 也可以将一个文件映射到内存中，方便可以像读写内存一样读写文件，这个在内存管理那节我们讲。</li>
<li>线程不会复制内存空间，因此因为CLONE_VM标识位而直接指向了原来的mm_struct。</li>
</ul>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">static</span> <span class="type">int</span> <span class="title function_">copy_mm</span><span class="params">(<span class="type">unsigned</span> <span class="type">long</span> clone_flags, <span class="keyword">struct</span> task_struct *tsk)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">mm_struct</span> *<span class="title">mm</span>, *<span class="title">oldmm</span>;</span></span><br><span class="line">    <span class="type">int</span> retval;</span><br><span class="line">......</span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">    * Are we cloning a kernel thread?</span></span><br><span class="line"><span class="comment">    * We need to steal a active VM for that..</span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line">    oldmm = current-&gt;mm;</span><br><span class="line">    <span class="keyword">if</span> (!oldmm)</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    <span class="comment">/* initialize the new vmacache entries */</span></span><br><span class="line">    vmacache_flush(tsk);</span><br><span class="line">    <span class="keyword">if</span> (clone_flags &amp; CLONE_VM) &#123;</span><br><span class="line">        mmget(oldmm);</span><br><span class="line">        mm = oldmm;</span><br><span class="line">        <span class="keyword">goto</span> good_mm;</span><br><span class="line">    &#125;</span><br><span class="line">    retval = -ENOMEM;</span><br><span class="line">    mm = dup_mm(tsk);</span><br><span class="line">    <span class="keyword">if</span> (!mm)</span><br><span class="line">        <span class="keyword">goto</span> fail_nomem;</span><br><span class="line">good_mm:</span><br><span class="line">    tsk-&gt;mm = mm;</span><br><span class="line">    tsk-&gt;active_mm = mm;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">fail_nomem:</span><br><span class="line">    <span class="keyword">return</span> retval;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>7、分配 pid，设置 tid，group_leader，并且建立任务之间的亲缘关系。</p>
<ul>
<li>group_leader：进程的话 group_leader就是它自己，和旧进程分开。线程的话则设置为当前进程的group_leader。</li>
<li>tgid: 对进程来说是自己的pid，对线程来说是当前进程的pid</li>
<li>real_parent : 对进程来说即当前进程，对线程来说则是当前进程的real_parent</li>
</ul>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">static</span> __latent_entropy <span class="keyword">struct</span> task_struct *<span class="title function_">copy_process</span><span class="params">(......)</span> &#123;</span><br><span class="line">......    </span><br><span class="line">    p-&gt;pid = pid_nr(pid);</span><br><span class="line">    <span class="keyword">if</span> (clone_flags &amp; CLONE_THREAD) &#123;</span><br><span class="line">        p-&gt;exit_signal = <span class="number">-1</span>;</span><br><span class="line">        p-&gt;group_leader = current-&gt;group_leader;</span><br><span class="line">        p-&gt;tgid = current-&gt;tgid;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (clone_flags &amp; CLONE_PARENT)</span><br><span class="line">          p-&gt;exit_signal = current-&gt;group_leader-&gt;exit_signal;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">          p-&gt;exit_signal = (clone_flags &amp; CSIGNAL);</span><br><span class="line">        p-&gt;group_leader = p;</span><br><span class="line">        p-&gt;tgid = p-&gt;pid;</span><br><span class="line">    &#125;</span><br><span class="line">......</span><br><span class="line">    <span class="keyword">if</span> (clone_flags &amp; (CLONE_PARENT|CLONE_THREAD)) &#123;</span><br><span class="line">        p-&gt;real_parent = current-&gt;real_parent;</span><br><span class="line">        p-&gt;parent_exec_id = current-&gt;parent_exec_id;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        p-&gt;real_parent = current;</span><br><span class="line">        p-&gt;parent_exec_id = current-&gt;self_exec_id;</span><br><span class="line">    &#125; </span><br><span class="line">......  </span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h3 id="4-2-新进程的唤醒"><a href="#4-2-新进程的唤醒" class="headerlink" title="4.2 新进程的唤醒"></a>4.2 新进程的唤醒</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">_do_fork 做的第二件大事是通过调用 wake_up_new_task()唤醒进程。</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">wake_up_new_task</span><span class="params">(<span class="keyword">struct</span> task_struct *p)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">rq_flags</span> <span class="title">rf</span>;</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">rq</span> *<span class="title">rq</span>;</span></span><br><span class="line">......</span><br><span class="line">    p-&gt;state = TASK_RUNNING;</span><br><span class="line">......</span><br><span class="line">    activate_task(rq, p, ENQUEUE_NOCLOCK);</span><br><span class="line">    trace_sched_wakeup_new(p);</span><br><span class="line">    check_preempt_curr(rq, p, WF_FORK);</span><br><span class="line">......</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>首先，我们需要将进程的状态设置为 TASK_RUNNING。activate_task() 函数中会调用 enqueue_task()。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">activate_task</span><span class="params">(<span class="keyword">struct</span> rq *rq, <span class="keyword">struct</span> task_struct *p, <span class="type">int</span> flags)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">if</span> (task_contributes_to_load(p))</span><br><span class="line">        rq-&gt;nr_uninterruptible--;</span><br><span class="line"></span><br><span class="line">    enqueue_task(rq, p, flags);</span><br><span class="line"></span><br><span class="line">    p-&gt;on_rq = TASK_ON_RQ_QUEUED;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">static</span> <span class="keyword">inline</span> <span class="type">void</span> <span class="title function_">enqueue_task</span><span class="params">(<span class="keyword">struct</span> rq *rq, <span class="keyword">struct</span> task_struct *p, <span class="type">int</span> flags)</span></span><br><span class="line">&#123;</span><br><span class="line">.....</span><br><span class="line">    p-&gt;sched_class-&gt;enqueue_task(rq, p, flags);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>如果是 CFS 的调度类，则执行相应的 enqueue_task_fair()。在 enqueue_task_fair() 中取出的队列就是 cfs_rq，然后调用 enqueue_entity()。在 enqueue_entity() 函数里面，会调用 update_curr()，更新运行的统计量，然后调用 __enqueue_entity，将 sched_entity 加入到红黑树里面，然后将 se-&gt;on_rq &#x3D; 1 设置在队列上。回到 enqueue_task_fair 后，将这个队列上运行的进程数目加一。然后，wake_up_new_task 会调用 check_preempt_curr，看是否能够抢占当前进程。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">static</span> <span class="type">void</span></span><br><span class="line"><span class="title function_">enqueue_task_fair</span><span class="params">(<span class="keyword">struct</span> rq *rq, <span class="keyword">struct</span> task_struct *p, <span class="type">int</span> flags)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">cfs_rq</span> *<span class="title">cfs_rq</span>;</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">sched_entity</span> *<span class="title">se</span> =</span> &amp;p-&gt;se;</span><br><span class="line">......</span><br><span class="line">    for_each_sched_entity(se) &#123;</span><br><span class="line">        <span class="keyword">if</span> (se-&gt;on_rq)</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        cfs_rq = cfs_rq_of(se);</span><br><span class="line">        enqueue_entity(cfs_rq, se, flags);</span><br><span class="line"></span><br><span class="line">        cfs_rq-&gt;h_nr_running++;</span><br><span class="line">        cfs_rq-&gt;idle_h_nr_running += idle_h_nr_running;</span><br><span class="line"></span><br><span class="line">        <span class="comment">/* end evaluation on encountering a throttled cfs_rq */</span></span><br><span class="line">        <span class="keyword">if</span> (cfs_rq_throttled(cfs_rq))</span><br><span class="line">            <span class="keyword">goto</span> enqueue_throttle;</span><br><span class="line"></span><br><span class="line">        flags = ENQUEUE_WAKEUP;</span><br><span class="line">    &#125;</span><br><span class="line">......</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>在 check_preempt_curr 中，会调用相应的调度类的 rq-&gt;curr-&gt;sched_class-&gt;check_preempt_curr(rq, p, flags)。对于CFS调度类来讲，调用的是 check_preempt_wakeup。在 check_preempt_wakeup函数中，前面调用 task_fork_fair的时候，设置 sysctl_sched_child_runs_first 了，已经将当前父进程的 TIF_NEED_RESCHED 设置了，则直接返回。否则，check_preempt_wakeup 还是会调用 update_curr 更新一次统计量，然后 wakeup_preempt_entity 将父进程和子进程 PK 一次，看是不是要抢占，如果要则调用 resched_curr 标记父进程为 TIF_NEED_RESCHED。如果新创建的进程应该抢占父进程，在什么时间抢占呢？别忘了 fork 是一个系统调用，从系统调用返回的时候，是抢占的一个好时机，如果父进程判断自己已经被设置为 TIF_NEED_RESCHED，就让子进程先跑，抢占自己。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">static</span> <span class="type">void</span> <span class="title function_">check_preempt_wakeup</span><span class="params">(<span class="keyword">struct</span> rq *rq, <span class="keyword">struct</span> task_struct *p, <span class="type">int</span> wake_flags)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">task_struct</span> *<span class="title">curr</span> =</span> rq-&gt;curr;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">sched_entity</span> *<span class="title">se</span> =</span> &amp;curr-&gt;se, *pse = &amp;p-&gt;se;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">cfs_rq</span> *<span class="title">cfs_rq</span> =</span> task_cfs_rq(curr);</span><br><span class="line">......</span><br><span class="line">    <span class="keyword">if</span> (test_tsk_need_resched(curr))</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">......</span><br><span class="line">    find_matching_se(&amp;se, &amp;pse);</span><br><span class="line">    update_curr(cfs_rq_of(se));</span><br><span class="line">    <span class="keyword">if</span> (wakeup_preempt_entity(se, pse) == <span class="number">1</span>) &#123;</span><br><span class="line">        <span class="keyword">goto</span> preempt;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span>;</span><br><span class="line">preempt:</span><br><span class="line">    resched_curr(rq);</span><br><span class="line">......</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>至此，我们就完成了任务的整个创建过程，并根据情况唤醒任务开始执行。</p>
<h2 id="五-总结"><a href="#五-总结" class="headerlink" title="五. 总结"></a>五. 总结</h2><p>本文十分之长，因为内容极多，源码复杂，本来想拆分为两篇文章，但是又因为过于紧密的联系因此合在了一起。本文介绍了进程的创建和线程的创建，而多进程的派生因为使用和线程内核态创建一样的函数因此放在了一起变对比边说明。由此，进程、线程的结构体以及创建过程就全部分析完了，下文将继续分析进程、线程的调度。</p>
</article><div class="post-copyright"><div class="post-copyright__author"><span class="post-copyright-meta"><i class="fas fa-circle-user fa-fw"></i>文章作者: </span><span class="post-copyright-info"><a href="https://vcloud.ysme.top">ysme</a></span></div><div class="post-copyright__type"><span class="post-copyright-meta"><i class="fas fa-square-arrow-up-right fa-fw"></i>文章链接: </span><span class="post-copyright-info"><a href="https://vcloud.ysme.top/2023/01/15/linux-docs/%E8%BF%9B%E7%A8%8B%E7%AE%A1%E7%90%86/%E8%BF%9B%E7%A8%8B%E3%80%81%E7%BA%BF%E7%A8%8B%E7%9A%84%E5%88%9B%E5%BB%BA%E5%92%8C%E6%B4%BE%E7%94%9F/">https://vcloud.ysme.top/2023/01/15/linux-docs/%E8%BF%9B%E7%A8%8B%E7%AE%A1%E7%90%86/%E8%BF%9B%E7%A8%8B%E3%80%81%E7%BA%BF%E7%A8%8B%E7%9A%84%E5%88%9B%E5%BB%BA%E5%92%8C%E6%B4%BE%E7%94%9F/</a></span></div><div class="post-copyright__notice"><span class="post-copyright-meta"><i class="fas fa-circle-exclamation fa-fw"></i>版权声明: </span><span class="post-copyright-info">本博客所有文章除特别声明外，均采用 <a href="https://creativecommons.org/licenses/by-nc-sa/4.0/" target="_blank">CC BY-NC-SA 4.0</a> 许可协议。转载请注明来自 <a href="https://vcloud.ysme.top" target="_blank">Blog</a>！</span></div></div><div class="tag_share"><div class="post-meta__tag-list"><a class="post-meta__tags" href="/tags/Linux/">Linux</a></div><div class="post_share"><div class="social-share" data-image="https://user-images.githubusercontent.com/87457873/128132712-dfe308a8-728b-4948-9e8e-f7563484355e.png" data-sites="facebook,twitter,wechat,weibo,qq"></div><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/butterfly-extsrc@1.1.3/sharejs/dist/css/share.min.css" media="print" onload="this.media='all'"><script src="https://cdn.jsdelivr.net/npm/butterfly-extsrc@1.1.3/sharejs/dist/js/social-share.min.js" defer></script></div></div><nav class="pagination-post" id="pagination"><div class="prev-post pull-left"><a href="/2023/01/15/linux-docs/%E8%BF%9B%E7%A8%8B%E7%AE%A1%E7%90%86/%E4%BB%BB%E5%8A%A1%E8%B0%83%E5%BA%A6/" title="任务调度"><img class="cover" src="https://user-images.githubusercontent.com/87457873/128118954-23f78086-e7fa-498c-8759-c897097b7f8c.png" onerror="onerror=null;src='/img/404.jpg'" alt="cover of previous post"><div class="pagination-info"><div class="label">上一篇</div><div class="prev_info">任务调度</div></div></a></div><div class="next-post pull-right"><a href="/2023/01/15/linux-docs/%E8%BF%9B%E7%A8%8B%E7%AE%A1%E7%90%86/%E8%BF%9B%E7%A8%8B%E7%9A%84%E6%A0%B8%E5%BF%83%E2%80%94%E2%80%94task_truct/" title="进程的核心——task_truct"><img class="cover" src="https://user-images.githubusercontent.com/87457873/128131628-97ac325a-96f2-4535-9c07-b718c1f54515.png" onerror="onerror=null;src='/img/404.jpg'" alt="cover of next post"><div class="pagination-info"><div class="label">下一篇</div><div class="next_info">进程的核心——task_truct</div></div></a></div></nav><div class="relatedPosts"><div class="headline"><i class="fas fa-thumbs-up fa-fw"></i><span>相关推荐</span></div><div class="relatedPosts-list"><div><a href="/2023/01/15/linux-docs/30%E5%88%86%E9%92%9F%E5%AD%A6%E4%BC%9A%E7%BC%96%E8%AF%91linux%E5%86%85%E6%A0%B8/" title="Linux 30分钟学会编译linux内核"><img class="cover" src="https://pic2.zhimg.com/80/v2-99c76217f4575d98a9001a4fd8c1681d_720w.webp" alt="cover"><div class="content is-center"><div class="date"><i class="far fa-calendar-alt fa-fw"></i> 2023-01-15</div><div class="title">Linux 30分钟学会编译linux内核</div></div></a></div><div><a href="/2023/01/15/linux-docs/Linux%20IO%20%E4%B9%8B%20IO%E4%B8%8E%E7%BD%91%E7%BB%9C%E6%A8%A1%E5%9E%8B/" title="Linux IO 之 IO与网络模型"><img class="cover" src="https://user-images.githubusercontent.com/87457873/127649604-761ead2e-8c72-4876-a52f-8310f3c3b49c.png" alt="cover"><div class="content is-center"><div class="date"><i class="far fa-calendar-alt fa-fw"></i> 2023-01-15</div><div class="title">Linux IO 之 IO与网络模型</div></div></a></div><div><a href="/2023/01/15/linux-docs/Linux%20Kernel%E5%86%85%E6%A0%B8%E6%95%B4%E4%BD%93%E6%9E%B6%E6%9E%84(%E5%9B%BE%E6%96%87%E8%AF%A6%E8%A7%A3)/" title="Linux Kernel内核整体架构(图文详解)"><img class="cover" src="https://pic2.zhimg.com/80/v2-93cd0f1a4abbdfeb4af71202535fe4f9_720w.webp" alt="cover"><div class="content is-center"><div class="date"><i class="far fa-calendar-alt fa-fw"></i> 2023-01-15</div><div class="title">Linux Kernel内核整体架构(图文详解)</div></div></a></div><div><a href="/2023/01/15/linux-docs/Linux%E5%86%85%E6%A0%B8Coding%20Style%E6%95%B4%E7%90%86/" title="Linux内核Coding Style整理"><img class="cover" src="https://pic4.zhimg.com/80/v2-55215e20944d5e1a161253e73eddaa07_720w.webp" alt="cover"><div class="content is-center"><div class="date"><i class="far fa-calendar-alt fa-fw"></i> 2023-01-15</div><div class="title">Linux内核Coding Style整理</div></div></a></div><div><a href="/2023/01/15/linux-docs/Linux%E5%86%85%E6%A0%B8Makefile%E7%B3%BB%E7%BB%9F%E6%96%87%E4%BB%B6%E8%AF%A6%E8%A7%A3/" title="Linux内核Makefile系统文件详解"><img class="cover" src="https://pic4.zhimg.com/80/v2-55215e20944d5e1a161253e73eddaa07_720w.webp" alt="cover"><div class="content is-center"><div class="date"><i class="far fa-calendar-alt fa-fw"></i> 2023-01-15</div><div class="title">Linux内核Makefile系统文件详解</div></div></a></div><div><a href="/2023/01/15/linux-docs/Linux%E5%86%85%E6%A0%B8RCU%E6%9C%BA%E5%88%B6/" title="Linux内核RCU机制"><img class="cover" src="https://pic2.zhimg.com/80/v2-012ee665b35eb28bca5c88269765f069_720w.webp" alt="cover"><div class="content is-center"><div class="date"><i class="far fa-calendar-alt fa-fw"></i> 2023-01-15</div><div class="title">Linux内核RCU机制</div></div></a></div></div></div></div><div class="aside-content" id="aside-content"><div class="card-widget card-info"><div class="is-center"><div class="avatar-img"><img src="/img/avatar.jpg" onerror="this.onerror=null;this.src='/img/friend_404.gif'" alt="avatar"/></div><div class="author-info__name">ysme</div><div class="author-info__description">嘻嘻哈哈。</div></div><div class="card-info-data site-data is-center"><a href="/archives/"><div class="headline">文章</div><div class="length-num">130</div></a><a href="/tags/"><div class="headline">标签</div><div class="length-num">4</div></a><a href="/categories/"><div class="headline">分类</div><div class="length-num">10</div></a></div><a id="card-info-btn" target="_blank" rel="noopener" href="https://github.com/ysme1"><i class="fab fa-github"></i><span>Follow Me</span></a><div class="card-info-social-icons is-center"><a class="social-icon" href="https://github.com/ysme1" target="_blank" title="Github"><i class="fab fa-github" style="color: #24292e;"></i></a><a class="social-icon" href="mailto:zys1395740068@gmail.com" target="_blank" title="Email"><i class="fas fa-envelope" style="color: #4a7dbe;"></i></a></div></div><div class="card-widget card-announcement"><div class="item-headline"><i class="fas fa-bullhorn fa-shake"></i><span>公告</span></div><div class="announcement_content">This is my Blog</div></div><div class="sticky_layout"><div class="card-widget" id="card-toc"><div class="item-headline"><i class="fas fa-stream"></i><span>目录</span><span class="toc-percentage"></span></div><div class="toc-content"><ol class="toc"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%B8%80-%E5%89%8D%E8%A8%80"><span class="toc-number">1.</span> <span class="toc-text">一. 前言</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%BA%8C-%E8%BF%9B%E7%A8%8B%E7%9A%84%E5%88%9B%E5%BB%BA"><span class="toc-number">2.</span> <span class="toc-text">二. 进程的创建</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#2-1-%E7%BC%96%E8%AF%91"><span class="toc-number">2.1.</span> <span class="toc-text">2. 1 编译</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#2-2-%E9%93%BE%E6%8E%A5"><span class="toc-number">2.2.</span> <span class="toc-text">2.2 链接</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#2-2-1-%E9%9D%99%E6%80%81%E9%93%BE%E6%8E%A5"><span class="toc-number">2.2.1.</span> <span class="toc-text">2.2.1 静态链接</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#2-2-2-%E5%8A%A8%E6%80%81%E9%93%BE%E6%8E%A5"><span class="toc-number">2.2.2.</span> <span class="toc-text">2.2.2 动态链接</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#2-3-%E5%8A%A0%E8%BD%BD%E8%BF%90%E8%A1%8C"><span class="toc-number">2.3.</span> <span class="toc-text">2.3 加载运行</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%B8%89-%E7%BA%BF%E7%A8%8B%E7%9A%84%E5%88%9B%E5%BB%BA%E4%B9%8B%E7%94%A8%E6%88%B7%E6%80%81"><span class="toc-number">3.</span> <span class="toc-text">三. 线程的创建之用户态</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%9B%9B-%E7%BA%BF%E7%A8%8B%E7%9A%84%E5%86%85%E6%A0%B8%E6%80%81%E5%88%9B%E5%BB%BA%E5%8F%8A%E8%BF%9B%E7%A8%8B%E7%9A%84%E6%B4%BE%E7%94%9F"><span class="toc-number">4.</span> <span class="toc-text">四. 线程的内核态创建及进程的派生</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#4-1-%E4%BB%BB%E5%8A%A1%E7%BB%93%E6%9E%84%E4%BD%93%E5%A4%8D%E5%88%B6"><span class="toc-number">4.1.</span> <span class="toc-text">4.1 任务结构体复制</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#4-2-%E6%96%B0%E8%BF%9B%E7%A8%8B%E7%9A%84%E5%94%A4%E9%86%92"><span class="toc-number">4.2.</span> <span class="toc-text">4.2 新进程的唤醒</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%BA%94-%E6%80%BB%E7%BB%93"><span class="toc-number">5.</span> <span class="toc-text">五. 总结</span></a></li></ol></div></div><div class="card-widget card-recent-post"><div class="item-headline"><i class="fas fa-history"></i><span>最新文章</span></div><div class="aside-list"><div class="aside-list-item"><a class="thumbnail" href="/2023/03/22/%E5%B7%A5%E5%85%B7/git/git%E5%BF%AB%E9%80%9F%E5%85%A5%E9%97%A8/" title="Git 快速入门指南"><img src="https://api.yimian.xyz/img?type=moe" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="Git 快速入门指南"/></a><div class="content"><a class="title" href="/2023/03/22/%E5%B7%A5%E5%85%B7/git/git%E5%BF%AB%E9%80%9F%E5%85%A5%E9%97%A8/" title="Git 快速入门指南">Git 快速入门指南</a><time datetime="2023-03-22T01:13:37.000Z" title="发表于 2023-03-22 09:13:37">2023-03-22</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/2023/01/15/linux-docs/30%E5%88%86%E9%92%9F%E5%AD%A6%E4%BC%9A%E7%BC%96%E8%AF%91linux%E5%86%85%E6%A0%B8/" title="Linux 30分钟学会编译linux内核"><img src="https://pic2.zhimg.com/80/v2-99c76217f4575d98a9001a4fd8c1681d_720w.webp" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="Linux 30分钟学会编译linux内核"/></a><div class="content"><a class="title" href="/2023/01/15/linux-docs/30%E5%88%86%E9%92%9F%E5%AD%A6%E4%BC%9A%E7%BC%96%E8%AF%91linux%E5%86%85%E6%A0%B8/" title="Linux 30分钟学会编译linux内核">Linux 30分钟学会编译linux内核</a><time datetime="2023-01-15T01:13:37.000Z" title="发表于 2023-01-15 09:13:37">2023-01-15</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/2023/01/15/linux-docs/Linux%20IO%20%E4%B9%8B%20IO%E4%B8%8E%E7%BD%91%E7%BB%9C%E6%A8%A1%E5%9E%8B/" title="Linux IO 之 IO与网络模型"><img src="https://user-images.githubusercontent.com/87457873/127649604-761ead2e-8c72-4876-a52f-8310f3c3b49c.png" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="Linux IO 之 IO与网络模型"/></a><div class="content"><a class="title" href="/2023/01/15/linux-docs/Linux%20IO%20%E4%B9%8B%20IO%E4%B8%8E%E7%BD%91%E7%BB%9C%E6%A8%A1%E5%9E%8B/" title="Linux IO 之 IO与网络模型">Linux IO 之 IO与网络模型</a><time datetime="2023-01-15T01:13:37.000Z" title="发表于 2023-01-15 09:13:37">2023-01-15</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/2023/01/15/linux-docs/Linux%20Kernel%E5%86%85%E6%A0%B8%E6%95%B4%E4%BD%93%E6%9E%B6%E6%9E%84(%E5%9B%BE%E6%96%87%E8%AF%A6%E8%A7%A3)/" title="Linux Kernel内核整体架构(图文详解)"><img src="https://pic2.zhimg.com/80/v2-93cd0f1a4abbdfeb4af71202535fe4f9_720w.webp" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="Linux Kernel内核整体架构(图文详解)"/></a><div class="content"><a class="title" href="/2023/01/15/linux-docs/Linux%20Kernel%E5%86%85%E6%A0%B8%E6%95%B4%E4%BD%93%E6%9E%B6%E6%9E%84(%E5%9B%BE%E6%96%87%E8%AF%A6%E8%A7%A3)/" title="Linux Kernel内核整体架构(图文详解)">Linux Kernel内核整体架构(图文详解)</a><time datetime="2023-01-15T01:13:37.000Z" title="发表于 2023-01-15 09:13:37">2023-01-15</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/2023/01/15/linux-docs/Linux%E5%86%85%E6%A0%B8Coding%20Style%E6%95%B4%E7%90%86/" title="Linux内核Coding Style整理"><img src="https://pic4.zhimg.com/80/v2-55215e20944d5e1a161253e73eddaa07_720w.webp" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="Linux内核Coding Style整理"/></a><div class="content"><a class="title" href="/2023/01/15/linux-docs/Linux%E5%86%85%E6%A0%B8Coding%20Style%E6%95%B4%E7%90%86/" title="Linux内核Coding Style整理">Linux内核Coding Style整理</a><time datetime="2023-01-15T01:13:37.000Z" title="发表于 2023-01-15 09:13:37">2023-01-15</time></div></div></div></div></div></div></main><footer id="footer"><div id="footer-wrap"><div class="copyright">&copy;2020 - 2024 By ysme</div><div class="framework-info"><span>框架 </span><a target="_blank" rel="noopener" href="https://hexo.io">Hexo</a><span class="footer-separator">|</span><span>主题 </span><a target="_blank" rel="noopener" href="https://github.com/jerryc127/hexo-theme-butterfly">Butterfly</a></div><div class="footer_custom_text"><a target="_blank" rel="noopener" href="https://beian.miit.gov.cn/#/Integrated/recordQuery"><img class="icp-icon" src=https://beian.mps.gov.cn/img/logo01.dd7ff50e.png><span>浙ICP备2021036292号</span></a></div></div></footer></div><div id="rightside"><div id="rightside-config-hide"><button id="readmode" type="button" title="阅读模式"><i class="fas fa-book-open"></i></button><button id="darkmode" type="button" title="浅色和深色模式转换"><i class="fas fa-adjust"></i></button><button id="hide-aside-btn" type="button" title="单栏和双栏切换"><i class="fas fa-arrows-alt-h"></i></button></div><div id="rightside-config-show"><button id="rightside-config" type="button" title="设置"><i class="fas fa-cog fa-spin"></i></button><button class="close" id="mobile-toc-button" type="button" title="目录"><i class="fas fa-list-ul"></i></button><button id="go-up" type="button" title="回到顶部"><span class="scroll-percent"></span><i class="fas fa-arrow-up"></i></button></div></div><div><script src="/js/utils.js?v=4.13.0"></script><script src="/js/main.js?v=4.13.0"></script><script src="https://cdn.jsdelivr.net/npm/@fancyapps/ui@5.0.33/dist/fancybox/fancybox.umd.min.js"></script><div class="js-pjax"></div><script async data-pjax src="//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script><div id="local-search"><div class="search-dialog"><nav class="search-nav"><span class="search-dialog-title">搜索</span><span id="loading-status"></span><button class="search-close-button"><i class="fas fa-times"></i></button></nav><div class="is-center" id="loading-database"><i class="fas fa-spinner fa-pulse"></i><span>  数据库加载中</span></div><div class="search-wrap"><div id="local-search-input"><div class="local-search-box"><input class="local-search-box--input" placeholder="搜索文章" type="text"/></div></div><hr/><div id="local-search-results"></div><div id="local-search-stats-wrap"></div></div></div><div id="search-mask"></div><script src="/js/search/local-search.js?v=4.13.0"></script></div></div></body></html>