<!DOCTYPE html><html lang="zh-CN" data-theme="light"><head><meta charset="UTF-8"><meta http-equiv="X-UA-Compatible" content="IE=edge"><meta name="viewport" content="width=device-width, initial-scale=1.0,viewport-fit=cover"><title>Linux内核文件系统挂载 | Blog</title><meta name="author" content="ysme"><meta name="copyright" content="ysme"><meta name="format-detection" content="telephone=no"><meta name="theme-color" content="#ffffff"><meta name="description" content="1、前言 环境：处理器架构：arm64内核源码：linux-5.11ubuntu版本：20.04.1代码阅读工具：vim+ctags+cscope   我们知道，Linux系统中我们经常将一个块设备上的文件系统挂载到某个目录下才能访问这个文件系统下的文件，但是你有没有思考过：为什么块设备挂载之后才能访问文件？挂载文件系统Linux内核到底为我们做了哪些事情？是否可以不将文件系统挂载到具体的目录下也">
<meta property="og:type" content="article">
<meta property="og:title" content="Linux内核文件系统挂载">
<meta property="og:url" content="https://vcloud.ysme.top/2023/01/15/linux-docs/%E6%96%87%E4%BB%B6%E7%B3%BB%E7%BB%9F/Linux%E5%86%85%E6%A0%B8%E6%96%87%E4%BB%B6%E7%B3%BB%E7%BB%9F%E6%8C%82%E8%BD%BD/index.html">
<meta property="og:site_name" content="Blog">
<meta property="og:description" content="1、前言 环境：处理器架构：arm64内核源码：linux-5.11ubuntu版本：20.04.1代码阅读工具：vim+ctags+cscope   我们知道，Linux系统中我们经常将一个块设备上的文件系统挂载到某个目录下才能访问这个文件系统下的文件，但是你有没有思考过：为什么块设备挂载之后才能访问文件？挂载文件系统Linux内核到底为我们做了哪些事情？是否可以不将文件系统挂载到具体的目录下也">
<meta property="og:locale" content="zh_CN">
<meta property="og:image" content="https://i.loli.net/2020/05/01/gkihqEjXxJ5UZ1C.jpg">
<meta property="article:published_time" content="2023-01-15T01:13:37.000Z">
<meta property="article:modified_time" content="2024-10-24T00:11:15.748Z">
<meta property="article:author" content="ysme">
<meta property="article:tag" content="Linux">
<meta name="twitter:card" content="summary">
<meta name="twitter:image" content="https://i.loli.net/2020/05/01/gkihqEjXxJ5UZ1C.jpg"><link rel="shortcut icon" href="/img/favicon.png"><link rel="canonical" href="https://vcloud.ysme.top/2023/01/15/linux-docs/%E6%96%87%E4%BB%B6%E7%B3%BB%E7%BB%9F/Linux%E5%86%85%E6%A0%B8%E6%96%87%E4%BB%B6%E7%B3%BB%E7%BB%9F%E6%8C%82%E8%BD%BD/index.html"><link rel="preconnect" href="//cdn.jsdelivr.net"/><link rel="preconnect" href="//busuanzi.ibruce.info"/><link rel="stylesheet" href="/css/index.css?v=4.13.0"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fortawesome/fontawesome-free@6.5.1/css/all.min.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fancyapps/ui@5.0.33/dist/fancybox/fancybox.min.css" media="print" onload="this.media='all'"><script>const GLOBAL_CONFIG = {
  root: '/',
  algolia: undefined,
  localSearch: {"path":"/search.xml","preload":false,"top_n_per_article":1,"unescape":false,"languages":{"hits_empty":"找不到您查询的内容：${query}","hits_stats":"共找到 ${hits} 篇文章"}},
  translate: undefined,
  noticeOutdate: undefined,
  highlight: {"plugin":"highlight.js","highlightCopy":true,"highlightLang":true,"highlightHeightLimit":200},
  copy: {
    success: '复制成功',
    error: '复制错误',
    noSupport: '浏览器不支持'
  },
  relativeDate: {
    homepage: false,
    post: false
  },
  runtime: '',
  dateSuffix: {
    just: '刚刚',
    min: '分钟前',
    hour: '小时前',
    day: '天前',
    month: '个月前'
  },
  copyright: undefined,
  lightbox: 'fancybox',
  Snackbar: undefined,
  infinitegrid: {
    js: 'https://cdn.jsdelivr.net/npm/@egjs/infinitegrid@4.11.1/dist/infinitegrid.min.js',
    buttonText: '加载更多'
  },
  isPhotoFigcaption: false,
  islazyload: false,
  isAnchor: false,
  percent: {
    toc: true,
    rightside: false,
  },
  autoDarkmode: false
}</script><script id="config-diff">var GLOBAL_CONFIG_SITE = {
  title: 'Linux内核文件系统挂载',
  isPost: true,
  isHome: false,
  isHighlightShrink: false,
  isToc: true,
  postUpdate: '2024-10-24 08:11:15'
}</script><script>(win=>{
      win.saveToLocal = {
        set: (key, value, ttl) => {
          if (ttl === 0) return
          const now = Date.now()
          const expiry = now + ttl * 86400000
          const item = {
            value,
            expiry
          }
          localStorage.setItem(key, JSON.stringify(item))
        },
      
        get: key => {
          const itemStr = localStorage.getItem(key)
      
          if (!itemStr) {
            return undefined
          }
          const item = JSON.parse(itemStr)
          const now = Date.now()
      
          if (now > item.expiry) {
            localStorage.removeItem(key)
            return undefined
          }
          return item.value
        }
      }
    
      win.getScript = (url, attr = {}) => new Promise((resolve, reject) => {
        const script = document.createElement('script')
        script.src = url
        script.async = true
        script.onerror = reject
        script.onload = script.onreadystatechange = function() {
          const loadState = this.readyState
          if (loadState && loadState !== 'loaded' && loadState !== 'complete') return
          script.onload = script.onreadystatechange = null
          resolve()
        }

        Object.keys(attr).forEach(key => {
          script.setAttribute(key, attr[key])
        })

        document.head.appendChild(script)
      })
    
      win.getCSS = (url, id = false) => new Promise((resolve, reject) => {
        const link = document.createElement('link')
        link.rel = 'stylesheet'
        link.href = url
        if (id) link.id = id
        link.onerror = reject
        link.onload = link.onreadystatechange = function() {
          const loadState = this.readyState
          if (loadState && loadState !== 'loaded' && loadState !== 'complete') return
          link.onload = link.onreadystatechange = null
          resolve()
        }
        document.head.appendChild(link)
      })
    
      win.activateDarkMode = () => {
        document.documentElement.setAttribute('data-theme', 'dark')
        if (document.querySelector('meta[name="theme-color"]') !== null) {
          document.querySelector('meta[name="theme-color"]').setAttribute('content', '#0d0d0d')
        }
      }
      win.activateLightMode = () => {
        document.documentElement.setAttribute('data-theme', 'light')
        if (document.querySelector('meta[name="theme-color"]') !== null) {
          document.querySelector('meta[name="theme-color"]').setAttribute('content', '#ffffff')
        }
      }
      const t = saveToLocal.get('theme')
    
        if (t === 'dark') activateDarkMode()
        else if (t === 'light') activateLightMode()
      
      const asideStatus = saveToLocal.get('aside-status')
      if (asideStatus !== undefined) {
        if (asideStatus === 'hide') {
          document.documentElement.classList.add('hide-aside')
        } else {
          document.documentElement.classList.remove('hide-aside')
        }
      }
    
      const detectApple = () => {
        if(/iPad|iPhone|iPod|Macintosh/.test(navigator.userAgent)){
          document.documentElement.classList.add('apple')
        }
      }
      detectApple()
    })(window)</script><meta name="generator" content="Hexo 7.1.1"></head><body><div id="sidebar"><div id="menu-mask"></div><div id="sidebar-menus"><div class="avatar-img is-center"><img src="/img/avatar.jpg" onerror="onerror=null;src='/img/friend_404.gif'" alt="avatar"/></div><div class="sidebar-site-data site-data is-center"><a href="/archives/"><div class="headline">文章</div><div class="length-num">131</div></a><a href="/tags/"><div class="headline">标签</div><div class="length-num">5</div></a><a href="/categories/"><div class="headline">分类</div><div class="length-num">10</div></a></div><hr class="custom-hr"/><div class="menus_items"><div class="menus_item"><a class="site-page" href="/"><i class="fa-fw fas fa-home"></i><span> Home</span></a></div><div class="menus_item"><a class="site-page" href="/archives/"><i class="fa-fw fas fa-archive"></i><span> Archives</span></a></div><div class="menus_item"><a class="site-page" href="/tags/"><i class="fa-fw fas fa-tags"></i><span> Tags</span></a></div><div class="menus_item"><a class="site-page" href="/categories/"><i class="fa-fw fas fa-folder-open"></i><span> Categories</span></a></div><div class="menus_item"><a class="site-page group" href="javascript:void(0);"><i class="fa-fw fas fa-list"></i><span> List</span><i class="fas fa-chevron-down"></i></a><ul class="menus_item_child"><li><a class="site-page child" href="/music/"><i class="fa-fw fas fa-music"></i><span> Music</span></a></li><li><a class="site-page child" href="/movies/"><i class="fa-fw fas fa-video"></i><span> Movie</span></a></li></ul></div><div class="menus_item"><a class="site-page" href="/link/"><i class="fa-fw fas fa-link"></i><span> Link</span></a></div><div class="menus_item"><a class="site-page" href="/about/"><i class="fa-fw fas fa-heart"></i><span> About</span></a></div></div></div></div><div class="post" id="body-wrap"><header class="post-bg" id="page-header" style="background-image: url('https://i.loli.net/2020/05/01/gkihqEjXxJ5UZ1C.jpg')"><nav id="nav"><span id="blog-info"><a href="/" title="Blog"><span class="site-name">Blog</span></a></span><div id="menus"><div id="search-button"><a class="site-page social-icon search" href="javascript:void(0);"><i class="fas fa-search fa-fw"></i><span> 搜索</span></a></div><div class="menus_items"><div class="menus_item"><a class="site-page" href="/"><i class="fa-fw fas fa-home"></i><span> Home</span></a></div><div class="menus_item"><a class="site-page" href="/archives/"><i class="fa-fw fas fa-archive"></i><span> Archives</span></a></div><div class="menus_item"><a class="site-page" href="/tags/"><i class="fa-fw fas fa-tags"></i><span> Tags</span></a></div><div class="menus_item"><a class="site-page" href="/categories/"><i class="fa-fw fas fa-folder-open"></i><span> Categories</span></a></div><div class="menus_item"><a class="site-page group" href="javascript:void(0);"><i class="fa-fw fas fa-list"></i><span> List</span><i class="fas fa-chevron-down"></i></a><ul class="menus_item_child"><li><a class="site-page child" href="/music/"><i class="fa-fw fas fa-music"></i><span> Music</span></a></li><li><a class="site-page child" href="/movies/"><i class="fa-fw fas fa-video"></i><span> Movie</span></a></li></ul></div><div class="menus_item"><a class="site-page" href="/link/"><i class="fa-fw fas fa-link"></i><span> Link</span></a></div><div class="menus_item"><a class="site-page" href="/about/"><i class="fa-fw fas fa-heart"></i><span> About</span></a></div></div><div id="toggle-menu"><a class="site-page" href="javascript:void(0);"><i class="fas fa-bars fa-fw"></i></a></div></div></nav><div id="post-info"><h1 class="post-title">Linux内核文件系统挂载</h1><div id="post-meta"><div class="meta-firstline"><span class="post-meta-date"><i class="far fa-calendar-alt fa-fw post-meta-icon"></i><span class="post-meta-label">发表于</span><time class="post-meta-date-created" datetime="2023-01-15T01:13:37.000Z" title="发表于 2023-01-15 09:13:37">2023-01-15</time><span class="post-meta-separator">|</span><i class="fas fa-history fa-fw post-meta-icon"></i><span class="post-meta-label">更新于</span><time class="post-meta-date-updated" datetime="2024-10-24T00:11:15.748Z" title="更新于 2024-10-24 08:11:15">2024-10-24</time></span><span class="post-meta-categories"><span class="post-meta-separator">|</span><i class="fas fa-inbox fa-fw post-meta-icon"></i><a class="post-meta-categories" href="/categories/linux-doc-%E6%96%87%E4%BB%B6%E7%B3%BB%E7%BB%9F/">linux-doc 文件系统</a></span></div><div class="meta-secondline"><span class="post-meta-separator">|</span><span class="post-meta-pv-cv" id="" data-flag-title="Linux内核文件系统挂载"><i class="far fa-eye fa-fw post-meta-icon"></i><span class="post-meta-label">阅读量:</span><span id="busuanzi_value_page_pv"><i class="fa-solid fa-spinner fa-spin"></i></span></span></div></div></div></header><main class="layout" id="content-inner"><div id="post"><article class="post-content" id="article-container"><h2 id="1、前言"><a href="#1、前言" class="headerlink" title="1、前言"></a><strong>1、前言</strong></h2><ul>
<li>环境：处理器架构：arm64内核源码：linux-5.11ubuntu版本：20.04.1代码阅读工具：vim+ctags+cscope</li>
</ul>
<blockquote>
<p>我们知道，Linux系统中我们经常将一个块设备上的文件系统挂载到某个目录下才能访问这个文件系统下的文件，但是你有没有思考过：为什么块设备挂载之后才能访问文件？挂载文件系统Linux内核到底为我们做了哪些事情？是否可以不将文件系统挂载到具体的目录下也能访问？下面，本文将详细讲解Linxu系统中，文件系统挂载的奥秘。<br>注：<strong>本文主要讲解文件系统挂载核心逻辑，暂不涉及挂载命名空间和绑定挂载等内容（后面的内容可能会涉及），且以ext2磁盘文件系统为例讲解挂载。本专题文章分为上下两篇，上篇主要介绍挂载全貌以及具体文件系统的挂载方法，下篇介绍如何通过挂载实例关联挂载点和超级块。</strong></p>
</blockquote>
<h2 id="2、vfs-几个重要对象"><a href="#2、vfs-几个重要对象" class="headerlink" title="2、vfs 几个重要对象"></a><strong>2、vfs 几个重要对象</strong></h2><blockquote>
<p>在这里我们不介绍整个IO栈，只说明和文件系统相关的vfs和具体文件系统层。我们知道在Linux中通过虚拟文件系统层VFS统一所有具体的文件系统，提取所有具体文件系统的共性，屏蔽具体文件系统的差异。VFS既是向下的接口（所有文件系统都必须实现该接口），同时也是向上的接口（用户进程通过系统调用最终能够访问文件系统功能）。<br>下面我们来看下，vfs中几个比较重要的结构体对象：</p>
</blockquote>
<h3 id="2-1file-system-type"><a href="#2-1file-system-type" class="headerlink" title="2.1file_system_type"></a><strong>2.1file_system_type</strong></h3><ul>
<li>这个结构来描述一种文件系统类型，一般具体文件系统会定义这个结构，然后注册到系统中；定义了具体文件系统的挂载和卸载方法，文件系统挂载时调用其挂载方法构建超级块、跟dentry等实例。</li>
<li>文件系统分为以下几种：</li>
</ul>
<p>1）磁盘文件系统</p>
<blockquote>
<p>文件在非易失性存储介质上(如硬盘，flash)，掉电文件不丢失。<br>如ext2,ext4,xfs</p>
</blockquote>
<p>2）内存文件系统</p>
<p>文件在内存上，掉电丢失。</p>
<p>如tmpfs</p>
<p>3）伪文件系统</p>
<p>是假的文件系统，是利用虚拟文件系统的接口（可以对用户可见如proc、sysfs,也可以对用户不可见内核可见如sockfs,bdev）。</p>
<p>如proc,sysfs,sockfs,bdev</p>
<p>4）网络文件系统</p>
<p>这种文件系统允许访问另一台计算机上的数据，该计算机通过网络连接到本地计算机。</p>
<p>如nfs文件系统</p>
<p>结构体定义源码路径：include&#x2F;linux&#x2F;fs.h +2226</p>
<h3 id="2-2super-block"><a href="#2-2super-block" class="headerlink" title="2.2super_block"></a><strong>2.2super_block</strong></h3><p>超级块，用于描述块设备上的一个文件系统总体信息（如文件块大小，最大文件大小，文件系统魔数等），一个块设备上的文件系统可以被挂载多次，但是内存中只能有个super_block来描述（至少对于磁盘文件系统来说）。</p>
<p>结构体定义源码路径：include&#x2F;linux&#x2F;fs.h +1414</p>
<h3 id="2-3mount"><a href="#2-3mount" class="headerlink" title="2.3mount"></a><strong>2.3mount</strong></h3><p>挂载描述符，用于建立超级块和挂载点等之间的联系，描述文件系统的一次挂载，一个块设备上的文件系统可以被挂载多次，每次挂载内存中有一个mount对象描述。</p>
<p>结构体定义源码路径：fs&#x2F;mount.h +39</p>
<h3 id="2-4inode"><a href="#2-4inode" class="headerlink" title="2.4inode"></a><strong>2.4inode</strong></h3><p>索引节点对象，<strong>描述磁盘上的一个文件元数据</strong>（文件属性、位置等），有些文件系统需要从块设备上读取磁盘上的索引节点,然后在内存中创建vfs的索引节点对象，一般在文件第一次打开时创建。</p>
<p>结构体定义源码路径：include&#x2F;linux&#x2F;fs.h +610</p>
<h3 id="2-5dentry"><a href="#2-5dentry" class="headerlink" title="2.5dentry"></a><strong>2.5dentry</strong></h3><p>目录项对象，用于<strong>描述文件的层次结构</strong>，从而构建文件系统的目录树，文件系统将目录当作文件，目录的数据由目录项组成，而每个目录项存储一个目录或文件的名称和索引节点号等内容。每当进程访问一个目录项就会在内存中创建目录项对象（如ext2路径名查找中，通过查找父目录数据块的目录项，找到对应文件&#x2F;目录的名称，获得inode号来找到对应inode）。</p>
<p>结构体定义源码路径：include&#x2F;linux&#x2F;dcache.h +90</p>
<h3 id="2-6file"><a href="#2-6file" class="headerlink" title="2.6file"></a><strong>2.6file</strong></h3><p>文件对象，描述进程打开的文件，当进程打开文件时会创建文件对象加入到进程的文件打开表，通过文件描述符来索引文件对象，后面读写等操作都通过文件描述符进行（一个文件可以被多个进程打开，会由多个文件对象加入到各个进程的文件打开表，但是inode只有一个）。</p>
<p>结构体定义源码路径：include&#x2F;linux&#x2F;fs.h +915</p>
<h2 id="3、挂载总体流程"><a href="#3、挂载总体流程" class="headerlink" title="3、挂载总体流程"></a><strong>3、挂载总体流程</strong></h2><h3 id="3-1系统调用处理"><a href="#3-1系统调用处理" class="headerlink" title="3.1系统调用处理"></a><strong>3.1系统调用处理</strong></h3><blockquote>
<p>用户执行挂载是通过系统调用路径进入内核处理，拷贝用户空间传递参数到内核，挂载委托do_mount。<br>&#x2F;&#x2F;fs&#x2F;namespace.c<br>SYSCALL_DEFINE5(mount</p>
</blockquote>
<p>参数：</p>
<figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">dev_name 要挂载的块设备</span><br><span class="line">dir_name 挂载点目录</span><br><span class="line">type 文件系统类型名</span><br><span class="line">flags 挂载标志</span><br><span class="line">data 挂载选项</span><br><span class="line">-&gt; kernel_type = copy_mount_string(type); //拷贝文件系统类型名到内核空间</span><br><span class="line">-&gt; kernel_dev = copy_mount_string(dev_name) //拷贝块设备路径名到内核空间</span><br><span class="line">-&gt; options = copy_mount_options(data) //拷贝挂载选项到内核空间</span><br><span class="line">-&gt; do_mount(kernel_dev, dir_name, kernel_type, flags, options) //挂载委托do_mount</span><br></pre></td></tr></table></figure>

<h3 id="3-2挂载点路径查找"><a href="#3-2挂载点路径查找" class="headerlink" title="3.2挂载点路径查找"></a><strong>3.2挂载点路径查找</strong></h3><figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">挂载点路径查找，挂载委托path_mount</span><br><span class="line">do_mount</span><br><span class="line">-&gt; user_path_at(AT_FDCWD, dir_name, LOOKUP_FOLLOW, &amp;path) //挂载点路径查找 查找挂载点目录的 vfsmount和dentry 存放在 path</span><br><span class="line">-&gt; path_mount(dev_name, &amp;path, type_page, flags, data_page) //挂载委托path_mount</span><br></pre></td></tr></table></figure>

<h3 id="3-3参数合法性检查"><a href="#3-3参数合法性检查" class="headerlink" title="3.3参数合法性检查"></a><strong>3.3参数合法性检查</strong></h3><blockquote>
<p>参数合法性检查， 新挂载委托do_new_mount<br>path_mount<br>-&gt; 参数合法性检查<br>-&gt; 根据挂载标志调用不同函数处理 这里讲解是默认 do_new_mount</p>
</blockquote>
<h3 id="3-4调用具体文件系统挂载方法"><a href="#3-4调用具体文件系统挂载方法" class="headerlink" title="3.4调用具体文件系统挂载方法"></a><strong>3.4调用具体文件系统挂载方法</strong></h3><figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">do_new_mount</span><br><span class="line">-&gt; type = get_fs_type(fstype)  //根据传递的文件系统名  查找已经注册的文件系统类型</span><br><span class="line">-&gt; fc = fs_context_for_mount(type, sb_flags) //为挂载分配文件系统上下文 struct fs_context</span><br><span class="line"> -&gt; alloc_fs_context</span><br><span class="line">   -&gt; 分配fs_context fc = kzalloc(sizeof(struct fs_context), GFP_KERNEL)</span><br><span class="line">   -&gt;  设置 ... </span><br><span class="line">   -&gt;  fc-&gt;fs_type     = get_filesystem(fs_type);  //赋值相应的文件系统类型</span><br><span class="line">   -&gt;  init_fs_context = **fc-&gt;fs_type-&gt;init_fs_context**;  //新内核使用fs_type-&gt;init_fs_context接口  来初始化文件系统上下文</span><br><span class="line">    if (!init_fs_context)   //init_fs_context回掉 主要用于初始化</span><br><span class="line">        init_fs_context = **legacy_init_fs_context**;    //没有 fs_type-&gt;init_fs_context接口 </span><br><span class="line">   -&gt; init_fs_context(fc)  //初始化文件系统上下文 (初始化一些回掉函数，供后续使用)</span><br></pre></td></tr></table></figure>

<p>来看下文件系统类型没有实现init_fs_context接口的情况：</p>
<figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">//fs/fs_context.c</span><br><span class="line">init_fs_context = legacy_init_fs_context</span><br><span class="line">-&gt;  fc-&gt;ops = &amp;legacy_fs_context_ops   //设置文件系统上下午操作</span><br><span class="line">                    -&gt;.get_tree               = legacy_get_tree  //操作方法的get_tree用于  读取磁盘超级块并在内存创建超级块，创建跟inode， 跟dentry</span><br><span class="line">                        -&gt; root = fc-&gt;fs_type-&gt;mount(fc-&gt;fs_type, fc-&gt;sb_flags,</span><br><span class="line">                                         ¦     fc-&gt;source, ctx-&gt;legacy_data)  //调用文件系统类型的mount方法来读取并创建超级块</span><br><span class="line">                        -&gt; fc-&gt;root = root  //赋值创建好的跟dentry</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">有一些文件系统使用原来的接口(fs_type.mount  = xxx_mount)：如ext2,ext4等</span><br><span class="line">有一些文件系统使用新的接口(fs_type.init_fs_context =  xxx_init_fs_context)：xfs， proc， sys</span><br><span class="line"></span><br><span class="line">无论使用哪一种，都会在xxx_init_fs_contex中实现 fc-&gt;ops =  &amp;xxx_context_ops 接口，后面会看的都会调用fc-&gt;ops.get_tree 来读取创建超级块实例</span><br></pre></td></tr></table></figure>

<ul>
<li>继续往下走：</li>
</ul>
<figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">do_new_mount</span><br><span class="line">    -&gt; ...</span><br><span class="line">    -&gt;  fc = fs_context_for_mount(type, sb_flags) //分配 赋值文件系统上下文</span><br><span class="line">    -&gt; parse_monolithic_mount_data(fc, data)  //调用fc-&gt;ops-&gt;parse_monolithic  解析挂载选项</span><br><span class="line">    -&gt; mount_capable(fc) //检查是否有挂载权限</span><br><span class="line">    -&gt; vfs_get_tree(fc)  //fs/super.c 挂载重点   调用fc-&gt;ops-&gt;get_tree(fc) 读取创建超级块实例</span><br><span class="line">    ...</span><br></pre></td></tr></table></figure>

<h3 id="3-5挂载实例添加到全局文件系统树"><a href="#3-5挂载实例添加到全局文件系统树" class="headerlink" title="3.5挂载实例添加到全局文件系统树"></a><strong>3.5挂载实例添加到全局文件系统树</strong></h3><figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">do_new_mount</span><br><span class="line">    ...</span><br><span class="line">    -&gt;  do_new_mount_fc(fc, path, mnt_flags)  //创建mount实例 关联挂载点和超级块  添加到命名空间的挂载树中</span><br></pre></td></tr></table></figure>

<p>下面主要看下vfs_get_tree和do_new_mount_fc：</p>
<h2 id="4、具体文件系统挂载方法"><a href="#4、具体文件系统挂载方法" class="headerlink" title="4、具体文件系统挂载方法"></a><strong>4、具体文件系统挂载方法</strong></h2><h3 id="4-1vfs-get-tree"><a href="#4-1vfs-get-tree" class="headerlink" title="4.1vfs_get_tree"></a><strong>4.1vfs_get_tree</strong></h3><figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">//以ext2文件系统为例</span><br><span class="line">vfs_get_tree  //fs/namespace.c</span><br><span class="line">-&gt; fc-&gt;ops-&gt;get_tree(fc)</span><br><span class="line"> -&gt; legacy_get_tree   //上面分析过 fs_type-&gt;init_fs_context == NULL使用旧的接口(ext2为NULL)</span><br><span class="line">  -&gt;fc-&gt;fs_type-&gt;mount</span><br><span class="line">   -&gt; ext2_mount  //fs/ext2/super.c  调用到具体文件系统的挂载方法</span><br></pre></td></tr></table></figure>

<p>来看下ext2对挂载的处理：</p>
<p>启动阶段初始化-&gt;</p>
<figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">//fs/ext2/super.c</span><br><span class="line">module_init(init_ext2_fs)</span><br><span class="line">init_ext2_fs</span><br><span class="line"> -&gt;init_inodecache  //创建ext2_inode_cache 对象缓存</span><br><span class="line"> -&gt;register_filesystem(&amp;ext2_fs_type) //注册ext2的文件系统类型</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">static struct file_system_type ext2_fs_type = &#123;</span><br><span class="line">        .owner          = THIS_MODULE,</span><br><span class="line">        .name           = &quot;ext2&quot;,</span><br><span class="line">        .mount          = ext2_mount,   //挂载时调用  用于读取创建超级块实例</span><br><span class="line">        .kill_sb        = kill_block_super,  //卸载时调用  用于释放超级块</span><br><span class="line">        .fs_flags       = FS_REQUIRES_DEV,  //文件系统标志为  请求块设备，文件系统在块设备上</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>挂载时调用-&gt;</p>
<figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">// fs/ext2/super.c</span><br><span class="line">static struct dentry *ext2_mount(struct file_system_type *fs_type,           </span><br><span class="line">        int flags, const char *dev_name, void *data)</span><br><span class="line">&#123;</span><br><span class="line">        return mount_bdev(fs_type, flags, dev_name, data, ext2_fill_super);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>ext2_mount通过调用mount_bdev来执行实际文件系统的挂载工作，<strong>ext2_fill_super</strong>的一个函数指针作为参数传递给<strong>get_sb_bdev</strong>。该函数用于填充一个超级块对象，如果内存中没有适当的超级块对象，数据就必须从硬盘读取。</p>
<p>mount_bdev是个公用的函数，一般磁盘文件系统会使用它来根据具体文件系统的fill_super方法来读取磁盘上的超级块并在创建内存超级块。</p>
<p>我们来看下mount_bdev的实现（**它执行完成之后会创建vfs的三大数据结构 super_block、根inode和根dentry **）：</p>
<h3 id="4-2mount-bdev源码分析"><a href="#4-2mount-bdev源码分析" class="headerlink" title="4.2mount_bdev源码分析"></a><strong>4.2mount_bdev源码分析</strong></h3><figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">//fs/super.c</span><br><span class="line">mount_bdev</span><br><span class="line">-&gt;bdev = blkdev_get_by_path(dev_name, mode, fs_type)  //通过要挂载的块设备路径名 获得它的块设备描述符block_device（会涉及到路径名查找和通过设备号在bdev文件系统查找block_device，block_device是添加块设备到系统时创建的）</span><br><span class="line">-&gt; s = sget(fs_type, test_bdev_super, set_bdev_super, flags | SB_NOSEC,   </span><br><span class="line">         ¦bdev);  //查找或创建vfs的超级块  （会首先在文件系统类型的fs_supers链表查找是否已经读取过指定的超级块，会对比每个超级块的s_bdev块设备描述符，没有创建一个）</span><br><span class="line">-&gt;  if (s-&gt;s_root) &#123;   //超级块的根dentry是否被赋值？</span><br><span class="line">  ...</span><br><span class="line"> &#125; else &#123;   //没有赋值说明时新创建的sb</span><br><span class="line">  ...</span><br><span class="line">  -&gt; sb_set_blocksize(s, block_size(bdev)) //根据块设备描述符设置文件系统块大小</span><br><span class="line">  -&gt;  fill_super(s, data, flags &amp; SB_SILENT ? 1 : 0)  //调用传递的具体文件系统的填充超级块方法读取填充超级块等 如ext2_fill_super</span><br><span class="line">  -&gt;  bdev-&gt;bd_super = s  //块设备bd_super指向sb</span><br><span class="line"> &#125;</span><br><span class="line">-&gt; return dget(s-&gt;s_root)  //返回文件系统的根dentry</span><br></pre></td></tr></table></figure>

<p>可以看到mount_bdev主要是：</p>
<p>1.<strong>根据要挂载的块设备文件名查找到对应的块设备描述符（内核后面操作块设备都是使用块设备描述符）；</strong></p>
<p><strong>2.首先在文件系统类型的fs_supers链表查找是否已经读取过指定的vfs超级块，会对比每个超级块的s_bdev块设备描述符，没有创建一个vfs超级块;</strong></p>
<p><strong>3.新创建的vfs超级块，需要调用具体文件系统的fill_super方法来读取填充超级块。</strong></p>
<p>那么下面主要集中在具体文件系统的fill_super方法，这里是ext2_fill_super：</p>
<p>分析重点代码如下：</p>
<h3 id="4-3ext2-fill-super源码分析"><a href="#4-3ext2-fill-super源码分析" class="headerlink" title="4.3ext2_fill_super源码分析"></a><strong>4.3ext2_fill_super源码分析</strong></h3><figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br></pre></td><td class="code"><pre><span class="line">//fs/ext2/super.c</span><br><span class="line">static int ext2_fill_super(struct super_block *sb, void *data, int silent)               </span><br><span class="line">&#123;                                                                                                          </span><br><span class="line">        struct buffer_head * bh;    //缓冲区头  记录读取的磁盘超级块                                                     </span><br><span class="line">        struct ext2_sb_info * sbi;   //内存的ext2 超级块信息                                                    </span><br><span class="line">        struct ext2_super_block * es;  //磁盘上的  超级块信息                                               </span><br><span class="line">           ...</span><br><span class="line">                                                        </span><br><span class="line">        sbi = kzalloc(sizeof(*sbi), GFP_KERNEL);     //分配 内存的ext2 超级块信息结构                                   </span><br><span class="line">        if (!sbi)                                                                        </span><br><span class="line">                goto failed;                                                             </span><br><span class="line">                                                                                         </span><br><span class="line">         ...                                                  </span><br><span class="line">        sb-&gt;s_fs_info = sbi;     //vfs的超级块 的s_fs_info指向内存的ext2 超级块信息结构                                                   </span><br><span class="line">        sbi-&gt;s_sb_block = sb_block;                                                      </span><br><span class="line">                                                       </span><br><span class="line">      if (!(bh = sb_bread(sb, logic_sb_block))) &#123;  // 读取磁盘上的超级块到内存的 使用buffer_head关联内存缓冲区和磁盘扇区                                   </span><br><span class="line">              ext2_msg(sb, KERN_ERR, &quot;error: unable to read superblock&quot;);                 </span><br><span class="line">              goto failed_sbi;                                                            </span><br><span class="line">      &#125;                                                                                   </span><br><span class="line">                   </span><br><span class="line">      es = (struct ext2_super_block *) (((char *)bh-&gt;b_data) + offset);  //转换为struct ext2_super_block 结构                 </span><br><span class="line">      sbi-&gt;s_es = es; //  内存的ext2 超级块信息结构的 s_es指向真正的ext2磁盘超级块信息结构                                                                 </span><br><span class="line">      sb-&gt;s_magic = le16_to_cpu(es-&gt;s_magic); //获得文件系统魔数   ext2为0xEF53                                        </span><br><span class="line">                                                                                          </span><br><span class="line">      if (sb-&gt;s_magic != EXT2_SUPER_MAGIC)    //验证 魔数是否正确                                           </span><br><span class="line">              goto cantfind_ext2;</span><br><span class="line"></span><br><span class="line">    blocksize = BLOCK_SIZE &lt;&lt; le32_to_cpu(sbi-&gt;s_es-&gt;s_log_block_size); //获得磁盘读取的块大小   </span><br><span class="line"></span><br><span class="line">                                                                                          </span><br><span class="line">        /* If the blocksize doesn&#x27;t match, re-read the thing.. */                         </span><br><span class="line">        if (sb-&gt;s_blocksize != blocksize) &#123;  //块大小不匹配 需要重新读取超级块                                              </span><br><span class="line">                brelse(bh);                                                               </span><br><span class="line">                                                                                          </span><br><span class="line">                if (!sb_set_blocksize(sb, blocksize)) &#123;                                   </span><br><span class="line">                        ext2_msg(sb, KERN_ERR,                                            </span><br><span class="line">                                &quot;error: bad blocksize %d&quot;, blocksize);                    </span><br><span class="line">                        goto failed_sbi;                                                  </span><br><span class="line">                &#125;                                                                         </span><br><span class="line">                                                                                          </span><br><span class="line">                logic_sb_block = (sb_block*BLOCK_SIZE) / blocksize;                       </span><br><span class="line">                offset = (sb_block*BLOCK_SIZE) % blocksize;                               </span><br><span class="line">                bh = sb_bread(sb, logic_sb_block); //重新 读取超级块                                       </span><br><span class="line">                if(!bh) &#123;                                                                 </span><br><span class="line">                        ext2_msg(sb, KERN_ERR, &quot;error: couldn&#x27;t read&quot;                     </span><br><span class="line">                                &quot;superblock on 2nd try&quot;);                                 </span><br><span class="line">                        goto failed_sbi;                                                  </span><br><span class="line">                &#125;                                                                         </span><br><span class="line">                es = (struct ext2_super_block *) (((char *)bh-&gt;b_data) + offset);         </span><br><span class="line">                sbi-&gt;s_es = es;                                                           </span><br><span class="line">                if (es-&gt;s_magic != cpu_to_le16(EXT2_SUPER_MAGIC)) &#123;                       </span><br><span class="line">                        ext2_msg(sb, KERN_ERR, &quot;error: magic mismatch&quot;);                  </span><br><span class="line">                        goto failed_mount;                                                </span><br><span class="line">                &#125;                                                                         </span><br><span class="line">        &#125;                                                                                 </span><br><span class="line">                                                                                          </span><br><span class="line">        sb-&gt;s_maxbytes = ext2_max_size(sb-&gt;s_blocksize_bits);  //设置最大文件大小                            </span><br><span class="line">        ...                                                           </span><br><span class="line">       </span><br><span class="line">       //读取或设置 inode大小和第一个inode号                                                                        </span><br><span class="line">       if (le32_to_cpu(es-&gt;s_rev_level) == EXT2_GOOD_OLD_REV) &#123;                   </span><br><span class="line">               sbi-&gt;s_inode_size = EXT2_GOOD_OLD_INODE_SIZE;                      </span><br><span class="line">               sbi-&gt;s_first_ino = EXT2_GOOD_OLD_FIRST_INO;                        </span><br><span class="line">       &#125; else &#123;                                                                   </span><br><span class="line">               sbi-&gt;s_inode_size = le16_to_cpu(es-&gt;s_inode_size);                 </span><br><span class="line">               sbi-&gt;s_first_ino = le32_to_cpu(es-&gt;s_first_ino);                   </span><br><span class="line">              ...                          </span><br><span class="line">       &#125;                                                                          </span><br><span class="line">                                                                                  </span><br><span class="line">      ...             </span><br><span class="line">                                                                                  </span><br><span class="line">       sbi-&gt;s_blocks_per_group = le32_to_cpu(es-&gt;s_blocks_per_group);    //赋值每个块组 块个数          </span><br><span class="line">       sbi-&gt;s_frags_per_group = le32_to_cpu(es-&gt;s_frags_per_group);               </span><br><span class="line">       sbi-&gt;s_inodes_per_group = le32_to_cpu(es-&gt;s_inodes_per_group);  //赋值每个块组 inode个数             </span><br><span class="line">                                                                                  </span><br><span class="line">       sbi-&gt;s_inodes_per_block = sb-&gt;s_blocksize / EXT2_INODE_SIZE(sb);    //赋值每个块 inode个数       </span><br><span class="line">       ...                     </span><br><span class="line">       sbi-&gt;s_desc_per_block = sb-&gt;s_blocksize /                                  </span><br><span class="line">                                       sizeof (struct ext2_group_desc);    //赋值每个块 块组描述符个数     </span><br><span class="line">       sbi-&gt;s_sbh = bh;  //赋值读取的超级块缓冲区                                                          </span><br><span class="line">       sbi-&gt;s_mount_state = le16_to_cpu(es-&gt;s_state);    //赋值挂载状态                           </span><br><span class="line">     ...                                   </span><br><span class="line">                                                                               </span><br><span class="line">    if (sb-&gt;s_magic != EXT2_SUPER_MAGIC)                                       </span><br><span class="line">            goto cantfind_ext2;                                                </span><br><span class="line">   </span><br><span class="line">   //一些合法性检查</span><br><span class="line">     ...    </span><br><span class="line">    </span><br><span class="line">  //计算块组描述符 个数</span><br><span class="line">  sbi-&gt;s_groups_count = ((le32_to_cpu(es-&gt;s_blocks_count) -               </span><br><span class="line">                          le32_to_cpu(es-&gt;s_first_data_block) - 1)        </span><br><span class="line">                                  / EXT2_BLOCKS_PER_GROUP(sb)) + 1;       </span><br><span class="line">  db_count = (sbi-&gt;s_groups_count + EXT2_DESC_PER_BLOCK(sb) - 1) /        </span><br><span class="line">          ¦  EXT2_DESC_PER_BLOCK(sb);                                     </span><br><span class="line">  sbi-&gt;s_group_desc = kmalloc_array(db_count,                             </span><br><span class="line">                                  ¦  sizeof(struct buffer_head *),        </span><br><span class="line">                                  ¦  GFP_KERNEL);  //分配块组描述符 bh数组                       </span><br><span class="line">   </span><br><span class="line">    </span><br><span class="line">    for (i = 0; i &lt; db_count; i++) &#123;      //读取块组描述符                                 </span><br><span class="line">          block = descriptor_loc(sb, logic_sb_block, i);                </span><br><span class="line">          sbi-&gt;s_group_desc[i] = sb_bread(sb, block);   //读取的 块组描述符缓冲区保存 到sbi-&gt;s_group_desc[i]              </span><br><span class="line">          if (!sbi-&gt;s_group_desc[i]) &#123;                                  </span><br><span class="line">                  for (j = 0; j &lt; i; j++)                               </span><br><span class="line">                          brelse (sbi-&gt;s_group_desc[j]);                </span><br><span class="line">                  ext2_msg(sb, KERN_ERR,                                </span><br><span class="line">                          &quot;error: unable to read group descriptors&quot;);   </span><br><span class="line">                  goto failed_mount_group_desc;                         </span><br><span class="line">          &#125;                                                             </span><br><span class="line">  &#125;                                                                     </span><br><span class="line"></span><br><span class="line">                                                                    </span><br><span class="line">  sb-&gt;s_op = &amp;ext2_sops;   //赋值超级块操作</span><br><span class="line">  ...</span><br><span class="line"> root = ext2_iget(sb, EXT2_ROOT_INO); //读取根inode  （ext2 根根inode号为2） </span><br><span class="line"></span><br><span class="line"> sb-&gt;s_root = d_make_root(root);  //创建根dentry  并建立根inode和根dentry关系</span><br><span class="line"> ext2_write_super(sb);  //同步超级块信息到磁盘 如挂载时间等</span><br></pre></td></tr></table></figure>

<p>可以看到ext2_fill_super主要工作为：</p>
<p><strong>1.读取磁盘上的超级块；</strong></p>
<p><strong>2.填充并关联vfs超级块；</strong></p>
<p><strong>3.读取块组描述符；</strong></p>
<p><strong>4.读取磁盘根inode并建立vfs 根inode;</strong></p>
<p><strong>5.创建根dentry关联到根inode</strong>。</p>
<p><strong>下面给出ext2_fill_super之后ext2相关图解：</strong></p>
<p><img src="https://pic2.zhimg.com/80/v2-464f0a179a76ef8ee3283bced520126d_720w.webp" alt="img"></p>
<p>有了这些信息，虽然能够获得块设备上的文件系统全貌，内核也能通过已经建立好的block_device等结构访问块设备，但是用户进程不能真正意义上访问到，用户一般会通过open打开一个文件路径来访问文件，但是现在并没有关联挂载目录的路径，需要将文件系统关联到挂载点，以至于路径名查找的时候查找到挂载点后，在转向文件系统的根目录，而这需要通过do_new_mount_fc来去关联并加入全局的文件系统树中,下一篇我们将做详细讲解。<strong>4、添加到全局文件系统树</strong></p>
<h3 id="4-1do-new-mount-fc"><a href="#4-1do-new-mount-fc" class="headerlink" title="4.1do_new_mount_fc"></a><strong>4.1do_new_mount_fc</strong></h3><figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">do_new_mount  //fs/namespace.c</span><br><span class="line">-&gt;do_new_mount_fc</span><br><span class="line"> -&gt;     struct vfsmount *mnt;                      </span><br><span class="line">    -&gt;   struct mountpoint *mp;                     </span><br><span class="line"> -&gt;  struct super_block *sb = fc-&gt;root-&gt;d_sb;  //获得vfs的超级块 （之前已经构建好）</span><br><span class="line"> &gt;  mnt = vfs_create_mount(fc);   //为一个已配置的超级块 分配mount实例</span><br><span class="line">    -&gt;    mp = lock_mount(mountpoint);  //寻找挂载点 如果挂载目录是挂载点（已经有文件系统挂载其上），则将最后一次挂载的文件系统根目录作为挂载点    </span><br><span class="line"> -&gt;  do_add_mount(real_mount(mnt), mp, mountpoint, mnt_flags);  //关联挂载点 加入全局文件系统树</span><br></pre></td></tr></table></figure>

<h3 id="4-2vfs-create-mount源码分析"><a href="#4-2vfs-create-mount源码分析" class="headerlink" title="4.2vfs_create_mount源码分析"></a><strong>4.2vfs_create_mount源码分析</strong></h3><figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">vfs_create_mount</span><br><span class="line">    -&gt;     mnt = alloc_vfsmnt(fc-&gt;source ?: &quot;none&quot;);  //分配mount实例 </span><br><span class="line">    -&gt;     mnt-&gt;mnt.mnt_sb         = fc-&gt;root-&gt;d_sb;  //mount关联超级块 (使用vfsmount关联)</span><br><span class="line">    -&gt;    mnt-&gt;mnt.mnt_root       = dget(fc-&gt;root);   //mount关联根dentry (使用vfsmount关联)</span><br><span class="line">    -&gt;    mnt-&gt;mnt_mountpoint     = mnt-&gt;mnt.mnt_root; // mount关联挂载点 （临时指向根dentry，后面会指向真正的挂载点，以至于对用户可见）</span><br><span class="line">    -&gt;  mnt-&gt;mnt_parent         = mnt;  //父挂载指向自己 (临时指向 后面会设置)              </span><br><span class="line">    -&gt;     return &amp;mnt-&gt;mnt;  //返回内嵌的vfsmount</span><br></pre></td></tr></table></figure>

<ul>
<li>注：老内核使用的是vfsmount来描述文件系统的一次挂载，现在内核都使用mount来描述，而vfsmount被内嵌到mount中，主要来描述文件系统的超级块和跟dentry。</li>
</ul>
<h4 id="4-2-1vfs-create-mount之后vfs对象数据结构之间关系图如下："><a href="#4-2-1vfs-create-mount之后vfs对象数据结构之间关系图如下：" class="headerlink" title="4.2.1vfs_create_mount之后vfs对象数据结构之间关系图如下："></a>4.2.1vfs_create_mount之后vfs对象数据结构之间关系图如下：</h4><p><img src="https://pic1.zhimg.com/80/v2-eb423661d85acf15649569f9c4e0d804_720w.webp" alt="img"></p>
<h3 id="4-3lock-mount源码分析"><a href="#4-3lock-mount源码分析" class="headerlink" title="4.3lock_mount源码分析"></a><strong>4.3lock_mount源码分析</strong></h3><p>lock_mount是最不好理解的函数，下面详细讲解：</p>
<p>-&gt; mp &#x3D; lock_mount(mountpoint);</p>
<p>&#x2F;&#x2F;不只是加锁， 通过传来的 挂载点的 path（vfsmout, dentry二元组)，来查找最后一次挂载的文件系统的根dentry作为即将挂载文件系统的挂载点</p>
<p>我们看下这个函数</p>
<p>-&gt; 这个函数主要从挂载点的path(即是挂载目录的path结构，如挂载到&#x2F;mnt下, path为mnt的path) 来找到真正的挂载点 两种情况：</p>
<p>1.如果挂载点的path 是正常的目录，原来不是挂载点，则直接返回这个目录的dentry作为挂载点（mountpoint的m_dentry会指向挂载点的dentry）</p>
<p>2.如果挂载点的path不是正常的目录，原来就是挂载点，说明这个目录已经有其他的文件系统挂载，那么它会查找最后一个挂载到这个目录的文件系统的根dentry,作为真正的挂载点。</p>
<p>我们打开这个黑匣子看一下：首先传递来的path 是一个表示要解析的挂载目录[vfsmount,dentry]二元组，如我们要挂载到 &#x2F;mnt （path即为&lt;mnt所在文件系统的vfsmount, mnt的dentry&gt;）</p>
<figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br></pre></td><td class="code"><pre><span class="line">//include/linux/path.h  描述一个路径</span><br><span class="line">struct path &#123; </span><br><span class="line">        struct vfsmount *mnt;</span><br><span class="line">        struct dentry *dentry;</span><br><span class="line">&#125; __randomize_layout;</span><br><span class="line"></span><br><span class="line"> //fs/mount.h       描述一个挂载点</span><br><span class="line">struct mountpoint &#123;       </span><br><span class="line">        struct hlist_node m_hash; </span><br><span class="line">        struct dentry *m_dentry;  </span><br><span class="line">        struct hlist_head m_list; </span><br><span class="line">        int m_count;              </span><br><span class="line">&#125;;                                </span><br><span class="line"></span><br><span class="line"></span><br><span class="line">static struct mountpoint *lock_mount(struct path *path)           </span><br><span class="line">&#123;                                                                 </span><br><span class="line">        struct vfsmount *mnt;                                     </span><br><span class="line">        struct dentry *dentry = path-&gt;dentry; //获得挂载目录的dentry                     </span><br><span class="line">retry:                                                            </span><br><span class="line">        inode_lock(dentry-&gt;d_inode);     //写方式申请 inode的读写信号量                        </span><br><span class="line">        if (unlikely(cant_mount(dentry))) &#123; //判断挂载目录能否被挂载</span><br><span class="line">                inode_unlock(dentry-&gt;d_inode);                    </span><br><span class="line">                return ERR_PTR(-ENOENT);                          </span><br><span class="line">        &#125;                                                         </span><br><span class="line">        namespace_lock();  //写方式申请 命名空间读写信号量                                      </span><br><span class="line">        mnt = lookup_mnt(path); //查找挂载在path上的第一个子mount    //！！！重点函数，后面分析 ！！！                               </span><br><span class="line">        if (likely(!mnt)) &#123; // mnt为空 说明没有文件系统挂载在这个path上  是我们要找的目标 </span><br><span class="line">    </span><br><span class="line">    //1.如果dentry之前是挂载点 则从mountpoint hash表 查找mountpoint （dentry计算hash）</span><br><span class="line">    // 2. 如果dentry之前不是挂载点 分配mountpoint 加入mountpoint hash表（dentry计算hash）,设置dentry为挂载点</span><br><span class="line">                struct mountpoint *mp = get_mountpoint(dentry); //！！！重点函数,后面会分析 ！！！</span><br><span class="line">      </span><br><span class="line">                if (IS_ERR(mp)) &#123;                                 </span><br><span class="line">                        namespace_unlock();                       </span><br><span class="line">                        inode_unlock(dentry-&gt;d_inode);            </span><br><span class="line">                        return mp;                                </span><br><span class="line">                &#125;                                                 </span><br><span class="line">                return mp; //返回找到的挂载点实例 （这个挂载点的dentry之前没有被挂载）                                      </span><br><span class="line">        &#125;</span><br><span class="line">        namespace_unlock(); //释放命名空间读写信号量</span><br><span class="line">        inode_unlock(path-&gt;dentry-&gt;d_inode); //释放 inode的读写信号量 </span><br><span class="line">        path_put(path);</span><br><span class="line">        path-&gt;mnt = mnt; // path-&gt;mnt指向找到的vfsmount                                          </span><br><span class="line">        dentry = path-&gt;dentry = dget(mnt-&gt;mnt_root); //path-&gt;dentry指向找到的vfsmount的根dentry！</span><br><span class="line">        goto retry; //继续查找下一个挂载</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="4-3-1get-mountpoint源码分析"><a href="#4-3-1get-mountpoint源码分析" class="headerlink" title="4.3.1get_mountpoint源码分析"></a><strong>4.3.1get_mountpoint源码分析</strong></h4><figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br></pre></td><td class="code"><pre><span class="line">static struct mountpoint *get_mountpoint(struct dentry *dentry)                      </span><br><span class="line">&#123;                                                                                    </span><br><span class="line">        struct mountpoint *mp, *new = NULL;                                          </span><br><span class="line">        int ret;                                                                     </span><br><span class="line">                                                                                     </span><br><span class="line">        if (d_mountpoint(dentry)) &#123;  //dentry为挂载点 （当dentry为挂载点时 会设置dentry-&gt;d_flags 的DCACHE_MOUNTED标志）                                                </span><br><span class="line">                /* might be worth a WARN_ON() */                                     </span><br><span class="line">                if (d_unlinked(dentry))                                              </span><br><span class="line">                        return ERR_PTR(-ENOENT);                                     </span><br><span class="line">mountpoint:                                                                          </span><br><span class="line">                read_seqlock_excl(&amp;mount_lock);                                      </span><br><span class="line">                mp = lookup_mountpoint(dentry); // 从mountpoint hash表 查找mountpoint （dentry计算hash）                                    </span><br><span class="line">                read_sequnlock_excl(&amp;mount_lock);                                    </span><br><span class="line">                if (mp)                                                              </span><br><span class="line">                        goto done;  //找到直接返回mountpoint实例                                               </span><br><span class="line">        &#125;                                                                            </span><br><span class="line">                                                                                     </span><br><span class="line">        if (!new)    //mountpoint哈希表中没有找到    则分配                                                             </span><br><span class="line">                new = kmalloc(sizeof(struct mountpoint), GFP_KERNEL);             </span><br><span class="line">        if (!new)                                                                    </span><br><span class="line">                return ERR_PTR(-ENOMEM);                                             </span><br><span class="line">                                                                                     </span><br><span class="line">                                                                                     </span><br><span class="line">        /* Exactly one processes may set d_mounted */                                </span><br><span class="line">        ret = d_set_mounted(dentry);   //设置dentry为挂载点</span><br><span class="line">   -&gt;dentry-&gt;d_flags |= DCACHE_MOUNTED;  //设置挂载点标志很重要  路径名查找时发现为挂载点则会步进到相关文件系统的跟dentry</span><br><span class="line">                                                                                     </span><br><span class="line">        /* Someone else set d_mounted? */                                            </span><br><span class="line">        if (ret == -EBUSY)                                                           </span><br><span class="line">                goto mountpoint;                                                     </span><br><span class="line">                                                                                     </span><br><span class="line">        /* The dentry is not available as a mountpoint? */                           </span><br><span class="line">        mp = ERR_PTR(ret);                                                           </span><br><span class="line">        if (ret)                                                                     </span><br><span class="line">                goto done;                                                           </span><br><span class="line">                                                              </span><br><span class="line">        /* Add the new mountpoint to the hash table */        </span><br><span class="line">        read_seqlock_excl(&amp;mount_lock);                       </span><br><span class="line">        new-&gt;m_dentry = dget(dentry);  //设置mountpoint实例  的m_dentry 指向dentry                       </span><br><span class="line">        new-&gt;m_count = 1;                                      </span><br><span class="line">        hlist_add_head(&amp;new-&gt;m_hash, mp_hash(dentry));   // mountpoint实例添加到 mountpoint_hashtable     </span><br><span class="line">        INIT_HLIST_HEAD(&amp;new-&gt;m_list);  //初始化 挂载链表   mount实例会加入到这个链表                      </span><br><span class="line">        read_sequnlock_excl(&amp;mount_lock);                     </span><br><span class="line">                                                              </span><br><span class="line">        mp = new;   //指向挂载点                                          </span><br><span class="line">        new = NULL;                                           </span><br><span class="line">done:                                                         </span><br><span class="line">        kfree(new);                                           </span><br><span class="line">        return mp;  //返回挂载点                                           </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="4-3-2lookup-mnt源码分析"><a href="#4-3-2lookup-mnt源码分析" class="headerlink" title="4.3.2lookup_mnt源码分析"></a><strong>4.3.2lookup_mnt源码分析</strong></h4><p>它在文件系统挂载和路径名查找都会使用到，作用为查找挂载在这个path下的第一个子vfsmount实例。</p>
<p>-&gt;文件系统挂载场景中，使用它查找合适的vfsmount实例作为父vfsmount。</p>
<p>-&gt;路径名查找场景中，使用它查找一个合适的vfsmount实例作为下一级路径名解析起点的vfsmount。</p>
<figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">//fs/namespace.c</span><br><span class="line">lookup_mnt(const struct path *path)</span><br><span class="line">-&gt;  struct mount *child_mnt;</span><br><span class="line"> struct vfsmount *m;     </span><br><span class="line"> child_mnt = __lookup_mnt(path-&gt;mnt, path-&gt;dentry);  //委托__lookup_mnt</span><br><span class="line"> m = child_mnt ? &amp;child_mnt-&gt;mnt : NULL; //返回mount实例的vfsmount实例 或NULL            </span><br><span class="line"> return m;</span><br><span class="line"></span><br><span class="line">-&gt;</span><br><span class="line">struct mount *__lookup_mnt(struct vfsmount *mnt, struct dentry *dentry)        </span><br><span class="line">&#123;               </span><br><span class="line">        struct hlist_head *head = m_hash(mnt, dentry);  // 根据 父vfsmount实例 和 挂载点的dentry查找  mount_hashtable的一个哈希表项</span><br><span class="line">        struct mount *p;</span><br><span class="line">        </span><br><span class="line">        hlist_for_each_entry_rcu(p, head, mnt_hash)  //从哈希表项对应的链表中查找   遍历链表的每个节点</span><br><span class="line">                if (&amp;p-&gt;mnt_parent-&gt;mnt == mnt &amp;&amp; p-&gt;mnt_mountpoint == dentry) //节点的mount实例的父mount为mnt 且mount实例的挂载点为 dentry</span><br><span class="line">                        return p; //找到返回mount实例</span><br><span class="line">        return NULL;  //没找到返回NULL</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="4-3-3lock-mount情景分析"><a href="#4-3-3lock-mount情景分析" class="headerlink" title="4.3.3lock_mount情景分析"></a><strong>4.3.3lock_mount情景分析</strong></h4><p>1)lock_mount传递的path 之前不是挂载点：</p>
<p>调用链为：</p>
<blockquote>
<p>lock_mount<br>-&gt;mnt &#x3D; lookup_mnt(path) &#x2F;&#x2F;没有子mount 返回NULL<br>-&gt;mp &#x3D; get_mountpoint(dentry) &#x2F;&#x2F;分配mountpoint 加入mountpoint hash表（dentry计算hash）,设置dentry为挂载点<br>-&gt;return mp &#x2F;&#x2F;返回找到的挂载点实例</p>
</blockquote>
<p>2)lock_mount传递的path 之前是挂载点：我们现在执行 mount -t ext2 &#x2F;dev&#x2F;sda4 &#x2F;mnt</p>
<p>之前 &#x2F;mnt的挂载情况</p>
<blockquote>
<p>mount &#x2F;dev&#x2F;sda1 &#x2F;mnt （1）<br>mount &#x2F;dev&#x2F;sda2 &#x2F;mnt （2）<br>mount &#x2F;dev&#x2F;sda3 &#x2F;mnt （3）</p>
</blockquote>
<p>调用链为：</p>
<blockquote>
<p>lock_mount<br>-&gt;mnt &#x3D; lookup_mnt(path) &#x2F;&#x2F;返回（1）的mount实例<br>-&gt;path-&gt;mnt &#x3D; mnt &#x2F;&#x2F;下一次查找的 path-&gt;mnt赋值（1）的mount实例<br>-&gt;dentry &#x3D; path-&gt;dentry &#x3D; dget(mnt-&gt;mnt_root) &#x2F;&#x2F; &#x2F;&#x2F;下一次查找path-&gt;dentry 赋值（1）的根dentry</p>
</blockquote>
<blockquote>
<p>-&gt;mnt &#x3D; lookup_mnt(path) &#x2F;&#x2F;返回（2）的mount实例<br>-&gt;path-&gt;mnt &#x3D; mnt &#x2F;&#x2F;下一次查找的 path-&gt;mnt赋值（2）的mount实例<br>-&gt;dentry &#x3D; path-&gt;dentry &#x3D; dget(mnt-&gt;mnt_root) &#x2F;&#x2F; &#x2F;&#x2F;下一次查找path-&gt;dentry 赋值（2）的根dentry</p>
<p>-&gt;mnt &#x3D; lookup_mnt(path) &#x2F;&#x2F;返回（3）的mount实例</p>
</blockquote>
<blockquote>
<p>-&gt;path-&gt;mnt &#x3D; mnt &#x2F;&#x2F;下一次查找的 path-&gt;mnt赋值（3）的mount实例<br>-&gt;dentry &#x3D; path-&gt;dentry &#x3D; dget(mnt-&gt;mnt_root) &#x2F;&#x2F; &#x2F;&#x2F;下一次查找path-&gt;dentry 赋值（3）的根dentry<br>-&gt; mnt &#x3D; lookup_mnt(path) &#x2F;&#x2F;没有子mount 返回NULL<br>-&gt;mp &#x3D; get_mountpoint(dentry) &#x2F;&#x2F;分配mountpoint 加入mountpoint hash表（dentry计算hash）,设置dentry为挂载点（（3）的根dentry作为挂载点）</p>
</blockquote>
<blockquote>
<p>-&gt;return mp &#x2F;&#x2F;返回找到的挂载点实例(也就是最后一次挂载（3） 文件系统的根dentry)</p>
</blockquote>
<h4 id="4-3-4do-add-mount源码分析"><a href="#4-3-4do-add-mount源码分析" class="headerlink" title="4.3.4do_add_mount源码分析"></a><strong>4.3.4do_add_mount源码分析</strong></h4><p>准备好了挂载点之后，接下来子mount实例关联挂载点以及添加子mount实例到全局的文件系统挂载树中。</p>
<figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">do_add_mount  //添加mount到全局的文件系统挂载树中</span><br><span class="line">-&gt;struct mount *parent = real_mount(path-&gt;mnt); //获得父挂载点的挂载实例</span><br><span class="line">-&gt;graft_tree(newmnt, parent, mp)</span><br><span class="line"> -&gt; mnt_set_mountpoint(dest_mnt, dest_mp, source_mnt)</span><br><span class="line">  -&gt;   child_mnt-&gt;mnt_mountpoint = mp-&gt;m_dentry;   //关联子mount到挂载点的dentry                 </span><br><span class="line">    child_mnt-&gt;mnt_parent = mnt; //子mount-&gt;mnt_parent指向父mount</span><br><span class="line">    child_mnt-&gt;mnt_mp = mp; //子mount-&gt;mnt_mp指向挂载点</span><br><span class="line">    hlist_add_head(&amp;child_mnt-&gt;mnt_mp_list, &amp;mp-&gt;m_list); //mount添加到挂载点链表</span><br><span class="line"></span><br><span class="line"> -&gt;commit_tree //提交挂载树</span><br><span class="line">  -&gt;__attach_mnt(mnt, parent)</span><br><span class="line">   -&gt;  hlist_add_head_rcu(&amp;mnt-&gt;mnt_hash,</span><br><span class="line">       ¦  m_hash(&amp;parent-&gt;mnt, mnt-&gt;mnt_mountpoint));  //添加到mount hash表 ，通过父挂载点的vfsmount和挂载点的dentry作为索引(如上面示例中的&lt;(3)的vfsmount , (3)的根dentry&gt;)</span><br><span class="line">    list_add_tail(&amp;mnt-&gt;mnt_child, &amp;parent-&gt;mnt_mounts);  //添加到父mount链表</span><br></pre></td></tr></table></figure>

<p>上面说了一大堆，主要为了实现：</p>
<p><strong>将mount实例与挂载点联系起来（会将mount实例加入到mount 哈希表，父文件系统的vfsmount和真正的挂载点的dentry组成的二元组为索引，路径名查找时便于查找），以及mount实例与文件系统的跟dentry联系起来（路径名查找的时候便于沿着跟dentry来访问这个文件系统的所有文件）。</strong></p>
<h4 id="4-3-5do-add-mount-之后vfs对象数据结构之间关系图（-mnt之前不是挂载点情况）如下："><a href="#4-3-5do-add-mount-之后vfs对象数据结构之间关系图（-mnt之前不是挂载点情况）如下：" class="headerlink" title="4.3.5do_add_mount 之后vfs对象数据结构之间关系图（&#x2F;mnt之前不是挂载点情况）如下："></a>4.3.5do_add_mount 之后vfs对象数据结构之间关系图（&#x2F;mnt之前不是挂载点情况）如下：</h4><p><img src="https://pic1.zhimg.com/80/v2-72f3ca5ef905b57826560d45046eab94_720w.webp" alt="img"></p>
<h2 id="5、mount的应用"><a href="#5、mount的应用" class="headerlink" title="5、mount的应用"></a><strong>5、mount的应用</strong></h2><ul>
<li>上面几章我们分析了文件系统挂载的主要流程，创建并关联了各个vfs的对象，为了打开文件等路径名查找时做准备。</li>
</ul>
<h3 id="5-1路径名查找到挂载点源码分析"><a href="#5-1路径名查找到挂载点源码分析" class="headerlink" title="5.1路径名查找到挂载点源码分析"></a><strong>5.1路径名查找到挂载点源码分析</strong></h3><figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line">//fs/namei.c 查找一个路径分量</span><br><span class="line">walk_component  </span><br><span class="line">-&gt;step_into</span><br><span class="line"> -&gt;handle_mounts</span><br><span class="line">  -&gt;traverse_mounts</span><br><span class="line">   -&gt;flags = smp_load_acquire(&amp;path-&gt;dentry-&gt;d_flags); //获得dentry标志</span><br><span class="line">   -&gt;__traverse_mounts(path, flags, jumped, count, lookup_flags); //查找挂载点  返回不再是挂载点的path</span><br><span class="line">     -&gt; &#123;</span><br><span class="line">     </span><br><span class="line">       while (flags &amp; DCACHE_MANAGED_DENTRY) &#123;    //找到的dentry是挂载点 则继续查找 ，不是则退出循环</span><br><span class="line">        ...</span><br><span class="line">        if (flags &amp; DCACHE_MOUNTED) &#123;   // something&#x27;s mounted on it..  是挂载点 和上面lock_mount分析逻辑类似 </span><br><span class="line">         //不断的查找挂载点  直到最后查找到的dentry不是挂载点 退出循环</span><br><span class="line">         struct vfsmount *mounted = lookup_mnt(path);  //查找第一个子mount          </span><br><span class="line">         if (mounted) &#123;          // ... in our namespace         </span><br><span class="line">           dput(path-&gt;dentry);                            </span><br><span class="line">           if (need_mntput)</span><br><span class="line">             mntput(path-&gt;mnt);</span><br><span class="line">           path-&gt;mnt = mounted; //path-&gt;mnt赋值子mount</span><br><span class="line">           path-&gt;dentry = dget(mounted-&gt;mnt_root); //path-&gt;dentry 赋值子mount的根dentry （是挂载点就会步进到挂载点的跟dentry）</span><br><span class="line">           // here we know it&#x27;s positive</span><br><span class="line">           flags = path-&gt;dentry-&gt;d_flags; //获得dentry标志</span><br><span class="line">           need_mntput = true;</span><br><span class="line">           continue; //继续查找</span><br><span class="line">        &#125;</span><br><span class="line">        ...</span><br><span class="line"></span><br><span class="line">       &#125;</span><br><span class="line">       </span><br><span class="line">       //最终返回找到的path（它不再是挂载点），后面继续查找下一个路径</span><br><span class="line">      &#125;</span><br></pre></td></tr></table></figure>

<h3 id="5-2举例说明"><a href="#5-2举例说明" class="headerlink" title="5.2举例说明"></a><strong>5.2举例说明</strong></h3><blockquote>
<p>我们做以下的路径名查找：&#x2F;mnt&#x2F;test&#x2F;text.txt<br>&#x2F;mnt&#x2F; 目录挂载情况为<br>mount &#x2F;dev&#x2F;sda1 &#x2F;mnt （1）<br>mount &#x2F;dev&#x2F;sda2 &#x2F;mnt （2）</p>
</blockquote>
<blockquote>
<p>mount &#x2F;dev&#x2F;sda3 &#x2F;mnt （3）<br>test&#x2F;text.txt文件在 &#x2F;dev&#x2F;sda3 上</p>
</blockquote>
<p>则路径名查找时，查找到mnt的dentry发现它是挂载点，就会依次查找（1）的根目录-&gt;（2）的根目录 -&gt;（3）的根目录， 最终将（3）的vfsmount和 根目录的dentry 填写到path，进行下一步的查找, 最终查找到&#x2F;dev&#x2F;sda3 上的text.txt文件。</p>
<p>注：一个目录被文件系统挂载时，原来目录中包含的其他子目录或文件会被隐藏。</p>
<h2 id="6、挂载图解"><a href="#6、挂载图解" class="headerlink" title="6、挂载图解"></a><strong>6、挂载图解</strong></h2><p>为了便于讲解图示中各个实例表示如下：</p>
<blockquote>
<p>Xyn —&gt; X表示哪个实例对象 如：mount实例使用M表示（第一个大小字母） dentry使用D表示 inode使用I表示 super_block用S表示 vfsmount使用V表示<br>y表示是父文件系统中的实例对象还是子文件系统中 如：p（parent）表示父文件系统中实例对象 c（child）表示子文件系统中实例对象<br>n 区分同一种对象的不同实例<br>例如：Dc1 表示子文件系统中一个dentry对象</p>
</blockquote>
<h3 id="6-1mount、super-block、file-system-type三者关系图解"><a href="#6-1mount、super-block、file-system-type三者关系图解" class="headerlink" title="6.1mount、super_block、file_system_type三者关系图解"></a><strong>6.1mount、super_block、file_system_type三者关系图解</strong></h3><p><img src="https://pic1.zhimg.com/80/v2-095bb1781dfa095aae41172484c23e3c_720w.webp" alt="img"></p>
<p>解释：mount实例、super_block实例、file_system_type实例三种层级逐渐升高，即一个file_system_type实例会包含多个super_block实例，一个super_block实例会包含多个mount实例。一种file_system_type必须先被注册到系统中来宣誓这种文件系统存在，主要提供此类文件系统的挂载和卸载方法等，注册即是加入全局的file_systems链表，等到有块设备上的文件系统要挂载时就会根据挂载时传递的文件系统类型名查找file_system_type实例，如果查找到，就会调用它的挂载方法进行挂载。首先，在file_systems实例的super_block链表中查找有没有super_block实例已经被创建，如果有就不需要从磁盘读取（这就是一个块设备上的文件系统挂载到多个目录上只有一个super_block实例的原因），如果没有从磁盘读取并加入对应的file_systems实例的super_block链表。而每次挂载都会创建一个mount实例来联系挂载点和super_block实例，并以（父vfsmount,挂载点dentry）为索引加入到全局mount哈希表，便于后面访问这个挂载点的文件系统时的路径名查找。</p>
<h3 id="6-2父子文件系统挂载关系图解"><a href="#6-2父子文件系统挂载关系图解" class="headerlink" title="6.2父子文件系统挂载关系图解"></a><strong>6.2父子文件系统挂载关系图解</strong></h3><p><img src="https://pic4.zhimg.com/80/v2-c88da59ea00bb451ddceb1cbf060d59f_720w.webp" alt="img"></p>
<p>解释：图中&#x2F;dev&#x2F;sda1中的子文件系统挂载到父文件系统的&#x2F;mnt目录下。当挂载的时候会创建mount、super_block、跟inode、跟dentry四大数据结构并建立相互关系，将子文件系统的mount加入到(Vp, Dp3)二元组为索引的mount哈希表中，通过设置mnt的目录项（Dp3）的DCACHE_MOUNTED来将其标记为挂载点，并与父文件系统建立亲缘关系挂载就完成了。</p>
<p>当需要访问子文件系统中的某个文件时，就会通过路径名各个分量解析到mnt目录，发现其为挂载点，就会通过(Vp, Dp3)二元组在mount哈希表中找到子文件系统的mount实例(Mc),然后就会从子文件系统的跟dentry（Dc1）开始往下继续查找，最终访问到子文件系统上的文件。</p>
<h3 id="6-3单个文件系统多挂载点关系图解"><a href="#6-3单个文件系统多挂载点关系图解" class="headerlink" title="6.3单个文件系统多挂载点关系图解"></a><strong>6.3单个文件系统多挂载点关系图解</strong></h3><p><img src="https://pic1.zhimg.com/80/v2-8a4deddc3f1722a73f4d113b7d64ead8_720w.webp" alt="img"></p>
<p>解释：图中将&#x2F;dev&#x2F;sda1中的文件系统分别挂载到父文件系统的&#x2F;mnt&#x2F;a和&#x2F;mnt&#x2F;b目录下。当第一次挂载到&#x2F;mnt&#x2F;a时，会创建mount、super_block、跟inode、跟dentry四大数据结构(分别对应与Mc1、Sc、Dc1、Ic)并建立相互关系，将子文件系统的Mc1加入到(Vp, Dp3)二元组为索引的mount哈希表中，通过设置&#x2F;mnt&#x2F;a的目录项的DCACHE_MOUNTED来将其标记为挂载点，并与父文件系统建立亲缘关系挂载就完成了。然后挂载到&#x2F;mnt&#x2F;b时, Sc、Dc1、Ic已经创建好不需要再创建，内存中只会有一份，会创建Mc2来关联super_block和第二次的挂载点，建立这几个数据结构关系，将子文件系统的Mc2加入到(Vp, Dp4)二元组为索引的mount哈希表中，通过设置&#x2F;mnt&#x2F;b的目录项的DCACHE_MOUNTED来将其标记为挂载点，并与父文件系统建立亲缘关系挂载就完成了。</p>
<p>当需要访问子文件系统中的某个文件时，就会通过路径名各个分量解析到&#x2F;mnt&#x2F;a目录，发现其为挂载点，就会通过(Vp, Dp3)在mount哈希表中找到子文件系统的Mc1,然后就会从子文件系统的Dc1开始往下继续查找，最终访问到子文件系统上的文件。同样，如果解析到&#x2F;mnt&#x2F;b目录,发现其为挂载点，就会通过(Vp, Dp4)在mount哈希表中找到子文件系统的Mc2,然后就会从子文件系统的Dc1开始往下继续查找，最终访问到子文件系统上的文件。可以发现，同一个块设备上的文件系统挂载到不同的目录上，相关联的super_block和跟dentry是一样的，这保证了无论从哪个挂载点开始路径名查找都访问到的是同一个文件系统上的文件。</p>
<h3 id="6-4多文件系统单挂载点关系图解"><a href="#6-4多文件系统单挂载点关系图解" class="headerlink" title="6.4多文件系统单挂载点关系图解"></a><strong>6.4多文件系统单挂载点关系图解</strong></h3><p><img src="https://pic4.zhimg.com/80/v2-03e69e56d7942f240dad3df406131303_720w.webp" alt="img"></p>
<p>解释：最后我们来看多文件系统单挂载点的情况，图中先将块设备&#x2F;dev&#x2F;sda1中的子文件系统1挂载到&#x2F;mnt目录，然后再将块设备&#x2F;dev&#x2F;sdb1中的子文件系统2挂载到&#x2F;mnt目录上。</p>
<p>当子文件系统1挂载的时候，会创建mount、super_block、跟inode、跟dentry四大数据结构(分别对应与Mc1、Sc1、Dc1、Ic1)并建立相互关系，将子文件系统的Mc1加入到(Vp, Dp3)二元组为索引的mount哈希表中，通过设置&#x2F;mnt的目录项的DCACHE_MOUNTED来将其标记为挂载点，并与父文件系统建立亲缘关系挂载就完成了。</p>
<p>当子文件系统2挂载的时候，会创建mount、super_block、跟inode、跟dentry四大数据结构(分别对应与Mc2、Sc2、Dc4、Ic2)并建立相互关系，这个时候会发现&#x2F;mnt目录是挂载点，则会将子文件系统1的根目录（Dc1）作为文件系统2的挂载点，将子文件系统的Mc2加入到(Vc1, Dc1)二元组为索引的mount哈希表中，通过设置Dc1的DCACHE_MOUNTED来将其标记为挂载点，并与父文件系统建立亲缘关系挂载就完成了。</p>
<p>这个时候，子文件系统1已经被子文件系统2隐藏起来了，当路径名查找到&#x2F;mnt目录时，发现其为挂载点，则通过(Vp, Dp3)二元组为索引在mount哈希表中找到Mc1，会转向文件系统1的跟目录（Dc1）开始往下继续查找，发现Dc1也是挂载点，则(通过Vc1, Dc1)二元组为索引在mount哈希表中找到Mc2, 会转向文件系统1的跟目录（Dc4）开始往下继续查找，于是就访问到了文件系统2中的文件。除非，文件系统2被卸载，文件系统1的跟dentry（Dc1）不再是挂载点，这个时候文件系统1中的文件才能再次被访问到。</p>
<h2 id="7、总结"><a href="#7、总结" class="headerlink" title="7、总结"></a><strong>7、总结</strong></h2><p>Linux中，块设备上的文件系统只有挂载到内存的目录树中的一个目录下，用户进程才能访问，而挂载是创建数据结构关联块设备上的文件系统和挂载点，使得路径名查找的时候能够通过挂载点目录访问到挂载在其下的文件系统。</p>
<h3 id="7-1挂载主要步骤"><a href="#7-1挂载主要步骤" class="headerlink" title="7.1挂载主要步骤"></a><strong>7.1挂载主要步骤</strong></h3><p>1.vfs_get_tree 调用具体文件系统的获取填充超级块方法(fs_context_operations.get_tree或者file_system_type.mount)， 在内存构建super_block，然后构建根inode和根dentry(磁盘文件系统可能需要从磁盘读取磁盘超级块构建内存的super_block，从磁盘读取根inode构建内存的inode)。2.do_new_mount_fc 对于每次挂载都会分配mount实例，用于关联挂载点到文件系统。当一个要挂载的目录不是挂载点，会设置这个目录的dentry为挂载点，然后mount实例记录这个挂载点。当一个要挂载的目录是挂载点（之前已经有文件系统被挂载到这个目录），那么新挂载的文件系统将挂载到这个目录最后一次挂载的文件系统的根dentry,之前挂载的文件系统的文件都被隐藏（当子挂载被卸载，原来的文件系统的文件才可见）。</p>
<h3 id="7-2文件系统的用户可见性"><a href="#7-2文件系统的用户可见性" class="headerlink" title="7.2文件系统的用户可见性"></a><strong>7.2文件系统的用户可见性</strong></h3><p><strong>只对内核内部可见：</strong>不需要将文件系统关联到一个挂载点，内核通过文件系统的super_block等结构即可访问到文件系统的文件（如bdev，sockfs）。</p>
<p><strong>对于用户可见：</strong>需要将文件系统关联到一个挂载点，就需要通过给定的挂载点目录名找到真正的挂载点，然后进行挂载操作， 挂载的实质是：通过mount实例的mnt_mountpoint关联真正的挂载点dentry,然后建立父mount关系，mount实例加入到全局的mount hash table（通过父vfsmount和真正的挂载点dentry作为hash索引），然后用户打开文件的时候通过路径名查找解析各个目录分量，当发现一个目录是挂载点时，就会步进到最后一次挂载到这个目录的文件系统的根dentry中继续查找，知道根dentry就可以继续查找到这个文件系统的任何文件。</p>
<h3 id="7-3几条重要规律"><a href="#7-3几条重要规律" class="headerlink" title="7.3几条重要规律"></a><strong>7.3几条重要规律</strong></h3><p>1）文件系统被挂载后都会有以下几大vfs对象被创建：</p>
<p>super_block<br>mount</p>
<p>根inode</p>
<p>根dentry</p>
<p>注：其中mount为纯软件构造的对象（内嵌vfsmount对象），其他对象视文件系统类型，可能涉及到磁盘操作。</p>
<p>super_block 超级块实例，描述一个文件系统的信息，有的需要磁盘读取在内存中填充来构建（如磁盘文件系统），有的直接内存中填充来构建。</p>
<p>mount 挂载实例，描述一个文件系统的一次挂载，主要关联一个文件系统到挂载点，为路径名查找做重要准备工作。</p>
<p>根inode 每个文件系统都会有根inode，有的需要磁盘读取在内存中填充来构建（如磁盘文件系统，根inode号已知），有的直接内存中填充来构建。</p>
<p>根dentry 每个文件系统都会有根dentry，根据根inode来构建，路径名查找时会步进到文件系统的根dentry来访问这个文件系统的文件。</p>
<p>2）一个目录可以被多个文件系统挂载。第一次挂载是直接挂载这个目录上，新挂载的文件系统实际上是挂载在上一个文件系统的根dentry上。</p>
<p>3）一个目录被多个文件系统挂载时，新挂载导致之前的挂载被隐藏。</p>
<p>4）一个目录被文件系统挂载时，原来目录中包含的其他子目录或文件被隐藏。</p>
<p>5）每次挂载都会有一个mount实例描述本次挂载。</p>
<p>6）一个快设备上的文件系统可以被挂载到多个目录，有多个mount实例，但是只会有一个super_block、根dentry 和根inode。</p>
<p>7）mount实例用于关联挂载点dentry和文件系统，起到路径名查找时“路由”的作用。</p>
<p>8）挂载一个文件系统必须保证所要挂载的文件系统类型已经被注册。</p>
<p>9）挂载时会查询文件系统类型的fs_type-&gt;fs_supers链表，检查是否已经有super_block被加入链表，如果没有才会分配并读磁盘超级块填充。</p>
<p>10）对象层次：一个fs_type-&gt;fs_supers链表可以挂接属于同一个文件系统的被挂载的超级块，超级块链表可以挂接属于同一个超级块的mount实例 fs_type -&gt; super_block -&gt; mount 从高到低的包含层次。</p>
<hr>
<p>版权声明：本文为知乎博主「Linux内核库」的原创文章，遵循CC 4.0 BY-SA版权协议，转载请附上原文 出处链接及本声明。 </p>
<p>原文链接：<a target="_blank" rel="noopener" href="https://zhuanlan.zhihu.com/p/515769749">https://zhuanlan.zhihu.com/p/515769749</a></p>
</article><div class="post-copyright"><div class="post-copyright__author"><span class="post-copyright-meta"><i class="fas fa-circle-user fa-fw"></i>文章作者: </span><span class="post-copyright-info"><a href="https://vcloud.ysme.top">ysme</a></span></div><div class="post-copyright__type"><span class="post-copyright-meta"><i class="fas fa-square-arrow-up-right fa-fw"></i>文章链接: </span><span class="post-copyright-info"><a href="https://vcloud.ysme.top/2023/01/15/linux-docs/%E6%96%87%E4%BB%B6%E7%B3%BB%E7%BB%9F/Linux%E5%86%85%E6%A0%B8%E6%96%87%E4%BB%B6%E7%B3%BB%E7%BB%9F%E6%8C%82%E8%BD%BD/">https://vcloud.ysme.top/2023/01/15/linux-docs/%E6%96%87%E4%BB%B6%E7%B3%BB%E7%BB%9F/Linux%E5%86%85%E6%A0%B8%E6%96%87%E4%BB%B6%E7%B3%BB%E7%BB%9F%E6%8C%82%E8%BD%BD/</a></span></div><div class="post-copyright__notice"><span class="post-copyright-meta"><i class="fas fa-circle-exclamation fa-fw"></i>版权声明: </span><span class="post-copyright-info">本博客所有文章除特别声明外，均采用 <a href="https://creativecommons.org/licenses/by-nc-sa/4.0/" target="_blank">CC BY-NC-SA 4.0</a> 许可协议。转载请注明来自 <a href="https://vcloud.ysme.top" target="_blank">Blog</a>！</span></div></div><div class="tag_share"><div class="post-meta__tag-list"><a class="post-meta__tags" href="/tags/Linux/">Linux</a></div><div class="post_share"><div class="social-share" data-image="https://i.loli.net/2020/05/01/gkihqEjXxJ5UZ1C.jpg" data-sites="facebook,twitter,wechat,weibo,qq"></div><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/butterfly-extsrc@1.1.3/sharejs/dist/css/share.min.css" media="print" onload="this.media='all'"><script src="https://cdn.jsdelivr.net/npm/butterfly-extsrc@1.1.3/sharejs/dist/js/social-share.min.js" defer></script></div></div><nav class="pagination-post" id="pagination"><div class="prev-post pull-left"><a href="/2023/01/15/linux-docs/%E6%96%87%E4%BB%B6%E7%B3%BB%E7%BB%9F/Linux%E5%86%85%E6%A0%B8%E6%96%87%E4%BB%B6%E7%B3%BB%E7%BB%9F%E5%8E%9F%E7%90%86%E4%B8%8E%E5%AE%9E%E7%8E%B0/" title="Linux内核文件系统原理与实现"><img class="cover" src="https://i.loli.net/2020/05/01/gkihqEjXxJ5UZ1C.jpg" onerror="onerror=null;src='/img/404.jpg'" alt="cover of previous post"><div class="pagination-info"><div class="label">上一篇</div><div class="prev_info">Linux内核文件系统原理与实现</div></div></a></div><div class="next-post pull-right"><a href="/2023/01/15/linux-docs/%E6%96%87%E4%BB%B6%E7%B3%BB%E7%BB%9F/Linux%E5%86%85%E6%A0%B8%E6%96%87%E4%BB%B6%E7%B3%BB%E7%BB%9F%E7%9F%A5%E8%AF%86%E5%A4%A7%E6%80%BB%E7%BB%93/" title="Linux内核文件系统知识大总结"><img class="cover" src="https://i.loli.net/2020/05/01/gkihqEjXxJ5UZ1C.jpg" onerror="onerror=null;src='/img/404.jpg'" alt="cover of next post"><div class="pagination-info"><div class="label">下一篇</div><div class="next_info">Linux内核文件系统知识大总结</div></div></a></div></nav><div class="relatedPosts"><div class="headline"><i class="fas fa-thumbs-up fa-fw"></i><span>相关推荐</span></div><div class="relatedPosts-list"><div><a href="/2023/01/15/linux-docs/30%E5%88%86%E9%92%9F%E5%AD%A6%E4%BC%9A%E7%BC%96%E8%AF%91linux%E5%86%85%E6%A0%B8/" title="Linux 30分钟学会编译linux内核"><img class="cover" src="https://pic2.zhimg.com/80/v2-99c76217f4575d98a9001a4fd8c1681d_720w.webp" alt="cover"><div class="content is-center"><div class="date"><i class="far fa-calendar-alt fa-fw"></i> 2023-01-15</div><div class="title">Linux 30分钟学会编译linux内核</div></div></a></div><div><a href="/2023/01/15/linux-docs/Linux%20IO%20%E4%B9%8B%20IO%E4%B8%8E%E7%BD%91%E7%BB%9C%E6%A8%A1%E5%9E%8B/" title="Linux IO 之 IO与网络模型"><img class="cover" src="https://user-images.githubusercontent.com/87457873/127649604-761ead2e-8c72-4876-a52f-8310f3c3b49c.png" alt="cover"><div class="content is-center"><div class="date"><i class="far fa-calendar-alt fa-fw"></i> 2023-01-15</div><div class="title">Linux IO 之 IO与网络模型</div></div></a></div><div><a href="/2023/01/15/linux-docs/Linux%20Kernel%E5%86%85%E6%A0%B8%E6%95%B4%E4%BD%93%E6%9E%B6%E6%9E%84(%E5%9B%BE%E6%96%87%E8%AF%A6%E8%A7%A3)/" title="Linux Kernel内核整体架构(图文详解)"><img class="cover" src="https://pic2.zhimg.com/80/v2-93cd0f1a4abbdfeb4af71202535fe4f9_720w.webp" alt="cover"><div class="content is-center"><div class="date"><i class="far fa-calendar-alt fa-fw"></i> 2023-01-15</div><div class="title">Linux Kernel内核整体架构(图文详解)</div></div></a></div><div><a href="/2023/01/15/linux-docs/Linux%E5%86%85%E6%A0%B8Coding%20Style%E6%95%B4%E7%90%86/" title="Linux内核Coding Style整理"><img class="cover" src="https://pic4.zhimg.com/80/v2-55215e20944d5e1a161253e73eddaa07_720w.webp" alt="cover"><div class="content is-center"><div class="date"><i class="far fa-calendar-alt fa-fw"></i> 2023-01-15</div><div class="title">Linux内核Coding Style整理</div></div></a></div><div><a href="/2023/01/15/linux-docs/Linux%E5%86%85%E6%A0%B8Makefile%E7%B3%BB%E7%BB%9F%E6%96%87%E4%BB%B6%E8%AF%A6%E8%A7%A3/" title="Linux内核Makefile系统文件详解"><img class="cover" src="https://pic4.zhimg.com/80/v2-55215e20944d5e1a161253e73eddaa07_720w.webp" alt="cover"><div class="content is-center"><div class="date"><i class="far fa-calendar-alt fa-fw"></i> 2023-01-15</div><div class="title">Linux内核Makefile系统文件详解</div></div></a></div><div><a href="/2023/01/15/linux-docs/Linux%E5%86%85%E6%A0%B8RCU%E6%9C%BA%E5%88%B6/" title="Linux内核RCU机制"><img class="cover" src="https://pic2.zhimg.com/80/v2-012ee665b35eb28bca5c88269765f069_720w.webp" alt="cover"><div class="content is-center"><div class="date"><i class="far fa-calendar-alt fa-fw"></i> 2023-01-15</div><div class="title">Linux内核RCU机制</div></div></a></div></div></div></div><div class="aside-content" id="aside-content"><div class="card-widget card-info"><div class="is-center"><div class="avatar-img"><img src="/img/avatar.jpg" onerror="this.onerror=null;this.src='/img/friend_404.gif'" alt="avatar"/></div><div class="author-info__name">ysme</div><div class="author-info__description">嘻嘻哈哈。</div></div><div class="card-info-data site-data is-center"><a href="/archives/"><div class="headline">文章</div><div class="length-num">131</div></a><a href="/tags/"><div class="headline">标签</div><div class="length-num">5</div></a><a href="/categories/"><div class="headline">分类</div><div class="length-num">10</div></a></div><a id="card-info-btn" target="_blank" rel="noopener" href="https://github.com/ysme1"><i class="fab fa-github"></i><span>Follow Me</span></a><div class="card-info-social-icons is-center"><a class="social-icon" href="https://github.com/ysme1" target="_blank" title="Github"><i class="fab fa-github" style="color: #24292e;"></i></a><a class="social-icon" href="mailto:zys1395740068@gmail.com" target="_blank" title="Email"><i class="fas fa-envelope" style="color: #4a7dbe;"></i></a></div></div><div class="card-widget card-announcement"><div class="item-headline"><i class="fas fa-bullhorn fa-shake"></i><span>公告</span></div><div class="announcement_content">This is my Blog</div></div><div class="sticky_layout"><div class="card-widget" id="card-toc"><div class="item-headline"><i class="fas fa-stream"></i><span>目录</span><span class="toc-percentage"></span></div><div class="toc-content"><ol class="toc"><li class="toc-item toc-level-2"><a class="toc-link" href="#1%E3%80%81%E5%89%8D%E8%A8%80"><span class="toc-number">1.</span> <span class="toc-text">1、前言</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#2%E3%80%81vfs-%E5%87%A0%E4%B8%AA%E9%87%8D%E8%A6%81%E5%AF%B9%E8%B1%A1"><span class="toc-number">2.</span> <span class="toc-text">2、vfs 几个重要对象</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#2-1file-system-type"><span class="toc-number">2.1.</span> <span class="toc-text">2.1file_system_type</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#2-2super-block"><span class="toc-number">2.2.</span> <span class="toc-text">2.2super_block</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#2-3mount"><span class="toc-number">2.3.</span> <span class="toc-text">2.3mount</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#2-4inode"><span class="toc-number">2.4.</span> <span class="toc-text">2.4inode</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#2-5dentry"><span class="toc-number">2.5.</span> <span class="toc-text">2.5dentry</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#2-6file"><span class="toc-number">2.6.</span> <span class="toc-text">2.6file</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#3%E3%80%81%E6%8C%82%E8%BD%BD%E6%80%BB%E4%BD%93%E6%B5%81%E7%A8%8B"><span class="toc-number">3.</span> <span class="toc-text">3、挂载总体流程</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#3-1%E7%B3%BB%E7%BB%9F%E8%B0%83%E7%94%A8%E5%A4%84%E7%90%86"><span class="toc-number">3.1.</span> <span class="toc-text">3.1系统调用处理</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#3-2%E6%8C%82%E8%BD%BD%E7%82%B9%E8%B7%AF%E5%BE%84%E6%9F%A5%E6%89%BE"><span class="toc-number">3.2.</span> <span class="toc-text">3.2挂载点路径查找</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#3-3%E5%8F%82%E6%95%B0%E5%90%88%E6%B3%95%E6%80%A7%E6%A3%80%E6%9F%A5"><span class="toc-number">3.3.</span> <span class="toc-text">3.3参数合法性检查</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#3-4%E8%B0%83%E7%94%A8%E5%85%B7%E4%BD%93%E6%96%87%E4%BB%B6%E7%B3%BB%E7%BB%9F%E6%8C%82%E8%BD%BD%E6%96%B9%E6%B3%95"><span class="toc-number">3.4.</span> <span class="toc-text">3.4调用具体文件系统挂载方法</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#3-5%E6%8C%82%E8%BD%BD%E5%AE%9E%E4%BE%8B%E6%B7%BB%E5%8A%A0%E5%88%B0%E5%85%A8%E5%B1%80%E6%96%87%E4%BB%B6%E7%B3%BB%E7%BB%9F%E6%A0%91"><span class="toc-number">3.5.</span> <span class="toc-text">3.5挂载实例添加到全局文件系统树</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#4%E3%80%81%E5%85%B7%E4%BD%93%E6%96%87%E4%BB%B6%E7%B3%BB%E7%BB%9F%E6%8C%82%E8%BD%BD%E6%96%B9%E6%B3%95"><span class="toc-number">4.</span> <span class="toc-text">4、具体文件系统挂载方法</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#4-1vfs-get-tree"><span class="toc-number">4.1.</span> <span class="toc-text">4.1vfs_get_tree</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#4-2mount-bdev%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90"><span class="toc-number">4.2.</span> <span class="toc-text">4.2mount_bdev源码分析</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#4-3ext2-fill-super%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90"><span class="toc-number">4.3.</span> <span class="toc-text">4.3ext2_fill_super源码分析</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#4-1do-new-mount-fc"><span class="toc-number">4.4.</span> <span class="toc-text">4.1do_new_mount_fc</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#4-2vfs-create-mount%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90"><span class="toc-number">4.5.</span> <span class="toc-text">4.2vfs_create_mount源码分析</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#4-2-1vfs-create-mount%E4%B9%8B%E5%90%8Evfs%E5%AF%B9%E8%B1%A1%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B9%8B%E9%97%B4%E5%85%B3%E7%B3%BB%E5%9B%BE%E5%A6%82%E4%B8%8B%EF%BC%9A"><span class="toc-number">4.5.1.</span> <span class="toc-text">4.2.1vfs_create_mount之后vfs对象数据结构之间关系图如下：</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#4-3lock-mount%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90"><span class="toc-number">4.6.</span> <span class="toc-text">4.3lock_mount源码分析</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#4-3-1get-mountpoint%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90"><span class="toc-number">4.6.1.</span> <span class="toc-text">4.3.1get_mountpoint源码分析</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#4-3-2lookup-mnt%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90"><span class="toc-number">4.6.2.</span> <span class="toc-text">4.3.2lookup_mnt源码分析</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#4-3-3lock-mount%E6%83%85%E6%99%AF%E5%88%86%E6%9E%90"><span class="toc-number">4.6.3.</span> <span class="toc-text">4.3.3lock_mount情景分析</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#4-3-4do-add-mount%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90"><span class="toc-number">4.6.4.</span> <span class="toc-text">4.3.4do_add_mount源码分析</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#4-3-5do-add-mount-%E4%B9%8B%E5%90%8Evfs%E5%AF%B9%E8%B1%A1%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B9%8B%E9%97%B4%E5%85%B3%E7%B3%BB%E5%9B%BE%EF%BC%88-mnt%E4%B9%8B%E5%89%8D%E4%B8%8D%E6%98%AF%E6%8C%82%E8%BD%BD%E7%82%B9%E6%83%85%E5%86%B5%EF%BC%89%E5%A6%82%E4%B8%8B%EF%BC%9A"><span class="toc-number">4.6.5.</span> <span class="toc-text">4.3.5do_add_mount 之后vfs对象数据结构之间关系图（&#x2F;mnt之前不是挂载点情况）如下：</span></a></li></ol></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#5%E3%80%81mount%E7%9A%84%E5%BA%94%E7%94%A8"><span class="toc-number">5.</span> <span class="toc-text">5、mount的应用</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#5-1%E8%B7%AF%E5%BE%84%E5%90%8D%E6%9F%A5%E6%89%BE%E5%88%B0%E6%8C%82%E8%BD%BD%E7%82%B9%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90"><span class="toc-number">5.1.</span> <span class="toc-text">5.1路径名查找到挂载点源码分析</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#5-2%E4%B8%BE%E4%BE%8B%E8%AF%B4%E6%98%8E"><span class="toc-number">5.2.</span> <span class="toc-text">5.2举例说明</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#6%E3%80%81%E6%8C%82%E8%BD%BD%E5%9B%BE%E8%A7%A3"><span class="toc-number">6.</span> <span class="toc-text">6、挂载图解</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#6-1mount%E3%80%81super-block%E3%80%81file-system-type%E4%B8%89%E8%80%85%E5%85%B3%E7%B3%BB%E5%9B%BE%E8%A7%A3"><span class="toc-number">6.1.</span> <span class="toc-text">6.1mount、super_block、file_system_type三者关系图解</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#6-2%E7%88%B6%E5%AD%90%E6%96%87%E4%BB%B6%E7%B3%BB%E7%BB%9F%E6%8C%82%E8%BD%BD%E5%85%B3%E7%B3%BB%E5%9B%BE%E8%A7%A3"><span class="toc-number">6.2.</span> <span class="toc-text">6.2父子文件系统挂载关系图解</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#6-3%E5%8D%95%E4%B8%AA%E6%96%87%E4%BB%B6%E7%B3%BB%E7%BB%9F%E5%A4%9A%E6%8C%82%E8%BD%BD%E7%82%B9%E5%85%B3%E7%B3%BB%E5%9B%BE%E8%A7%A3"><span class="toc-number">6.3.</span> <span class="toc-text">6.3单个文件系统多挂载点关系图解</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#6-4%E5%A4%9A%E6%96%87%E4%BB%B6%E7%B3%BB%E7%BB%9F%E5%8D%95%E6%8C%82%E8%BD%BD%E7%82%B9%E5%85%B3%E7%B3%BB%E5%9B%BE%E8%A7%A3"><span class="toc-number">6.4.</span> <span class="toc-text">6.4多文件系统单挂载点关系图解</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#7%E3%80%81%E6%80%BB%E7%BB%93"><span class="toc-number">7.</span> <span class="toc-text">7、总结</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#7-1%E6%8C%82%E8%BD%BD%E4%B8%BB%E8%A6%81%E6%AD%A5%E9%AA%A4"><span class="toc-number">7.1.</span> <span class="toc-text">7.1挂载主要步骤</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#7-2%E6%96%87%E4%BB%B6%E7%B3%BB%E7%BB%9F%E7%9A%84%E7%94%A8%E6%88%B7%E5%8F%AF%E8%A7%81%E6%80%A7"><span class="toc-number">7.2.</span> <span class="toc-text">7.2文件系统的用户可见性</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#7-3%E5%87%A0%E6%9D%A1%E9%87%8D%E8%A6%81%E8%A7%84%E5%BE%8B"><span class="toc-number">7.3.</span> <span class="toc-text">7.3几条重要规律</span></a></li></ol></li></ol></div></div><div class="card-widget card-recent-post"><div class="item-headline"><i class="fas fa-history"></i><span>最新文章</span></div><div class="aside-list"><div class="aside-list-item"><a class="thumbnail" href="/2024/10/22/%E5%B5%8C%E5%85%A5%E5%BC%8F/%E5%B5%8C%E5%85%A5%E5%BC%8F%E8%BD%AF%E4%BB%B6%E5%91%BD%E5%90%8D%E5%B8%B8%E7%94%A8%E8%8B%B1%E6%96%87%E9%9B%86/" title="嵌入式软件命名常用英文集"><img src="https://randomimage.ysme.top/" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="嵌入式软件命名常用英文集"/></a><div class="content"><a class="title" href="/2024/10/22/%E5%B5%8C%E5%85%A5%E5%BC%8F/%E5%B5%8C%E5%85%A5%E5%BC%8F%E8%BD%AF%E4%BB%B6%E5%91%BD%E5%90%8D%E5%B8%B8%E7%94%A8%E8%8B%B1%E6%96%87%E9%9B%86/" title="嵌入式软件命名常用英文集">嵌入式软件命名常用英文集</a><time datetime="2024-10-22T06:13:37.000Z" title="发表于 2024-10-22 14:13:37">2024-10-22</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/2023/03/22/%E5%B7%A5%E5%85%B7/git/git%E5%BF%AB%E9%80%9F%E5%85%A5%E9%97%A8/" title="Git 快速入门指南"><img src="https://randomimage.ysme.top/" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="Git 快速入门指南"/></a><div class="content"><a class="title" href="/2023/03/22/%E5%B7%A5%E5%85%B7/git/git%E5%BF%AB%E9%80%9F%E5%85%A5%E9%97%A8/" title="Git 快速入门指南">Git 快速入门指南</a><time datetime="2023-03-22T01:13:37.000Z" title="发表于 2023-03-22 09:13:37">2023-03-22</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/2023/01/15/linux-docs/30%E5%88%86%E9%92%9F%E5%AD%A6%E4%BC%9A%E7%BC%96%E8%AF%91linux%E5%86%85%E6%A0%B8/" title="Linux 30分钟学会编译linux内核"><img src="https://pic2.zhimg.com/80/v2-99c76217f4575d98a9001a4fd8c1681d_720w.webp" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="Linux 30分钟学会编译linux内核"/></a><div class="content"><a class="title" href="/2023/01/15/linux-docs/30%E5%88%86%E9%92%9F%E5%AD%A6%E4%BC%9A%E7%BC%96%E8%AF%91linux%E5%86%85%E6%A0%B8/" title="Linux 30分钟学会编译linux内核">Linux 30分钟学会编译linux内核</a><time datetime="2023-01-15T01:13:37.000Z" title="发表于 2023-01-15 09:13:37">2023-01-15</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/2023/01/15/linux-docs/Linux%20IO%20%E4%B9%8B%20IO%E4%B8%8E%E7%BD%91%E7%BB%9C%E6%A8%A1%E5%9E%8B/" title="Linux IO 之 IO与网络模型"><img src="https://user-images.githubusercontent.com/87457873/127649604-761ead2e-8c72-4876-a52f-8310f3c3b49c.png" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="Linux IO 之 IO与网络模型"/></a><div class="content"><a class="title" href="/2023/01/15/linux-docs/Linux%20IO%20%E4%B9%8B%20IO%E4%B8%8E%E7%BD%91%E7%BB%9C%E6%A8%A1%E5%9E%8B/" title="Linux IO 之 IO与网络模型">Linux IO 之 IO与网络模型</a><time datetime="2023-01-15T01:13:37.000Z" title="发表于 2023-01-15 09:13:37">2023-01-15</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/2023/01/15/linux-docs/Linux%20Kernel%E5%86%85%E6%A0%B8%E6%95%B4%E4%BD%93%E6%9E%B6%E6%9E%84(%E5%9B%BE%E6%96%87%E8%AF%A6%E8%A7%A3)/" title="Linux Kernel内核整体架构(图文详解)"><img src="https://pic2.zhimg.com/80/v2-93cd0f1a4abbdfeb4af71202535fe4f9_720w.webp" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="Linux Kernel内核整体架构(图文详解)"/></a><div class="content"><a class="title" href="/2023/01/15/linux-docs/Linux%20Kernel%E5%86%85%E6%A0%B8%E6%95%B4%E4%BD%93%E6%9E%B6%E6%9E%84(%E5%9B%BE%E6%96%87%E8%AF%A6%E8%A7%A3)/" title="Linux Kernel内核整体架构(图文详解)">Linux Kernel内核整体架构(图文详解)</a><time datetime="2023-01-15T01:13:37.000Z" title="发表于 2023-01-15 09:13:37">2023-01-15</time></div></div></div></div></div></div></main><footer id="footer"><div id="footer-wrap"><div class="copyright">&copy;2020 - 2024 By ysme</div><div class="framework-info"><span>框架 </span><a target="_blank" rel="noopener" href="https://hexo.io">Hexo</a><span class="footer-separator">|</span><span>主题 </span><a target="_blank" rel="noopener" href="https://github.com/jerryc127/hexo-theme-butterfly">Butterfly</a></div><div class="footer_custom_text"><a target="_blank" rel="noopener" href="https://beian.miit.gov.cn/#/Integrated/recordQuery"><img class="icp-icon" src=https://beian.mps.gov.cn/img/logo01.dd7ff50e.png><span>浙ICP备2021036292号</span></a></div></div></footer></div><div id="rightside"><div id="rightside-config-hide"><button id="readmode" type="button" title="阅读模式"><i class="fas fa-book-open"></i></button><button id="darkmode" type="button" title="浅色和深色模式转换"><i class="fas fa-adjust"></i></button><button id="hide-aside-btn" type="button" title="单栏和双栏切换"><i class="fas fa-arrows-alt-h"></i></button></div><div id="rightside-config-show"><button id="rightside-config" type="button" title="设置"><i class="fas fa-cog fa-spin"></i></button><button class="close" id="mobile-toc-button" type="button" title="目录"><i class="fas fa-list-ul"></i></button><button id="go-up" type="button" title="回到顶部"><span class="scroll-percent"></span><i class="fas fa-arrow-up"></i></button></div></div><div><script src="/js/utils.js?v=4.13.0"></script><script src="/js/main.js?v=4.13.0"></script><script src="https://cdn.jsdelivr.net/npm/@fancyapps/ui@5.0.33/dist/fancybox/fancybox.umd.min.js"></script><div class="js-pjax"></div><script async data-pjax src="//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script><div id="local-search"><div class="search-dialog"><nav class="search-nav"><span class="search-dialog-title">搜索</span><span id="loading-status"></span><button class="search-close-button"><i class="fas fa-times"></i></button></nav><div class="is-center" id="loading-database"><i class="fas fa-spinner fa-pulse"></i><span>  数据库加载中</span></div><div class="search-wrap"><div id="local-search-input"><div class="local-search-box"><input class="local-search-box--input" placeholder="搜索文章" type="text"/></div></div><hr/><div id="local-search-results"></div><div id="local-search-stats-wrap"></div></div></div><div id="search-mask"></div><script src="/js/search/local-search.js?v=4.13.0"></script></div></div></body></html>