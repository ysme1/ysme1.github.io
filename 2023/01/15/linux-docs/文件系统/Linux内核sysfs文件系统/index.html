<!DOCTYPE html><html lang="zh-CN" data-theme="light"><head><meta charset="UTF-8"><meta http-equiv="X-UA-Compatible" content="IE=edge"><meta name="viewport" content="width=device-width, initial-scale=1.0,viewport-fit=cover"><title>Linux内核sysfs文件系统 | Blog</title><meta name="author" content="ysme"><meta name="copyright" content="ysme"><meta name="format-detection" content="telephone=no"><meta name="theme-color" content="#ffffff"><meta name="description" content="内核源码：linux-2.6.38.8.tar.bz2 目标平台：ARM体系结构 sysfs是基于内存的文件系统，用于向用户空间导出内核对象并且能对其进行读写。 1、sysfs文件系统不支持特殊文件，只支持目录、普通文件（文本或二进制文件）和符号链接文件等三种类型，在内核中都使用struct sysfs_dirent结构体来表示，相当于其他文件系统在硬盘或flash里的数据。源代码如下所示： 12">
<meta property="og:type" content="article">
<meta property="og:title" content="Linux内核sysfs文件系统">
<meta property="og:url" content="https://vcloud.ysme.top/2023/01/15/linux-docs/%E6%96%87%E4%BB%B6%E7%B3%BB%E7%BB%9F/Linux%E5%86%85%E6%A0%B8sysfs%E6%96%87%E4%BB%B6%E7%B3%BB%E7%BB%9F/index.html">
<meta property="og:site_name" content="Blog">
<meta property="og:description" content="内核源码：linux-2.6.38.8.tar.bz2 目标平台：ARM体系结构 sysfs是基于内存的文件系统，用于向用户空间导出内核对象并且能对其进行读写。 1、sysfs文件系统不支持特殊文件，只支持目录、普通文件（文本或二进制文件）和符号链接文件等三种类型，在内核中都使用struct sysfs_dirent结构体来表示，相当于其他文件系统在硬盘或flash里的数据。源代码如下所示： 12">
<meta property="og:locale" content="zh_CN">
<meta property="og:image" content="https://i.loli.net/2020/05/01/gkihqEjXxJ5UZ1C.jpg">
<meta property="article:published_time" content="2023-01-15T01:13:37.000Z">
<meta property="article:modified_time" content="2024-10-28T08:31:33.236Z">
<meta property="article:author" content="ysme">
<meta property="article:tag" content="Linux">
<meta name="twitter:card" content="summary">
<meta name="twitter:image" content="https://i.loli.net/2020/05/01/gkihqEjXxJ5UZ1C.jpg"><link rel="shortcut icon" href="/img/favicon.png"><link rel="canonical" href="https://vcloud.ysme.top/2023/01/15/linux-docs/%E6%96%87%E4%BB%B6%E7%B3%BB%E7%BB%9F/Linux%E5%86%85%E6%A0%B8sysfs%E6%96%87%E4%BB%B6%E7%B3%BB%E7%BB%9F/index.html"><link rel="preconnect" href="//cdn.jsdelivr.net"/><link rel="preconnect" href="//busuanzi.ibruce.info"/><link rel="stylesheet" href="/css/index.css?v=4.13.0"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fortawesome/fontawesome-free@6.5.1/css/all.min.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fancyapps/ui@5.0.33/dist/fancybox/fancybox.min.css" media="print" onload="this.media='all'"><script>const GLOBAL_CONFIG = {
  root: '/',
  algolia: undefined,
  localSearch: {"path":"/search.xml","preload":false,"top_n_per_article":1,"unescape":false,"languages":{"hits_empty":"找不到您查询的内容：${query}","hits_stats":"共找到 ${hits} 篇文章"}},
  translate: undefined,
  noticeOutdate: undefined,
  highlight: {"plugin":"highlight.js","highlightCopy":true,"highlightLang":true,"highlightHeightLimit":200},
  copy: {
    success: '复制成功',
    error: '复制错误',
    noSupport: '浏览器不支持'
  },
  relativeDate: {
    homepage: false,
    post: false
  },
  runtime: '',
  dateSuffix: {
    just: '刚刚',
    min: '分钟前',
    hour: '小时前',
    day: '天前',
    month: '个月前'
  },
  copyright: undefined,
  lightbox: 'fancybox',
  Snackbar: undefined,
  infinitegrid: {
    js: 'https://cdn.jsdelivr.net/npm/@egjs/infinitegrid@4.11.1/dist/infinitegrid.min.js',
    buttonText: '加载更多'
  },
  isPhotoFigcaption: false,
  islazyload: false,
  isAnchor: false,
  percent: {
    toc: true,
    rightside: false,
  },
  autoDarkmode: false
}</script><script id="config-diff">var GLOBAL_CONFIG_SITE = {
  title: 'Linux内核sysfs文件系统',
  isPost: true,
  isHome: false,
  isHighlightShrink: false,
  isToc: false,
  postUpdate: '2024-10-28 16:31:33'
}</script><script>(win=>{
      win.saveToLocal = {
        set: (key, value, ttl) => {
          if (ttl === 0) return
          const now = Date.now()
          const expiry = now + ttl * 86400000
          const item = {
            value,
            expiry
          }
          localStorage.setItem(key, JSON.stringify(item))
        },
      
        get: key => {
          const itemStr = localStorage.getItem(key)
      
          if (!itemStr) {
            return undefined
          }
          const item = JSON.parse(itemStr)
          const now = Date.now()
      
          if (now > item.expiry) {
            localStorage.removeItem(key)
            return undefined
          }
          return item.value
        }
      }
    
      win.getScript = (url, attr = {}) => new Promise((resolve, reject) => {
        const script = document.createElement('script')
        script.src = url
        script.async = true
        script.onerror = reject
        script.onload = script.onreadystatechange = function() {
          const loadState = this.readyState
          if (loadState && loadState !== 'loaded' && loadState !== 'complete') return
          script.onload = script.onreadystatechange = null
          resolve()
        }

        Object.keys(attr).forEach(key => {
          script.setAttribute(key, attr[key])
        })

        document.head.appendChild(script)
      })
    
      win.getCSS = (url, id = false) => new Promise((resolve, reject) => {
        const link = document.createElement('link')
        link.rel = 'stylesheet'
        link.href = url
        if (id) link.id = id
        link.onerror = reject
        link.onload = link.onreadystatechange = function() {
          const loadState = this.readyState
          if (loadState && loadState !== 'loaded' && loadState !== 'complete') return
          link.onload = link.onreadystatechange = null
          resolve()
        }
        document.head.appendChild(link)
      })
    
      win.activateDarkMode = () => {
        document.documentElement.setAttribute('data-theme', 'dark')
        if (document.querySelector('meta[name="theme-color"]') !== null) {
          document.querySelector('meta[name="theme-color"]').setAttribute('content', '#0d0d0d')
        }
      }
      win.activateLightMode = () => {
        document.documentElement.setAttribute('data-theme', 'light')
        if (document.querySelector('meta[name="theme-color"]') !== null) {
          document.querySelector('meta[name="theme-color"]').setAttribute('content', '#ffffff')
        }
      }
      const t = saveToLocal.get('theme')
    
        if (t === 'dark') activateDarkMode()
        else if (t === 'light') activateLightMode()
      
      const asideStatus = saveToLocal.get('aside-status')
      if (asideStatus !== undefined) {
        if (asideStatus === 'hide') {
          document.documentElement.classList.add('hide-aside')
        } else {
          document.documentElement.classList.remove('hide-aside')
        }
      }
    
      const detectApple = () => {
        if(/iPad|iPhone|iPod|Macintosh/.test(navigator.userAgent)){
          document.documentElement.classList.add('apple')
        }
      }
      detectApple()
    })(window)</script><meta name="generator" content="Hexo 7.1.1"></head><body><div id="sidebar"><div id="menu-mask"></div><div id="sidebar-menus"><div class="avatar-img is-center"><img src="/img/avatar.jpg" onerror="onerror=null;src='/img/friend_404.gif'" alt="avatar"/></div><div class="sidebar-site-data site-data is-center"><a href="/archives/"><div class="headline">文章</div><div class="length-num">131</div></a><a href="/tags/"><div class="headline">标签</div><div class="length-num">5</div></a><a href="/categories/"><div class="headline">分类</div><div class="length-num">10</div></a></div><hr class="custom-hr"/><div class="menus_items"><div class="menus_item"><a class="site-page" href="/"><i class="fa-fw fas fa-home"></i><span> Home</span></a></div><div class="menus_item"><a class="site-page" href="/archives/"><i class="fa-fw fas fa-archive"></i><span> Archives</span></a></div><div class="menus_item"><a class="site-page" href="/tags/"><i class="fa-fw fas fa-tags"></i><span> Tags</span></a></div><div class="menus_item"><a class="site-page" href="/categories/"><i class="fa-fw fas fa-folder-open"></i><span> Categories</span></a></div><div class="menus_item"><a class="site-page group" href="javascript:void(0);"><i class="fa-fw fas fa-list"></i><span> List</span><i class="fas fa-chevron-down"></i></a><ul class="menus_item_child"><li><a class="site-page child" href="/music/"><i class="fa-fw fas fa-music"></i><span> Music</span></a></li><li><a class="site-page child" href="/movies/"><i class="fa-fw fas fa-video"></i><span> Movie</span></a></li></ul></div><div class="menus_item"><a class="site-page" href="/link/"><i class="fa-fw fas fa-link"></i><span> Link</span></a></div><div class="menus_item"><a class="site-page" href="/about/"><i class="fa-fw fas fa-heart"></i><span> About</span></a></div></div></div></div><div class="post" id="body-wrap"><header class="post-bg" id="page-header" style="background-image: url('https://i.loli.net/2020/05/01/gkihqEjXxJ5UZ1C.jpg')"><nav id="nav"><span id="blog-info"><a href="/" title="Blog"><span class="site-name">Blog</span></a></span><div id="menus"><div id="search-button"><a class="site-page social-icon search" href="javascript:void(0);"><i class="fas fa-search fa-fw"></i><span> 搜索</span></a></div><div class="menus_items"><div class="menus_item"><a class="site-page" href="/"><i class="fa-fw fas fa-home"></i><span> Home</span></a></div><div class="menus_item"><a class="site-page" href="/archives/"><i class="fa-fw fas fa-archive"></i><span> Archives</span></a></div><div class="menus_item"><a class="site-page" href="/tags/"><i class="fa-fw fas fa-tags"></i><span> Tags</span></a></div><div class="menus_item"><a class="site-page" href="/categories/"><i class="fa-fw fas fa-folder-open"></i><span> Categories</span></a></div><div class="menus_item"><a class="site-page group" href="javascript:void(0);"><i class="fa-fw fas fa-list"></i><span> List</span><i class="fas fa-chevron-down"></i></a><ul class="menus_item_child"><li><a class="site-page child" href="/music/"><i class="fa-fw fas fa-music"></i><span> Music</span></a></li><li><a class="site-page child" href="/movies/"><i class="fa-fw fas fa-video"></i><span> Movie</span></a></li></ul></div><div class="menus_item"><a class="site-page" href="/link/"><i class="fa-fw fas fa-link"></i><span> Link</span></a></div><div class="menus_item"><a class="site-page" href="/about/"><i class="fa-fw fas fa-heart"></i><span> About</span></a></div></div><div id="toggle-menu"><a class="site-page" href="javascript:void(0);"><i class="fas fa-bars fa-fw"></i></a></div></div></nav><div id="post-info"><h1 class="post-title">Linux内核sysfs文件系统</h1><div id="post-meta"><div class="meta-firstline"><span class="post-meta-date"><i class="far fa-calendar-alt fa-fw post-meta-icon"></i><span class="post-meta-label">发表于</span><time class="post-meta-date-created" datetime="2023-01-15T01:13:37.000Z" title="发表于 2023-01-15 09:13:37">2023-01-15</time><span class="post-meta-separator">|</span><i class="fas fa-history fa-fw post-meta-icon"></i><span class="post-meta-label">更新于</span><time class="post-meta-date-updated" datetime="2024-10-28T08:31:33.236Z" title="更新于 2024-10-28 16:31:33">2024-10-28</time></span><span class="post-meta-categories"><span class="post-meta-separator">|</span><i class="fas fa-inbox fa-fw post-meta-icon"></i><a class="post-meta-categories" href="/categories/linux-doc-%E6%96%87%E4%BB%B6%E7%B3%BB%E7%BB%9F/">linux-doc 文件系统</a></span></div><div class="meta-secondline"><span class="post-meta-separator">|</span><span class="post-meta-pv-cv" id="" data-flag-title="Linux内核sysfs文件系统"><i class="far fa-eye fa-fw post-meta-icon"></i><span class="post-meta-label">阅读量:</span><span id="busuanzi_value_page_pv"><i class="fa-solid fa-spinner fa-spin"></i></span></span></div></div></div></header><main class="layout" id="content-inner"><div id="post"><article class="post-content" id="article-container"><p>内核源码：linux-2.6.38.8.tar.bz2</p>
<p>目标平台：ARM体系结构</p>
<p>sysfs是基于内存的文件系统，用于向用户空间导出内核对象并且能对其进行读写。</p>
<p>1、sysfs文件系统不支持特殊文件，只支持目录、普通文件（文本或二进制文件）和符号链接文件等三种类型，在内核中都使用struct sysfs_dirent结构体来表示，相当于其他文件系统在硬盘或flash里的数据。源代码如下所示：</p>
<figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><span class="line">/* fs/sysfs/sysfs.h */</span><br><span class="line">struct sysfs_dirent &#123;</span><br><span class="line">	atomic_t		s_count;	//struct sysfs_dirent结构体实例自身的引用计数</span><br><span class="line">	atomic_t		s_active;	//struct sysfs_elem_*所涉及的外部对象的引用计数</span><br><span class="line">#ifdef CONFIG_DEBUG_LOCK_ALLOC</span><br><span class="line">	struct lockdep_map	dep_map; //死锁检测模块，针对s_attr.attr中的key或skey</span><br><span class="line">#endif</span><br><span class="line">	struct sysfs_dirent	*s_parent;	//指向父节点</span><br><span class="line">	struct sysfs_dirent	*s_sibling; //同级节点链表，插入到父节点的s_dir.children链表中</span><br><span class="line">	const char		*s_name;	//文件名</span><br><span class="line"> </span><br><span class="line">	const void		*s_ns;		//命名空间</span><br><span class="line">	union &#123;</span><br><span class="line">		struct sysfs_elem_dir		s_dir;		//目录</span><br><span class="line">		struct sysfs_elem_symlink	s_symlink;	//符号链接文件</span><br><span class="line">		struct sysfs_elem_attr		s_attr;		//文本文件</span><br><span class="line">		struct sysfs_elem_bin_attr	s_bin_attr;	//二进制文件</span><br><span class="line">	&#125;;</span><br><span class="line"> </span><br><span class="line">	unsigned int		s_flags;	//标志，表示struct sysfs_dirent类型、命名空间类型等信息</span><br><span class="line">	unsigned short		s_mode;		//文件访问权限，包含文件类型信息</span><br><span class="line">	ino_t			s_ino;			//对应于i节点号</span><br><span class="line">	struct sysfs_inode_attrs *s_iattr;	//文件属性</span><br><span class="line">&#125;;</span><br><span class="line"> </span><br><span class="line">struct sysfs_inode_attrs &#123;</span><br><span class="line">	struct iattr	ia_iattr;	//文件属性</span><br><span class="line">	void		*ia_secdata;	//安全检测模块所用数据</span><br><span class="line">	u32		ia_secdata_len;		//ia_secdata所指数据的长度</span><br><span class="line">&#125;;</span><br><span class="line"> </span><br><span class="line">/* include/linux/fs.h */</span><br><span class="line">struct iattr &#123;</span><br><span class="line">	unsigned int	ia_valid;	//文件属性标志</span><br><span class="line">	umode_t		ia_mode;		//文件类型及其访问权限</span><br><span class="line">	uid_t		ia_uid;			//用户ID</span><br><span class="line">	gid_t		ia_gid;			//组ID</span><br><span class="line">	loff_t		ia_size;		//文件大小</span><br><span class="line">	struct timespec	ia_atime;	//访问时间</span><br><span class="line">	struct timespec	ia_mtime;	//数据修改时间</span><br><span class="line">	struct timespec	ia_ctime;	//元数据修改时间</span><br><span class="line"> </span><br><span class="line">	struct file	*ia_file;	//辅助信息，用于想实现ftruncate等方法的文件系统</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>



<p><a href="https://link.zhihu.com/?target=https://so.csdn.net/so/search?q=struct&spm=1001.2101.3001.7020">struct</a> sysfs_dirent分为四种类型，如下所示：</p>
<figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">/* fs/sysfs/sysfs.h */</span><br><span class="line">struct sysfs_elem_dir &#123;</span><br><span class="line">	struct kobject		*kobj;	//指向内核对象</span><br><span class="line">	//子节点链表，只有目录才有可能包含文件或子目录</span><br><span class="line">	//子节点通过s_sibling成员以s_ino成员升序的方式插入到该链表</span><br><span class="line">	struct sysfs_dirent	*children;</span><br><span class="line">&#125;;</span><br><span class="line"> </span><br><span class="line">struct sysfs_elem_symlink &#123;</span><br><span class="line">	struct sysfs_dirent	*target_sd;	//指向所链接的节点</span><br><span class="line">&#125;;</span><br><span class="line"> </span><br><span class="line">struct sysfs_elem_attr &#123;</span><br><span class="line">	struct attribute	*attr;	//对象属性</span><br><span class="line">	struct sysfs_open_dirent *open;	//文件open信息，其中buffers成员是struct sysfs_buffer的链表</span><br><span class="line">&#125;;</span><br><span class="line"> </span><br><span class="line">struct sysfs_elem_bin_attr &#123;</span><br><span class="line">	struct bin_attribute	*bin_attr;	//二进制的对象属性</span><br><span class="line">	struct hlist_head	buffers; //struct bin_buffer的链表</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>struct sysfs_open_dirent等结构体的详细信息后文说明。</p>
<p>2、sysfs文件系统的初始化是由sysfs_init函数来完成的（该函数由vfs_caches_init函数所调用的mnt_init函数调用），执行文件系统的注册和挂载，与rootfs根文件系统的相关操作类似。源代码如下所示：</p>
<figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line">/* fs/sysfs/mount.c */</span><br><span class="line">static struct vfsmount *sysfs_mnt;</span><br><span class="line">struct kmem_cache *sysfs_dir_cachep;</span><br><span class="line"> </span><br><span class="line">int __init sysfs_init(void)</span><br><span class="line">&#123;</span><br><span class="line">	int err = -ENOMEM;</span><br><span class="line"> </span><br><span class="line">	sysfs_dir_cachep = kmem_cache_create(&quot;sysfs_dir_cache&quot;,</span><br><span class="line">					      sizeof(struct sysfs_dirent),</span><br><span class="line">					      0, 0, NULL);  //创建用于struct sysfs_dirent的高速缓存</span><br><span class="line">	if (!sysfs_dir_cachep)</span><br><span class="line">		goto out;</span><br><span class="line">	</span><br><span class="line">	//初始化后备存储介质相关结构体struct backing_dev_info（sysfs文件系统基于内存，无须数据同步）</span><br><span class="line">	err = sysfs_inode_init(); </span><br><span class="line">	if (err)</span><br><span class="line">		goto out_err;</span><br><span class="line"> </span><br><span class="line">	err = register_filesystem(&amp;sysfs_fs_type); //注册文件系统</span><br><span class="line">	if (!err) &#123; //成功返回零</span><br><span class="line">		sysfs_mnt = kern_mount(&amp;sysfs_fs_type); //挂载文件系统，不过没有将sysfs_mnt所指的结构体实例插入到挂载树中</span><br><span class="line">		if (IS_ERR(sysfs_mnt)) &#123;</span><br><span class="line">			printk(KERN_ERR &quot;sysfs: could not mount!\n&quot;);</span><br><span class="line">			err = PTR_ERR(sysfs_mnt);</span><br><span class="line">			sysfs_mnt = NULL;</span><br><span class="line">			unregister_filesystem(&amp;sysfs_fs_type);</span><br><span class="line">			goto out_err;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125; else</span><br><span class="line">		goto out_err;</span><br><span class="line">out:</span><br><span class="line">	return err;</span><br><span class="line">out_err:</span><br><span class="line">	kmem_cache_destroy(sysfs_dir_cachep);</span><br><span class="line">	sysfs_dir_cachep = NULL;</span><br><span class="line">	goto out;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>在用户空间一般都将sysfs文件系统挂载在&#x2F;sys目录，而这里也有一次通过kern_mount函数的挂载，这样的话 sysfs文件系统就会挂载两次？其实是没有的，后者的挂载并没有将当前的struct vfsmount结构体实例插入到挂载树中，而是保存在全局指针sysfs_mnt中，并且会与用户空间挂载sysfs文件系统时所创建的struct vfsmount结构体实例共享相同的超级块。因此，无论用户空间的挂载操作是否执行，sysfs文件系统都会存在于内核之中（编译内核有配置CONFIG_SYSFS选项）。sysfs文件系统的struct file_system_type结构体实例如下所示：</p>
<figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line">/* fs/sysfs/mount.c */</span><br><span class="line">static struct file_system_type sysfs_fs_type = &#123;</span><br><span class="line">	.name		= &quot;sysfs&quot;,</span><br><span class="line">	.mount		= sysfs_mount,</span><br><span class="line">	.kill_sb	= sysfs_kill_sb,</span><br><span class="line">&#125;;</span><br><span class="line"> </span><br><span class="line">static struct dentry *sysfs_mount(struct file_system_type *fs_type,</span><br><span class="line">	int flags, const char *dev_name, void *data)</span><br><span class="line">&#123;</span><br><span class="line">	struct sysfs_super_info *info;</span><br><span class="line">	enum kobj_ns_type type;</span><br><span class="line">	struct super_block *sb;</span><br><span class="line">	int error;</span><br><span class="line"> </span><br><span class="line">	info = kzalloc(sizeof(*info), GFP_KERNEL); //分配私有数据所用内存</span><br><span class="line">	if (!info)</span><br><span class="line">		return ERR_PTR(-ENOMEM);</span><br><span class="line">	</span><br><span class="line">	//构建超级块私有数据，用于sysfs_test_super和sysfs_set_super函数</span><br><span class="line">	for (type = KOBJ_NS_TYPE_NONE; type &lt; KOBJ_NS_TYPES; type++) </span><br><span class="line">		info-&gt;ns[type] = kobj_ns_current(type);</span><br><span class="line"> </span><br><span class="line">	sb = sget(fs_type, sysfs_test_super, sysfs_set_super, info); //查找或创建超级块</span><br><span class="line">	if (IS_ERR(sb) || sb-&gt;s_fs_info != info)  </span><br><span class="line">		kfree(info);</span><br><span class="line">	if (IS_ERR(sb))</span><br><span class="line">		return ERR_CAST(sb);</span><br><span class="line">	if (!sb-&gt;s_root) &#123; //如果根目录项为空指针，则说明超级块sb是新创建的</span><br><span class="line">		sb-&gt;s_flags = flags;</span><br><span class="line">		error = sysfs_fill_super(sb, data, flags &amp; MS_SILENT ? 1 : 0); //填充超级块</span><br><span class="line">		if (error) &#123;</span><br><span class="line">			deactivate_locked_super(sb);</span><br><span class="line">			return ERR_PTR(error);</span><br><span class="line">		&#125;</span><br><span class="line">		sb-&gt;s_flags |= MS_ACTIVE;</span><br><span class="line">	&#125;</span><br><span class="line"> </span><br><span class="line">	return dget(sb-&gt;s_root);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<p>其中，sysfs_test_super函数用于判断struct sysfs_super_info结构体数据是否相同以便确认是否可以共享超级块，源代码如下所示：</p>
<figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line">/* include/linux/kobject_ns.h */</span><br><span class="line">enum kobj_ns_type &#123;</span><br><span class="line">	KOBJ_NS_TYPE_NONE = 0,</span><br><span class="line">	KOBJ_NS_TYPE_NET,</span><br><span class="line">	KOBJ_NS_TYPES</span><br><span class="line">&#125;;</span><br><span class="line"> </span><br><span class="line">/* fs/sysfs/sysfs.h */</span><br><span class="line">struct sysfs_super_info &#123;</span><br><span class="line">	const void *ns[KOBJ_NS_TYPES];</span><br><span class="line">&#125;;</span><br><span class="line"> </span><br><span class="line">/* fs/sysfs/mount.c */</span><br><span class="line">static int sysfs_test_super(struct super_block *sb, void *data)</span><br><span class="line">&#123;</span><br><span class="line">	struct sysfs_super_info *sb_info = sysfs_info(sb); //sb-&gt;s_fs_info</span><br><span class="line">	struct sysfs_super_info *info = data;</span><br><span class="line">	enum kobj_ns_type type;</span><br><span class="line">	int found = 1;</span><br><span class="line"> </span><br><span class="line">	for (type = KOBJ_NS_TYPE_NONE; type &lt; KOBJ_NS_TYPES; type++) &#123;</span><br><span class="line">		if (sb_info-&gt;ns[type] != info-&gt;ns[type]) //只要有任何一项的值不相同则函数返回0</span><br><span class="line">			found = 0;</span><br><span class="line">	&#125;</span><br><span class="line">	return found;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>sysfs_fill_super函数主要用于创建sysfs文件系统根目录所对应的目录项及其i节点，并且将sysfs_root作为根目录项的私有数据。源代码如下所示：</p>
<figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br></pre></td><td class="code"><pre><span class="line">/* fs/sysfs/mount.c */</span><br><span class="line">static int sysfs_fill_super(struct super_block *sb, void *data, int silent)</span><br><span class="line">&#123;</span><br><span class="line">	struct inode *inode;</span><br><span class="line">	struct dentry *root;</span><br><span class="line"> </span><br><span class="line">	sb-&gt;s_blocksize = PAGE_CACHE_SIZE; //与内存页大小相同</span><br><span class="line">	sb-&gt;s_blocksize_bits = PAGE_CACHE_SHIFT;</span><br><span class="line">	sb-&gt;s_magic = SYSFS_MAGIC;</span><br><span class="line">	sb-&gt;s_op = &amp;sysfs_ops;</span><br><span class="line">	sb-&gt;s_time_gran = 1;</span><br><span class="line"></span><br><span class="line">	//创建并初始化根目录的i节点</span><br><span class="line">	mutex_lock(&amp;sysfs_mutex);</span><br><span class="line">	inode = sysfs_get_inode(sb, &amp;sysfs_root);</span><br><span class="line">	mutex_unlock(&amp;sysfs_mutex);</span><br><span class="line">	if (!inode) &#123;</span><br><span class="line">		pr_debug(&quot;sysfs: could not get root inode\n&quot;);</span><br><span class="line">		return -ENOMEM;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	//创建并初始化sysfs文件系统的根目录项并关联根目录的i节点</span><br><span class="line">	root = d_alloc_root(inode);</span><br><span class="line">	if (!root) &#123;</span><br><span class="line">		pr_debug(&quot;%s: could not get root dentry!\n&quot;,__func__);</span><br><span class="line">		iput(inode);</span><br><span class="line">		return -ENOMEM;</span><br><span class="line">	&#125;</span><br><span class="line">	root-&gt;d_fsdata = &amp;sysfs_root;  //根目录项的d_fsdata成员指向sysfs文件系统的根数据项sysfs_root</span><br><span class="line">	sb-&gt;s_root = root;</span><br><span class="line">	return 0;</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line">struct sysfs_dirent sysfs_root = &#123;</span><br><span class="line">	.s_name		= &quot;&quot;,</span><br><span class="line">	.s_count	= ATOMIC_INIT(1),</span><br><span class="line">	.s_flags	= SYSFS_DIR | (KOBJ_NS_TYPE_NONE &lt;&lt; SYSFS_NS_TYPE_SHIFT),</span><br><span class="line">	.s_mode		= S_IFDIR | S_IRWXU | S_IRUGO | S_IXUGO, //目录文件，访问权限0755</span><br><span class="line">	.s_ino		= 1,   //起始i节点号为1</span><br><span class="line">&#125;;</span><br><span class="line"> </span><br><span class="line">static const struct super_operations sysfs_ops = &#123; //超级块操作函数</span><br><span class="line">    .statfs        = simple_statfs,</span><br><span class="line">    .drop_inode    = generic_delete_inode,</span><br><span class="line">    .evict_inode    = sysfs_evict_inode,</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>3、文件系统最核心的内容是要看其i节点是如何构建的，sysfs文件系统使用sysfs_init_inode函数来创建。源代码如下所示：</p>
<figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br></pre></td><td class="code"><pre><span class="line">/* fs/sysfs/inode.c */</span><br><span class="line">static void sysfs_init_inode(struct sysfs_dirent *sd, struct inode *inode)</span><br><span class="line">&#123;</span><br><span class="line">	struct bin_attribute *bin_attr;</span><br><span class="line"> </span><br><span class="line">	inode-&gt;i_private = sysfs_get(sd); //指向引用计数递增之后的sd</span><br><span class="line">	inode-&gt;i_mapping-&gt;a_ops = &amp;sysfs_aops; //地址空间操作函数</span><br><span class="line">	inode-&gt;i_mapping-&gt;backing_dev_info = &amp;sysfs_backing_dev_info; //后备存储介质的相关信息</span><br><span class="line">	inode-&gt;i_op = &amp;sysfs_inode_operations;</span><br><span class="line"> </span><br><span class="line">	set_default_inode_attr(inode, sd-&gt;s_mode);</span><br><span class="line">	sysfs_refresh_inode(sd, inode);</span><br><span class="line"></span><br><span class="line">	switch (sysfs_type(sd)) &#123; //struct sysfs_dirent类型</span><br><span class="line">	case SYSFS_DIR: //目录</span><br><span class="line">		inode-&gt;i_op = &amp;sysfs_dir_inode_operations;</span><br><span class="line">		inode-&gt;i_fop = &amp;sysfs_dir_operations;</span><br><span class="line">		break;</span><br><span class="line">	case SYSFS_KOBJ_ATTR: //文本文件</span><br><span class="line">		inode-&gt;i_size = PAGE_SIZE; //文件大小固定为一页内存</span><br><span class="line">		inode-&gt;i_fop = &amp;sysfs_file_operations;</span><br><span class="line">		break;</span><br><span class="line">	case SYSFS_KOBJ_BIN_ATTR: //二进制文件</span><br><span class="line">		bin_attr = sd-&gt;s_bin_attr.bin_attr;</span><br><span class="line">		inode-&gt;i_size = bin_attr-&gt;size;</span><br><span class="line">		inode-&gt;i_fop = &amp;bin_fops;</span><br><span class="line">		break;</span><br><span class="line">	case SYSFS_KOBJ_LINK: //符号链接文件</span><br><span class="line">		inode-&gt;i_op = &amp;sysfs_symlink_inode_operations;</span><br><span class="line">		break;</span><br><span class="line">	default:</span><br><span class="line">		BUG();</span><br><span class="line">	&#125;</span><br><span class="line"> </span><br><span class="line">	unlock_new_inode(inode);</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line">static inline void set_default_inode_attr(struct inode * inode, mode_t mode)</span><br><span class="line">&#123;</span><br><span class="line">	inode-&gt;i_mode = mode;</span><br><span class="line">	inode-&gt;i_atime = inode-&gt;i_mtime = inode-&gt;i_ctime = CURRENT_TIME;</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line">static void sysfs_refresh_inode(struct sysfs_dirent *sd, struct inode *inode)</span><br><span class="line">&#123;</span><br><span class="line">	struct sysfs_inode_attrs *iattrs = sd-&gt;s_iattr;</span><br><span class="line"> </span><br><span class="line">	inode-&gt;i_mode = sd-&gt;s_mode;</span><br><span class="line">	if (iattrs) &#123; //sd-&gt;s_iattr为真</span><br><span class="line">		//从iattrs-&gt;ia_iattr拷贝ia_uid、ia_gid、ia_atime、ia_mtime和ia_ctime等成员的值给i节点相应的成员</span><br><span class="line">		set_inode_attr(inode, &amp;iattrs-&gt;ia_iattr); </span><br><span class="line">		security_inode_notifysecctx(inode,</span><br><span class="line">					    iattrs-&gt;ia_secdata,</span><br><span class="line">					    iattrs-&gt;ia_secdata_len); //安全检测模块</span><br><span class="line">	&#125;</span><br><span class="line"> </span><br><span class="line">	if (sysfs_type(sd) == SYSFS_DIR)</span><br><span class="line">		inode-&gt;i_nlink = sysfs_count_nlink(sd); //计算目录的硬链接数目（等于子目录数+2）</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>四种structsysfs_dirent类型对应三种文件类型，其中SYSFS_KOBJ_ATTR和SYSFS_KOBJ_BIN_ATTR都为普通文件。文件系统针对不同的文件类型，i节点操作函数（struct inode_operations）和文件内容操作函数（struct file_operations）都会有不同的实现，并且其中的函数也是根据文件类型来决定是否实现（大部分成员为空指针）。</p>
<p>3.1、目录的i节点操作函数和文件内容操作函数分别为sysfs_dir_inode_operations和sysfs_dir_operations，其中i节点操作函数的create、mkdir和rmdir等成员都为空指针，表示sysfs文件系统的目录或文件无法从用户空间通过系统调用来创建和删除。对于sysfs文件系统中的目录来说，i节点操作函数最重要的是查找函数sysfs_lookup，文件内容操作函数最重要的是遍历目录函数sysfs_readdir。源代码如下所示：</p>
<figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br></pre></td><td class="code"><pre><span class="line">/* fs/sysfs/dir.c */</span><br><span class="line">const struct inode_operations sysfs_dir_inode_operations = &#123;</span><br><span class="line">	.lookup		= sysfs_lookup,</span><br><span class="line">	.permission	= sysfs_permission,</span><br><span class="line">	.setattr	= sysfs_setattr,</span><br><span class="line">	.getattr	= sysfs_getattr,</span><br><span class="line">	.setxattr	= sysfs_setxattr,</span><br><span class="line">&#125;;</span><br><span class="line"> </span><br><span class="line">const struct file_operations sysfs_dir_operations = &#123;</span><br><span class="line">	.read		= generic_read_dir,</span><br><span class="line">	.readdir	= sysfs_readdir,</span><br><span class="line">	.release	= sysfs_dir_release,</span><br><span class="line">	.llseek		= generic_file_llseek,</span><br><span class="line">&#125;;</span><br><span class="line"> </span><br><span class="line">static struct dentry * sysfs_lookup(struct inode *dir, struct dentry *dentry,</span><br><span class="line">				struct nameidata *nd) //dir为父目录的i节点，dentry为被查找对象的目录项(这时为d_alloc函数操作之后的状态)</span><br><span class="line">&#123;</span><br><span class="line">	struct dentry *ret = NULL;</span><br><span class="line">	struct dentry *parent = dentry-&gt;d_parent; //父目录项</span><br><span class="line">	struct sysfs_dirent *parent_sd = parent-&gt;d_fsdata;</span><br><span class="line">	struct sysfs_dirent *sd;</span><br><span class="line">	struct inode *inode;</span><br><span class="line">	enum kobj_ns_type type;</span><br><span class="line">	const void *ns;</span><br><span class="line"> </span><br><span class="line">	mutex_lock(&amp;sysfs_mutex);</span><br><span class="line"></span><br><span class="line">	//获取命名空间</span><br><span class="line">	type = sysfs_ns_type(parent_sd);</span><br><span class="line">	ns = sysfs_info(dir-&gt;i_sb)-&gt;ns[type];</span><br><span class="line"></span><br><span class="line">	//从其parent_sd-&gt;s_dir.children链表中查找相同命名空间并且名字相同的子项</span><br><span class="line">	sd = sysfs_find_dirent(parent_sd, ns, dentry-&gt;d_name.name);</span><br><span class="line">	if (!sd) &#123; //该子项不存在</span><br><span class="line">		ret = ERR_PTR(-ENOENT);</span><br><span class="line">		goto out_unlock;</span><br><span class="line">	&#125;</span><br><span class="line"> </span><br><span class="line">	//从inode_hashtable哈希表中查找该子项对应的i节点，若不存在则构建一个新的i节点实例</span><br><span class="line">	inode = sysfs_get_inode(dir-&gt;i_sb, sd);</span><br><span class="line">	if (!inode) &#123; //构建失败</span><br><span class="line">		ret = ERR_PTR(-ENOMEM);</span><br><span class="line">		goto out_unlock;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	//对于目录来说，只能有一个目录项，并且只有在其为空目录或者为当前文件系统的根目录时才有可能被设置DCACHE_UNHASHED状态</span><br><span class="line">	//当i节点为IS_ROOT和DCACHE_DISCONNECTED时，d_find_alias函数返回真</span><br><span class="line">	ret = d_find_alias(inode);</span><br><span class="line">	if (!ret) &#123;</span><br><span class="line">		d_set_d_op(dentry, &amp;sysfs_dentry_ops); //sysfs_dentry_ops为sysfs文件系统目录项的操作函数</span><br><span class="line">		dentry-&gt;d_fsdata = sysfs_get(sd);</span><br><span class="line">		d_add(dentry, inode);	//调用d_instantiate函数将目录项dentry插入到inode-&gt;i_dentry链表并且dentry-&gt;d_inode指向i节点inode</span><br><span class="line">								//调用d_rehash函数将目录项dentry插入到dentry_hashtable哈希表中</span><br><span class="line">	&#125; else &#123;</span><br><span class="line">		d_move(ret, dentry); //重新使用所返回的目录项ret并与目录项dentry交换d_name等数据</span><br><span class="line">		iput(inode); //销毁i节点</span><br><span class="line">	&#125;</span><br><span class="line"> </span><br><span class="line"> out_unlock:</span><br><span class="line">	mutex_unlock(&amp;sysfs_mutex);</span><br><span class="line">	return ret;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>对于目录来说，只能有一个目录项别名。</p>
<figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br></pre></td><td class="code"><pre><span class="line">/* fs/sysfs/dir.c */</span><br><span class="line">static int sysfs_readdir(struct file * filp, void * dirent, filldir_t filldir)</span><br><span class="line">&#123;</span><br><span class="line">	struct dentry *dentry = filp-&gt;f_path.dentry; //当前目录所对应的目录项</span><br><span class="line">	struct sysfs_dirent * parent_sd = dentry-&gt;d_fsdata;</span><br><span class="line">	struct sysfs_dirent *pos = filp-&gt;private_data;</span><br><span class="line">	enum kobj_ns_type type;</span><br><span class="line">	const void *ns;</span><br><span class="line">	ino_t ino;</span><br><span class="line"></span><br><span class="line">	//获取命名空间</span><br><span class="line">	type = sysfs_ns_type(parent_sd);</span><br><span class="line">	ns = sysfs_info(dentry-&gt;d_sb)-&gt;ns[type];</span><br><span class="line"></span><br><span class="line">	//当前目录</span><br><span class="line">	if (filp-&gt;f_pos == 0) &#123;</span><br><span class="line">		ino = parent_sd-&gt;s_ino;</span><br><span class="line">		if (filldir(dirent, &quot;.&quot;, 1, filp-&gt;f_pos, ino, DT_DIR) == 0)</span><br><span class="line">			filp-&gt;f_pos++;</span><br><span class="line">	&#125;</span><br><span class="line">	//父目录</span><br><span class="line">	if (filp-&gt;f_pos == 1) &#123;</span><br><span class="line">		if (parent_sd-&gt;s_parent)</span><br><span class="line">			ino = parent_sd-&gt;s_parent-&gt;s_ino;</span><br><span class="line">		else</span><br><span class="line">			ino = parent_sd-&gt;s_ino; //文件系统根目录将自身当作父目录</span><br><span class="line">		if (filldir(dirent, &quot;..&quot;, 2, filp-&gt;f_pos, ino, DT_DIR) == 0)</span><br><span class="line">			filp-&gt;f_pos++;</span><br><span class="line">	&#125;</span><br><span class="line">	mutex_lock(&amp;sysfs_mutex);</span><br><span class="line">	for (pos = sysfs_dir_pos(ns, parent_sd, filp-&gt;f_pos, pos); //这时filp-&gt;f_pos等于2，pos为NULL</span><br><span class="line">	     pos;</span><br><span class="line">	     pos = sysfs_dir_next_pos(ns, parent_sd, filp-&gt;f_pos, pos)) &#123; //遍历当前目录</span><br><span class="line">		const char * name;</span><br><span class="line">		unsigned int type;</span><br><span class="line">		int len, ret;</span><br><span class="line"> </span><br><span class="line">		name = pos-&gt;s_name;</span><br><span class="line">		len = strlen(name);</span><br><span class="line">		ino = pos-&gt;s_ino;</span><br><span class="line">		type = dt_type(pos); //文件类型</span><br><span class="line">		filp-&gt;f_pos = ino; //将i节点号作为上一个struct linux_dirent实例中d_off成员的值</span><br><span class="line">		filp-&gt;private_data = sysfs_get(pos);</span><br><span class="line"> </span><br><span class="line">		mutex_unlock(&amp;sysfs_mutex);</span><br><span class="line">		ret = filldir(dirent, name, len, filp-&gt;f_pos, ino, type);</span><br><span class="line">		mutex_lock(&amp;sysfs_mutex);</span><br><span class="line">		if (ret &lt; 0)</span><br><span class="line">			break;</span><br><span class="line">	&#125;</span><br><span class="line">	mutex_unlock(&amp;sysfs_mutex);</span><br><span class="line">	if ((filp-&gt;f_pos &gt; 1) &amp;&amp; !pos) &#123; //遍历完全</span><br><span class="line">		filp-&gt;f_pos = INT_MAX;</span><br><span class="line">		filp-&gt;private_data = NULL;</span><br><span class="line">	&#125;</span><br><span class="line">	return 0;</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line">static struct sysfs_dirent *sysfs_dir_pos(const void *ns,</span><br><span class="line">	struct sysfs_dirent *parent_sd,	ino_t ino, struct sysfs_dirent *pos)</span><br><span class="line">&#123;</span><br><span class="line">	if (pos) &#123;</span><br><span class="line">		int valid = !(pos-&gt;s_flags &amp; SYSFS_FLAG_REMOVED) &amp;&amp; //非SYSFS_FLAG_REMOVED项</span><br><span class="line">			pos-&gt;s_parent == parent_sd &amp;&amp;  //属于目录parent_sd</span><br><span class="line">			ino == pos-&gt;s_ino;</span><br><span class="line">		sysfs_put(pos);</span><br><span class="line">		if (!valid)</span><br><span class="line">			pos = NULL; //重新遍历该目录</span><br><span class="line">	&#125;</span><br><span class="line">	if (!pos &amp;&amp; (ino &gt; 1) &amp;&amp; (ino &lt; INT_MAX)) &#123; //这时pos为空指针，且i节点号的大小在有效范围内</span><br><span class="line">		pos = parent_sd-&gt;s_dir.children;</span><br><span class="line">		while (pos &amp;&amp; (ino &gt; pos-&gt;s_ino)) //过滤掉i节点号比它小的</span><br><span class="line">			pos = pos-&gt;s_sibling;</span><br><span class="line">	&#125;</span><br><span class="line">	while (pos &amp;&amp; pos-&gt;s_ns &amp;&amp; pos-&gt;s_ns != ns) //过滤掉不是相同命名空间的</span><br><span class="line">		pos = pos-&gt;s_sibling;</span><br><span class="line">	return pos;</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line">static struct sysfs_dirent *sysfs_dir_next_pos(const void *ns,</span><br><span class="line">	struct sysfs_dirent *parent_sd,	ino_t ino, struct sysfs_dirent *pos)</span><br><span class="line">&#123;</span><br><span class="line">	pos = sysfs_dir_pos(ns, parent_sd, ino, pos);</span><br><span class="line">	if (pos)</span><br><span class="line">		pos = pos-&gt;s_sibling; //获取下一个项</span><br><span class="line">	while (pos &amp;&amp; pos-&gt;s_ns &amp;&amp; pos-&gt;s_ns != ns)</span><br><span class="line">		pos = pos-&gt;s_sibling;</span><br><span class="line">	return pos;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>当在用户空间通过ls等命令查看sysfs文件系统的目录时，会通过系统调用getdents调用vfs_readdir，然后再调用sysfs_readdir函数。其中参数filp表示该目录打开之后的文件指针，dirent实际为struct getdents_callback类型的数据，filldir为回调函数指针，指向同名的filldir函数。源代码如下所示：</p>
<figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br></pre></td><td class="code"><pre><span class="line">/* include/linux/kernel.h */</span><br><span class="line">#define __ALIGN_KERNEL(x, a)		__ALIGN_KERNEL_MASK(x, (typeof(x))(a) - 1)</span><br><span class="line">#define __ALIGN_KERNEL_MASK(x, mask)	(((x) + (mask)) &amp; ~(mask))</span><br><span class="line">#define ALIGN(x, a)		__ALIGN_KERNEL((x), (a))</span><br><span class="line"> </span><br><span class="line">/* include/linux/compiler-gcc4.h */</span><br><span class="line">#define __compiler_offsetof(a,b) __builtin_offsetof(a,b)  //GCC编译器内置函数，计算成员偏移量</span><br><span class="line"> </span><br><span class="line">/* include/linux/stddef.h */</span><br><span class="line">#undef offsetof</span><br><span class="line">#ifdef __compiler_offsetof</span><br><span class="line">#define offsetof(TYPE,MEMBER) __compiler_offsetof(TYPE,MEMBER)</span><br><span class="line">#else</span><br><span class="line">#define offsetof(TYPE, MEMBER) ((size_t) &amp;((TYPE *)0)-&gt;MEMBER)</span><br><span class="line">#endif</span><br><span class="line"> </span><br><span class="line">/* fs/readdir.c */</span><br><span class="line">struct linux_dirent &#123;</span><br><span class="line">	unsigned long	d_ino; //i节点号</span><br><span class="line">	unsigned long	d_off; //偏移量，无实际意义，在sysfs文件系统的实现中，它的值为上一个所遍历的文件或目录的i节点号（最后一个为INT_MAX）</span><br><span class="line">	unsigned short	d_reclen; //整个struct linux_dirent实例的长度（经过对齐修正）</span><br><span class="line">	char		d_name[1]; //文件名，大小由实际文件名的长度决定（空字符结尾）</span><br><span class="line">&#125;;</span><br><span class="line"> </span><br><span class="line">struct getdents_callback &#123;</span><br><span class="line">	struct linux_dirent __user * current_dir;	//初始化为系统调用传入的内存地址</span><br><span class="line">	struct linux_dirent __user * previous;		//指向上一个struct linux_dirent实例</span><br><span class="line">	int count;	//初始化为系统调用传入的内存的总大小（字节数）</span><br><span class="line">	int error;	//保存错误码</span><br><span class="line">&#125;;</span><br><span class="line"> </span><br><span class="line">static int filldir(void * __buf, const char * name, int namlen, loff_t offset,</span><br><span class="line">		   u64 ino, unsigned int d_type)</span><br><span class="line">&#123;</span><br><span class="line">	struct linux_dirent __user * dirent;</span><br><span class="line">	struct getdents_callback * buf = (struct getdents_callback *) __buf;</span><br><span class="line">	unsigned long d_ino;</span><br><span class="line">	//功能等效于(len / sizeof(long) + (len % sizeof(long) ? 1 : 0)) * sizeof(long)，其中len为ALIGN的第一个参数的值</span><br><span class="line">	int reclen = ALIGN(offsetof(struct linux_dirent, d_name) + namlen + 2,	//其中加2个字节的意义是：一个字节用来存储字符串的结束符，</span><br><span class="line">		sizeof(long)); 														//另一个字节用来存储文件类型。</span><br><span class="line"> </span><br><span class="line">	buf-&gt;error = -EINVAL;</span><br><span class="line">	if (reclen &gt; buf-&gt;count) //剩余的内存不够</span><br><span class="line">		return -EINVAL;</span><br><span class="line">	d_ino = ino;</span><br><span class="line">	if (sizeof(d_ino) &lt; sizeof(ino) &amp;&amp; d_ino != ino) &#123; //d_ino的数据类型较小且导致数据溢出</span><br><span class="line">		buf-&gt;error = -EOVERFLOW;</span><br><span class="line">		return -EOVERFLOW;</span><br><span class="line">	&#125;</span><br><span class="line">	dirent = buf-&gt;previous;</span><br><span class="line">	if (dirent) &#123;</span><br><span class="line">		if (__put_user(offset, &amp;dirent-&gt;d_off)) //以当前的offset值填充上一个struct linux_dirent实例的d_off成员</span><br><span class="line">			goto efault;</span><br><span class="line">	&#125;</span><br><span class="line">	dirent = buf-&gt;current_dir;</span><br><span class="line">	if (__put_user(d_ino, &amp;dirent-&gt;d_ino)) //i节点号</span><br><span class="line">		goto efault;</span><br><span class="line">	if (__put_user(reclen, &amp;dirent-&gt;d_reclen)) //当前struct linux_dirent实例的总大小（字节数）</span><br><span class="line">		goto efault;</span><br><span class="line">	if (copy_to_user(dirent-&gt;d_name, name, namlen)) //拷贝文件名</span><br><span class="line">		goto efault;</span><br><span class="line">	if (__put_user(0, dirent-&gt;d_name + namlen)) //在文件名后加字符串结束符&#x27;\0&#x27;</span><br><span class="line">		goto efault;</span><br><span class="line">	if (__put_user(d_type, (char __user *) dirent + reclen - 1)) //最后一个字节用来保存文件类型信息</span><br><span class="line">		goto efault;</span><br><span class="line">	buf-&gt;previous = dirent;</span><br><span class="line">	dirent = (void __user *)dirent + reclen;</span><br><span class="line">	buf-&gt;current_dir = dirent; //指向下一个尚未使用的struct linux_dirent实例</span><br><span class="line">	buf-&gt;count -= reclen; //计算剩余内存数量</span><br><span class="line">	return 0;</span><br><span class="line">efault:</span><br><span class="line">	buf-&gt;error = -EFAULT;</span><br><span class="line">	return -EFAULT;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>3.2、sysfs文件系统针对文本文件和二进制文件实现了不同的文件内容操作函数，而i节点操作函数则相同。源代码如下所示：</p>
<figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line">/* fs/sysfs/inode.c */</span><br><span class="line">static const struct inode_operations sysfs_inode_operations =&#123;</span><br><span class="line">	.permission	= sysfs_permission,</span><br><span class="line">	.setattr	= sysfs_setattr,</span><br><span class="line">	.getattr	= sysfs_getattr,</span><br><span class="line">	.setxattr	= sysfs_setxattr,</span><br><span class="line">&#125;;</span><br><span class="line"> </span><br><span class="line">/* fs/sysfs/file.c */</span><br><span class="line">const struct file_operations sysfs_file_operations = &#123; //文本文件</span><br><span class="line">	.read		= sysfs_read_file,</span><br><span class="line">	.write		= sysfs_write_file,</span><br><span class="line">	.llseek		= generic_file_llseek,</span><br><span class="line">	.open		= sysfs_open_file,</span><br><span class="line">	.release	= sysfs_release,</span><br><span class="line">	.poll		= sysfs_poll,</span><br><span class="line">&#125;;</span><br><span class="line"> </span><br><span class="line">/* fs/sysfs/bin.c */</span><br><span class="line">const struct file_operations bin_fops = &#123; //二进制文件</span><br><span class="line">	.read		= read,</span><br><span class="line">	.write		= write,</span><br><span class="line">	.mmap		= mmap,</span><br><span class="line">	.llseek		= generic_file_llseek,</span><br><span class="line">	.open		= open,</span><br><span class="line">	.release	= release,</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>针对普通文件，最重要的是观察它的文件内容操作函数的实现，如open、read和write等函数。下面则以文本文件为例，看看sysfs文件系统是如何读写文件的。源代码如下所示：</p>
<figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br></pre></td><td class="code"><pre><span class="line">/* include/linux/limits.h */</span><br><span class="line">#define PATH_MAX        4096</span><br><span class="line"> </span><br><span class="line">/* fs/sysfs/file.c */</span><br><span class="line">static char last_sysfs_file[PATH_MAX];</span><br><span class="line"> </span><br><span class="line">static int sysfs_open_file(struct inode *inode, struct file *file)</span><br><span class="line">&#123;</span><br><span class="line">	struct sysfs_dirent *attr_sd = file-&gt;f_path.dentry-&gt;d_fsdata; //sysfs数据项，表示当前被打开的文件</span><br><span class="line">	struct kobject *kobj = attr_sd-&gt;s_parent-&gt;s_dir.kobj; //所属目录所对应的内核对象</span><br><span class="line">	struct sysfs_buffer *buffer;</span><br><span class="line">	const struct sysfs_ops *ops;</span><br><span class="line">	int error = -EACCES;</span><br><span class="line">	char *p;</span><br><span class="line"></span><br><span class="line">	//获得该文件的全路径并依次保存在last_sysfs_file数组的尾部</span><br><span class="line">	p = d_path(&amp;file-&gt;f_path, last_sysfs_file, sizeof(last_sysfs_file));</span><br><span class="line">	if (!IS_ERR(p))</span><br><span class="line">		memmove(last_sysfs_file, p, strlen(p) + 1); //将路径移动到数组的开头</span><br><span class="line">	</span><br><span class="line">	//获取活动引用计数</span><br><span class="line">	if (!sysfs_get_active(attr_sd))</span><br><span class="line">		return -ENODEV;</span><br><span class="line">	</span><br><span class="line">	if (kobj-&gt;ktype &amp;&amp; kobj-&gt;ktype-&gt;sysfs_ops) //内核对象针对所属属性的读写函数必须存在</span><br><span class="line">		ops = kobj-&gt;ktype-&gt;sysfs_ops;</span><br><span class="line">	else &#123;</span><br><span class="line">		WARN(1, KERN_ERR &quot;missing sysfs attribute operations for &quot;</span><br><span class="line">		       &quot;kobject: %s\n&quot;, kobject_name(kobj));</span><br><span class="line">		goto err_out;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	if (file-&gt;f_mode &amp; FMODE_WRITE) &#123; //写文件</span><br><span class="line">		if (!(inode-&gt;i_mode &amp; S_IWUGO) || !ops-&gt;store) //需S_IWUGO访问权限且store函数必须定义</span><br><span class="line">			goto err_out;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	if (file-&gt;f_mode &amp; FMODE_READ) &#123; //读文件</span><br><span class="line">		if (!(inode-&gt;i_mode &amp; S_IRUGO) || !ops-&gt;show) //需S_IRUGO访问权限且show函数必须定义</span><br><span class="line">			goto err_out;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	//每次打开的文本文件都对应一个struct sysfs_buffer实例</span><br><span class="line">	error = -ENOMEM;</span><br><span class="line">	buffer = kzalloc(sizeof(struct sysfs_buffer), GFP_KERNEL);</span><br><span class="line">	if (!buffer)</span><br><span class="line">		goto err_out;</span><br><span class="line"> </span><br><span class="line">	mutex_init(&amp;buffer-&gt;mutex);</span><br><span class="line">	buffer-&gt;needs_read_fill = 1;</span><br><span class="line">	buffer-&gt;ops = ops;</span><br><span class="line">	file-&gt;private_data = buffer; //保存在文件指针的私有数据中</span><br><span class="line"> </span><br><span class="line">	//分配struct sysfs_open_dirent结构体实例</span><br><span class="line">	error = sysfs_get_open_dirent(attr_sd, buffer);</span><br><span class="line">	if (error)</span><br><span class="line">		goto err_free;</span><br><span class="line">	</span><br><span class="line">	//打开成功，释放活动引用计数</span><br><span class="line">	sysfs_put_active(attr_sd);</span><br><span class="line">	return 0;</span><br><span class="line"> </span><br><span class="line"> err_free:</span><br><span class="line">	kfree(buffer);</span><br><span class="line"> err_out:</span><br><span class="line">	sysfs_put_active(attr_sd);</span><br><span class="line">	return error;</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line">static DEFINE_SPINLOCK(sysfs_open_dirent_lock);</span><br><span class="line"> </span><br><span class="line">static int sysfs_get_open_dirent(struct sysfs_dirent *sd,</span><br><span class="line">				 struct sysfs_buffer *buffer)</span><br><span class="line">&#123;</span><br><span class="line">	struct sysfs_open_dirent *od, *new_od = NULL;</span><br><span class="line"> </span><br><span class="line"> retry:</span><br><span class="line">	spin_lock_irq(&amp;sysfs_open_dirent_lock);</span><br><span class="line"> </span><br><span class="line">	if (!sd-&gt;s_attr.open &amp;&amp; new_od) &#123; //每个文本文件的struct sysfs_dirent都有一个open成员</span><br><span class="line">		sd-&gt;s_attr.open = new_od; //指向新分配并初始化的struct sysfs_open_dirent实例</span><br><span class="line">		new_od = NULL;</span><br><span class="line">	&#125;</span><br><span class="line"> </span><br><span class="line">	od = sd-&gt;s_attr.open;</span><br><span class="line">	if (od) &#123;</span><br><span class="line">		atomic_inc(&amp;od-&gt;refcnt); //递增引用计数</span><br><span class="line">		//将buffer作为链表元素插入到od-&gt;buffers链表（该链表中元素的数量就是该文本文件正被打开的次数）</span><br><span class="line">		list_add_tail(&amp;buffer-&gt;list, &amp;od-&gt;buffers); </span><br><span class="line">	&#125;</span><br><span class="line"> </span><br><span class="line">	spin_unlock_irq(&amp;sysfs_open_dirent_lock);</span><br><span class="line"> </span><br><span class="line">	if (od) &#123;</span><br><span class="line">		kfree(new_od);</span><br><span class="line">		return 0;</span><br><span class="line">	&#125;</span><br><span class="line"> </span><br><span class="line">	//为struct sysfs_open_dirent结构体实例分配内存</span><br><span class="line">	new_od = kmalloc(sizeof(*new_od), GFP_KERNEL);</span><br><span class="line">	if (!new_od)</span><br><span class="line">		return -ENOMEM;</span><br><span class="line">	</span><br><span class="line">	//初始化成员</span><br><span class="line">	atomic_set(&amp;new_od-&gt;refcnt, 0);</span><br><span class="line">	atomic_set(&amp;new_od-&gt;event, 1);</span><br><span class="line">	init_waitqueue_head(&amp;new_od-&gt;poll);</span><br><span class="line">	INIT_LIST_HEAD(&amp;new_od-&gt;buffers);</span><br><span class="line">	goto retry;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>在sysfs文件系统中，文本文件使用struct sysfs_elem_attr来表示，而该结构体有一个struct sysfs_open_dirent类型的open成员，主要用于管理每次打开并读&#x2F;写该文件时所使用的内存（struct sysfs_buffer）。源代码如下所示：</p>
<figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">/* fs/sysfs/file.c */</span><br><span class="line">struct sysfs_open_dirent &#123;</span><br><span class="line">	atomic_t		refcnt; //打开次数</span><br><span class="line">	atomic_t		event;</span><br><span class="line">	wait_queue_head_t	poll; //等待队列</span><br><span class="line">	struct list_head	buffers; //sysfs_buffer.list的链表</span><br><span class="line">&#125;;</span><br><span class="line"> </span><br><span class="line">struct sysfs_buffer &#123;</span><br><span class="line">	size_t			count;	//数据大小（字节数）</span><br><span class="line">	loff_t			pos;	//偏移量</span><br><span class="line">	char			* page;	//指向一页内存，用于存储数据</span><br><span class="line">	const struct sysfs_ops	* ops;	//操作函数</span><br><span class="line">	struct mutex		mutex;		//互斥锁</span><br><span class="line">	int			needs_read_fill;	//是否已填充数据</span><br><span class="line">	int			event;</span><br><span class="line">	struct list_head	list;	//插入所属的struct sysfs_open_dirent的buffers链表</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>sysfs_read_file为sysfs文件系统文本文件的读函数，源代码如下所示：</p>
<figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br></pre></td><td class="code"><pre><span class="line">/* fs/sysfs/file.c */</span><br><span class="line">static ssize_t</span><br><span class="line">sysfs_read_file(struct file *file, char __user *buf, size_t count, loff_t *ppos)</span><br><span class="line">&#123;</span><br><span class="line">	struct sysfs_buffer * buffer = file-&gt;private_data;  //调用sysfs_open_file时所生成的</span><br><span class="line">	ssize_t retval = 0;</span><br><span class="line"> </span><br><span class="line">	mutex_lock(&amp;buffer-&gt;mutex);</span><br><span class="line">	if (buffer-&gt;needs_read_fill || *ppos == 0) &#123; //尚未获取数据或者文件偏移量为零</span><br><span class="line">		retval = fill_read_buffer(file-&gt;f_path.dentry,buffer); //一次读取</span><br><span class="line">		if (retval) //获取数据失败（返回零表示成功）</span><br><span class="line">			goto out;</span><br><span class="line">	&#125;</span><br><span class="line">	pr_debug(&quot;%s: count = %zd, ppos = %lld, buf = %s\n&quot;,</span><br><span class="line">		 __func__, count, *ppos, buffer-&gt;page);</span><br><span class="line">		 </span><br><span class="line">	//将count个字节的数据拷贝到用户空间内存buf，buffer-&gt;count表示可拷贝数据的最大字节数（可能须要多次拷贝才能读取完整个内存）</span><br><span class="line">	retval = simple_read_from_buffer(buf, count, ppos, buffer-&gt;page,</span><br><span class="line">					 buffer-&gt;count); </span><br><span class="line">out:</span><br><span class="line">	mutex_unlock(&amp;buffer-&gt;mutex);</span><br><span class="line">	return retval;</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line">static int fill_read_buffer(struct dentry * dentry, struct sysfs_buffer * buffer)</span><br><span class="line">&#123;</span><br><span class="line">	struct sysfs_dirent *attr_sd = dentry-&gt;d_fsdata; //sysfs数据项</span><br><span class="line">	struct kobject *kobj = attr_sd-&gt;s_parent-&gt;s_dir.kobj; //所属内核对象</span><br><span class="line">	const struct sysfs_ops * ops = buffer-&gt;ops;</span><br><span class="line">	int ret = 0;</span><br><span class="line">	ssize_t count;</span><br><span class="line"> </span><br><span class="line">	if (!buffer-&gt;page) //分配存储数据的内存</span><br><span class="line">		buffer-&gt;page = (char *) get_zeroed_page(GFP_KERNEL);</span><br><span class="line">	if (!buffer-&gt;page) //内存分配失败</span><br><span class="line">		return -ENOMEM;</span><br><span class="line">	</span><br><span class="line">	if (!sysfs_get_active(attr_sd)) //获取活动引用计数</span><br><span class="line">		return -ENODEV;</span><br><span class="line"> </span><br><span class="line">	buffer-&gt;event = atomic_read(&amp;attr_sd-&gt;s_attr.open-&gt;event);</span><br><span class="line">	count = ops-&gt;show(kobj, attr_sd-&gt;s_attr.attr, buffer-&gt;page);  //从该内核对象相应的属性中获取数据并保存到刚才所分配的内存中</span><br><span class="line"> </span><br><span class="line">	sysfs_put_active(attr_sd); //释放活动引用计数</span><br><span class="line"></span><br><span class="line">	if (count &gt;= (ssize_t)PAGE_SIZE) &#123; //至多能读取PAGE_SIZE - 1个字节</span><br><span class="line">		print_symbol(&quot;fill_read_buffer: %s returned bad count\n&quot;,</span><br><span class="line">			(unsigned long)ops-&gt;show);</span><br><span class="line">		/* Try to struggle along */</span><br><span class="line">		count = PAGE_SIZE - 1;</span><br><span class="line">	&#125;</span><br><span class="line">	if (count &gt;= 0) &#123;</span><br><span class="line">		buffer-&gt;needs_read_fill = 0; //表示填充过数据</span><br><span class="line">		buffer-&gt;count = count;</span><br><span class="line">	&#125; else &#123;</span><br><span class="line">		ret = count; //获取失败</span><br><span class="line">	&#125;</span><br><span class="line">	return ret;</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line">/* fs/libfs.c */</span><br><span class="line">ssize_t simple_read_from_buffer(void __user *to, size_t count, loff_t *ppos,</span><br><span class="line">				const void *from, size_t available)</span><br><span class="line">&#123;</span><br><span class="line">	loff_t pos = *ppos;</span><br><span class="line">	size_t ret;</span><br><span class="line"> </span><br><span class="line">	if (pos &lt; 0) //文件偏移量不能为负数</span><br><span class="line">		return -EINVAL;</span><br><span class="line">	if (pos &gt;= available || !count) //已无数据可读或者是想读取零个字节</span><br><span class="line">		return 0;</span><br><span class="line">	if (count &gt; available - pos)  //只剩available - pos个字节</span><br><span class="line">		count = available - pos;</span><br><span class="line">	ret = copy_to_user(to, from + pos, count); //拷贝数据</span><br><span class="line">	if (ret == count) //返回值为没有拷贝成功的字节数</span><br><span class="line">		return -EFAULT;</span><br><span class="line">	count -= ret; //获得count个字节的数据</span><br><span class="line">	*ppos = pos + count; //更新文件偏移量</span><br><span class="line">	return count;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>sysfs_write_file为sysfs文件系统的写函数，源代码如下所示：</p>
<figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br></pre></td><td class="code"><pre><span class="line">/* fs/sysfs/file.c */</span><br><span class="line">static ssize_t</span><br><span class="line">sysfs_write_file(struct file *file, const char __user *buf, size_t count, loff_t *ppos) //ppos为文件偏移量</span><br><span class="line">&#123;</span><br><span class="line">	struct sysfs_buffer * buffer = file-&gt;private_data; //调用sysfs_open_file时所生成的</span><br><span class="line">	ssize_t len;</span><br><span class="line"> </span><br><span class="line">	mutex_lock(&amp;buffer-&gt;mutex);</span><br><span class="line">	len = fill_write_buffer(buffer, buf, count); //一次写入，从用户空间内存buf中拷贝count个字节到内核空间</span><br><span class="line">	if (len &gt; 0) //成功拷贝len个字节</span><br><span class="line">		len = flush_write_buffer(file-&gt;f_path.dentry, buffer, len); //根据获得的数据更新该内核对象相应的属性</span><br><span class="line">	if (len &gt; 0)</span><br><span class="line">		*ppos += len; //更改文件偏移量，对buffer-&gt;page中的数据无意义，后面写入的数据会覆盖前面写入的数据</span><br><span class="line">	mutex_unlock(&amp;buffer-&gt;mutex);</span><br><span class="line">	return len;</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line">static int </span><br><span class="line">fill_write_buffer(struct sysfs_buffer * buffer, const char __user * buf, size_t count)</span><br><span class="line">&#123;</span><br><span class="line">	int error;</span><br><span class="line"> </span><br><span class="line">	if (!buffer-&gt;page) //分配存储数据的内存</span><br><span class="line">		buffer-&gt;page = (char *)get_zeroed_page(GFP_KERNEL);</span><br><span class="line">	if (!buffer-&gt;page) //内存分配失败</span><br><span class="line">		return -ENOMEM;</span><br><span class="line"> </span><br><span class="line">	if (count &gt;= PAGE_SIZE) //写入的数据最多只能为PAGE_SIZE - 1个字节</span><br><span class="line">		count = PAGE_SIZE - 1;</span><br><span class="line">	error = copy_from_user(buffer-&gt;page,buf,count); //拷贝数据，成功函数返回零</span><br><span class="line">	buffer-&gt;needs_read_fill = 1;</span><br><span class="line">	buffer-&gt;page[count] = 0; //字符串结束符&#x27;\0&#x27;</span><br><span class="line">	return error ? -EFAULT : count;</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line">static int</span><br><span class="line">flush_write_buffer(struct dentry * dentry, struct sysfs_buffer * buffer, size_t count)</span><br><span class="line">&#123;</span><br><span class="line">	struct sysfs_dirent *attr_sd = dentry-&gt;d_fsdata; //sysfs数据项，这里表示一个文本文件</span><br><span class="line">	struct kobject *kobj = attr_sd-&gt;s_parent-&gt;s_dir.kobj; //所属内核对象</span><br><span class="line">	const struct sysfs_ops * ops = buffer-&gt;ops;</span><br><span class="line">	int rc;</span><br><span class="line"> </span><br><span class="line">	if (!sysfs_get_active(attr_sd)) //获取活动引用计数</span><br><span class="line">		return -ENODEV;</span><br><span class="line"> </span><br><span class="line">	rc = ops-&gt;store(kobj, attr_sd-&gt;s_attr.attr, buffer-&gt;page, count); //调用store函数</span><br><span class="line"> </span><br><span class="line">	sysfs_put_active(attr_sd); //释放活动引用计数</span><br><span class="line"> </span><br><span class="line">	return rc;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>关闭文件时，打开、读&#x2F;写文件时所分配的内存都会释放，并不会一直存在于内核中。</p>
<p>3.3、对于符号链接文件来说，它没有文件内容操作函数，只有i节点操作函数，其中最重要的函数为符号链接文件的解析函数sysfs_follow_link，源代码如下所示：</p>
<figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br></pre></td><td class="code"><pre><span class="line">/* fs/sysfs/symlink.c */</span><br><span class="line">const struct inode_operations sysfs_symlink_inode_operations = &#123;</span><br><span class="line">	.setxattr	= sysfs_setxattr,</span><br><span class="line">	.readlink	= generic_readlink,</span><br><span class="line">	.follow_link	= sysfs_follow_link,</span><br><span class="line">	.put_link	= sysfs_put_link,</span><br><span class="line">	.setattr	= sysfs_setattr,</span><br><span class="line">	.getattr	= sysfs_getattr,</span><br><span class="line">	.permission	= sysfs_permission,</span><br><span class="line">&#125;;</span><br><span class="line"> </span><br><span class="line">static void *sysfs_follow_link(struct dentry *dentry, struct nameidata *nd)</span><br><span class="line">&#123;</span><br><span class="line">	int error = -ENOMEM;</span><br><span class="line">	unsigned long page = get_zeroed_page(GFP_KERNEL); //分配内存</span><br><span class="line">	if (page) &#123;</span><br><span class="line">		error = sysfs_getlink(dentry, (char *) page); </span><br><span class="line">		if (error &lt; 0)  //成功时sysfs_getlink返回零</span><br><span class="line">			free_page((unsigned long)page);</span><br><span class="line">	&#125;</span><br><span class="line">	nd_set_link(nd, error ? ERR_PTR(error) : (char *)page); //保存获得的相对路径或错误码</span><br><span class="line">	return NULL;</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line">static int sysfs_getlink(struct dentry *dentry, char * path)</span><br><span class="line">&#123;</span><br><span class="line">	struct sysfs_dirent *sd = dentry-&gt;d_fsdata; //sysfs数据项</span><br><span class="line">	struct sysfs_dirent *parent_sd = sd-&gt;s_parent; //父sysfs数据项</span><br><span class="line">	struct sysfs_dirent *target_sd = sd-&gt;s_symlink.target_sd; //所链接到的sysfs数据项</span><br><span class="line">	int error;</span><br><span class="line"> </span><br><span class="line">	mutex_lock(&amp;sysfs_mutex);</span><br><span class="line">	error = sysfs_get_target_path(parent_sd, target_sd, path); //获取从链接文件到链接对象的相对路径</span><br><span class="line">	mutex_unlock(&amp;sysfs_mutex);</span><br><span class="line"> </span><br><span class="line">	return error;</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line">//sysfs链接文件是两个内核对象之间的链接，也就是目录之间的链接</span><br><span class="line">static int sysfs_get_target_path(struct sysfs_dirent *parent_sd,</span><br><span class="line">				 struct sysfs_dirent *target_sd, char *path)</span><br><span class="line">&#123;</span><br><span class="line">	struct sysfs_dirent *base, *sd;</span><br><span class="line">	char *s = path;</span><br><span class="line">	int len = 0;</span><br><span class="line"></span><br><span class="line">	base = parent_sd;</span><br><span class="line">	while (base-&gt;s_parent) &#123; //sysfs的根数据项为sysfs_root，该数据项的s_parent成员为空指针</span><br><span class="line">		sd = target_sd-&gt;s_parent;</span><br><span class="line">		while (sd-&gt;s_parent &amp;&amp; base != sd)  //如果base一直不等于sd，则循环直到根数据项才会停止</span><br><span class="line">			sd = sd-&gt;s_parent;</span><br><span class="line"> </span><br><span class="line">		if (base == sd) //两者相等，这时链接文件和被链接对象的直接或间接的父目录相同</span><br><span class="line">			break;</span><br><span class="line"> </span><br><span class="line">		strcpy(s, &quot;../&quot;);  //拷贝字符串“../”，意味着两者不是同在这一目录下</span><br><span class="line">		s += 3;</span><br><span class="line">		base = base-&gt;s_parent; //接下来将比较链接文件的上一级目录的数据项</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	//这时，base已指向链接文件和被链接对象首个共有的直接或间接的父目录的数据项</span><br><span class="line"></span><br><span class="line">	//计算整个路径的长度</span><br><span class="line">	sd = target_sd;</span><br><span class="line">	while (sd-&gt;s_parent &amp;&amp; sd != base) &#123;</span><br><span class="line">		len += strlen(sd-&gt;s_name) + 1; //其中的加1表示目录项分隔符“/”所占的字节</span><br><span class="line">		sd = sd-&gt;s_parent;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	if (len &lt; 2) //名称为空字符串</span><br><span class="line">		return -EINVAL;</span><br><span class="line">	len--; //减去一个多余的目录项分隔符所占的字节</span><br><span class="line">	if ((s - path) + len &gt; PATH_MAX) //总长度超过path数组的大小</span><br><span class="line">		return -ENAMETOOLONG;</span><br><span class="line"> </span><br><span class="line">	//从被链接对象开始以倒序的方式拷贝目录项名称，直到base数据项（但不包括它的）</span><br><span class="line">	sd = target_sd;</span><br><span class="line">	while (sd-&gt;s_parent &amp;&amp; sd != base) &#123;</span><br><span class="line">		int slen = strlen(sd-&gt;s_name);</span><br><span class="line"> </span><br><span class="line">		len -= slen;</span><br><span class="line">		strncpy(s + len, sd-&gt;s_name, slen); //拷贝名称</span><br><span class="line">		if (len) //等于0时表示最后一个名称的前面不需要再加分隔符</span><br><span class="line">			s[--len] = &#x27;/&#x27;; //在该名称前加目录项分隔符“/”</span><br><span class="line"> </span><br><span class="line">		sd = sd-&gt;s_parent; //接着处理上一级目录</span><br><span class="line">	&#125;</span><br><span class="line"> </span><br><span class="line">	return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>读取符号链接文件内容的函数generic_readlink主要就是靠解析函数来实现的，源代码如下所示：</p>
<figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line">/* fs/namei.c */</span><br><span class="line">int generic_readlink(struct dentry *dentry, char __user *buffer, int buflen)</span><br><span class="line">&#123;</span><br><span class="line">	struct nameidata nd;</span><br><span class="line">	void *cookie;</span><br><span class="line">	int res;</span><br><span class="line"> </span><br><span class="line">	nd.depth = 0;</span><br><span class="line">	cookie = dentry-&gt;d_inode-&gt;i_op-&gt;follow_link(dentry, &amp;nd);</span><br><span class="line">	if (IS_ERR(cookie)) //返回错误码</span><br><span class="line">		return PTR_ERR(cookie);</span><br><span class="line"> </span><br><span class="line">	res = vfs_readlink(dentry, buffer, buflen, nd_get_link(&amp;nd)); //通过nd_get_link获取follow_link保存的路径或错误码</span><br><span class="line">	if (dentry-&gt;d_inode-&gt;i_op-&gt;put_link)</span><br><span class="line">		dentry-&gt;d_inode-&gt;i_op-&gt;put_link(dentry, &amp;nd, cookie); //这里put_link指向sysfs_put_link函数</span><br><span class="line">	return res;</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line">int vfs_readlink(struct dentry *dentry, char __user *buffer, int buflen, const char *link)</span><br><span class="line">&#123;</span><br><span class="line">	int len;</span><br><span class="line"> </span><br><span class="line">	len = PTR_ERR(link);</span><br><span class="line">	if (IS_ERR(link)) //这里的link也有可能是错误码</span><br><span class="line">		goto out;</span><br><span class="line"> </span><br><span class="line">	len = strlen(link);</span><br><span class="line">	if (len &gt; (unsigned) buflen) //路径长度比传入的内存大</span><br><span class="line">		len = buflen;</span><br><span class="line">	if (copy_to_user(buffer, link, len)) //拷贝到用户空间内存（但不包括字符串结束符）</span><br><span class="line">		len = -EFAULT;</span><br><span class="line">out:</span><br><span class="line">	return len;</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line">/* fs/sysfs/symlink.c */</span><br><span class="line">static void sysfs_put_link(struct dentry *dentry, struct nameidata *nd, void *cookie)</span><br><span class="line">&#123;</span><br><span class="line">	char *page = nd_get_link(nd);</span><br><span class="line">	if (!IS_ERR(page)) //非错误码</span><br><span class="line">		free_page((unsigned long)page); //释放内存</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>其中，sysfs_put_link函数执行与sysfs_follow_link函数相反的操作，这里只是释放由sysfs_follow_link函数分配的内存。</p>
<p>4、对于sysfs文件系统来说，在用户空间只能读写文件的内容，而无法创建或删除文件或目录，只能在内核中通过sysfs_create_dir、sysfs_create_file等等函数来实现。</p>
<p>4.1、内核对象（struct kobject）对应于sysfs文件系统中的目录，可使用sysfs_create_dir函数来创建，源代码如下所示：</p>
<figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br></pre></td><td class="code"><pre><span class="line">/* fs/sysfs/dir.c */</span><br><span class="line">int sysfs_create_dir(struct kobject * kobj)</span><br><span class="line">&#123;</span><br><span class="line">	enum kobj_ns_type type;</span><br><span class="line">	struct sysfs_dirent *parent_sd, *sd;</span><br><span class="line">	const void *ns = NULL;</span><br><span class="line">	int error = 0;</span><br><span class="line"> </span><br><span class="line">	BUG_ON(!kobj);</span><br><span class="line"> </span><br><span class="line">	if (kobj-&gt;parent) //父内核对象为空时，则在sysfs文件系统的根目录下创建目录</span><br><span class="line">		parent_sd = kobj-&gt;parent-&gt;sd;</span><br><span class="line">	else</span><br><span class="line">		parent_sd = &amp;sysfs_root;</span><br><span class="line">	</span><br><span class="line">	//获取命名空间及其类型</span><br><span class="line">	if (sysfs_ns_type(parent_sd))</span><br><span class="line">		ns = kobj-&gt;ktype-&gt;namespace(kobj);</span><br><span class="line">	type = sysfs_read_ns_type(kobj);</span><br><span class="line"> </span><br><span class="line">	error = create_dir(kobj, parent_sd, type, ns, kobject_name(kobj), &amp;sd);</span><br><span class="line">	if (!error) //成功则返回零</span><br><span class="line">		kobj-&gt;sd = sd;  //保存相应的sysfs数据项</span><br><span class="line">	return error;</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line">/* include/linux/kobject.h */</span><br><span class="line">static inline const char *kobject_name(const struct kobject *kobj)</span><br><span class="line">&#123;</span><br><span class="line">	return kobj-&gt;name;</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line">/* fs/sysfs/dir.c */</span><br><span class="line">static int create_dir(struct kobject *kobj, struct sysfs_dirent *parent_sd,</span><br><span class="line">	enum kobj_ns_type type, const void *ns, const char *name,</span><br><span class="line">	struct sysfs_dirent **p_sd)</span><br><span class="line">&#123;</span><br><span class="line">	umode_t mode = S_IFDIR| S_IRWXU | S_IRUGO | S_IXUGO; //文件类型为目录，访问权限为0755</span><br><span class="line">	struct sysfs_addrm_cxt acxt;</span><br><span class="line">	struct sysfs_dirent *sd;</span><br><span class="line">	int rc;</span><br><span class="line"> </span><br><span class="line">	//分配sysfs数据项并初始化</span><br><span class="line">	sd = sysfs_new_dirent(name, mode, SYSFS_DIR); //数据项类型为目录</span><br><span class="line">	if (!sd)</span><br><span class="line">		return -ENOMEM;</span><br><span class="line"> </span><br><span class="line">	sd-&gt;s_flags |= (type &lt;&lt; SYSFS_NS_TYPE_SHIFT); //命名空间类型，占用s_flags倒数第二个8位</span><br><span class="line">	sd-&gt;s_ns = ns; //命名空间</span><br><span class="line">	sd-&gt;s_dir.kobj = kobj; //关联内核对象</span><br><span class="line"></span><br><span class="line">	sysfs_addrm_start(&amp;acxt, parent_sd); //加锁并携带父数据项</span><br><span class="line">	rc = sysfs_add_one(&amp;acxt, sd); //关联父数据项</span><br><span class="line">	sysfs_addrm_finish(&amp;acxt); //解锁</span><br><span class="line"> </span><br><span class="line">	if (rc == 0)  //成功返回</span><br><span class="line">		*p_sd = sd;</span><br><span class="line">	else</span><br><span class="line">		sysfs_put(sd); //释放数据项</span><br><span class="line"> </span><br><span class="line">	return rc;</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line">struct sysfs_dirent *sysfs_new_dirent(const char *name, umode_t mode, int type)</span><br><span class="line">&#123;</span><br><span class="line">	char *dup_name = NULL;</span><br><span class="line">	struct sysfs_dirent *sd;</span><br><span class="line"> </span><br><span class="line">	if (type &amp; SYSFS_COPY_NAME) &#123; //目录或符号链接文件需要拷贝文件名，它们对应的都是内核对象</span><br><span class="line">		name = dup_name = kstrdup(name, GFP_KERNEL); //分配内存并拷贝文件名</span><br><span class="line">		if (!name) //当不为空指针时则表示name指向新分配的内存</span><br><span class="line">			return NULL;</span><br><span class="line">	&#125;</span><br><span class="line"> </span><br><span class="line">	sd = kmem_cache_zalloc(sysfs_dir_cachep, GFP_KERNEL); //从sysfs_dir_cachep缓存中分配sysfs数据项</span><br><span class="line">	if (!sd)</span><br><span class="line">		goto err_out1;</span><br><span class="line"> </span><br><span class="line">	if (sysfs_alloc_ino(&amp;sd-&gt;s_ino)) //分配i节点号</span><br><span class="line">		goto err_out2;</span><br><span class="line">	</span><br><span class="line">	//引用计数</span><br><span class="line">	atomic_set(&amp;sd-&gt;s_count, 1);</span><br><span class="line">	atomic_set(&amp;sd-&gt;s_active, 0);</span><br><span class="line"> </span><br><span class="line">	sd-&gt;s_name = name; //目录项名称</span><br><span class="line">	sd-&gt;s_mode = mode; //文件类型及访问权限</span><br><span class="line">	sd-&gt;s_flags = type; //sysfs数据项类型，占用s_flags低8位</span><br><span class="line"> </span><br><span class="line">	return sd;</span><br><span class="line"> </span><br><span class="line"> err_out2:</span><br><span class="line">	kmem_cache_free(sysfs_dir_cachep, sd);</span><br><span class="line"> err_out1:</span><br><span class="line">	kfree(dup_name);</span><br><span class="line">	return NULL;</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line">int sysfs_add_one(struct sysfs_addrm_cxt *acxt, struct sysfs_dirent *sd)</span><br><span class="line">&#123;</span><br><span class="line">	int ret;</span><br><span class="line"> </span><br><span class="line">	ret = __sysfs_add_one(acxt, sd);</span><br><span class="line">	if (ret == -EEXIST) &#123; //同名数据项已经存在则输出告警信息</span><br><span class="line">		char *path = kzalloc(PATH_MAX, GFP_KERNEL);</span><br><span class="line">		WARN(1, KERN_WARNING</span><br><span class="line">		     &quot;sysfs: cannot create duplicate filename &#x27;%s&#x27;\n&quot;,</span><br><span class="line">		     (path == NULL) ? sd-&gt;s_name :</span><br><span class="line">		     strcat(strcat(sysfs_pathname(acxt-&gt;parent_sd, path), &quot;/&quot;),</span><br><span class="line">		            sd-&gt;s_name)); //数据项的全路径</span><br><span class="line">		kfree(path);</span><br><span class="line">	&#125;</span><br><span class="line"> </span><br><span class="line">	return ret;</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line">int __sysfs_add_one(struct sysfs_addrm_cxt *acxt, struct sysfs_dirent *sd)</span><br><span class="line">&#123;</span><br><span class="line">	struct sysfs_inode_attrs *ps_iattr;</span><br><span class="line"> </span><br><span class="line">	if (sysfs_find_dirent(acxt-&gt;parent_sd, sd-&gt;s_ns, sd-&gt;s_name)) //查找该父目录下是否存在同名的数据项</span><br><span class="line">		return -EEXIST; //已存在则返回错误码</span><br><span class="line"> </span><br><span class="line">	sd-&gt;s_parent = sysfs_get(acxt-&gt;parent_sd); //递增父数据项的引用计数，然后指向该父数据项</span><br><span class="line"> </span><br><span class="line">	sysfs_link_sibling(sd); //加入到父数据项的子数据项链表</span><br><span class="line"> </span><br><span class="line">	//更新父数据项的时间戳</span><br><span class="line">	ps_iattr = acxt-&gt;parent_sd-&gt;s_iattr;</span><br><span class="line">	if (ps_iattr) &#123;</span><br><span class="line">		struct iattr *ps_iattrs = &amp;ps_iattr-&gt;ia_iattr;</span><br><span class="line">		ps_iattrs-&gt;ia_ctime = ps_iattrs-&gt;ia_mtime = CURRENT_TIME;</span><br><span class="line">	&#125;</span><br><span class="line"> </span><br><span class="line">	return 0;</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line">struct sysfs_dirent *sysfs_find_dirent(struct sysfs_dirent *parent_sd,</span><br><span class="line">				       const void *ns,</span><br><span class="line">				       const unsigned char *name)</span><br><span class="line">&#123;</span><br><span class="line">	struct sysfs_dirent *sd;</span><br><span class="line"> </span><br><span class="line">	for (sd = parent_sd-&gt;s_dir.children; sd; sd = sd-&gt;s_sibling) &#123; //遍历父目录</span><br><span class="line">		if (ns &amp;&amp; sd-&gt;s_ns &amp;&amp; (sd-&gt;s_ns != ns)) //查找同一命名空间</span><br><span class="line">			continue;</span><br><span class="line">		if (!strcmp(sd-&gt;s_name, name)) //同名sysfs数据项</span><br><span class="line">			return sd;</span><br><span class="line">	&#125;</span><br><span class="line">	return NULL;</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line">static void sysfs_link_sibling(struct sysfs_dirent *sd)</span><br><span class="line">&#123;</span><br><span class="line">	struct sysfs_dirent *parent_sd = sd-&gt;s_parent;</span><br><span class="line">	struct sysfs_dirent **pos;</span><br><span class="line"> </span><br><span class="line">	BUG_ON(sd-&gt;s_sibling);</span><br><span class="line"> </span><br><span class="line">	for (pos = &amp;parent_sd-&gt;s_dir.children; *pos; pos = &amp;(*pos)-&gt;s_sibling) &#123;</span><br><span class="line">		if (sd-&gt;s_ino &lt; (*pos)-&gt;s_ino) //升序排列</span><br><span class="line">			break;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	sd-&gt;s_sibling = *pos;</span><br><span class="line">	*pos = sd;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>4.2、内核对象的属性（struct attribute）对应于sysfs文件系统中的文本文件，可使用sysfs_create_file函数来创建，源代码如下所示：</p>
<figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line">/* fs/sysfs/file.c */</span><br><span class="line">int sysfs_create_file(struct kobject * kobj, const struct attribute * attr)</span><br><span class="line">&#123;</span><br><span class="line">	BUG_ON(!kobj || !kobj-&gt;sd || !attr); //三者必须为真</span><br><span class="line"> </span><br><span class="line">	return sysfs_add_file(kobj-&gt;sd, attr, SYSFS_KOBJ_ATTR); //数据项类型为SYSFS_KOBJ_ATTR，对应sysfs文件系统中的文本文件</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line">int sysfs_add_file(struct sysfs_dirent *dir_sd, const struct attribute *attr,</span><br><span class="line">		   int type)</span><br><span class="line">&#123;</span><br><span class="line">	return sysfs_add_file_mode(dir_sd, attr, type, attr-&gt;mode); //访问权限由内核对象的属性自身配置</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line">int sysfs_add_file_mode(struct sysfs_dirent *dir_sd,</span><br><span class="line">			const struct attribute *attr, int type, mode_t amode)</span><br><span class="line">&#123;</span><br><span class="line">	umode_t mode = (amode &amp; S_IALLUGO) | S_IFREG; //文件类型为普通文件</span><br><span class="line">	struct sysfs_addrm_cxt acxt;</span><br><span class="line">	struct sysfs_dirent *sd;</span><br><span class="line">	int rc;</span><br><span class="line"></span><br><span class="line">	//分配sysfs数据项并初始化</span><br><span class="line">	sd = sysfs_new_dirent(attr-&gt;name, mode, type);</span><br><span class="line">	if (!sd)</span><br><span class="line">		return -ENOMEM;</span><br><span class="line">	sd-&gt;s_attr.attr = (void *)attr; //保存内核对象属性</span><br><span class="line">	sysfs_dirent_init_lockdep(sd); //初始化死锁检测模块</span><br><span class="line"> </span><br><span class="line">	sysfs_addrm_start(&amp;acxt, dir_sd); //dir_sd对应于属性文件所在的目录</span><br><span class="line">	rc = sysfs_add_one(&amp;acxt, sd);</span><br><span class="line">	sysfs_addrm_finish(&amp;acxt);</span><br><span class="line"> </span><br><span class="line">	if (rc) //失败则销毁sysfs数据项</span><br><span class="line">		sysfs_put(sd);</span><br><span class="line"> </span><br><span class="line">	return rc;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>sysfs文件系统中的二进制文件通过sysfs_create_bin_file函数来创建，符号链接文件通过sysfs_create_link函数来创建。</p>
<hr>
<p>版权声明：本文为知乎博主「Linux内核库」的原创文章，遵循CC 4.0 BY-SA版权协议，转载请附上原文 出处链接及本声明。</p>
<p>原文链接：<a target="_blank" rel="noopener" href="https://zhuanlan.zhihu.com/p/558497992">https://zhuanlan.zhihu.com/p/558497992</a></p>
</article><div class="post-copyright"><div class="post-copyright__author"><span class="post-copyright-meta"><i class="fas fa-circle-user fa-fw"></i>文章作者: </span><span class="post-copyright-info"><a href="https://vcloud.ysme.top">ysme</a></span></div><div class="post-copyright__type"><span class="post-copyright-meta"><i class="fas fa-square-arrow-up-right fa-fw"></i>文章链接: </span><span class="post-copyright-info"><a href="https://vcloud.ysme.top/2023/01/15/linux-docs/%E6%96%87%E4%BB%B6%E7%B3%BB%E7%BB%9F/Linux%E5%86%85%E6%A0%B8sysfs%E6%96%87%E4%BB%B6%E7%B3%BB%E7%BB%9F/">https://vcloud.ysme.top/2023/01/15/linux-docs/%E6%96%87%E4%BB%B6%E7%B3%BB%E7%BB%9F/Linux%E5%86%85%E6%A0%B8sysfs%E6%96%87%E4%BB%B6%E7%B3%BB%E7%BB%9F/</a></span></div><div class="post-copyright__notice"><span class="post-copyright-meta"><i class="fas fa-circle-exclamation fa-fw"></i>版权声明: </span><span class="post-copyright-info">本博客所有文章除特别声明外，均采用 <a href="https://creativecommons.org/licenses/by-nc-sa/4.0/" target="_blank">CC BY-NC-SA 4.0</a> 许可协议。转载请注明来自 <a href="https://vcloud.ysme.top" target="_blank">Blog</a>！</span></div></div><div class="tag_share"><div class="post-meta__tag-list"><a class="post-meta__tags" href="/tags/Linux/">Linux</a></div><div class="post_share"><div class="social-share" data-image="https://i.loli.net/2020/05/01/gkihqEjXxJ5UZ1C.jpg" data-sites="facebook,twitter,wechat,weibo,qq"></div><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/butterfly-extsrc@1.1.3/sharejs/dist/css/share.min.css" media="print" onload="this.media='all'"><script src="https://cdn.jsdelivr.net/npm/butterfly-extsrc@1.1.3/sharejs/dist/js/social-share.min.js" defer></script></div></div><nav class="pagination-post" id="pagination"><div class="prev-post pull-left"><a href="/2023/01/15/linux-docs/%E6%96%87%E4%BB%B6%E7%B3%BB%E7%BB%9F/Linux%20%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E5%8E%9F%E7%90%86-%E6%96%87%E4%BB%B6%E7%B3%BB%E7%BB%9F(2)/" title="Linux 操作系统原理-文件系统(2)"><img class="cover" src="https://i.loli.net/2020/05/01/gkihqEjXxJ5UZ1C.jpg" onerror="onerror=null;src='/img/404.jpg'" alt="cover of previous post"><div class="pagination-info"><div class="label">上一篇</div><div class="prev_info">Linux 操作系统原理-文件系统(2)</div></div></a></div><div class="next-post pull-right"><a href="/2023/01/15/linux-docs/%E6%96%87%E4%BB%B6%E7%B3%BB%E7%BB%9F/Linux%E5%86%85%E6%A0%B8%E5%8A%A0%E5%AF%86%E6%96%87%E4%BB%B6%E7%B3%BB%E7%BB%9F%EF%BC%88eCryptfs%EF%BC%89/" title="Linux内核加密文件系统（eCryptfs）"><img class="cover" src="https://i.loli.net/2020/05/01/gkihqEjXxJ5UZ1C.jpg" onerror="onerror=null;src='/img/404.jpg'" alt="cover of next post"><div class="pagination-info"><div class="label">下一篇</div><div class="next_info">Linux内核加密文件系统（eCryptfs）</div></div></a></div></nav><div class="relatedPosts"><div class="headline"><i class="fas fa-thumbs-up fa-fw"></i><span>相关推荐</span></div><div class="relatedPosts-list"><div><a href="/2023/01/15/linux-docs/30%E5%88%86%E9%92%9F%E5%AD%A6%E4%BC%9A%E7%BC%96%E8%AF%91linux%E5%86%85%E6%A0%B8/" title="Linux 30分钟学会编译linux内核"><img class="cover" src="https://pic2.zhimg.com/80/v2-99c76217f4575d98a9001a4fd8c1681d_720w.webp" alt="cover"><div class="content is-center"><div class="date"><i class="far fa-calendar-alt fa-fw"></i> 2023-01-15</div><div class="title">Linux 30分钟学会编译linux内核</div></div></a></div><div><a href="/2023/01/15/linux-docs/Linux%20IO%20%E4%B9%8B%20IO%E4%B8%8E%E7%BD%91%E7%BB%9C%E6%A8%A1%E5%9E%8B/" title="Linux IO 之 IO与网络模型"><img class="cover" src="https://user-images.githubusercontent.com/87457873/127649604-761ead2e-8c72-4876-a52f-8310f3c3b49c.png" alt="cover"><div class="content is-center"><div class="date"><i class="far fa-calendar-alt fa-fw"></i> 2023-01-15</div><div class="title">Linux IO 之 IO与网络模型</div></div></a></div><div><a href="/2023/01/15/linux-docs/Linux%20Kernel%E5%86%85%E6%A0%B8%E6%95%B4%E4%BD%93%E6%9E%B6%E6%9E%84(%E5%9B%BE%E6%96%87%E8%AF%A6%E8%A7%A3)/" title="Linux Kernel内核整体架构(图文详解)"><img class="cover" src="https://pic2.zhimg.com/80/v2-93cd0f1a4abbdfeb4af71202535fe4f9_720w.webp" alt="cover"><div class="content is-center"><div class="date"><i class="far fa-calendar-alt fa-fw"></i> 2023-01-15</div><div class="title">Linux Kernel内核整体架构(图文详解)</div></div></a></div><div><a href="/2023/01/15/linux-docs/Linux%E5%86%85%E6%A0%B8Coding%20Style%E6%95%B4%E7%90%86/" title="Linux内核Coding Style整理"><img class="cover" src="https://pic4.zhimg.com/80/v2-55215e20944d5e1a161253e73eddaa07_720w.webp" alt="cover"><div class="content is-center"><div class="date"><i class="far fa-calendar-alt fa-fw"></i> 2023-01-15</div><div class="title">Linux内核Coding Style整理</div></div></a></div><div><a href="/2023/01/15/linux-docs/Linux%E5%86%85%E6%A0%B8Makefile%E7%B3%BB%E7%BB%9F%E6%96%87%E4%BB%B6%E8%AF%A6%E8%A7%A3/" title="Linux内核Makefile系统文件详解"><img class="cover" src="https://pic4.zhimg.com/80/v2-55215e20944d5e1a161253e73eddaa07_720w.webp" alt="cover"><div class="content is-center"><div class="date"><i class="far fa-calendar-alt fa-fw"></i> 2023-01-15</div><div class="title">Linux内核Makefile系统文件详解</div></div></a></div><div><a href="/2023/01/15/linux-docs/Linux%E5%86%85%E6%A0%B8RCU%E6%9C%BA%E5%88%B6/" title="Linux内核RCU机制"><img class="cover" src="https://pic2.zhimg.com/80/v2-012ee665b35eb28bca5c88269765f069_720w.webp" alt="cover"><div class="content is-center"><div class="date"><i class="far fa-calendar-alt fa-fw"></i> 2023-01-15</div><div class="title">Linux内核RCU机制</div></div></a></div></div></div></div><div class="aside-content" id="aside-content"><div class="card-widget card-info"><div class="is-center"><div class="avatar-img"><img src="/img/avatar.jpg" onerror="this.onerror=null;this.src='/img/friend_404.gif'" alt="avatar"/></div><div class="author-info__name">ysme</div><div class="author-info__description">嘻嘻哈哈。</div></div><div class="card-info-data site-data is-center"><a href="/archives/"><div class="headline">文章</div><div class="length-num">131</div></a><a href="/tags/"><div class="headline">标签</div><div class="length-num">5</div></a><a href="/categories/"><div class="headline">分类</div><div class="length-num">10</div></a></div><a id="card-info-btn" target="_blank" rel="noopener" href="https://github.com/ysme1"><i class="fab fa-github"></i><span>Follow Me</span></a><div class="card-info-social-icons is-center"><a class="social-icon" href="https://github.com/ysme1" target="_blank" title="Github"><i class="fab fa-github" style="color: #24292e;"></i></a><a class="social-icon" href="mailto:zys1395740068@gmail.com" target="_blank" title="Email"><i class="fas fa-envelope" style="color: #4a7dbe;"></i></a></div></div><div class="card-widget card-announcement"><div class="item-headline"><i class="fas fa-bullhorn fa-shake"></i><span>公告</span></div><div class="announcement_content">This is my Blog</div></div><div class="sticky_layout"><div class="card-widget card-recent-post"><div class="item-headline"><i class="fas fa-history"></i><span>最新文章</span></div><div class="aside-list"><div class="aside-list-item"><a class="thumbnail" href="/2024/10/22/%E5%B5%8C%E5%85%A5%E5%BC%8F/%E5%B5%8C%E5%85%A5%E5%BC%8F%E8%BD%AF%E4%BB%B6%E5%91%BD%E5%90%8D%E5%B8%B8%E7%94%A8%E8%8B%B1%E6%96%87%E9%9B%86/" title="嵌入式软件命名常用英文集"><img src="https://randomimage.ysme.top/" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="嵌入式软件命名常用英文集"/></a><div class="content"><a class="title" href="/2024/10/22/%E5%B5%8C%E5%85%A5%E5%BC%8F/%E5%B5%8C%E5%85%A5%E5%BC%8F%E8%BD%AF%E4%BB%B6%E5%91%BD%E5%90%8D%E5%B8%B8%E7%94%A8%E8%8B%B1%E6%96%87%E9%9B%86/" title="嵌入式软件命名常用英文集">嵌入式软件命名常用英文集</a><time datetime="2024-10-22T06:13:37.000Z" title="发表于 2024-10-22 14:13:37">2024-10-22</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/2023/03/22/%E5%B7%A5%E5%85%B7/git/git%E5%BF%AB%E9%80%9F%E5%85%A5%E9%97%A8/" title="Git 快速入门指南"><img src="https://randomimage.ysme.top/" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="Git 快速入门指南"/></a><div class="content"><a class="title" href="/2023/03/22/%E5%B7%A5%E5%85%B7/git/git%E5%BF%AB%E9%80%9F%E5%85%A5%E9%97%A8/" title="Git 快速入门指南">Git 快速入门指南</a><time datetime="2023-03-22T01:13:37.000Z" title="发表于 2023-03-22 09:13:37">2023-03-22</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/2023/01/15/linux-docs/30%E5%88%86%E9%92%9F%E5%AD%A6%E4%BC%9A%E7%BC%96%E8%AF%91linux%E5%86%85%E6%A0%B8/" title="Linux 30分钟学会编译linux内核"><img src="https://pic2.zhimg.com/80/v2-99c76217f4575d98a9001a4fd8c1681d_720w.webp" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="Linux 30分钟学会编译linux内核"/></a><div class="content"><a class="title" href="/2023/01/15/linux-docs/30%E5%88%86%E9%92%9F%E5%AD%A6%E4%BC%9A%E7%BC%96%E8%AF%91linux%E5%86%85%E6%A0%B8/" title="Linux 30分钟学会编译linux内核">Linux 30分钟学会编译linux内核</a><time datetime="2023-01-15T01:13:37.000Z" title="发表于 2023-01-15 09:13:37">2023-01-15</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/2023/01/15/linux-docs/Linux%20IO%20%E4%B9%8B%20IO%E4%B8%8E%E7%BD%91%E7%BB%9C%E6%A8%A1%E5%9E%8B/" title="Linux IO 之 IO与网络模型"><img src="https://user-images.githubusercontent.com/87457873/127649604-761ead2e-8c72-4876-a52f-8310f3c3b49c.png" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="Linux IO 之 IO与网络模型"/></a><div class="content"><a class="title" href="/2023/01/15/linux-docs/Linux%20IO%20%E4%B9%8B%20IO%E4%B8%8E%E7%BD%91%E7%BB%9C%E6%A8%A1%E5%9E%8B/" title="Linux IO 之 IO与网络模型">Linux IO 之 IO与网络模型</a><time datetime="2023-01-15T01:13:37.000Z" title="发表于 2023-01-15 09:13:37">2023-01-15</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/2023/01/15/linux-docs/Linux%20Kernel%E5%86%85%E6%A0%B8%E6%95%B4%E4%BD%93%E6%9E%B6%E6%9E%84(%E5%9B%BE%E6%96%87%E8%AF%A6%E8%A7%A3)/" title="Linux Kernel内核整体架构(图文详解)"><img src="https://pic2.zhimg.com/80/v2-93cd0f1a4abbdfeb4af71202535fe4f9_720w.webp" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="Linux Kernel内核整体架构(图文详解)"/></a><div class="content"><a class="title" href="/2023/01/15/linux-docs/Linux%20Kernel%E5%86%85%E6%A0%B8%E6%95%B4%E4%BD%93%E6%9E%B6%E6%9E%84(%E5%9B%BE%E6%96%87%E8%AF%A6%E8%A7%A3)/" title="Linux Kernel内核整体架构(图文详解)">Linux Kernel内核整体架构(图文详解)</a><time datetime="2023-01-15T01:13:37.000Z" title="发表于 2023-01-15 09:13:37">2023-01-15</time></div></div></div></div></div></div></main><footer id="footer"><div id="footer-wrap"><div class="copyright">&copy;2020 - 2024 By ysme</div><div class="framework-info"><span>框架 </span><a target="_blank" rel="noopener" href="https://hexo.io">Hexo</a><span class="footer-separator">|</span><span>主题 </span><a target="_blank" rel="noopener" href="https://github.com/jerryc127/hexo-theme-butterfly">Butterfly</a></div><div class="footer_custom_text"><a target="_blank" rel="noopener" href="https://beian.miit.gov.cn/#/Integrated/recordQuery"><img class="icp-icon" src=https://beian.mps.gov.cn/img/logo01.dd7ff50e.png><span>浙ICP备2021036292号</span></a></div></div></footer></div><div id="rightside"><div id="rightside-config-hide"><button id="readmode" type="button" title="阅读模式"><i class="fas fa-book-open"></i></button><button id="darkmode" type="button" title="浅色和深色模式转换"><i class="fas fa-adjust"></i></button><button id="hide-aside-btn" type="button" title="单栏和双栏切换"><i class="fas fa-arrows-alt-h"></i></button></div><div id="rightside-config-show"><button id="rightside-config" type="button" title="设置"><i class="fas fa-cog fa-spin"></i></button><button id="go-up" type="button" title="回到顶部"><span class="scroll-percent"></span><i class="fas fa-arrow-up"></i></button></div></div><div><script src="/js/utils.js?v=4.13.0"></script><script src="/js/main.js?v=4.13.0"></script><script src="https://cdn.jsdelivr.net/npm/@fancyapps/ui@5.0.33/dist/fancybox/fancybox.umd.min.js"></script><div class="js-pjax"></div><script async data-pjax src="//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script><div id="local-search"><div class="search-dialog"><nav class="search-nav"><span class="search-dialog-title">搜索</span><span id="loading-status"></span><button class="search-close-button"><i class="fas fa-times"></i></button></nav><div class="is-center" id="loading-database"><i class="fas fa-spinner fa-pulse"></i><span>  数据库加载中</span></div><div class="search-wrap"><div id="local-search-input"><div class="local-search-box"><input class="local-search-box--input" placeholder="搜索文章" type="text"/></div></div><hr/><div id="local-search-results"></div><div id="local-search-stats-wrap"></div></div></div><div id="search-mask"></div><script src="/js/search/local-search.js?v=4.13.0"></script></div></div></body></html>