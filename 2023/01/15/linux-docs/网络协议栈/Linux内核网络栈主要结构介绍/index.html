
<!DOCTYPE html><html lang="zh-CN">

<head>
  <meta charset="utf-8">
  <meta name="hexo-theme" content="https://github.com/xaoxuu/hexo-theme-stellar/tree/1.27.0" theme-name="Stellar" theme-version="1.27.0">
  
  <meta name="generator" content="Hexo 7.1.1">
  <meta http-equiv='x-dns-prefetch-control' content='on' />
  
  <meta name="renderer" content="webkit">
  <meta name="force-rendering" content="webkit">
  <meta http-equiv="X-UA-Compatible" content="IE=Edge,chrome=1">
  <meta name="HandheldFriendly" content="True" >
  <meta name="apple-mobile-web-app-capable" content="yes">
  <meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1">
  <meta name="theme-color" content="#f8f8f8">
  
  <title>Linux内核网络栈主要结构介绍 - Blog</title>

  
    <meta name="description" content="1、socket（include\linux\Socket.h）该结构体socket 主要使用在BSD socket 层，是最上层的结构，在INET socket 层也会有涉及，但很少。 12345678910111213141516171819202122232425262728&#x2F;*  * Internal representation of a socket. not all the fiel">
<meta property="og:type" content="article">
<meta property="og:title" content="Linux内核网络栈主要结构介绍">
<meta property="og:url" content="https://vcloud.ysme.top/2023/01/15/linux-docs/%E7%BD%91%E7%BB%9C%E5%8D%8F%E8%AE%AE%E6%A0%88/Linux%E5%86%85%E6%A0%B8%E7%BD%91%E7%BB%9C%E6%A0%88%E4%B8%BB%E8%A6%81%E7%BB%93%E6%9E%84%E4%BB%8B%E7%BB%8D/index.html">
<meta property="og:site_name" content="Blog">
<meta property="og:description" content="1、socket（include\linux\Socket.h）该结构体socket 主要使用在BSD socket 层，是最上层的结构，在INET socket 层也会有涉及，但很少。 12345678910111213141516171819202122232425262728&#x2F;*  * Internal representation of a socket. not all the fiel">
<meta property="og:locale" content="zh_CN">
<meta property="article:published_time" content="2023-01-15T01:13:37.000Z">
<meta property="article:modified_time" content="2024-04-05T12:59:49.936Z">
<meta property="article:author" content="ysme">
<meta property="article:tag" content="Linux">
<meta name="twitter:card" content="summary">
  
  
  
  <meta name="keywords" content="Linux">

  <!-- feed -->
  

  <link rel="stylesheet" href="/css/main.css?v=1.27.0">

  

  

  
</head>
<body>

<div class="l_body s:aa content tech" id="start" layout="post" ><aside class="l_left"><div class="leftbar-container">


<header class="header"><div class="logo-wrap"><a class="avatar" href="/about/"><div class="bg" style="opacity:0;background-image:url(https://gcore.jsdelivr.net/gh/cdn-x/placeholder@1.0.12/avatar/round/rainbow64@3x.webp);"></div><img no-lazy class="avatar" src="undefined" onerror="javascript:this.classList.add('error');this.src='https://gcore.jsdelivr.net/gh/cdn-x/placeholder@1.0.12/image/2659360.svg';"></a><a class="title" href="/"><div class="main" ff="title">Blog</div></a></div></header>

<div class="nav-area">
<div class="search-wrapper" id="search-wrapper"><form class="search-form"><a class="search-button" onclick="document.getElementById(&quot;search-input&quot;).focus();"><svg t="1705074644177" viewBox="0 0 1025 1024" version="1.1" xmlns="http://www.w3.org/2000/svg" p-id="1560" width="200" height="200"><path d="M1008.839137 935.96571L792.364903 719.491476a56.783488 56.783488 0 0 0-80.152866 0 358.53545 358.53545 0 1 1 100.857314-335.166073 362.840335 362.840335 0 0 1-3.689902 170.145468 51.248635 51.248635 0 1 0 99.217358 26.444296 462.057693 462.057693 0 1 0-158.255785 242.303546l185.930047 185.725053a51.248635 51.248635 0 0 0 72.568068 0 51.248635 51.248635 0 0 0 0-72.978056z" p-id="1561"></path><path d="M616.479587 615.969233a50.428657 50.428657 0 0 0-61.498362-5.534852 174.655348 174.655348 0 0 1-177.525271 3.484907 49.403684 49.403684 0 0 0-58.833433 6.76482l-3.074918 2.869923a49.403684 49.403684 0 0 0 8.609771 78.10292 277.767601 277.767601 0 0 0 286.992355-5.739847 49.403684 49.403684 0 0 0 8.404776-76.667958z" p-id="1562"></path></svg></a><input type="text" class="search-input" id="search-input" placeholder="站内搜索"></form><div id="search-result"></div><div class="search-no-result">没有找到内容！</div></div>


<nav class="menu dis-select"></nav>
</div>
<div class="widgets">


<widget class="widget-wrapper post-list"><div class="widget-header dis-select"><span class="name">最近更新</span></div><div class="widget-body fs14"><a class="item title" href="/2023/01/15/linux-docs/%E8%BF%9B%E7%A8%8B%E7%AE%A1%E7%90%86/Linux%E5%86%85%E6%A0%B8%E8%BF%9B%E7%A8%8B%E8%BF%B0%E7%AC%A6%E5%92%8C%E8%BF%9B%E7%A8%8B%E7%8A%B6%E6%80%81/"><span class="title">Linux内核进程述符和进程状态</span></a><a class="item title" href="/2023/01/15/linux-docs/%E8%BF%9B%E7%A8%8B%E7%AE%A1%E7%90%86/Linux%E5%86%85%E6%A0%B8%E8%BF%9B%E7%A8%8B%E9%97%B4%E9%80%9A%E4%BF%A1-%E7%AE%A1%E9%81%93/"><span class="title">Linux内核进程间通信-管道</span></a><a class="item title" href="/2023/01/15/linux-docs/%E8%BF%9B%E7%A8%8B%E7%AE%A1%E7%90%86/Linux%E8%BF%9B%E7%A8%8B%E3%80%81%E7%BA%BF%E7%A8%8B%E3%80%81%E8%B0%83%E5%BA%A6(%E4%B8%80)/"><span class="title">Linux进程、线程、调度(一)</span></a><a class="item title" href="/2023/01/15/linux-docs/%E8%BF%9B%E7%A8%8B%E7%AE%A1%E7%90%86/Linux%E8%BF%9B%E7%A8%8B%E3%80%81%E7%BA%BF%E7%A8%8B%E3%80%81%E8%B0%83%E5%BA%A6(%E4%B8%89)/"><span class="title">Linux进程、线程、调度(三)</span></a><a class="item title" href="/2023/01/15/linux-docs/%E8%BF%9B%E7%A8%8B%E7%AE%A1%E7%90%86/Linux%E8%BF%9B%E7%A8%8B%E3%80%81%E7%BA%BF%E7%A8%8B%E3%80%81%E8%B0%83%E5%BA%A6(%E4%BA%8C)/"><span class="title">Linux进程、线程、调度(二)</span></a><a class="item title" href="/2023/01/15/linux-docs/%E8%BF%9B%E7%A8%8B%E7%AE%A1%E7%90%86/Linux%E8%BF%9B%E7%A8%8B%E3%80%81%E7%BA%BF%E7%A8%8B%E3%80%81%E8%B0%83%E5%BA%A6(%E5%9B%9B)/"><span class="title">Linux进程、线程、调度(四)</span></a><a class="item title" href="/2023/01/15/linux-docs/%E8%BF%9B%E7%A8%8B%E7%AE%A1%E7%90%86/Linux%E8%BF%9B%E7%A8%8B%E7%8A%B6%E6%80%81%E6%80%BB%E7%BB%93/"><span class="title">Linux进程状态总结</span></a><a class="item title" href="/2023/01/15/linux-docs/%E8%BF%9B%E7%A8%8B%E7%AE%A1%E7%90%86/%E4%B8%80%E6%96%87%E5%B8%A6%E4%BD%A0%EF%BC%8C%E5%BD%BB%E5%BA%95%E4%BA%86%E8%A7%A3%EF%BC%8C%E9%9B%B6%E6%8B%B7%E8%B4%9DZero-Copy%E6%8A%80%E6%9C%AF/"><span class="title">一文带你，彻底了解，零拷贝Zero-Copy技术</span></a><a class="item title" href="/2023/01/15/linux-docs/%E8%BF%9B%E7%A8%8B%E7%AE%A1%E7%90%86/%E4%BB%BB%E5%8A%A1%E8%B0%83%E5%BA%A6/"><span class="title">任务调度</span></a><a class="item title" href="/2023/01/15/linux-docs/%E8%BF%9B%E7%A8%8B%E7%AE%A1%E7%90%86/%E8%BF%9B%E7%A8%8B%E3%80%81%E7%BA%BF%E7%A8%8B%E7%9A%84%E5%88%9B%E5%BB%BA%E5%92%8C%E6%B4%BE%E7%94%9F/"><span class="title">进程、线程的创建和派生</span></a></div></widget>
</div>
<footer class="footer dis-select"><div class="social-wrap"><a class="social" href="/" rel="noopener noreferrer"><img class="lazy" src="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII=" data-src="https://gcore.jsdelivr.net/gh/cdn-x/placeholder@1.0.12/social/08a41b181ce68.svg"/></a><a class="social" href="/" rel="noopener noreferrer"><img class="lazy" src="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII=" data-src="https://gcore.jsdelivr.net/gh/cdn-x/placeholder@1.0.12/social/3845874.svg"/></a><a class="social" href="/" rel="noopener noreferrer"><img class="lazy" src="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII=" data-src="https://gcore.jsdelivr.net/gh/cdn-x/placeholder@1.0.12/social/3616429.svg"/></a><a class="social" href="/about/#comments" rel="noopener noreferrer"><img class="lazy" src="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII=" data-src="https://gcore.jsdelivr.net/gh/cdn-x/placeholder@1.0.12/social/942ebbf1a4b91.svg"/></a></div></footer>
</div></aside><div class="l_main" id="main">





<div class="article banner top">
  <div class="content">
    <div class="top bread-nav footnote"><div class="left"><div class="flex-row" id="breadcrumb"><a class="cap breadcrumb" href="/">主页</a>
<span class="sep"></span><a class="cap breadcrumb" href="/">文章</a><span class="sep"></span><a class="cap breadcrumb-link" href="/categories/linux-doc-%E7%BD%91%E7%BB%9C%E5%8D%8F%E8%AE%AE%E6%A0%88/">linux-doc 网络协议栈</a></div>
<div class="flex-row" id="post-meta"><span class="text created">发布于：<time datetime="2023-01-15T01:13:37.000Z">2023-01-15</time></span><span class="sep updated"></span><span class="text updated">更新于：<time datetime="2024-04-05T12:59:49.936Z">2024-04-05</time></span></div></div></div>
    
    <div class="bottom only-title">
      
      <div class="text-area">
        <h1 class="text title"><span>Linux内核网络栈主要结构介绍</span></h1>
        
      </div>
    </div>
    
  </div>
  </div><article class="md-text content"><h2 id="1、socket"><a href="#1、socket" class="headerlink" title="1、socket"></a>1、socket</h2><p>（include\linux\Socket.h）该结构体socket 主要使用在BSD socket 层，是最上层的结构，在INET socket 层也会有涉及，但很少。</p>
<figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line">/* </span><br><span class="line"> * Internal representation of a socket. not all the fields are used by </span><br><span class="line"> * all configurations: </span><br><span class="line"> * </span><br><span class="line"> *            server                client </span><br><span class="line"> * conn     client connected to server connected to </span><br><span class="line"> * iconn        list of clients     -unused- </span><br><span class="line"> *       awaiting connections </span><br><span class="line"> * wait     sleep for clients,  sleep for connection, </span><br><span class="line"> *          sleep for i/o               sleep for i/o </span><br><span class="line"> */  </span><br><span class="line"> //该结构表示一个网络套接字  </span><br><span class="line">struct socket &#123;  </span><br><span class="line">  short         type;       /* 套接字所用的流类型*/  </span><br><span class="line">  socket_state      state;//套接字所处状态  </span><br><span class="line">  long          flags;//标识字段，目前尚无明确作用  </span><br><span class="line">  struct proto_ops  *ops;       /* 操作函数集指针  */  </span><br><span class="line">    /* data保存指向‘私有&#x27;数据结构指针，在不同的域指向不同的数据结构        */  </span><br><span class="line">  //在INET域，指向sock结构，UNIX域指向unix_proto_data结构  </span><br><span class="line">  void          *data;    </span><br><span class="line">  //下面两个字段只用于UNIX域  </span><br><span class="line">  struct socket     *conn;      /* 指向连接的对端套接字   */  </span><br><span class="line">  struct socket     *iconn;     /* 指向正等待连接的客户端(服务器端)    */  </span><br><span class="line">  struct socket     *next;//链表  </span><br><span class="line">  struct wait_queue **wait;     /* 等待队列 */  </span><br><span class="line">  struct inode      *inode;//inode结构指针  </span><br><span class="line">  struct fasync_struct  *fasync_list;   /* 异步唤醒链表结构 */  </span><br><span class="line">&#125;;  </span><br></pre></td></tr></table></figure>

<h2 id="2、sock"><a href="#2、sock" class="headerlink" title="2、sock"></a>2、sock</h2><p>(include\linux\Net.h) sock 的使用范围比socket 要大得多，sock结构的使用基本贯穿硬件层、设备接口层、ip层、INET socket 层，而且是作为各层之间的一个联系，主要是因为无论是发送还是接收的数据包都要被缓存到sock 结构中的缓冲队列中。</p>
<p>sock 结构与其对应的 socket 会相互绑定。</p>
<figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br></pre></td><td class="code"><pre><span class="line">/* </span><br><span class="line"> * This structure really needs to be cleaned up. </span><br><span class="line"> * Most of it is for TCP, and not used by any of </span><br><span class="line"> * the other protocols. </span><br><span class="line"> * 大部分功能是为TCP准备的 </span><br><span class="line"> */  </span><br><span class="line">struct sock &#123;  </span><br><span class="line">  struct options        *opt;//IP选项缓冲于此处  </span><br><span class="line">  volatile unsigned long    wmem_alloc;//发送缓冲队列中存放的数据的大小，这两个与后面的rcvbuf和sndbuf一起使用  </span><br><span class="line">  volatile unsigned long    rmem_alloc;//接收缓冲队列中存放的数据的大小  </span><br><span class="line">  /* 下面三个seq用于TCP协议中为保证可靠数据传输而使用的序列号 */  </span><br><span class="line">  unsigned long         write_seq;//  </span><br><span class="line">  unsigned long         sent_seq;//  </span><br><span class="line">  unsigned long         acked_seq;//  </span><br><span class="line">  unsigned long         copied_seq;//应用程序有待读取(但尚未读取)数据的第一个序列号  </span><br><span class="line">  unsigned long         rcv_ack_seq;//目前本地接收到的对本地发送数据的应答序列号  </span><br><span class="line">  unsigned long         window_seq;//窗口大小  </span><br><span class="line">  unsigned long         fin_seq;//应答序列号  </span><br><span class="line">  //下面两个字段用于紧急数据处理  </span><br><span class="line">  unsigned long         urg_seq;//紧急数据最大序列号  </span><br><span class="line">  unsigned long         urg_data;//标志位，1表示收到紧急数据  </span><br><span class="line">  </span><br><span class="line">  /* </span><br><span class="line">   * Not all are volatile, but some are, so we </span><br><span class="line">   * might as well say they all are. </span><br><span class="line">   */  </span><br><span class="line">  volatile char                 inuse,//表示其他进程正在使用该sock结构，本进程需等待  </span><br><span class="line">                dead,//表示该sock结构已处于释放状态  </span><br><span class="line">                urginline,//=1，表示紧急数据将被当做普通数据处理  </span><br><span class="line">                intr,//  </span><br><span class="line">                blog,  </span><br><span class="line">                done,  </span><br><span class="line">                reuse,  </span><br><span class="line">                keepopen,//=1，使用保活定时器  </span><br><span class="line">                linger,//=1，表示在关闭套接字时需要等待一段时间以确认其已关闭  </span><br><span class="line">                delay_acks,//=1，表示延迟应答  </span><br><span class="line">                destroy,//=1，表示该sock结构等待销毁  </span><br><span class="line">                ack_timed,  </span><br><span class="line">                no_check,  </span><br><span class="line">                zapped, /* In ax25 &amp; ipx means not linked */  </span><br><span class="line">                broadcast,  </span><br><span class="line">                nonagle;//=1，表示不使用NAGLE算法  </span><br><span class="line">                //NAGLE算法:在前一个发送的数据包被应答之前，不可再继续发送其它数据包  </span><br><span class="line">  unsigned long             lingertime;//等待关闭操作的时间  </span><br><span class="line">  int               proc;//该sock结构所属的进程的进程号  </span><br><span class="line">  struct sock           *next;  </span><br><span class="line">  struct sock           *prev; /* Doubly linked chain.. */  </span><br><span class="line">  struct sock           *pair;  </span><br><span class="line">  //下面两个字段用于TCP协议重发队列  </span><br><span class="line">  struct sk_buff        * volatile send_head;//这个队列中的数据均已经发送出去，但尚未接收到应答  </span><br><span class="line">  struct sk_buff        * volatile send_tail;  </span><br><span class="line">  struct sk_buff_head       back_log;//接收的数据包缓存队列，当套接字正忙时，数据包暂存在这里  </span><br><span class="line">  struct sk_buff        *partial;//用于创建最大长度的待发送数据包  </span><br><span class="line">  struct timer_list     partial_timer;//定时器，用于按时发送partial指针指向的数据包  </span><br><span class="line">  long              retransmits;//重发次数  </span><br><span class="line">  struct sk_buff_head       write_queue,//指向待发送数据包  </span><br><span class="line">                receive_queue;//读队列，表示数据报已被正式接收，该队列中的数据可被应用程序读取?  </span><br><span class="line">  struct proto          *prot;//传输层处理函数集  </span><br><span class="line">  struct wait_queue     **sleep;  </span><br><span class="line">  unsigned long         daddr;//sock结构所代表套接字的远端地址  </span><br><span class="line">  unsigned long         saddr;//本地地址  </span><br><span class="line">  unsigned short        max_unacked;//最大未处理请求连接数  </span><br><span class="line">  unsigned short        window;//远端窗口大小  </span><br><span class="line">  unsigned short        bytes_rcv;//已接收字节总数  </span><br><span class="line">/* mss is min(mtu, max_window) */  </span><br><span class="line">  unsigned short        mtu; //和链路层协议密切相关      /* 最大传输单元 */  </span><br><span class="line">  volatile unsigned short   mss; //最大报文长度 =mtu-ip首部长度-tcp首部长度，也就是tcp数据包每次能够传输的最大数据分段  </span><br><span class="line">  volatile unsigned short   user_mss;  /* mss requested by user in ioctl */  </span><br><span class="line">  volatile unsigned short   max_window;//最大窗口大小  </span><br><span class="line">  unsigned long         window_clamp;//窗口大小钳制值  </span><br><span class="line">  unsigned short        num;//本地端口号  </span><br><span class="line">  //下面三个字段用于拥塞算法  </span><br><span class="line">  volatile unsigned short   cong_window;  </span><br><span class="line">  volatile unsigned short   cong_count;  </span><br><span class="line">  volatile unsigned short   ssthresh;  </span><br><span class="line">  volatile unsigned short   packets_out;//本地已发送出去但尚未得到应答的数据包数目  </span><br><span class="line">  volatile unsigned short   shutdown;//本地关闭标志位，用于半关闭操作  </span><br><span class="line">  volatile unsigned long    rtt;//往返时间估计值  </span><br><span class="line">  volatile unsigned long    mdev;//绝对偏差  </span><br><span class="line">  volatile unsigned long    rto;//用rtt和mdev 用算法计算出的延迟时间值  </span><br><span class="line">/* currently backoff isn&#x27;t used, but I&#x27;m maintaining it in case </span><br><span class="line"> * we want to go back to a backoff formula that needs it </span><br><span class="line"> */  </span><br><span class="line">  volatile unsigned short   backoff;//退避算法度量值  </span><br><span class="line">  volatile short        err;//错误标志值  </span><br><span class="line">  unsigned char         protocol;//传输层协议值  </span><br><span class="line">  volatile unsigned char    state;//套接字状态值  </span><br><span class="line">  volatile unsigned char    ack_backlog;//缓存的未应答数据包个数  </span><br><span class="line">  unsigned char         max_ack_backlog;//最大缓存的未应答数据包个数  </span><br><span class="line">  unsigned char         priority;//该套接字优先级  </span><br><span class="line">  unsigned char         debug;  </span><br><span class="line">  unsigned short        rcvbuf;//最大接收缓冲区大小  </span><br><span class="line">  unsigned short        sndbuf;//最大发送缓冲区大小  </span><br><span class="line">  unsigned short        type;//类型值如 SOCK_STREAM  </span><br><span class="line">  unsigned char         localroute;//=1,表示只使用本地路由 /* Route locally only */  </span><br><span class="line">#ifdef CONFIG_IPX  </span><br><span class="line">  ipx_address           ipx_dest_addr;  </span><br><span class="line">  ipx_interface         *ipx_intrfc;  </span><br><span class="line">  unsigned short        ipx_port;  </span><br><span class="line">  unsigned short        ipx_type;  </span><br><span class="line">#endif  </span><br><span class="line">#ifdef CONFIG_AX25  </span><br><span class="line">/* Really we want to add a per protocol private area */  </span><br><span class="line">  ax25_address          ax25_source_addr,ax25_dest_addr;  </span><br><span class="line">  struct sk_buff *volatile  ax25_retxq[8];  </span><br><span class="line">  char              ax25_state,ax25_vs,ax25_vr,ax25_lastrxnr,ax25_lasttxnr;  </span><br><span class="line">  char              ax25_condition;  </span><br><span class="line">  char              ax25_retxcnt;  </span><br><span class="line">  char              ax25_xx;  </span><br><span class="line">  char              ax25_retxqi;  </span><br><span class="line">  char              ax25_rrtimer;  </span><br><span class="line">  char              ax25_timer;  </span><br><span class="line">  unsigned char         ax25_n2;  </span><br><span class="line">  unsigned short        ax25_t1,ax25_t2,ax25_t3;  </span><br><span class="line">  ax25_digi         *ax25_digipeat;  </span><br><span class="line">#endif    </span><br><span class="line">#ifdef CONFIG_ATALK  </span><br><span class="line">  struct atalk_sock     at;  </span><br><span class="line">#endif  </span><br><span class="line">  </span><br><span class="line">/* IP &#x27;private area&#x27; or will be eventually */  </span><br><span class="line">  int               ip_ttl;//ip首部ttl字段值，实际上表示路由器跳数      /* TTL setting */  </span><br><span class="line">  int               ip_tos;//ip首部tos字段值，服务类型值       /* TOS */  </span><br><span class="line">  struct tcphdr         dummy_th;//缓存的tcp首部，在tcp协议中创建一个发送数据包时可以利用此字段快速创建tcp首部  </span><br><span class="line">  struct timer_list     keepalive_timer;//保活定时器，用于探测对方窗口大小，防止对方通报窗口大小的数据包丢弃 /* TCP keepalive hack */  </span><br><span class="line">  struct timer_list     retransmit_timer;//重发定时器，用于数据包超时重发  /* TCP retransmit timer */  </span><br><span class="line">  struct timer_list     ack_timer;//延迟应答定时器     /* TCP delayed ack timer */  </span><br><span class="line">  int               ip_xmit_timeout;//表示定时器超时原因 /* Why the timeout is running */  </span><br><span class="line">  </span><br><span class="line">//用于ip多播  </span><br><span class="line">#ifdef CONFIG_IP_MULTICAST    </span><br><span class="line">  int               ip_mc_ttl;          /* Multicasting TTL */  </span><br><span class="line">  int               ip_mc_loop;         /* Loopback (not implemented yet) */  </span><br><span class="line">  char              ip_mc_name[MAX_ADDR_LEN];   /* Multicast device name */  </span><br><span class="line">  struct ip_mc_socklist     *ip_mc_list;            /* Group array */  </span><br><span class="line">#endif    </span><br><span class="line">  </span><br><span class="line">  /* This part is used for the timeout functions (timer.c). */  </span><br><span class="line">  int               timeout;    /* What are we waiting for? */  </span><br><span class="line">  struct timer_list     timer;      /* This is the TIME_WAIT/receive timer when we are doing IP */  </span><br><span class="line">  struct timeval        stamp;  </span><br><span class="line">  </span><br><span class="line">  /* identd */  </span><br><span class="line">  //一个套接在在不同的层次上分别由socket结构和sock结构表示  </span><br><span class="line">  struct socket         *socket;  </span><br><span class="line">    </span><br><span class="line">  /* Callbacks *///回调函数  </span><br><span class="line">  void              (*state_change)(struct sock *sk);  </span><br><span class="line">  void              (*data_ready)(struct sock *sk,int bytes);  </span><br><span class="line">  void              (*write_space)(struct sock *sk);  </span><br><span class="line">  void              (*error_report)(struct sock *sk);  </span><br><span class="line">    </span><br><span class="line">&#125;;  </span><br></pre></td></tr></table></figure>

<h2 id="3、sk-buff"><a href="#3、sk-buff" class="headerlink" title="3、sk_buff"></a>3、sk_buff</h2><p>(include\linux\Skbuff.h) sk_buff 是网络数据报在内核中的表现形式，通过源码可以看出，数据包在内核协议栈中是通过这个数据结构来变现的。</p>
<p>从其中的 union 字段可以看出，该结构是贯穿在各个层的，可以说这个结构是用来为网络数据包服务的。其中的字段表明了数据包隶属的套接字、当前所处的协议层、所搭载的数据负载长度（data指针指向）、源端，目的端地址以及相关字段等。</p>
<p>主要重要的一个字段是 data[0]，这是一个指针，它指向对应层的数据报（首部+数据负载）内容的首地址。怎么解释呢？</p>
<p>如果在传输层，那么data指向的数据部分的首地址，其数据部分为 TCP 首部 + 有效数据负载。</p>
<p>如果在网络层，data指向的数据部分的首地址，其数据部分为 IP 首部 + TCP 首部 + 有效数据负载。</p>
<p>如果在链路层，data指向的首地址，其数据布局为 MAC 首部 + IP 首部 + TCP 首部 + 有效数据负载。</p>
<p>所以在该skb_buff结构传递时，获取某一层的首部，都是通过拷贝 data 指向地址对应首部大小的数据。</p>
<figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br></pre></td><td class="code"><pre><span class="line">  //sk_buff 结构用来封装网络数据  </span><br><span class="line">  //网络栈代码对数据的处理都是以sk_buff 结构为单元进行的  </span><br><span class="line">struct sk_buff &#123;  </span><br><span class="line">  struct sk_buff        * volatile next;  </span><br><span class="line">  struct sk_buff        * volatile prev;//构成队列  </span><br><span class="line">#if CONFIG_SKB_CHECK  </span><br><span class="line">  int               magic_debug_cookie; //调试用  </span><br><span class="line">#endif  </span><br><span class="line">  struct sk_buff        * volatile link3; //构成数据包重发队列  </span><br><span class="line">  struct sock           *sk; //数据包所属的套接字  </span><br><span class="line">  volatile unsigned long    when;    //数据包的发送时间，用于计算往返时间RTT/* used to compute rtt&#x27;s */  </span><br><span class="line">  struct timeval        stamp; //记录时间  </span><br><span class="line">  struct device         *dev; //接收该数据包的接口设备  </span><br><span class="line">  struct sk_buff        *mem_addr; //该sk_buff在内存中的基地址，用于释放该sk_buff结构  </span><br><span class="line">  //联合类型，表示数据报在不同处理层次上所到达的处理位置  </span><br><span class="line">  union &#123;  </span><br><span class="line">    struct tcphdr   *th; //传输层tcp，指向首部第一个字节位置  </span><br><span class="line">    struct ethhdr   *eth; //链路层上，指向以太网首部第一个字节位置  </span><br><span class="line">    struct iphdr    *iph; //网络层上，指向ip首部第一个字节位置  </span><br><span class="line">    struct udphdr   *uh; //传输层udp协议，  </span><br><span class="line">    unsigned char   *raw; //随层次变化而变化，链路层=eth，网络层=iph  </span><br><span class="line">    unsigned long   seq; //针对tcp协议的待发送数据包而言，表示该数据包的ACK值  </span><br><span class="line">  &#125; h;  </span><br><span class="line">  struct iphdr      *ip_hdr; //指向ip首部的指针        /* For IPPROTO_RAW */  </span><br><span class="line">  unsigned long         mem_len; //表示sk_buff结构大小加上数据部分的总长度  </span><br><span class="line">  unsigned long         len; //只表示数据部分长度，len = mem_len - sizeof(sk_buff)  </span><br><span class="line">  unsigned long         fraglen; //分片数据包个数  </span><br><span class="line">  struct sk_buff        *fraglist;  /* Fragment list */  </span><br><span class="line">  unsigned long         truesize; //同men_len  </span><br><span class="line">  unsigned long         saddr; //源端ip地址  </span><br><span class="line">  unsigned long         daddr; //目的端ip地址  </span><br><span class="line">  unsigned long         raddr; //数据包下一站ip地址     /* next hop addr */  </span><br><span class="line">   //标识字段  </span><br><span class="line">  volatile char         acked, //=1，表示数据报已得到确认，可以从重发队列中删除  </span><br><span class="line">                used, //=1，表示该数据包的数据已被应用程序读完，可以进行释放  </span><br><span class="line">                free, //用于数据包发送，=1表示再进行发送操作后立即释放，无需缓存  </span><br><span class="line">                arp; //用于待发送数据包，=1表示已完成MAC首部的建立，=0表示还不知道目的端MAC地址  </span><br><span class="line">  //已进行tries试发送，该数据包正在被其余部分使用，路由类型，数据包类型  </span><br><span class="line">  unsigned char         tries,lock,localroute,pkt_type;  </span><br><span class="line">   //下面是数据包的类型，即pkt_type的取值  </span><br><span class="line">#define PACKET_HOST     0     //发往本机    /* To us */  </span><br><span class="line">#define PACKET_BROADCAST    1 //广播  </span><br><span class="line">#define PACKET_MULTICAST    2 //多播  </span><br><span class="line">#define PACKET_OTHERHOST    3 //其他机器        /* Unmatched promiscuous */  </span><br><span class="line">  unsigned short        users; //使用该数据包的模块数     /* User count - see datagram.c (and soon seqpacket.c/stream.c) */  </span><br><span class="line">  unsigned short        pkt_class;  /* For drivers that need to cache the packet type with the skbuff (new PPP) */  </span><br><span class="line">#ifdef CONFIG_SLAVE_BALANCING  </span><br><span class="line">  unsigned short        in_dev_queue; //该字段是否正在缓存于设备缓存队列中  </span><br><span class="line">#endif    </span><br><span class="line">  unsigned long         padding[0]; //填充字节  </span><br><span class="line">  unsigned char         data[0]; //指向该层数据部分  </span><br><span class="line">  //data指向的数据负载首地址，在各个层对应不同的数据部分  </span><br><span class="line">//从侧面看出sk_buff结构基本上是贯穿整个网络栈的非常重要的一个数据结构  </span><br><span class="line">&#125;;  </span><br></pre></td></tr></table></figure>

<h2 id="4、device"><a href="#4、device" class="headerlink" title="4、device"></a>4、device</h2><p>（include\linux\Netdevice.h）该结构表明了一个网络设备需要的字段信息。</p>
<figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br></pre></td><td class="code"><pre><span class="line">/* </span><br><span class="line"> * The DEVICE structure. </span><br><span class="line"> * Actually, this whole structure is a big mistake.  It mixes I/O </span><br><span class="line"> * data with strictly &quot;high-level&quot; data, and it has to know about </span><br><span class="line"> * almost every data structure used in the INET module.   </span><br><span class="line"> */  </span><br><span class="line">  //网络设备结构  </span><br><span class="line">struct device   </span><br><span class="line">&#123;  </span><br><span class="line">  </span><br><span class="line">  /* </span><br><span class="line">   * This is the first field of the &quot;visible&quot; part of this structure </span><br><span class="line">   * (i.e. as seen by users in the &quot;Space.c&quot; file).  It is the name </span><br><span class="line">   * the interface. </span><br><span class="line">   */  </span><br><span class="line">  char            *name;//设备名称  </span><br><span class="line">  </span><br><span class="line">  /* I/O specific fields - FIXME: Merge these and struct ifmap into one */  </span><br><span class="line">  unsigned long       rmem_end;//设备读缓冲区空间       /* shmem &quot;recv&quot; end */  </span><br><span class="line">  unsigned long       rmem_start;       /* shmem &quot;recv&quot; start   */  </span><br><span class="line">  unsigned long       mem_end;//设备总缓冲区首地址和尾地址       /* sahared mem end  */  </span><br><span class="line">  unsigned long       mem_start;        /* shared mem start */  </span><br><span class="line">  unsigned long       base_addr;//设备寄存器读写IO基地址      /* device I/O address   */  </span><br><span class="line">  unsigned char       irq;  //设备所使用中断号      /* device IRQ number    */  </span><br><span class="line">  </span><br><span class="line">  /* Low-level status flags. */  </span><br><span class="line">  volatile unsigned char  start,//=1，表示设备已处于工作状态        /* start an operation   */  </span><br><span class="line">                          tbusy,//=1，表示设备正忙于数据包发送       /* transmitter busy */  </span><br><span class="line">                          interrupt;//=1，软件正在进行设备中断处理       /* interrupt arrived    */  </span><br><span class="line">  </span><br><span class="line">  struct device       *next;//构成设备队列  </span><br><span class="line">  </span><br><span class="line">  /* The device initialization function. Called only once. */  </span><br><span class="line">  int             (*init)(struct device *dev);//设备初始化指针(函数指针)  </span><br><span class="line">  </span><br><span class="line">  /* Some hardware also needs these fields, but they are not part of the </span><br><span class="line">     usual set specified in Space.c. */  </span><br><span class="line">  unsigned char       if_port;//指定使用的设备端口号      /* Selectable AUI, TP,..*/  </span><br><span class="line">  unsigned char       dma;//设备所用的dma通道号         /* DMA channel      */  </span><br><span class="line">  </span><br><span class="line">  struct enet_statistics* (*get_stats)(struct device *dev);//设备信息获取函数指针  </span><br><span class="line">  </span><br><span class="line">  /* </span><br><span class="line">   * This marks the end of the &quot;visible&quot; part of the structure. All </span><br><span class="line">   * fields hereafter are internal to the system, and may change at </span><br><span class="line">   * will (read: may be cleaned up at will). </span><br><span class="line">   */  </span><br><span class="line">  </span><br><span class="line">  /* These may be needed for future network-power-down code. */  </span><br><span class="line">  unsigned long       trans_start;//用于传输超时计算    /* Time (in jiffies) of last Tx */  </span><br><span class="line">  unsigned long       last_rx;//上次接收一个数据包的时间    /* Time of last Rx      */  </span><br><span class="line">  </span><br><span class="line">  unsigned short      flags;//标志位   /* interface flags (a la BSD)   */  </span><br><span class="line">  unsigned short      family;//设备所属的域协议 /* address family ID (AF_INET)  */  </span><br><span class="line">  unsigned short      metric;   /* routing metric (not used)    */  </span><br><span class="line">  unsigned short      mtu;//该接口设备的最大传输单元，ip首部+tcp首部+有效数据负载，去掉了以太网帧的帧头 /* interface MTU value*/  </span><br><span class="line">  unsigned short      type;//该设备所属硬件类型      /* interface hardware type  */  </span><br><span class="line">  unsigned short      hard_header_len;//硬件首部长度  /* hardware hdr length  */  </span><br><span class="line">  void            *priv;//私有数据指针    /* pointer to private data  */  </span><br><span class="line">  </span><br><span class="line">  /* Interface address info. */  </span><br><span class="line">  unsigned char       broadcast[MAX_ADDR_LEN];//链路层硬件广播地址   /* hw bcast add */  </span><br><span class="line">  unsigned char       dev_addr[MAX_ADDR_LEN];//本设备硬件地址  /* hw address   */  </span><br><span class="line">  unsigned char       addr_len;//硬件地址长度 /* hardware address length  */  </span><br><span class="line">  unsigned long       pa_addr;//本地ip地址  /* protocol address     */  </span><br><span class="line">  unsigned long       pa_brdaddr;//网络层广播ip地址    /* protocol broadcast addr  */  </span><br><span class="line">  unsigned long       pa_dstaddr;//点对点网络中对点的ip地址    /* protocol P-P other side addr */  </span><br><span class="line">  unsigned long       pa_mask;//ip地址网络掩码    /* protocol netmask     */  </span><br><span class="line">  unsigned short      pa_alen;//ip地址长度  /* protocol address length  */  </span><br><span class="line">  </span><br><span class="line">  struct dev_mc_list     *mc_list;//多播地址链表  /* Multicast mac addresses  */  </span><br><span class="line">  int            mc_count;//多播地址数目  /* Number of installed mcasts   */  </span><br><span class="line">    </span><br><span class="line">  struct ip_mc_list  *ip_mc_list;//网络层ip多播地址链表  /* IP multicast filter chain    */  </span><br><span class="line">      </span><br><span class="line">  /* For load balancing driver pair support */  </span><br><span class="line">    </span><br><span class="line">  unsigned long        pkt_queue;//该设备缓存的待发送的数据包个数  /* Packets queued */  </span><br><span class="line">  struct device       *slave;//从设备  /* Slave device */  </span><br><span class="line">    </span><br><span class="line">  </span><br><span class="line">  /* Pointer to the interface buffers. */  </span><br><span class="line">  struct sk_buff_head     buffs[DEV_NUMBUFFS];//设备缓存的待发送的数据包  </span><br><span class="line">  </span><br><span class="line"> //函数指针  </span><br><span class="line">  /* Pointers to interface service routines. */  </span><br><span class="line">  int             (*open)(struct device *dev);  </span><br><span class="line">  int             (*stop)(struct device *dev);  </span><br><span class="line">  int             (*hard_start_xmit) (struct sk_buff *skb,  </span><br><span class="line">                          struct device *dev);  </span><br><span class="line">  int             (*hard_header) (unsigned char *buff,  </span><br><span class="line">                      struct device *dev,  </span><br><span class="line">                      unsigned short type,  </span><br><span class="line">                      void *daddr,  </span><br><span class="line">                      void *saddr,  </span><br><span class="line">                      unsigned len,  </span><br><span class="line">                      struct sk_buff *skb);  </span><br><span class="line">  int             (*rebuild_header)(void *eth, struct device *dev,  </span><br><span class="line">                unsigned long raddr, struct sk_buff *skb);  </span><br><span class="line">  </span><br><span class="line">  //用于从接收到的数据包提取MAC首部中类型字符值，从而将数据包传送给适当的协议处理函数进行处理  </span><br><span class="line">  unsigned short      (*type_trans) (struct sk_buff *skb,  </span><br><span class="line">                     struct device *dev);  </span><br><span class="line">#define HAVE_MULTICAST             </span><br><span class="line">  void            (*set_multicast_list)(struct device *dev,  </span><br><span class="line">                     int num_addrs, void *addrs);  </span><br><span class="line">#define HAVE_SET_MAC_ADDR          </span><br><span class="line">  int             (*set_mac_address)(struct device *dev, void *addr);  </span><br><span class="line">#define HAVE_PRIVATE_IOCTL  </span><br><span class="line">  int             (*do_ioctl)(struct device *dev, struct ifreq *ifr, int cmd);  </span><br><span class="line">#define HAVE_SET_CONFIG  </span><br><span class="line">  int             (*set_config)(struct device *dev, struct ifmap *map);  </span><br><span class="line">    </span><br><span class="line">&#125;;  </span><br></pre></td></tr></table></figure>

<h2 id="5、tcp-首部格式"><a href="#5、tcp-首部格式" class="headerlink" title="5、tcp 首部格式"></a>5、tcp 首部格式</h2><figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"> //tcp首部格式  </span><br><span class="line"> //http://blog.csdn.net/wenqian1991/article/details/44598537  </span><br><span class="line">struct tcphdr &#123;  </span><br><span class="line">    __u16   source;//源端口号  </span><br><span class="line">    __u16   dest;//目的端口号  </span><br><span class="line">    __u32   seq;//32位序列号  </span><br><span class="line">    __u32   ack_seq;//32位确认号  </span><br><span class="line">#if defined(LITTLE_ENDIAN_BITFIELD)  </span><br><span class="line">    __u16   res1:4,//4位首部长度  </span><br><span class="line">        doff:4,//保留  </span><br><span class="line">        //下面为各个控制位  </span><br><span class="line">        fin:1,//最后控制位，表示数据已全部传输完成  </span><br><span class="line">        syn:1,//同步控制位  </span><br><span class="line">        rst:1,//重置控制位  </span><br><span class="line">        psh:1,//推控制位  </span><br><span class="line">        ack:1,//确认控制位  </span><br><span class="line">        urg:1,//紧急控制位  </span><br><span class="line">        res2:2;//  </span><br><span class="line">#elif defined(BIG_ENDIAN_BITFIELD)  </span><br><span class="line">    __u16   doff:4,  </span><br><span class="line">        res1:4,  </span><br><span class="line">        res2:2,  </span><br><span class="line">        urg:1,  </span><br><span class="line">        ack:1,  </span><br><span class="line">        psh:1,  </span><br><span class="line">        rst:1,  </span><br><span class="line">        syn:1,  </span><br><span class="line">        fin:1;  </span><br><span class="line">#else  </span><br><span class="line">#error  &quot;Adjust your &lt;asm/byteorder.h&gt; defines&quot;  </span><br><span class="line">#endif    </span><br><span class="line">    __u16   window;//16位窗口大小  </span><br><span class="line">    __u16   check;//16位校验和  </span><br><span class="line">    __u16   urg_ptr;//16位紧急指针  </span><br><span class="line">&#125;;  </span><br></pre></td></tr></table></figure>

<h2 id="6、ip-首部格式"><a href="#6、ip-首部格式" class="headerlink" title="6、ip 首部格式"></a>6、ip 首部格式</h2><figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"> //ip数据报，首部格式  </span><br><span class="line">struct iphdr &#123;  </span><br><span class="line">#if defined(LITTLE_ENDIAN_BITFIELD)//如果是小端模式  </span><br><span class="line">    __u8    ihl:4,//首部长度  </span><br><span class="line">        version:4;//版本  </span><br><span class="line">#elif defined (BIG_ENDIAN_BITFIELD)//大端  </span><br><span class="line">    __u8    version:4,  </span><br><span class="line">        ihl:4;  </span><br><span class="line">#else  </span><br><span class="line">#error  &quot;Please fix &lt;asm/byteorder.h&gt;&quot;  </span><br><span class="line">#endif  </span><br><span class="line">    __u8    tos;//区分服务，用语表示数据报的优先级和服务类型  </span><br><span class="line">    __u16   tot_len;//总长度，标识整个ip数据报的总长度 = 报头+数据部分  </span><br><span class="line">    __u16   id;//表示ip数据报的标识符  </span><br><span class="line">    __u16   frag_off;//片偏移  </span><br><span class="line">    __u8    ttl;//生存时间，即ip数据报在网络中传输的有效期  </span><br><span class="line">    __u8    protocol;//协议，标识此ip数据报在传输层所采用的协议类型  </span><br><span class="line">    __u16   check;//首部校验和  </span><br><span class="line">    __u32   saddr;//源地址  </span><br><span class="line">    __u32   daddr;//目的地址  </span><br><span class="line">    /*The options start here. */  </span><br><span class="line">&#125;;  </span><br></pre></td></tr></table></figure>

<h2 id="7、以太网帧帧头格式"><a href="#7、以太网帧帧头格式" class="headerlink" title="7、以太网帧帧头格式"></a>7、以太网帧帧头格式</h2><figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">/* This is an Ethernet frame header. */ </span><br><span class="line">struct ethhdr &#123;  </span><br><span class="line">  unsigned char     h_dest[ETH_ALEN];//目的地址 /* destination eth addr */ </span><br><span class="line">  unsigned char     h_source[ETH_ALEN];//源地址    /* source ether addr    */ </span><br><span class="line">  unsigned short    h_proto;//类型        /* packet type ID field */ </span><br><span class="line">&#125;;  </span><br></pre></td></tr></table></figure>

<h2 id="8、ARP报文报头"><a href="#8、ARP报文报头" class="headerlink" title="8、ARP报文报头"></a>8、ARP报文报头</h2><figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">/* </span><br><span class="line"> *  This structure defines an ethernet arp header. </span><br><span class="line"> */  </span><br><span class="line"> //ARP报文格式(arp报头)  </span><br><span class="line">struct arphdr  </span><br><span class="line">&#123;  </span><br><span class="line">    unsigned short  ar_hrd;//硬件类型       /* format of hardware address   */  </span><br><span class="line">    unsigned short  ar_pro;//上层协议类型     /* format of protocol address   */  </span><br><span class="line">    unsigned char   ar_hln;//MAC地址长度        /* length of hardware address   */  </span><br><span class="line">    unsigned char   ar_pln;//协议地址长度     /* length of protocol address   */  </span><br><span class="line">    unsigned short  ar_op;//操作类型        /* ARP opcode (command)     */  </span><br><span class="line">  </span><br><span class="line">#if 0  </span><br><span class="line">     /* </span><br><span class="line">      *  Ethernet looks like this : This bit is variable sized however... </span><br><span class="line">      */  </span><br><span class="line">    unsigned char       ar_sha[ETH_ALEN];//源MAC地址   /* sender hardware address  */  </span><br><span class="line">    unsigned char       ar_sip[4];//源IP地址       /* sender IP address        */  </span><br><span class="line">    unsigned char       ar_tha[ETH_ALEN];//目的MAC地址  /* target hardware address  */  </span><br><span class="line">    unsigned char       ar_tip[4];//目的IP地址      /* target IP address        */  </span><br><span class="line">#endif  </span><br><span class="line">  </span><br><span class="line">&#125;;  </span><br></pre></td></tr></table></figure>

<hr>
<p>版权声明：本文为知乎博主「<a target="_blank" rel="noopener" href="https://www.zhihu.com/people/linuxwang-xian-sheng">极致Linux内核</a>」的原创文章，遵循CC 4.0 BY-SA版权协议，转载请附上原文出处链接及本声明。</p>
<p>原文链接：<a target="_blank" rel="noopener" href="https://zhuanlan.zhihu.com/p/549140581">https://zhuanlan.zhihu.com/p/549140581</a></p>

<div class="article-footer fs14">
    <section id="license">
      <div class="header"><span>许可协议</span></div>
      <div class="body"><p>本文采用 <a target="_blank" rel="noopener" href="https://creativecommons.org/licenses/by-nc-sa/4.0/">署名-非商业性使用-相同方式共享 4.0 国际</a> 许可协议，转载请注明出处。</p>
</div>
    </section>
    </div>
</article>
<div class="related-wrap" id="read-next"><section class="body"><div class="item" id="prev"><div class="note">较新文章</div><a href="/2023/01/15/linux-docs/%E7%BD%91%E7%BB%9C%E5%8D%8F%E8%AE%AE%E6%A0%88/Linux%E5%86%85%E6%A0%B8%E7%BD%91%E7%BB%9C%E5%8D%8F%E8%AE%AE%E6%A0%88%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9F%BA%E7%A1%80/">Linux内核网络协议栈计算机基础</a></div><div class="item" id="next"><div class="note">较早文章</div><a href="/2023/01/15/linux-docs/%E7%BD%91%E7%BB%9C%E5%8D%8F%E8%AE%AE%E6%A0%88/Linux%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E5%8E%9F%E7%90%86%E2%80%94%E5%86%85%E6%A0%B8%E7%BD%91%E7%BB%9C%E5%8D%8F%E8%AE%AE%E6%A0%88/">Linux操作系统原理—内核网络协议栈</a></div></section></div>






<footer class="page-footer footnote"><hr><div class="sitemap"><div class="sitemap-group"><span class="fs15">博客</span><a href="/">近期</a><a href="/">分类</a><a href="/">标签</a><a href="/">归档</a></div><div class="sitemap-group"><span class="fs15">项目</span><a href="/">开源库</a></div><div class="sitemap-group"><span class="fs15">社交</span><a href="/">友链</a><a href="/">留言板</a></div><div class="sitemap-group"><span class="fs15">更多</span><a href="/">关于本站</a><a href="/">GitHub</a></div></div><div class="text"><p>本站由 <a href="/">ysme</a> 使用 <a target="_blank" rel="noopener" href="https://github.com/xaoxuu/hexo-theme-stellar/tree/1.27.0">Stellar 1.27.0</a> 主题创建。<br>本博客所有文章除特别声明外，均采用 <a target="_blank" rel="noopener" href="https://creativecommons.org/licenses/by-nc-sa/4.0/">CC BY-NC-SA 4.0</a> 许可协议，转载请注明出处。</p>
</div></footer>
<div class="main-mask" onclick="sidebar.dismiss()"></div></div><aside class="l_right">
<div class="widgets">



<widget class="widget-wrapper toc" id="data-toc" collapse="false"><div class="widget-header dis-select"><span class="name">本文目录</span><a class="cap-action" onclick="sidebar.toggleTOC()" ><svg xmlns="http://www.w3.org/2000/svg" width="32" height="32" viewBox="0 0 24 24"><path fill="none" stroke="currentColor" stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M10 6h11m-11 6h11m-11 6h11M4 6h1v4m-1 0h2m0 8H4c0-1 2-2 2-3s-1-1.5-2-1"/></svg></a></div><div class="widget-body"><ol class="toc"><li class="toc-item toc-level-2"><a class="toc-link" href="#1%E3%80%81socket"><span class="toc-text">1、socket</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#2%E3%80%81sock"><span class="toc-text">2、sock</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#3%E3%80%81sk-buff"><span class="toc-text">3、sk_buff</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#4%E3%80%81device"><span class="toc-text">4、device</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#5%E3%80%81tcp-%E9%A6%96%E9%83%A8%E6%A0%BC%E5%BC%8F"><span class="toc-text">5、tcp 首部格式</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#6%E3%80%81ip-%E9%A6%96%E9%83%A8%E6%A0%BC%E5%BC%8F"><span class="toc-text">6、ip 首部格式</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#7%E3%80%81%E4%BB%A5%E5%A4%AA%E7%BD%91%E5%B8%A7%E5%B8%A7%E5%A4%B4%E6%A0%BC%E5%BC%8F"><span class="toc-text">7、以太网帧帧头格式</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#8%E3%80%81ARP%E6%8A%A5%E6%96%87%E6%8A%A5%E5%A4%B4"><span class="toc-text">8、ARP报文报头</span></a></li></ol></div><div class="widget-footer">

<a class="top" onclick="util.scrollTop()"><svg xmlns="http://www.w3.org/2000/svg" width="32" height="32" viewBox="0 0 24 24"><g fill="none" stroke="currentColor" stroke-width="1.5"><path d="M2 12c0-4.714 0-7.071 1.464-8.536C4.93 2 7.286 2 12 2c4.714 0 7.071 0 8.535 1.464C22 4.93 22 7.286 22 12c0 4.714 0 7.071-1.465 8.535C19.072 22 16.714 22 12 22s-7.071 0-8.536-1.465C2 19.072 2 16.714 2 12Z"/><path stroke-linecap="round" stroke-linejoin="round" d="m9 15.5l3-3l3 3m-6-4l3-3l3 3"/></g></svg><span>回到顶部</span></a></div></widget>
</div></aside><div class='float-panel blur'>
  <button type='button' style='display:none' class='laptop-only rightbar-toggle mobile' onclick='sidebar.rightbar()'>
    <svg xmlns="http://www.w3.org/2000/svg" width="32" height="32" viewBox="0 0 24 24"><path fill="none" stroke="currentColor" stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M10 6h11m-11 6h11m-11 6h11M4 6h1v4m-1 0h2m0 8H4c0-1 2-2 2-3s-1-1.5-2-1"/></svg>
  </button>
  <button type='button' style='display:none' class='mobile-only leftbar-toggle mobile' onclick='sidebar.leftbar()'>
    <svg xmlns="http://www.w3.org/2000/svg" width="32" height="32" viewBox="0 0 24 24"><g fill="none" stroke="currentColor" stroke-width="1.5"><path d="M2 11c0-3.771 0-5.657 1.172-6.828C4.343 3 6.229 3 10 3h4c3.771 0 5.657 0 6.828 1.172C22 5.343 22 7.229 22 11v2c0 3.771 0 5.657-1.172 6.828C19.657 21 17.771 21 14 21h-4c-3.771 0-5.657 0-6.828-1.172C2 18.657 2 16.771 2 13z"/><path id="sep" stroke-linecap="round" d="M5.5 10h6m-5 4h4m4.5 7V3"/></g></svg>
  </button>
</div>
</div><div class="scripts">
<script type="text/javascript">
  const ctx = {
    date_suffix: {
      just: `刚刚`,
      min: `分钟前`,
      hour: `小时前`,
      day: `天前`,
    },
    root : `/`,
  };

  // required plugins (only load if needs)
  if (`local_search`) {
    ctx.search = {};
    ctx.search.service = `local_search`;
    if (ctx.search.service == 'local_search') {
      let service_obj = Object.assign({}, `{"field":"all","path":"/search.json","content":true,"sort":"-date"}`);
      ctx.search[ctx.search.service] = service_obj;
    }
  }
  const def = {
    avatar: `https://gcore.jsdelivr.net/gh/cdn-x/placeholder@1.0.12/avatar/round/3442075.svg`,
    cover: `https://gcore.jsdelivr.net/gh/cdn-x/placeholder@1.0.12/cover/76b86c0226ffd.svg`,
  };
  const deps = {
    jquery: `https://cdn.bootcdn.net/ajax/libs/jquery/3.7.1/jquery.min.js`,
    marked: `https://cdn.bootcdn.net/ajax/libs/marked/4.0.18/marked.min.js`
  }
  

</script>

<script type="text/javascript">
  const utils = {
    // 懒加载 css https://github.com/filamentgroup/loadCSS
    css: (href, before, media, attributes) => {
      var doc = window.document;
      var ss = doc.createElement("link");
      var ref;
      if (before) {
        ref = before;
      } else {
        var refs = (doc.body || doc.getElementsByTagName("head")[0]).childNodes;
        ref = refs[refs.length - 1];
      }
      var sheets = doc.styleSheets;
      if (attributes) {
        for (var attributeName in attributes) {
          if (attributes.hasOwnProperty(attributeName)) {
            ss.setAttribute(attributeName, attributes[attributeName]);
          }
        }
      }
      ss.rel = "stylesheet";
      ss.href = href;
      ss.media = "only x";
      function ready(cb) {
        if (doc.body) {
          return cb();
        }
        setTimeout(function () {
          ready(cb);
        });
      }
      ready(function () {
        ref.parentNode.insertBefore(ss, before ? ref : ref.nextSibling);
      });
      var onloadcssdefined = function (cb) {
        var resolvedHref = ss.href;
        var i = sheets.length;
        while (i--) {
          if (sheets[i].href === resolvedHref) {
            return cb();
          }
        }
        setTimeout(function () {
          onloadcssdefined(cb);
        });
      };
      function loadCB() {
        if (ss.addEventListener) {
          ss.removeEventListener("load", loadCB);
        }
        ss.media = media || "all";
      }
      if (ss.addEventListener) {
        ss.addEventListener("load", loadCB);
      }
      ss.onloadcssdefined = onloadcssdefined;
      onloadcssdefined(loadCB);
      return ss;
    },

    js: (src, opt) => new Promise((resolve, reject) => {
      var script = document.createElement('script');
      if (src.startsWith('/')){
        src = ctx.root + src.substring(1);
      }
      script.src = src;
      if (opt) {
        for (let key of Object.keys(opt)) {
          script[key] = opt[key]
        }
      } else {
        // 默认异步，如果需要同步，第二个参数传入 {} 即可
        script.async = true
      }
      script.onerror = reject
      script.onload = script.onreadystatechange = function() {
        const loadState = this.readyState
        if (loadState && loadState !== 'loaded' && loadState !== 'complete') return
        script.onload = script.onreadystatechange = null
        resolve()
      }
      document.head.appendChild(script)
    }),

    jq: (fn) => {
      if (typeof jQuery === 'undefined') {
        utils.js(deps.jquery).then(fn)
      } else {
        fn()
      }
    },
    
    onLoading: (el) => {
      if (el) {
        $(el).append('<div class="loading-wrap"><svg xmlns="http://www.w3.org/2000/svg" width="2em" height="2em" preserveAspectRatio="xMidYMid meet" viewBox="0 0 24 24"><g fill="none" stroke="currentColor" stroke-linecap="round" stroke-width="2"><path stroke-dasharray="60" stroke-dashoffset="60" stroke-opacity=".3" d="M12 3C16.9706 3 21 7.02944 21 12C21 16.9706 16.9706 21 12 21C7.02944 21 3 16.9706 3 12C3 7.02944 7.02944 3 12 3Z"><animate fill="freeze" attributeName="stroke-dashoffset" dur="1.3s" values="60;0"/></path><path stroke-dasharray="15" stroke-dashoffset="15" d="M12 3C16.9706 3 21 7.02944 21 12"><animate fill="freeze" attributeName="stroke-dashoffset" dur="0.3s" values="15;0"/><animateTransform attributeName="transform" dur="1.5s" repeatCount="indefinite" type="rotate" values="0 12 12;360 12 12"/></path></g></svg></div>');
      }
    },
    onLoadSuccess: (el) => {
      if (el) {
        $(el).find('.loading-wrap').remove();
      }
    },
    onLoadFailure: (el) => {
      if (el) {
        $(el).find('.loading-wrap svg').remove();
        $(el).find('.loading-wrap').append('<svg xmlns="http://www.w3.org/2000/svg" width="2em" height="2em" preserveAspectRatio="xMidYMid meet" viewBox="0 0 24 24"><g fill="none" stroke="currentColor" stroke-linecap="round" stroke-linejoin="round" stroke-width="2"><path stroke-dasharray="60" stroke-dashoffset="60" d="M12 3L21 20H3L12 3Z"><animate fill="freeze" attributeName="stroke-dashoffset" dur="0.5s" values="60;0"/></path><path stroke-dasharray="6" stroke-dashoffset="6" d="M12 10V14"><animate fill="freeze" attributeName="stroke-dashoffset" begin="0.6s" dur="0.2s" values="6;0"/></path></g><circle cx="12" cy="17" r="1" fill="currentColor" fill-opacity="0"><animate fill="freeze" attributeName="fill-opacity" begin="0.8s" dur="0.4s" values="0;1"/></circle></svg>');
        $(el).find('.loading-wrap').addClass('error');
      }
    },
    request: (el, url, callback, onFailure) => {
      let retryTimes = 3;
      utils.onLoading(el);
      function req() {
        return new Promise((resolve, reject) => {
          let status = 0; // 0 等待 1 完成 2 超时
          let timer = setTimeout(() => {
            if (status === 0) {
              status = 2;
              timer = null;
              reject('请求超时');
              if (retryTimes == 0) {
                onFailure();
              }
            }
          }, 5000);
          fetch(url).then(function(response) {
            if (status !== 2) {
              clearTimeout(timer);
              resolve(response);
              timer = null;
              status = 1;
            }
            if (response.ok) {
              return response.json();
            }
            throw new Error('Network response was not ok.');
          }).then(function(data) {
            retryTimes = 0;
            utils.onLoadSuccess(el);
            callback(data);
          }).catch(function(error) {
            if (retryTimes > 0) {
              retryTimes -= 1;
              setTimeout(() => {
                req();
              }, 5000);
            } else {
              utils.onLoadFailure(el);
              onFailure();
            }
          });
        });
      }
      req();
    },
  };
</script>

<script>
  const sidebar = {
    leftbar: () => {
      if (l_body) {
        l_body.toggleAttribute('leftbar');
        l_body.removeAttribute('rightbar');
      }
    },
    rightbar: () => {
      if (l_body) {
        l_body.toggleAttribute('rightbar');
        l_body.removeAttribute('leftbar');
      }
    },
    dismiss: () => {
      if (l_body) {
        l_body.removeAttribute('leftbar');
        l_body.removeAttribute('rightbar');
      }
    },
    toggleTOC: () => {
      document.querySelector('#data-toc').classList.toggle('collapse');
    }
  }
</script>

<!-- required -->
<script src="/js/main.js?v=1.27.0" async></script>

<!-- optional -->



<script defer>
  window.addEventListener('DOMContentLoaded', (event) => {
    ctx.services = Object.assign({}, JSON.parse(`{"mdrender":{"js":"/js/services/mdrender.js"},"siteinfo":{"js":"/js/services/siteinfo.js","api":null},"ghinfo":{"js":"/js/services/ghinfo.js"},"sites":{"js":"/js/services/sites.js"},"friends":{"js":"/js/services/friends.js"},"timeline":{"js":"/js/services/timeline.js"},"fcircle":{"js":"/js/services/fcircle.js"},"weibo":{"js":"/js/services/weibo.js"},"memos":{"js":"/js/services/memos.js"}}`));
    for (let id of Object.keys(ctx.services)) {
      const js = ctx.services[id].js;
      if (id == 'siteinfo') {
        ctx.cardlinks = document.querySelectorAll('a.link-card[cardlink]');
        if (ctx.cardlinks?.length > 0) {
          utils.js(js, { defer: true }).then(function () {
            setCardLink(ctx.cardlinks);
          });
        }
      } else {
        const els = document.getElementsByClassName(`ds-${id}`);
        if (els?.length > 0) {
          utils.jq(() => {
            if (id == 'timeline' || 'memos' || 'marked') {
              utils.js(deps.marked).then(function () {
                utils.js(js, { defer: true });
              });
            } else {
              utils.js(js, { defer: true });
            }
          });
        }
      }
    }
  });
</script>

<script>
  window.addEventListener('DOMContentLoaded', (event) => {
    ctx.search = {
      path: `/search.json`,
    }
    utils.js('/js/search/local-search.js', { defer: true });
  });
</script><script>
  window.FPConfig = {
    delay: 0,
    ignoreKeywords: [],
    maxRPS: 5,
    hoverDelay: 25
  };
</script>
<script defer src="https://cdn.bootcdn.net/ajax/libs/flying-pages/2.1.2/flying-pages.min.js"></script><script defer src="https://cdn.bootcdn.net/ajax/libs/vanilla-lazyload/17.8.4/lazyload.min.js"></script>
<script>
  // https://www.npmjs.com/package/vanilla-lazyload
  // Set the options globally
  // to make LazyLoad self-initialize
  window.lazyLoadOptions = {
    elements_selector: ".lazy",
  };
  // Listen to the initialization event
  // and get the instance of LazyLoad
  window.addEventListener(
    "LazyLoad::Initialized",
    function (event) {
      window.lazyLoadInstance = event.detail.instance;
    },
    false
  );
  document.addEventListener('DOMContentLoaded', function () {
    window.lazyLoadInstance?.update();
  });
</script><script>
  ctx.fancybox = {
    selector: `.timenode p>img`,
    css: `https://cdn.bootcdn.net/ajax/libs/fancyapps-ui/5.0.22/fancybox/fancybox.min.css`,
    js: `https://cdn.bootcdn.net/ajax/libs/fancyapps-ui/5.0.22/fancybox/fancybox.umd.min.js`
  };
  var selector = '[data-fancybox]:not(.error)';
  if (ctx.fancybox.selector) {
    selector += `, ${ctx.fancybox.selector}`
  }
  var needFancybox = document.querySelectorAll(selector).length !== 0;
  if (!needFancybox) {
    const els = document.getElementsByClassName('ds-memos');
    if (els != undefined && els.length > 0) {
      needFancybox = true;
    }
  }
  if (needFancybox) {
    utils.css(ctx.fancybox.css);
    utils.js(ctx.fancybox.js, { defer: true }).then(function () {
      Fancybox.bind(selector, {
        hideScrollbar: false,
        Thumbs: {
          autoStart: false,
        },
        caption: (fancybox, slide) => {
          return slide.triggerEl.alt || null
        }
      });
    })
  }
</script><script>
  window.addEventListener('DOMContentLoaded', (event) => {
    const swiper_api = document.getElementById('swiper-api');
    if (swiper_api != undefined) {
      utils.css(`https://unpkg.com/swiper@10.3.1/swiper-bundle.min.css`);
      utils.js(`https://unpkg.com/swiper@10.3.1/swiper-bundle.min.js`, { defer: true }).then(function () {
        const effect = swiper_api.getAttribute('effect') || '';
        var swiper = new Swiper('.swiper#swiper-api', {
          slidesPerView: 'auto',
          spaceBetween: 8,
          centeredSlides: true,
          effect: effect,
          loop: true,
          pagination: {
            el: '.swiper-pagination',
            clickable: true,
          },
          navigation: {
            nextEl: '.swiper-button-next',
            prevEl: '.swiper-button-prev',
          },
        });
      })
    }
  });
</script><script>
  document.addEventListener('DOMContentLoaded', function () {
    window.codeElements = document.querySelectorAll('.code');
    if (window.codeElements.length > 0) {
      ctx.copycode = {
        default_text: `Copy`,
        success_text: `Copied`,
        toast: `复制成功`,
      };
      utils.js('/js/plugins/copycode.js');
    }
  });
</script>


<!-- inject -->

</div></body></html>
