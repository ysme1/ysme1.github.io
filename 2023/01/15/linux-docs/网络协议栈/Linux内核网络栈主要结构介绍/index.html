<!DOCTYPE html><html lang="zh-CN" data-theme="light"><head><meta charset="UTF-8"><meta http-equiv="X-UA-Compatible" content="IE=edge"><meta name="viewport" content="width=device-width, initial-scale=1.0,viewport-fit=cover"><title>Linux内核网络栈主要结构介绍 | Blog</title><meta name="author" content="ysme"><meta name="copyright" content="ysme"><meta name="format-detection" content="telephone=no"><meta name="theme-color" content="#ffffff"><meta name="description" content="1、socket（include\linux\Socket.h）该结构体socket 主要使用在BSD socket 层，是最上层的结构，在INET socket 层也会有涉及，但很少。 12345678910111213141516171819202122232425262728&#x2F;*  * Internal representation of a socket. not all the fiel">
<meta property="og:type" content="article">
<meta property="og:title" content="Linux内核网络栈主要结构介绍">
<meta property="og:url" content="https://vcloud.ysme.top/2023/01/15/linux-docs/%E7%BD%91%E7%BB%9C%E5%8D%8F%E8%AE%AE%E6%A0%88/Linux%E5%86%85%E6%A0%B8%E7%BD%91%E7%BB%9C%E6%A0%88%E4%B8%BB%E8%A6%81%E7%BB%93%E6%9E%84%E4%BB%8B%E7%BB%8D/index.html">
<meta property="og:site_name" content="Blog">
<meta property="og:description" content="1、socket（include\linux\Socket.h）该结构体socket 主要使用在BSD socket 层，是最上层的结构，在INET socket 层也会有涉及，但很少。 12345678910111213141516171819202122232425262728&#x2F;*  * Internal representation of a socket. not all the fiel">
<meta property="og:locale" content="zh_CN">
<meta property="og:image" content="https://i.loli.net/2020/05/01/gkihqEjXxJ5UZ1C.jpg">
<meta property="article:published_time" content="2023-01-15T01:13:37.000Z">
<meta property="article:modified_time" content="2024-08-28T10:13:39.915Z">
<meta property="article:author" content="ysme">
<meta property="article:tag" content="Linux">
<meta name="twitter:card" content="summary">
<meta name="twitter:image" content="https://i.loli.net/2020/05/01/gkihqEjXxJ5UZ1C.jpg"><link rel="shortcut icon" href="/img/favicon.png"><link rel="canonical" href="https://vcloud.ysme.top/2023/01/15/linux-docs/%E7%BD%91%E7%BB%9C%E5%8D%8F%E8%AE%AE%E6%A0%88/Linux%E5%86%85%E6%A0%B8%E7%BD%91%E7%BB%9C%E6%A0%88%E4%B8%BB%E8%A6%81%E7%BB%93%E6%9E%84%E4%BB%8B%E7%BB%8D/index.html"><link rel="preconnect" href="//cdn.jsdelivr.net"/><link rel="preconnect" href="//busuanzi.ibruce.info"/><link rel="stylesheet" href="/css/index.css?v=4.13.0"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fortawesome/fontawesome-free@6.5.1/css/all.min.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fancyapps/ui@5.0.33/dist/fancybox/fancybox.min.css" media="print" onload="this.media='all'"><script>const GLOBAL_CONFIG = {
  root: '/',
  algolia: undefined,
  localSearch: {"path":"/search.xml","preload":false,"top_n_per_article":1,"unescape":false,"languages":{"hits_empty":"找不到您查询的内容：${query}","hits_stats":"共找到 ${hits} 篇文章"}},
  translate: undefined,
  noticeOutdate: undefined,
  highlight: {"plugin":"highlight.js","highlightCopy":true,"highlightLang":true,"highlightHeightLimit":200},
  copy: {
    success: '复制成功',
    error: '复制错误',
    noSupport: '浏览器不支持'
  },
  relativeDate: {
    homepage: false,
    post: false
  },
  runtime: '',
  dateSuffix: {
    just: '刚刚',
    min: '分钟前',
    hour: '小时前',
    day: '天前',
    month: '个月前'
  },
  copyright: undefined,
  lightbox: 'fancybox',
  Snackbar: undefined,
  infinitegrid: {
    js: 'https://cdn.jsdelivr.net/npm/@egjs/infinitegrid@4.11.1/dist/infinitegrid.min.js',
    buttonText: '加载更多'
  },
  isPhotoFigcaption: false,
  islazyload: false,
  isAnchor: false,
  percent: {
    toc: true,
    rightside: false,
  },
  autoDarkmode: false
}</script><script id="config-diff">var GLOBAL_CONFIG_SITE = {
  title: 'Linux内核网络栈主要结构介绍',
  isPost: true,
  isHome: false,
  isHighlightShrink: false,
  isToc: true,
  postUpdate: '2024-08-28 18:13:39'
}</script><script>(win=>{
      win.saveToLocal = {
        set: (key, value, ttl) => {
          if (ttl === 0) return
          const now = Date.now()
          const expiry = now + ttl * 86400000
          const item = {
            value,
            expiry
          }
          localStorage.setItem(key, JSON.stringify(item))
        },
      
        get: key => {
          const itemStr = localStorage.getItem(key)
      
          if (!itemStr) {
            return undefined
          }
          const item = JSON.parse(itemStr)
          const now = Date.now()
      
          if (now > item.expiry) {
            localStorage.removeItem(key)
            return undefined
          }
          return item.value
        }
      }
    
      win.getScript = (url, attr = {}) => new Promise((resolve, reject) => {
        const script = document.createElement('script')
        script.src = url
        script.async = true
        script.onerror = reject
        script.onload = script.onreadystatechange = function() {
          const loadState = this.readyState
          if (loadState && loadState !== 'loaded' && loadState !== 'complete') return
          script.onload = script.onreadystatechange = null
          resolve()
        }

        Object.keys(attr).forEach(key => {
          script.setAttribute(key, attr[key])
        })

        document.head.appendChild(script)
      })
    
      win.getCSS = (url, id = false) => new Promise((resolve, reject) => {
        const link = document.createElement('link')
        link.rel = 'stylesheet'
        link.href = url
        if (id) link.id = id
        link.onerror = reject
        link.onload = link.onreadystatechange = function() {
          const loadState = this.readyState
          if (loadState && loadState !== 'loaded' && loadState !== 'complete') return
          link.onload = link.onreadystatechange = null
          resolve()
        }
        document.head.appendChild(link)
      })
    
      win.activateDarkMode = () => {
        document.documentElement.setAttribute('data-theme', 'dark')
        if (document.querySelector('meta[name="theme-color"]') !== null) {
          document.querySelector('meta[name="theme-color"]').setAttribute('content', '#0d0d0d')
        }
      }
      win.activateLightMode = () => {
        document.documentElement.setAttribute('data-theme', 'light')
        if (document.querySelector('meta[name="theme-color"]') !== null) {
          document.querySelector('meta[name="theme-color"]').setAttribute('content', '#ffffff')
        }
      }
      const t = saveToLocal.get('theme')
    
        if (t === 'dark') activateDarkMode()
        else if (t === 'light') activateLightMode()
      
      const asideStatus = saveToLocal.get('aside-status')
      if (asideStatus !== undefined) {
        if (asideStatus === 'hide') {
          document.documentElement.classList.add('hide-aside')
        } else {
          document.documentElement.classList.remove('hide-aside')
        }
      }
    
      const detectApple = () => {
        if(/iPad|iPhone|iPod|Macintosh/.test(navigator.userAgent)){
          document.documentElement.classList.add('apple')
        }
      }
      detectApple()
    })(window)</script><meta name="generator" content="Hexo 7.1.1"></head><body><div id="sidebar"><div id="menu-mask"></div><div id="sidebar-menus"><div class="avatar-img is-center"><img src="/img/avatar.jpg" onerror="onerror=null;src='/img/friend_404.gif'" alt="avatar"/></div><div class="sidebar-site-data site-data is-center"><a href="/archives/"><div class="headline">文章</div><div class="length-num">130</div></a><a href="/tags/"><div class="headline">标签</div><div class="length-num">4</div></a><a href="/categories/"><div class="headline">分类</div><div class="length-num">10</div></a></div><hr class="custom-hr"/><div class="menus_items"><div class="menus_item"><a class="site-page" href="/"><i class="fa-fw fas fa-home"></i><span> Home</span></a></div><div class="menus_item"><a class="site-page" href="/archives/"><i class="fa-fw fas fa-archive"></i><span> Archives</span></a></div><div class="menus_item"><a class="site-page" href="/tags/"><i class="fa-fw fas fa-tags"></i><span> Tags</span></a></div><div class="menus_item"><a class="site-page" href="/categories/"><i class="fa-fw fas fa-folder-open"></i><span> Categories</span></a></div><div class="menus_item"><a class="site-page group" href="javascript:void(0);"><i class="fa-fw fas fa-list"></i><span> List</span><i class="fas fa-chevron-down"></i></a><ul class="menus_item_child"><li><a class="site-page child" href="/music/"><i class="fa-fw fas fa-music"></i><span> Music</span></a></li><li><a class="site-page child" href="/movies/"><i class="fa-fw fas fa-video"></i><span> Movie</span></a></li></ul></div><div class="menus_item"><a class="site-page" href="/link/"><i class="fa-fw fas fa-link"></i><span> Link</span></a></div><div class="menus_item"><a class="site-page" href="/about/"><i class="fa-fw fas fa-heart"></i><span> About</span></a></div></div></div></div><div class="post" id="body-wrap"><header class="post-bg" id="page-header" style="background-image: url('https://i.loli.net/2020/05/01/gkihqEjXxJ5UZ1C.jpg')"><nav id="nav"><span id="blog-info"><a href="/" title="Blog"><span class="site-name">Blog</span></a></span><div id="menus"><div id="search-button"><a class="site-page social-icon search" href="javascript:void(0);"><i class="fas fa-search fa-fw"></i><span> 搜索</span></a></div><div class="menus_items"><div class="menus_item"><a class="site-page" href="/"><i class="fa-fw fas fa-home"></i><span> Home</span></a></div><div class="menus_item"><a class="site-page" href="/archives/"><i class="fa-fw fas fa-archive"></i><span> Archives</span></a></div><div class="menus_item"><a class="site-page" href="/tags/"><i class="fa-fw fas fa-tags"></i><span> Tags</span></a></div><div class="menus_item"><a class="site-page" href="/categories/"><i class="fa-fw fas fa-folder-open"></i><span> Categories</span></a></div><div class="menus_item"><a class="site-page group" href="javascript:void(0);"><i class="fa-fw fas fa-list"></i><span> List</span><i class="fas fa-chevron-down"></i></a><ul class="menus_item_child"><li><a class="site-page child" href="/music/"><i class="fa-fw fas fa-music"></i><span> Music</span></a></li><li><a class="site-page child" href="/movies/"><i class="fa-fw fas fa-video"></i><span> Movie</span></a></li></ul></div><div class="menus_item"><a class="site-page" href="/link/"><i class="fa-fw fas fa-link"></i><span> Link</span></a></div><div class="menus_item"><a class="site-page" href="/about/"><i class="fa-fw fas fa-heart"></i><span> About</span></a></div></div><div id="toggle-menu"><a class="site-page" href="javascript:void(0);"><i class="fas fa-bars fa-fw"></i></a></div></div></nav><div id="post-info"><h1 class="post-title">Linux内核网络栈主要结构介绍</h1><div id="post-meta"><div class="meta-firstline"><span class="post-meta-date"><i class="far fa-calendar-alt fa-fw post-meta-icon"></i><span class="post-meta-label">发表于</span><time class="post-meta-date-created" datetime="2023-01-15T01:13:37.000Z" title="发表于 2023-01-15 09:13:37">2023-01-15</time><span class="post-meta-separator">|</span><i class="fas fa-history fa-fw post-meta-icon"></i><span class="post-meta-label">更新于</span><time class="post-meta-date-updated" datetime="2024-08-28T10:13:39.915Z" title="更新于 2024-08-28 18:13:39">2024-08-28</time></span><span class="post-meta-categories"><span class="post-meta-separator">|</span><i class="fas fa-inbox fa-fw post-meta-icon"></i><a class="post-meta-categories" href="/categories/linux-doc-%E7%BD%91%E7%BB%9C%E5%8D%8F%E8%AE%AE%E6%A0%88/">linux-doc 网络协议栈</a></span></div><div class="meta-secondline"><span class="post-meta-separator">|</span><span class="post-meta-pv-cv" id="" data-flag-title="Linux内核网络栈主要结构介绍"><i class="far fa-eye fa-fw post-meta-icon"></i><span class="post-meta-label">阅读量:</span><span id="busuanzi_value_page_pv"><i class="fa-solid fa-spinner fa-spin"></i></span></span></div></div></div></header><main class="layout" id="content-inner"><div id="post"><article class="post-content" id="article-container"><h2 id="1、socket"><a href="#1、socket" class="headerlink" title="1、socket"></a>1、socket</h2><p>（include\linux\Socket.h）该结构体socket 主要使用在BSD socket 层，是最上层的结构，在INET socket 层也会有涉及，但很少。</p>
<figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line">/* </span><br><span class="line"> * Internal representation of a socket. not all the fields are used by </span><br><span class="line"> * all configurations: </span><br><span class="line"> * </span><br><span class="line"> *            server                client </span><br><span class="line"> * conn     client connected to server connected to </span><br><span class="line"> * iconn        list of clients     -unused- </span><br><span class="line"> *       awaiting connections </span><br><span class="line"> * wait     sleep for clients,  sleep for connection, </span><br><span class="line"> *          sleep for i/o               sleep for i/o </span><br><span class="line"> */  </span><br><span class="line"> //该结构表示一个网络套接字  </span><br><span class="line">struct socket &#123;  </span><br><span class="line">  short         type;       /* 套接字所用的流类型*/  </span><br><span class="line">  socket_state      state;//套接字所处状态  </span><br><span class="line">  long          flags;//标识字段，目前尚无明确作用  </span><br><span class="line">  struct proto_ops  *ops;       /* 操作函数集指针  */  </span><br><span class="line">    /* data保存指向‘私有&#x27;数据结构指针，在不同的域指向不同的数据结构        */  </span><br><span class="line">  //在INET域，指向sock结构，UNIX域指向unix_proto_data结构  </span><br><span class="line">  void          *data;    </span><br><span class="line">  //下面两个字段只用于UNIX域  </span><br><span class="line">  struct socket     *conn;      /* 指向连接的对端套接字   */  </span><br><span class="line">  struct socket     *iconn;     /* 指向正等待连接的客户端(服务器端)    */  </span><br><span class="line">  struct socket     *next;//链表  </span><br><span class="line">  struct wait_queue **wait;     /* 等待队列 */  </span><br><span class="line">  struct inode      *inode;//inode结构指针  </span><br><span class="line">  struct fasync_struct  *fasync_list;   /* 异步唤醒链表结构 */  </span><br><span class="line">&#125;;  </span><br></pre></td></tr></table></figure>

<h2 id="2、sock"><a href="#2、sock" class="headerlink" title="2、sock"></a>2、sock</h2><p>(include\linux\Net.h) sock 的使用范围比socket 要大得多，sock结构的使用基本贯穿硬件层、设备接口层、ip层、INET socket 层，而且是作为各层之间的一个联系，主要是因为无论是发送还是接收的数据包都要被缓存到sock 结构中的缓冲队列中。</p>
<p>sock 结构与其对应的 socket 会相互绑定。</p>
<figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br></pre></td><td class="code"><pre><span class="line">/* </span><br><span class="line"> * This structure really needs to be cleaned up. </span><br><span class="line"> * Most of it is for TCP, and not used by any of </span><br><span class="line"> * the other protocols. </span><br><span class="line"> * 大部分功能是为TCP准备的 </span><br><span class="line"> */  </span><br><span class="line">struct sock &#123;  </span><br><span class="line">  struct options        *opt;//IP选项缓冲于此处  </span><br><span class="line">  volatile unsigned long    wmem_alloc;//发送缓冲队列中存放的数据的大小，这两个与后面的rcvbuf和sndbuf一起使用  </span><br><span class="line">  volatile unsigned long    rmem_alloc;//接收缓冲队列中存放的数据的大小  </span><br><span class="line">  /* 下面三个seq用于TCP协议中为保证可靠数据传输而使用的序列号 */  </span><br><span class="line">  unsigned long         write_seq;//  </span><br><span class="line">  unsigned long         sent_seq;//  </span><br><span class="line">  unsigned long         acked_seq;//  </span><br><span class="line">  unsigned long         copied_seq;//应用程序有待读取(但尚未读取)数据的第一个序列号  </span><br><span class="line">  unsigned long         rcv_ack_seq;//目前本地接收到的对本地发送数据的应答序列号  </span><br><span class="line">  unsigned long         window_seq;//窗口大小  </span><br><span class="line">  unsigned long         fin_seq;//应答序列号  </span><br><span class="line">  //下面两个字段用于紧急数据处理  </span><br><span class="line">  unsigned long         urg_seq;//紧急数据最大序列号  </span><br><span class="line">  unsigned long         urg_data;//标志位，1表示收到紧急数据  </span><br><span class="line">  </span><br><span class="line">  /* </span><br><span class="line">   * Not all are volatile, but some are, so we </span><br><span class="line">   * might as well say they all are. </span><br><span class="line">   */  </span><br><span class="line">  volatile char                 inuse,//表示其他进程正在使用该sock结构，本进程需等待  </span><br><span class="line">                dead,//表示该sock结构已处于释放状态  </span><br><span class="line">                urginline,//=1，表示紧急数据将被当做普通数据处理  </span><br><span class="line">                intr,//  </span><br><span class="line">                blog,  </span><br><span class="line">                done,  </span><br><span class="line">                reuse,  </span><br><span class="line">                keepopen,//=1，使用保活定时器  </span><br><span class="line">                linger,//=1，表示在关闭套接字时需要等待一段时间以确认其已关闭  </span><br><span class="line">                delay_acks,//=1，表示延迟应答  </span><br><span class="line">                destroy,//=1，表示该sock结构等待销毁  </span><br><span class="line">                ack_timed,  </span><br><span class="line">                no_check,  </span><br><span class="line">                zapped, /* In ax25 &amp; ipx means not linked */  </span><br><span class="line">                broadcast,  </span><br><span class="line">                nonagle;//=1，表示不使用NAGLE算法  </span><br><span class="line">                //NAGLE算法:在前一个发送的数据包被应答之前，不可再继续发送其它数据包  </span><br><span class="line">  unsigned long             lingertime;//等待关闭操作的时间  </span><br><span class="line">  int               proc;//该sock结构所属的进程的进程号  </span><br><span class="line">  struct sock           *next;  </span><br><span class="line">  struct sock           *prev; /* Doubly linked chain.. */  </span><br><span class="line">  struct sock           *pair;  </span><br><span class="line">  //下面两个字段用于TCP协议重发队列  </span><br><span class="line">  struct sk_buff        * volatile send_head;//这个队列中的数据均已经发送出去，但尚未接收到应答  </span><br><span class="line">  struct sk_buff        * volatile send_tail;  </span><br><span class="line">  struct sk_buff_head       back_log;//接收的数据包缓存队列，当套接字正忙时，数据包暂存在这里  </span><br><span class="line">  struct sk_buff        *partial;//用于创建最大长度的待发送数据包  </span><br><span class="line">  struct timer_list     partial_timer;//定时器，用于按时发送partial指针指向的数据包  </span><br><span class="line">  long              retransmits;//重发次数  </span><br><span class="line">  struct sk_buff_head       write_queue,//指向待发送数据包  </span><br><span class="line">                receive_queue;//读队列，表示数据报已被正式接收，该队列中的数据可被应用程序读取?  </span><br><span class="line">  struct proto          *prot;//传输层处理函数集  </span><br><span class="line">  struct wait_queue     **sleep;  </span><br><span class="line">  unsigned long         daddr;//sock结构所代表套接字的远端地址  </span><br><span class="line">  unsigned long         saddr;//本地地址  </span><br><span class="line">  unsigned short        max_unacked;//最大未处理请求连接数  </span><br><span class="line">  unsigned short        window;//远端窗口大小  </span><br><span class="line">  unsigned short        bytes_rcv;//已接收字节总数  </span><br><span class="line">/* mss is min(mtu, max_window) */  </span><br><span class="line">  unsigned short        mtu; //和链路层协议密切相关      /* 最大传输单元 */  </span><br><span class="line">  volatile unsigned short   mss; //最大报文长度 =mtu-ip首部长度-tcp首部长度，也就是tcp数据包每次能够传输的最大数据分段  </span><br><span class="line">  volatile unsigned short   user_mss;  /* mss requested by user in ioctl */  </span><br><span class="line">  volatile unsigned short   max_window;//最大窗口大小  </span><br><span class="line">  unsigned long         window_clamp;//窗口大小钳制值  </span><br><span class="line">  unsigned short        num;//本地端口号  </span><br><span class="line">  //下面三个字段用于拥塞算法  </span><br><span class="line">  volatile unsigned short   cong_window;  </span><br><span class="line">  volatile unsigned short   cong_count;  </span><br><span class="line">  volatile unsigned short   ssthresh;  </span><br><span class="line">  volatile unsigned short   packets_out;//本地已发送出去但尚未得到应答的数据包数目  </span><br><span class="line">  volatile unsigned short   shutdown;//本地关闭标志位，用于半关闭操作  </span><br><span class="line">  volatile unsigned long    rtt;//往返时间估计值  </span><br><span class="line">  volatile unsigned long    mdev;//绝对偏差  </span><br><span class="line">  volatile unsigned long    rto;//用rtt和mdev 用算法计算出的延迟时间值  </span><br><span class="line">/* currently backoff isn&#x27;t used, but I&#x27;m maintaining it in case </span><br><span class="line"> * we want to go back to a backoff formula that needs it </span><br><span class="line"> */  </span><br><span class="line">  volatile unsigned short   backoff;//退避算法度量值  </span><br><span class="line">  volatile short        err;//错误标志值  </span><br><span class="line">  unsigned char         protocol;//传输层协议值  </span><br><span class="line">  volatile unsigned char    state;//套接字状态值  </span><br><span class="line">  volatile unsigned char    ack_backlog;//缓存的未应答数据包个数  </span><br><span class="line">  unsigned char         max_ack_backlog;//最大缓存的未应答数据包个数  </span><br><span class="line">  unsigned char         priority;//该套接字优先级  </span><br><span class="line">  unsigned char         debug;  </span><br><span class="line">  unsigned short        rcvbuf;//最大接收缓冲区大小  </span><br><span class="line">  unsigned short        sndbuf;//最大发送缓冲区大小  </span><br><span class="line">  unsigned short        type;//类型值如 SOCK_STREAM  </span><br><span class="line">  unsigned char         localroute;//=1,表示只使用本地路由 /* Route locally only */  </span><br><span class="line">#ifdef CONFIG_IPX  </span><br><span class="line">  ipx_address           ipx_dest_addr;  </span><br><span class="line">  ipx_interface         *ipx_intrfc;  </span><br><span class="line">  unsigned short        ipx_port;  </span><br><span class="line">  unsigned short        ipx_type;  </span><br><span class="line">#endif  </span><br><span class="line">#ifdef CONFIG_AX25  </span><br><span class="line">/* Really we want to add a per protocol private area */  </span><br><span class="line">  ax25_address          ax25_source_addr,ax25_dest_addr;  </span><br><span class="line">  struct sk_buff *volatile  ax25_retxq[8];  </span><br><span class="line">  char              ax25_state,ax25_vs,ax25_vr,ax25_lastrxnr,ax25_lasttxnr;  </span><br><span class="line">  char              ax25_condition;  </span><br><span class="line">  char              ax25_retxcnt;  </span><br><span class="line">  char              ax25_xx;  </span><br><span class="line">  char              ax25_retxqi;  </span><br><span class="line">  char              ax25_rrtimer;  </span><br><span class="line">  char              ax25_timer;  </span><br><span class="line">  unsigned char         ax25_n2;  </span><br><span class="line">  unsigned short        ax25_t1,ax25_t2,ax25_t3;  </span><br><span class="line">  ax25_digi         *ax25_digipeat;  </span><br><span class="line">#endif    </span><br><span class="line">#ifdef CONFIG_ATALK  </span><br><span class="line">  struct atalk_sock     at;  </span><br><span class="line">#endif  </span><br><span class="line">  </span><br><span class="line">/* IP &#x27;private area&#x27; or will be eventually */  </span><br><span class="line">  int               ip_ttl;//ip首部ttl字段值，实际上表示路由器跳数      /* TTL setting */  </span><br><span class="line">  int               ip_tos;//ip首部tos字段值，服务类型值       /* TOS */  </span><br><span class="line">  struct tcphdr         dummy_th;//缓存的tcp首部，在tcp协议中创建一个发送数据包时可以利用此字段快速创建tcp首部  </span><br><span class="line">  struct timer_list     keepalive_timer;//保活定时器，用于探测对方窗口大小，防止对方通报窗口大小的数据包丢弃 /* TCP keepalive hack */  </span><br><span class="line">  struct timer_list     retransmit_timer;//重发定时器，用于数据包超时重发  /* TCP retransmit timer */  </span><br><span class="line">  struct timer_list     ack_timer;//延迟应答定时器     /* TCP delayed ack timer */  </span><br><span class="line">  int               ip_xmit_timeout;//表示定时器超时原因 /* Why the timeout is running */  </span><br><span class="line">  </span><br><span class="line">//用于ip多播  </span><br><span class="line">#ifdef CONFIG_IP_MULTICAST    </span><br><span class="line">  int               ip_mc_ttl;          /* Multicasting TTL */  </span><br><span class="line">  int               ip_mc_loop;         /* Loopback (not implemented yet) */  </span><br><span class="line">  char              ip_mc_name[MAX_ADDR_LEN];   /* Multicast device name */  </span><br><span class="line">  struct ip_mc_socklist     *ip_mc_list;            /* Group array */  </span><br><span class="line">#endif    </span><br><span class="line">  </span><br><span class="line">  /* This part is used for the timeout functions (timer.c). */  </span><br><span class="line">  int               timeout;    /* What are we waiting for? */  </span><br><span class="line">  struct timer_list     timer;      /* This is the TIME_WAIT/receive timer when we are doing IP */  </span><br><span class="line">  struct timeval        stamp;  </span><br><span class="line">  </span><br><span class="line">  /* identd */  </span><br><span class="line">  //一个套接在在不同的层次上分别由socket结构和sock结构表示  </span><br><span class="line">  struct socket         *socket;  </span><br><span class="line">    </span><br><span class="line">  /* Callbacks *///回调函数  </span><br><span class="line">  void              (*state_change)(struct sock *sk);  </span><br><span class="line">  void              (*data_ready)(struct sock *sk,int bytes);  </span><br><span class="line">  void              (*write_space)(struct sock *sk);  </span><br><span class="line">  void              (*error_report)(struct sock *sk);  </span><br><span class="line">    </span><br><span class="line">&#125;;  </span><br></pre></td></tr></table></figure>

<h2 id="3、sk-buff"><a href="#3、sk-buff" class="headerlink" title="3、sk_buff"></a>3、sk_buff</h2><p>(include\linux\Skbuff.h) sk_buff 是网络数据报在内核中的表现形式，通过源码可以看出，数据包在内核协议栈中是通过这个数据结构来变现的。</p>
<p>从其中的 union 字段可以看出，该结构是贯穿在各个层的，可以说这个结构是用来为网络数据包服务的。其中的字段表明了数据包隶属的套接字、当前所处的协议层、所搭载的数据负载长度（data指针指向）、源端，目的端地址以及相关字段等。</p>
<p>主要重要的一个字段是 data[0]，这是一个指针，它指向对应层的数据报（首部+数据负载）内容的首地址。怎么解释呢？</p>
<p>如果在传输层，那么data指向的数据部分的首地址，其数据部分为 TCP 首部 + 有效数据负载。</p>
<p>如果在网络层，data指向的数据部分的首地址，其数据部分为 IP 首部 + TCP 首部 + 有效数据负载。</p>
<p>如果在链路层，data指向的首地址，其数据布局为 MAC 首部 + IP 首部 + TCP 首部 + 有效数据负载。</p>
<p>所以在该skb_buff结构传递时，获取某一层的首部，都是通过拷贝 data 指向地址对应首部大小的数据。</p>
<figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br></pre></td><td class="code"><pre><span class="line">  //sk_buff 结构用来封装网络数据  </span><br><span class="line">  //网络栈代码对数据的处理都是以sk_buff 结构为单元进行的  </span><br><span class="line">struct sk_buff &#123;  </span><br><span class="line">  struct sk_buff        * volatile next;  </span><br><span class="line">  struct sk_buff        * volatile prev;//构成队列  </span><br><span class="line">#if CONFIG_SKB_CHECK  </span><br><span class="line">  int               magic_debug_cookie; //调试用  </span><br><span class="line">#endif  </span><br><span class="line">  struct sk_buff        * volatile link3; //构成数据包重发队列  </span><br><span class="line">  struct sock           *sk; //数据包所属的套接字  </span><br><span class="line">  volatile unsigned long    when;    //数据包的发送时间，用于计算往返时间RTT/* used to compute rtt&#x27;s */  </span><br><span class="line">  struct timeval        stamp; //记录时间  </span><br><span class="line">  struct device         *dev; //接收该数据包的接口设备  </span><br><span class="line">  struct sk_buff        *mem_addr; //该sk_buff在内存中的基地址，用于释放该sk_buff结构  </span><br><span class="line">  //联合类型，表示数据报在不同处理层次上所到达的处理位置  </span><br><span class="line">  union &#123;  </span><br><span class="line">    struct tcphdr   *th; //传输层tcp，指向首部第一个字节位置  </span><br><span class="line">    struct ethhdr   *eth; //链路层上，指向以太网首部第一个字节位置  </span><br><span class="line">    struct iphdr    *iph; //网络层上，指向ip首部第一个字节位置  </span><br><span class="line">    struct udphdr   *uh; //传输层udp协议，  </span><br><span class="line">    unsigned char   *raw; //随层次变化而变化，链路层=eth，网络层=iph  </span><br><span class="line">    unsigned long   seq; //针对tcp协议的待发送数据包而言，表示该数据包的ACK值  </span><br><span class="line">  &#125; h;  </span><br><span class="line">  struct iphdr      *ip_hdr; //指向ip首部的指针        /* For IPPROTO_RAW */  </span><br><span class="line">  unsigned long         mem_len; //表示sk_buff结构大小加上数据部分的总长度  </span><br><span class="line">  unsigned long         len; //只表示数据部分长度，len = mem_len - sizeof(sk_buff)  </span><br><span class="line">  unsigned long         fraglen; //分片数据包个数  </span><br><span class="line">  struct sk_buff        *fraglist;  /* Fragment list */  </span><br><span class="line">  unsigned long         truesize; //同men_len  </span><br><span class="line">  unsigned long         saddr; //源端ip地址  </span><br><span class="line">  unsigned long         daddr; //目的端ip地址  </span><br><span class="line">  unsigned long         raddr; //数据包下一站ip地址     /* next hop addr */  </span><br><span class="line">   //标识字段  </span><br><span class="line">  volatile char         acked, //=1，表示数据报已得到确认，可以从重发队列中删除  </span><br><span class="line">                used, //=1，表示该数据包的数据已被应用程序读完，可以进行释放  </span><br><span class="line">                free, //用于数据包发送，=1表示再进行发送操作后立即释放，无需缓存  </span><br><span class="line">                arp; //用于待发送数据包，=1表示已完成MAC首部的建立，=0表示还不知道目的端MAC地址  </span><br><span class="line">  //已进行tries试发送，该数据包正在被其余部分使用，路由类型，数据包类型  </span><br><span class="line">  unsigned char         tries,lock,localroute,pkt_type;  </span><br><span class="line">   //下面是数据包的类型，即pkt_type的取值  </span><br><span class="line">#define PACKET_HOST     0     //发往本机    /* To us */  </span><br><span class="line">#define PACKET_BROADCAST    1 //广播  </span><br><span class="line">#define PACKET_MULTICAST    2 //多播  </span><br><span class="line">#define PACKET_OTHERHOST    3 //其他机器        /* Unmatched promiscuous */  </span><br><span class="line">  unsigned short        users; //使用该数据包的模块数     /* User count - see datagram.c (and soon seqpacket.c/stream.c) */  </span><br><span class="line">  unsigned short        pkt_class;  /* For drivers that need to cache the packet type with the skbuff (new PPP) */  </span><br><span class="line">#ifdef CONFIG_SLAVE_BALANCING  </span><br><span class="line">  unsigned short        in_dev_queue; //该字段是否正在缓存于设备缓存队列中  </span><br><span class="line">#endif    </span><br><span class="line">  unsigned long         padding[0]; //填充字节  </span><br><span class="line">  unsigned char         data[0]; //指向该层数据部分  </span><br><span class="line">  //data指向的数据负载首地址，在各个层对应不同的数据部分  </span><br><span class="line">//从侧面看出sk_buff结构基本上是贯穿整个网络栈的非常重要的一个数据结构  </span><br><span class="line">&#125;;  </span><br></pre></td></tr></table></figure>

<h2 id="4、device"><a href="#4、device" class="headerlink" title="4、device"></a>4、device</h2><p>（include\linux\Netdevice.h）该结构表明了一个网络设备需要的字段信息。</p>
<figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br></pre></td><td class="code"><pre><span class="line">/* </span><br><span class="line"> * The DEVICE structure. </span><br><span class="line"> * Actually, this whole structure is a big mistake.  It mixes I/O </span><br><span class="line"> * data with strictly &quot;high-level&quot; data, and it has to know about </span><br><span class="line"> * almost every data structure used in the INET module.   </span><br><span class="line"> */  </span><br><span class="line">  //网络设备结构  </span><br><span class="line">struct device   </span><br><span class="line">&#123;  </span><br><span class="line">  </span><br><span class="line">  /* </span><br><span class="line">   * This is the first field of the &quot;visible&quot; part of this structure </span><br><span class="line">   * (i.e. as seen by users in the &quot;Space.c&quot; file).  It is the name </span><br><span class="line">   * the interface. </span><br><span class="line">   */  </span><br><span class="line">  char            *name;//设备名称  </span><br><span class="line">  </span><br><span class="line">  /* I/O specific fields - FIXME: Merge these and struct ifmap into one */  </span><br><span class="line">  unsigned long       rmem_end;//设备读缓冲区空间       /* shmem &quot;recv&quot; end */  </span><br><span class="line">  unsigned long       rmem_start;       /* shmem &quot;recv&quot; start   */  </span><br><span class="line">  unsigned long       mem_end;//设备总缓冲区首地址和尾地址       /* sahared mem end  */  </span><br><span class="line">  unsigned long       mem_start;        /* shared mem start */  </span><br><span class="line">  unsigned long       base_addr;//设备寄存器读写IO基地址      /* device I/O address   */  </span><br><span class="line">  unsigned char       irq;  //设备所使用中断号      /* device IRQ number    */  </span><br><span class="line">  </span><br><span class="line">  /* Low-level status flags. */  </span><br><span class="line">  volatile unsigned char  start,//=1，表示设备已处于工作状态        /* start an operation   */  </span><br><span class="line">                          tbusy,//=1，表示设备正忙于数据包发送       /* transmitter busy */  </span><br><span class="line">                          interrupt;//=1，软件正在进行设备中断处理       /* interrupt arrived    */  </span><br><span class="line">  </span><br><span class="line">  struct device       *next;//构成设备队列  </span><br><span class="line">  </span><br><span class="line">  /* The device initialization function. Called only once. */  </span><br><span class="line">  int             (*init)(struct device *dev);//设备初始化指针(函数指针)  </span><br><span class="line">  </span><br><span class="line">  /* Some hardware also needs these fields, but they are not part of the </span><br><span class="line">     usual set specified in Space.c. */  </span><br><span class="line">  unsigned char       if_port;//指定使用的设备端口号      /* Selectable AUI, TP,..*/  </span><br><span class="line">  unsigned char       dma;//设备所用的dma通道号         /* DMA channel      */  </span><br><span class="line">  </span><br><span class="line">  struct enet_statistics* (*get_stats)(struct device *dev);//设备信息获取函数指针  </span><br><span class="line">  </span><br><span class="line">  /* </span><br><span class="line">   * This marks the end of the &quot;visible&quot; part of the structure. All </span><br><span class="line">   * fields hereafter are internal to the system, and may change at </span><br><span class="line">   * will (read: may be cleaned up at will). </span><br><span class="line">   */  </span><br><span class="line">  </span><br><span class="line">  /* These may be needed for future network-power-down code. */  </span><br><span class="line">  unsigned long       trans_start;//用于传输超时计算    /* Time (in jiffies) of last Tx */  </span><br><span class="line">  unsigned long       last_rx;//上次接收一个数据包的时间    /* Time of last Rx      */  </span><br><span class="line">  </span><br><span class="line">  unsigned short      flags;//标志位   /* interface flags (a la BSD)   */  </span><br><span class="line">  unsigned short      family;//设备所属的域协议 /* address family ID (AF_INET)  */  </span><br><span class="line">  unsigned short      metric;   /* routing metric (not used)    */  </span><br><span class="line">  unsigned short      mtu;//该接口设备的最大传输单元，ip首部+tcp首部+有效数据负载，去掉了以太网帧的帧头 /* interface MTU value*/  </span><br><span class="line">  unsigned short      type;//该设备所属硬件类型      /* interface hardware type  */  </span><br><span class="line">  unsigned short      hard_header_len;//硬件首部长度  /* hardware hdr length  */  </span><br><span class="line">  void            *priv;//私有数据指针    /* pointer to private data  */  </span><br><span class="line">  </span><br><span class="line">  /* Interface address info. */  </span><br><span class="line">  unsigned char       broadcast[MAX_ADDR_LEN];//链路层硬件广播地址   /* hw bcast add */  </span><br><span class="line">  unsigned char       dev_addr[MAX_ADDR_LEN];//本设备硬件地址  /* hw address   */  </span><br><span class="line">  unsigned char       addr_len;//硬件地址长度 /* hardware address length  */  </span><br><span class="line">  unsigned long       pa_addr;//本地ip地址  /* protocol address     */  </span><br><span class="line">  unsigned long       pa_brdaddr;//网络层广播ip地址    /* protocol broadcast addr  */  </span><br><span class="line">  unsigned long       pa_dstaddr;//点对点网络中对点的ip地址    /* protocol P-P other side addr */  </span><br><span class="line">  unsigned long       pa_mask;//ip地址网络掩码    /* protocol netmask     */  </span><br><span class="line">  unsigned short      pa_alen;//ip地址长度  /* protocol address length  */  </span><br><span class="line">  </span><br><span class="line">  struct dev_mc_list     *mc_list;//多播地址链表  /* Multicast mac addresses  */  </span><br><span class="line">  int            mc_count;//多播地址数目  /* Number of installed mcasts   */  </span><br><span class="line">    </span><br><span class="line">  struct ip_mc_list  *ip_mc_list;//网络层ip多播地址链表  /* IP multicast filter chain    */  </span><br><span class="line">      </span><br><span class="line">  /* For load balancing driver pair support */  </span><br><span class="line">    </span><br><span class="line">  unsigned long        pkt_queue;//该设备缓存的待发送的数据包个数  /* Packets queued */  </span><br><span class="line">  struct device       *slave;//从设备  /* Slave device */  </span><br><span class="line">    </span><br><span class="line">  </span><br><span class="line">  /* Pointer to the interface buffers. */  </span><br><span class="line">  struct sk_buff_head     buffs[DEV_NUMBUFFS];//设备缓存的待发送的数据包  </span><br><span class="line">  </span><br><span class="line"> //函数指针  </span><br><span class="line">  /* Pointers to interface service routines. */  </span><br><span class="line">  int             (*open)(struct device *dev);  </span><br><span class="line">  int             (*stop)(struct device *dev);  </span><br><span class="line">  int             (*hard_start_xmit) (struct sk_buff *skb,  </span><br><span class="line">                          struct device *dev);  </span><br><span class="line">  int             (*hard_header) (unsigned char *buff,  </span><br><span class="line">                      struct device *dev,  </span><br><span class="line">                      unsigned short type,  </span><br><span class="line">                      void *daddr,  </span><br><span class="line">                      void *saddr,  </span><br><span class="line">                      unsigned len,  </span><br><span class="line">                      struct sk_buff *skb);  </span><br><span class="line">  int             (*rebuild_header)(void *eth, struct device *dev,  </span><br><span class="line">                unsigned long raddr, struct sk_buff *skb);  </span><br><span class="line">  </span><br><span class="line">  //用于从接收到的数据包提取MAC首部中类型字符值，从而将数据包传送给适当的协议处理函数进行处理  </span><br><span class="line">  unsigned short      (*type_trans) (struct sk_buff *skb,  </span><br><span class="line">                     struct device *dev);  </span><br><span class="line">#define HAVE_MULTICAST             </span><br><span class="line">  void            (*set_multicast_list)(struct device *dev,  </span><br><span class="line">                     int num_addrs, void *addrs);  </span><br><span class="line">#define HAVE_SET_MAC_ADDR          </span><br><span class="line">  int             (*set_mac_address)(struct device *dev, void *addr);  </span><br><span class="line">#define HAVE_PRIVATE_IOCTL  </span><br><span class="line">  int             (*do_ioctl)(struct device *dev, struct ifreq *ifr, int cmd);  </span><br><span class="line">#define HAVE_SET_CONFIG  </span><br><span class="line">  int             (*set_config)(struct device *dev, struct ifmap *map);  </span><br><span class="line">    </span><br><span class="line">&#125;;  </span><br></pre></td></tr></table></figure>

<h2 id="5、tcp-首部格式"><a href="#5、tcp-首部格式" class="headerlink" title="5、tcp 首部格式"></a>5、tcp 首部格式</h2><figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"> //tcp首部格式  </span><br><span class="line"> //http://blog.csdn.net/wenqian1991/article/details/44598537  </span><br><span class="line">struct tcphdr &#123;  </span><br><span class="line">    __u16   source;//源端口号  </span><br><span class="line">    __u16   dest;//目的端口号  </span><br><span class="line">    __u32   seq;//32位序列号  </span><br><span class="line">    __u32   ack_seq;//32位确认号  </span><br><span class="line">#if defined(LITTLE_ENDIAN_BITFIELD)  </span><br><span class="line">    __u16   res1:4,//4位首部长度  </span><br><span class="line">        doff:4,//保留  </span><br><span class="line">        //下面为各个控制位  </span><br><span class="line">        fin:1,//最后控制位，表示数据已全部传输完成  </span><br><span class="line">        syn:1,//同步控制位  </span><br><span class="line">        rst:1,//重置控制位  </span><br><span class="line">        psh:1,//推控制位  </span><br><span class="line">        ack:1,//确认控制位  </span><br><span class="line">        urg:1,//紧急控制位  </span><br><span class="line">        res2:2;//  </span><br><span class="line">#elif defined(BIG_ENDIAN_BITFIELD)  </span><br><span class="line">    __u16   doff:4,  </span><br><span class="line">        res1:4,  </span><br><span class="line">        res2:2,  </span><br><span class="line">        urg:1,  </span><br><span class="line">        ack:1,  </span><br><span class="line">        psh:1,  </span><br><span class="line">        rst:1,  </span><br><span class="line">        syn:1,  </span><br><span class="line">        fin:1;  </span><br><span class="line">#else  </span><br><span class="line">#error  &quot;Adjust your &lt;asm/byteorder.h&gt; defines&quot;  </span><br><span class="line">#endif    </span><br><span class="line">    __u16   window;//16位窗口大小  </span><br><span class="line">    __u16   check;//16位校验和  </span><br><span class="line">    __u16   urg_ptr;//16位紧急指针  </span><br><span class="line">&#125;;  </span><br></pre></td></tr></table></figure>

<h2 id="6、ip-首部格式"><a href="#6、ip-首部格式" class="headerlink" title="6、ip 首部格式"></a>6、ip 首部格式</h2><figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"> //ip数据报，首部格式  </span><br><span class="line">struct iphdr &#123;  </span><br><span class="line">#if defined(LITTLE_ENDIAN_BITFIELD)//如果是小端模式  </span><br><span class="line">    __u8    ihl:4,//首部长度  </span><br><span class="line">        version:4;//版本  </span><br><span class="line">#elif defined (BIG_ENDIAN_BITFIELD)//大端  </span><br><span class="line">    __u8    version:4,  </span><br><span class="line">        ihl:4;  </span><br><span class="line">#else  </span><br><span class="line">#error  &quot;Please fix &lt;asm/byteorder.h&gt;&quot;  </span><br><span class="line">#endif  </span><br><span class="line">    __u8    tos;//区分服务，用语表示数据报的优先级和服务类型  </span><br><span class="line">    __u16   tot_len;//总长度，标识整个ip数据报的总长度 = 报头+数据部分  </span><br><span class="line">    __u16   id;//表示ip数据报的标识符  </span><br><span class="line">    __u16   frag_off;//片偏移  </span><br><span class="line">    __u8    ttl;//生存时间，即ip数据报在网络中传输的有效期  </span><br><span class="line">    __u8    protocol;//协议，标识此ip数据报在传输层所采用的协议类型  </span><br><span class="line">    __u16   check;//首部校验和  </span><br><span class="line">    __u32   saddr;//源地址  </span><br><span class="line">    __u32   daddr;//目的地址  </span><br><span class="line">    /*The options start here. */  </span><br><span class="line">&#125;;  </span><br></pre></td></tr></table></figure>

<h2 id="7、以太网帧帧头格式"><a href="#7、以太网帧帧头格式" class="headerlink" title="7、以太网帧帧头格式"></a>7、以太网帧帧头格式</h2><figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">/* This is an Ethernet frame header. */ </span><br><span class="line">struct ethhdr &#123;  </span><br><span class="line">  unsigned char     h_dest[ETH_ALEN];//目的地址 /* destination eth addr */ </span><br><span class="line">  unsigned char     h_source[ETH_ALEN];//源地址    /* source ether addr    */ </span><br><span class="line">  unsigned short    h_proto;//类型        /* packet type ID field */ </span><br><span class="line">&#125;;  </span><br></pre></td></tr></table></figure>

<h2 id="8、ARP报文报头"><a href="#8、ARP报文报头" class="headerlink" title="8、ARP报文报头"></a>8、ARP报文报头</h2><figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">/* </span><br><span class="line"> *  This structure defines an ethernet arp header. </span><br><span class="line"> */  </span><br><span class="line"> //ARP报文格式(arp报头)  </span><br><span class="line">struct arphdr  </span><br><span class="line">&#123;  </span><br><span class="line">    unsigned short  ar_hrd;//硬件类型       /* format of hardware address   */  </span><br><span class="line">    unsigned short  ar_pro;//上层协议类型     /* format of protocol address   */  </span><br><span class="line">    unsigned char   ar_hln;//MAC地址长度        /* length of hardware address   */  </span><br><span class="line">    unsigned char   ar_pln;//协议地址长度     /* length of protocol address   */  </span><br><span class="line">    unsigned short  ar_op;//操作类型        /* ARP opcode (command)     */  </span><br><span class="line">  </span><br><span class="line">#if 0  </span><br><span class="line">     /* </span><br><span class="line">      *  Ethernet looks like this : This bit is variable sized however... </span><br><span class="line">      */  </span><br><span class="line">    unsigned char       ar_sha[ETH_ALEN];//源MAC地址   /* sender hardware address  */  </span><br><span class="line">    unsigned char       ar_sip[4];//源IP地址       /* sender IP address        */  </span><br><span class="line">    unsigned char       ar_tha[ETH_ALEN];//目的MAC地址  /* target hardware address  */  </span><br><span class="line">    unsigned char       ar_tip[4];//目的IP地址      /* target IP address        */  </span><br><span class="line">#endif  </span><br><span class="line">  </span><br><span class="line">&#125;;  </span><br></pre></td></tr></table></figure>

<hr>
<p>版权声明：本文为知乎博主「<a target="_blank" rel="noopener" href="https://www.zhihu.com/people/linuxwang-xian-sheng">极致Linux内核</a>」的原创文章，遵循CC 4.0 BY-SA版权协议，转载请附上原文出处链接及本声明。</p>
<p>原文链接：<a target="_blank" rel="noopener" href="https://zhuanlan.zhihu.com/p/549140581">https://zhuanlan.zhihu.com/p/549140581</a></p>
</article><div class="post-copyright"><div class="post-copyright__author"><span class="post-copyright-meta"><i class="fas fa-circle-user fa-fw"></i>文章作者: </span><span class="post-copyright-info"><a href="https://vcloud.ysme.top">ysme</a></span></div><div class="post-copyright__type"><span class="post-copyright-meta"><i class="fas fa-square-arrow-up-right fa-fw"></i>文章链接: </span><span class="post-copyright-info"><a href="https://vcloud.ysme.top/2023/01/15/linux-docs/%E7%BD%91%E7%BB%9C%E5%8D%8F%E8%AE%AE%E6%A0%88/Linux%E5%86%85%E6%A0%B8%E7%BD%91%E7%BB%9C%E6%A0%88%E4%B8%BB%E8%A6%81%E7%BB%93%E6%9E%84%E4%BB%8B%E7%BB%8D/">https://vcloud.ysme.top/2023/01/15/linux-docs/%E7%BD%91%E7%BB%9C%E5%8D%8F%E8%AE%AE%E6%A0%88/Linux%E5%86%85%E6%A0%B8%E7%BD%91%E7%BB%9C%E6%A0%88%E4%B8%BB%E8%A6%81%E7%BB%93%E6%9E%84%E4%BB%8B%E7%BB%8D/</a></span></div><div class="post-copyright__notice"><span class="post-copyright-meta"><i class="fas fa-circle-exclamation fa-fw"></i>版权声明: </span><span class="post-copyright-info">本博客所有文章除特别声明外，均采用 <a href="https://creativecommons.org/licenses/by-nc-sa/4.0/" target="_blank">CC BY-NC-SA 4.0</a> 许可协议。转载请注明来自 <a href="https://vcloud.ysme.top" target="_blank">Blog</a>！</span></div></div><div class="tag_share"><div class="post-meta__tag-list"><a class="post-meta__tags" href="/tags/Linux/">Linux</a></div><div class="post_share"><div class="social-share" data-image="https://i.loli.net/2020/05/01/gkihqEjXxJ5UZ1C.jpg" data-sites="facebook,twitter,wechat,weibo,qq"></div><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/butterfly-extsrc@1.1.3/sharejs/dist/css/share.min.css" media="print" onload="this.media='all'"><script src="https://cdn.jsdelivr.net/npm/butterfly-extsrc@1.1.3/sharejs/dist/js/social-share.min.js" defer></script></div></div><nav class="pagination-post" id="pagination"><div class="prev-post pull-left"><a href="/2023/01/15/linux-docs/%E7%BD%91%E7%BB%9C%E5%8D%8F%E8%AE%AE%E6%A0%88/Linux%E5%86%85%E6%A0%B8%E7%BD%91%E7%BB%9C%E5%8D%8F%E8%AE%AE%E6%A0%88%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9F%BA%E7%A1%80/" title="Linux内核网络协议栈计算机基础"><img class="cover" src="https://i.loli.net/2020/05/01/gkihqEjXxJ5UZ1C.jpg" onerror="onerror=null;src='/img/404.jpg'" alt="cover of previous post"><div class="pagination-info"><div class="label">上一篇</div><div class="prev_info">Linux内核网络协议栈计算机基础</div></div></a></div><div class="next-post pull-right"><a href="/2023/01/15/linux-docs/%E7%BD%91%E7%BB%9C%E5%8D%8F%E8%AE%AE%E6%A0%88/Linux%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E5%8E%9F%E7%90%86%E2%80%94%E5%86%85%E6%A0%B8%E7%BD%91%E7%BB%9C%E5%8D%8F%E8%AE%AE%E6%A0%88/" title="Linux操作系统原理—内核网络协议栈"><img class="cover" src="https://i.loli.net/2020/05/01/gkihqEjXxJ5UZ1C.jpg" onerror="onerror=null;src='/img/404.jpg'" alt="cover of next post"><div class="pagination-info"><div class="label">下一篇</div><div class="next_info">Linux操作系统原理—内核网络协议栈</div></div></a></div></nav><div class="relatedPosts"><div class="headline"><i class="fas fa-thumbs-up fa-fw"></i><span>相关推荐</span></div><div class="relatedPosts-list"><div><a href="/2023/01/15/linux-docs/30%E5%88%86%E9%92%9F%E5%AD%A6%E4%BC%9A%E7%BC%96%E8%AF%91linux%E5%86%85%E6%A0%B8/" title="Linux 30分钟学会编译linux内核"><img class="cover" src="https://pic2.zhimg.com/80/v2-99c76217f4575d98a9001a4fd8c1681d_720w.webp" alt="cover"><div class="content is-center"><div class="date"><i class="far fa-calendar-alt fa-fw"></i> 2023-01-15</div><div class="title">Linux 30分钟学会编译linux内核</div></div></a></div><div><a href="/2023/01/15/linux-docs/Linux%20IO%20%E4%B9%8B%20IO%E4%B8%8E%E7%BD%91%E7%BB%9C%E6%A8%A1%E5%9E%8B/" title="Linux IO 之 IO与网络模型"><img class="cover" src="https://user-images.githubusercontent.com/87457873/127649604-761ead2e-8c72-4876-a52f-8310f3c3b49c.png" alt="cover"><div class="content is-center"><div class="date"><i class="far fa-calendar-alt fa-fw"></i> 2023-01-15</div><div class="title">Linux IO 之 IO与网络模型</div></div></a></div><div><a href="/2023/01/15/linux-docs/Linux%20Kernel%E5%86%85%E6%A0%B8%E6%95%B4%E4%BD%93%E6%9E%B6%E6%9E%84(%E5%9B%BE%E6%96%87%E8%AF%A6%E8%A7%A3)/" title="Linux Kernel内核整体架构(图文详解)"><img class="cover" src="https://pic2.zhimg.com/80/v2-93cd0f1a4abbdfeb4af71202535fe4f9_720w.webp" alt="cover"><div class="content is-center"><div class="date"><i class="far fa-calendar-alt fa-fw"></i> 2023-01-15</div><div class="title">Linux Kernel内核整体架构(图文详解)</div></div></a></div><div><a href="/2023/01/15/linux-docs/Linux%E5%86%85%E6%A0%B8Coding%20Style%E6%95%B4%E7%90%86/" title="Linux内核Coding Style整理"><img class="cover" src="https://pic4.zhimg.com/80/v2-55215e20944d5e1a161253e73eddaa07_720w.webp" alt="cover"><div class="content is-center"><div class="date"><i class="far fa-calendar-alt fa-fw"></i> 2023-01-15</div><div class="title">Linux内核Coding Style整理</div></div></a></div><div><a href="/2023/01/15/linux-docs/Linux%E5%86%85%E6%A0%B8Makefile%E7%B3%BB%E7%BB%9F%E6%96%87%E4%BB%B6%E8%AF%A6%E8%A7%A3/" title="Linux内核Makefile系统文件详解"><img class="cover" src="https://pic4.zhimg.com/80/v2-55215e20944d5e1a161253e73eddaa07_720w.webp" alt="cover"><div class="content is-center"><div class="date"><i class="far fa-calendar-alt fa-fw"></i> 2023-01-15</div><div class="title">Linux内核Makefile系统文件详解</div></div></a></div><div><a href="/2023/01/15/linux-docs/Linux%E5%86%85%E6%A0%B8RCU%E6%9C%BA%E5%88%B6/" title="Linux内核RCU机制"><img class="cover" src="https://pic2.zhimg.com/80/v2-012ee665b35eb28bca5c88269765f069_720w.webp" alt="cover"><div class="content is-center"><div class="date"><i class="far fa-calendar-alt fa-fw"></i> 2023-01-15</div><div class="title">Linux内核RCU机制</div></div></a></div></div></div></div><div class="aside-content" id="aside-content"><div class="card-widget card-info"><div class="is-center"><div class="avatar-img"><img src="/img/avatar.jpg" onerror="this.onerror=null;this.src='/img/friend_404.gif'" alt="avatar"/></div><div class="author-info__name">ysme</div><div class="author-info__description">嘻嘻哈哈。</div></div><div class="card-info-data site-data is-center"><a href="/archives/"><div class="headline">文章</div><div class="length-num">130</div></a><a href="/tags/"><div class="headline">标签</div><div class="length-num">4</div></a><a href="/categories/"><div class="headline">分类</div><div class="length-num">10</div></a></div><a id="card-info-btn" target="_blank" rel="noopener" href="https://github.com/ysme1"><i class="fab fa-github"></i><span>Follow Me</span></a><div class="card-info-social-icons is-center"><a class="social-icon" href="https://github.com/ysme1" target="_blank" title="Github"><i class="fab fa-github" style="color: #24292e;"></i></a><a class="social-icon" href="mailto:zys1395740068@gmail.com" target="_blank" title="Email"><i class="fas fa-envelope" style="color: #4a7dbe;"></i></a></div></div><div class="card-widget card-announcement"><div class="item-headline"><i class="fas fa-bullhorn fa-shake"></i><span>公告</span></div><div class="announcement_content">This is my Blog</div></div><div class="sticky_layout"><div class="card-widget" id="card-toc"><div class="item-headline"><i class="fas fa-stream"></i><span>目录</span><span class="toc-percentage"></span></div><div class="toc-content"><ol class="toc"><li class="toc-item toc-level-2"><a class="toc-link" href="#1%E3%80%81socket"><span class="toc-number">1.</span> <span class="toc-text">1、socket</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#2%E3%80%81sock"><span class="toc-number">2.</span> <span class="toc-text">2、sock</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#3%E3%80%81sk-buff"><span class="toc-number">3.</span> <span class="toc-text">3、sk_buff</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#4%E3%80%81device"><span class="toc-number">4.</span> <span class="toc-text">4、device</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#5%E3%80%81tcp-%E9%A6%96%E9%83%A8%E6%A0%BC%E5%BC%8F"><span class="toc-number">5.</span> <span class="toc-text">5、tcp 首部格式</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#6%E3%80%81ip-%E9%A6%96%E9%83%A8%E6%A0%BC%E5%BC%8F"><span class="toc-number">6.</span> <span class="toc-text">6、ip 首部格式</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#7%E3%80%81%E4%BB%A5%E5%A4%AA%E7%BD%91%E5%B8%A7%E5%B8%A7%E5%A4%B4%E6%A0%BC%E5%BC%8F"><span class="toc-number">7.</span> <span class="toc-text">7、以太网帧帧头格式</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#8%E3%80%81ARP%E6%8A%A5%E6%96%87%E6%8A%A5%E5%A4%B4"><span class="toc-number">8.</span> <span class="toc-text">8、ARP报文报头</span></a></li></ol></div></div><div class="card-widget card-recent-post"><div class="item-headline"><i class="fas fa-history"></i><span>最新文章</span></div><div class="aside-list"><div class="aside-list-item"><a class="thumbnail" href="/2023/03/22/%E5%B7%A5%E5%85%B7/git/git%E5%BF%AB%E9%80%9F%E5%85%A5%E9%97%A8/" title="Git 快速入门指南"><img src="https://blog.ysme.top/html/getImage.html" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="Git 快速入门指南"/></a><div class="content"><a class="title" href="/2023/03/22/%E5%B7%A5%E5%85%B7/git/git%E5%BF%AB%E9%80%9F%E5%85%A5%E9%97%A8/" title="Git 快速入门指南">Git 快速入门指南</a><time datetime="2023-03-22T01:13:37.000Z" title="发表于 2023-03-22 09:13:37">2023-03-22</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/2023/01/15/linux-docs/30%E5%88%86%E9%92%9F%E5%AD%A6%E4%BC%9A%E7%BC%96%E8%AF%91linux%E5%86%85%E6%A0%B8/" title="Linux 30分钟学会编译linux内核"><img src="https://pic2.zhimg.com/80/v2-99c76217f4575d98a9001a4fd8c1681d_720w.webp" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="Linux 30分钟学会编译linux内核"/></a><div class="content"><a class="title" href="/2023/01/15/linux-docs/30%E5%88%86%E9%92%9F%E5%AD%A6%E4%BC%9A%E7%BC%96%E8%AF%91linux%E5%86%85%E6%A0%B8/" title="Linux 30分钟学会编译linux内核">Linux 30分钟学会编译linux内核</a><time datetime="2023-01-15T01:13:37.000Z" title="发表于 2023-01-15 09:13:37">2023-01-15</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/2023/01/15/linux-docs/Linux%20IO%20%E4%B9%8B%20IO%E4%B8%8E%E7%BD%91%E7%BB%9C%E6%A8%A1%E5%9E%8B/" title="Linux IO 之 IO与网络模型"><img src="https://user-images.githubusercontent.com/87457873/127649604-761ead2e-8c72-4876-a52f-8310f3c3b49c.png" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="Linux IO 之 IO与网络模型"/></a><div class="content"><a class="title" href="/2023/01/15/linux-docs/Linux%20IO%20%E4%B9%8B%20IO%E4%B8%8E%E7%BD%91%E7%BB%9C%E6%A8%A1%E5%9E%8B/" title="Linux IO 之 IO与网络模型">Linux IO 之 IO与网络模型</a><time datetime="2023-01-15T01:13:37.000Z" title="发表于 2023-01-15 09:13:37">2023-01-15</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/2023/01/15/linux-docs/Linux%20Kernel%E5%86%85%E6%A0%B8%E6%95%B4%E4%BD%93%E6%9E%B6%E6%9E%84(%E5%9B%BE%E6%96%87%E8%AF%A6%E8%A7%A3)/" title="Linux Kernel内核整体架构(图文详解)"><img src="https://pic2.zhimg.com/80/v2-93cd0f1a4abbdfeb4af71202535fe4f9_720w.webp" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="Linux Kernel内核整体架构(图文详解)"/></a><div class="content"><a class="title" href="/2023/01/15/linux-docs/Linux%20Kernel%E5%86%85%E6%A0%B8%E6%95%B4%E4%BD%93%E6%9E%B6%E6%9E%84(%E5%9B%BE%E6%96%87%E8%AF%A6%E8%A7%A3)/" title="Linux Kernel内核整体架构(图文详解)">Linux Kernel内核整体架构(图文详解)</a><time datetime="2023-01-15T01:13:37.000Z" title="发表于 2023-01-15 09:13:37">2023-01-15</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/2023/01/15/linux-docs/Linux%E5%86%85%E6%A0%B8Coding%20Style%E6%95%B4%E7%90%86/" title="Linux内核Coding Style整理"><img src="https://pic4.zhimg.com/80/v2-55215e20944d5e1a161253e73eddaa07_720w.webp" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="Linux内核Coding Style整理"/></a><div class="content"><a class="title" href="/2023/01/15/linux-docs/Linux%E5%86%85%E6%A0%B8Coding%20Style%E6%95%B4%E7%90%86/" title="Linux内核Coding Style整理">Linux内核Coding Style整理</a><time datetime="2023-01-15T01:13:37.000Z" title="发表于 2023-01-15 09:13:37">2023-01-15</time></div></div></div></div></div></div></main><footer id="footer"><div id="footer-wrap"><div class="copyright">&copy;2020 - 2024 By ysme</div><div class="framework-info"><span>框架 </span><a target="_blank" rel="noopener" href="https://hexo.io">Hexo</a><span class="footer-separator">|</span><span>主题 </span><a target="_blank" rel="noopener" href="https://github.com/jerryc127/hexo-theme-butterfly">Butterfly</a></div><div class="footer_custom_text"><a target="_blank" rel="noopener" href="https://beian.miit.gov.cn/#/Integrated/recordQuery"><img class="icp-icon" src=https://beian.mps.gov.cn/img/logo01.dd7ff50e.png><span>浙ICP备2021036292号</span></a></div></div></footer></div><div id="rightside"><div id="rightside-config-hide"><button id="readmode" type="button" title="阅读模式"><i class="fas fa-book-open"></i></button><button id="darkmode" type="button" title="浅色和深色模式转换"><i class="fas fa-adjust"></i></button><button id="hide-aside-btn" type="button" title="单栏和双栏切换"><i class="fas fa-arrows-alt-h"></i></button></div><div id="rightside-config-show"><button id="rightside-config" type="button" title="设置"><i class="fas fa-cog fa-spin"></i></button><button class="close" id="mobile-toc-button" type="button" title="目录"><i class="fas fa-list-ul"></i></button><button id="go-up" type="button" title="回到顶部"><span class="scroll-percent"></span><i class="fas fa-arrow-up"></i></button></div></div><div><script src="/js/utils.js?v=4.13.0"></script><script src="/js/main.js?v=4.13.0"></script><script src="https://cdn.jsdelivr.net/npm/@fancyapps/ui@5.0.33/dist/fancybox/fancybox.umd.min.js"></script><div class="js-pjax"></div><script async data-pjax src="//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script><div id="local-search"><div class="search-dialog"><nav class="search-nav"><span class="search-dialog-title">搜索</span><span id="loading-status"></span><button class="search-close-button"><i class="fas fa-times"></i></button></nav><div class="is-center" id="loading-database"><i class="fas fa-spinner fa-pulse"></i><span>  数据库加载中</span></div><div class="search-wrap"><div id="local-search-input"><div class="local-search-box"><input class="local-search-box--input" placeholder="搜索文章" type="text"/></div></div><hr/><div id="local-search-results"></div><div id="local-search-stats-wrap"></div></div></div><div id="search-mask"></div><script src="/js/search/local-search.js?v=4.13.0"></script></div></div></body></html>