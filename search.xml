<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title>Linux 30分钟学会编译linux内核</title>
    <url>/2023/01/15/linux-docs/30%E5%88%86%E9%92%9F%E5%AD%A6%E4%BC%9A%E7%BC%96%E8%AF%91linux%E5%86%85%E6%A0%B8/</url>
    <content><![CDATA[<h2 id="1、编译前的准备"><a href="#1、编译前的准备" class="headerlink" title="1、编译前的准备"></a><strong>1、编译前的准备</strong></h2><p>下载linux源文件：<a href="https://www.kernel.org/%EF%BC%8C%E6%88%91%E4%B8%8B%E8%BD%BD%E7%9A%84%E6%98%AFlinux-3.7.4%E7%89%88%E6%9C%AC%EF%BC%8C%E8%A7%A3%E5%8E%8B%E5%88%B0/usr/src/kernels%E7%9B%AE%E5%BD%95%E4%B8%AD%EF%BC%8C%E7%84%B6%E5%90%8E%E8%BF%9B%E5%85%A5/usr/src/kernels/linux-3.7.4%E4%B8%AD%EF%BC%8C%E7%94%A8make">https://www.kernel.org/，我下载的是linux-3.7.4版本，解压到/usr/src/kernels目录中，然后进入/usr/src/kernels/linux-3.7.4中，用make</a> menuconfig命令来选择要编译的模块，但使用make menuconfig（重新编译内核常用的命令，还可以用其他的）报下面的错误：</p>
<p><img src="https://pic2.zhimg.com/80/v2-99c76217f4575d98a9001a4fd8c1681d_720w.webp" alt="img"></p>
<p>说缺少ncurses库，然后安装ncurses开发库就可以了，ubuntu下貌似是libncurses-dev包</p>
<p>yum install ncurses-devel.i686</p>
<p>再次使用make menuconfig，出现下面的界面：</p>
<p><img src="https://pic4.zhimg.com/80/v2-9749efd129f16d1a3c6f980cf3d5c7a3_720w.webp" alt="img"></p>
<p>然后我直接保存了，都用的默认的选项。</p>
<h2 id="2、编译内核"><a href="#2、编译内核" class="headerlink" title="2、编译内核"></a><strong>2、编译内核</strong></h2><p>如果你是第一次重新编译内核，先用”make mrproper”命令处理一下内核代码目录中残留的文件，由于我们不知道源代码文件中是否包含像.o之类的文件。</p>
<p>如果不是第一次的话，使用”make clean”命令来清楚.o等编译内核产生的中间文件，但不会删除配置文件。</p>
<p>使用”make bzImage”命令来编译内核，这个内核是经过压缩的。或者使用“make -j10 bzImage”命令，表示用10个线程来编译。</p>
<p>使用”make modules”来编译模块，这个会花费比较长的时间。</p>
<p>上面的命令会花费非常长的时间，编译的动作依据你选择的项目以及你主机硬件的效能而不同。 最后制作出来的数据是被放置在 &#x2F;usr&#x2F;src&#x2F;kernels&#x2F;linux-3.7.4&#x2F; 这个目录下，还没有被放到系统的相关路径中喔！在上面的编译过程当中，如果有发生任何错误的话， 很可能是由于核心模块选择的不好，可能你需要重新以 make menuconfig 再次的检查一下你的相关配置喔！ 如果还是无法成功的话，那么或许将原本系统的内核代码中的 .config 文件，复制到你的内核代码目录下， 然后据以修改，应该就可以顺利的编译出你的核心了。可以发现你的核心已经编译好而且放置在 &#x2F;usr&#x2F;src&#x2F;kernels&#x2F;linux-3.7.4&#x2F;arch&#x2F;x86&#x2F;boot&#x2F;bzImage。</p>
<h2 id="3、安装模块"><a href="#3、安装模块" class="headerlink" title="3、安装模块"></a><strong>3、安装模块</strong></h2><p>使用命令”make modules_install”安装模块，执行成功后，最终会在 &#x2F;lib&#x2F;modules 底下创建起你这个核心的相关模块，我的模块放在&#x2F;lib&#x2F;modules&#x2F;3.7.4目录下，其中3.7.4就是默认的模块名称。</p>
<h2 id="4、安装内核"><a href="#4、安装内核" class="headerlink" title="4、安装内核"></a><strong>4、安装内核</strong></h2><p>有两种方法，一种是手工的，一种是自动的。</p>
<p>如果是用手工的，将编译好的内核 &#x2F;usr&#x2F;src&#x2F;kernels&#x2F;linux-3.7.4&#x2F;arch&#x2F;x86&#x2F;boot&#x2F;bzImage复制到&#x2F;boot&#x2F;中，命名为vmlinuz-3.7.4。用命令”mkinitrd -v &#x2F;boot&#x2F;initrd-3.7.4.img 3.7.4”前面一个参数是生成initrd文件，后面一个参数是对应内核模块的名称，mkinitrd回去查找lib&#x2F;modules&#x2F;3.7.4中的模块，将需要的模块插入initrd文件中。为什么我们要制作initrd文件呢？</p>
<p>initrd 文件，他的目的在于提供启动过程中所需要的最重要的核心模块，以让系统启动过程可以顺利完成。 会需要 initrd 的原因，是因为核心模块放至于&#x2F;lib&#x2F;modules&#x2F;$(uname -r)&#x2F;kernel&#x2F; 当中， 这些模块必须要根目录 (&#x2F;) 被挂载时才能够被读取。但是如果核心本身不具备磁盘的驱动程序时， 当然无法挂载根目录，也就没有办法取得驱动程序，因此造成两难的地步，如果没有initrd文件，启动系统时会报下面的错误。</p>
<p><img src="https://pic1.zhimg.com/80/v2-a9dc897ce503c0295a1e3f10a734bf44_720w.webp" alt="img"></p>
<p>mkinitrd可以将 &#x2F;lib&#x2F;modules&#x2F;…. 内的模块（启动过程当中一定需要的模块）包成一个文件 (就是initrd文件)， 然后在启动时透过主机的 INT 13 硬件功能将该文件读出来解压缩，并且 initrd 在内存内会模拟成为根目录， 由于此虚拟文件系统 (Initial RAM Disk) 主要包含磁盘与文件系统的模块，因此我们的核心最后就能够认识实际的磁盘， 那就能够进行实际根目录的挂载！所以说：initrd 内所包含的模块大多是与启动过程有关，而主要以文件系统及硬盘模块 (如 usb, SCSI 等) 为主！（参考鸟哥的书）</p>
<p>如果是自动的话，直接在 &#x2F;usr&#x2F;src&#x2F;kernels&#x2F;linux-3.7.4目录下输入”make install”就ok了。</p>
<h2 id="5、在启动项中加载新编译的内核"><a href="#5、在启动项中加载新编译的内核" class="headerlink" title="5、在启动项中加载新编译的内核"></a><strong>5、在启动项中加载新编译的内核</strong></h2><p>由于我用的是fedora16,所以直接输入grub2-mkconfig命令，就会在&#x2F;boot&#x2F;grub2&#x2F;grub.cfg文件中将我们刚编译的模块作为一个启动项了。</p>
<p>其它系统可以通过更改&#x2F;boot&#x2F;grub&#x2F;menu.lst文件来添加启动项。</p>
<h2 id="6、重新启动系统"><a href="#6、重新启动系统" class="headerlink" title="6、重新启动系统"></a><strong>6、重新启动系统</strong></h2><p>最后就是重新启动系统，选择刚编译的内核那项启动，不过我的系统总是报下面的错误</p>
<p><img src="https://pic3.zhimg.com/80/v2-f74eb8dd5e44dea0806e1aa7bd52e452_720w.webp" alt="img"></p>
<p>在网上找了半天，很多都是按我上面写的编译内核的，也没出现这个问题，不知道是不是因为我是在vmware下编译内核的原因。汗，按提示是没有找到根设备，但如果我用原本的内核启动，却不会出错，原来的内核启动也是通过uuid来找根设备的。</p>
<hr>
<p>版权声明：本文为知乎博主「<a href="https://www.zhihu.com/people/linuxwang-xian-sheng">极致Linux内核</a>」的原创文章，遵循CC 4.0 BY-SA版权协议，转载请附上原文出处链接及本声明。</p>
<p>原文链接：<a href="https://zhuanlan.zhihu.com/p/547970302">https://zhuanlan.zhihu.com/p/547970302</a></p>
]]></content>
      <categories>
        <category>linux-doc</category>
      </categories>
      <tags>
        <tag>Linux</tag>
      </tags>
  </entry>
  <entry>
    <title>Linux IO 之 IO与网络模型</title>
    <url>/2023/01/15/linux-docs/Linux%20IO%20%E4%B9%8B%20IO%E4%B8%8E%E7%BD%91%E7%BB%9C%E6%A8%A1%E5%9E%8B/</url>
    <content><![CDATA[<h2 id="Linux内核针对不同并发场景的工具实现"><a href="#Linux内核针对不同并发场景的工具实现" class="headerlink" title="Linux内核针对不同并发场景的工具实现"></a>Linux内核针对不同并发场景的工具实现</h2><p><img src="https://user-images.githubusercontent.com/87457873/127649604-761ead2e-8c72-4876-a52f-8310f3c3b49c.png" alt="image"></p>
<h3 id="atomic-原子变量"><a href="#atomic-原子变量" class="headerlink" title="atomic 原子变量"></a>atomic 原子变量</h3><p>x86在多核环境下，多核竞争数据总线时，提供Lock指令进行锁总线操作。保证“读-修改-写”的操作在芯片级的原子性。</p>
<h3 id="spinlock-自旋锁"><a href="#spinlock-自旋锁" class="headerlink" title="spinlock 自旋锁"></a>spinlock 自旋锁</h3><p>自旋锁将当前线程不停地执行循环体，而不改变线程的运行状态，在CPU上实现忙等，以此保证响应速度更快。这种类型的线程数不断增加时，性能明显下降。所以自旋锁保护的临界区必须小，操作过程必须短。</p>
<h3 id="semaphore-信号量"><a href="#semaphore-信号量" class="headerlink" title="semaphore 信号量"></a>semaphore 信号量</h3><p>信号量用于保护有限数量的临界资源，信号量在获取和释放时，通过自旋锁保护，当有中断会把中断保存到eflags寄存器，最后再恢复中断。</p>
<h3 id="mutex-互斥锁"><a href="#mutex-互斥锁" class="headerlink" title="mutex 互斥锁"></a>mutex 互斥锁</h3><p>为了控制同一时刻只有一个线程进入临界区，让无法进入临界区的线程休眠。</p>
<h3 id="rw-lock-读写锁"><a href="#rw-lock-读写锁" class="headerlink" title="rw-lock 读写锁"></a>rw-lock 读写锁</h3><p>读写锁，把读操作和写操作分别进行加锁处理，减小了加锁粒度，优化了读大于写的场景。</p>
<h3 id="preempt-抢占"><a href="#preempt-抢占" class="headerlink" title="preempt 抢占"></a>preempt 抢占</h3><ul>
<li>时间片用完后调用schedule函数。</li>
<li>由于IO等原因自己主动调用schedule。</li>
<li>其他情况，当前进程被其他进程替换的时候。</li>
</ul>
<h3 id="per-cpu-变量"><a href="#per-cpu-变量" class="headerlink" title="per-cpu 变量"></a>per-cpu 变量</h3><p>linux为解决cpu 各自使用的L2 cache 数据与内存中的不一致的问题。</p>
<h3 id="RCU机制-Read-Copy-Update"><a href="#RCU机制-Read-Copy-Update" class="headerlink" title="RCU机制 (Read, Copy, Update)"></a>RCU机制 (Read, Copy, Update)</h3><p>用于解决多个CPU同时读写共享数据的场景。它允许多个CPU同时进行写操作，不使用锁，并且实现垃圾回收来处理旧数据。</p>
<p><img src="https://user-images.githubusercontent.com/87457873/127649772-3121520b-8989-4176-a472-43719b64eb10.png" alt="image"></p>
<h3 id="内存屏障-memory-barrier"><a href="#内存屏障-memory-barrier" class="headerlink" title="内存屏障 memory-barrier"></a>内存屏障 memory-barrier</h3><p>程序运行过程中，对内存访问不一定按照代码编写的顺序来进行。</p>
<ul>
<li>编译器对代码进行优化。</li>
<li>多cpu架构存在指令乱序访问内存的可能。</li>
</ul>
<h2 id="I-O-与网络模型"><a href="#I-O-与网络模型" class="headerlink" title="I&#x2F;O 与网络模型"></a>I&#x2F;O 与网络模型</h2><p>介绍各种各样的I&#x2F;O模型，包括以下场景：</p>
<ul>
<li>阻塞 &amp; 非阻塞</li>
<li>多路复用</li>
<li>Signal IO</li>
<li>异步 IO</li>
<li>libevent</li>
</ul>
<p>现实生活中的场景复杂，Linux CPU和IO行为，他们之间互相等待。例如，阻塞的IO可能会让CPU暂停。</p>
<p>I&#x2F;O模型很难说好与坏，只能说在某些场景下，更适合某些IO模型。其中，1、4 更适合块设备，2、3 更适用于字符设备。</p>
<p>为什么硬盘没有所谓的 多路复用，libevent，signal IO？</p>
<blockquote>
<p>因为select(串口), epoll（socket） 这些都是在监听事件，所以各种各样的IO模型，更多是描述字符设备和网络socket的问题。但硬盘的文件，只有读写，没有 epoll这些。<br>这些IO模型更多是在字符设备，网络socket的场景。</p>
</blockquote>
<h3 id="为什么程序要选择正确的IO模型？"><a href="#为什么程序要选择正确的IO模型？" class="headerlink" title="为什么程序要选择正确的IO模型？"></a>为什么程序要选择正确的IO模型？</h3><p>蓝色代表：cpu，红色代表：io</p>
<p><img src="https://user-images.githubusercontent.com/87457873/127649947-6c89dd89-5076-4aca-af0a-69f154cf26b4.png" alt="image"></p>
<p>如上图，某个应用打开一个图片文件，先需要100ms初始化，接下来100ms读这个图片。那打开这个图片就需要200ms。</p>
<p>但是 是否可以开两个线程，同时做这两件事？</p>
<p><img src="https://user-images.githubusercontent.com/87457873/127649983-79730c12-91e9-462f-8abf-5fbf9634bd08.png" alt="image"></p>
<p>如上图，网络收发程序，如果串行执行，CPU和IO会需要互相等待。<br><br>为什么CPU和IO可以并行？因为一般硬件，IO通过DMA，cpu消耗比较小，在硬件上操作的时间更长。CPU和硬盘是两个不同的硬件。</p>
<p>再比如开机加速中systemd使用的readahead功能:<br><br>第一次启动过程，读的文件，会通过Linux inotify监控linux内核文件被操作的情况，记录下来。第二次启动，后台有进程直接读这些文件，而不是等到需要的时候再读。</p>
<p><img src="https://user-images.githubusercontent.com/87457873/127650021-0bed9b00-4448-4c7a-b9a4-ccff573a50ea.png" alt="image"></p>
<p>I&#x2F;O模型会深刻影响应用的最终性能，阻塞 &amp; 非阻塞 、异步 IO 是针对硬盘， 多路复用、signal io、libevent 是针对字符设备和 socket。</p>
<h3 id="简单的IO模型"><a href="#简单的IO模型" class="headerlink" title="简单的IO模型"></a>简单的IO模型</h3><p><img src="https://user-images.githubusercontent.com/87457873/127650047-8bb138e2-f652-4115-8ea6-0498b3e1be1a.png" alt="image"></p>
<p>当一个进程需要读 键盘、触屏、鼠标时，进程会阻塞。但对于大量并发的场景，阻塞IO无法搞定，也可能会被信号打断。</p>
<p>内核程序等待IO，gobal fifo read不到</p>
<p>一般情况select返回，会调用 if signal_pending，进程会返回 ERESTARTSYS；此时，进程的read 返回由singal决定。有可能返回（EINTR），也有可能不返回。</p>
<h4 id="demo"><a href="#demo" class="headerlink" title="demo:"></a>demo:</h4><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;signal.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/types.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;errno.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">static</span> <span class="type">void</span> <span class="title function_">sig_handler</span><span class="params">(<span class="type">int</span> signum)</span></span><br><span class="line">&#123;</span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">&quot;int handler %d\n&quot;</span>, signum);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">(<span class="type">int</span> argc, <span class="type">char</span> **argv)</span></span><br><span class="line">&#123;</span><br><span class="line">	<span class="type">char</span> buf[<span class="number">100</span>];</span><br><span class="line">	<span class="type">ssize_t</span> ret;</span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">sigaction</span> <span class="title">oldact</span>;</span></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">sigaction</span> <span class="title">act</span>;</span></span><br><span class="line"></span><br><span class="line">	act.sa_handler = sig_handler;</span><br><span class="line">	act.sa_flags = <span class="number">0</span>;</span><br><span class="line">	<span class="comment">//  act.sa_flags |= SA_RESTART;</span></span><br><span class="line">	sigemptyset(&amp;act.sa_mask);</span><br><span class="line">	<span class="keyword">if</span> (<span class="number">-1</span> == sigaction(SIGUSR1, &amp;act, &amp;oldact)) &#123;</span><br><span class="line">		<span class="built_in">printf</span>(<span class="string">&quot;sigaction failed!/n&quot;</span>);</span><br><span class="line">		<span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	bzero(buf, <span class="number">100</span>);</span><br><span class="line">	<span class="keyword">do</span> &#123;</span><br><span class="line">		ret = read(STDIN_FILENO, buf, <span class="number">10</span>);</span><br><span class="line">		<span class="keyword">if</span> ((ret == <span class="number">-1</span>) &amp;&amp; (errno == EINTR))</span><br><span class="line">			<span class="built_in">printf</span>(<span class="string">&quot;retry after eintr\n&quot;</span>);</span><br><span class="line">	&#125; <span class="keyword">while</span>((ret == <span class="number">-1</span>) &amp;&amp; (errno == EINTR));</span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span> (ret &gt; <span class="number">0</span>)</span><br><span class="line">		<span class="built_in">printf</span>(<span class="string">&quot;read %d bytes, content is %s\n&quot;</span>, ret, buf);</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><img src="https://user-images.githubusercontent.com/87457873/127650094-8544cd30-d8de-4773-8a5c-b5d865115dce.png" alt="image"></p>
<p>一个阻塞的IO，在睡眠等IO时Ready，但中途被信号打断，linux响应信号，read&#x2F;write请求阻塞。<br><br>配置信号时，在SA_FLAG是不是加“自动”，SA_RESTART指定 被阻塞的IO请求是否重发，并且应用中可以捕捉。加了SA_RESTART重发，就不会返回出错码EINTR。<br><br>没有加SA_RESTART重发，就会返回出错码（EINTR），这样可以检测read被信号打断时的返回。<br></p>
<p>但Linux中有一些系统调用，即便你加了自动重发，也不能自动重发。man signal.</p>
<p><img src="https://user-images.githubusercontent.com/87457873/127650145-bcad6c25-0a99-4158-af47-7ead22941fb2.png" alt="image"></p>
<p>当使用阻塞IO时，要小心这部分。</p>
<p><img src="https://user-images.githubusercontent.com/87457873/127650167-86e622e8-4e04-437d-9e29-aa3cacc78968.png" alt="image"></p>
<h3 id="多进程、多线程模型"><a href="#多进程、多线程模型" class="headerlink" title="多进程、多线程模型"></a>多进程、多线程模型</h3><p>当有多个socket消息需要处理，阻塞IO搞不定，有一种可能是多个进程&#x2F;线程，每当有一个连接建立（accept socket)，都会启动一个线程去处理新建立的连接。但是，这种模型性能不太好，创建多进程、多线程时会有开销。</p>
<p>经典的C10K问题，意思是 在一台服务器上维护1w个连接，需要建立1w个进程或者线程。那么如果维护1亿用户在线，则需要1w台服务器。</p>
<p>IO多路复用，则是解决以上问题的场景。</p>
<p>总结：多进程、多线程模型企图把每一个fd放到不同的线程&#x2F;进程处理，避免阻塞的问题，从而引入了进程创建\撤销，调度的开销。能否在一个线程内搞定所有IO? – 这就是多路复用的作用。</p>
<h3 id="多路复用"><a href="#多路复用" class="headerlink" title="多路复用"></a>多路复用</h3><p><img src="https://user-images.githubusercontent.com/87457873/127650193-d91a7751-d9be-43e4-ace1-d153f18d82e7.png" alt="image"></p>
<h4 id="select"><a href="#select" class="headerlink" title="select"></a>select</h4><p>select：效率低，性能不太好。不能解决大量并发请求的问题。</p>
<p>它把1000个fd加入到fd_set（文件描述符集合），通过select监控fd_set里的fd是否有变化。如果有一个fd满足读写事件，就会依次查看每个文件描述符，那些发生变化的描述符在fd_set对应位设为1，表示socket可读或者可写。</p>
<p>Select通过轮询的方式监听，对监听的FD数量 t通过FD_SETSIZE限制。</p>
<p>两个问题：</p>
<p>1、select初始化时，要告诉内核，关注1000个fd， 每次初始化都需要重新关注1000个fd。前期准备阶段长。<br><br>2、select返回之后，要扫描1000个fd。 后期扫描维护成本大，CPU开销大。</p>
<h4 id="epoll"><a href="#epoll" class="headerlink" title="epoll"></a>epoll</h4><p>epoll ：在内核中的实现不是通过轮询的方式，而是通过注册callback函数的方式。当某个文件描述符发现变化，就主动通知。成功解决了select的两个问题，“epoll 被称为解决 C10K 问题的利器。”</p>
<p>1、select的“健忘症”，一返回就不记得关注了多少fd。api 把告诉内核等哪些文件，和最终监听哪些文件，都是同一个api。而epoll，告诉内核等哪些文件 和具体等哪些文件分开成两个api，epoll的“等”返回后，还是知道关注了哪些fd。<br><br>2、select在返回后的维护开销很大，而epoll就可以直接知道需要等fd。</p>
<p><img src="https://user-images.githubusercontent.com/87457873/127650306-b4419ff5-164e-4678-80f4-6f839ad44245.png" alt="image"></p>
<p><img src="https://user-images.githubusercontent.com/87457873/127650321-094aa0ad-c49b-46d9-8100-4b7c3cc60f53.png" alt="image"></p>
<p>epoll获取事件的时候，无须遍历整个被侦听的描述符集，只要遍历那些被内核I&#x2F;O事件异步唤醒而加入就绪队列的描述符集合。</p>
<p>epoll_create: 创建epoll池子。<br><br>epoll_ctl：向epoll注册事件。告诉内核epoll关心哪些文件，让内核没有健忘症。<br><br>epoll_wait：等待就绪事件的到来。专门等哪些文件，第2个参数 是输出参数，包含满足的fd，不需要再遍历所有的fd文件。<br></p>
<p><img src="https://user-images.githubusercontent.com/87457873/127650368-39c111d9-a074-4f0b-befd-3c0e9a29867b.png" alt="image"></p>
<p>如上图，epoll在CPU的消耗上，远低于select，这样就可以在一个线程内监控更多的IO。</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;fcntl.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/types.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/epoll.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/stat.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">static</span> <span class="type">void</span> <span class="title function_">call_epoll</span><span class="params">(<span class="type">void</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">   <span class="type">int</span> epfd, fifofd, pipefd;</span><br><span class="line">   <span class="class"><span class="keyword">struct</span> <span class="title">epoll_event</span> <span class="title">ev</span>, <span class="title">events</span>[2];</span></span><br><span class="line">   <span class="type">int</span> ret;</span><br><span class="line"></span><br><span class="line">   epfd = epoll_create(<span class="number">2</span>);</span><br><span class="line">   <span class="keyword">if</span> (epfd &lt; <span class="number">0</span>) &#123;</span><br><span class="line">   	perror(<span class="string">&quot;epoll_create()&quot;</span>);</span><br><span class="line">   	<span class="keyword">return</span>;</span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line">   ev.events = EPOLLIN|EPOLLET;</span><br><span class="line"></span><br><span class="line">   fifofd = open(<span class="string">&quot;/dev/globalfifo&quot;</span>, O_RDONLY, S_IRUSR);</span><br><span class="line">   <span class="built_in">printf</span>(<span class="string">&quot;fifo fd:%d\n&quot;</span>, fifofd);</span><br><span class="line">   ev.data.fd = fifofd;</span><br><span class="line">   ret = epoll_ctl(epfd, EPOLL_CTL_ADD, fifofd, &amp;ev);</span><br><span class="line"></span><br><span class="line">   pipefd = open(<span class="string">&quot;pipe&quot;</span>, O_RDONLY|O_NONBLOCK, S_IRUSR);</span><br><span class="line">   <span class="built_in">printf</span>(<span class="string">&quot;pipe fd:%d\n&quot;</span>, pipefd);</span><br><span class="line">   ev.data.fd = pipefd;</span><br><span class="line">   ret = epoll_ctl(epfd, EPOLL_CTL_ADD, pipefd, &amp;ev);</span><br><span class="line"></span><br><span class="line">   <span class="keyword">while</span>(<span class="number">1</span>) &#123;</span><br><span class="line">   	ret = epoll_wait(epfd, events, <span class="number">2</span>, <span class="number">50000</span>);</span><br><span class="line">   	<span class="keyword">if</span> (ret &lt; <span class="number">0</span>) &#123;</span><br><span class="line">   		perror(<span class="string">&quot;epoll_wait()&quot;</span>);</span><br><span class="line">   	&#125; <span class="keyword">else</span> <span class="keyword">if</span> (ret == <span class="number">0</span>) &#123;</span><br><span class="line">   		<span class="built_in">printf</span>(<span class="string">&quot;No data within 50 seconds.\n&quot;</span>);</span><br><span class="line">   	&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">   		<span class="type">int</span> i;</span><br><span class="line">   		<span class="keyword">for</span>(i=<span class="number">0</span>;i&lt;ret;i++) &#123;</span><br><span class="line">   			<span class="type">char</span> buf[<span class="number">100</span>];</span><br><span class="line">   			read(events[i].data.fd, buf, <span class="number">100</span>);</span><br><span class="line">   			<span class="built_in">printf</span>(<span class="string">&quot;%s is available now:, %s\n&quot;</span>,</span><br><span class="line">   					events[i].data.fd==fifofd? <span class="string">&quot;fifo&quot;</span>:<span class="string">&quot;pipe&quot;</span>, buf);</span><br><span class="line">   		&#125;</span><br><span class="line">   	&#125;</span><br><span class="line">   &#125;</span><br><span class="line">_out:</span><br><span class="line">   close(epfd);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">   call_epoll();</span><br><span class="line">   <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>总结：epoll是几乎是大规模并行网络程序设计的代名词，一个线程里可以处理大量的tcp连接，cpu消耗也比较低。很多框架模型，nginx, nodejs, 底层均使用epoll实现。</p>
<h4 id="signal-IO"><a href="#signal-IO" class="headerlink" title="signal IO"></a>signal IO</h4><p>目前在linux中很少被用到，Linux内核某个IO事件ready，通过kill出一个signal，应用程序在signal IO上绑定处理函数。</p>
<p><img src="https://user-images.githubusercontent.com/87457873/127650438-dafaa967-0eb9-4886-9a90-4200fd3d2708.png" alt="image"></p>
<p>kernel发现设备读写事件变化，调用一个 kill fa_sync ，应用程序绑定signal_io上的事件。</p>
<p><img src="https://user-images.githubusercontent.com/87457873/127650461-1e5fc79c-496e-4c7e-a1d4-dfa0c922644e.png" alt="image"></p>
<h4 id="异步IO"><a href="#异步IO" class="headerlink" title="异步IO"></a>异步IO</h4><p><img src="https://user-images.githubusercontent.com/87457873/127650494-6b63c04c-7b7e-4afa-9f8e-d37f36046651.png" alt="image"></p>
<p>Linux中</p>
<p>不要把aio串起来，</p>
<p>基于epoll等api进行上层的封装，再基于事件编程。某个事件成立了，就开始去做某件事。</p>
<h4 id="libevent"><a href="#libevent" class="headerlink" title="libevent"></a>libevent</h4><p><img src="https://user-images.githubusercontent.com/87457873/127650540-a0005da6-290f-464a-a14b-f05088b9c9d8.png" alt="image"></p>
<p>就像MFC一样，界面上的按钮，VC会产生一个on_button，调对应的函数。是一种典型的事件循环。</p>
<p>本质上还是用了epoll，只是基于事件编程。</p>
<p><img src="https://user-images.githubusercontent.com/87457873/127650560-697e2b4e-61ab-4e43-960f-67d6f2aa2b1a.png" alt="image"></p>
]]></content>
      <categories>
        <category>linux-doc</category>
      </categories>
      <tags>
        <tag>Linux</tag>
      </tags>
  </entry>
  <entry>
    <title>Linux Kernel内核整体架构(图文详解)</title>
    <url>/2023/01/15/linux-docs/Linux%20Kernel%E5%86%85%E6%A0%B8%E6%95%B4%E4%BD%93%E6%9E%B6%E6%9E%84(%E5%9B%BE%E6%96%87%E8%AF%A6%E8%A7%A3)/</url>
    <content><![CDATA[<h2 id="1，前言"><a href="#1，前言" class="headerlink" title="1，前言"></a>1，前言</h2><p>本文是“Linux内核分析”系列文章的第一篇，会以内核的核心功能为出发点，描述Linux内核的整体架构，以及架构之下主要的软件子系统。之后，会介绍Linux内核源文件的目录结构，并和各个软件子系统对应。</p>
<p><strong>注：本文和其它的“Linux内核分析”文章都基于如下约定：</strong></p>
<ul>
<li>a) 内核版本为Linux 3.10.29（该版本是一个long term的版本，会被Linux社区持续维护至少2年)。</li>
<li>b) 鉴于嵌入式系统大多使用ARM处理器，因此涉及到体系结构部分的内容，都以ARM为分析对象</li>
</ul>
<h2 id="2，Linux内核的核心功能"><a href="#2，Linux内核的核心功能" class="headerlink" title="2，Linux内核的核心功能"></a>2，Linux内核的核心功能</h2><p>如下图所示，Linux内核只是Linux操作系统一部分。对下，它管理系统的所有硬件设备；对上，它通过系统调用，向Library Routine（例如C库）或者其它应用程序提供接口。</p>
<p><img src="https://pic2.zhimg.com/80/v2-93cd0f1a4abbdfeb4af71202535fe4f9_720w.webp" alt="img"></p>
<p>因此，其核心功能就是：<strong>管理硬件设备，供应用程序使用</strong>。而现代计算机（无论是PC还是嵌入式系统）的标准组成，就是CPU、Memory（内存和外存）、输入输出设备、网络设备和其它的外围设备。所以为了管理这些设备，Linux内核提出了如下的架构。</p>
<h2 id="3，Linux内核的整体架构"><a href="#3，Linux内核的整体架构" class="headerlink" title="3，Linux内核的整体架构"></a>3，Linux内核的整体架构</h2><h3 id="3-1-整体架构和子系统划分"><a href="#3-1-整体架构和子系统划分" class="headerlink" title="3.1 整体架构和子系统划分"></a>3.1 整体架构和子系统划分</h3><p><img src="https://pic4.zhimg.com/80/v2-52cdc054e6571065367b8af733bccbff_720w.webp" alt="img"></p>
<p>上图说明了Linux内核的整体架构。根据内核的核心功能，Linux内核提出了5个子系统，分别负责如下的功能：<br>\1. Process Scheduler，也称作进程管理、进程调度。负责管理CPU资源，以便让各个进程可以以尽量公平的方式访问CPU。<br>\2. Memory Manager，内存管理。负责管理Memory（内存）资源，以便让各个进程可以安全地共享机器的内存资源。另外，内存管理会提供虚拟内存的机制，该机制可以让进程使用多于系统可用Memory的内存，不用的内存会通过文件系统保存在外部非易失存储器中，需要使用的时候，再取回到内存中。<br>\3. VFS（Virtual File System），虚拟文件系统。Linux内核将不同功能的外部设备，例如Disk设备（硬盘、磁盘、NAND Flash、Nor Flash等）、输入输出设备、显示设备等等，抽象为可以通过统一的文件操作接口（open、close、read、write等）来访问。这就是Linux系统“一切皆是文件”的体现（其实Linux做的并不彻底，因为CPU、内存、网络等还不是文件，如果真的需要一切皆是文件，还得看贝尔实验室正在开发的”Plan 9”的）。<br>\4. Network，网络子系统。负责管理系统的网络设备，并实现多种多样的网络标准。<br>\5. IPC（Inter-Process Communication），进程间通信。IPC不管理任何的硬件，它主要负责Linux系统中进程之间的通信。</p>
<h3 id="3-2-进程调度（Process-Scheduler"><a href="#3-2-进程调度（Process-Scheduler" class="headerlink" title="3.2 进程调度（Process Scheduler)"></a>3.2 进程调度（Process Scheduler)</h3><p>进程调度是Linux内核中最重要的子系统，它主要提供对CPU的访问控制。因为在计算机中，CPU资源是有限的，而众多的应用程序都要使用CPU资源，所以需要“进程调度子系统”对CPU进行调度管理。<br><strong>进程调度子系统包括4个子模块（见下图），它们的功能如下：</strong></p>
<p><img src="https://pic1.zhimg.com/80/v2-e91ce13f5a171b3af45cd74043c8e64c_720w.webp" alt="img"></p>
<p>\1. Scheduling Policy，实现进程调度的策略，它决定哪个（或哪几个）进程将拥有CPU。<br>\2. Architecture-specific Schedulers，体系结构相关的部分，用于将对不同CPU的控制，抽象为统一的接口。这些控制主要在suspend和resume进程时使用，牵涉到CPU的寄存器访问、汇编指令操作等。<br>\3. Architecture-independent Scheduler，体系结构无关的部分。它会和“Scheduling Policy模块”沟通，决定接下来要执行哪个进程，然后通过“Architecture-specific Schedulers模块”resume指定的进程。<br>\4. System Call Interface，系统调用接口。进程调度子系统通过系统调用接口，将需要提供给用户空间的接口开放出去，同时屏蔽掉不需要用户空间程序关心的细节。<br>3.3 内存管理（Memory Manager, MM)<br>内存管理同样是Linux内核中最重要的子系统，它主要提供对内存资源的访问控制。Linux系统会在硬件物理内存和进程所使用的内存（称作虚拟内存）之间建立一种映射关系，这种映射是以进程为单位，因而不同的进程可以使用相同的虚拟内存，而这些相同的虚拟内存，可以映射到不同的物理内存上。</p>
<p><strong>内存管理子系统包括3个子模块（见下图），它们的功能如下：</strong></p>
<p><img src="https://pic1.zhimg.com/80/v2-367c1e3b65e2c49b2989faad4a50c360_720w.webp" alt="img"></p>
<p>\1. Architecture Specific Managers，体系结构相关部分。提供用于访问硬件Memory的虚拟接口。<br>\2. Architecture Independent Manager，体系结构无关部分。提供所有的内存管理机制，包括：以进程为单位的memory mapping；虚拟内存的Swapping。<br>\3. System Call Interface，系统调用接口。通过该接口，向用户空间程序应用程序提供内存的分配、释放，文件的map等功能。</p>
<h3 id="3-4-虚拟文件系统（Virtual-Filesystem-VFS）"><a href="#3-4-虚拟文件系统（Virtual-Filesystem-VFS）" class="headerlink" title="3.4 虚拟文件系统（Virtual Filesystem, VFS）"></a>3.4 虚拟文件系统（Virtual Filesystem, VFS）</h3><p>传统意义上的文件系统，是一种存储和组织计算机数据的方法。它用易懂、人性化的方法（文件和目录结构），抽象计算机磁盘、硬盘等设备上冰冷的数据块，从而使对它们的查找和访问变得容易。因而文件系统的实质，就是“存储和组织数据的方法”，文件系统的表现形式，就是“从某个设备中读取数据和向某个设备写入数据”。<br>随着计算机技术的进步，存储和组织数据的方法也是在不断进步的，从而导致有多种类型的文件系统，例如FAT、FAT32、NTFS、EXT2、EXT3等等。而为了兼容，操作系统或者内核，要以相同的表现形式，同时支持多种类型的文件系统，这就延伸出了虚拟文件系统（VFS）的概念。VFS的功能就是管理各种各样的文件系统，屏蔽它们的差异，以统一的方式，为用户程序提供访问文件的接口。<br>我们可以从磁盘、硬盘、NAND Flash等设备中读取或写入数据，因而最初的文件系统都是构建在这些设备之上的。这个概念也可以推广到其它的硬件设备，例如内存、显示器（LCD）、键盘、串口等等。我们对硬件设备的访问控制，也可以归纳为读取或者写入数据，因而可以用统一的文件操作接口访问。Linux内核就是这样做的，除了传统的磁盘文件系统之外，它还抽象出了设备文件系统、内存文件系统等等。这些逻辑，都是由VFS子系统实现。<br><strong>VFS子系统包括6个子模块（见下图），它们的功能如下：</strong></p>
<p><img src="https://pic1.zhimg.com/80/v2-609e277dbb82e1ea76edbb6219632540_720w.webp" alt="img"></p>
<p>\1. Device Drivers，设备驱动，用于控制所有的外部设备及控制器。由于存在大量不能相互兼容的硬件设备（特别是嵌入式产品），所以也有非常多的设备驱动。因此，Linux内核中将近一半的Source Code都是设备驱动，大多数的Linux底层工程师（特别是国内的企业）都是在编写或者维护设备驱动，而无暇估计其它内容（它们恰恰是Linux内核的精髓所在）。<br>\2. Device Independent Interface， 该模块定义了描述硬件设备的统一方式（统一设备模型），所有的设备驱动都遵守这个定义，可以降低开发的难度。同时可以用一致的形式向上提供接口。<br>\3. Logical Systems，每一种文件系统，都会对应一个Logical System（逻辑文件系统），它会实现具体的文件系统逻辑。<br>\4. System Independent Interface，该模块负责以统一的接口（快设备和字符设备）表示硬件设备和逻辑文件系统，这样上层软件就不再关心具体的硬件形态了。<br>\5. System Call Interface，系统调用接口，向用户空间提供访问文件系统和硬件设备的统一的接口。<br>3.5 网络子系统（Net）<br>网络子系统在Linux内核中主要负责管理各种网络设备，并实现各种网络协议栈，最终实现通过网络连接其它系统的功能。在Linux内核中，网络子系统几乎是自成体系，它包括5个子模块（见下图），它们的功能如下：</p>
<p><img src="https://pic3.zhimg.com/80/v2-784345aace76acd75f415b61635e2c46_720w.webp" alt="img"></p>
<p>\1. Network Device Drivers，网络设备的驱动，和VFS子系统中的设备驱动是一样的。<br>\2. Device Independent Interface，和VFS子系统中的是一样的。<br>\3. Network Protocols，实现各种网络传输协议，例如IP, TCP, UDP等等。<br>\4. Protocol Independent Interface，屏蔽不同的硬件设备和网络协议，以相同的格式提供接口（socket)。<br>\5. System Call interface，系统调用接口，向用户空间提供访问网络设备的统一的接口。<br>至于IPC子系统，由于功能比较单纯，这里就不再描述了。</p>
<h2 id="4，Linux内核源代码的目录结构"><a href="#4，Linux内核源代码的目录结构" class="headerlink" title="4，Linux内核源代码的目录结构"></a>4，Linux内核源代码的目录结构</h2><p>Linux内核源代码包括三个主要部分：<br>\1. 内核核心代码，包括第3章所描述的各个子系统和子模块，以及其它的支撑子系统，例如电源管理、Linux初始化等<br>\2. 其它非核心代码，例如库文件（因为Linux内核是一个自包含的内核，即内核不依赖其它的任何软件，自己就可以编译通过）、固件集合、KVM（虚拟机技术）等<br>\3. 编译脚本、配置文件、帮助文档、版权说明等辅助性文件<br><strong>下图是使用ls命令看到的内核源代码的顶层目录结构，具体描述如下：</strong></p>
<p><img src="https://pic4.zhimg.com/80/v2-bb926260267cf97371e235cbc7715ffb_720w.webp" alt="img"></p>
<ol>
<li>include&#x2F; —- 内核头文件，需要提供给外部模块（例如用户空间代码）使用。</li>
<li>kernel&#x2F; —- Linux内核的核心代码，包含了3.2小节所描述的进程调度子系统，以及和进程调度相关的模块。</li>
<li>mm&#x2F; —- 内存管理子系统（3.3小节）。</li>
<li>fs&#x2F; —- VFS子系统（3.4小节）。</li>
<li>net&#x2F; —- 不包括网络设备驱动的网络子系统（3.5小节）。</li>
<li>ipc&#x2F; —- IPC（进程间通信）子系统。</li>
<li>arch&#x2F;&#x2F; —- 体系结构相关的代码，例如arm, x86等等。</li>
<li>arch&#x2F;&#x2F;mach- —- 具体的machine&#x2F;board相关的代码。</li>
<li>arch&#x2F;&#x2F;include&#x2F;asm —- 体系结构相关的头文件。</li>
<li>arch&#x2F;&#x2F;boot&#x2F;dts —- 设备树（Device Tree）文件。</li>
<li>init&#x2F; —- Linux系统启动初始化相关的代码。</li>
<li>block&#x2F; —- 提供块设备的层次。</li>
<li>sound&#x2F; —- 音频相关的驱动及子系统，可以看作“音频子系统”。</li>
<li>drivers&#x2F; —- 设备驱动（在Linux kernel 3.10中，设备驱动占了49.4的代码量）。</li>
<li>lib&#x2F; —- 实现需要在内核中使用的库函数，例如CRC、FIFO、list、MD5等。</li>
<li>crypto&#x2F; —– 加密、解密相关的库函数。</li>
<li>security&#x2F; —- 提供安全特性（SELinux）。</li>
<li>virt&#x2F; —- 提供虚拟机技术（KVM等）的支持。</li>
<li>usr&#x2F; —- 用于生成initramfs的代码。</li>
<li>firmware&#x2F; —- 保存用于驱动第三方设备的固件。</li>
<li>samples&#x2F; —- 一些示例代码。</li>
<li>tools&#x2F; —- 一些常用工具，如性能剖析、自测试等。</li>
<li>Kconfig, Kbuild, Makefile, scripts&#x2F; —- 用于内核编译的配置文件、脚本等。</li>
<li>COPYING —- 版权声明。</li>
<li>MAINTAINERS —-维护者名单。</li>
<li>CREDITS —- Linux主要的贡献者名单。</li>
<li>REPORTING-BUGS —- Bug上报的指南。</li>
<li>Documentation, README —- 帮助、说明文档。</li>
</ol>
<hr>
<p>版权声明：本文为知乎博主「玩转Linux内核」的原创文章，遵循CC 4.0 BY-SA版权协议，转载请附上原文出处链接及本声明。<br>原文链接：<a href="https://zhuanlan.zhihu.com/p/438248184">https://zhuanlan.zhihu.com/p/438248184</a></p>
]]></content>
      <categories>
        <category>linux-doc</category>
      </categories>
      <tags>
        <tag>Linux</tag>
      </tags>
  </entry>
  <entry>
    <title>Linux内核Coding Style整理</title>
    <url>/2023/01/15/linux-docs/Linux%E5%86%85%E6%A0%B8Coding%20Style%E6%95%B4%E7%90%86/</url>
    <content><![CDATA[<h2 id="1、缩进了"><a href="#1、缩进了" class="headerlink" title="1、缩进了"></a><strong>1、缩进了</strong></h2><p>缩进用 Tab, 并且Tab的宽度为8个字符</p>
<p>swich 和 case对齐, 不用缩进</p>
<figure class="highlight text"><table><tr><td class="code"><pre><span class="line">switch (suffix) &#123;</span><br><span class="line">case &#x27;G&#x27;:</span><br><span class="line">case &#x27;g&#x27;:</span><br><span class="line">        mem &lt;&lt;= 30;</span><br><span class="line">        break;</span><br><span class="line">case &#x27;M&#x27;:</span><br><span class="line">case &#x27;m&#x27;:</span><br><span class="line">        mem &lt;&lt;= 20;</span><br><span class="line">        break;</span><br><span class="line">case &#x27;K&#x27;:</span><br><span class="line">case &#x27;k&#x27;:</span><br><span class="line">        mem &lt;&lt;= 10;</span><br><span class="line">        /* fall through */</span><br><span class="line">default:</span><br><span class="line">        break;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>一行只有一个表达式</p>
<figure class="highlight text"><table><tr><td class="code"><pre><span class="line">if (condition) do_this;  /* bad example */</span><br></pre></td></tr></table></figure>

<p>不要用空格来缩进 (除了注释或文档)</p>
<h2 id="2、代码行长度控制在80个字符以内"><a href="#2、代码行长度控制在80个字符以内" class="headerlink" title="2、代码行长度控制在80个字符以内"></a><strong>2、代码行长度控制在80个字符以内</strong></h2><p>长度过长的行截断时, 注意保持易读性</p>
<figure class="highlight text"><table><tr><td class="code"><pre><span class="line">void fun(int a, int b, int c)</span><br><span class="line">&#123;</span><br><span class="line">        if (condition)</span><br><span class="line">                printk(KERN_WARNING &quot;Warning this is a long printk with &quot;</span><br><span class="line">                       &quot;3 parameters a: %u b: %u &quot;</span><br><span class="line">                       &quot;c: %u \n&quot;, a, b, c);</span><br><span class="line">        else</span><br><span class="line">                next_statement;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="3、括号和空格的位置"><a href="#3、括号和空格的位置" class="headerlink" title="3、括号和空格的位置"></a><strong>3、括号和空格的位置</strong></h2><p>函数的大括号另起一行</p>
<figure class="highlight text"><table><tr><td class="code"><pre><span class="line">int function(int x)</span><br><span class="line">&#123;   /* 这个大括号 &#123; 另起了一行 */</span><br><span class="line">        body of function</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>非函数的语句块(if, switch, for, while, do)不用另起一行</p>
<figure class="highlight text"><table><tr><td class="code"><pre><span class="line">if (x is true) &#123;  /* 这个大括号 &#123; 不用另起一行 */</span><br><span class="line">        we do y</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>只有一行的语句块不用大括号</p>
<figure class="highlight text"><table><tr><td class="code"><pre><span class="line">if (condition)</span><br><span class="line">        action();</span><br></pre></td></tr></table></figure>

<p>如果if用了大括号, 那么else即使只有一行也要用大括号</p>
<figure class="highlight text"><table><tr><td class="code"><pre><span class="line">if (condition) &#123;</span><br><span class="line">        do_this();</span><br><span class="line">        do_that();</span><br><span class="line">&#125; else &#123;</span><br><span class="line">        otherwise();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>下列 keywords 后面追加一个空格</p>
<p>if, switch, case, for, do, while</p>
<p>下列 keywords 后面 <em>不要</em> 追加一个空格</p>
<p>sizeof, typeof, alignof, __attribute</p>
<figure class="highlight text"><table><tr><td class="code"><pre><span class="line">if (condition) &#123;</span><br><span class="line">        do_this();</span><br><span class="line">        do_that();</span><br><span class="line">&#125; else &#123;</span><br><span class="line">        otherwise();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>定义指针时, * 紧靠函数名或者变量名</p>
<figure class="highlight text"><table><tr><td class="code"><pre><span class="line">if (condition) &#123;</span><br><span class="line">        do_this();</span><br><span class="line">        do_that();</span><br><span class="line">&#125; else &#123;</span><br><span class="line">        otherwise();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>下面的二元和三元操作符左右要留一个空格</p>
<p>&#x3D; + - &lt; &gt; * &#x2F; % | &amp; ^ &lt;&#x3D; &gt;&#x3D; &#x3D;&#x3D; !&#x3D; ? :</p>
<p>下面的一元操作符后面 <em>不要</em> 留空格</p>
<p>&amp; * + - ~ ! sizeof typeof alignof <strong>attribute</strong> defined</p>
<p>后缀操作符(++ –)前面不要留空格</p>
<p>前缀操作符(++ –)后面不要留空格</p>
<p>结构体成员操作符(. -&gt;)前后都不要留空格</p>
<p>每行代码之后不要有多余的空格</p>
<h2 id="4、命名"><a href="#4、命名" class="headerlink" title="4、命名"></a><strong>4、命名</strong></h2><p>全局变量或函数(在确实需要时才使用)要有个描述性的名称</p>
<figure class="highlight text"><table><tr><td class="code"><pre><span class="line">count_active_users()  /* good */</span><br><span class="line">cntusr()              /* cnt  */</span><br></pre></td></tr></table></figure>

<p>局部变量名称要简洁(这个规则比较抽象, 只能多看看内核代码中其他人的命名方式)</p>
<h2 id="5、Typedefs"><a href="#5、Typedefs" class="headerlink" title="5、Typedefs"></a><strong>5、Typedefs</strong></h2><p>尽量不要使用 typedef, 使用typedef主要为了下面的用途:</p>
<ol>
<li>完全不透明的类型(访问这些类型也需要对应的访问函数)</li>
</ol>
<p>ex. pid_t, uid_t, pte_t … 等等</p>
<ol start="2">
<li>避免整型数据的困扰</li>
</ol>
<p>比如int, long类型的长度在不同体系结构中不一致等等, 使用 u8&#x2F;u16&#x2F;u32 来代替整型定义</p>
<ol start="3">
<li><p>当使用kernel的sparse工具做变量类型检查时, 可以typedef一个类型.</p>
</li>
<li><p>定义C99标准中的新类型</p>
</li>
<li><p>为了用户空间的类型安全</p>
</li>
</ol>
<p>内核空间的结构体映射到用户空间时使用typedef, 这样即使内核空间的数据结构有变化, 用户空间也能正常运行</p>
<h2 id="6、函数"><a href="#6、函数" class="headerlink" title="6、函数"></a><strong>6、函数</strong></h2><p>函数要简短,一个函数只做一件事情</p>
<p>函数长度一般不超过2屏(1屏的大小是 80x24), 也就是48行</p>
<p>如果函数中的 switch 有很多简单的 case语句, 那么超出2屏也可以</p>
<p>函数中局部变量不能超过 5~10 个</p>
<p>函数与函数之间空一行, 但是和EXPORT* 之间不用空</p>
<figure class="highlight text"><table><tr><td class="code"><pre><span class="line">int one_func(void)</span><br><span class="line">&#123;</span><br><span class="line">        return 0;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">int system_is_up(void)</span><br><span class="line">&#123;</span><br><span class="line">        return system_state == SYSTEM_RUNNING;</span><br><span class="line">&#125;</span><br><span class="line">EXPORT_SYMBOL(system_is_up);</span><br></pre></td></tr></table></figure>

<h2 id="7、函数退出"><a href="#7、函数退出" class="headerlink" title="7、函数退出"></a><strong>7、函数退出</strong></h2><p>将函数的退出集中在一起, 特别有需要清理内存的时候.(goto 并不是洪水猛兽, 有时也很有用)</p>
<figure class="highlight text"><table><tr><td class="code"><pre><span class="line">int fun(int a)</span><br><span class="line">&#123;</span><br><span class="line">        int result = 0;</span><br><span class="line">        char *buffer = kmalloc(SIZE);</span><br><span class="line"></span><br><span class="line">        if (buffer == NULL)</span><br><span class="line">                return -ENOMEM;</span><br><span class="line"></span><br><span class="line">        if (condition1) &#123;</span><br><span class="line">                while (loop1) &#123;</span><br><span class="line">                        ...</span><br><span class="line">                &#125;</span><br><span class="line">                result = 1;</span><br><span class="line">                goto out;</span><br><span class="line">        &#125;</span><br><span class="line">        ...</span><br><span class="line">        out:</span><br><span class="line">                kfree(buffer);</span><br><span class="line">                return result;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="8、注释"><a href="#8、注释" class="headerlink" title="8、注释"></a><strong>8、注释</strong></h2><p>注释code做了什么, 而不是如何做的</p>
<p>使用C89的注释风格(&#x2F;* … *&#x2F;), 不要用C99的注释风格(&#x2F;&#x2F; …)</p>
<p>注释定义的数据, 不管是基本类型还是衍生的类型</p>
<h2 id="9、控制缩进的方法"><a href="#9、控制缩进的方法" class="headerlink" title="9、控制缩进的方法"></a><strong>9、控制缩进的方法</strong></h2><p>用emacs来保证缩进, .emacs中的配置如下:</p>
<figure class="highlight text"><table><tr><td class="code"><pre><span class="line">(defun c-lineup-arglist-tabs-only (ignored)</span><br><span class="line">  &quot;Line up argument lists by tabs, not spaces&quot;</span><br><span class="line">  (let* ((anchor (c-langelem-pos c-syntactic-element))</span><br><span class="line">     (column (c-langelem-2nd-pos c-syntactic-element))</span><br><span class="line">     (offset (- (1+ column) anchor))</span><br><span class="line">     (steps (floor offset c-basic-offset)))</span><br><span class="line">    (* (max steps 1)</span><br><span class="line">       c-basic-offset)))</span><br><span class="line"></span><br><span class="line">(add-hook &#x27;c-mode-common-hook</span><br><span class="line">          (lambda ()</span><br><span class="line">            ;; Add kernel style</span><br><span class="line">            (c-add-style</span><br><span class="line">             &quot;linux-tabs-only&quot;</span><br><span class="line">             &#x27;(&quot;linux&quot; (c-offsets-alist</span><br><span class="line">                        (arglist-cont-nonempty</span><br><span class="line">                         c-lineup-gcc-asm-reg</span><br><span class="line">                         c-lineup-arglist-tabs-only))))))</span><br><span class="line"></span><br><span class="line">(add-hook &#x27;c-mode-hook</span><br><span class="line">          (lambda ()</span><br><span class="line">            (let ((filename (buffer-file-name)))</span><br><span class="line">              ;; Enable kernel mode for the appropriate files</span><br><span class="line">              (when (and filename</span><br><span class="line">                         (string-match (expand-file-name &quot;~/src/linux-trees&quot;)</span><br><span class="line">                                       filename))</span><br><span class="line">                (setq indent-tabs-mode t)</span><br><span class="line">                (c-set-style &quot;linux-tabs-only&quot;)))))</span><br></pre></td></tr></table></figure>

<p>使用 indent 脚本来保证缩进. (脚本位置: scripts&#x2F;Lindent)</p>
<h2 id="10、Kconfig配置文件"><a href="#10、Kconfig配置文件" class="headerlink" title="10、Kconfig配置文件"></a><strong>10、Kconfig配置文件</strong></h2><p>“config” 下一行要缩进一个Tab, “help” 下则缩进2个空格</p>
<figure class="highlight text"><table><tr><td class="code"><pre><span class="line">config AUDIT</span><br><span class="line">        bool &quot;Auditing support&quot;</span><br><span class="line">        depends on NET</span><br><span class="line">        help</span><br><span class="line">          Enable auditing infrastructure that can be used with another</span><br><span class="line">          kernel subsystem, such as SELinux (which requires this for</span><br><span class="line">          logging of avc messages output).  Does not do system-call</span><br><span class="line">          auditing without CONFIG_AUDITSYSCALL.</span><br></pre></td></tr></table></figure>

<p>不稳定的特性要加上 <em>EXPERIMENTAL</em></p>
<figure class="highlight text"><table><tr><td class="code"><pre><span class="line">config SLUB</span><br><span class="line">        depends on EXPERIMENTAL &amp;&amp; !ARCH_USES_SLAB_PAGE_STRUCT</span><br><span class="line">        bool &quot;SLUB (Unqueued Allocator)&quot;</span><br><span class="line">        ...</span><br></pre></td></tr></table></figure>

<p>危险的特性要加上 <em>DANGEROUS</em></p>
<figure class="highlight text"><table><tr><td class="code"><pre><span class="line">config ADFS_FS_RW</span><br><span class="line">        bool &quot;ADFS write support (DANGEROUS)&quot;</span><br><span class="line">        depends on ADFS_FS</span><br><span class="line">        ...    </span><br></pre></td></tr></table></figure>

<h2 id="11、数据结构"><a href="#11、数据结构" class="headerlink" title="11、数据结构"></a><strong>11、数据结构</strong></h2><p>结构体要包含一个引用计数字段 (内核中没有自动垃圾收集, 需要手动释放内存)</p>
<p>需要保证结构体数据一致性时要加锁</p>
<p>结构体中有时甚至会需要多层的引用计数</p>
<p>ex. struc mm_struct, struct super_block</p>
<h2 id="12、宏-枚举类型和RTL"><a href="#12、宏-枚举类型和RTL" class="headerlink" title="12、宏, 枚举类型和RTL"></a><strong>12、宏, 枚举类型和RTL</strong></h2><p>宏定义常量后者标签时使用大写字母</p>
<figure class="highlight text"><table><tr><td class="code"><pre><span class="line">#define CONSTANT 0x12345</span><br></pre></td></tr></table></figure>

<p>宏定义多行语句时要放入 do - while 中, 此时宏的名称用小写</p>
<figure class="highlight text"><table><tr><td class="code"><pre><span class="line">#define macrofun(a, b, c)             \</span><br><span class="line">    do &#123;                    \</span><br><span class="line">        if (a == 5)            \</span><br><span class="line">            do_this(b, c);        \</span><br><span class="line">    &#125; while (0)</span><br></pre></td></tr></table></figure>

<p>宏定义表达式时要放在 () 中</p>
<figure class="highlight text"><table><tr><td class="code"><pre><span class="line">#define CONSTANT 0x4000</span><br><span class="line">#define CONSTEXP (CONSTANT | 3)</span><br></pre></td></tr></table></figure>

<p>枚举类型 用来定义多个有联系的常量</p>
<h2 id="13、打印内核消息"><a href="#13、打印内核消息" class="headerlink" title="13、打印内核消息"></a><strong>13、打印内核消息</strong></h2><p>保持打印信息的简明清晰</p>
<p>比如, 不要用 “dont”, 而是使用 “do not” 或者 “don’t”</p>
<p>内核信息不需要使用 “.” 结尾</p>
<p>打印 “(%d)” 之类的没有任何意义, 应该避免</p>
<p>选择合适的打印级别(调试,还是警告,错误等等)</p>
<h2 id="14、分配内存"><a href="#14、分配内存" class="headerlink" title="14、分配内存"></a><strong>14、分配内存</strong></h2><p>分配内存时sizeof(指针) 而不是 sizeof(结构体)</p>
<figure class="highlight text"><table><tr><td class="code"><pre><span class="line">p = kmalloc(sizeof(*p), ...);</span><br></pre></td></tr></table></figure>

<p>这样的话, 当p指向其他结构体时, 上面的代码仍然可用</p>
<p>分配内存后返回值转为 void指针是多余的, C语言本身会完成这个步骤</p>
<h2 id="15、内联的弊端"><a href="#15、内联的弊端" class="headerlink" title="15、内联的弊端"></a><strong>15、内联的弊端</strong></h2><p>如果一个函数有3行以上, 不要使用 inline 来标记它</p>
<h2 id="16、函数返回值和名称"><a href="#16、函数返回值和名称" class="headerlink" title="16、函数返回值和名称"></a><strong>16、函数返回值和名称</strong></h2><p>如果函数功能是一个动作或者一个命令时, 返回 int型的 error-code</p>
<p>比如, add_work() 函数执行成功时返回 0, 失败时返回对应的error-code(ex. -EBUSY)</p>
<p>如果函数功能是一个判断时, 返回 “0” 表示失败, “1” 表示成功</p>
<p>所有Exported函数, 公用的函数都要上述2条要求</p>
<p>所有私有(static)函数, 不强制要求, 但最好能满足上面2条要求</p>
<p>如果函数返回真实计算结果, 而不是是否成功时, 通过返回计算结果范围外的值来表示失败</p>
<p>比如一个返回指针的函数, 通过返回 NULL 来表示失败</p>
<h2 id="17、不要重复发明内核宏"><a href="#17、不要重复发明内核宏" class="headerlink" title="17、不要重复发明内核宏"></a><strong>17、不要重复发明内核宏</strong></h2><p>内核定义的宏在头文件 <em>include&#x2F;linux&#x2F;kernel.h</em> 中, 想定义新的宏时, 首先看看其中是否已有类似的宏可用</p>
<h2 id="18、编辑器模式行和其他"><a href="#18、编辑器模式行和其他" class="headerlink" title="18、编辑器模式行和其他"></a><strong>18、编辑器模式行和其他</strong></h2><p>不要在代码中加入特定编辑器的内容或者其他工具的配置,</p>
<p>比如 emacs 的配置</p>
<figure class="highlight text"><table><tr><td class="code"><pre><span class="line">-*- mode: c -*-</span><br><span class="line">or</span><br><span class="line">Local Variables:</span><br><span class="line">compile-command: &quot;gcc -DMAGIC_DEBUG_FLAG foo.c&quot;</span><br><span class="line">End:</span><br></pre></td></tr></table></figure>

<p>vim 的配置</p>
<figure class="highlight text"><table><tr><td class="code"><pre><span class="line">vim:set sw=8 noet </span><br></pre></td></tr></table></figure>

<p>每个人使用的开发工具可能都不一样, 这样的配置对有些人来说就是垃圾</p>
<hr>
<p>版权声明：本文为知乎博主「<a href="https://www.zhihu.com/people/linuxwang-xian-sheng">极致Linux内核</a>」的原创文章，遵循CC 4.0 BY-SA版权协议，转载请附上原文出处链接及本声明。</p>
<p>原文链接：<a href="https://zhuanlan.zhihu.com/p/548067470">https://zhuanlan.zhihu.com/p/548067470</a></p>
]]></content>
      <categories>
        <category>linux-doc</category>
      </categories>
      <tags>
        <tag>Linux</tag>
      </tags>
  </entry>
  <entry>
    <title>Linux内核Makefile系统文件详解</title>
    <url>/2023/01/15/linux-docs/Linux%E5%86%85%E6%A0%B8Makefile%E7%B3%BB%E7%BB%9F%E6%96%87%E4%BB%B6%E8%AF%A6%E8%A7%A3/</url>
    <content><![CDATA[<h2 id="第一部分、概述"><a href="#第一部分、概述" class="headerlink" title="第一部分、概述"></a><strong>第一部分、概述</strong></h2><p>什么是makefile?或许很多Winodws的程序员都不知道这个东西,因为那些Windows 的IDE都为你做了这个工作,但我觉得要作一个好的和professional的程序员,makefile 还是要懂。这就好像现在有这么多的HTML的编辑器,但如果你想成为一个专业人士,你还是要了解HTML的标识的含义。特别在Unix下的软件编译,你就不能不自己写makefile了,会不会写makefile,从一个侧面说明了一个人是否具备完成大型工程的能力。 因为, makefile关系到了整个工程的编译规则。一个工程中的源文件不计数,其按类型、功能、模块分别放在若干个目录中,makefile定义了一系列的规则来指定,哪些文件需要先编译,哪些文件需要后编译,哪些文件需要重新编译,甚至于进行更复杂的功能操作,因为makefile就像一个Shell脚本一样,其中也可以执行操作系统的命令。 makefile带来的好处就是——“自动化编译”,一旦写好,只需要一个make命令,整个工程完全自动编译,极大的提高了软件开发的效率。make是一个命令工具,是一个解释makefile中指令的命令工具,一般来说,大多数的IDE都有这个命令,比如:Delphi的make,Visual C++的nmake, Linux下GNU的make。可见,makefile都成为了一种在工程方面的编译方法。</p>
<p>现在讲述如何写makefile的文章比较少,这是我想写这篇文章的原因。当然,不同产商的make各不相同,也有不同的语法,但其本质都是在“文件依赖性”上做文章,这里,我仅对GNU的make进行讲述,我的环境是RedHat Linux 8.0,make的版本是3.80。毕竟,这个make是应用最为广泛的,也是用得最多的。而且其还是最遵循于IEEE 1003.2-1992 标准的(POSIX.2)。</p>
<p>在这篇文档中,将以C&#x2F;C++的源码作为我们基础,所以必然涉及一些关于C&#x2F;C++的编译的知识,相关于这方面的内容,还请各位查看相关的编译器的文档。这里所默认的编译器是UNIX下的GCC和CC。</p>
<h2 id="第二部分、关于程序的编译和链接"><a href="#第二部分、关于程序的编译和链接" class="headerlink" title="第二部分、关于程序的编译和链接"></a><strong>第二部分、关于程序的编译和链接</strong></h2><p>在此,我想多说关于程序编译的一些规范和方法,一般来说,无论是C、C++、还是pas,首先要把源文件编译成中间代码文件,在Windows下也就是 .obj 文件,UNIX下是 .o 文件,即 Object File,这个动作叫做编译(compile)。然后再把大量的Object File合成执行文件,这个动作叫作链接(link)。 编译时,编译器需要的是语法的正确,函数与变量的声明的正确。对于后者,通常是你需要告诉编译器头文件的所在位置(头文件中应该只是声明,而定义应该放在C&#x2F;C++文件中),只要所有的语法正确,编译器就可以编译出中间目标文件。一般来说,每个源文件都应该对应于一个中间目标文件(O文件或是OBJ文件)。链接时,主要是链接函数和全局变量,所以,我们可以使用这些中间目标文件(O文件或是OBJ 文件)来链接我们的应用程序。链接器并不管函数所在的源文件,只管函数的中间目标文件(Object File),在大多数时候,由于源文件太多,编译生成的中间目标文件太多,而在链</p>
<p>届时需要明显地指出中间目标文件名,这对于编译很不方便,所以,我们要给中间目标文件打个包,在Windows下这种包叫“库文件”(Library File),也就是 .lib 文件,在UNIX 下,是Archive File,也就是 .a 文件。</p>
<p>总结一下,源文件首先会生成中间目标文件,再由中间目标文件生成执行文件。在编译时,编译器只检测程序语法,和函数、变量是否被声明。如果函数未被声明,编译器会给出一个警告,但可以生成Object File。而在链接程序时,链接器会在所有的Object File中找寻函数的实现,如果找不到,那到就会报链接错误码(Linker Error),在VC下,这种错误一般是:Link 2001错误,意思是说,链接器未能找到函数的实现。你需要指定函数的Object File.</p>
<p>好,言归正传,GNU的make有许多的内容,闲言少叙,还是让我们开始吧。</p>
<p><strong>第三部分、Makefile 介绍</strong></p>
<p>make命令执行时,需要一个 Makefile 文件,以告诉make命令需要怎么样的去编译和链接程序。</p>
<p>首先,我们用一个示例来说明Makefile的书写规则。以便给大家一个兴趣认识。这个示例来源于GNU的make使用手册,在这个示例中,我们的工程有8个C文件,和3个头文件,我们要写一个Makefile来告诉make命令如何编译和链接这几个文件。我们的规则是:</p>
<p>1)如果这个工程没有编译过,那么我们的所有C文件都要编译并被链接。</p>
<p>2)如果这个工程的某几个C文件被修改,那么我们只编译被修改的C文件,并链接目标程。</p>
<p>3)如果这个工程的头文件被改变了,那么我们需要编译引用了这几个头文件的C文件,并链接目标程序。</p>
<p>只要我们的Makefile写得够好,所有的这一切,我们只用一个make命令就可以完成, make命令会自动智能地根据当前的文件修改的情况来确定哪些文件需要重编译,从而自己编译所需要的文件和链接目标程序。</p>
<h3 id="一、Makefile的规则"><a href="#一、Makefile的规则" class="headerlink" title="一、Makefile的规则"></a>一、Makefile的规则</h3><p>在讲述这个Makefile之前,还是让我们先来粗略地看一看Makefile的规则。</p>
<figure class="highlight text"><table><tr><td class="code"><pre><span class="line">target ... : prerequisites ...</span><br><span class="line"></span><br><span class="line">command</span><br><span class="line"></span><br><span class="line">...</span><br><span class="line"></span><br><span class="line">...</span><br></pre></td></tr></table></figure>

<p>target也就是一个目标文件,可以是Object File,也可以是执行文件。还可以是一个标签(Label),对于标签这种特性,在后续的“伪目标”章节中会有叙述。 prerequisites就是,要生成那个target所需要的文件或是目标。</p>
<p>command也就是make需要执行的命令。(任意的Shell命令)</p>
<p>这是一个文件的依赖关系,也就是说,target这一个或多个的目标文件依赖于prerequisites中的文件,其生成规则定义在command中。说白一点就是说,prerequisites 中如果有一个以上的文件比target文件要新的话,command所定义的命令就会被执行。这就是Makefile的规则。也就是Makefile中最核心的内容。</p>
<p>说到底,Makefile的东西就是这样一点,好像我的这篇文档也该结束了。呵呵。还不尽然,这是Makefile的主线和核心,但要写好一个Makefile还不够,我会以后面一点一点地结合我的工作经验给你慢慢到来。内容还多着呢。</p>
<h3 id="二、一个示例"><a href="#二、一个示例" class="headerlink" title="二、一个示例"></a>二、一个示例</h3><p>正如前面所说的,如果一个工程有3个头文件,和8个C文件,我们为了完成前面所述的那三个规则,我们的Makefile应该是下面的这个样子的。</p>
<figure class="highlight text"><table><tr><td class="code"><pre><span class="line">edit : main.o kbd.o command.o display.o \</span><br><span class="line">insert.o search.o files.o utils.o</span><br><span class="line">cc -o edit main.o kbd.o command.o display.o \</span><br><span class="line">insert.o search.o files.o utils.o</span><br><span class="line">main.o : main.c defs.h</span><br><span class="line">cc -c main.c</span><br><span class="line">kbd.o : kbd.c defs.h command.h</span><br><span class="line">cc -c kbd.c</span><br><span class="line">command.o : command.c defs.h command.h</span><br><span class="line">cc -c command.c</span><br><span class="line">display.o : display.c defs.h buffer.h</span><br><span class="line">cc -c display.c</span><br><span class="line">insert.o : insert.c defs.h buffer.h</span><br><span class="line">cc -c insert.c</span><br><span class="line">search.o : search.c defs.h buffer.h</span><br><span class="line">cc -c search.c</span><br><span class="line">files.o : files.c defs.h buffer.h command.h</span><br><span class="line">cc -c files.c</span><br><span class="line">utils.o : utils.c defs.h</span><br><span class="line">cc -c utils.c</span><br><span class="line">clean :</span><br><span class="line">rm edit main.o kbd.o command.o display.o \</span><br><span class="line">insert.o search.o files.o utils.o</span><br></pre></td></tr></table></figure>

<p>反斜杠()是换行符的意思。这样比较便于Makefile的易读。我们可以把这个内容保存在文件为“Makefile”或“makefile”的文件中,然后在该目录下直接输入命令“make”就可以生成执行文件edit。如果要删除执行文件和所有的中间目标文件,那么,只要简单地执行一下“make clean”就可以了。</p>
<p>在这个makefile中,目标文件(target)包含:执行文件edit和中间目标文件(*.o),依赖文件(prerequisites)就是冒号后面的那些.c 文件和.h文件。每一个o 每个文件都有一组依赖文件,而这些 .o 文件又是执行文件 edit 的依赖文件。依赖关系的实质上就是说明了目标文件是由哪些文件生成的,换言之,目标文件是由哪些文件更新的。</p>
<p>在定义好依赖关系后,后续的那一行定义了如何生成目标文件的操作系统命令,一定要以一个Tab键作为开头。记住,make并不管命令是怎么工作的,他只管执行所定义的命令。make会比较targets文件和prerequisites文件的修改日期,如果prerequisites文件的日期要比targets文件的日期要新,或者target不存在的话,那么,make就会执行后续定义的命令。</p>
<p>这里要说明一点的是,clean不是一个文件,它只不过是一个动作名字,有点像C语言中的lable一样,其冒号后什么也没有,那么,make就不会自动去找文件的依赖性,也就不会自动执行其后所定义的命令。要执行其后的命令,就要在make命令后明显地指出这个lable的名字。这样的方法非常有用,我们可以在一个makefile中定义不用的编译或是和编译无关的命令,比如程序的打包,程序的备份等等。</p>
<h3 id="三、make是如何工作的"><a href="#三、make是如何工作的" class="headerlink" title="三、make是如何工作的"></a>三、make是如何工作的</h3><p><strong>在默认的方式下,也就是我们只输入make命令。那么,</strong></p>
<p>1、make会在当前目录下找名字叫“Makefile”或“makefile”的文件。</p>
<p>2、如果找到,它会找文件中的第一个目标文件(target),在上面的例子中,他会找到“edit”这个文件,并把这个文件作为最终的目标文件。</p>
<p>3、如果edit文件不存在,或是edit所依赖的后面的 .o 文件的文件修改时间要比edit 这个文件新,那么,他就会执行后面所定义的命令来生成edit这个文件。</p>
<p>4、如果edit所依赖的.o文件也存在,那么make会在当前文件中找目标为.o文件的依赖性,如果找到则再根据那一个规则生成.o文件。(这有点像一个堆栈的过程)</p>
<p>5、当然,你的C文件和H文件是存在的啦,于是make会生成 .o 文件,然后再用 .o 文件生命make的终极任务,也就是执行文件edit了。</p>
<p>这就是整个make的依赖性,make会一层又一层地去找文件的依赖关系,直到最终编译</p>
<p>出第一个目标文件。在找寻的过程中,如果出现错误,比如最后被依赖的文件找不到,那么make就会直接退出,并报错,而对于所定义的命令的错误,或是编译不成功,make根本不理。make只管文件的依赖性,即,如果在我找了依赖关系之后,冒号后面的文件还是不在,那么对不起,我就不工作啦。</p>
<p>通过上述分析,我们知道,像clean这种,没有被第一个目标文件直接或间接关联,那么它后面所定义的命令将不会被自动执行,不过,我们可以显示要make执行。即命令——“make clean”,以此来清除所有的目标文件,以便重编译。</p>
<p>于是在我们编程中,如果这个工程已被编译过了,当我们修改了其中一个源文件,比如file.c,那么根据我们的依赖性,我们的目标file.o会被重编译(也就是在这个依性关系后面所定义的命令),于是file.o的文件也是最新的啦,于是file.o的文件修改时间要比edit要新,所以edit也会被重新链接了(详见edit目标文件后定义的命令)。</p>
<p>而如果我们改变了“command.h”,那么,kdb.o、command.o和files.o都会被重编译,并且,edit会被重链接。</p>
<h3 id="四、makefile中使用变量"><a href="#四、makefile中使用变量" class="headerlink" title="四、makefile中使用变量"></a>四、makefile中使用变量</h3><p><strong>在上面的例子中,先让我们看看edit的规则:</strong></p>
<figure class="highlight text"><table><tr><td class="code"><pre><span class="line">edit : main.o kbd.o command.o display.o \</span><br><span class="line">insert.o search.o files.o utils.o</span><br><span class="line">cc -o edit main.o kbd.o command.o display.o \</span><br><span class="line">insert.o search.o files.o utils.o</span><br></pre></td></tr></table></figure>

<p>我们可以看到[.o]文件的字符串被重复了两次,如果我们的工程需要加入一个新的[.o]文件,那么我们需要在两个地方加(应该是三个地方,还有一个地方在clean中)。当然,我们的makefile并不复杂,所以在两个地方加也不累,但如果makefile变得复杂,那么我们就有可能会忘掉一个需要加入的地方,而导致编译失败。所以,为了makefile的易维护,在makefile中我们可以使用变量。makefile的变量也就是一个字符串,理解成C语言中的宏可能会更好。</p>
<p>比如,我们声明一个变量,叫objects, OBJECTS, objs, OBJS, obj, 或是 OBJ,反正不管什么啦,只要能够表示obj文件就行了。我们在makefile一开始就这样定义:</p>
<figure class="highlight text"><table><tr><td class="code"><pre><span class="line">objects = main.o kbd.o command.o display.o \</span><br><span class="line">insert.o search.o files.o utils.o</span><br></pre></td></tr></table></figure>

<p>于是,我们就可以很方便地在我们的makefile中以“$(objects)”的方式来使用这个变量了,于是我们的改良版makefile就变成下面这个样子:</p>
<figure class="highlight text"><table><tr><td class="code"><pre><span class="line">insert.o search.o files.o utils.o</span><br><span class="line">edit : $(objects)</span><br><span class="line">cc -o edit $(objects)</span><br><span class="line">main.o : main.c defs.h</span><br><span class="line">cc -c main.c</span><br><span class="line">kbd.o : kbd.c defs.h command.h</span><br><span class="line">cc -c kbd.c</span><br><span class="line">command.o : command.c defs.h command.h</span><br><span class="line">cc -c command.c</span><br><span class="line">display.o : display.c defs.h buffer.h</span><br><span class="line">cc -c display.c</span><br><span class="line">insert.o : insert.c defs.h buffer.h</span><br><span class="line">cc -c insert.c</span><br><span class="line">search.o : search.c defs.h buffer.h</span><br><span class="line">cc -c search.c</span><br><span class="line">files.o : files.c defs.h buffer.h command.h</span><br><span class="line">cc -c files.c</span><br><span class="line">utils.o : utils.c defs.h</span><br><span class="line">cc -c utils.c</span><br><span class="line">clean :</span><br><span class="line">rm edit $(objects)</span><br></pre></td></tr></table></figure>

<p>于是如果有新的 .o 文件加入,我们只需简单地修改一下 objects 变量就可以了。</p>
<p>关于变量更多的话题,我会在后续给你一一道来。</p>
<h3 id="五、让make自动推导"><a href="#五、让make自动推导" class="headerlink" title="五、让make自动推导"></a>五、让make自动推导</h3><p>GNU的make很强大,它可以自动推导文件以及文件依赖关系后面的命令,于是我们就没必要去在每一个[.o]文件后都写上类似的命令,因为,我们的make会自动识别,并自己推导命令。</p>
<p>只要make看到一个[.o]文件,它就会自动地把[.c]文件加在依赖关系中,如果make 找到一个whatever.o,那么whatever.c,就会是whatever.o的依赖文件。并且 cc -c whatever.c 也会被推导出来,于是,我们的makefile再也不用写得这么复杂。我们的是新的makefile又出炉了。</p>
<figure class="highlight text"><table><tr><td class="code"><pre><span class="line">insert.o search.o files.o utils.o</span><br><span class="line">edit : $(objects)</span><br><span class="line">cc -o edit $(objects)</span><br><span class="line">main.o : defs.h</span><br><span class="line">kbd.o : defs.h command.h</span><br><span class="line">command.o : defs.h command.h</span><br><span class="line">display.o : defs.h buffer.h</span><br><span class="line">insert.o : defs.h buffer.h</span><br><span class="line">search.o : defs.h buffer.h</span><br><span class="line">files.o : defs.h buffer.h command.h</span><br><span class="line">utils.o : defs.h</span><br><span class="line">.PHONY : clean</span><br><span class="line">clean :</span><br><span class="line">rm edit $(objects)</span><br></pre></td></tr></table></figure>

<p>这种方法,也就是make得“隐晦规则”。上面文件内容中,“.PHONY”表示,clean 是个伪目标文件。</p>
<p>关于更为详细的“隐晦规则”和“伪目标文件”,我会在后续给你一一道来。 六、另类风格的makefile</p>
<p>既然我们的make可以自动推导命令,那么我看到那堆[.o]和[.h]的依赖就有点不爽,那么多的重复的[.h],能不能把其收拢起来,好吧,没有问题,这个对于make来说很容易,谁叫它提供了自动推导命令和文件的功能呢?来看看最新风格的makefile吧。</p>
<figure class="highlight text"><table><tr><td class="code"><pre><span class="line">objects = main.o kbd.o command.o display.o \</span><br><span class="line">insert.o search.o files.o utils.o</span><br><span class="line">edit : $(objects)</span><br><span class="line">cc -o edit $(objects)</span><br><span class="line">$(objects) : defs.h</span><br><span class="line">kbd.o command.o files.o : command.h</span><br><span class="line">display.o insert.o search.o files.o : buffer.h</span><br><span class="line">.PHONY : clean</span><br><span class="line">clean :</span><br><span class="line">rm edit $(objects)</span><br></pre></td></tr></table></figure>

<p>这种风格,让我们的makefile变得很简单,但我们的文件依赖关系就显得有点凌乱了。鱼和熊掌不可兼得。还看你的喜好了。我是不喜欢这种风格的,一是文件的依赖关系看不清楚,二是如果文件一多,要加入几个新的.o文件,那就理不清楚了。</p>
<h3 id="七、清空目标文件的规则"><a href="#七、清空目标文件的规则" class="headerlink" title="七、清空目标文件的规则"></a>七、清空目标文件的规则</h3><p>每个Makefile中都应该写一个清空目标文件(.o和执行文件)的规则,这不仅便于重编译,也很利于保持文件的清洁。这是一个“修养”(呵呵,还记得我的《编程修养》吗)。一般的风格都是这样的:</p>
<figure class="highlight text"><table><tr><td class="code"><pre><span class="line">clean:</span><br><span class="line">rm edit $(objects)</span><br><span class="line">更为稳健的做法是:</span><br><span class="line">.PHONY : clean</span><br><span class="line">clean :</span><br><span class="line">-rm edit $(objects)</span><br></pre></td></tr></table></figure>

<p>前面说过,.PHONY意思表示clean是一个“伪目标”,。而在rm命令前面加了一个小减号的意思就是,也许某些文件出现问题,但不要管,继续做后面的事。当然,clean的规则不要放在文件的开头,不然,这就会变成make的默认目标,相信谁也不愿意这样。不成文的规矩是——“clean从来都是放在文件的最后”。</p>
<p>上面就是一个makefile的概貌,也是makefile的基础,下面还有很多makefile的相关细节,准备好了吗?准备好了就来。</p>
<h2 id="四部分、Makefile-总述"><a href="#四部分、Makefile-总述" class="headerlink" title="四部分、Makefile 总述"></a><strong>四部分、Makefile 总述</strong></h2><h3 id="一、Makefile里有什么"><a href="#一、Makefile里有什么" class="headerlink" title="一、Makefile里有什么?"></a>一、Makefile里有什么?</h3><p>Makefile里主要包含了五个东西:显式规则、隐晦规则、变量定义、文件指示和注释。</p>
<p>1、显式规则。</p>
<p>显式规则说明了,如何生成一个或多的的目标文件。这是由Makefile的书写者明显指出,要生成的文件,文件的依赖文件,生成的命令。</p>
<p>2、隐晦规则。</p>
<p>由于我们的make有自动推导的功能,所以隐晦的规则可以让我们比较粗糙地简略地书写Makefile,这是由make所支持的。</p>
<p>3、变量的定义。</p>
<p>在Makefile中我们要定义一系列的变量,变量一般都是字符串,这个有点你C语言中的宏,当Makefile被执行时,其中的变量都会被扩展到相应的引用位置上。</p>
<p>4、文件指示。</p>
<p>其包括了三个部分,一个是在一个Makefile中引用另一个Makefile,就像C语言中的include一样;另一个是指根据某些情况指定Makefile中的有效部分,就像C语言中的预编译#if一样;还有就是定义一个多行的命令。有关这一部分的内容,我会在后续的部分中讲述。</p>
<p>5、注释。</p>
<p>Makefile中只有行注释,和UNIX的Shell脚本一样,其注释是用“#”字符,这个就像C&#x2F;C++中的“&#x2F;&#x2F;”一样。如果你要在你的Makefile中使用“#”字符,可以用反斜框进行转义,如:“#”。</p>
<p>最后,还值得一提的是,在Makefile中的命令,必须要以[Tab]键开始。</p>
<h3 id="二、Makefile的文件名"><a href="#二、Makefile的文件名" class="headerlink" title="二、Makefile的文件名"></a>二、Makefile的文件名</h3><p>默认的情况下,make命令会在当前目录下按顺序找寻文件名为“GNUmakefile”、“makefile”、“Makefile”的文件,找到了解释这个文件。在这三个文件名中,最好使用“Makefile”这个文件名,因为,这个文件名第一个字符为大写,这样有一种显目的感觉。最好不要用“GNUmakefile”,这个文件是GNU的make识别的。有另外一些make只对全小写的“makefile”文件名敏感,但是基本上来说,大多数的make都支持“makefile”和“Makefile”这两种默认文件名。</p>
<p>当然,你可以使用别的文件名来书写Makefile,比如:“Make.Linux”,“Make.Solaris”,“Make.AIX”等,如果要指定特定的Makefile,你可以使用make的“-f”和“–file”参数,如:make -f Make.Linux或make –file Make.AIX。</p>
<h3 id="三、引用其它的Makefile"><a href="#三、引用其它的Makefile" class="headerlink" title="三、引用其它的Makefile"></a>三、引用其它的Makefile</h3><p>在Makefile使用include关键字可以把别的Makefile包含进来,这很像C语言的#include,被包含的文件会原模原样的放在当前文件的包含位置。include的语法是: include <filename></p>
<p>filename可以是当前操作系统Shell的文件模式(可以保含路径和通配符) 在include 前面可以有一些空字符,但是绝不能是[Tab]键开始。include和<filename>可以用一个或多个空格隔开。举个例子,你有这样几个Makefile:a.mk、b.mk、c.mk,还有一个文件叫foo.make,以及一个变量$(bar),其包含了e.mk和f.mk,那么,下面的语句:</p>
<p>include foo.make *.mk $(bar)</p>
<p>等价于:</p>
<p>include foo.make a.mk b.mk c.mk e.mk f.mk</p>
<p>make命令开始时,会把找寻include所指出的其它Makefile,并把其内容安置在当前的位。就好像C&#x2F;C++的#include指令一样。如果文件都没有指定绝对路径或是相对路径的话, make会在当前目录下首先寻找,如果当前目录下没有找到,那么,make还会在下面的几个目录下找:</p>
<p>1、如果make执行时,有“-I”或“–include-dir”参数,那么make就会在这个参数 所指定的目录下去寻找。</p>
<p>2、如果目录<prefix>&#x2F;include(一般是:&#x2F;usr&#x2F;local&#x2F;bin或&#x2F;usr&#x2F;include)存在的话, make也会去找。如果有文件没有找到的话,make会生成一条警告信息,但不会马上出现致命错误。它会继续载入其它的文件,一旦完成makefile的读取,make会再重试这些没有找到,或是不能读取的文件,如果还是不行,make才会出现一条致命信息。如果你想让make 不理那些无法读取的文件,而继续执行,你可以在include前加一个减号“-”。</p>
<p>如: -include <filename></p>
<p>其表示,无论include过程中出现什么错误,都不要报错继续执行。和其它版本make 兼 容的相关命令是sinclude,其作用和这一个是一样的。</p>
<h3 id="四、环境变量-MAKEFILES"><a href="#四、环境变量-MAKEFILES" class="headerlink" title="四、环境变量 MAKEFILES"></a>四、环境变量 MAKEFILES</h3><p>如果你的当前环境中定义了环境变量MAKEFILES,那么,make会把这个变量中的值做一个类似于include的动作。这个变量中的值是其它的Makefile,用空格分隔。只是,它和include 不同的是,从这个环境变中引入的Makefile的“目标”不会起作用,如果环境变量中定义的文件发现错误,make也会不理。</p>
<p>但是在这里我还是建议不要使用这个环境变量,因为只要这个变量一被定义,那么当你使用make时,所有的Makefile都会受到它的影响,这绝不是你想看到的。在这里提这个事,只是为了告诉大家,也许有时候你的Makefile出现了怪事,那么你可以看看当前环境中有没有定义这个变量。</p>
<h3 id="五、make的工作方式"><a href="#五、make的工作方式" class="headerlink" title="五、make的工作方式"></a>五、make的工作方式</h3><p>GNU的make工作时的执行步骤入下:(想来其它的make也是类似)</p>
<p>1、读入所有的Makefile。</p>
<p>2、读入被include的其它Makefile。</p>
<p>3、初始化文件中的变量。</p>
<p>4、推导隐晦规则,并分析所有规则。</p>
<p>5、为所有的目标文件创建依赖关系链。</p>
<p>6、根据依赖关系,决定哪些目标要重新生成。</p>
<p>7、执行生成命令。</p>
<p>1-5步为第一个阶段,6-7为第二个阶段。第一个阶段中,如果定义的变量被使用了,那么, make会把其展开在使用的位置。但make并不会完全马上展开,make使用的是拖延战术,如果变量出现在依赖关系的规则中,那么仅当这条依赖被决定要使用了,变量才会在其内部展开。</p>
<p>当然,这个工作方式你不一定要清楚,但是知道这个方式你也会对make更为熟悉。有了这个基础,后续部分也就容易看懂了。</p>
<h2 id="第五部分、书写规则"><a href="#第五部分、书写规则" class="headerlink" title="第五部分、书写规则"></a><strong>第五部分、书写规则</strong></h2><p>规则包含两个部分,一个是依赖关系,一个是生成目标的方法。</p>
<p>在Makefile中,规则的顺序是很重要的,因为,Makefile中只应该有一个最终目标,其它的目标都是被这个目标所连带出来的,所以一定要让make知道你的最终目标是什么。一般来说,定义在Makefile中的目标可能会有很多,但是第一条规则中的目标将被确立为最终的目标。如果第一条规则中的目标有很多个,那么,第一个目标会成为最终的目标。make 所完成的也就是这个目标。</p>
<p>好了,还是让我们来看一看如何书写规则。</p>
<h3 id="一、规则举例"><a href="#一、规则举例" class="headerlink" title="一、规则举例"></a>一、规则举例</h3><figure class="highlight text"><table><tr><td class="code"><pre><span class="line">foo.o : foo.c defs.h # foo模块</span><br><span class="line">cc -c -g foo.c</span><br></pre></td></tr></table></figure>

<p>看到这个例子,各位应该不是很陌生了,前面也已说过,foo.o是我们的目标,foo.c 和defs.h是目标所依赖的源文件,而只有一个命令“cc -c -g foo.c”(以Tab键开头)。这个规则告诉我们两件事:</p>
<p>1、文件的依赖关系,foo.o依赖于foo.c和defs.h的文件,如果foo.c和defs.h的文件日期要比foo.o文件日期要新,或是foo.o不存在,那么依赖关系发生。</p>
<p>2、如果生成(或更新)foo.o文件。也就是那个cc命令,其说明了,如何生成foo.o 这个文件。(当然foo.c文件include了defs.h文件)</p>
<h3 id="二、规则的语法"><a href="#二、规则的语法" class="headerlink" title="二、规则的语法"></a>二、规则的语法</h3><figure class="highlight text"><table><tr><td class="code"><pre><span class="line">targets : prerequisites</span><br><span class="line">command</span><br><span class="line">...</span><br></pre></td></tr></table></figure>

<p>或是这样:</p>
<figure class="highlight text"><table><tr><td class="code"><pre><span class="line">targets : prerequisites ; command</span><br><span class="line">command</span><br><span class="line">...</span><br></pre></td></tr></table></figure>

<p>targets是文件名,以空格分开,可以使用通配符。一般来说,我们的目标基本上是一个文件,但也有可能是多个文件。</p>
<p>command是命令行,如果其不与“target:prerequisites”在一行,那么,必须以[Tab 键]开头,如果和prerequisites在一行,那么可以用分号做为分隔。(见上) prerequisites 也就是目标所依赖的文件(或依赖目标)。如果其中的某个文件要比目标文件要新,那么,目标就被认为是“过时的”,被认为是需要重生成的。这个在前面已经讲过了。</p>
<p>如果命令太长,你可以使用反斜框(‘\’)作为换行符。make对一行上有多少个字符没有限制。规则告诉make两件事,文件的依赖关系和如何成成目标文件。</p>
<p>一般来说,make会以UNIX的标准Shell,也就是&#x2F;bin&#x2F;sh来执行命令。</p>
<h3 id="三、在规则中使用通配符"><a href="#三、在规则中使用通配符" class="headerlink" title="三、在规则中使用通配符"></a>三、在规则中使用通配符</h3><p>如果我们想定义一系列比较类似的文件,我们很自然地就想起使用通配符。make支持三各通配符:“*”,“?”和“[…]”。这是和Unix的B-Shell是相同的。 波浪号(“<del>”)字符在文件名中也有比较特殊的用途。如果是“</del>&#x2F;test”,这就表示当前用户的$HOME目录下的test目录。而“~hchen&#x2F;test”则表示用户hchen的宿主目录下的test目录。(这些都是Unix下的小知识了,make也支持)而在Windows或是MS-DOS下,用户没有宿主目录,那么波浪号所指的目录则根据环境变量“HOME”而定。</p>
<p>通配符代替了你一系列的文件,如“*.c”表示所以后缀为c的文件。一个需要我们注意的是,如果我们的文件名中有通配符,如:“<em>”,那么可以用转义字符“\”,如“*”来表示真实的“</em>”字符,而不是任意长度的字符串。</p>
<p>好吧,还是先来看几个例子吧:</p>
<figure class="highlight text"><table><tr><td class="code"><pre><span class="line">clean:</span><br><span class="line">rm -f *.o</span><br></pre></td></tr></table></figure>

<p>上面这个例子我不不多说了,这是操作系统Shell所支持的通配符。这是在命令中的通配符。</p>
<figure class="highlight text"><table><tr><td class="code"><pre><span class="line">print: *.c</span><br><span class="line">lpr -p $?</span><br><span class="line">touch print</span><br></pre></td></tr></table></figure>

<p>上面这个例子说明了通配符也可以在我们的规则中,目标print依赖于所有的[.c]文件。其中的“$?”是一个自动化变量,我会在后面给你讲述。</p>
<figure class="highlight text"><table><tr><td class="code"><pre><span class="line">objects = *.o</span><br></pre></td></tr></table></figure>

<p>上面这个例子,表示了,通符同样可以用在变量中。并不是说[<em>.o]会展开,不!objects 的值就是“</em>.o”。Makefile中的变量其实就是C&#x2F;C++中的宏。如果你要让通配符在变量中展开,也就是让objects的值是所有[.o]的文件名的集合,那么,你可以这样:</p>
<figure class="highlight text"><table><tr><td class="code"><pre><span class="line">objects := $(wildcard *.o)</span><br></pre></td></tr></table></figure>

<p>这种用法由关键字“wildcard”指出,关于Makefile的关键字,我们将在后面讨论。</p>
<h3 id="四、文件搜寻"><a href="#四、文件搜寻" class="headerlink" title="四、文件搜寻"></a>四、文件搜寻</h3><p>在一些大的工程中,有大量的源文件,我们通常的做法是把这许多的源文件分类,并存放在不同的目录中。所以,当make需要去找寻文件的依赖关系时,你可以在文件前加上路径,但最好的方法是把一个路径告诉make,让make在自动去找。</p>
<p>Makefile文件中的特殊变量“VPATH”就是完成这个功能的,如果没有指明这个变量, make只会在当前的目录中去找寻依赖文件和目标文件。如果定义了这个变量,那么,make 就会在当当前目录找不到的情况下,到所指定的目录中去找寻文件了。</p>
<figure class="highlight text"><table><tr><td class="code"><pre><span class="line">VPATH = src:../headers</span><br></pre></td></tr></table></figure>

<p>上面的的定义指定两个目录,“src”和“..&#x2F;headers”,make会按照这个顺序进行搜索。目录由“冒号”分隔。(当然,当前目录永远是最高优先搜索的地方)</p>
<p>另一个设置文件搜索路径的方法是使用make的“vpath”关键字(注意,它是全小写的),这不是变量,这是一个make的关键字,这和上面提到的那个VPATH变量很类似,但是它更为灵活。它可以指定不同的文件在不同的搜索目录中。这是一个很灵活的功能。它的使用方法有三种:</p>
<p>1、vpath <pattern> <directories></p>
<p>为符合模式<pattern>的文件指定搜索目录<directories>。</p>
<p>2、vpath <pattern></p>
<p>清除符合模式<pattern>的文件的搜索目录。</p>
<p>3、vpath</p>
<p>清除所有已被设置好了的文件搜索目录。</p>
<p>vapth使用方法中的<pattern>需要包含“%”字符。“%”的意思是匹配零或若干字符,例如,“%.h”表示所有以“.h”结尾的文件。<pattern>指定了要搜索的文件集,而<directories>则指定了<pattern>的文件集的搜索的目录。例如:</p>
<p>vpath %.h ..&#x2F;headers</p>
<p>该语句表示,要求make在“..&#x2F;headers”目录下搜索所有以“.h”结尾的文件。(如果某文件在当前目录没有找到的话)</p>
<p>我们可以连续地使用vpath语句,以指定不同搜索策略。如果连续的vpath语句中出现了相同的<pattern>,或是被重复了的<pattern>,那么,make会按照vpath语句的先后顺序来执行搜索。如:</p>
<figure class="highlight text"><table><tr><td class="code"><pre><span class="line">vpath %.c foo</span><br><span class="line">vpath % blish</span><br><span class="line">vpath %.c bar</span><br></pre></td></tr></table></figure>

<p>其表示“.c”结尾的文件,先在“foo”目录,然后是“blish”,最后是“bar”目录。</p>
<figure class="highlight text"><table><tr><td class="code"><pre><span class="line">vpath %.c foo:bar</span><br><span class="line">vpath % blish</span><br></pre></td></tr></table></figure>

<p>而上面的语句则表示“.c”结尾的文件,先在“foo”目录,然后是“bar”目录,最后才是“blish”目录。</p>
<h3 id="五、伪目标"><a href="#五、伪目标" class="headerlink" title="五、伪目标"></a>五、伪目标</h3><p>最早先的一个例子中,我们提到过一个“clean”的目标,这是一个“伪目标”,</p>
<figure class="highlight text"><table><tr><td class="code"><pre><span class="line">clean:</span><br><span class="line">rm *.o temp</span><br></pre></td></tr></table></figure>

<p>正像我们前面例子中的“clean”一样,即然我们生成了许多文件编译文件,我们也应该提供一个清除它们的“目标”以备完整地重编译而用。 (以“make clean”来使用该目标)</p>
<p>因为,我们并不生成“clean”这个文件。“伪目标”并不是一个文件,只是一个标签,由于“伪目标”不是文件,所以make无法生成它的依赖关系和决定它是否要执行。我们只有通过显示地指明这个“目标”才能让其生效。当然,“伪目标”的取名不能和文件名重名,不然其就失去了“伪目标”的意义了。</p>
<p>当然,为了避免和文件重名的这种情况,我们可以使用一个特殊的标记“.PHONY”来显示地指明一个目标是“伪目标”,向make说明,不管是否有这个文件,这个目标就是“伪目标”。</p>
<figure class="highlight text"><table><tr><td class="code"><pre><span class="line">.PHONY : clean</span><br></pre></td></tr></table></figure>

<p>只要有这个声明,不管是否有“clean”文件,要运行“clean”这个目标,只有“make clean”这样。于是整个过程可以这样写:</p>
<figure class="highlight text"><table><tr><td class="code"><pre><span class="line">.PHONY: clean</span><br><span class="line">clean:</span><br><span class="line">rm *.o temp</span><br></pre></td></tr></table></figure>

<p>伪目标一般没有依赖的文件。但是,我们也可以为伪目标指定所依赖的文件。伪目标同样可以作为“默认目标”,只要将其放在第一个。一个示例就是,如果你的Makefile需要一口气生成若干个可执行文件,但你只想简单地敲一个make完事,并且,所有的目标文件都写在一个Makefile中,那么你可以使用“伪目标”这个特性:</p>
<figure class="highlight text"><table><tr><td class="code"><pre><span class="line">all : prog1 prog2 prog3</span><br><span class="line">.PHONY : all</span><br><span class="line">prog1 : prog1.o utils.o</span><br><span class="line">cc -o prog1 prog1.o utils.o</span><br><span class="line">prog2 : prog2.o</span><br><span class="line">cc -o prog2 prog2.o</span><br><span class="line">prog3 : prog3.o sort.o utils.o</span><br><span class="line">cc -o prog3 prog3.o sort.o utils.o</span><br></pre></td></tr></table></figure>

<p>我们知道,Makefile中的第一个目标会被作为其默认目标。我们声明了一个“all”的伪目标,其依赖于其它三个目标。由于伪目标的特性是,总是被执行的,所以其依赖的那三个目标就总是不如“all”这个目标新。所以,其它三个目标的规则总是会被决议。也就达到了我们一口气生成多个目标的目的。“.PHONY : all”声明了“all”这个目标为“伪目标”。</p>
<p>随便提一句,从上面的例子我们可以看出,目标也可以成为依赖。所以,伪目标同样也可以成为依赖。看下面的例子:</p>
<figure class="highlight text"><table><tr><td class="code"><pre><span class="line">.PHONY: cleanall cleanobj cleandiff</span><br><span class="line">cleanall : cleanobj cleandiff</span><br><span class="line">rm program</span><br><span class="line">cleanobj :</span><br><span class="line">rm *.o</span><br><span class="line">cleandiff :</span><br><span class="line">rm *.diff</span><br><span class="line">“make clean”将清除所有要被清除的文件。</span><br><span class="line">“cleanobj”和“cleandiff”这两个伪目标有点像“子程序”的意思。</span><br><span class="line">我们可以输入“make cleanall”和“make cleanobj”和“make cleandiff”</span><br><span class="line">命令来达到清除不同种类文件的目的。</span><br></pre></td></tr></table></figure>

<h3 id="六、多目标"><a href="#六、多目标" class="headerlink" title="六、多目标"></a>六、多目标</h3><p>Makefile的规则中的目标可以不止一个,其支持多目标,有可能我们的多个目标同时依赖于一个文件,并且其生成的命令大体类似。于是我们就能把其合并起来。当然,多个目标的生成规则的执行命令是同一个,这可能会可我们带来麻烦,不过好在我们的可以使用一个自动化变量“$@”(关于自动化变量,将在后面讲述),这个变量表示着目前规则中所有的目标的集合,这样说可能很抽象,还是看一个例子吧。</p>
<figure class="highlight text"><table><tr><td class="code"><pre><span class="line">bigoutput littleoutput : text.g</span><br><span class="line">generate text.g -$(subst output,,$@) &gt; $@</span><br></pre></td></tr></table></figure>

<p>上述规则等价于:</p>
<figure class="highlight text"><table><tr><td class="code"><pre><span class="line">bigoutput : text.g</span><br><span class="line">generate text.g -big &gt; bigoutput</span><br><span class="line">littleoutput : text.g</span><br><span class="line">generate text.g -little &gt; littleoutput</span><br></pre></td></tr></table></figure>

<p>其中,-$(subst output,,$@)中的“$”表示执行一个Makefile的函数,函数名为subst,后面的为参数。关于函数,将在后面讲述。这里的这个函数是截取字符串的意思,“$@”表示目标的集合,就像一个数组,“$@”依次取出目标,并执于命令。</p>
<h3 id="七、静态模式"><a href="#七、静态模式" class="headerlink" title="七、静态模式"></a>七、静态模式</h3><p>静态模式可以更加容易地定义多目标的规则,可以让我们的规则变得更加的有弹性和灵活</p>
<p><strong>我们还是先来看一下语法:</strong></p>
<figure class="highlight text"><table><tr><td class="code"><pre><span class="line">&lt;targets ...&gt;: &lt;target-pattern&gt;: &lt;prereq-patterns ...&gt;</span><br><span class="line">&lt;commands&gt;</span><br><span class="line">....</span><br></pre></td></tr></table></figure>

<p>targets定义了一系列的目标文件,可以有通配符。是目标的一个集合。</p>
<p>target-parrtern是指明了targets的模式,也就是的目标集模式。</p>
<p>prereq-parrterns是目标的依赖模式,它对target-parrtern形成的模式再进行一次依赖目标的定义。</p>
<p>这样描述这三个东西,可能还是没有说清楚,还是举个例子来说明一下吧。如果我们的</p>
<p><target-parrtern>定义成“%.o”,意思是我们的<target>集合中都是以“.o”结尾的,而如果我们的<prereq-parrterns>定义成“%.c”,意思是对<target-parrtern>所形成的目标集进行二次定义,其计算方法是,取<target-parrtern>模式中的“%”(也就是去掉了[.o]这个结尾),并为其加上[.c]这个结尾,形成的新集合。</p>
<p>所以,我们的“目标模式”或是“依赖模式”中都应该有“%”这个字符,如果你的文件名中有“%”那么你可以使用反斜杠“\”进行转义,来标明真实的“%”字符。</p>
<p><strong>看一个例子:</strong></p>
<figure class="highlight text"><table><tr><td class="code"><pre><span class="line">objects = foo.o bar.o</span><br><span class="line">all: $(objects)</span><br><span class="line">$(objects): %.o: %.c</span><br><span class="line">$(CC) -c $(CFLAGS) $&lt; -o $@</span><br></pre></td></tr></table></figure>

<p>上面的例子中,指明了我们的目标从$object中获取,“%.o”表明要所有以“.o”结尾的目标,也就是“foo.o bar.o”,也就是变量$object集合的模式,而依赖模式“%.c”则取模式“%.o”的“%”,也就是“foo bar”,并为其加下“.c”的后缀,于是,我们的依赖目标就是“foo.c bar.c”。而命令中的“$&lt;”和“$@”则是自动化变量,“$&lt;”表示所有的依赖目标集(也就是“foo.c bar.c”),“$@”表示目标集(也就是“foo.o bar.o”)。于是,上面的规则展开后等价于下面的规则:</p>
<figure class="highlight text"><table><tr><td class="code"><pre><span class="line">foo.o : foo.c</span><br><span class="line">$(CC) -c $(CFLAGS) foo.c -o foo.o</span><br><span class="line">bar.o : bar.c</span><br><span class="line">$(CC) -c $(CFLAGS) bar.c -o bar.o</span><br></pre></td></tr></table></figure>

<p>试想,如果我们的“%.o”有几百个,那种我们只要用这种很简单的“静态模式规则”就可以写完一堆规则,实在是太有效率了。“静态模式规则”的用法很灵活,如果用得好,那会一个很强大的功能。再看一个例子:</p>
<figure class="highlight text"><table><tr><td class="code"><pre><span class="line">files = foo.elc bar.o lose.o</span><br><span class="line">$(filter %.o,$(files)): %.o: %.c</span><br><span class="line">$(CC) -c $(CFLAGS) $&lt; -o $@</span><br><span class="line">$(filter %.elc,$(files)): %.elc: %.el</span><br><span class="line">emacs -f batch-byte-compile $&lt;</span><br></pre></td></tr></table></figure>

<p>$(filter %.o,$(files))表示调用Makefile的filter函数,过滤“$filter”集,只要其中模式为“%.o”的内容。其的它内容,我就不用多说了吧。这个例字展示了Makefile中更大的弹性。</p>
<h3 id="八、自动生成依赖性"><a href="#八、自动生成依赖性" class="headerlink" title="八、自动生成依赖性"></a>八、自动生成依赖性</h3><p>在Makefile中,我们的依赖关系可能会需要包含一系列的头文件,比如,如果我们的main.c 中有一句“#include “defs.h””,那么我们的依赖关系应该是:</p>
<p>main.o : main.c defs.h</p>
<p>但是,如果是一个比较大型的工程,你必需清楚哪些C文件包含了哪些头文件,并且,你在加入或删除头文件时,也需要小心地修改Makefile,这是一个很没有维护性的工作。为了避免这种繁重而又容易出错的事情,我们可以使用C&#x2F;C++编译的一个功能。大多数的C&#x2F;C++编译器都支持一个“-M”的选项,即自动找寻源文件中包含的头文件,并生成一个依赖关系。例如,如果我们执行下面的命令:</p>
<figure class="highlight text"><table><tr><td class="code"><pre><span class="line">cc -M main.c</span><br></pre></td></tr></table></figure>

<p>其输出是:</p>
<figure class="highlight text"><table><tr><td class="code"><pre><span class="line">main.o : main.c defs.h</span><br></pre></td></tr></table></figure>

<p>于是由编译器自动生成的依赖关系,这样一来,你就不必再手动书写若干文件的依赖关系,而由编译器自动生成了。需要提醒一句的是,如果你使用GNU的C&#x2F;C++编译器,你得用“-MM”参数,不然,“-M”参数会把一些标准库的头文件也包含进来。</p>
<p><strong>gcc -M main.c的输出是:</strong></p>
<figure class="highlight text"><table><tr><td class="code"><pre><span class="line">main.o: main.c defs.h /usr/include/stdio.h /usr/include/features.h \</span><br><span class="line">/usr/include/sys/cdefs.h /usr/include/gnu/stubs.h \</span><br><span class="line">/usr/lib/gcc-lib/i486-suse-linux/2.95.3/include/stddef.h \</span><br><span class="line">/usr/include/bits/types.h /usr/include/bits/pthreadtypes.h \</span><br><span class="line">/usr/include/bits/sched.h /usr/include/libio.h \</span><br><span class="line">/usr/include/_G_config.h /usr/include/wchar.h \</span><br><span class="line">/usr/include/bits/wchar.h /usr/include/gconv.h \</span><br><span class="line">/usr/lib/gcc-lib/i486-suse-linux/2.95.3/include/stdarg.h \</span><br><span class="line">/usr/include/bits/stdio_lim.h</span><br><span class="line">gcc -MM main.c的输出则是:</span><br><span class="line">main.o: main.c defs.h</span><br></pre></td></tr></table></figure>

<p>那么,编译器的这个功能如何与我们的Makefile联系在一起呢。因为这样一来,我们的Makefile也要根据这些源文件重新生成,让Makefile自已依赖于源文件?这个功能并不现实,不过我们可以有其它手段来迂回地实现这一功能。GNU组织建议把编译器为每一个源</p>
<p>文件的自动生成的依赖关系放到一个文件中,为每一个“name.c”的文件都生成一个“name.d”的Makefile文件,[.d]文件中就存放对应[.c]文件的依赖关系。于是,我们可以写出[.c]文件和[.d]文件的依赖关系,并让make自动更新或自成[.d]文件,并把其包含在我们的主Makefile中,这样,我们就可以自动化地生成每个文件的依赖关系了。</p>
<p><strong>这里,我们给出了一个模式规则来产生[.d]文件:</strong></p>
<figure class="highlight text"><table><tr><td class="code"><pre><span class="line">%.d: %.c</span><br><span class="line">@set -e; rm -f $@; \</span><br><span class="line">$(CC) -M $(CPPFLAGS) $&lt; &gt; $@.$$$$; \</span><br><span class="line">sed &#x27;s,\($*\)\.o[ :]*,\1.o $@ : ,g&#x27; &lt; $@.$$$$ &gt; $@; \</span><br><span class="line">rm -f $@.$$$$</span><br></pre></td></tr></table></figure>

<p>这个规则的意思是,所有的[.d]文件依赖于[.c]文件,“rm -f $@”的意思是删除所有的目标,也就是[.d]文件,第二行的意思是,为每个依赖文件“$&lt;”,也就是[.c]文件生成依赖文件,“$@”表示模式“%.d”文件,如果有一个C文件是name.c,那么“%”就是“name”,“$$$$”意为一个随机编号,第二行生成的文件有可能是“name.d.12345”,第三行使用sed命令做了一个替换,关于sed命令的用法请参看相关的使用文档。第四行就是删除临时文件。</p>
<p>总而言之,这个模式要做的事就是在编译器生成的依赖关系中加入[.d]文件的依赖,即把依赖关系:</p>
<figure class="highlight text"><table><tr><td class="code"><pre><span class="line">main.o : main.c defs.h</span><br></pre></td></tr></table></figure>

<p>转成:</p>
<figure class="highlight text"><table><tr><td class="code"><pre><span class="line">main.o main.d : main.c defs.h</span><br></pre></td></tr></table></figure>

<p>于是,我们的[.d]文件也会自动更新了,并会自动生成了,当然,你还可以在这个[.d]文件中加入的不只是依赖关系,包括生成的命令也可一并加入,让每个[.d]文件都包含一个完赖的规则。一旦我们完成这个工作,接下来,我们就要把这些自动生成的规则放进我们的主Makefile中。我们可以使用Makefile的“include”命令,来引入别的Makefile文件(前面讲过),例如:</p>
<figure class="highlight text"><table><tr><td class="code"><pre><span class="line">sources = foo.c bar.c</span><br><span class="line">include $(sources:.c=.d)</span><br></pre></td></tr></table></figure>

<p>上述语句中的“$(sources:.c&#x3D;.d)”中的“.c&#x3D;.d”的意思是做一个替换,把变量$(sources)所有[.c]的字串都替换成[.d],关于这个“替换”的内容,在后面我会有更为详细的讲述。当然,你得注意次序,因为include是按次来载入文件,最先载入的[.d]文件中的目标会成为默认目标。</p>
<h2 id="第六部分书写命令"><a href="#第六部分书写命令" class="headerlink" title="第六部分书写命令"></a><strong>第六部分书写命令</strong></h2><p>每条规则中的命令和操作系统Shell的命令行是一致的。make会一按顺序一条一条的执行命令,每条命令的开头必须以[Tab]键开头,除非,命令是紧跟在依赖规则后面的分号后的。在命令行之间中的空格或是空行会被忽略,但是如果该空格或空行是以Tab键开头的,那么make会认为其是一个空命令。</p>
<p>我们在UNIX下可能会使用不同的Shell,但是make的命令默认是被“&#x2F;bin&#x2F;sh”——UNIX的标准Shell解释执行的。除非你特别指定一个其它的Shell。Makefile中,“#”是注释符,很像C&#x2F;C++中的“&#x2F;&#x2F;”,其后的本行字符都被注释。</p>
<h3 id="一、显示命令"><a href="#一、显示命令" class="headerlink" title="一、显示命令"></a><strong>一、显示命令</strong></h3><p>通常,make会把其要执行的命令行在命令执行前输出到屏幕上。当我们用“@”字符在命令行前,那么,这个命令将不被make显示出来,最具代表性的例子是,我们用这个功能来像屏幕显示一些信息。如:</p>
<p>@echo 正在编译XXX模块……</p>
<p>当make执行时,会输出“正在编译XXX模块……”字串,但不会输出命令,如果没有“@”,那么,make将输出:</p>
<p>echo 正在编译XXX模块……</p>
<p>正在编译XXX模块……</p>
<p>如果make执行时,带入make参数“-n”或“–just-print”,那么其只是显示命令,但不会执行命令,这个功能很有利于我们调试我们的Makefile,看看我们书写的命令是执行起来是什么样子的或是什么顺序的。</p>
<p>而make参数“-s”或“–slient”则是全面禁止命令的显示。</p>
<h3 id="二、命令执行"><a href="#二、命令执行" class="headerlink" title="二、命令执行"></a>二、命令执行</h3><p>当依赖目标新于目标时,也就是当规则的目标需要被更新时,make会一条一条的执行其后的命令。需要注意的是,如果你要让上一条命令的结果应用在下一条命令时,你应该使用分号分隔这两条命令。比如你的第一条命令是cd命令,你希望第二条命令得在cd之后的基础上运行,那么你就不能把这两条命令写在两行上,而应该把这两条命令写在一行上,用分号分隔。如:</p>
<p>示例一:</p>
<figure class="highlight text"><table><tr><td class="code"><pre><span class="line">exec:</span><br><span class="line">cd /home/hchen</span><br><span class="line">pwd</span><br></pre></td></tr></table></figure>

<p>示例二:</p>
<figure class="highlight text"><table><tr><td class="code"><pre><span class="line">exec:</span><br><span class="line">cd /home/hchen; pwd</span><br></pre></td></tr></table></figure>

<p>当我们执行“make exec”时,第一个例子中的cd没有作用,pwd会打印出当前的Makefile目录,而第二个例子中,cd就起作用了,pwd会打印出“&#x2F;home&#x2F;hchen”。make 一般是使用环境变量SHELL中所定义的系统Shell来执行命令,默认情况下使用UNIX的 标准Shell——&#x2F;bin&#x2F;sh来执行命令。但在MS-DOS下有点特殊,因为MS-DOS下没有SHELL 环境变量,当然你也可以指定。如果你指定了UNIX风格的目录形式,首先,make会在SHELL 所指定的路径中找寻命令解释器,如果找不到,其会在当前盘符中的当前目录中寻找,如果再找不到,其会在PATH环境变量中所定义的所有路径中寻找。MS-DOS中,如果你定义的命令解释器没有找到,其会给你的命令解释器加上诸如“.exe”、“.com”、“.bat”、“.sh”等后缀。</p>
<h3 id="三、命令出错"><a href="#三、命令出错" class="headerlink" title="三、命令出错"></a>三、命令出错</h3><p>每当命令运行完后,make会检测每个命令的返回码,如果命令返回成功,那么make会执行下一条命令,当规则中所有的命令成功返回后,这个规则就算是成功完成了。如果一个规则中的某个命令出错了(命令退出码非零),那么make就会终止执行当前规则,这将有可能终止所有规则的执行。</p>
<p>有些时候,命令的出错并不表示就是错误的。例如mkdir命令,我们一定需要建立一个目录,如果目录不存在,那么mkdir就成功执行,万事大吉,如果目录存在,那么就出错了。我们之所以使用mkdir的意思就是一定要有这样的一个目录,于是我们就不希望mkdir出错而终止规则的运行。</p>
<p>为了做到这一点,忽略命令的出错,我们可以在Makefile的命令行前加一个减号“-”(在Tab键之后),标记为不管命令出不出错都认为是成功的。如:</p>
<figure class="highlight text"><table><tr><td class="code"><pre><span class="line">clean:</span><br><span class="line">-rm -f *.o</span><br></pre></td></tr></table></figure>

<p>还有一个全局的办法是,给make加上“-i”或是“–ignore-errors”参数,那么, Makefile中所有命令都会忽略错误。而如果一个规则是以“.IGNORE”作为目标的,那么这个规则中的所有命令将会忽略错误。这些是不同级别的防止命令出错的方法,你可以根据你的不同喜欢设置。</p>
<p>还有一个要提一下的make的参数的是“-k”或是“–keep-going”,这个参数的意思是,如果某规则中的命令出错了,那么就终目该规则的执行,但继续执行其它规则。</p>
<h3 id="四、嵌套执行make"><a href="#四、嵌套执行make" class="headerlink" title="四、嵌套执行make"></a>四、嵌套执行make</h3><p>在一些大的工程中,我们会把我们不同模块或是不同功能的源文件放在不同的目录中,我们可以在每个目录中都书写一个该目录的Makefile,这有利于让我们的Makefile变得更加地简洁,而不至于把所有的东西全部写在一个Makefile中,这样会很难维护我们的Makefile,这个技术对于我们模块编译和分段编译有着非常大的好处。</p>
<p>例如,我们有一个子目录叫subdir,这个目录下有个Makefile文件,来指明了这个目录下文件的编译规则。那么我们总控的Makefile可以这样书写:</p>
<figure class="highlight text"><table><tr><td class="code"><pre><span class="line">subsystem:</span><br><span class="line">cd subdir &amp;&amp; $(MAKE)</span><br></pre></td></tr></table></figure>

<p>其等价于:</p>
<figure class="highlight text"><table><tr><td class="code"><pre><span class="line">subsystem:</span><br><span class="line">$(MAKE) -C subdir</span><br></pre></td></tr></table></figure>

<p>定义$(MAKE)宏变量的意思是,也许我们的make需要一些参数,所以定义成一个变量比较利于维护。这两个例子的意思都是先进入“subdir”目录,然后执行make命令。</p>
<p>我们把这个Makefile叫做“总控Makefile”,总控Makefile的变量可以传递到下级的Makefile中(如果你显示的声明),但是不会覆盖下层的Makefile中所定义的变量,除非指定了“-e”参数。</p>
<p>如果你要传递变量到下级Makefile中,那么你可以使用这样的声明:</p>
<p>export &lt;variable …&gt;</p>
<p>如果你不想让某些变量传递到下级Makefile中,那么你可以这样声明:</p>
<p>unexport &lt;variable …&gt;</p>
<p>如:</p>
<p>示例一:</p>
<figure class="highlight text"><table><tr><td class="code"><pre><span class="line">export variable = value</span><br></pre></td></tr></table></figure>

<p>其等价于:</p>
<figure class="highlight text"><table><tr><td class="code"><pre><span class="line">variable = value</span><br><span class="line">export variable</span><br></pre></td></tr></table></figure>

<p>其等价于:</p>
<figure class="highlight text"><table><tr><td class="code"><pre><span class="line">export variable := value</span><br></pre></td></tr></table></figure>

<p>其等价于:</p>
<figure class="highlight text"><table><tr><td class="code"><pre><span class="line">variable := value</span><br><span class="line">export variable</span><br></pre></td></tr></table></figure>

<p>示例二:</p>
<figure class="highlight text"><table><tr><td class="code"><pre><span class="line">export variable += value</span><br></pre></td></tr></table></figure>

<p>其等价于:</p>
<figure class="highlight text"><table><tr><td class="code"><pre><span class="line">variable += value</span><br><span class="line">export variable</span><br></pre></td></tr></table></figure>

<p>如果你要传递所有的变量,那么,只要一个export就行了。后面什么也不用跟,表示传递所有的变量。</p>
<p>需要注意的是,有两个变量,一个是SHELL,一个是MAKEFLAGS,这两个变量不管你是否export,其总是要传递到下层Makefile中,特别是MAKEFILES变量,其中包含了make 的参数信息,如果我们执行“总控Makefile”时有make参数或是在上层Makefile中定义了这个变量,那么MAKEFILES变量将会是这些参数,并会传递到下层Makefile中,这是一个系统级的环境变量。</p>
<p>但是make命令中的有几个参数并不往下传递,它们是“-C”,“-f”,“-h”“-o”和“-W”(有关Makefile参数的细节将在后面说明),如果你不想往下层传递参数,那么,你可以这样来:</p>
<p>subsystem:</p>
<p>cd subdir &amp;&amp; $(MAKE) MAKEFLAGS&#x3D;</p>
<p>如果你定义了环境变量MAKEFLAGS,那么你得确信其中的选项是大家都会用到的,如果其中有“-t”,“-n”,和“-q”参数,那么将会有让你意想不到的结果,或许会让你异常地恐慌。</p>
<p>还有一个在“嵌套执行”中比较有用的参数,“-w”或是“–print-directory”会在make的过程中输出一些信息,让你看到目前的工作目录。比如,如果我们的下级make目录是“&#x2F;home&#x2F;hchen&#x2F;gnu&#x2F;make”,如果我们使用“make -w”来执行,那么当进入该目录时,我们会看到:</p>
<p>make: Entering directory &#96;&#x2F;home&#x2F;hchen&#x2F;gnu&#x2F;make’.</p>
<p>而在完成下层make后离开目录时,我们会看到:</p>
<p>make: Leaving directory &#96;&#x2F;home&#x2F;hchen&#x2F;gnu&#x2F;make’</p>
<p>当你使用“-C”参数来指定make下层Makefile时,“-w”会被自动打开的。如果参数中有“-s”(“–slient”)或是“–no-print-directory”,那么,“-w”总是失效的。</p>
<p>五、定义命令包</p>
<p>如果Makefile中出现一些相同命令序列,那么我们可以为这些相同的命令序列定义一个变量。定义这种命令序列的语法以“define”开始,以“endef”结束,如:</p>
<figure class="highlight text"><table><tr><td class="code"><pre><span class="line">define run-yacc</span><br><span class="line">yacc $(firstword $^)</span><br><span class="line">mv y.tab.c $@</span><br><span class="line">endef</span><br></pre></td></tr></table></figure>

<p>这里,“run-yacc”是这个命令包的名字,其不要和Makefile中的变量重名。在“define”和“endef”中的两行就是命令序列。这个命令包中的第一个命令是运行Yacc 程序,因为Yacc程序总是生成“y.tab.c”的文件,所以第二行的命令就是把这个文件改改名字。还是把这个命令包放到一个示例中来看看吧。</p>
<p>foo.c : foo.y</p>
<p>$(run-yacc)</p>
<p>我们可以看见,要使用这个命令包,我们就好像使用变量一样。在这个命令包的使用中,命令包“run-yacc”中的“$^”就是“foo.y”,“$@”就是“foo.c”(有关这种以“$”开头的特殊变量,我们会在后面介绍),make在执行命令包时,命令包中的每个命令会被依次独立执行。</p>
<h2 id="第七部分使用变量"><a href="#第七部分使用变量" class="headerlink" title="第七部分使用变量"></a><strong>第七部分使用变量</strong></h2><p>在Makefile中的定义的变量,就像是C&#x2F;C++语言中的宏一样,他代表了一个文本字串,在Makefile中执行的时候其会自动原模原样地展开在所使用的地方。其与C&#x2F;C++所不同的是,你可以在Makefile中改变其值。在Makefile中,变量可以使用在“目标”,“依赖目标”,“命令”或是Makefile的其它部分中。</p>
<p>变量的命名字可以包含字符、数字,下划线(可以是数字开头),但不应该含有“:”、</p>
<p>“#”、“&#x3D;”或是空字符(空格、回车等)。变量是大小写敏感的,“foo”、“Foo”和“FOO”是三个不同的变量名。传统的Makefile的变量名是全大写的命名方式,但我推荐使用大小写搭配的变量名,如:MakeFlags。这样可以避免和系统的变量冲突,而发生意外的事情。</p>
<p>有一些变量是很奇怪字串,如“$&lt;”、“$@”等,这些是自动化变量,我会在后面介绍。</p>
<h3 id="一、变量的基础"><a href="#一、变量的基础" class="headerlink" title="一、变量的基础"></a>一、变量的基础</h3><p>变量在声明时需要给予初值,而在使用时,需要给在变量名前加上“$”符号,但最好用小括号“()”或是大括号“{}”把变量给包括起来。如果你要使用真实的“$”字符,那么你需要用“$$”来表示。</p>
<p>变量可以使用在许多地方,如规则中的“目标”、“依赖”、“命令”以及新的变量中。先看一个例子:</p>
<figure class="highlight text"><table><tr><td class="code"><pre><span class="line">objects = program.o foo.o utils.o</span><br><span class="line">program : $(objects)</span><br><span class="line">cc -o program $(objects)</span><br><span class="line">$(objects) : defs.h</span><br></pre></td></tr></table></figure>

<p>变量会在使用它的地方精确地展开,就像C&#x2F;C++中的宏一样,例如:</p>
<figure class="highlight text"><table><tr><td class="code"><pre><span class="line">foo = c</span><br><span class="line">prog.o : prog.$(foo)</span><br><span class="line">$(foo)$(foo) -$(foo) prog.$(foo)</span><br></pre></td></tr></table></figure>

<p>展开后得到:</p>
<figure class="highlight text"><table><tr><td class="code"><pre><span class="line">prog.o : prog.c</span><br><span class="line">cc -c prog.c</span><br></pre></td></tr></table></figure>

<p>当然,千万不要在你的Makefile中这样干,这里只是举个例子来表明Makefile中的变量在使用处展开的真实样子。可见其就是一个“替代”的原理。</p>
<p>另外,给变量加上括号完全是为了更加安全地使用这个变量,在上面的例子中,如果你不想给变量加上括号,那也可以,但我还是强烈建议你给变量加上括号。</p>
<h3 id="二、变量中的变量"><a href="#二、变量中的变量" class="headerlink" title="二、变量中的变量"></a>二、变量中的变量</h3><p>在定义变量的值时,我们可以使用其它变量来构造变量的值,在Makefile中有两种方式来在用变量定义变量的值。</p>
<p>先看第一种方式,也就是简单的使用“&#x3D;”号,在“&#x3D;”左侧是变量,右侧是变量的值,右侧变量的值可以定义在文件的任何一处,也就是说,右侧中的变量不一定非要是已定义好的值,其也可以使用后面定义的值。如:</p>
<figure class="highlight text"><table><tr><td class="code"><pre><span class="line">foo = $(bar)</span><br><span class="line">bar = $(ugh)</span><br><span class="line">ugh = Huh?</span><br><span class="line">all:</span><br><span class="line">echo $(foo)</span><br></pre></td></tr></table></figure>

<p>我们执行“make all”将会打出变量$(foo)的值是“Huh?”( $(foo)的值是$(bar), $(bar)的值是$(ugh),$(ugh)的值是“Huh?”)可见,变量是可以使用后面的变量来定义的。</p>
<p>这个功能有好的地方,也有不好的地方,好的地方是,我们可以把变量的真实值推到后面来定义,如:</p>
<figure class="highlight text"><table><tr><td class="code"><pre><span class="line">CFLAGS = $(include_dirs) -O</span><br><span class="line">include_dirs = -Ifoo -Ibar</span><br></pre></td></tr></table></figure>

<p>当“CFLAGS”在命令中被展开时,会是“-Ifoo -Ibar -O”。但这种形式也有不好的地方,那就是递归定义,如:</p>
<figure class="highlight text"><table><tr><td class="code"><pre><span class="line">CFLAGS = $(CFLAGS) -O</span><br></pre></td></tr></table></figure>

<p>或:</p>
<figure class="highlight text"><table><tr><td class="code"><pre><span class="line">A = $(B)</span><br><span class="line">B = $(A)</span><br></pre></td></tr></table></figure>

<p>这会让make陷入无限的变量展开过程中去,当然,我们的make是有能力检测这样的定义,并会报错。还有就是如果在变量中使用函数,那么,这种方式会让我们的make运行时非常慢,更糟糕的是,他会使用得两个make的函数“wildcard”和“shell”发生不可预知的错误。因为你不会知道这两个函数会被调用多少次。</p>
<p>为了避免上面的这种方法,我们可以使用make中的另一种用变量来定义变量的方法。这种方法使用的是“:&#x3D;”操作符,如:</p>
<figure class="highlight text"><table><tr><td class="code"><pre><span class="line">x := foo</span><br><span class="line">y := $(x) bar</span><br><span class="line">x := later</span><br></pre></td></tr></table></figure>

<p>其等价于:</p>
<figure class="highlight text"><table><tr><td class="code"><pre><span class="line">y := foo bar</span><br><span class="line">x := later</span><br></pre></td></tr></table></figure>

<p>值得一提的是,这种方法,前面的变量不能使用后面的变量,只能使用前面已定义好了的变量。如果是这样:</p>
<figure class="highlight text"><table><tr><td class="code"><pre><span class="line">y := $(x) bar</span><br><span class="line">x := foo</span><br></pre></td></tr></table></figure>

<p>那么,y的值是“bar”,而不是“foo bar”。</p>
<p>上面都是一些比较简单的变量使用了,让我们来看一个复杂的例子,其中包括了make 的函数、条件表达式和一个系统变量“MAKELEVEL”的使用:</p>
<figure class="highlight text"><table><tr><td class="code"><pre><span class="line">ifeq (0,$&#123;MAKELEVEL&#125;)</span><br><span class="line">cur-dir := $(shell pwd)</span><br><span class="line">whoami := $(shell whoami)</span><br><span class="line">host-type := $(shell arch)</span><br><span class="line">MAKE := $&#123;MAKE&#125; host-type=$&#123;host-type&#125; whoami=$&#123;whoami&#125;</span><br><span class="line">endif</span><br></pre></td></tr></table></figure>

<p>关于条件表达式和函数,我们在后面再说,对于系统变量“MAKELEVEL”,其意思是,如果我们的make有一个嵌套执行的动作(参见前面的“嵌套使用make”),那么,这个变量会记录了我们的当前Makefile的调用层数。</p>
<p>下面再介绍两个定义变量时我们需要知道的,请先看一个例子,如果我们要定义一个变量,其值是一个空格,那么我们可以这样来:</p>
<figure class="highlight text"><table><tr><td class="code"><pre><span class="line">nullstring :=</span><br><span class="line">space := $(nullstring) # end of the line</span><br></pre></td></tr></table></figure>

<p>nullstring是一个Empty变量,其中什么也没有,而我们的space的值是一个空格。因为在</p>
<p>操作符的右边是很难描述一个空格的,这里采用的技术很管用,先用一个Empty变量来标明变量的值开始了,而后面采用“#”注释符来表示变量定义的终止,这样,我们可以定义出其值是一个空格的变量。请注意这里关于“#”的使用,注释符“#”的这种特性值得我</p>
<p>们注意,如果我们这样定义一个变量:</p>
<figure class="highlight text"><table><tr><td class="code"><pre><span class="line">dir := /foo/bar # directory to put the frobs in</span><br></pre></td></tr></table></figure>

<p>dir这个变量的值是“&#x2F;foo&#x2F;bar”,后面还跟了4个空格,如果我们这样使用这样变量来指定别的目录——“$(dir)&#x2F;file”那么就完蛋了。</p>
<p>还有一个比较有用的操作符是“?&#x3D;”,先看示例:</p>
<figure class="highlight text"><table><tr><td class="code"><pre><span class="line">FOO ?= bar</span><br></pre></td></tr></table></figure>

<p>其含义是,如果FOO没有被定义过,那么变量FOO的值就是“bar”,如果FOO先前被定义过,那么这条语将什么也不做,其等价于:</p>
<figure class="highlight text"><table><tr><td class="code"><pre><span class="line">ifeq ($(origin FOO), undefined)</span><br><span class="line">FOO = bar</span><br><span class="line">endif</span><br></pre></td></tr></table></figure>

<h3 id="三、变量高级用法"><a href="#三、变量高级用法" class="headerlink" title="三、变量高级用法"></a>三、变量高级用法</h3><p>这里介绍两种变量的高级使用方法,第一种是变量值的替换。我们可以替换变量中的共有的部分,其格式是“$(var:a&#x3D;b)”或是“${var:a&#x3D;b}”,其意思是,把变量“var”中所有以“a”字串“结尾”的“a”替换成“b”字串。这里的“结尾”意思是“空格”或是“结束符”。</p>
<p>还是看一个示例吧:</p>
<figure class="highlight text"><table><tr><td class="code"><pre><span class="line">foo := a.o b.o c.o</span><br><span class="line">bar := $(foo:.o=.c)</span><br></pre></td></tr></table></figure>

<p>这个示例中,我们先定义了一个“$(foo)”变量,而第二行的意思是把“$(foo)”中所有以“.o”字串“结尾”全部替换成“.c”,所以我们的“$(bar)”的值就是“a.c b.c c.c”。</p>
<p>另外一种变量替换的技术是以“静态模式”(参见前面章节)定义的,如:</p>
<figure class="highlight text"><table><tr><td class="code"><pre><span class="line">foo := a.o b.o c.o</span><br><span class="line">bar := $(foo:%.o=%.c)</span><br></pre></td></tr></table></figure>

<p>这依赖于被替换字串中的有相同的模式,模式中必须包含一个“%”字符,这个例子同样让$(bar)变量的值为“a.c b.c c.c”。</p>
<p>第二种高级用法是——“把变量的值再当成变量”。先看一个例子:</p>
<figure class="highlight text"><table><tr><td class="code"><pre><span class="line">x = y</span><br><span class="line">y = z</span><br><span class="line">a := $($(x))</span><br></pre></td></tr></table></figure>

<p>在这个例子中,$(x)的值是“y”,所以$($(x))就是$(y),于是$(a)的值就是“z”。(注意,是“x&#x3D;y”,而不是“x&#x3D;$(y)”)</p>
<p>我们还可以使用更多的层次:</p>
<figure class="highlight text"><table><tr><td class="code"><pre><span class="line">x = y</span><br><span class="line">y = z</span><br><span class="line">z = u</span><br><span class="line">a := $($($(x)))</span><br></pre></td></tr></table></figure>

<p>这里的$(a)的值是“u”,相关的推导留给读者自己去做吧。</p>
<p>让我们再复杂一点,使用上“在变量定义中使用变量”的第一个方式,来看一个例子:</p>
<figure class="highlight text"><table><tr><td class="code"><pre><span class="line">x = $(y)</span><br><span class="line">y = z</span><br><span class="line">z = Hello</span><br><span class="line">a := $($(x))</span><br></pre></td></tr></table></figure>

<p>这里的$($(x))被替换成了$($(y)),因为$(y)值是“z”,所以,最终结果是:a:&#x3D;$(z),也就是“Hello”。</p>
<p>再复杂一点,我们再加上函数:</p>
<figure class="highlight text"><table><tr><td class="code"><pre><span class="line">x = variable1</span><br><span class="line">variable2 := Hello</span><br><span class="line">y = $(subst 1,2,$(x))</span><br><span class="line">z = y</span><br><span class="line">a := $($($(z)))</span><br></pre></td></tr></table></figure>

<p>这个例子中,“$($($(z)))”扩展为“$($(y))”,而其再次被扩展为“$($(subst 1,2,$(x)))”。$(x)的值是“variable1”,subst函数把“variable1”中的所有“1”字串替换成“2”字串,于是,“variable1”变成“variable2”,再取其值,所以,最终, $(a)的值就是$(variable2)的值——“Hello”。(喔,好不容易)</p>
<p>在这种方式中,或要可以使用多个变量来组成一个变量的名字,然后再取其值:</p>
<figure class="highlight text"><table><tr><td class="code"><pre><span class="line">first_second = Hello</span><br><span class="line">a = first</span><br><span class="line">b = second</span><br><span class="line">all = $($a_$b)</span><br></pre></td></tr></table></figure>

<p>这里的“$a_$b”组成了“first_second”,于是,$(all)的值就是“Hello”。</p>
<p>再来看看结合第一种技术的例子:</p>
<figure class="highlight text"><table><tr><td class="code"><pre><span class="line">a_objects := a.o b.o c.o</span><br><span class="line">1_objects := 1.o 2.o 3.o</span><br><span class="line">sources := $($(a1)_objects:.o=.c)</span><br></pre></td></tr></table></figure>

<p>这个例子中,如果$(a1)的值是“a”的话,那么,$(sources)的值就是“a.c b.c c.c”;如果$(a1)的值是“1”,那么$(sources)的值是“1.c 2.c 3.c”。</p>
<p>再来看一个这种技术和“函数”与“条件语句”一同使用的例子:</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">ifdef do_sort</span><br><span class="line">func := sort</span><br><span class="line"><span class="keyword">else</span></span><br><span class="line">func := strip</span><br><span class="line">endif</span><br><span class="line">bar := a d b g q c</span><br><span class="line">foo := $($(func) $(bar))</span><br></pre></td></tr></table></figure>

<p>这个示例中,如果定义了“do_sort”,那么:foo :&#x3D; $(sort a d b g q c),于是$(foo)的值就是“a b c d g q”,而如果没有定义“do_sort”,那么:foo :&#x3D; $(sort a d bg q c),调用的就是strip函数。</p>
<p>当然,“把变量的值再当成变量”这种技术,同样可以用在操作符的左边:</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">dir = foo</span><br><span class="line">$(dir)_sources := $(wildcard $(dir)<span class="comment">/*.c)</span></span><br><span class="line"><span class="comment">define $(dir)_print</span></span><br><span class="line"><span class="comment">lpr $($(dir)_sources)</span></span><br><span class="line"><span class="comment">endef</span></span><br></pre></td></tr></table></figure>

<p>这个例子中定义了三个变量:“dir”,“foo_sources”和“foo_print”。</p>
<h3 id="四、追加变量值"><a href="#四、追加变量值" class="headerlink" title="四、追加变量值"></a>四、追加变量值</h3><p>我们可以使用“+&#x3D;”操作符给变量追加值,如:</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">objects = main.o foo.o bar.o utils.o</span><br><span class="line">objects += another.o</span><br></pre></td></tr></table></figure>

<p>于是,我们的$(objects)值变成:“main.o foo.o bar.o utils.o another.o”(another.o 被追加进去了)</p>
<p>使用“+&#x3D;”操作符,可以模拟为下面的这种例子:</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">objects = main.o foo.o bar.o utils.o</span><br><span class="line">objects := $(objects) another.o</span><br></pre></td></tr></table></figure>

<p>所不同的是,用“+&#x3D;”更为简洁。</p>
<p>如果变量之前没有定义过,那么,“+&#x3D;”会自动变成“&#x3D;”,如果前面有变量定义,那么“+&#x3D;”会继承于前次操作的赋值符。如果前一次的是“:&#x3D;”,那么“+&#x3D;”会以“:&#x3D;”作为其赋值符,如:</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">variable := value</span><br><span class="line">variable += more</span><br></pre></td></tr></table></figure>

<p>等价于:</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">variable := value</span><br><span class="line">variable := $(variable) more</span><br></pre></td></tr></table></figure>

<p>但如果是这种情况:</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">variable = value</span><br><span class="line">variable += more</span><br></pre></td></tr></table></figure>

<p>由于前次的赋值符是“&#x3D;”,所以“+&#x3D;”也会以“&#x3D;”来做为赋值,那么岂不会发生变量的递补归定义,这是很不好的,所以make会自动为我们解决这个问题,我们不必担心这个问题。</p>
<h3 id="五、override-指示符"><a href="#五、override-指示符" class="headerlink" title="五、override 指示符"></a>五、override 指示符</h3><p>如果有变量是通常make的命令行参数设置的,那么Makefile中对这个变量的赋值会被忽略。</p>
<p>如果你想在Makefile中设置这类参数的值,那么,你可以使用“override”指示符。其语法是:</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">override</span> &lt;variable&gt; = &lt;value&gt;</span><br><span class="line"><span class="keyword">override</span> &lt;variable&gt; := &lt;value&gt;</span><br></pre></td></tr></table></figure>

<p>当然,你还可以追加:</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">override</span> &lt;variable&gt; += &lt;more text&gt;</span><br></pre></td></tr></table></figure>

<p>对于多行的变量定义,我们用define指示符,在define指示符前,也同样可以使用ovveride 指示符,如:</p>
<figure class="highlight text"><table><tr><td class="code"><pre><span class="line">override define foo</span><br><span class="line">bar</span><br><span class="line">endef</span><br></pre></td></tr></table></figure>

<h3 id="六、多行变量"><a href="#六、多行变量" class="headerlink" title="六、多行变量"></a>六、多行变量</h3><p>还有一种设置变量值的方法是使用define关键字。使用define关键字设置变量的值可以有换行,这有利于定义一系列的命令(前面我们讲过“命令包”的技术就是利用这个关键字)。</p>
<p>define指示符后面跟的是变量的名字,而重起一行定义变量的值,定义是以endef关键字结束。其工作方式和“&#x3D;”操作符一样。变量的值可以包含函数、命令、文字,或是其它变量。因为命令需要以[Tab]键开头,所以如果你用define定义的命令变量中没有以[Tab]键开头,那么make就不会把其认为是命令。</p>
<p>下面的这个示例展示了define的用法:</p>
<figure class="highlight text"><table><tr><td class="code"><pre><span class="line">define two-lines</span><br><span class="line">echo foo</span><br><span class="line">echo $(bar)</span><br><span class="line">endef</span><br></pre></td></tr></table></figure>

<h3 id="七、环境变量"><a href="#七、环境变量" class="headerlink" title="七、环境变量"></a>七、环境变量</h3><p>make运行时的系统环境变量可以在make开始运行时被载入到Makefile文件中,但是</p>
<p>如果Makefile中已定义了这个变量,或是这个变量由make命令行带入,那么系统的环境变量的值将被覆盖。(如果make指定了“-e”参数,那么,系统环境变量将覆盖Makefile中定义的变量)</p>
<p>因此,如果我们在环境变量中设置了“CFLAGS”环境变量,那么我们就可以在所有的Makefile中使用这个变量了。这对于我们使用统一的编译参数有比较大的好处。如果Makefile中定义了CFLAGS,那么则会使用Makefile中的这个变量,如果没有定义则使用系统环境变量的值,一个共性和个性的统一,很像“全局变量”和“局部变量”的特性。</p>
<p>当make嵌套调用时(参见前面的“嵌套调用”章节),上层Makefile中定义的变量会以系统环境变量的方式传递到下层的Makefile中。当然,默认情况下,只有通过命令行设置的变量会被传递。而定义在文件中的变量,如果要向下层Makefile传递,则需要使用exprot关键字来声明。(参见前面章节)</p>
<p>当然,我并不推荐把许多的变量都定义在系统环境中,这样,在我们执行不用的Makefile时,拥有的是同一套系统变量,这可能会带来更多的麻烦。</p>
<h3 id="八、目标变量"><a href="#八、目标变量" class="headerlink" title="八、目标变量"></a>八、目标变量</h3><p>前面我们所讲的在Makefile中定义的变量都是“全局变量”,在整个文件,我们都可以访问这些变量。当然,“自动化变量”除外,如“$&lt;”等这种类量的自动化变量就属于“规则型变量”,这种变量的值依赖于规则的目标和依赖目标的定义。当然,我样同样可以为某个目标设置局部变量,这种变量被称为“Target-specific Variable”,它可以和“全局变量”同名,因为它的作用范围只在这条规则以及连带规则中,所以其值也只在作用范围内有效。而不会影响规则链以外的全局变量的值。</p>
<p><strong>其语法是:</strong></p>
<figure class="highlight text"><table><tr><td class="code"><pre><span class="line">&lt;target ...&gt; : &lt;variable-assignment&gt;</span><br><span class="line">&lt;target ...&gt; : overide &lt;variable-assignment&gt;</span><br></pre></td></tr></table></figure>

<p><variable-assignment>可以是前面讲过的各种赋值表达式,如“&#x3D;”、“:&#x3D;”、“+&#x3D;”或是“?&#x3D;”。第二个语法是针对于make命令行带入的变量,或是系统环境变量。这个特性非常的有用,当我们设置了这样一个变量,这个变量会作用到由这个目标所引发的所有的规则中去。如:</p>
<figure class="highlight text"><table><tr><td class="code"><pre><span class="line">prog : CFLAGS = -g</span><br><span class="line">prog : prog.o foo.o bar.o</span><br><span class="line">$(CC) $(CFLAGS) prog.o foo.o bar.o</span><br><span class="line">prog.o : prog.c</span><br><span class="line">$(CC) $(CFLAGS) prog.c</span><br><span class="line">foo.o : foo.c</span><br><span class="line">$(CC) $(CFLAGS) foo.c</span><br><span class="line">bar.o : bar.c</span><br><span class="line">$(CC) $(CFLAGS) bar.c</span><br></pre></td></tr></table></figure>

<p>在这个示例中,不管全局的$(CFLAGS)的值是什么,在prog目标,以及其所引发的所有规则中(prog.o foo.o bar.o的规则),$(CFLAGS)的值都是“-g”</p>
<h3 id="九、模式变量"><a href="#九、模式变量" class="headerlink" title="九、模式变量"></a>九、模式变量</h3><p>在GNU的make中,还支持模式变量(Pattern-specific Variable),通过上面的目标变量中,我们知道,变量可以定义在某个目标上。模式变量的好处就是,我们可以给定一种“模式”,可以把变量定义在符合这种模式的所有目标上。</p>
<p>我们知道,make的“模式”一般是至少含有一个“%”的,所以,我们可以以如下方式给所有以[.o]结尾的目标定义目标变量:</p>
<figure class="highlight text"><table><tr><td class="code"><pre><span class="line">%.o : CFLAGS = -O</span><br></pre></td></tr></table></figure>

<p>同样,模式变量的语法和“目标变量”一样:</p>
<figure class="highlight text"><table><tr><td class="code"><pre><span class="line">&lt;pattern ...&gt; : &lt;variable-assignment&gt;</span><br><span class="line">&lt;pattern ...&gt; : override &lt;variable-assignment&gt;</span><br></pre></td></tr></table></figure>

<p>override同样是针对于系统环境传入的变量,或是make命令行指定的变量。</p>
<h2 id="第八部分使用条件判断"><a href="#第八部分使用条件判断" class="headerlink" title="第八部分使用条件判断"></a>第八部分使用条件判断</h2><p>使用条件判断,可以让make根据运行时的不同情况选择不同的执行分支。条件表达式可以是比较变量的值,或是比较</p>
<hr>
<p>版权声明：本文为知乎博主「玩转Linux内核」的原创文章，遵循CC 4.0 BY-SA版权协议，转载请附上原文出处链接及本声明。<br>原文链接：<a href="https://zhuanlan.zhihu.com/p/437667448">https://zhuanlan.zhihu.com/p/437667448</a></p>
]]></content>
      <categories>
        <category>linux-doc</category>
      </categories>
      <tags>
        <tag>Linux</tag>
      </tags>
  </entry>
  <entry>
    <title>Linux内核RCU机制</title>
    <url>/2023/01/15/linux-docs/Linux%E5%86%85%E6%A0%B8RCU%E6%9C%BA%E5%88%B6/</url>
    <content><![CDATA[<h2 id="1、概述"><a href="#1、概述" class="headerlink" title="1、概述"></a>1、概述</h2><ul>
<li>Read-copy update (RCU) 是一种 2002 年 10 月被引入到内核当中的同步机制。通过允许在更新的同时读数据，RCU 提高了同步机制的可伸缩性（scalability）。相对于传统的在并发线程间不区分是读者还是写者的简单互斥性锁机制，或者是哪些允许并发读但同时不 允许写的读写锁，RCU 支持同时一个更新线程和多个读线程的并发。RCU 通过保存对象的多个副本来保障读操作的连续性，并保证在预定的读方临界区没有完成之前不会释放这个对象。RCU定义并使用高效、可伸缩的机制来发布并读取 对象的新版本，并延长旧版本们的寿命。这些机制将工作分发到了读和更新路径上，以保证读路径可以极快地运行。在某些场合（非抢占内核），RCU 的读方没有任何性能负担。</li>
</ul>
<blockquote>
<p><strong>问题1</strong>：seqlock 不是也允许读线程和更新线程并发工作么？</p>
</blockquote>
<ul>
<li>这个问题可以归结到 “确切地说，什么是RCU？” 这个问题，或许还是 “RCU 可能是如何工作的？” （再或者，不太可能的情况下，问题会变为什么情况下 RCU 不太可能工作）。本文从几个基本的出发点来回答这些问题；之后还会分批地从使用的角度和 API 的角度来看这些问题。最后一篇连载还会给出一组参考文献。</li>
<li>RCU 由三个基本机制组成，第一个用于插入，第二个用于删除，而第三个则用于让读线程可以承受并发的插入或删除。这三个机制将在下面的三节中介绍，讲述如何将 RCU 转化为链表：</li>
</ul>
<ol>
<li>订阅发布机制 （用于插入）</li>
<li>等待已有的RCU读者完成 （用于删除）</li>
<li>维护多个最近更新的对象的版本 （为读者维护）</li>
</ol>
<ul>
<li>这三个章节之后还有上重点回顾与快速问题答案。</li>
</ul>
<h2 id="2、订阅发布机制"><a href="#2、订阅发布机制" class="headerlink" title="2、订阅发布机制"></a>2、订阅发布机制</h2><ul>
<li>RCU的一个关键特性是它可以安全地扫描数据，即使数据正被同时改写也没问题。要提供这种并发插入的能力，RCU使用了一种订阅发布机制。举例说，考虑一 个被初始化为 NULL 的全局指针变量 gp 将要被修改为新分配并初始化的数据结构。下面这段代码（使用附加的合适的锁机制）可以用于这个目的：</li>
</ul>
<figure class="highlight text"><table><tr><td class="code"><pre><span class="line">1 struct foo &#123;</span><br><span class="line">2 int a;</span><br><span class="line">3 int b;</span><br><span class="line">4 int c;</span><br><span class="line">5 &#125;;</span><br><span class="line">6 struct foo *gp = NULL;</span><br><span class="line">7</span><br><span class="line">8 /* . . . */</span><br><span class="line">9</span><br><span class="line">10 p = kmalloc(sizeof(*p), GFP_KERNEL);</span><br><span class="line">11 p-&gt;a = 1;</span><br><span class="line">12 p-&gt;b = 2;</span><br><span class="line">13 p-&gt;c = 3;</span><br><span class="line">14 gp = p;</span><br></pre></td></tr></table></figure>

<ul>
<li>不幸的是，没有方法强制保证编译器和CPU能顺序执行最后四条语句。如果gp的赋值早于p的各个域的初始化的话，那么并发的读操作将访问到未初始化的变 量。内存屏障（barrier）可以用于保障操作的顺序，但内存屏障以难以使用而闻名。这样我们将他们封装到具有发布语义的 rcu_assign_pointer() 原语之中。最后的四条将成为这样：</li>
</ul>
<figure class="highlight text"><table><tr><td class="code"><pre><span class="line">1 p-&gt;a = 1;</span><br><span class="line">2 p-&gt;b = 2;</span><br><span class="line">3 p-&gt;c = 3;</span><br><span class="line">4 rcu_assign_pointer(gp, p);</span><br></pre></td></tr></table></figure>

<ul>
<li>rcu_assign_pointer() 将会发布新的结构，强制编译器和CPU在给p的各个域赋值之后再把指针赋值给gp。然而，仅仅强制更新操作的顺序是不够的，读者也必须强制使用恰当的顺序。考虑下面的这段代码：</li>
</ul>
<figure class="highlight text"><table><tr><td class="code"><pre><span class="line">1 p = gp;</span><br><span class="line">2 if (p != NULL) &#123;</span><br><span class="line">3 do_something_with(p-&gt;a, p-&gt;b, p-&gt;c);</span><br><span class="line">4 &#125;</span><br></pre></td></tr></table></figure>

<ul>
<li>尽管这段代码看起来不会受到顺序错乱的影响，不过十分不幸，DEC Alpha CPU 和投机性编译器优化可能会引发问题，不论你是否相信，这的确有可能会导致 p-&gt;a, p-&gt;b, p-&gt;c 的读取会在读取 p 之前！这种情况在投机性编译器优化的情况中最有可能会出现，编译器会揣测p的值，取出 p-&gt;a, p-&gt;b 和 p-&gt;c，之后取出 p 的真实值来检查拽侧的正确性。这种优化非常激进，或者说疯狂，不过在确实会在profile-driven优化时发生。</li>
<li>毫无疑问，我们需要在CPU和编译器上阻止这种情况的发生。rcu_dereference() 原语使用了必要的内存屏障指令和编译器指令来达到这一目的：</li>
</ul>
<figure class="highlight text"><table><tr><td class="code"><pre><span class="line">1 rcu_read_lock();</span><br><span class="line">2 p = rcu_dereference(gp);</span><br><span class="line">3 if (p != NULL) &#123;</span><br><span class="line">4 do_something_with(p-&gt;a, p-&gt;b, p-&gt;c);</span><br><span class="line">5 &#125;</span><br><span class="line">6 rcu_read_unlock();</span><br></pre></td></tr></table></figure>

<ul>
<li>rcu_dereference() 原语可以被看作是订阅了指针指向的值，保证接下来的取值操作将会看到对应的发布操作（rcu_assign_pointer()）发生之前被初始化的值。 rcu_read_lock() 和 rcu_read_unlock() 绝对是必须的：他们定义了 RCU 读方临界区的范围。他们的目的将在下一节 解释，不过，他们不会自旋或阻塞，也不阻止 list_add_rcu() 的并发执行。事实上，对于非抢占内核，它们不产生任何代码。</li>
<li>虽然 rcu_assign_pointer() 和 rcu_dereference() 在理论上可以用于构建任意 RCU 保护的数据结构，但实际上，使用高层构造常常更好。因此，rcu_assign_pointer() 和 rcu_dereference() 原语被嵌入到了 Linux 的链表维护 API 中的特殊 RCU 变量之中了。Linux 有两个双向链表的变种，循环链表 struct list_head 和线性链表 struct hlist_head&#x2F;struct hlist_node。前者的结构如下图所示，绿色的方块表示表头，蓝色的是链表中的元素。</li>
</ul>
<p><img src="https://pic2.zhimg.com/80/v2-012ee665b35eb28bca5c88269765f069_720w.webp" alt="img"></p>
<ul>
<li>将上面的指针发布例子放到链表的场景中来就是这样：</li>
</ul>
<figure class="highlight text"><table><tr><td class="code"><pre><span class="line">1 struct foo &#123;</span><br><span class="line">2 struct list_head list;</span><br><span class="line">3 int a;</span><br><span class="line">4 int b;</span><br><span class="line">5 int c;</span><br><span class="line">6 &#125;;</span><br><span class="line">7 LIST_HEAD(head);</span><br><span class="line">8</span><br><span class="line">9 /* . . . */</span><br><span class="line">10</span><br><span class="line">11 p = kmalloc(sizeof(*p), GFP_KERNEL);</span><br><span class="line">12 p-&gt;a = 1;</span><br><span class="line">13 p-&gt;b = 2;</span><br><span class="line">14 p-&gt;c = 3;</span><br><span class="line">15 list_add_rcu(&amp;p-&gt;list, &amp;head);</span><br></pre></td></tr></table></figure>

<ul>
<li>第15行被使用某种同步机制保护住了，通常是某种所，以组织多个 list_add() 实例并发执行。然而，这些同步不能组织同时发生的RCU读者。订阅一个 RCU 保护的链表非常直接：</li>
</ul>
<figure class="highlight text"><table><tr><td class="code"><pre><span class="line">1 rcu_read_lock();</span><br><span class="line">2 list_for_each_entry_rcu(p, head, list) &#123;</span><br><span class="line">3 do_something_with(p-&gt;a, p-&gt;b, p-&gt;c);</span><br><span class="line">4 &#125;</span><br><span class="line">5 rcu_read_unlock();</span><br></pre></td></tr></table></figure>

<ul>
<li>ist_add_rcu() 原语发布一个节点到制定的链表中去，保证对应的 list_for_each_entry_rcu() 调用都正确的订阅到同一个节点上。</li>
</ul>
<blockquote>
<p><strong>问题2</strong>：如果在 list_for_each_entry_rcu() 运行时，刚好进行了一次 list_add_rcu()，如何防止 segfault 的发生呢？</p>
</blockquote>
<ul>
<li>Linux 中的另一个双向链表，hlist，是一个线性表，也就是说，它的头部仅需要一个指针，而不是向循环链表一样需要两个指针。这样，使用 hlist 作为大型哈希表的 hash-bucket 数组的容器将仅消耗一半的内存空间。</li>
</ul>
<p><img src="https://pic4.zhimg.com/80/v2-496211e59b1d9ad60c00facd22b051bb_720w.webp" alt="img"></p>
<ul>
<li>将一个新元素添加到一个 RCU 保护的 hlist 里面与添加到循环链表里非常类似：</li>
</ul>
<figure class="highlight text"><table><tr><td class="code"><pre><span class="line">1 struct foo &#123;</span><br><span class="line">2 struct hlist_node *list;</span><br><span class="line">3 int a;</span><br><span class="line">4 int b;</span><br><span class="line">5 int c;</span><br><span class="line">6 &#125;;</span><br><span class="line">7 HLIST_HEAD(head);</span><br><span class="line">8</span><br><span class="line">9 /* . . . */</span><br><span class="line">10</span><br><span class="line">11 p = kmalloc(sizeof(*p), GFP_KERNEL);</span><br><span class="line">12 p-&gt;a = 1;</span><br><span class="line">13 p-&gt;b = 2;</span><br><span class="line">14 p-&gt;c = 3;</span><br><span class="line">15 hlist_add_head_rcu(&amp;p-&gt;list, &amp;head);</span><br></pre></td></tr></table></figure>

<ul>
<li>和上面一样，第15行一定使用了锁或其他某种同步机制。</li>
<li>订阅一个 RCU 保护的 hlist 也和循环链表非常接近。</li>
</ul>
<figure class="highlight text"><table><tr><td class="code"><pre><span class="line">1 rcu_read_lock();</span><br><span class="line">2 hlist_for_each_entry_rcu(p, q, head, list) &#123;</span><br><span class="line">3 do_something_with(p-&gt;a, p-&gt;b, p-&gt;c);</span><br><span class="line">4 &#125;</span><br><span class="line">5 rcu_read_unlock();</span><br></pre></td></tr></table></figure>

<blockquote>
<p><strong>问题3</strong>：为什么我们需要传递两个指针给 hlist_for_each_entry_rcu()， list_for_each_entry_rcu() 可是只需要一个指针的啊？</p>
</blockquote>
<ul>
<li>RCU 发布与订阅原语在如下表中列出，同时给出了 “取消发布”或是撤回的原语</li>
</ul>
<blockquote>
<p>类别<br>发布<br>撤销<br>订阅<br>类别<br>发布<br>撤销<br>订阅<br>指针</p>
</blockquote>
<figure class="highlight text"><table><tr><td class="code"><pre><span class="line">rcu_assign_pointer()</span><br><span class="line">rcu_assign_pointer(…, NULL)</span><br><span class="line">rcu_dereference()</span><br></pre></td></tr></table></figure>

<ul>
<li>循环链表</li>
</ul>
<figure class="highlight text"><table><tr><td class="code"><pre><span class="line">list_add_rcu()</span><br><span class="line">list_add_tail_rcu()</span><br><span class="line">list_replace_rcu()</span><br><span class="line">list_del_rcu()</span><br><span class="line">list_for_each_entry_rcu()</span><br></pre></td></tr></table></figure>

<ul>
<li>双向链表</li>
</ul>
<figure class="highlight text"><table><tr><td class="code"><pre><span class="line">hlist_add_after_rcu()</span><br><span class="line">hlist_add_before_rcu()</span><br><span class="line">hlist_add_head_rcu()</span><br><span class="line">hlist_replace_rcu()</span><br><span class="line">hlist_del_rcu()</span><br><span class="line">hlist_for_each_entry_rcu()</span><br></pre></td></tr></table></figure>

<ul>
<li>注意，list_replace_rcu(), list_del_rcu(), hlist_replace_rcu(), 以及 hlist_del_rcu() 增加了一些复杂度。什么时候释放被替换或删除掉的数据元素才是安全的呢？具体地说，我们怎么能知道所有的读者都释放了他们手中对数据元素的引用呢？</li>
<li>这些问题将在下面的章节中得到回答。</li>
</ul>
<h2 id="3、等待已经存在的RCU读者完成"><a href="#3、等待已经存在的RCU读者完成" class="headerlink" title="3、等待已经存在的RCU读者完成"></a>3、等待已经存在的RCU读者完成</h2><ul>
<li>RCU的最基本的功能就是等待一些事情的完成。当然，还有很多其他方法也是用于等待事情完成的，包括引用计数、读写锁、事件等。RCU最大的好处在于它可 以等待所有（比如说）两万件不同点事情，而无需显式地跟踪它们中的每一个，也不需要担心性能的下降、可伸缩性限制、复杂度死锁场景，以及内存泄露等所有这 些显式跟踪手法所固有的问题。</li>
<li>RCU 中，被等待的东西被叫做“RCU读方临界区”。一个RCU读方临界区始于 rcu_read_lock() 原语，止于 rcu_read_unlock() 原语。RCU 读方临界区可以嵌套，也可以放入很多代码，只要这些代码显式阻塞或睡眠即可（有一种称为“SRCU”的特殊RCU允许在它的读方临界区中睡眠）。只要你遵守这些约定，你就可以使用RCU来等待任何期望的代码段的完成。</li>
<li>正如其他地方对经典RCU和实时RCU的描述，RCU 通过间接确定这些其他事情的完成时间来达到这一目的。</li>
<li>具体地说，如下图所示，RCU是一种等待已经存在的RCU读方临界区结束的方法，包括这些临界区中执行的内存操作。</li>
</ul>
<p><img src="https://pic2.zhimg.com/80/v2-1a827f87a39a2dc60210641d58550815_720w.webp" alt="img"></p>
<ul>
<li>注意，开始于一个给定宽限期开始之后的RCU读方临界区能够、并可以延续到该宽限期结束之后。</li>
<li>下面的伪码展示了使用RCU等待读者的基本算法形式：</li>
</ul>
<ol>
<li>进行改动，比如，替换链表中的一个元素。</li>
<li>等待所有已经存在的RCU读方临界区完成（比如，使用synchronize_rcu()原语）。关键点是接下来的RCU读方临界区将无法得到新近删除的元素的引用了。</li>
<li>清理，比如，释放上述所有被替换的元素。</li>
</ol>
<ul>
<li>下面的代码段是从前一节修改而得的，用于说明这一过程，这里面的域a是这个搜索的键值。</li>
</ul>
<figure class="highlight text"><table><tr><td class="code"><pre><span class="line">1 struct foo &#123;</span><br><span class="line">2 struct list_head list;</span><br><span class="line">3 int a;</span><br><span class="line">4 int b;</span><br><span class="line">5 int c;</span><br><span class="line">6 &#125;;</span><br><span class="line">7 LIST_HEAD(head);</span><br><span class="line">8</span><br><span class="line">9 /* . . . */</span><br><span class="line">10</span><br><span class="line">11 p = search(head, key);</span><br><span class="line">12 if (p == NULL) &#123;</span><br><span class="line">13 /* Take appropriate action, unlock, and return. */</span><br><span class="line">14 &#125;</span><br><span class="line">15 q = kmalloc(sizeof(*p), GFP_KERNEL);</span><br><span class="line">16 *q = *p;</span><br><span class="line">17 q-&gt;b = 2;</span><br><span class="line">18 q-&gt;c = 3;</span><br><span class="line">19 list_replace_rcu(&amp;p-&gt;list, &amp;q-&gt;list);</span><br><span class="line">20 synchronize_rcu();</span><br><span class="line">21 kfree(p);</span><br></pre></td></tr></table></figure>

<ul>
<li>第19、20 和 21 行实现了上面所说的三个步骤。第 16-19行展现了 RCU 的名字（读-复制-更新）：在允许进行并发读操作的同时，第16行进行了复制，而第17-19行进行了更新。</li>
<li>乍一看会觉得 synchronize_rcu() 原语显得比较神秘。毕竟它必须等所有读方临界区完成，而且，正如我们前面看到的，用于限制RCU读方临界区的rcu_read_lock() 和 rcu_read_unlock() 原语在非抢占内核中甚至什么代码都不会生成。</li>
<li>这里有一个小伎俩，经典RCU通过 rcu_read_lock() 和 rcu_read_unlock() 界定的读方临界区是不允许阻塞和休眠的。因此，当一个给定的CPU要进行上下文切换的时候，我们可以确定任何已有的RCU读方临界区都已经完成了。也就是说，只要每个CPU都至少进行了一次上下文切换，那么所有先前的 RCU 读方临界区也就保证都完成了，即 synchronize_rcu() 可以安全返回了。</li>
<li>因此，经典RCU的 synchronize_rcu() 从概念上说可以被简化成这样：</li>
</ul>
<figure class="highlight text"><table><tr><td class="code"><pre><span class="line">1 for_each_online_cpu(cpu)</span><br><span class="line">2 run_on(cpu);</span><br></pre></td></tr></table></figure>

<ul>
<li>这里，run_on() 将当前线程切换到指定 CPU，来强制该 CPU 进行上下文切换。而 for_each_online_cpu() 循环强制对每个 CPU 进行一次上下文切换。虽然这个简单的方法可以在一个不支持抢占的内核上工作，换句话说，对 non-CONFIG_PREEMPT 和 CONFIG_PREEMPT，但对 CONFIG_PREEMPT_RT 实时 (-rt) 内核无效。因此，实时RCU使用了一个（松散地）基于引用计数的方法。</li>
<li>当然，在真实内核中的实现要复杂得多了，因为它需要管理终端，NMI，CPU热插拔和其他实际内核中的可能有的风险，而且还要维护良好的性能和可伸缩性。RCU的实时实现还必须拥有良好的实时响应能力，这就使得（像上面两行那样）直接禁止抢占变得不可能了。</li>
<li>虽然我们了解到了 synchronize_rcu() 的简单实现原理，不过还有很多其它问题呢。比如，RCU读者们在读一个正在被并发地更新的链表的时候究竟读到了什么呢？这个问题将在下一节讲到。</li>
</ul>
<h2 id="3、维护多个版本的近期更新的对象"><a href="#3、维护多个版本的近期更新的对象" class="headerlink" title="3、维护多个版本的近期更新的对象"></a>3、维护多个版本的近期更新的对象</h2><ul>
<li>本节将展示 RCU 如何为多个不需要同步的读者维护不同版本的链表。我们使用两个例子来展示一个可能被给定的读者引用的元素必须在该读者处于读方临界区的整个过程中保持完好无损。第一个例子展示了链表元素的删除，而第二个例子则展示了元素的替换。</li>
</ul>
<h3 id="3-1例1：在删除时维护多个版本"><a href="#3-1例1：在删除时维护多个版本" class="headerlink" title="3.1例1：在删除时维护多个版本"></a>3.1例1：在删除时维护多个版本</h3><ul>
<li>要开始这个“删除”的例子，我们先把上节这个例子的 11-21行改成如下的形式：</li>
</ul>
<figure class="highlight text"><table><tr><td class="code"><pre><span class="line">1 p = search(head, key);</span><br><span class="line">2 if (p != NULL) &#123;</span><br><span class="line">3 list_del_rcu(&amp;p-&gt;list);</span><br><span class="line">4 synchronize_rcu();</span><br><span class="line">5 kfree(p);</span><br><span class="line">6 &#125;</span><br></pre></td></tr></table></figure>

<ul>
<li>这个链表以及指针p的最初情况是这样的：</li>
</ul>
<p><img src="https://pic3.zhimg.com/80/v2-5b6276c060823603a0ba47ebd86708fa_720w.webp" alt="img"></p>
<ul>
<li>表中每个元素的三元组分别代表域a, b, c。红色的便捷表明读者可以获取它们的指针，而且因为读操作和更新操作不是直接同步的，读者可以在这个删除的过程中同时发生。这里我们为了清晰没有画出双向链表的反向指针。</li>
<li>在第三行的 list_del_rcu() 完成的时候，5,6,7 这个元素已经被从链表中删除了（如下图）。由于读者并不直接和更新操作同步，读者可能同时正在扫描这个链表。由于访问时间不同，这些并发读者可能看到、也 可能没看到新近删除的元素。不过，那些在获取指针之后延迟了读操作的读者（比如因为中断、ECC内存错误，或在 <code>CONFIG_PREEMPT_RT</code>内核中因为抢占而延迟了的）可能仍然会在删除之后的一段时间内看到那个老的链表的版本。下图中 5,6,7 元素的边框仍然是红色的，这意味着仍然有读者可能会引用它。</li>
</ul>
<p><img src="https://pic3.zhimg.com/80/v2-ca58204812ee5d6f99b1ec329d4ba336_720w.webp" alt="img"></p>
<ul>
<li>这里注意，在退出读方临界区之后，读者们就不能再持有 5,6,7 这个元素的引用了。所以，一旦第4行的 synchronize_rcu() 完成了，所有已有读者也就保证都完成了，这样就没有读者会访问这个元素了，下图中，这个元素的边框也变黑了。我们的链表也回到了一个单一的版本了。</li>
</ul>
<p><img src="https://pic4.zhimg.com/80/v2-8967e74f0a254a2b248797e0799a469f_720w.webp" alt="img"></p>
<ul>
<li>这之后，5,6,7 这个元素就可以被安全的释放了：</li>
</ul>
<p><img src="https://pic2.zhimg.com/80/v2-eaa5c8018d4881fd75b7679190804d05_720w.webp" alt="img"></p>
<ul>
<li>这里，我们完成了删除 5,6,7 这个元素的操作，下一小节将介绍替换操作。</li>
</ul>
<h3 id="3-2例2：在替换的过程中维护数据的多个不同版本"><a href="#3-2例2：在替换的过程中维护数据的多个不同版本" class="headerlink" title="3.2例2：在替换的过程中维护数据的多个不同版本"></a>3.2例2：在替换的过程中维护数据的多个不同版本</h3><ul>
<li>在开始替换的例子钱，我们再修改一下前面例子的最后几行：</li>
</ul>
<figure class="highlight text"><table><tr><td class="code"><pre><span class="line">1 q = kmalloc(sizeof(*p), GFP_KERNEL);</span><br><span class="line">2 *q = *p;</span><br><span class="line">3 q-&gt;b = 2;</span><br><span class="line">4 q-&gt;c = 3;</span><br><span class="line">5 list_replace_rcu(&amp;p-&gt;list, &amp;q-&gt;list);</span><br><span class="line">6 synchronize_rcu();</span><br><span class="line">7 kfree(p);</span><br></pre></td></tr></table></figure>

<ul>
<li>这个链表的初始状态和指针p和删除的那个例子是完全一样的：</li>
</ul>
<p><img src="https://pic2.zhimg.com/80/v2-7c98797d5c46f6ec578f73367bf48539_720w.webp" alt="img"></p>
<ul>
<li>和之前一样，每个元素里面的三元组分别代表域 a, b 和 c。红色的边框代表了读者可能会持有这个元素的引用，因为读者和更新者没有直接的同步，读者可能会和整个替换过程并发进行。再次说明，这里我们为了清晰，再次省略了反向指针。</li>
<li>第一行的 kmalloc() 生成了一个替换元素，如下：</li>
</ul>
<p><img src="https://pic2.zhimg.com/80/v2-29c9713c93585e62275d53a59afb3c91_720w.webp" alt="img"></p>
<ul>
<li>第二行把旧的元素的内容拷贝给新的元素：</li>
</ul>
<p><img src="https://pic2.zhimg.com/80/v2-31e7ed70baf14bbf03e6da6d1b7fa789_720w.webp" alt="img"></p>
<ul>
<li>第三行，将 q-&gt;b 更新为2：</li>
</ul>
<p><img src="https://pic3.zhimg.com/80/v2-e2f9f26c5c686f526a308c29f379d9c6_720w.webp" alt="img"></p>
<ul>
<li>第四行，将 q-&gt;c 更新为3：</li>
</ul>
<p><img src="https://pic2.zhimg.com/80/v2-528c4fbc5af72c30b4c3ab45a1951021_720w.webp" alt="img"></p>
<ul>
<li>现在，第5行进行替换操作，这里，新元素最终对读者可见了。到了这里，如下所示，我们有了这个链表的两个版本。先前已经存在的读者可以看到 5,6,7 元素，而新读者将看到 5,2,3 元素。不过，任何读者都被保证可以看到一个完整的链表。</li>
</ul>
<p><img src="https://pic4.zhimg.com/80/v2-5306ffd65ecd6a45b4531f47758746f3_720w.webp" alt="img"></p>
<ul>
<li>第6行的 synchronize_rcu() 返回后，宽限期将完成，所有在 list_replace_rcu() 之前开始的读者都将完成。具体地说，任何可能持有 5,6,7 的读者都已经退出了他们的读方临界区，这就保证他们不再持有一个引用。因而也在没有任何读者持有老元素的引用了，途中，5,6,7 元素的边框也就变黑了。对于读者来说，目前又只有一个单一的链表版本了，只是新的元素已经替代了旧元素的位置。</li>
</ul>
<p><img src="https://pic3.zhimg.com/80/v2-b108855ba36180615dfbedab4e48ed1a_720w.webp" alt="img"></p>
<ul>
<li>第七行的 kfree() 完成后，链表旧成为了如下的样子：</li>
</ul>
<p><img src="https://pic1.zhimg.com/80/v2-98f007f889db00e72742635c8273c068_720w.webp" alt="img"></p>
<ul>
<li>尽管 RCU 是以替换而命名的，但内核中的大多数使用都是前面小节 中的简单删除的情况。</li>
</ul>
<h2 id="4、讨论"><a href="#4、讨论" class="headerlink" title="4、讨论"></a>4、讨论</h2><ul>
<li>这个例子假设在更新操作的过程中保存着一个互斥量，也就是说，这个链表在一个给定时间最多有两种版本。</li>
</ul>
<blockquote>
<p><strong>问题4</strong>：如何修改删除的例子，来允许超过两个版本的链表可以同时存在？<br><strong>问题5</strong>：在某一时刻，RCU最多可以有多少个链表的版本？</p>
</blockquote>
<ul>
<li>这组例子显示了RCU使用多个版本来保障在存在并发读者的情况下的安全更改数据。当然，一些算法是无法很好地支持多个版本的。</li>
</ul>
<blockquote>
<p><strong>问题6</strong>：如果 rcu_read_lock() 与 rcu_read_unlock() 之间没有自旋锁或阻塞，RCU更新者会怎样延迟RCU读者？</p>
</blockquote>
<ul>
<li>这三个RCU的组成部分允许数据在并发读者访问的同时更新数据，并可以以多种方式实现基于RCU的算法，</li>
</ul>
<hr>
<p>版权声明：本文为知乎博主「Linux内核库」的原创文章，遵循CC 4.0 BY-SA版权协议，转载请附上原文 出处链接及本声明。 </p>
<p>原文链接：<a href="https://zhuanlan.zhihu.com/p/516304206">https://zhuanlan.zhihu.com/p/516304206</a></p>
]]></content>
      <categories>
        <category>linux-doc</category>
      </categories>
      <tags>
        <tag>Linux</tag>
      </tags>
  </entry>
  <entry>
    <title>Linux内核fork()函数详解</title>
    <url>/2023/01/15/linux-docs/Linux%E5%86%85%E6%A0%B8fork()%E5%87%BD%E6%95%B0%E8%AF%A6%E8%A7%A3/</url>
    <content><![CDATA[<p>从一个比较有意思的题开始说起，最近要找工作无意间看到一个关于unix&#x2F;linux中fork()的面试题：</p>
<figure class="highlight text"><table><tr><td class="code"><pre><span class="line">1 #include&lt;sys/types.h&gt;</span><br><span class="line">  2 #include&lt;stdio.h&gt;</span><br><span class="line">  3 #include&lt;unistd.h&gt;</span><br><span class="line">  4    int main(void)</span><br><span class="line">  5         &#123;</span><br><span class="line">  6          int i;</span><br><span class="line">  7          int buf[100]=&#123;1,2,3,4,5,6,7,8,9&#125;;</span><br><span class="line">  8          for(i=0;i&lt;2;i++)</span><br><span class="line">  9           &#123;</span><br><span class="line"> 10             fork();</span><br><span class="line"> 11             printf(&quot;+&quot;);</span><br><span class="line"> 12             //write(&quot;/home/pi/code/test_fork/test_fork.txt&quot;,buf,8);</span><br><span class="line"> 13             write(STDOUT_FILENO,&quot;-&quot;,1);</span><br><span class="line"> 14           &#125;</span><br><span class="line"> 15          return 0;</span><br><span class="line"> 16</span><br><span class="line"> 17 &#125;</span><br></pre></td></tr></table></figure>

<p>题目要求是从上面的代码中确定输出的“+”的数量，我后面加了一个“-”，再确定输出“-”的数量。</p>
<p>先给答案：“+”8次，“-”6次</p>
<figure class="highlight text"><table><tr><td class="code"><pre><span class="line">1 ---++--++-++++</span><br></pre></td></tr></table></figure>

<p>上面的这段代码很简单，包含的内容却有很多，有进程产生、系统调用、不带缓冲I&#x2F;O、标准I&#x2F;O。</p>
<p>linux中产生一个进程的调用函数过程如下：</p>
<p>fork()———-&gt;sys_fork()————–&gt;do_fork()———-&gt;copy_process()</p>
<p>fork()、vfork()、_clone()库函数都根据各自需要的参数标志去调用clone()，然后由clone()去调用do_fork()。do_fork()完成了创建中的大部分工作，该函数调用copy_process()函数，</p>
<p>从用户空间调用fork()函数到执行系统调用产生软件中断陷入内核空间，在内核空间执行do_fork()函数，主要是复制父进程的页表、内核栈等，如果要执行子进程代码还要调用exac()函数拷贝硬盘上的代码到位内存上，由于刚创建的子进程没有申请内存，目前和父进程共用父进程的代码段、数据段等，没有存放子进程自己代码段数据段的内存，此时会产生一个缺页异常，为子进程申请内存，同时定制自己的全局描述GDT、局部描述符LDT、任务状态描述符TSS，下面从代码中分析这个过程然后在回答上面为什么“+”是8次，“-”6次。</p>
<p>调用fork()函数执行到了unistd.h中的宏函数syscall0</p>
<figure class="highlight text"><table><tr><td class="code"><pre><span class="line">/* XXX - _foo needs to be __foo, while __NR_bar could be _NR_bar. */</span><br><span class="line">/*</span><br><span class="line"> * Don&#x27;t remove the .ifnc tests; they are an insurance against</span><br><span class="line"> * any hard-to-spot gcc register allocation bugs.</span><br><span class="line"> */</span><br><span class="line">#define _syscall0(type,name) \</span><br><span class="line">type name(void) \</span><br><span class="line">&#123; \</span><br><span class="line">  register long __a __asm__ (&quot;r10&quot;); \</span><br><span class="line">  register long __n_ __asm__ (&quot;r9&quot;) = (__NR_##name); \</span><br><span class="line">  __asm__ __volatile__ (&quot;.ifnc %0%1,$r10$r9\n\t&quot; \</span><br><span class="line">            &quot;.err\n\t&quot; \</span><br><span class="line">            &quot;.endif\n\t&quot; \</span><br><span class="line">            &quot;break 13&quot; \</span><br><span class="line">            : &quot;=r&quot; (__a) \</span><br><span class="line">            : &quot;r&quot; (__n_)); \</span><br><span class="line">  if (__a &gt;= 0) \</span><br><span class="line">     return (type) __a; \</span><br><span class="line">  errno = -__a; \</span><br><span class="line">  return (type) -1; \</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>将宏函数展开后变为</p>
<figure class="highlight text"><table><tr><td class="code"><pre><span class="line">1 /* XXX - _foo needs to be __foo, while __NR_bar could be _NR_bar. */</span><br><span class="line"> 2 /*</span><br><span class="line"> 3  * Don&#x27;t remove the .ifnc tests; they are an insurance against</span><br><span class="line"> 4  * any hard-to-spot gcc register allocation bugs.</span><br><span class="line"> 5  */</span><br><span class="line"> 7 int fork(void) </span><br><span class="line"> 8 &#123; </span><br><span class="line"> 9   register long __a __asm__ (&quot;r10&quot;); \</span><br><span class="line">10   register long __n_ __asm__ (&quot;r9&quot;) = (__NR_##name); \</span><br><span class="line">11   __asm__ __volatile__ (&quot;.ifnc %0%1,$r10$r9\n\t&quot; \</span><br><span class="line">12             &quot;.err\n\t&quot; \</span><br><span class="line">13             &quot;.endif\n\t&quot; \</span><br><span class="line">14             &quot;break 13&quot; \</span><br><span class="line">15             : &quot;=r&quot; (__a) \</span><br><span class="line">16             : &quot;r&quot; (__n_)); \</span><br><span class="line">17   if (__a &gt;= 0) \</span><br><span class="line">18      return (type) __a; \</span><br><span class="line">19   errno = -__a; \</span><br><span class="line">20   return (type) -1; \</span><br><span class="line">21 &#125;</span><br></pre></td></tr></table></figure>

<p>##的意思就是宏中的字符直接替换</p>
<p>如果name &#x3D; fork，那么在宏中_ NR_##name就替换成了 _ NR_fork了。</p>
<p>_ NR _ ##name是系统调用号，##指的是两次宏展开．即用实际的系统调用名字代替”name”,然后再把_ NR _ …展开．如name &#x3D;&#x3D; ioctl，则为_ NR_ioctl。<br>上面的汇编目前还是没有怎么弄懂——-<br>int $0x80 是所有系统调用函数的总入口，fork()是其中之一，“0”(_NR_fork) 意思是将fork在sys_call_table[]中对应的函数编号_NR_fork也就是2，将2传给eax寄存器。这个编号就是sys_fork()函数在sys_call_table中的偏移值，其他的系统调用在sys_call_table均存在偏移值()。<br>int $0x80 中断返回后，将执行return (type) -1—–&gt;展开就是return (int) __a;产生int $0x80软件中断，CPU从3级特权的进程跳到0特权级内核代码中执行。中断使CPU硬件自动将SS、ESP、EFLAGGS、CS、EIP这五个寄存器的值按照这个顺序压人父进程的内核栈，这些压栈的数据将在后续的copy_process()函数中用来初始化进程1的任务状态描述符TSS<br>CPU自动压栈完成后，跳转到system_call.s中的_system_call处执行，继续将DS、ES、FS、EDX、ECX、EBX压栈(这些压栈仍旧是为了初始化子进程中的任务状态描述符TSS做准备)。最终内核通过刚刚设置的eax的偏移值“2”查询sys_call_table[],知道此次系统调用对应的函数是sys_fork()。跳转到_sys_fork处执行。<br>注意：一个函数的参数不是由函数定义的，而是由函数定义以外的程序通过压栈的方式“做”出来的，是操作系统底层代码与应用程序代码写作手法的差异之一。我们知道在C语言中函数运行时参数是存在栈中的，根据这个原理操作系统设计者可以将前面程序强行压栈的值作为函数的参数，当调用这个函数时这些值就是函数的参数。</p>
<p>sys_fork函数</p>
<figure class="highlight text"><table><tr><td class="code"><pre><span class="line">asmlinkage int sys_fork(void)</span><br><span class="line">&#123;</span><br><span class="line">#ifndef CONFIG_MMU</span><br><span class="line">    /* fork almost works, enough to trick you into looking elsewhere:-( */</span><br><span class="line">    return -EINVAL;</span><br><span class="line">#else</span><br><span class="line">    return do_fork(SIGCHLD, user_stack(__frame), __frame, 0, NULL, NULL);</span><br><span class="line">#endif</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>do_fork函数</p>
<figure class="highlight text"><table><tr><td class="code"><pre><span class="line">/*</span><br><span class="line"> *  Ok, this is the main fork-routine.</span><br><span class="line"> *</span><br><span class="line"> * It copies the process, and if successful kick-starts</span><br><span class="line"> * it and waits for it to finish using the VM if required.</span><br><span class="line"> */</span><br><span class="line">long do_fork(unsigned long clone_flags,</span><br><span class="line">          unsigned long stack_start,</span><br><span class="line">          struct pt_regs *regs,</span><br><span class="line">          unsigned long stack_size,</span><br><span class="line">          int __user *parent_tidptr,</span><br><span class="line">          int __user *child_tidptr)</span><br><span class="line">&#123;</span><br><span class="line">    struct task_struct *p;</span><br><span class="line">    int trace = 0;</span><br><span class="line">    struct pid *pid = alloc_pid();</span><br><span class="line">    long nr;</span><br><span class="line"></span><br><span class="line">    if (!pid)</span><br><span class="line">        return -EAGAIN;</span><br><span class="line">    nr = pid-&gt;nr;</span><br><span class="line">    if (unlikely(current-&gt;ptrace)) &#123;</span><br><span class="line">        trace = fork_traceflag (clone_flags);</span><br><span class="line">        if (trace)</span><br><span class="line">            clone_flags |= CLONE_PTRACE;</span><br><span class="line">    &#125;</span><br><span class="line">dup_task_struct</span><br><span class="line">    p = copy_process(clone_flags, stack_start, regs, stack_size, parent_tidptr, child_tidptr, pid);</span><br><span class="line">    /*</span><br><span class="line">     * Do this prior waking up the new thread - the thread pointer</span><br><span class="line">     * might get invalid after that point, if the thread exits quickly.</span><br><span class="line">     */</span><br><span class="line">    if (!IS_ERR(p)) &#123;</span><br><span class="line">        struct completion vfork;</span><br><span class="line"></span><br><span class="line">        if (clone_flags &amp; CLONE_VFORK) &#123;</span><br><span class="line">            p-&gt;vfork_done = &amp;vfork;</span><br><span class="line">            init_completion(&amp;vfork);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        if ((p-&gt;ptrace &amp; PT_PTRACED) || (clone_flags &amp; CLONE_STOPPED)) &#123;</span><br><span class="line">            /*</span><br><span class="line">             * We&#x27;ll start up with an immediate SIGSTOP.</span><br><span class="line">             */</span><br><span class="line">            sigaddset(&amp;p-&gt;pending.signal, SIGSTOP);</span><br><span class="line">            set_tsk_thread_flag(p, TIF_SIGPENDING);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        if (!(clone_flags &amp; CLONE_STOPPED))</span><br><span class="line">            wake_up_new_task(p, clone_flags);</span><br><span class="line">        else</span><br><span class="line">            p-&gt;state = TASK_STOPPED;</span><br><span class="line"></span><br><span class="line">        if (unlikely (trace)) &#123;</span><br><span class="line">            current-&gt;ptrace_message = nr;</span><br><span class="line">            ptrace_notify ((trace &lt;&lt; 8) | SIGTRAP);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        if (clone_flags &amp; CLONE_VFORK) &#123;</span><br><span class="line">            freezer_do_not_count();</span><br><span class="line">            wait_for_completion(&amp;vfork);</span><br><span class="line">            freezer_count();</span><br><span class="line">            if (unlikely (current-&gt;ptrace &amp; PT_TRACE_VFORK_DONE)) &#123;</span><br><span class="line">                current-&gt;ptrace_message = nr;</span><br><span class="line">                ptrace_notify ((PTRACE_EVENT_VFORK_DONE &lt;&lt; 8) | SIGTRAP);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; else &#123;</span><br><span class="line">        free_pid(pid);</span><br><span class="line">        nr = PTR_ERR(p);</span><br><span class="line">    &#125;</span><br><span class="line">    return nr;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>copy_process函数</p>
<figure class="highlight text"><table><tr><td class="code"><pre><span class="line">/*</span><br><span class="line"> * This creates a new process as a copy of the old one,</span><br><span class="line"> * but does not actually start it yet.</span><br><span class="line"> *</span><br><span class="line"> * It copies the registers, and all the appropriate</span><br><span class="line"> * parts of the process environment (as per the clone</span><br><span class="line"> * flags). The actual kick-off is left to the caller.</span><br><span class="line"> */</span><br><span class="line">static struct task_struct *copy_process(unsigned long clone_flags,</span><br><span class="line">                    unsigned long stack_start,</span><br><span class="line">                    struct pt_regs *regs,</span><br><span class="line">                    unsigned long stack_size,</span><br><span class="line">                    int __user *parent_tidptr,</span><br><span class="line">                    int __user *child_tidptr,</span><br><span class="line">                    struct pid *pid)</span><br><span class="line">&#123;</span><br><span class="line">    int retval;</span><br><span class="line">    struct task_struct *p = NULL;</span><br><span class="line"></span><br><span class="line">    if ((clone_flags &amp; (CLONE_NEWNS|CLONE_FS)) == (CLONE_NEWNS|CLONE_FS))</span><br><span class="line">        return ERR_PTR(-EINVAL);</span><br><span class="line"></span><br><span class="line">    /*</span><br><span class="line">     * Thread groups must share signals as well, and detached threads</span><br><span class="line">     * can only be started up within the thread group.</span><br><span class="line">     */</span><br><span class="line">    if ((clone_flags &amp; CLONE_THREAD) &amp;&amp; !(clone_flags &amp; CLONE_SIGHAND))</span><br><span class="line">        return ERR_PTR(-EINVAL);</span><br><span class="line"></span><br><span class="line">    /*</span><br><span class="line">     * Shared signal handlers imply shared VM. By way of the above,</span><br><span class="line">     * thread groups also imply shared VM. Blocking this case allows</span><br><span class="line">     * for various simplifications in other code.</span><br><span class="line">     */</span><br><span class="line">    if ((clone_flags &amp; CLONE_SIGHAND) &amp;&amp; !(clone_flags &amp; CLONE_VM))</span><br><span class="line">        return ERR_PTR(-EINVAL);</span><br><span class="line"></span><br><span class="line">    retval = security_task_create(clone_flags);</span><br><span class="line">    if (retval)</span><br><span class="line">        goto fork_out;</span><br><span class="line"></span><br><span class="line">    retval = -ENOMEM;</span><br><span class="line">    p = dup_task_struct(current);</span><br><span class="line">    if (!p)</span><br><span class="line">        goto fork_out;</span><br><span class="line">sys_fork</span><br><span class="line">    rt_mutex_init_task(p);</span><br><span class="line"></span><br><span class="line">#ifdef CONFIG_TRACE_IRQFLAGS</span><br><span class="line">    DEBUG_LOCKS_WARN_ON(!p-&gt;hardirqs_enabled);</span><br><span class="line">    DEBUG_LOCKS_WARN_ON(!p-&gt;softirqs_enabled);</span><br><span class="line">#endif</span><br><span class="line">    retval = -EAGAIN;</span><br><span class="line">    if (atomic_read(&amp;p-&gt;user-&gt;processes) &gt;=</span><br><span class="line">            p-&gt;signal-&gt;rlim[RLIMIT_NPROC].rlim_cur) &#123;</span><br><span class="line">        if (!capable(CAP_SYS_ADMIN) &amp;&amp; !capable(CAP_SYS_RESOURCE) &amp;&amp;</span><br><span class="line">                p-&gt;user != &amp;root_user)</span><br><span class="line">            goto bad_fork_free;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    atomic_inc(&amp;p-&gt;user-&gt;__count);</span><br><span class="line">    atomic_inc(&amp;p-&gt;user-&gt;processes);</span><br><span class="line">    get_group_info(p-&gt;group_info);</span><br><span class="line"></span><br><span class="line">    /*</span><br><span class="line">     * If multiple threads are within copy_process(), then this check</span><br><span class="line">     * triggers too late. This doesn&#x27;t hurt, the check is only there</span><br><span class="line">     * to stop root fork bombs.</span><br><span class="line">     */</span><br><span class="line">    if (nr_threads &gt;= max_threads)</span><br><span class="line">        goto bad_fork_cleanup_count;</span><br><span class="line"></span><br><span class="line">    if (!try_module_get(task_thread_info(p)-&gt;exec_domain-&gt;module))</span><br><span class="line">        goto bad_fork_cleanup_count;</span><br><span class="line"></span><br><span class="line">    if (p-&gt;binfmt &amp;&amp; !try_module_get(p-&gt;binfmt-&gt;module))</span><br><span class="line">        goto bad_fork_cleanup_put_domain;</span><br><span class="line"></span><br><span class="line">    p-&gt;did_exec = 0;</span><br><span class="line">    delayacct_tsk_init(p);    /* Must remain after dup_task_struct() */</span><br><span class="line">    copy_flags(clone_flags, p);</span><br><span class="line">    p-&gt;pid = pid_nr(pid);</span><br><span class="line">    retval = -EFAULT;</span><br><span class="line">    if (clone_flags &amp; CLONE_PARENT_SETTID)</span><br><span class="line">        if (put_user(p-&gt;pid, parent_tidptr))</span><br><span class="line">            goto bad_fork_cleanup_delays_binfmt;</span><br><span class="line"></span><br><span class="line">    INIT_LIST_HEAD(&amp;p-&gt;children);</span><br><span class="line">    INIT_LIST_HEAD(&amp;p-&gt;sibling);</span><br><span class="line">    p-&gt;vfork_done = NULL;</span><br><span class="line">    spin_lock_init(&amp;p-&gt;alloc_lock);</span><br><span class="line"></span><br><span class="line">    clear_tsk_thread_flag(p, TIF_SIGPENDING);</span><br><span class="line">    init_sigpending(&amp;p-&gt;pending);</span><br><span class="line"></span><br><span class="line">    p-&gt;utime = cputime_zero;</span><br><span class="line">    p-&gt;stime = cputime_zero;</span><br><span class="line">     p-&gt;sched_time = 0;</span><br><span class="line">#ifdef CONFIG_TASK_XACCT</span><br><span class="line">    p-&gt;rchar = 0;        /* I/O counter: bytes read */</span><br><span class="line">    p-&gt;wchar = 0;        /* I/O counter: bytes written */</span><br><span class="line">    p-&gt;syscr = 0;        /* I/O counter: read syscalls */</span><br><span class="line">    p-&gt;syscw = 0;        /* I/O counter: write syscalls */</span><br><span class="line">#endif</span><br><span class="line">    task_io_accounting_init(p);</span><br><span class="line">    acct_clear_integrals(p);</span><br><span class="line"></span><br><span class="line">     p-&gt;it_virt_expires = cputime_zero;</span><br><span class="line">    p-&gt;it_prof_expires = cputime_zero;</span><br><span class="line">     p-&gt;it_sched_expires = 0;</span><br><span class="line">     INIT_LIST_HEAD(&amp;p-&gt;cpu_timers[0]);</span><br><span class="line">     INIT_LIST_HEAD(&amp;p-&gt;cpu_timers[1]);</span><br><span class="line">     INIT_LIST_HEAD(&amp;p-&gt;cpu_timers[2]);</span><br><span class="line"></span><br><span class="line">    p-&gt;lock_depth = -1;        /* -1 = no lock */</span><br><span class="line">    do_posix_clock_monotonic_gettime(&amp;p-&gt;start_time);</span><br><span class="line">    p-&gt;security = NULL;</span><br><span class="line">    p-&gt;io_context = NULL;</span><br><span class="line">    p-&gt;io_wait = NULL;</span><br><span class="line">    p-&gt;audit_context = NULL;</span><br><span class="line">    cpuset_fork(p);</span><br><span class="line">#ifdef CONFIG_NUMA</span><br><span class="line">     p-&gt;mempolicy = mpol_copy(p-&gt;mempolicy);</span><br><span class="line">     if (IS_ERR(p-&gt;mempolicy)) &#123;</span><br><span class="line">         retval = PTR_ERR(p-&gt;mempolicy);</span><br><span class="line">         p-&gt;mempolicy = NULL;</span><br><span class="line">         goto bad_fork_cleanup_cpuset;</span><br><span class="line">     &#125;</span><br><span class="line">    mpol_fix_fork_child_flag(p);</span><br><span class="line">#endif</span><br><span class="line">#ifdef CONFIG_TRACE_IRQFLAGS</span><br><span class="line">    p-&gt;irq_events = 0;</span><br><span class="line">#ifdef __ARCH_WANT_INTERRUPTS_ON_CTXSW</span><br><span class="line">    p-&gt;hardirqs_enabled = 1;</span><br><span class="line">#else</span><br><span class="line">    p-&gt;hardirqs_enabled = 0;</span><br><span class="line">#endif</span><br><span class="line">    p-&gt;hardirq_enable_ip = 0;</span><br><span class="line">    p-&gt;hardirq_enable_event = 0;</span><br><span class="line">    p-&gt;hardirq_disable_ip = _THIS_IP_;</span><br><span class="line">    p-&gt;hardirq_disable_event = 0;</span><br><span class="line">    p-&gt;softirqs_enabled = 1;</span><br><span class="line">    p-&gt;softirq_enable_ip = _THIS_IP_;</span><br><span class="line">    p-&gt;softirq_enable_event = 0;</span><br><span class="line">    p-&gt;softirq_disable_ip = 0;</span><br><span class="line">    p-&gt;softirq_disable_event = 0;</span><br><span class="line">    p-&gt;hardirq_context = 0;</span><br><span class="line">    p-&gt;softirq_context = 0;</span><br><span class="line">#endif</span><br><span class="line">#ifdef CONFIG_LOCKDEP</span><br><span class="line">    p-&gt;lockdep_depth = 0; /* no locks held yet */</span><br><span class="line">    p-&gt;curr_chain_key = 0;</span><br><span class="line">    p-&gt;lockdep_recursion = 0;</span><br><span class="line">#endif</span><br><span class="line"></span><br><span class="line">#ifdef CONFIG_DEBUG_MUTEXES</span><br><span class="line">    p-&gt;blocked_on = NULL; /* not blocked yet */</span><br><span class="line">#endif</span><br><span class="line"></span><br><span class="line">    p-&gt;tgid = p-&gt;pid;</span><br><span class="line">    if (clone_flags &amp; CLONE_THREAD)</span><br><span class="line">        p-&gt;tgid = current-&gt;tgid;</span><br><span class="line"></span><br><span class="line">    if ((retval = security_task_alloc(p)))</span><br><span class="line">        goto bad_fork_cleanup_policy;</span><br><span class="line">    if ((retval = audit_alloc(p)))</span><br><span class="line">        goto bad_fork_cleanup_security;</span><br><span class="line">    /* copy all the process information */</span><br><span class="line">    if ((retval = copy_semundo(clone_flags, p)))</span><br><span class="line">        goto bad_fork_cleanup_audit;</span><br><span class="line">    if ((retval = copy_files(clone_flags, p)))</span><br><span class="line">        goto bad_fork_cleanup_semundo;</span><br><span class="line">    if ((retval = copy_fs(clone_flags, p)))</span><br><span class="line">        goto bad_fork_cleanup_files;</span><br><span class="line">    if ((retval = copy_sighand(clone_flags, p)))</span><br><span class="line">        goto bad_fork_cleanup_fs;</span><br><span class="line">    if ((retval = copy_signal(clone_flags, p)))</span><br><span class="line">        goto bad_fork_cleanup_sighand;</span><br><span class="line">    if ((retval = copy_mm(clone_flags, p)))</span><br><span class="line">        goto bad_fork_cleanup_signal;</span><br><span class="line">    if ((retval = copy_keys(clone_flags, p)))</span><br><span class="line">        goto bad_fork_cleanup_mm;</span><br><span class="line">    if ((retval = copy_namespaces(clone_flags, p)))</span><br><span class="line">        goto bad_fork_cleanup_keys;</span><br><span class="line">    retval = copy_thread(0, clone_flags, stack_start, stack_size, p, regs);</span><br><span class="line">    if (retval)</span><br><span class="line">        goto bad_fork_cleanup_namespaces;</span><br><span class="line"></span><br><span class="line">    p-&gt;set_child_tid = (clone_flags &amp; CLONE_CHILD_SETTID) ? child_tidptr : NULL;</span><br><span class="line">    /*</span><br><span class="line">     * Clear TID on mm_release()?</span><br><span class="line">     */</span><br><span class="line">    p-&gt;clear_child_tid = (clone_flags &amp; CLONE_CHILD_CLEARTID) ? child_tidptr: NULL;</span><br><span class="line">    p-&gt;robust_list = NULL;</span><br><span class="line">#ifdef CONFIG_COMPAT</span><br><span class="line">    p-&gt;compat_robust_list = NULL;</span><br><span class="line">#endif</span><br><span class="line">    INIT_LIST_HEAD(&amp;p-&gt;pi_state_list);</span><br><span class="line">    p-&gt;pi_state_cache = NULL;</span><br><span class="line"></span><br><span class="line">    /*</span><br><span class="line">     * sigaltstack should be cleared when sharing the same VM</span><br><span class="line">     */</span><br><span class="line">    if ((clone_flags &amp; (CLONE_VM|CLONE_VFORK)) == CLONE_VM)</span><br><span class="line">        p-&gt;sas_ss_sp = p-&gt;sas_ss_size = 0;</span><br><span class="line"></span><br><span class="line">    /*</span><br><span class="line">     * Syscall tracing should be turned off in the child regardless</span><br><span class="line">     * of CLONE_PTRACE.</span><br><span class="line">     */</span><br><span class="line">    clear_tsk_thread_flag(p, TIF_SYSCALL_TRACE);</span><br><span class="line">#ifdef TIF_SYSCALL_EMU</span><br><span class="line">    clear_tsk_thread_flag(p, TIF_SYSCALL_EMU);</span><br><span class="line">#endif</span><br><span class="line"></span><br><span class="line">    /* Our parent execution domain becomes current domain</span><br><span class="line">       These must match for thread signalling to apply */</span><br><span class="line">    p-&gt;parent_exec_id = p-&gt;self_exec_id;</span><br><span class="line"></span><br><span class="line">    /* ok, now we should be set up.. */</span><br><span class="line">    p-&gt;exit_signal = (clone_flags &amp; CLONE_THREAD) ? -1 : (clone_flags &amp; CSIGNAL);</span><br><span class="line">    p-&gt;pdeath_signal = 0;</span><br><span class="line">    p-&gt;exit_state = 0;</span><br><span class="line"></span><br><span class="line">    /*</span><br><span class="line">     * Ok, make it visible to the rest of the system.</span><br><span class="line">     * We dont wake it up yet.</span><br><span class="line">     */</span><br><span class="line">    p-&gt;group_leader = p;</span><br><span class="line">    INIT_LIST_HEAD(&amp;p-&gt;thread_group);</span><br><span class="line">    INIT_LIST_HEAD(&amp;p-&gt;ptrace_children);</span><br><span class="line">    INIT_LIST_HEAD(&amp;p-&gt;ptrace_list);</span><br><span class="line"></span><br><span class="line">    /* Perform scheduler related setup. Assign this task to a CPU. */</span><br><span class="line">    sched_fork(p, clone_flags);</span><br><span class="line"></span><br><span class="line">    /* Need tasklist lock for parent etc handling! */</span><br><span class="line">    write_lock_irq(&amp;tasklist_lock);</span><br><span class="line"></span><br><span class="line">    /* for sys_ioprio_set(IOPRIO_WHO_PGRP) */</span><br><span class="line">    p-&gt;ioprio = current-&gt;ioprio;</span><br><span class="line"></span><br><span class="line">    /*</span><br><span class="line">     * The task hasn&#x27;t been attached yet, so its cpus_allowed mask will</span><br><span class="line">     * not be changed, nor will its assigned CPU.</span><br><span class="line">     *</span><br><span class="line">     * The cpus_allowed mask of the parent may have changed after it was</span><br><span class="line">     * copied first time - so re-copy it here, then check the child&#x27;s CPU</span><br><span class="line">     * to ensure it is on a valid CPU (and if not, just force it back to</span><br><span class="line">     * parent&#x27;s CPU). This avoids alot of nasty races.</span><br><span class="line">     */</span><br><span class="line">    p-&gt;cpus_allowed = current-&gt;cpus_allowed;</span><br><span class="line">    if (unlikely(!cpu_isset(task_cpu(p), p-&gt;cpus_allowed) ||</span><br><span class="line">            !cpu_online(task_cpu(p))))</span><br><span class="line">        set_task_cpu(p, smp_processor_id());</span><br><span class="line"></span><br><span class="line">    /* CLONE_PARENT re-uses the old parent */</span><br><span class="line">    if (clone_flags &amp; (CLONE_PARENT|CLONE_THREAD))</span><br><span class="line">        p-&gt;real_parent = current-&gt;real_parent;</span><br><span class="line">    else</span><br><span class="line">        p-&gt;real_parent = current;</span><br><span class="line">    p-&gt;parent = p-&gt;real_parent;</span><br><span class="line"></span><br><span class="line">    spin_lock(&amp;current-&gt;sighand-&gt;siglock);</span><br><span class="line"></span><br><span class="line">    /*</span><br><span class="line">     * Process group and session signals need to be delivered to just the</span><br><span class="line">     * parent before the fork or both the parent and the child after the</span><br><span class="line">     * fork. Restart if a signal comes in before we add the new process to</span><br><span class="line">     * it&#x27;s process group.</span><br><span class="line">     * A fatal signal pending means that current will exit, so the new</span><br><span class="line">     * thread can&#x27;t slip out of an OOM kill (or normal SIGKILL).</span><br><span class="line">      */</span><br><span class="line">     recalc_sigpending();</span><br><span class="line">    if (signal_pending(current)) &#123;</span><br><span class="line">        spin_unlock(&amp;current-&gt;sighand-&gt;siglock);</span><br><span class="line">        write_unlock_irq(&amp;tasklist_lock);</span><br><span class="line">        retval = -ERESTARTNOINTR;</span><br><span class="line">        goto bad_fork_cleanup_namespaces;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    if (clone_flags &amp; CLONE_THREAD) &#123;</span><br><span class="line">        p-&gt;group_leader = current-&gt;group_leader;</span><br><span class="line">        list_add_tail_rcu(&amp;p-&gt;thread_group, &amp;p-&gt;group_leader-&gt;thread_group);</span><br><span class="line"></span><br><span class="line">        if (!cputime_eq(current-&gt;signal-&gt;it_virt_expires,</span><br><span class="line">                cputime_zero) ||</span><br><span class="line">            !cputime_eq(current-&gt;signal-&gt;it_prof_expires,</span><br><span class="line">                cputime_zero) ||</span><br><span class="line">            current-&gt;signal-&gt;rlim[RLIMIT_CPU].rlim_cur != RLIM_INFINITY ||</span><br><span class="line">            !list_empty(&amp;current-&gt;signal-&gt;cpu_timers[0]) ||</span><br><span class="line">            !list_empty(&amp;current-&gt;signal-&gt;cpu_timers[1]) ||</span><br><span class="line">            !list_empty(&amp;current-&gt;signal-&gt;cpu_timers[2])) &#123;</span><br><span class="line">            /*</span><br><span class="line">             * Have child wake up on its first tick to check</span><br><span class="line">             * for process CPU timers.</span><br><span class="line">             */</span><br><span class="line">            p-&gt;it_prof_expires = jiffies_to_cputime(1);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    if (likely(p-&gt;pid)) &#123;</span><br><span class="line">        add_parent(p);</span><br><span class="line">        if (unlikely(p-&gt;ptrace &amp; PT_PTRACED))</span><br><span class="line">            __ptrace_link(p, current-&gt;parent);</span><br><span class="line"></span><br><span class="line">        if (thread_group_leader(p)) &#123;</span><br><span class="line">            p-&gt;signal-&gt;tty = current-&gt;signal-&gt;tty;</span><br><span class="line">            p-&gt;signal-&gt;pgrp = process_group(current);</span><br><span class="line">            set_signal_session(p-&gt;signal, process_session(current));</span><br><span class="line">            attach_pid(p, PIDTYPE_PGID, task_pgrp(current));</span><br><span class="line">            attach_pid(p, PIDTYPE_SID, task_session(current));</span><br><span class="line"></span><br><span class="line">            list_add_tail_rcu(&amp;p-&gt;tasks, &amp;init_task.tasks);</span><br><span class="line">            __get_cpu_var(process_counts)++;</span><br><span class="line">        &#125;</span><br><span class="line">        attach_pid(p, PIDTYPE_PID, pid);</span><br><span class="line">        nr_threads++;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    total_forks++;</span><br><span class="line">    spin_unlock(&amp;current-&gt;sighand-&gt;siglock);</span><br><span class="line">    write_unlock_irq(&amp;tasklist_lock);</span><br><span class="line">    proc_fork_connector(p);</span><br><span class="line">    return p;</span><br><span class="line"></span><br><span class="line">bad_fork_cleanup_namespaces:</span><br><span class="line">    exit_task_namespaces(p);</span><br><span class="line">bad_fork_cleanup_keys:</span><br><span class="line">    exit_keys(p);</span><br><span class="line">bad_fork_cleanup_mm:</span><br><span class="line">    if (p-&gt;mm)</span><br><span class="line">        mmput(p-&gt;mm);</span><br><span class="line">bad_fork_cleanup_signal:</span><br><span class="line">    cleanup_signal(p);</span><br><span class="line">bad_fork_cleanup_sighand:</span><br><span class="line">    __cleanup_sighand(p-&gt;sighand);</span><br><span class="line">bad_fork_cleanup_fs:</span><br><span class="line">    exit_fs(p); /* blocking */</span><br><span class="line">bad_fork_cleanup_files:</span><br><span class="line">    exit_files(p); /* blocking */</span><br><span class="line">bad_fork_cleanup_semundo:</span><br><span class="line">    exit_sem(p);</span><br><span class="line">bad_fork_cleanup_audit:</span><br><span class="line">    audit_free(p);</span><br><span class="line">bad_fork_cleanup_security:</span><br><span class="line">    security_task_free(p);</span><br><span class="line">bad_fork_cleanup_policy:</span><br><span class="line">#ifdef CONFIG_NUMA</span><br><span class="line">    mpol_free(p-&gt;mempolicy);</span><br><span class="line">bad_fork_cleanup_cpuset:</span><br><span class="line">#endif</span><br><span class="line">    cpuset_exit(p);</span><br><span class="line">bad_fork_cleanup_delays_binfmt:</span><br><span class="line">    delayacct_tsk_free(p);</span><br><span class="line">    if (p-&gt;binfmt)</span><br><span class="line">        module_put(p-&gt;binfmt-&gt;module);</span><br><span class="line">bad_fork_cleanup_put_domain:</span><br><span class="line">    module_put(task_thread_info(p)-&gt;exec_domain-&gt;module);</span><br><span class="line">bad_fork_cleanup_count:</span><br><span class="line">    put_group_info(p-&gt;group_info);</span><br><span class="line">    atomic_dec(&amp;p-&gt;user-&gt;processes);</span><br><span class="line">    free_uid(p-&gt;user);</span><br><span class="line">bad_fork_free:</span><br><span class="line">    free_task(p);</span><br><span class="line">fork_out:</span><br><span class="line">    return ERR_PTR(retval);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>dup_task_struct函数，tsk &#x3D; alloc_task_struct();dup_task_struct()函数主要是为子进程创建一个内核栈，主要赋值语句setup_thread_stack(tsk, orig);</p>
<p>在函数中调用alloc_task_struct()进行内存分配，alloc_task_struct()函数获取内存的方式内核里面有几种：</p>
<p>1、# define alloc_task_struct() kmem_cache_alloc(task_struct_cachep, GFP_KERNEL)</p>
<p>2、</p>
<figure class="highlight text"><table><tr><td class="code"><pre><span class="line">struct task_struct *alloc_task_struct(void)</span><br><span class="line">&#123;</span><br><span class="line">    struct task_struct *p = kmalloc(THREAD_SIZE, GFP_KERNEL);</span><br><span class="line">    if (p)</span><br><span class="line">        atomic_set((atomic_t *)(p+1), 1);</span><br><span class="line">    return p;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>3、#define alloc_task_struct() ((struct task_struct *)_ _ get_free_pages(GFP_KERNEL | __GFP_COMP, KERNEL_STACK_SIZE_ORDER))</p>
<p>以上3中申请内存的方式最后一种是最底层的，直接分配页，第二种利用了页高速缓存，相当于是对第3中方式进行了封装，第1种在第2中的方式上进行分配，相当于调用了第2种页高速缓存的API进行内存分配的。</p>
<figure class="highlight text"><table><tr><td class="code"><pre><span class="line">static struct task_struct *dup_task_struct(struct task_struct *orig)</span><br><span class="line">&#123;</span><br><span class="line">    struct task_struct *tsk;</span><br><span class="line">    struct thread_info *ti;</span><br><span class="line"></span><br><span class="line">    prepare_to_copy(orig);</span><br><span class="line"></span><br><span class="line">    tsk = alloc_task_struct();</span><br><span class="line">    if (!tsk)</span><br><span class="line">        return NULL;</span><br><span class="line"></span><br><span class="line">    ti = alloc_thread_info(tsk);</span><br><span class="line">    if (!ti) &#123;</span><br><span class="line">        free_task_struct(tsk);</span><br><span class="line">        return NULL;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    *tsk = *orig;</span><br><span class="line">    tsk-&gt;stack = ti;</span><br><span class="line">    setup_thread_stack(tsk, orig);               //主要赋值语句将父进程的进程的thread_info赋值给子进程</span><br><span class="line"></span><br><span class="line">#ifdef CONFIG_CC_STACKPROTECTOR</span><br><span class="line">    tsk-&gt;stack_canary = get_random_int();</span><br><span class="line">#endif</span><br><span class="line"></span><br><span class="line">    /* One for us, one for whoever does the &quot;release_task()&quot; (usually parent) */</span><br><span class="line">    atomic_set(&amp;tsk-&gt;usage,2);</span><br><span class="line">    atomic_set(&amp;tsk-&gt;fs_excl, 0);</span><br><span class="line">#ifdef CONFIG_BLK_DEV_IO_TRACE</span><br><span class="line">    tsk-&gt;btrace_seq = 0;</span><br><span class="line">#endif</span><br><span class="line">    tsk-&gt;splice_pipe = NULL;</span><br><span class="line">    return tsk;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>现在我们主要分析copy_process函数，此函数中做了非常重要的，体现linux中父子进程创建机制的工作。</p>
<p>1、调用dup_task_struct()为子进程创建一个内核栈、thread_info结构和task_struct，这些值与当前进程的值相同。此时子进程和父进程的描述符是完全相同的。</p>
<p>p &#x3D; dup_task_struct(current)—-&gt;(struct task_struct *tsk———-&gt;tsk &#x3D; alloc_task_struct()从slab层分配了一个关于进程描述符的slab)</p>
<p>2、检查并确保新创建这个子进程后，当前用户所拥有的进程数目没有超出给它分配的资源的限制。</p>
<p>3、子进程着手使自己与父进程区别开来，为进程的task_struct、tss做个性化设置，进程描述符内的许多成员都要被清0或设置为初始值。那些不是继承而来的进程描述符成员，主要是统计信息。task_struct中的大多数数据都依然未被修改。</p>
<p>4、为子进程创建第一个页表，将进程0的页表项内容赋给这个页表。</p>
<p>copy_process()————&gt;copy_fs(),_copy_fs_struct(current-&gt;fs)中current指针表示当前进程也就是父进程的</p>
<p>copy_fs()函数为子进程复制父进程的页目录项</p>
<figure class="highlight text"><table><tr><td class="code"><pre><span class="line">static inline int copy_fs(unsigned long clone_flags, struct task_struct * tsk)</span><br><span class="line">&#123;</span><br><span class="line">    if (clone_flags &amp; CLONE_FS) &#123;</span><br><span class="line">        atomic_inc(&amp;current-&gt;fs-&gt;count);</span><br><span class="line">        return 0;</span><br><span class="line">    &#125;</span><br><span class="line">    tsk-&gt;fs = __copy_fs_struct(current-&gt;fs);</span><br><span class="line">    if (!tsk-&gt;fs)</span><br><span class="line">        return -ENOMEM;</span><br><span class="line">    return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>_copy_fs_struct()</p>
<figure class="highlight text"><table><tr><td class="code"><pre><span class="line">static inline struct fs_struct *__copy_fs_struct(struct fs_struct *old)</span><br><span class="line">&#123;</span><br><span class="line">    struct fs_struct *fs = kmem_cache_alloc(fs_cachep, GFP_KERNEL);</span><br><span class="line">    /* We don&#x27;t need to lock fs - think why ;-) */</span><br><span class="line">    if (fs) &#123;</span><br><span class="line">        atomic_set(&amp;fs-&gt;count, 1);</span><br><span class="line">        rwlock_init(&amp;fs-&gt;lock);</span><br><span class="line">        fs-&gt;umask = old-&gt;umask;</span><br><span class="line">        read_lock(&amp;old-&gt;lock);                         //进行加锁不能被打断</span><br><span class="line">        fs-&gt;rootmnt = mntget(old-&gt;rootmnt);</span><br><span class="line">        fs-&gt;root = dget(old-&gt;root);</span><br><span class="line">        fs-&gt;pwdmnt = mntget(old-&gt;pwdmnt);</span><br><span class="line">        fs-&gt;pwd = dget(old-&gt;pwd);</span><br><span class="line">        if (old-&gt;altroot) &#123;</span><br><span class="line">            fs-&gt;altrootmnt = mntget(old-&gt;altrootmnt);</span><br><span class="line">            fs-&gt;altroot = dget(old-&gt;altroot);</span><br><span class="line">        &#125; else &#123;</span><br><span class="line">            fs-&gt;altrootmnt = NULL;</span><br><span class="line">            fs-&gt;altroot = NULL;</span><br><span class="line">        &#125;</span><br><span class="line">        read_unlock(&amp;old-&gt;lock);</span><br><span class="line">    &#125;</span><br><span class="line">    return fs;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>fs_struct数据结构，这个数据结构将VFS层里面的描述页目录对象的结构体进行了实例化，这样就可以为子进程创建一个页目录项，同时这个fs_strcut结构体和为子进程分配内核栈一样都是通过页高速缓存实现的：struct fs_struct *fs &#x3D; kmem_cache_alloc(fs_cachep, GFP_KERNEL);</p>
<figure class="highlight text"><table><tr><td class="code"><pre><span class="line">struct fs_struct &#123;</span><br><span class="line">    atomic_t count;</span><br><span class="line">    rwlock_t lock;</span><br><span class="line">    int umask;</span><br><span class="line">    struct dentry * root, * pwd, * altroot;                     //struct denty 页目录项结构体</span><br><span class="line">    struct vfsmount * rootmnt, * pwdmnt, * altrootmnt;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>copy_files()函数，为子进程复制父进程的页表，共享父进程的文件</p>
<figure class="highlight text"><table><tr><td class="code"><pre><span class="line">static int copy_files(unsigned long clone_flags, struct task_struct * tsk)</span><br><span class="line">&#123;</span><br><span class="line">    struct files_struct *oldf, *newf;</span><br><span class="line">    int error = 0;</span><br><span class="line"></span><br><span class="line">    /*</span><br><span class="line">     * A background process may not have any files ...</span><br><span class="line">     */</span><br><span class="line">    oldf = current-&gt;files;                         //将父进程的页表</span><br><span class="line">    if (!oldf)</span><br><span class="line">        goto out;</span><br><span class="line"></span><br><span class="line">    if (clone_flags &amp; CLONE_FILES) &#123;</span><br><span class="line">        atomic_inc(&amp;oldf-&gt;count);</span><br><span class="line">        goto out;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    /*</span><br><span class="line">     * Note: we may be using current for both targets (See exec.c)</span><br><span class="line">     * This works because we cache current-&gt;files (old) as oldf. Don&#x27;t</span><br><span class="line">     * break this.</span><br><span class="line">     */</span><br><span class="line">    tsk-&gt;files = NULL;</span><br><span class="line">    newf = dup_fd(oldf, &amp;error);</span><br><span class="line">    if (!newf)</span><br><span class="line">        goto out;</span><br><span class="line"></span><br><span class="line">    tsk-&gt;files = newf;</span><br><span class="line">    error = 0;</span><br><span class="line">out:</span><br><span class="line">    return error;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>dup_fd()　</p>
<figure class="highlight text"><table><tr><td class="code"><pre><span class="line">/*</span><br><span class="line"> * Allocate a new files structure and copy contents from the</span><br><span class="line"> * passed in files structure.</span><br><span class="line"> * errorp will be valid only when the returned files_struct is NULL.</span><br><span class="line"> */</span><br><span class="line"> files_struct</span><br><span class="line">static struct files_struct *dup_fd(struct files_struct *oldf, int *errorp)</span><br><span class="line">&#123;</span><br><span class="line">    struct files_struct *newf;</span><br><span class="line">    struct file **old_fds, **new_fds;</span><br><span class="line">    int open_files, size, i;</span><br><span class="line">    struct fdtable *old_fdt, *new_fdt;</span><br><span class="line"></span><br><span class="line">    *errorp = -ENOMEM;</span><br><span class="line">    newf = alloc_files();</span><br><span class="line">    if (!newf)</span><br><span class="line">        goto out;</span><br><span class="line"></span><br><span class="line">    spin_lock(&amp;oldf-&gt;file_lock);</span><br><span class="line">    old_fdt = files_fdtable(oldf);</span><br><span class="line">    new_fdt = files_fdtable(newf);</span><br><span class="line">    open_files = count_open_files(old_fdt);</span><br><span class="line"></span><br><span class="line">    /*</span><br><span class="line">     * Check whether we need to allocate a larger fd array and fd set.</span><br><span class="line">     * Note: we&#x27;re not a clone task, so the open count won&#x27;t change.</span><br><span class="line">     */</span><br><span class="line">    if (open_files &gt; new_fdt-&gt;max_fds) &#123;</span><br><span class="line">        new_fdt-&gt;max_fds = 0;</span><br><span class="line">        spin_unlock(&amp;oldf-&gt;file_lock);</span><br><span class="line">        spin_lock(&amp;newf-&gt;file_lock);</span><br><span class="line">        *errorp = expand_files(newf, open_files-1);</span><br><span class="line">        spin_unlock(&amp;newf-&gt;file_lock);</span><br><span class="line">        if (*errorp &lt; 0)</span><br><span class="line">            goto out_release;</span><br><span class="line">        new_fdt = files_fdtable(newf);</span><br><span class="line">        /*</span><br><span class="line">         * Reacquire the oldf lock and a pointer to its fd table</span><br><span class="line">         * who knows it may have a new bigger fd table. We need</span><br><span class="line">         * the latest pointer.</span><br><span class="line">         */</span><br><span class="line">        spin_lock(&amp;oldf-&gt;file_lock);</span><br><span class="line">        old_fdt = files_fdtable(oldf);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    old_fds = old_fdt-&gt;fd;</span><br><span class="line">    new_fds = new_fdt-&gt;fd;</span><br><span class="line"></span><br><span class="line">    memcpy(new_fdt-&gt;open_fds-&gt;fds_bits,</span><br><span class="line">        old_fdt-&gt;open_fds-&gt;fds_bits, open_files/8);</span><br><span class="line">    memcpy(new_fdt-&gt;close_on_exec-&gt;fds_bits,</span><br><span class="line">        old_fdt-&gt;close_on_exec-&gt;fds_bits, open_files/8);</span><br><span class="line"></span><br><span class="line">    for (i = open_files; i != 0; i--) &#123;</span><br><span class="line">        struct file *f = *old_fds++;</span><br><span class="line">        if (f) &#123;</span><br><span class="line">            get_file(f);</span><br><span class="line">        &#125; else &#123;</span><br><span class="line">            /*</span><br><span class="line">             * The fd may be claimed in the fd bitmap but not yet</span><br><span class="line">             * instantiated in the files array if a sibling thread</span><br><span class="line">             * is partway through open().  So make sure that this</span><br><span class="line">             * fd is available to the new process.</span><br><span class="line">             */</span><br><span class="line">            FD_CLR(open_files - i, new_fdt-&gt;open_fds);</span><br><span class="line">        &#125;</span><br><span class="line">        rcu_assign_pointer(*new_fds++, f);</span><br><span class="line">    &#125;</span><br><span class="line">    spin_unlock(&amp;oldf-&gt;file_lock);</span><br><span class="line"></span><br><span class="line">    /* compute the remainder to be cleared */</span><br><span class="line">    size = (new_fdt-&gt;max_fds - open_files) * sizeof(struct file *);</span><br><span class="line"></span><br><span class="line">    /* This is long word aligned thus could use a optimized version */</span><br><span class="line">    memset(new_fds, 0, size);</span><br><span class="line"></span><br><span class="line">    if (new_fdt-&gt;max_fds &gt; open_files) &#123;</span><br><span class="line">        int left = (new_fdt-&gt;max_fds-open_files)/8;</span><br><span class="line">        int start = open_files / (8 * sizeof(unsigned long));</span><br><span class="line"></span><br><span class="line">        memset(&amp;new_fdt-&gt;open_fds-&gt;fds_bits[start], 0, left);</span><br><span class="line">        memset(&amp;new_fdt-&gt;close_on_exec-&gt;fds_bits[start], 0, left);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    return newf;</span><br><span class="line"></span><br><span class="line">out_release:</span><br><span class="line">    kmem_cache_free(files_cachep, newf);</span><br><span class="line">out:</span><br><span class="line">    return NULL;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>files_struct结构体，files_struct结构保存了进程打开的所有文件表数据，描述一个正被打开的文件。</p>
<figure class="highlight text"><table><tr><td class="code"><pre><span class="line">struct files_struct &#123;</span><br><span class="line">    atomic_t        count;              //自动增量</span><br><span class="line">    struct fdtable  *fdt;</span><br><span class="line">    struct fdtable  fdtab;</span><br><span class="line">    fd_set      close_on_exec_init;     //执行exec时</span><br><span class="line">需要关闭的文件描述符初值集合</span><br><span class="line">    fd_set      open_fds_init;          //当前打开文件</span><br><span class="line">的文件描述符屏蔽字</span><br><span class="line">    struct file         * fd_array[NR_OPEN_DEFAULT];</span><br><span class="line">    spinlock_t      file_lock;  /* Protects concurrent</span><br><span class="line">writers.  Nests inside tsk-&gt;alloc_lock */</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>alloc_files()函数</p>
<figure class="highlight text"><table><tr><td class="code"><pre><span class="line">static struct files_struct *alloc_files(void)</span><br><span class="line">&#123;</span><br><span class="line">    struct files_struct *newf;</span><br><span class="line">    struct fdtable *fdt;</span><br><span class="line"></span><br><span class="line">    newf = kmem_cache_alloc(files_cachep, GFP_KERNEL);</span><br><span class="line">    if (!newf)</span><br><span class="line">        goto out;</span><br><span class="line"></span><br><span class="line">    atomic_set(&amp;newf-&gt;count, 1);</span><br><span class="line"></span><br><span class="line">    spin_lock_init(&amp;newf-&gt;file_lock);</span><br><span class="line">    newf-&gt;next_fd = 0;</span><br><span class="line">    fdt = &amp;newf-&gt;fdtab;</span><br><span class="line">    fdt-&gt;max_fds = NR_OPEN_DEFAULT;</span><br><span class="line">    fdt-&gt;close_on_exec = (fd_set *)&amp;newf-&gt;close_on_exec_init;</span><br><span class="line">    fdt-&gt;open_fds = (fd_set *)&amp;newf-&gt;open_fds_init;</span><br><span class="line">    fdt-&gt;fd = &amp;newf-&gt;fd_array[0];</span><br><span class="line">    INIT_RCU_HEAD(&amp;fdt-&gt;rcu);</span><br><span class="line">    fdt-&gt;next = NULL;</span><br><span class="line">    rcu_assign_pointer(newf-&gt;fdt, fdt);</span><br><span class="line">out:</span><br><span class="line">    return newf;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>4、子进程的状态被设置为TASK_UNINTERRUPTEIBLE,保证子进程不会投入运行。</p>
<p>前面对于子进程个性化设置没有分析得很清楚，后面自己弄懂了再来补充。</p>
<p>先总结一下fork()的执行流程然后在来解决文章刚开始的问题。</p>
<p>从上面的分析可以看出fork()的流程大概是：</p>
<p>1、p &#x3D; dup_task_struct(current);　为新进程创建一个内核栈、thread_iofo和task_struct,这里完全copy父进程的内容，所以到目前为止，父进程和子进程是没有任何区别的。</p>
<p>2、为新进程在其内存上建立内核堆栈</p>
<p>3、对子进程task_struct任务结构体中部分变量进行初始化设置，检查所有的进程数目是否已经超出了系统规定的最大进程数，如果没有的话，那么就开始设置进程描诉符中的初始值，从这开始，父进程和子进程就开始区别开了。</p>
<p>4、把父进程的有关信息复制给子进程，建立共享关系</p>
<p>5、设置子进程的状态为不可被TASK_UNINTERRUPTIBLE，从而保证这个进程现在不能被投入运行，因为还有很多的标志位、数据等没有被设置</p>
<p>6、复制标志位（falgs成员）以及权限位(PE_SUPERPRIV)和其他的一些标志</p>
<p>7、调用get_pid()给子进程获取一个有效的并且是唯一的进程标识符PID</p>
<p>8、return ret_from_fork;返回一个指向子进程的指针，开始执行</p>
<p>关于文章开始提出的问题，我们可以从前面的分析知道，子进程的产生是从父进程那儿复制的内核栈、页表项以及与父进程共享文件(对于父进程的文件只能读不能写)，所以子进程如果没有执行exac()函数载入自己的可执行代码，他和父进程将共享数据即代码段数据段，这就是为什么fork()一次感觉执行了两次printf()函数，至于为什么不是6次“+”这个和标准I&#x2F;O里面的缓冲有关系，所以后面我用了一个不带缓冲的I&#x2F;O函数进行了测试输出是6次“-”，在子进程复制父进程的内核栈、页表项、页表的时候页把缓存复制到了子进程中，所以多了两次。</p>
<p>可以从下面的图中看明白</p>
<p><img src="https://pic4.zhimg.com/80/v2-8697811d12166c392c829101b9c83ea7_720w.webp" alt="img"></p>
<p>总结</p>
<p>linux创建一个新的进程是从复制父进程内核栈、页表项开始的，在系统内核里首先是将父进程的进程描述符进行拷贝，然后再根据自己的情况修改相应的参数，获取自己的进程号，再开始执行。</p>
<p>后续关于线程</p>
<p>在前面我们讲的是在linux中创建一个进程，其实在其中创建线程也和上面的流程一样，只是我们需要设置标志位让子进程与父进程共享数据。linux实现线程的机制非常独特，从内核的角度讲，linux没有线程这个说法，linux把所有的线程都当做进程来实现。内核没有准备特别的调度算法或者是定义特别的数据结构来表征线程。相反，线程仅仅被视为一个与其它进程共享某些资源的进程。每个线程都拥有唯一隶属于自己的task_struct，所以在内核中看起来像一个普通的进程只是线程和其它进程共享某些资源，如地址空间。</p>
<p>所以linux里面实现线程的方法和windows或者sun solaris等操作系统实现差异非常大。这些操作系统在内核里面专门提供了支持线程的机制。对于linux来说线程只是一种共享资源的手段。</p>
<p>线程创建时和普通的进程类似，只不过在调用clone()的时候需要传递一些参数标志来指明需要共享的资源。如：</p>
<p>CLONE_FILES:父子进程共享打开的文件</p>
<p>CLONE_FS：父子进程共享打开的文件系统信息</p>
<p>。。。。</p>
<p>后续关于进程终结</p>
<p>一般来说进程的析构是自身引起的。它发生在进程调用exit()系统调用时，既可以显示的调用这个系统调用，也可以隐式的从某个函数返回，C语言编译器会在main函数的返回点后面放置调用exit()的代码。当进程接收到它既不能处理也不能忽略的信号或者异常时，它还能被动的终结。调用do_exit()函数完成进程的终结。进程的终结就是一个释放进程占有的资源的过程。</p>
<hr>
<p>版权声明：本文为知乎博主「<a href="https://www.zhihu.com/people/linuxwang-xian-sheng">极致Linux内核</a>」的原创文章，遵循CC 4.0 BY-SA版权协议，转载请附上原文出处链接及本声明。</p>
<p>原文链接：<a href="https://zhuanlan.zhihu.com/p/547943571">https://zhuanlan.zhihu.com/p/547943571</a></p>
]]></content>
      <categories>
        <category>linux-doc</category>
      </categories>
      <tags>
        <tag>Linux</tag>
      </tags>
  </entry>
  <entry>
    <title>Linux内核堆栈浅谈</title>
    <url>/2023/01/15/linux-docs/Linux%E5%86%85%E6%A0%B8%E5%A0%86%E6%A0%88%E6%B5%85%E8%B0%88/</url>
    <content><![CDATA[<p>内核为每个进程分配一个task_struct结构时，实际上分配两个连续的物理页面(8192字节)，如图所示。底部用作task_struct结构(大小约为1K字节)，结构的上面用作内核堆栈(大小约为7K字节)。访问进程自身的task_struct结构，使用宏操作current, 在2.4中定义如下：</p>
<p><img src="https://pic2.zhimg.com/80/v2-175f0020378c22ce70736eb4889c32e5_720w.webp" alt="img"></p>
<p>根据内核的配置，THREAD_SIZE既可以是4K字节(1个页面)也可以是8K字节(2个页面)。thread_info是52个字节长。<br>下图是当设为8KB时候的内核堆栈：Thread_info在这个内存区的开始处，内核堆栈从末端向下增长。进程描述符不是在这个内存区中，而分别通过task与thread_info指针使thread_info与进程描述符互联。所以获得当前进程描述符的current定义如下:</p>
<p><img src="https://pic2.zhimg.com/80/v2-883080a042dcaaba752d1603f81f3ab9_720w.webp" alt="img"></p>
<p>下面是thread_info结构体的定义：</p>
<figure class="highlight text"><table><tr><td class="code"><pre><span class="line">struct thread_info &#123;</span><br><span class="line">        struct task_struct    *task;           /* main task structure */</span><br><span class="line">        struct exec_domain    *exec_domain;    /* execution domain */</span><br><span class="line">        __u32            flags;                /* low level flags */</span><br><span class="line">        __u32            status;               /* thread synchronous flags */</span><br><span class="line">        __u32            cpu;                  /* current CPU */</span><br><span class="line">        int            preempt_count;          /* 0 =&gt; preemptable, &lt;0 =&gt; BUG */</span><br><span class="line">        mm_segment_t            addr_limit;</span><br><span class="line">        struct restart_block     restart_block;</span><br><span class="line">        void __user             *sysenter_return;</span><br><span class="line">    #ifdef CONFIG_X86_32</span><br><span class="line">        unsigned long previous_esp; /* ESP of the previous stack in</span><br><span class="line">                                       case of nested (IRQ) stacks</span><br><span class="line">                                       */</span><br><span class="line">        __u8                supervisor_stack[0];</span><br><span class="line">    #endif</span><br><span class="line">        unsigned int        sig_on_uaccess_error:1;</span><br><span class="line">        unsigned int        uaccess_err:1;    /* uaccess failed */</span><br><span class="line">    &#125;;</span><br></pre></td></tr></table></figure>

<p>可以看到在thread_info中个task_struct结构体，里面包含的是进程描述符，其他的参数如下：（可以略过）</p>
<p>(1) unsigned short used_math;</p>
<p>是否使用FPU。</p>
<p>(2) char comm[16];</p>
<p>进程正在运行的可执行文件的文件名。</p>
<p>(3) struct rlimit rlim[RLIM_NLIMITS];</p>
<p>结 构rlimit用于资源管理，定义在linux&#x2F;include&#x2F;linux&#x2F;resource.h中，成员共有两项:rlim_cur是资源的当前最大 数目;rlim_max是资源可有的最大数目。在i386环境中，受控资源共有RLIM_NLIMITS项，即10项，定义在 linux&#x2F;include&#x2F;asm&#x2F;resource.h中，见下表:</p>
<p>(4) int errno;</p>
<p>最后一次出错的系统调用的错误号，0表示无错误。系统调用返回时，全程量也拥有该错误号。</p>
<p>(5) long debugreg[8];</p>
<p>保存INTEL CPU调试寄存器的值，在ptrace系统调用中使用。</p>
<p>(6) struct exec_domain *exec_domain;</p>
<p>Linux可以运行由80386平台其它UNIX操作系统生成的符合iBCS2标准的程序。关于此类程序与Linux程序差异的消息就由 exec_domain结构保存。</p>
<p>(7) unsigned long personality;</p>
<p>Linux 可以运行由80386平台其它UNIX操作系统生成的符合iBCS2标准的程序。 Personality进一步描述进程执行的程序属于何种UNIX平台的“个性”信息。通常有PER_Linux、PER_Linux_32BIT、 PER_Linux_EM86、PER_SVR3、PER_SCOSVR3、PER_WYSEV386、PER_ISCR4、PER_BSD、 PER_XENIX和PER_MASK等，参见include&#x2F;linux&#x2F;personality.h。</p>
<p>(8) struct linux_binfmt *binfmt;</p>
<p>指向进程所属的全局执行文件格式结构，共有a。out、script、elf和java等四种。结构定义在include&#x2F;linux &#x2F;binfmts.h中(core_dump、load_shlib(fd)、load_binary、use_count)。</p>
<p>(9) int exit_code，exit_signal;</p>
<p>引起进程退出的返回代码exit_code，引起错误的信号名exit_signal。</p>
<p>(10) int dumpable:1;</p>
<p>布尔量，表示出错时是否可以进行memory dump。</p>
<p>(11) int did_exec:1;</p>
<p>按POSIX要求设计的布尔量，区分进程是正在执行老程序代码，还是在执行execve装入的新代码。</p>
<p>(12) int tty_old_pgrp;</p>
<p>进程显示终端所在的组标识。</p>
<p>(13) struct tty_struct *tty;</p>
<p>指向进程所在的显示终端的信息。如果进程不需要显示终端，如0号进程，则该指针为空。结构定义在include&#x2F;linux&#x2F;tty.h中。</p>
<p>(14) struct wait_queue *wait_chldexit;</p>
<p>在进程结束时，或发出系统调用wait4后，为了等待子进程的结束，而将自己(父进程)睡眠在该队列上。结构定义在include&#x2F;linux &#x2F;wait.h中。</p>
<p><strong>13. 进程队列的全局变量</strong></p>
<p>(1) current;</p>
<p>当前正在运行的进程的指针，在SMP中则指向CPU组中正被调度的CPU的当前进程:</p>
<p>#define current(0+current_set[smp_processor_id()])&#x2F;<em>sched.h</em>&#x2F;</p>
<p>struct task_struct *current_set[NR_CPUS];</p>
<p>(2) struct task_struct init_task;</p>
<p>即0号进程的PCB，是进程的“根”，始终保持初值INIT_TASK。</p>
<p>(3) struct task_struct *task[NR_TASKS];</p>
<p>进程队列数组，规定系统可同时运行的最大进程数(见kernel&#x2F;sched.c)。NR_TASKS定义在include&#x2F;linux&#x2F;tasks.h 中，值为512。每个进程占一个数组元素(元素的下标不一定就是进程的pid)，task[0]必须指向init_task(0号进程)。可以通过 task[]数组遍历所有进程的PCB。但Linux也提供一个宏定义for_each_task()(见 include&#x2F;linux&#x2F;sched.h)，它通过next_task遍历所有进程的PCB:</p>
<p>#define for_each_task(p) \</p>
<p>for(p&#x3D;&amp;init_task;(p&#x3D;p-&gt;next_task)!&#x3D;&amp;init_task;)</p>
<p>(4) unsigned long volatile jiffies;</p>
<p>Linux的基准时间(见kernal&#x2F;sched.c)。系统初始化时清0，以后每隔10ms由时钟中断服务程序do_timer()增1。</p>
<p>(5) int need_resched;</p>
<p>重新调度标志位(见kernal&#x2F;sched.c)。当需要Linux调度时置位。在系统调用返回前(或者其它情形下)，判断该标志是否置位。置位的话，马上调用schedule进行CPU调度。</p>
<p>(6) unsigned long intr_count;</p>
<p>记 录中断服务程序的嵌套层数(见kernal&#x2F;softirq.c)。正常运行时，intr_count为0。当处理硬件中断、执行任务队列中的任务或者执 行bottom half队列中的任务时，intr_count非0。这时，内核禁止某些操作，例如不允许重新调度。</p>
<p>接下来写一个模块，打印当前的进程名字：</p>
<figure class="highlight text"><table><tr><td class="code"><pre><span class="line">#include &lt;linux/init.h&gt;</span><br><span class="line">#include &lt;linux/thread_info.h&gt;</span><br><span class="line">#include &lt;linux/module.h&gt;</span><br><span class="line">#include &lt;linux/sched.h&gt;</span><br><span class="line"></span><br><span class="line">MODULE_LICENSE(&quot;GPL&quot;);</span><br><span class="line">MODULE_AUTHOR(&quot;binary_tree&quot;);</span><br><span class="line"></span><br><span class="line">int test_init()</span><br><span class="line">&#123;</span><br><span class="line">    printk(&quot;hello binary_tree!\n&quot;);</span><br><span class="line"></span><br><span class="line">    int i=0;</span><br><span class="line">    struct thread_info *  info;</span><br><span class="line">    struct task_struct *  t;</span><br><span class="line"></span><br><span class="line">    unsigned long addr =(unsigned long)&amp;i;//</span><br><span class="line">    unsigned long base = addr &amp; ~ 0x1fff;//屏蔽低13位  8K</span><br><span class="line">    info = (struct thread_info *)base;//</span><br><span class="line">    t=  info -&gt; task;</span><br><span class="line">    printk(&quot;it is name is %s\n&quot;,t-&gt; comm);//打印出进程名字</span><br><span class="line">    return 0;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">void test_exit()</span><br><span class="line">&#123;</span><br><span class="line">    printk(&quot;bye! bye ! binary_tree! \n&quot;);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">module_init(test_init);</span><br><span class="line">module_exit(test_exit);</span><br></pre></td></tr></table></figure>

<p>在栈中，struct_task的存在方式如下：</p>
<p><img src="https://pic3.zhimg.com/80/v2-9383324bde77195778798d571aac74a2_720w.webp" alt="img"></p>
<p>可以看到在struct_task中有一个staks的结构体，就是一个循环双向链表，因此，我们可以模拟出一个PS命令：</p>
<p>（今天布置的习题）</p>
<figure class="highlight text"><table><tr><td class="code"><pre><span class="line">#include &lt;linux/init.h&gt;</span><br><span class="line">#include &lt;linux/thread_info.h&gt;</span><br><span class="line">#include &lt;linux/module.h&gt;</span><br><span class="line">#include &lt;linux/sched.h&gt;</span><br><span class="line"></span><br><span class="line">MODULE_LICENSE(&quot;GPL&quot;);</span><br><span class="line">MODULE_AUTHOR(&quot;bunfly&quot;);</span><br><span class="line"></span><br><span class="line">int test_init()</span><br><span class="line">&#123;</span><br><span class="line">    int i = 0;</span><br><span class="line">    struct task_struct *t;</span><br><span class="line">    struct thread_info *info;</span><br><span class="line"></span><br><span class="line">    unsigned long addr = (unsigned long)&amp;i;</span><br><span class="line">    unsigned long base = addr &amp; ~0x1fff;</span><br><span class="line">    info = (struct thread_info *)base;</span><br><span class="line">    t = info-&gt;task;</span><br><span class="line"></span><br><span class="line">    struct task_struct* flag  = t;</span><br><span class="line">    struct task_struct *next = container_of(t-&gt;tasks.next, struct task_struct, tasks);</span><br><span class="line">                                            //首地址    子类的类型， 父类</span><br><span class="line">    //获得t下一个进程符next;</span><br><span class="line">    printk(&quot;now comm is %s\n&quot;,t-&gt;comm);</span><br><span class="line"></span><br><span class="line">    struct task_struct *nnext = container_of(next-&gt;tasks.next, struct task_struct, tasks);</span><br><span class="line">    //获得next下一个进程nnext</span><br><span class="line">    while(nnext  != flag)</span><br><span class="line">    &#123;</span><br><span class="line">        next=nnext;</span><br><span class="line">        nnext=container_of(next-&gt;tasks.next, struct task_struct, tasks);</span><br><span class="line">        printk(&quot;next comm is %s\n&quot;,next-&gt;comm);</span><br><span class="line">    &#125;</span><br><span class="line">    //依次循环打印下一个进程</span><br><span class="line">    printk(&quot;nnext comm is %s\n&quot;,nnext-&gt;comm);</span><br><span class="line">    return 0;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">void test_exit()</span><br><span class="line">&#123;</span><br><span class="line">    printk(&quot;exit\n&quot;);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">module_init(test_init);</span><br><span class="line">module_exit(test_exit);</span><br></pre></td></tr></table></figure>

<p>在代码中，用到一个函数：container_of(ptr,type,mem),其中三个参数可分别描述为：ptr, type,mem,分别代表：</p>
<p><strong>ptr</strong>:父类在子类对象中的首地址;</p>
<p><strong>type</strong>:子类的类型：</p>
<p><strong>mem</strong>:父类的实体（成员）:</p>
<p><img src="https://pic4.zhimg.com/80/v2-9c3883b480a5eac7f33fa7a91a36feeb_720w.webp" alt="img"></p>
<p>其具体的功能就是求下面是对container_of函数的具体实现：（重点讲解的）</p>
<figure class="highlight text"><table><tr><td class="code"><pre><span class="line">1 #include&lt;stdio.h&gt;</span><br><span class="line">  2 </span><br><span class="line">  3 #define container_of(ptr,type,mem) (type*)((unsigned long )(ptr)-(unsigned long)(&amp;((type*)0)-&gt;mem));</span><br><span class="line">  4 struct person</span><br><span class="line">  5 &#123;   </span><br><span class="line">  6     int age;</span><br><span class="line">  7     struct person* next;</span><br><span class="line">  8 &#125;;</span><br><span class="line">  9 </span><br><span class="line"> 10 struct man</span><br><span class="line"> 11 &#123;   </span><br><span class="line"> 12     int len;</span><br><span class="line"> 13     int size;</span><br><span class="line"> 14     char name;</span><br><span class="line"> 15     struct person p;</span><br><span class="line"> 16 &#125;;</span><br><span class="line"> 17 </span><br><span class="line"> 18 int main()</span><br><span class="line"> 19 &#123;   </span><br><span class="line"> 20     struct man haha;</span><br><span class="line"> 21     </span><br><span class="line"> 22     haha.len=100;</span><br><span class="line"> 23     haha.p.age=20;</span><br><span class="line"> 24     struct man* head = &amp;haha.p;//已知父类在子类中的首地址　　　　//3</span><br><span class="line"> 25 //  struct man* tmp=malloc(1);</span><br><span class="line"> 26 //  int size = (unsigned long)(&amp;tmp-&gt;p)-(unsigned long)(tmp);</span><br><span class="line"> 27 　　　　//2</span><br><span class="line"> 28 //  struct man* tmp=0;</span><br><span class="line"> 29 //  int size = (unsigned long)(&amp;tmp-&gt;p);</span><br><span class="line"> 30 //  struct man* m=(struct man*)( (unsigned long )(head)-size );</span><br><span class="line"> 31     　　　　　//1</span><br><span class="line"> 32     //struct man* tmp=0;</span><br><span class="line"> 33     //int size = (unsigned long)(&amp;tmp-&gt;p);</span><br><span class="line"> 34     //struct man* m=(struct man*)( (unsigned long )(head)-size );</span><br><span class="line"> 35    </span><br><span class="line"> 36    // struct man* m=(struct man*)((unsigned long )(head)-(unsigned long)(&amp;((struct man*)0)-&gt;p));</span><br><span class="line"> 37     struct man* m = container_of(head,struct man,p);</span><br><span class="line"> 38 </span><br><span class="line"> 39 //  printf(&quot;head addr is  %p\n&quot;,&amp;head);</span><br><span class="line"> 40 //  printf(&quot;m addr is  %p\n&quot;,&amp;m);</span><br><span class="line"> 41 //  printf(&quot;head of len is %d\n&quot;,head-&gt;len);</span><br><span class="line"> 42 //  printf(&quot;head of age is %d\n&quot;,(head-&gt;p.age)  );</span><br><span class="line"> 43     </span><br><span class="line"> 44     printf(&quot;m of len is %d\n&quot;,m-&gt;len);</span><br><span class="line"> 45     printf(&quot;m of age is %d\n&quot;,m-&gt;p.age);</span><br><span class="line"> 46 </span><br><span class="line"> 47 &#125;</span><br><span class="line">~</span><br></pre></td></tr></table></figure>

<hr>
<p>版权声明：本文为知乎博主「<a href="https://www.zhihu.com/people/linuxwang-xian-sheng">极致Linux内核</a>」的原创文章，遵循CC 4.0 BY-SA版权协议，转载请附上原文出处链接及本声明。</p>
<p>原文链接：<a href="https://zhuanlan.zhihu.com/p/549156208">https://zhuanlan.zhihu.com/p/549156208</a></p>
]]></content>
      <categories>
        <category>linux-doc</category>
      </categories>
      <tags>
        <tag>Linux</tag>
      </tags>
  </entry>
  <entry>
    <title>Linux内核操作系统原理与概述(流程图)</title>
    <url>/2023/01/15/linux-docs/Linux%E5%86%85%E6%A0%B8%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E5%8E%9F%E7%90%86%E4%B8%8E%E6%A6%82%E8%BF%B0(%E6%B5%81%E7%A8%8B%E5%9B%BE)/</url>
    <content><![CDATA[<h2 id="1、操作系统是什么"><a href="#1、操作系统是什么" class="headerlink" title="1、操作系统是什么"></a>1、操作系统是什么</h2><p>操作系统(Operating System,OS)是控制应用程序执行和充当硬件系统和应用程序之间的界面的软件。</p>
<p>计算机系统由硬件和软件两部分组成。操作系统(OS，Operating System)是配置在计算机硬件上的第一层软件，是对硬件系统的首次扩充。它在计算机系统中占据了特别重要的地位；</p>
<p>而其它的诸如汇编程序、编译程序、数据库管理系统等系统软件，以及大量的应用软件，都将依赖于操作系统的支持，取得它的服务。操作系统已成为现代计算机系统(大、中、小及微型机)、多处理机系统、计算机网络、多媒体系统以及嵌入式系统中都必须配置的、最重要的系统软件。</p>
<p><img src="https://pic2.zhimg.com/80/v2-904b5e9cc059f3714d300994e97b6fc1_720w.webp" alt="img"></p>
<h3 id="1-1初步认识操作系统及其功能"><a href="#1-1初步认识操作系统及其功能" class="headerlink" title="1.1初步认识操作系统及其功能"></a>1.1初步认识操作系统及其功能</h3><p>当前比较流行的操作系统有：</p>
<p><img src="https://pic1.zhimg.com/80/v2-dbbe320d3dbe10cccdceea743e7181dc_720w.webp" alt="img"></p>
<p>操作系统具体能做什么？毫无疑问，我们都知道的有 运行程序、控制多个程序并发运行、管理系统资源、监控系统状态、 提供图形化交互界面、 存储文件，读取文件</p>
<p><strong>进程管理</strong></p>
<ol>
<li>进程控制：创建、暂停、唤醒、撤销等；</li>
<li>进程调度：调度策略、优先级；</li>
<li>进程通信：进程之间怎么通信。</li>
</ol>
<p><strong>设备管理</strong></p>
<ol>
<li>设备的分配和调度；</li>
<li>设备的无关性动作；</li>
<li>设备的传输控制；</li>
<li>设备的驱动管理</li>
</ol>
<p><strong>内存管理</strong></p>
<ol>
<li>内存分配；</li>
<li>内存共享；</li>
<li>内存保护；</li>
<li>虚拟内存——我们运行程序从来因为内存过小而失败，只会变慢、卡。</li>
</ol>
<p><strong>文件管理</strong></p>
<ol>
<li>存储的空间管理；</li>
<li>文件的操作；</li>
<li>目录的操作；</li>
<li>文件和目录的存取权限管理等</li>
</ol>
<h3 id="1-2操作系统的地位"><a href="#1-2操作系统的地位" class="headerlink" title="1.2操作系统的地位"></a>1.2操作系统的地位</h3><p><img src="https://pic4.zhimg.com/80/v2-f5da7232a0e1e9f1acfe8981658ec75b_720w.webp" alt="img"></p>
<h2 id="2，为什么需要操作系统"><a href="#2，为什么需要操作系统" class="headerlink" title="2，为什么需要操作系统"></a>2，为什么需要操作系统</h2><p><strong>一般地说，在计算机硬件上配置的 OS，其目标有以下几点：</strong></p>
<p><strong>1．有效性</strong></p>
<p>在早期(20 世纪 50～60 年代)，由于计算机系统非常昂贵，操作系统最重要的目标无疑是有效性。事实上，那时有效性是推动操作系统发展最主要的动力。操作系统的有效性可包含如下两方面的含义：</p>
<ul>
<li>(1) 提高系统资源利用率。在未配置 OS 的计算机系统中，诸如 CPU、I&#x2F;O 设备等各种资源，都会因它们经常处于空闲状态而得不到充分利用；内存及外存中所存放的数据太少或者无序而浪费了大量的存储空间。配置了 OS 之后，可使 CPU 和 I&#x2F;O 设备由于能保持稳定的状态而得到有效的利用，且可使内存和外存中存放的数据因有序而节省了存储空间。</li>
<li>(2) 提高系统的吞吐量。操作系统还可以通过合理地组织计算机的工作流程，而进一步改善资源的利用率，加速程序的运行，缩短程序的运行周期，从而提高系统的吞吐量。</li>
</ul>
<p><strong>2．方便性</strong></p>
<p>配置 OS 后者可使计算机系统更容易使用。一个未配置 OS 计算机系统是极难使用的，因为计算机硬件只能识别 0 和 1 这样的机器代码。用户要直接在计算机硬件上运行自己所编写的程序，就必须用机器语言书写程序；如果我们在计算机硬件上配置了 OS，用户便可通过 OS 所提供的各种命令来使用计算机系统。比如，用编译命令可方便地把用户用高级语言书写的程序翻译成机器代码，大大地方便了用户，从而使计算机变得易学易用。方便性和有效性是设计操作系统时最重要的两个目标。</p>
<p><strong>3．可扩充性</strong></p>
<p>随着 VLSI 技术和计算机技术的迅速发展，计算机硬件和体系结构也随之得到迅速发展，相应地，它们也对 OS 提出了更高的功能和性能要求。此外，多处理机系统、计算机网络，特别是 Internet 的发展，又对 OS 提出了一系列更新的要求。因此，OS 必须具有很好的可扩充性，方能适应计算机硬件、体系结构以及应用发展的要求。这就是说，现代 OS 应采用新的 OS 结构，如微内核结构和客户服务器模式，以便于方便地增加新的功能和模块，并能修改老的功能和模块。</p>
<p><strong>4．开放性</strong></p>
<p>自 20 世纪 80 年代以来，由于计算机网络的迅速发展，特别是 Internet 的应用的日益普及，使计算机操作系统的应用环境已由单机封闭环境转向开放的网络环境。为使来自不同厂家的计算机和设备能通过网络加以集成化，并能正确、有效地协同工作，实现应用的可移植性和互操作性，要求操作系统必须提供统一的开放环境，进而要求 OS 具有开放性。开放性是指系统能遵循世界标准规范，特别是遵循开放系统互连(OSI)国际标准。凡遵循国际标准所开发的硬件和软件，均能彼此兼容，可方便地实现互连。开放性已成为20世纪 90 年代以后计算机技术的一个核心问题，也是一个新推出的系统或软件能否被广泛应用的至关重要的因素。</p>
<p><img src="https://pic2.zhimg.com/80/v2-4d8a72d49d1a435bb8677a97439c57b9_720w.webp" alt="img"></p>
<p><strong>硬件发展时代划分：</strong></p>
<p><img src="https://pic2.zhimg.com/80/v2-46801c46bb57667a2fcf25110cf93065_720w.webp" alt="img"></p>
<h2 id="3，操作系统的发展史"><a href="#3，操作系统的发展史" class="headerlink" title="3，操作系统的发展史"></a>3，操作系统的发展史</h2><h3 id="3-1手工操作时代"><a href="#3-1手工操作时代" class="headerlink" title="3.1手工操作时代"></a>3.1手工操作时代</h3><p><img src="https://pic3.zhimg.com/80/v2-8e41e7bd7b0b911ad9c9c51acd2f56d2_720w.webp" alt="img"></p>
<h3 id="3-2-单批道处理系统"><a href="#3-2-单批道处理系统" class="headerlink" title="3.2 单批道处理系统"></a>3.2 单批道处理系统</h3><p><img src="https://pic4.zhimg.com/80/v2-82e96c3eb230d87b6c68cc1ea29e62cb_720w.webp" alt="img"></p>
<p><img src="https://pic2.zhimg.com/80/v2-c0c87c6347078de0900a970c0a43981d_720w.webp" alt="img"></p>
<p><img src="https://pic4.zhimg.com/80/v2-73191177a46ee6c9e24002f6302b13a3_720w.webp" alt="img"></p>
<h3 id="3-3-多批道处理系统"><a href="#3-3-多批道处理系统" class="headerlink" title="3.3 多批道处理系统"></a>3.3 多批道处理系统</h3><p><img src="https://pic1.zhimg.com/80/v2-7c1136b0f979f9832efc4cdea68a9cb8_720w.webp" alt="img"></p>
<p><img src="https://pic1.zhimg.com/80/v2-839e3842654fb16a4e79b0bccfe01390_720w.webp" alt="img"></p>
<p><img src="https://pic2.zhimg.com/80/v2-2cf31bf5d8473ae00b8916b24775a079_720w.webp" alt="img"></p>
<h3 id="3-4分时技术和分时操作系统"><a href="#3-4分时技术和分时操作系统" class="headerlink" title="3.4分时技术和分时操作系统"></a>3.4分时技术和分时操作系统</h3><p><img src="https://pic1.zhimg.com/80/v2-bf4f7a5bb6606ddc40e27e3dfbc70394_720w.webp" alt="img"></p>
<p><img src="https://pic3.zhimg.com/80/v2-18f7ee444a86e6f0288a63b09afebb8e_720w.webp" alt="img"></p>
<p><strong>分时系统实例</strong></p>
<p><img src="https://pic1.zhimg.com/80/v2-b14c53169718e8fc58a014a135bb9124_720w.webp" alt="img"></p>
<p><img src="https://pic2.zhimg.com/80/v2-caf4f9ce55ad6b88551db6aa05708edd_720w.webp" alt="img"></p>
<h2 id="4，典型的操作系统"><a href="#4，典型的操作系统" class="headerlink" title="4，典型的操作系统"></a>4，典型的操作系统</h2><p><img src="https://pic2.zhimg.com/80/v2-4065584a1d738add3aaf0a4a01482405_720w.webp" alt="img"></p>
<h3 id="4-1微机操作系统"><a href="#4-1微机操作系统" class="headerlink" title="4.1微机操作系统"></a>4.1微机操作系统</h3><p><img src="https://pic4.zhimg.com/80/v2-990f1540e5ce58832062a03db54840e3_720w.webp" alt="img"></p>
<h3 id="4-2实时操作系统"><a href="#4-2实时操作系统" class="headerlink" title="4.2实时操作系统"></a>4.2实时操作系统</h3><p><img src="https://pic4.zhimg.com/80/v2-bdd85e6c91a8c87d9d8529be4a15b323_720w.webp" alt="img"></p>
<p>所谓“实时”，是表示“及时”，而实时系统(Real Time System)是指系统能及时(或即时)响应外部事件的请求，在规定的时间内完成对该事件的处理，并控制所有实时任务协调一致地运行。</p>
<p><strong>1、需求：</strong></p>
<p>虽然多道批处理系统和分时系统已能获得较为令人满意的资源利用率和响应时间，从而使计算机的应用范围日益扩大，但它们仍然不能满足以下某些应用领域的需要。</p>
<ul>
<li>(1) 实时控制。当把计算机用于生产过程的控制，以形成以计算机为中心的控制系统时，系统要求能实时采集现场数据，并对所采集的数据进行及时处理，进而自动地控制相应的执行机构，使某些(个)参数(如温度、压力、方位等)能按预定的规律变化，以保证产品的质量量和提高产量。类似地，也可将计算机用于对武器的控制，如火炮的自动控制系统、飞机自动驾驶系统，以及导弹的制导系统等。此外，随着大规模集成电路的发展，已制作出各种类型的芯片，并可将这些芯片嵌入到各种仪器和设备中，用来对设备的工作进行实施控制，这就构成了所谓的智能仪器和设备。在这些设备中也需要配置某种类型的、能进行实时控制的系统。通常把用于进行实时控制的系统称为实时系统。</li>
<li>(2) 实时信息处理。通常，人们把用于对信息进行实时处理的系统称为实时信息处理系统统。该系统由一台或多台主机通过通信线路连接到成百上千个远程终端上，计算机接收从远程终端上发来的服务请求，根据用户提出的请求对信息进行检索和处理，并在很短的时间内为用户做出正确的响应。典型的实时信息处理系统有早期的飞机或火车的订票系统、情报检索系统等。</li>
</ul>
<p><strong>2、实时任务</strong></p>
<p>在实时系统中必然存在着若干个实时任务，这些任务通常与某个(些)外部设备相关，能反应或控制相应的外部设备，因而带有某种程度的紧迫性。可以从不同的角度对实时任务加以分类。</p>
<p><strong>按任务执行时是否呈现周期性来划分</strong></p>
<p>(1) 周期性实时任务。外部设备周期性地发出激励信号给计算机，要求它按指定周期循环执行，以便周期性地控制某外部设备。</p>
<p>(2) 非周期性实时任务。外部设备所发出的激励信号并无明显的周期性，但都必须联系着一个截止时间(Deadline)。它又可分为开始截止时间(某任务在某时间以前必须开始执行)和完成截止时间(某任务在某时间以前必须完成)两部分。</p>
<p><strong>根据对截止时间的要求来划分</strong></p>
<p>(1) 硬实时任务(Hard real-time Task)。系统必须满足任务对截止时间的要求，否则可能出现难以预测的结果。</p>
<p>(2) 软实时任务(Soft real-time Task)。它也联系着一个截止时间，但并不严格，若偶尔错过了任务的截止时间，对系统产生的影响也不会太大。</p>
<p><strong>3、实时系统与分时系统特征的比较</strong></p>
<p>实时系统有着与分时系统相似但并不完全相同的特点，下面从五个方面对这两种系统</p>
<p>加以比较。</p>
<p>(1) 多路性。实时信息处理系统也按分时原则为多个终端用户服务。实时控制系统得多路性则主要表现在系统周期性地对多路现场信息进行采集，以及对多个对象或多个执行机构进行控制。而分时系统中的多路性则与用户情况有关，时多时少。</p>
<p>(2) 独立性。实时信息处理系统中的每个终端用户在向实时系统提出服务请求时，是彼此独立地操作，互不干扰；而实时控制系统中，对信息的采集和对对象的控制也都是彼此互不干扰。</p>
<p>(3) 及时性。实时信息处理系统对实时性的要求与分时系统类似，都是所有人所能接受的等待时间来确定的；而实时控制系统的及时性，则是以控制对象所要求的开始截止时间为准完成截止时间来确定的，一般为秒级到毫秒级，甚至有的要低于 100 微秒。</p>
<p>(4) 交互性。实时信息处理系统虽然也具有交互性，但这里人与系统的交互仅限于访问系统中某些特定的专用服务程序。它不像分时系统那样能向终端用户提供数据处理和资源共享等服务。</p>
<p>(5) 可靠性。分时系统虽然也要求系统可靠，但相比之下，实时系统则要求系统更高度的可靠性。因为任何差错都可能带来巨大的经济损失，甚至是无法预料的灾难性后果，所以在实时系统中，往往都采取了多级容错措施来保障系统的安全性及数据的安全性。</p>
<p><img src="https://pic2.zhimg.com/80/v2-47dedbe57295615e4388668ab7f858c5_720w.webp" alt="img"></p>
<h3 id="4-3嵌入式系统"><a href="#4-3嵌入式系统" class="headerlink" title="4.3嵌入式系统"></a>4.3嵌入式系统</h3><p><img src="https://pic4.zhimg.com/80/v2-0b69ad1a8d35e89582acd7586b4592ab_720w.webp" alt="img"></p>
<h3 id="4-4网络系统"><a href="#4-4网络系统" class="headerlink" title="4.4网络系统"></a>4.4网络系统</h3><p><img src="https://pic1.zhimg.com/80/v2-694ec1835e88a2acb8ca6f9657662250_720w.webp" alt="img"></p>
<h2 id="5，操作系统的功能"><a href="#5，操作系统的功能" class="headerlink" title="5，操作系统的功能"></a>5，操作系统的功能</h2><p><strong>4.1、OS 作为用户与计算机硬件系统之间的接口</strong></p>
<p>OS 作为用户与计算机硬件系统之间接口的含义是：OS 处于用户与计算机硬件系统之间间，用户通过 OS 来使用计算机系统。或者说，用户在 OS 帮助下，能够方便、快捷、安全、可靠地操纵计算机硬件和运行自己的程序。应注意，OS 是一个系统软件，因而这种接口是软件接口。图 1-1 是 OS 作为接口的示意图。由图可看出，用户可通过以下三种方式使用计算机。</p>
<p>1、命令方式。这是指由 OS 提供了一组联机命令接口，以允许用户通过键盘输入有关命令来取得操作系统的服务，并控制用户程序的运行。</p>
<p>2、系统调用方式。OS提供了一组系统调用，用户可在自己的应用程序中通过相应的系统调用，来实现与操作系统的通信，并取得它的服务。</p>
<p>3、 图形、窗口等方式。这是当前使用最为方便、最为广泛的接口，它允许用户通过屏幕上的窗口和图标来实现与操作系统的通信，并取得它的服务。</p>
<p><img src="https://pic3.zhimg.com/80/v2-0038552a78db1f28d50096024e0ee736_720w.webp" alt="img"></p>
<p><strong>4.2、OS 作为计算机系统资源的管理者</strong></p>
<p>在一个计算机系统中，通常都含有各种各样的硬件和软件资源。归纳起来可将资源分为四类：处理器、存储器、I&#x2F;O 设备以及信息(数据和程序)。相应地，OS 的主要功能也正是针对这四类资源进行有效的管理，即：</p>
<ol>
<li>处理机管理，用于分配和控制处理机；</li>
<li>存储器管理，主要负责内存的分配与回收；</li>
<li>I&#x2F;O 设备管理，负责 I&#x2F;O 设备的分配与操纵；</li>
<li>文件管理，负责文件的存取、共享和保护。</li>
</ol>
<p>可见，OS 的确是计算机系统资源的管理者。事实上，当今世界上广为流行的一个关于 OS 作用的观点，正是把 OS 作为计算机系统的资源管理者。值得进一步说明的是，当一个计算机系统同时供多个用户使用时，用户对系统中共享资源的需求(包括数量和时间)可能发生冲突，为了管理好这些共享资源(包括硬件和信息)的使用，操作系统必须记录下各种资源的使用情况，对使用资源的请求进行授权，协调诸用户对共享资源的使用，避免发生冲突，并计算使用资源的费用等</p>
<p><strong>4.3、OS 实现了对计算机资源的抽象</strong></p>
<p>对于一个完全无软件的计算机系统(即裸机)，它向用户提供的是实际硬件接口(物理接口)，用户必须对物理接口的实现细节有充分的了解，并利用机器指令进行编程，因此该物理机器必定是难以使用的。为了方便用户使用 I&#x2F;O 设备，人们在裸机上覆盖上一层 I&#x2F;O 设备管理软件，如图 1-2 所示，由它来实现对 I&#x2F;O 设备操作的细节，并向上提供一组 I&#x2F;O 操作命令，如 Read 和 Write 命令，用户可利用它来进行数据输入或输出，而无需关心 I&#x2F;O 是如何实现的。</p>
<p><img src="https://pic1.zhimg.com/80/v2-8a60506370228cb3202ffcfc737be368_720w.webp" alt="img"></p>
<h2 id="6、操作系统的基本特性"><a href="#6、操作系统的基本特性" class="headerlink" title="6、操作系统的基本特性"></a>6、操作系统的基本特性</h2><h3 id="6-1、并发性"><a href="#6-1、并发性" class="headerlink" title="6.1、并发性"></a>6.1、并发性</h3><p>并发性是指同一时间间隔内发生两个或多个事件。并行性是指同一时刻内发生两个或多个事件</p>
<p>1．并行与并发：并行性和并发性 (Concurrence) 是既相似又有区别的两个概念，并行性是指两个或多个事件在同一时刻发生；而并发性是指两个或多个事件在同一时间间隔内发生。在多道程序环境下，并发性是指在一段时间内宏观上有多个程序在同时运行，但在单处理机系统中每一时刻却仅能有一道程序执行，故微观上这些程序只能是分时地交替执行。倘若在计算机系统中有多个处理机，则这些可以并发执行的程序便可被分配到多个处理机上，实现并行执行，即利用每个处理机来处理一个可并发执行的程序，这样，多个程序便可同时执行。</p>
<p>2．引入进程：应当指出，通常的程序是静态实体(Passive Entity)，在多道程序系统中，它们是不能独立运行的，更不能和其它程序并发执行。在操作系统中引入进程的目的，就是为了使多个程序能并发执行。例如，在一个未引入进程的系统中，在属于同一个应用程序的计算程序和 I&#x2F;O 程序之间，两者只能是顺序执行，即只有在计算程序执行告一段落后，才允许 I&#x2F;O 程序执行；反之，该程序执行 I&#x2F;O 操作时，计算程序也不能执行，这意味着处理机处于空闲状态 。但在引入进程后，若分别为计算程序和 I&#x2F;O 程序各建立一个进程，则这两个进程便可并发执行。由于在系统中具备计算程序和 I&#x2F;O 程序同时运行的硬件条件，因而可将系统中的 CPU 和 I&#x2F;O 设备同时开动起来，实现并行工作，从而有效地提高了系统资源的利用率和系统吞吐量，并改善了系统的性能。引入进程的好处远不止于此，事实上可以在内存中存放多个用户程序，分别为它们建立进程后，这些进程可以并发执行，亦即实现前面所说的多道程序运行。这样便能极大地提高系统资源的利用率，增加系统的吞吐量。为使多个程序能并发执行，系统必须分别为每个程序建立进程(Process)。简单说来，进程是指在系统中能独立运行并作为资源分配的基本单位，它是由一组机器指令、数据和堆栈等组成的，是一个能独立运行的活动实体。多个进程之间可以并发执行和交换信息。一个进程在运行时需要一定的资源，如 CPU、存储空间及 I&#x2F;O 设备等。OS 中程序的并发执行将使系统复杂化，以致在系统中必须增设若干新的功能模块，分别用于对处理机、内存、I&#x2F;O 设备以及文件系统等资源进行管理，并控制系统中所有作业的运行。事实上，进程和并发是现代操作系统中最重要的基本概念，也是操作系统运行的基础</p>
<p>3．引入线程：长期以来，进程都是操作系统中可以拥有资源并作为独立运行的基本单位。当一个进程因故不能继续运行时，操作系统便调度另一个进程运行。由于进程拥有自己的资源，故使调度付出的开销较大。直到 20 世纪 80 年代中期，人们才又提出了比进程更小的单位——线程(Threads)。通常在一个进程中可以包含若干个线程，它们可以利用进程所拥有的资源。在引入线程的 OS 中，通常都是把进程作为分配资源的基本单位，而把线程作为独立运行和独立调度的基本单位。由于线程比进程更小，基本上不拥有系统资源，故对它的调度所付出的开销就会小得多，能更高效地提高系统内多个程序间并发执行的程度。因而近年来推出的通用操作系统都引入了线程，以便进一步提高系统的并发性，并把它视作现代操作系统的一个重要标致。</p>
<h3 id="6-2、共享性"><a href="#6-2、共享性" class="headerlink" title="6.2、共享性"></a>6.2、共享性</h3><p>在操作系统环境下，所谓共享 (Sharing)， 是指系统中的资源可供内存中多个并发执行的进程(线程)共同使用，相应地，把这种资源共同使用称为资源共享，或称为资源复用。由于各种资源的属性不同，进程对资源复用的方式也不同，目前主要实现资源共享的方式有如下两种。</p>
<p>1．互斥共享方式：系统中的某些资源，如打印机、磁带机，虽然它们可以提供给多个进程(线程)使用，但为使所打印或记录的结果不致造成混淆，应规定在一段时间内只允许一个进程(线程)访问该资源。为此，系统中应建立一种机制，以保证对这类资源的互斥访问。当一个进程 A 要访问某资源时，必须先提出请求。如果此时该资源空闲，系统便可将之分配给请求进程 A 使用。此后若再有其它进程也要访问该资源时(只要 A 未用完)，则必须等待。仅当 A 进程访问完并释放该资源后，才允许另一方进程对该资源进行访问。我们把这种资源共享方式称为互斥式共享，而把在一段时间内只允许一个进程访问的资源称为临界资源或独占资源。计算机系统中的大多数物理设备，以及某些软件中所用的栈、变量和表格，都属于临界资源，它们要求被互斥地共享。为此，在系统中必须配置某种机制来保证诸进程互斥地使用独占资源。</p>
<p>2．同时访问方式：系统中还有另一类资源，允许在一段时间内由多个进程“同时”对它们进行访问。这里所谓的“同时”，在单处理机环境下往往是宏观上的，而在微观上，这些进程可能是交替地对该资源进行访问。典型的可供多个进程“同时”访问的资源是磁盘设备，一些用重入码编写的文件也可以被“同时”共享，即若干个用户同时访问该文件。并发和共享是操作系统的两个最基本的特征，它们又是互为存在的条件。一方面，资源共享是以程序(进程)的并发执行为条件的，若系统不允许程序并发执行，自然不存在资源共享问题；另一方面，若系统不能对资源共享实施有效管理，协调好诸进程对共享资源的访问，也必然影响到程序并发执行的程度，甚至根本无法并发执行。</p>
<h3 id="6-3、虚拟技术"><a href="#6-3、虚拟技术" class="headerlink" title="6.3、虚拟技术"></a>6.3、虚拟技术</h3><p>操作系统中的所谓“虚拟” (Virtual) ，是指通过某种技术把一个物理实体变为若干个逻辑上的对应物。物理实体(前者)是实的，即实际存在的，而后者是虚的，仅是用户感觉上的东西。相应地，用于实现拟的技术称为虚拟技术。在操作系统中利用了两种方式实现虚拟技术，即时分复用技术和空分复用技术。</p>
<p><strong>1、时分复用技术</strong></p>
<p>时分复用，亦即分时使用方式，它最早用于电信业中。为了提高信道的利用率，人们利用时分复用方式，将一条物理信道虚拟为多条逻辑信道，将每条信道供一对用户通话。在计算机领域中，广泛利用该技术来实现虚拟处理机、虚拟设备等，以提高资源的利用率。</p>
<figure class="highlight text"><table><tr><td class="code"><pre><span class="line">虚拟处理机技术</span><br><span class="line">虚拟设备技术</span><br></pre></td></tr></table></figure>

<p><strong>2．空分复用技术</strong></p>
<p>早在上世纪初，电信业中就使用频分复用技术来提高信道的利用率。它是将一个频率范围非常宽的信道，划分成多个频率范围较窄的信道，其中的任何一个频道都只供一对用户通话。早期的频分复用只能将一条物理信道划分为十几条到几十条话路，后来又很快发展成上万条话路，每条话路也只供一对用户通话。之后，在计算机中也使用了空分复用技术来提高存储空间的利用率。</p>
<figure class="highlight text"><table><tr><td class="code"><pre><span class="line">虚拟磁盘技术</span><br><span class="line">虚拟存储器技术</span><br></pre></td></tr></table></figure>

<p>应当着重指出：如果虚拟的实现是通过时分复用的方法来实现的，即对某一物理设备进行分时使用，设 N 是某物理设备所对应的虚拟的逻辑设备数，则每台虚拟设备的平均速度必然等于或低于物理设备速度的 1&#x2F;N。类似地，如果是利用空分复用方法来实现虚拟，此时一台虚拟设备平均占用的空间必然也等于或低于物理设备所拥有空间的 1&#x2F;N。</p>
<h3 id="6-4、异步性"><a href="#6-4、异步性" class="headerlink" title="6.4、异步性"></a>6.4、异步性</h3><p>在多道程序环境下允许多个进程并发执行，但只有进程在获得所需的资源后方能执行。在单处理机环境下，由于系统中只有一台处理机，因而每次只允许一个进程执行，其余进程只能等待。当正在执行的进程提出某种资源要求时，如打印请求，而此时打印机正在为其它某进程打印，由于打印机属于临界资源，因此正在执行的进程必须等待，且放弃处理机，直到打印机空闲，并再次把处理机分配给该进程时，该进程方能继续执行。可见，由于资源等因素的限制，使进程的执行通常都不是“一气呵成”，而是以“停停走走”的方式运行。</p>
<p>内存中的每个进程在何时能获得处理机运行，何时又因提出某种资源请求而暂停，以及进程以怎样的速度向前推进，每道程序总共需多少时间才能完成，等等，这些都是不可预知的。由于各用户程序性能的不同，比如，有的侧重于计算而较少需要 I&#x2F;O，而有的程序其计算少而 I&#x2F;O 多，这样，很可能是先进入内存的作业后完成，而后进入内存的作业先完成。或者说，进程是以人们不可预知的速度向前推进，此即进程的异步性(Asynchronism)。尽管如此，但只要在操作系统中配置有完善的进程同步机制，且运行环境相同，作业经多次运行都会获得完全相同的结果。因此，异步运行方式是允许的，而且是操作系统的一个重要特征。</p>
<hr>
<p>版权声明：本文为知乎博主「玩转Linux内核」的原创文章，遵循CC 4.0 BY-SA版权协议，转载请附上原文出处链接及本声明。<br>原文链接：<a href="https://zhuanlan.zhihu.com/p/446635858">https://zhuanlan.zhihu.com/p/446635858</a></p>
]]></content>
      <categories>
        <category>linux-doc</category>
      </categories>
      <tags>
        <tag>Linux</tag>
      </tags>
  </entry>
  <entry>
    <title>Linux内核架构和工作原理</title>
    <url>/2023/01/15/linux-docs/Linux%E5%86%85%E6%A0%B8%E6%9E%B6%E6%9E%84%E5%92%8C%E5%B7%A5%E4%BD%9C%E5%8E%9F%E7%90%86/</url>
    <content><![CDATA[<blockquote>
<p><strong>前言：</strong>作用是将应用层序的请求传递给硬件，并充当底层驱动程序，对系统中的各种设备和组件进行寻址。目前支持模块的动态装卸(裁剪)。Linux内核就是基于这个策略实现的。Linux进程1.采用层次结构，每个进程都依赖于一个父进程。内核启动init程序作为第一个进程。该进程负责进一步的系统初始化操作。init进程是进程树的根，所有的进程都直接或者间接起源于该进程。virt&#x2F; —- 提供虚拟机技术的支持。</p>
</blockquote>
<h2 id="1、Linux内核预备工作"><a href="#1、Linux内核预备工作" class="headerlink" title="1、Linux内核预备工作"></a>1、Linux内核预备工作</h2><p><strong>理解Linux内核最好预备的知识点：</strong></p>
<p>懂C语言<br>懂一点操作系统的知识<br>熟悉少量相关算法<br>懂计算机体系结构</p>
<p><strong>Linux内核的特点：</strong></p>
<p>结合了Unix操作系统的一些基础概念</p>
<p><img src="https://pic4.zhimg.com/80/v2-d969437fc09bcd369092c2f85b01e8c7_720w.webp" alt="img"></p>
<p><img src="https://pic2.zhimg.com/80/v2-2316dd0f3cd70e0390554a35e8881bf9_720w.webp" alt="img"></p>
<p><strong>Linux内核的任务：</strong></p>
<p>1.从技术层面讲，内核是硬件与软件之间的一个中间层。作用是将应用层序的请求传递给硬件，并充当底层驱动程序，对系统中的各种设备和组件进行寻址。</p>
<p>2.从应用程序的层面讲，应用程序与硬件没有联系，只与内核有联系，内核是应用程序知道的层次中的最底层。在实际工作中内核抽象了相关细节。</p>
<p>3.内核是一个资源管理程序。负责将可用的共享资源(CPU时间、磁盘空间、网络连接等)分配得到各个系统进程。</p>
<p>4.内核就像一个库，提供了一组面向系统的命令。系统调用对于应用程序来说，就像调用普通函数一样。</p>
<p><strong>内核实现策略：</strong></p>
<p>1.微内核。最基本的功能由中央内核（微内核）实现。所有其他的功能都委托给一些独立进程，这些进程通过明确定义的通信接口与中心内核通信。</p>
<p>2.宏内核。内核的所有代码，包括子系统（如内存管理、文件管理、设备驱动程序）都打包到一个文件中。内核中的每一个函数都可以访问到内核中所有其他部分。目前支持模块的动态装卸(裁剪)。Linux内核就是基于这个策略实现的。</p>
<p><strong>哪些地方用到了内核机制？</strong></p>
<p>1.进程（在cpu的虚拟内存中分配地址空间，各个进程的地址空间完全独立;同时执行的进程数最多不超过cpu数目）之间进行通 信，需要使用特定的内核机制。</p>
<p>2.进程间切换(同时执行的进程数最多不超过cpu数目)，也需要用到内核机制。</p>
<p>进程切换也需要像FreeRTOS任务切换一样保存状态，并将进程置于闲置状态&#x2F;恢复状态。</p>
<p>3.进程的调度。确认哪个进程运行多长的时间。</p>
<p><strong>Linux进程</strong></p>
<p>1.采用层次结构，每个进程都依赖于一个父进程。内核启动init程序作为第一个进程。该进程负责进一步的系统初始化操作。init进程是进程树的根，所有的进程都直接或者间接起源于该进程。</p>
<p>2.通过Pstree命令查询。实际上得系统第一个进程是Systemd，而不是init（这也是疑问点）</p>
<p>3.系统中每一个进程都有一个唯一标识符(ID),用户（或其他进程）可以使用ID来访问进程。</p>
<p><strong>Linux内核源代码的目录结构</strong></p>
<p>Linux内核源代码包括三个主要部分：</p>
<p>\1. 内核核心代码，包括第3章所描述的各个子系统和子模块，以及其它的支撑子系统，例如电源管理、Linux初始化等</p>
<p>\2. 其它非核心代码，例如库文件（因为Linux内核是一个自包含的内核，即内核不依赖其它的任何软件，自己就可以编译通过）、固件集合、KVM（虚拟机技术）等</p>
<p>\3. 编译脚本、配置文件、帮助文档、版权说明等辅助性文件。</p>
<p><strong>使用ls命令看到的内核源代码的顶层目录结构，具体描述如下：</strong></p>
<ul>
<li>include&#x2F; —- 内核头文件，需要提供给外部模块（例如用户空间代码）使用。</li>
<li>kernel&#x2F; —- Linux内核的核心代码，包含了3.2小节所描述的进程调度子系统，以及和进程调度相关的模块。</li>
<li>mm&#x2F; —- 内存管理子系统（3.3小节）。</li>
<li>fs&#x2F; —- VFS子系统（3.4小节）。</li>
<li>net&#x2F; —- 不包括网络设备驱动的网络子系统（3.5小节）。</li>
<li>ipc&#x2F; —- IPC（进程间通信）子系统。</li>
<li>arch&#x2F;&#x2F; —- 体系结构相关的代码，例如arm, x86等等。</li>
<li>arch&#x2F;&#x2F;mach- —- 具体的machine&#x2F;board相关的代码。</li>
<li>arch&#x2F;&#x2F;include&#x2F;asm —- 体系结构相关的头文件。</li>
<li>arch&#x2F;&#x2F;boot&#x2F;dts —- 设备树（Device Tree）文件。</li>
<li>init&#x2F; —- Linux系统启动初始化相关的代码。</li>
<li>block&#x2F; —- 提供块设备的层次。</li>
<li>sound&#x2F; —- 音频相关的驱动及子系统，可以看作“音频子系统”。</li>
<li>drivers&#x2F; —- 设备驱动（在Linux kernel 3.10中，设备驱动占了49.4的代码量）。</li>
<li>lib&#x2F; —- 实现需要在内核中使用的库函数，例如CRC、FIFO、list、MD5等。</li>
<li>crypto&#x2F; —– 加密、解密相关的库函数。</li>
<li>security&#x2F; —- 提供安全特性（SELinux）。</li>
<li>virt&#x2F; —- 提供虚拟机技术（KVM等）的支持。</li>
<li>usr&#x2F; —- 用于生成initramfs的代码。</li>
<li>firmware&#x2F; —- 保存用于驱动第三方设备的固件。</li>
<li>samples&#x2F; —- 一些示例代码。</li>
<li>tools&#x2F; —- 一些常用工具，如性能剖析、自测试等。</li>
<li>Kconfig, Kbuild, Makefile, scripts&#x2F; —- 用于内核编译的配置文件、脚本等。</li>
<li>COPYING —- 版权声明。</li>
<li>MAINTAINERS —-维护者名单。</li>
<li>CREDITS —- Linux主要的贡献者名单。</li>
<li>REPORTING-BUGS —- Bug上报的指南。</li>
<li>Documentation, README —- 帮助、说明文档。</li>
</ul>
<h2 id="2、Linux内核体系结构简析简析"><a href="#2、Linux内核体系结构简析简析" class="headerlink" title="2、Linux内核体系结构简析简析"></a>2、Linux内核体系结构简析简析</h2><p><img src="https://pic4.zhimg.com/80/v2-ba1465f73c052a0acf19c922c11a13df_720w.webp" alt="img"></p>
<p>Linux系统层次结构</p>
<p>最上面是用户（或应用程序）空间。这是用户应用程序执行的地方。用户空间之下是内核空间，Linux 内核正是位于这里。GNU C Library （glibc）也在这里。它提供了连接内核的系统调用接口，还提供了在用户空间应用程序和内核之间进行转换的机制。这点非常重要，因为内核和用户空间的应用程序使用的是不同的保护地址空间。每个用户空间的进程都使用自己的虚拟地址空间，而内核则占用单独的地址空间。</p>
<p>Linux 内核可以进一步划分成 3 层。最上面是系统调用接口，它实现了一些基本的功能，例如 read 和 write。系统调用接口之下是内核代码，可以更精确地定义为独立于体系结构的内核代码。这些代码是 Linux 所支持的所有处理器体系结构所通用的。在这些代码之下是依赖于体系结构的代码，构成了通常称为 BSP（Board Support Package）的部分。这些代码用作给定体系结构的处理器和特定于平台的代码。</p>
<p>Linux 内核实现了很多重要的体系结构属性。在或高或低的层次上，内核被划分为多个子系统。Linux 也可以看作是一个整体，因为它会将所有这些基本服务都集成到内核中。这与微内核的体系结构不同，后者会提供一些基本的服务，例如通信、I&#x2F;O、内存和进程管理，更具体的服务都是插入到微内核层中的。每种内核都有自己的优点，不过这里并不对此进行讨论。</p>
<p>随着时间的流逝，Linux 内核在内存和 CPU 使用方面具有较高的效率，并且非常稳定。但是对于 Linux 来说，最为有趣的是在这种大小和复杂性的前提下，依然具有良好的可移植性。Linux 编译后可在大量处理器和具有不同体系结构约束和需求的平台上运行。一个例子是 Linux 可以在一个具有内存管理单元（MMU）的处理器上运行，也可以在那些不提供 MMU 的处理器上运行。</p>
<p>Linux 内核的 uClinux 移植提供了对非 MMU 的支持。</p>
<p><img src="https://pic2.zhimg.com/80/v2-dc367274df8b2a5b2a1c88d6efa4e901_720w.webp" alt="img"></p>
<p>Linux内核体系结构</p>
<p>Linux内核的主要组件有：系统调用接口、进程管理、内存管理、虚拟文件系统、网络堆栈、设备驱动程序、硬件架构的相关代码。</p>
<p><strong>（1）系统调用接口</strong></p>
<p>SCI 层提供了某些机制执行从用户空间到内核的函数调用。正如前面讨论的一样，这个接口依赖于体系结构，甚至在相同的处理器家族内也是如此。SCI 实际上是一个非常有用的函数调用多路复用和多路分解服务。在 .&#x2F;linux&#x2F;kernel 中您可以找到 SCI 的实现，并在 .&#x2F;linux&#x2F;arch 中找到依赖于体系结构的部分。</p>
<p><strong>（2）进程管理</strong></p>
<p>进程管理的重点是进程的执行。在内核中，这些进程称为线程，代表了单独的处理器虚拟化（线程代码、数据、堆栈和 CPU 寄存器）。在用户空间，通常使用进程 这个术语，不过 Linux 实现并没有区分这两个概念（进程和线程）。内核通过 SCI 提供了一个应用程序编程接口（API）来创建一个新进程（fork、exec 或 Portable Operating System Interface [POSIX] 函数），停止进程（kill、exit），并在它们之间进行通信和同步（signal 或者 POSIX 机制）。</p>
<p>进程管理还包括处理活动进程之间共享 CPU 的需求。内核实现了一种新型的调度算法，不管有多少个线程在竞争 CPU，这种算法都可以在固定时间内进行操作。这种算法就称为 O(1) 调度程序，这个名字就表示它调度多个线程所使用的时间和调度一个线程所使用的时间是相同的。O(1) 调度程序也可以支持多处理器（称为对称多处理器或 SMP）。您可以在 .&#x2F;linux&#x2F;kernel 中找到进程管理的源代码，在 .&#x2F;linux&#x2F;arch 中可以找到依赖于体系结构的源代码。</p>
<p><strong>（3）内存管理</strong></p>
<p>内核所管理的另外一个重要资源是内存。为了提高效率，如果由硬件管理虚拟内存，内存是按照所谓的内存页 方式进行管理的（对于大部分体系结构来说都是 4KB）。Linux 包括了管理可用内存的方式，以及物理和虚拟映射所使用的硬件机制。不过内存管理要管理的可不止 4KB 缓冲区。Linux 提供了对 4KB 缓冲区的抽象，例如 slab 分配器。这种内存管理模式使用 4KB 缓冲区为基数，然后从中分配结构，并跟踪内存页使用情况，比如哪些内存页是满的，哪些页面没有完全使用，哪些页面为空。这样就允许该模式根据系统需要来动态调整内存使用。为了支持多个用户使用内存，有时会出现可用内存被消耗光的情况。由于这个原因，页面可以移出内存并放入磁盘中。这个过程称为交换，因为页面会被从内存交换到硬盘上。内存管理的源代码可以在 .&#x2F;linux&#x2F;mm 中找到。</p>
<p><strong>（4）虚拟文件系统</strong></p>
<p>虚拟文件系统（VFS）是 Linux 内核中非常有用的一个方面，因为它为文件系统提供了一个通用的接口抽象。VFS 在 SCI 和内核所支持的文件系统之间提供了一个交换层（请参看图4）。</p>
<p><img src="https://pic4.zhimg.com/80/v2-5f5326e20c34c3eb6efeeeaaf389ba67_720w.webp" alt="img"></p>
<p>Linux文件系统层次结构</p>
<p>在 VFS 上面，是对诸如 open、close、read 和 write 之类的函数的一个通用 API 抽象。在 VFS 下面是文件系统抽象，它定义了上层函数的实现方式。它们是给定文件系统（超过 50 个）的插件。文件系统的源代码可以在 .&#x2F;linux&#x2F;fs 中找到。文件系统层之下是缓冲区缓存，它为文件系统层提供了一个通用函数集（与具体文件系统无关）。这个缓存层通过将数据保留一段时间（或者随即预先读取数据以便在需要是就可用）优化了对物理设备的访问。缓冲区缓存之下是设备驱动程序，它实现了特定物理设备的接口。</p>
<p><strong>（5）网络堆栈</strong></p>
<p>网络堆栈在设计上遵循模拟协议本身的分层体系结构。回想一下，Internet Protocol (IP) 是传输协议（通常称为传输控制协议或 TCP）下面的核心网络层协议。TCP 上面是 socket 层，它是通过 SCI 进行调用的。socket 层是网络子系统的标准 API，它为各种网络协议提供了一个用户接口。从原始帧访问到 IP 协议数据单元（PDU），再到 TCP 和 User Datagram Protocol (UDP)，socket 层提供了一种标准化的方法来管理连接，并在各个终点之间移动数据。内核中网络源代码可以在 .&#x2F;linux&#x2F;net 中找到。</p>
<p><strong>（6）设备驱动程序</strong></p>
<p>Linux 内核中有大量代码都在设备驱动程序中，它们能够运转特定的硬件设备。Linux 源码树提供了一个驱动程序子目录，这个目录又进一步划分为各种支持设备，例如 Bluetooth、I2C、serial 等。设备驱动程序的代码可以在 .&#x2F;linux&#x2F;drivers 中找到。</p>
<p><strong>（7）依赖体系结构的代码</strong></p>
<p>尽管 Linux 很大程度上独立于所运行的体系结构，但是有些元素则必须考虑体系结构才能正常操作并实现更高效率。.&#x2F;linux&#x2F;arch 子目录定义了内核源代码中依赖于体系结构的部分，其中包含了各种特定于体系结构的子目录（共同组成了 BSP）。对于一个典型的桌面系统来说，使用的是 x86 目录。每个体系结构子目录都包含了很多其他子目录，每个子目录都关注内核中的一个特定方面，例如引导、内核、内存管理等。这些依赖体系结构的代码可以在 .&#x2F;linux&#x2F;arch 中找到。</p>
<p>如果 Linux 内核的可移植性和效率还不够好，Linux 还提供了其他一些特性，它们无法划分到上面的分类中。作为一个生产操作系统和开源软件，Linux 是测试新协议及其增强的良好平台。Linux 支持大量网络协议，包括典型的 TCP&#x2F;IP，以及高速网络的扩展（大于 1 Gigabit Ethernet [GbE] 和 10 GbE）。Linux 也可以支持诸如流控制传输协议（SCTP）之类的协议，它提供了很多比 TCP 更高级的特性（是传输层协议的接替者）。</p>
<p>Linux 还是一个动态内核，支持动态添加或删除软件组件。被称为动态可加载内核模块，它们可以在引导时根据需要（当前特定设备需要这个模块）或在任何时候由用户插入。</p>
<p>Linux 最新的一个增强是可以用作其他操作系统的操作系统（称为系统管理程序）。最近，对内核进行了修改，称为基于内核的虚拟机（KVM）。这个修改为用户空间启用了一个新的接口，它可以允许其他操作系统在启用了 KVM 的内核之上运行。除了运行 Linux 的其他实例之外， Microsoft Windows也可以进行虚拟化。惟一的限制是底层处理器必须支持新的虚拟化指令。</p>
<h2 id="3、Linux体系结构和内核结构区别"><a href="#3、Linux体系结构和内核结构区别" class="headerlink" title="3、Linux体系结构和内核结构区别"></a>3、Linux体系结构和内核结构区别</h2><p><strong>1．当被问到Linux体系结构（就是Linux系统是怎么构成的）时，</strong>我们可以参照下图这么回答：从大的方面讲，Linux体系结构可以分为两块：</p>
<ul>
<li>（1）用户空间：用户空间中又包含了，用户的应用程序，C库</li>
<li>（2）内核空间：内核空间包括，系统调用，内核，以及与平台架构相关的代码</li>
</ul>
<p><img src="https://pic4.zhimg.com/80/v2-0c0e596001874218a2a246af82adc88f_720w.webp" alt="img"></p>
<p><strong>2．Linux体系结构要分成用户空间和内核空间的原因：</strong></p>
<p>1）现代CPU通常都实现了不同的工作模式，</p>
<p>以ARM为例：ARM实现了7种工作模式，不同模式下CPU可以执行的指令或者访问的寄存器不同：</p>
<ul>
<li>（1）用户模式 usr</li>
<li>（2）系统模式 sys</li>
<li>（3）管理模式 svc</li>
<li>（4）快速中断 fiq</li>
<li>（5）外部中断 irq</li>
<li>（6）数据访问终止 abt</li>
<li>（7）未定义指令异常</li>
</ul>
<p>以（2）X86为例：X86实现了4个不同级别的权限，Ring0—Ring3 ;Ring0下可以执行特权指令，可以访问IO设备；Ring3则有很多的限制</p>
<p>2）所以，Linux从CPU的角度出发，为了保护内核的安全，把系统分成了2部分；</p>
<p>3．用户空间和内核空间是程序执行的两种不同状态，我们可以通过“系统调用”和“硬件中断“来完成用户空间到内核空间的转移</p>
<p>4．Linux的内核结构（注意区分LInux体系结构和Linux内核结构）</p>
<p><img src="https://pic4.zhimg.com/80/v2-4afc669c4dfb7c46c227b2b45690e6d3_720w.webp" alt="img"></p>
<h2 id="4、Linux驱动的platform机制"><a href="#4、Linux驱动的platform机制" class="headerlink" title="4、Linux驱动的platform机制"></a>4、Linux驱动的platform机制</h2><p>Linux的这种platform driver机制和传统的device_driver机制相比，一个十分明显的优势在于platform机制将本身的资源注册进内核，由内核统一管理，在驱动程序中使用这些资源时通过platform_device提供的标准接口进行申请并使用。这样提高了驱动和资源管理的独立性，并且拥有较好的可移植性和安全性。下面是SPI驱动层次示意图，Linux中的SPI总线可理解为SPI控制器引出的总线：</p>
<p><img src="https://pic1.zhimg.com/80/v2-5bd23fdb2e32e999d5103cb05b8c2764_720w.webp" alt="img"></p>
<p>和传统的驱动一样，<strong>platform机制也分为三个步骤：</strong></p>
<p><strong>1、总线注册阶段：</strong></p>
<p>内核启动初始化时的main.c文件中的kernel_init()→do_basic_setup()→driver_init()→platform_bus_init()→bus_register(&amp;platform_bus_type)，注册了一条platform总线（虚拟总线，platform_bus）。</p>
<p><strong>2、添加设备阶段：</strong></p>
<p>设备注册的时候Platform_device_register()→platform_device_add()→(pdev→dev.bus &#x3D; &amp;platform_bus_type)→device_add()，就这样把设备给挂到虚拟的总线上。</p>
<p><strong>3、驱动注册阶段：</strong></p>
<p>Platform_driver_register()→driver_register()→bus_add_driver()→driver_attach()→bus_for_each_dev(), 对在每个挂在虚拟的platform bus的设备作__driver_attach()→driver_probe_device(),判断drv→bus→match()是否执行成功，此时通过指针执行platform_match→strncmp(pdev→name , drv→name , BUS_ID_SIZE),如果相符就调用really_probe(实际就是执行相应设备的platform_driver→probe(platform_device)。)开始真正的探测，如果probe成功，则绑定设备到该驱动。</p>
<p>从上面可以看出，platform机制最后还是调用了bus_register() , device_add() , driver_register()这三个关键的函数。</p>
<p><strong>下面看几个结构体：</strong></p>
<p><img src="https://pic3.zhimg.com/80/v2-5f6443d292671c2f505285967ea62ae2_720w.webp" alt="img"></p>
<p>Platform_device结构体描述了一个platform结构的设备，在其中包含了一般设备的结构体struct device dev;设备的资源结构体struct resource * resource;还有设备的名字const char * name。（注意，这个名字一定要和后面platform_driver.driver àname相同，原因会在后面说明。）</p>
<p><strong>该结构体中最重要的就是resource结构，这也是之所以引入platform机制的原因。</strong></p>
<p><img src="https://pic2.zhimg.com/80/v2-579a8a2db3ad4e5af52aa2cdb43e3589_720w.webp" alt="img"></p>
<p><strong>名字要一致的原因：</strong></p>
<p>上面说的驱动在注册的时候会调用函数bus_for_each_dev(), 对在每个挂在虚拟的platform bus的设备作__driver_attach()→driver_probe_device(),在此函数中会对dev和drv做初步的匹配，调用的是drv-&gt;bus-&gt;match所指向的函数。platform_driver_register函数中drv-&gt;driver.bus &#x3D; &amp;platform_bus_type，所以drv-&gt;bus-&gt;match就为platform_bus_type→match,为platform_match函数，该函数如下：</p>
<p><img src="https://pic2.zhimg.com/80/v2-ba6968431a2f40ca694eb4d497e62979_720w.webp" alt="img"></p>
<p>是比较dev和drv的name，相同则会进入really_probe（）函数，从而进入自己写的probe函数做进一步的匹配。所以dev→name和driver→drv→name在初始化时一定要填一样的。</p>
<p>不同类型的驱动，其match函数是不一样的，这个platform的驱动，比较的是dev和drv的名字，还记得usb类驱动里的match吗？它比较的是Product ID和Vendor ID。</p>
<p><strong>个人总结Platform机制的好处：</strong></p>
<p>1、提供platform_bus_type类型的总线，把那些不是总线型的soc设备都添加到这条虚拟总线上。使得，总线——设备——驱动的模式可以得到普及。</p>
<p>2、提供platform_device和platform_driver类型的数据结构，将传统的device和driver数据结构嵌入其中，并且加入resource成员，以便于和Open Firmware这种动态传递设备资源的新型bootloader和kernel 接轨。</p>
<h2 id="5、Linux内核体系结构"><a href="#5、Linux内核体系结构" class="headerlink" title="5、Linux内核体系结构"></a>5、Linux内核体系结构</h2><p>因为Linux内核是单片的，所以它比其他类型的内核占用空间最大，复杂度也最高。这是一个设计特性，在Linux早期引起了相当多的争论，并且仍然带有一些与单内核固有的相同的设计缺陷。</p>
<p><img src="https://pic3.zhimg.com/80/v2-27733a2ef35c2b2c70ba8c6ad50aad2a_720w.webp" alt="img"></p>
<p>为了解决这些缺陷，Linux内核开发人员所做的一件事就是使内核模块可以在运行时加载和卸载，这意味着您可以动态地添加或删除内核的特性。这不仅可以向内核添加硬件功能，还可以包括运行服务器进程的模块，比如低级别虚拟化，但也可以替换整个内核，而不需要在某些情况下重启计算机。<br>想象一下，如果您可以升级到Windows服务包，而不需要重新启动……</p>
<p><strong>内核模块</strong></p>
<p>如果Windows已经安装了所有可用的驱动程序，而您只需要打开所需的驱动程序怎么办?这本质上就是内核模块为Linux所做的。内核模块，也称为可加载内核模块(LKM)，对于保持内核在不消耗所有可用内存的情况下与所有硬件一起工作是必不可少的。</p>
<p><img src="https://pic1.zhimg.com/80/v2-05bbaa4cf8f0d0b8dc7243392fc0d84c_720w.webp" alt="img"></p>
<p>模块通常向基本内核添加设备、文件系统和系统调用等功能。lkm的文件扩展名是.ko，通常存储在&#x2F;lib&#x2F;modules目录中。由于模块的特性，您可以通过在启动时使用menuconfig命令将模块设置为load或not load，或者通过编辑&#x2F;boot&#x2F;config文件，或者使用modprobe命令动态地加载和卸载模块，轻松定制内核。</p>
<p>第三方和封闭源码模块在一些发行版中是可用的，比如Ubuntu，默认情况下可能无法安装，因为这些模块的源代码是不可用的。该软件的开发人员(即nVidia、ATI等)不提供源代码，而是构建自己的模块并编译所需的.ko文件以便分发。虽然这些模块像beer一样是免费的，但它们不像speech那样是免费的，因此不包括在一些发行版中，因为维护人员认为它通过提供非免费软件“污染”了内核。</p>
<p>内核并不神奇，但对于任何正常运行的计算机来说，它都是必不可少的。Linux内核不同于OS X和Windows，因为它包含内核级别的驱动程序，并使许多东西“开箱即用”。希望您能对软件和硬件如何协同工作以及启动计算机所需的文件有更多的了解。</p>
<hr>
<p>版权声明：本文为知乎博主「玩转Linux内核」的原创文章，遵循CC 4.0 BY-SA版权协议，转载请附上原文出处链接及本声明。<br>原文链接：<a href="https://zhuanlan.zhihu.com/p/419643250">https://zhuanlan.zhihu.com/p/419643250</a></p>
]]></content>
      <categories>
        <category>linux-doc</category>
      </categories>
      <tags>
        <tag>Linux</tag>
      </tags>
  </entry>
  <entry>
    <title>Linux内核看socket底层的本质(IO)</title>
    <url>/2023/01/15/linux-docs/Linux%E5%86%85%E6%A0%B8%E7%9C%8Bsocket%E5%BA%95%E5%B1%82%E7%9A%84%E6%9C%AC%E8%B4%A8(IO)/</url>
    <content><![CDATA[<h2 id="1、I-O-模型"><a href="#1、I-O-模型" class="headerlink" title="1、I&#x2F;O 模型"></a>1、I&#x2F;O 模型</h2><p><strong>一个输入操作通常包括两个阶段：</strong></p>
<ul>
<li>等待数据准备好</li>
<li>从内核向进程复制数据</li>
</ul>
<p>对于一个套接字上的输入操作，第一步通常涉及等待数据从网络中到达。当所等待数据到达时，它被复制到内核中的某个缓冲区。第二步就是把数据从内核缓冲区复制到应用进程缓冲区。</p>
<p>Unix 有五种 I&#x2F;O 模型：</p>
<ul>
<li>阻塞式 I&#x2F;O</li>
<li>非阻塞式 I&#x2F;O</li>
<li>I&#x2F;O 复用（select 和 poll）</li>
<li>信号驱动式 I&#x2F;O（SIGIO）</li>
<li>异步 I&#x2F;O（AIO）</li>
</ul>
<h3 id="1-1阻塞式-I-O"><a href="#1-1阻塞式-I-O" class="headerlink" title="1.1阻塞式 I&#x2F;O"></a>1.1阻塞式 I&#x2F;O</h3><p>应用进程被阻塞，直到数据从内核缓冲区复制到应用进程缓冲区中才返回。</p>
<p>应该注意到，在阻塞的过程中，其它应用进程还可以执行，因此阻塞不意味着整个操作系统都被阻塞。因为其它应用进程还可以执行，所以不消耗 CPU 时间，这种模型的 CPU 利用率会比较高。</p>
<p>下图中，recvfrom() 用于接收 Socket 传来的数据，并复制到应用进程的缓冲区 buf 中。这里把 recvfrom() 当成系统调用。</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">ssize_t</span> <span class="title">recvfrom</span><span class="params">(</span></span></span><br><span class="line"><span class="params"><span class="function"><span class="type">int</span> sockfd, <span class="type">void</span> *buf, </span></span></span><br><span class="line"><span class="params"><span class="function"><span class="type">size_t</span> len, <span class="type">int</span> flags, </span></span></span><br><span class="line"><span class="params"><span class="function"><span class="keyword">struct</span> sockaddr *src_addr, </span></span></span><br><span class="line"><span class="params"><span class="function"><span class="type">socklen_t</span> *addrlen)</span></span>;</span><br></pre></td></tr></table></figure>

<p><img src="https://pic1.zhimg.com/80/v2-5360be48b37f8ff02990e5ba9e691b40_720w.webp" alt="img"></p>
<h3 id="1-2非阻塞式-I-O"><a href="#1-2非阻塞式-I-O" class="headerlink" title="1.2非阻塞式 I&#x2F;O"></a>1.2非阻塞式 I&#x2F;O</h3><p>应用进程执行系统调用之后，内核返回一个错误码。应用进程可以继续执行，但是需要不断的执行系统调用来获知 I&#x2F;O 是否完成，这种方式称为轮询（polling）。</p>
<p>由于 CPU 要处理更多的系统调用，因此这种模型的 CPU 利用率比较低。</p>
<p><img src="https://pic4.zhimg.com/80/v2-06d2b7a4c60fdee4d8c737523457510b_720w.webp" alt="img"></p>
<h3 id="1-3I-O-复用"><a href="#1-3I-O-复用" class="headerlink" title="1.3I&#x2F;O 复用"></a>1.3I&#x2F;O 复用</h3><p>使用 select 或者 poll 等待数据，并且可以等待多个套接字中的任何一个变为可读。这一过程会被阻塞，当某一个套接字可读时返回，之后再使用 recvfrom 把数据从内核复制到进程中。</p>
<p>它可以让单个进程具有处理多个 I&#x2F;O 事件的能力。又被称为 Event Driven I&#x2F;O，即事件驱动 I&#x2F;O。</p>
<p>如果一个 Web 服务器没有 I&#x2F;O 复用，那么每一个 Socket 连接都需要创建一个线程去处理。如果同时有几万个连接，那么就需要创建相同数量的线程。相比于多进程和多线程技术，I&#x2F;O 复用不需要进程线程创建和切换的开销，系统开销更小。</p>
<p><img src="https://pic3.zhimg.com/80/v2-c81b85be36389bf6d3c1a3293afe2242_720w.webp" alt="img"></p>
<h3 id="1-4信号驱动-I-O"><a href="#1-4信号驱动-I-O" class="headerlink" title="1.4信号驱动 I&#x2F;O"></a>1.4信号驱动 I&#x2F;O</h3><p>应用进程使用 sigaction 系统调用，内核立即返回，应用进程可以继续执行，也就是说等待数据阶段应用进程是非阻塞的。内核在数据到达时向应用进程发送 SIGIO 信号，应用进程收到之后在信号处理程序中调用 recvfrom 将数据从内核复制到应用进程中。</p>
<p>相比于非阻塞式 I&#x2F;O 的轮询方式，信号驱动 I&#x2F;O 的 CPU 利用率更高。</p>
<p><img src="https://pic2.zhimg.com/80/v2-6a2d4905b2f02f2ffca3faa0ef70db3d_720w.webp" alt="img"></p>
<h3 id="1-5异步-I-O"><a href="#1-5异步-I-O" class="headerlink" title="1.5异步 I&#x2F;O"></a>1.5异步 I&#x2F;O</h3><p>应用进程执行 aio_read 系统调用会立即返回，应用进程可以继续执行，不会被阻塞，内核会在所有操作完成之后向应用进程发送信号。</p>
<p>异步 I&#x2F;O 与信号驱动 I&#x2F;O 的区别在于，异步 I&#x2F;O 的信号是通知应用进程 I&#x2F;O 完成，而信号驱动 I&#x2F;O 的信号是通知应用进程可以开始 I&#x2F;O。</p>
<p><img src="https://pic2.zhimg.com/80/v2-cdb7b4db741402d81752e4651fddf5f1_720w.webp" alt="img"></p>
<h3 id="1-6五大-I-O-模型比较"><a href="#1-6五大-I-O-模型比较" class="headerlink" title="1.6五大 I&#x2F;O 模型比较"></a>1.6五大 I&#x2F;O 模型比较</h3><ul>
<li>同步 I&#x2F;O：将数据从内核缓冲区复制到应用进程缓冲区的阶段（第二阶段），应用进程会阻塞。</li>
<li>异步 I&#x2F;O：第二阶段应用进程不会阻塞。</li>
</ul>
<p>同步 I&#x2F;O 包括阻塞式 I&#x2F;O、非阻塞式 I&#x2F;O、I&#x2F;O 复用和信号驱动 I&#x2F;O ，它们的主要区别在第一个阶段。</p>
<p>非阻塞式 I&#x2F;O 、信号驱动 I&#x2F;O 和异步 I&#x2F;O 在第一阶段不会阻塞。</p>
<p><img src="https://pic2.zhimg.com/80/v2-ffb7600b9628204090b41550e4c967b5_720w.webp" alt="img"></p>
<h2 id="2、I-O-复用"><a href="#2、I-O-复用" class="headerlink" title="2、I&#x2F;O 复用"></a>2、I&#x2F;O 复用</h2><p>select&#x2F;poll&#x2F;epoll 都是 I&#x2F;O 多路复用的具体实现，select 出现的最早，之后是 poll，再是 epoll。</p>
<h3 id="2-1select"><a href="#2-1select" class="headerlink" title="2.1select"></a>2.1select</h3><figure class="highlight text"><table><tr><td class="code"><pre><span class="line">int select(</span><br><span class="line">int n, fd_set *readfds, fd_set *writefds, fd_set *exceptfds, </span><br><span class="line">struct timeval *timeout);</span><br></pre></td></tr></table></figure>

<p>select 允许应用程序监视一组文件描述符，等待一个或者多个描述符成为就绪状态，从而完成 I&#x2F;O 操作。</p>
<ul>
<li>fd_set 使用数组实现，数组大小使用 FD_SETSIZE 定义，所以只能监听少于 FD_SETSIZE 数量的描述符。有三种类型的描述符类型：readset、writeset、exceptset，分别对应读、写、异常条件的描述符集合。</li>
<li>timeout 为超时参数，调用 select 会一直阻塞直到有描述符的事件到达或者等待的时间超过 timeout。</li>
<li>成功调用返回结果大于 0，出错返回结果为 -1，超时返回结果为 0。</li>
</ul>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">fd_set fd_in, fd_out;</span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">timeval</span> tv;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Reset the sets</span></span><br><span class="line"><span class="built_in">FD_ZERO</span>( &amp;fd_in );</span><br><span class="line"><span class="built_in">FD_ZERO</span>( &amp;fd_out );</span><br><span class="line"></span><br><span class="line"><span class="comment">// Monitor sock1 for input events</span></span><br><span class="line"><span class="built_in">FD_SET</span>( sock1, &amp;fd_in );</span><br><span class="line"></span><br><span class="line"><span class="comment">// Monitor sock2 for output events</span></span><br><span class="line"><span class="built_in">FD_SET</span>( sock2, &amp;fd_out );</span><br><span class="line"></span><br><span class="line"><span class="comment">// Find out which socket has the largest numeric value as select requires it</span></span><br><span class="line"><span class="type">int</span> largest_sock = sock1 &gt; sock2 ? sock1 : sock2;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Wait up to 10 seconds</span></span><br><span class="line">tv.tv_sec = <span class="number">10</span>;</span><br><span class="line">tv.tv_usec = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Call the select</span></span><br><span class="line"><span class="type">int</span> ret = <span class="built_in">select</span>( largest_sock + <span class="number">1</span>, &amp;fd_in, &amp;fd_out, <span class="literal">NULL</span>, &amp;tv );</span><br><span class="line"></span><br><span class="line"><span class="comment">// Check if select actually succeed</span></span><br><span class="line"><span class="keyword">if</span> ( ret == <span class="number">-1</span> )</span><br><span class="line">    <span class="comment">// report error and abort</span></span><br><span class="line"><span class="keyword">else</span> <span class="keyword">if</span> ( ret == <span class="number">0</span> )</span><br><span class="line">    <span class="comment">// timeout; no event detected</span></span><br><span class="line"><span class="keyword">else</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">if</span> ( <span class="built_in">FD_ISSET</span>( sock1, &amp;fd_in ) )</span><br><span class="line">        <span class="comment">// input event on sock1</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> ( <span class="built_in">FD_ISSET</span>( sock2, &amp;fd_out ) )</span><br><span class="line">        <span class="comment">// output event on sock2</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="2-2poll"><a href="#2-2poll" class="headerlink" title="2.2poll"></a>2.2poll</h3><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span> <span class="title">poll</span><span class="params">(<span class="keyword">struct</span> pollfd *fds, <span class="type">unsigned</span> <span class="type">int</span> nfds, <span class="type">int</span> timeout)</span></span>;</span><br></pre></td></tr></table></figure>

<p>poll 的功能与 select 类似，也是等待一组描述符中的一个成为就绪状态。</p>
<p>poll 中的描述符是 pollfd 类型的数组，pollfd 的定义如下：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">struct</span> <span class="title class_">pollfd</span> &#123;</span><br><span class="line">               <span class="type">int</span>   fd;         <span class="comment">/* file descriptor */</span></span><br><span class="line">               <span class="type">short</span> events;     <span class="comment">/* requested events */</span></span><br><span class="line">               <span class="type">short</span> revents;    <span class="comment">/* returned events */</span></span><br><span class="line">           &#125;;</span><br></pre></td></tr></table></figure>



<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">// The structure for two events</span></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">pollfd</span> fds[<span class="number">2</span>];</span><br><span class="line"></span><br><span class="line"><span class="comment">// Monitor sock1 for input</span></span><br><span class="line">fds[<span class="number">0</span>].fd = sock1;</span><br><span class="line">fds[<span class="number">0</span>].events = POLLIN;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Monitor sock2 for output</span></span><br><span class="line">fds[<span class="number">1</span>].fd = sock2;</span><br><span class="line">fds[<span class="number">1</span>].events = POLLOUT;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Wait 10 seconds</span></span><br><span class="line"><span class="type">int</span> ret = <span class="built_in">poll</span>( &amp;fds, <span class="number">2</span>, <span class="number">10000</span> );</span><br><span class="line"><span class="comment">// Check if poll actually succeed</span></span><br><span class="line"><span class="keyword">if</span> ( ret == <span class="number">-1</span> )</span><br><span class="line">    <span class="comment">// report error and abort</span></span><br><span class="line"><span class="keyword">else</span> <span class="keyword">if</span> ( ret == <span class="number">0</span> )</span><br><span class="line">    <span class="comment">// timeout; no event detected</span></span><br><span class="line"><span class="keyword">else</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">// If we detect the event, zero it out so we can reuse the structure</span></span><br><span class="line">    <span class="keyword">if</span> ( fds[<span class="number">0</span>].revents &amp; POLLIN )</span><br><span class="line">        fds[<span class="number">0</span>].revents = <span class="number">0</span>;</span><br><span class="line">        <span class="comment">// input event on sock1</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> ( fds[<span class="number">1</span>].revents &amp; POLLOUT )</span><br><span class="line">        fds[<span class="number">1</span>].revents = <span class="number">0</span>;</span><br><span class="line">        <span class="comment">// output event on sock2</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="2-3比较"><a href="#2-3比较" class="headerlink" title="2.3比较"></a>2.3比较</h3><p><strong>1. 功能</strong></p>
<p>select 和 poll 的功能基本相同，不过在一些实现细节上有所不同。</p>
<ul>
<li>select 会修改描述符，而 poll 不会；</li>
<li>select 的描述符类型使用数组实现，FD_SETSIZE 大小默认为 1024，因此默认只能监听少于 1024 个描述符。如果要监听更多描述符的话，需要修改 FD_SETSIZE 之后重新编译；而 poll 没有描述符数量的限制；</li>
<li>poll 提供了更多的事件类型，并且对描述符的重复利用上比 select 高。</li>
<li>如果一个线程对某个描述符调用了 select 或者 poll，另一个线程关闭了该描述符，会导致调用结果不确定。</li>
</ul>
<p><strong>2. 速度</strong></p>
<p>select 和 poll 速度都比较慢，每次调用都需要将全部描述符从应用进程缓冲区复制到内核缓冲区。</p>
<p><strong>3. 可移植性</strong></p>
<p>几乎所有的系统都支持 select，但是只有比较新的系统支持 poll。</p>
<h3 id="2-4epoll"><a href="#2-4epoll" class="headerlink" title="2.4epoll"></a>2.4epoll</h3><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span> <span class="title">epoll_create</span><span class="params">(<span class="type">int</span> size)</span></span>;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">epoll_ctl</span><span class="params">(<span class="type">int</span> epfd, <span class="type">int</span> op, <span class="type">int</span> fd, <span class="keyword">struct</span> epoll_event *event)</span>；</span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">epoll_wait</span><span class="params">(<span class="type">int</span> epfd, <span class="keyword">struct</span> epoll_event * events, <span class="type">int</span> maxevents, <span class="type">int</span> timeout)</span></span>;</span><br></pre></td></tr></table></figure>



<p>epoll_ctl() 用于向内核注册新的描述符或者是改变某个文件描述符的状态。已注册的描述符在内核中会被维护在一棵红黑树上，通过回调函数内核会将 I&#x2F;O 准备好的描述符加入到一个链表中管理，进程调用 epoll_wait() 便可以得到事件完成的描述符。</p>
<p>从上面的描述可以看出，epoll 只需要将描述符从进程缓冲区向内核缓冲区拷贝一次，并且进程不需要通过轮询来获得事件完成的描述符。</p>
<p>epoll 仅适用于 Linux OS。</p>
<p>epoll 比 select 和 poll 更加灵活而且没有描述符数量限制。</p>
<p>epoll 对多线程编程更有友好，一个线程调用了 epoll_wait() 另一个线程关闭了同一个描述符也不会产生像 select 和 poll 的不确定情况。</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">// Create the epoll descriptor. Only one is needed per app, and is used to monitor all sockets.</span></span><br><span class="line"><span class="comment">// The function argument is ignored (it was not before, but now it is), so put your favorite number here</span></span><br><span class="line"><span class="type">int</span> pollingfd = <span class="built_in">epoll_create</span>( <span class="number">0xCAFE</span> );</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> ( pollingfd &lt; <span class="number">0</span> )</span><br><span class="line"> <span class="comment">// report error</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// Initialize the epoll structure in case more members are added in future</span></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">epoll_event</span> ev = &#123; <span class="number">0</span> &#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Associate the connection class instance with the event. You can associate anything</span></span><br><span class="line"><span class="comment">// you want, epoll does not use this information. We store a connection class pointer, pConnection1</span></span><br><span class="line">ev.data.ptr = pConnection1;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Monitor for input, and do not automatically rearm the descriptor after the event</span></span><br><span class="line">ev.events = EPOLLIN | EPOLLONESHOT;</span><br><span class="line"><span class="comment">// Add the descriptor into the monitoring list. We can do it even if another thread is</span></span><br><span class="line"><span class="comment">// waiting in epoll_wait - the descriptor will be properly added</span></span><br><span class="line"><span class="keyword">if</span> ( <span class="built_in">epoll_ctl</span>( epollfd, EPOLL_CTL_ADD, pConnection1-&gt;<span class="built_in">getSocket</span>(), &amp;ev ) != <span class="number">0</span> )</span><br><span class="line">    <span class="comment">// report error</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// Wait for up to 20 events (assuming we have added maybe 200 sockets before that it may happen)</span></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">epoll_event</span> pevents[ <span class="number">20</span> ];</span><br><span class="line"></span><br><span class="line"><span class="comment">// Wait for 10 seconds, and retrieve less than 20 epoll_event and store them into epoll_event array</span></span><br><span class="line"><span class="type">int</span> ready = <span class="built_in">epoll_wait</span>( pollingfd, pevents, <span class="number">20</span>, <span class="number">10000</span> );</span><br><span class="line"><span class="comment">// Check if epoll actually succeed</span></span><br><span class="line"><span class="keyword">if</span> ( ret == <span class="number">-1</span> )</span><br><span class="line">    <span class="comment">// report error and abort</span></span><br><span class="line"><span class="keyword">else</span> <span class="keyword">if</span> ( ret == <span class="number">0</span> )</span><br><span class="line">    <span class="comment">// timeout; no event detected</span></span><br><span class="line"><span class="keyword">else</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">// Check if any events detected</span></span><br><span class="line">    <span class="keyword">for</span> ( <span class="type">int</span> i = <span class="number">0</span>; i &lt; ready; i++ )</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span> ( pevents[i].events &amp; EPOLLIN )</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="comment">// Get back our connection pointer</span></span><br><span class="line">            Connection * c = (Connection*) pevents[i].data.ptr;</span><br><span class="line">            c-&gt;<span class="built_in">handleReadEvent</span>();</span><br><span class="line">         &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h3 id="2-5工作模式"><a href="#2-5工作模式" class="headerlink" title="2.5工作模式"></a>2.5工作模式</h3><p>epoll 的描述符事件有两种触发模式：LT（level trigger）和 ET（edge trigger）。</p>
<p><strong>1. LT 模式</strong></p>
<p>当 epoll_wait() 检测到描述符事件到达时，将此事件通知进程，进程可以不立即处理该事件，下次调用 epoll_wait() 会再次通知进程。是默认的一种模式，并且同时支持 Blocking 和 No-Blocking。</p>
<p><strong>2. ET 模式</strong></p>
<p>和 LT 模式不同的是，通知之后进程必须立即处理事件，下次再调用 epoll_wait() 时不会再得到事件到达的通知。</p>
<p>很大程度上减少了 epoll 事件被重复触发的次数，因此效率要比 LT 模式高。只支持 No-Blocking，以避免由于一个文件句柄的阻塞读&#x2F;阻塞写操作把处理多个文件描述符的任务饿死。</p>
<h3 id="2-6应用场景"><a href="#2-6应用场景" class="headerlink" title="2.6应用场景"></a>2.6应用场景</h3><p>很容易产生一种错觉认为只要用 epoll 就可以了，select 和 poll 都已经过时了，其实它们都有各自的使用场景。</p>
<p><strong>select 应用场景</strong></p>
<p>select 的 timeout 参数精度为微秒，而 poll 和 epoll 为毫秒，因此 select 更加适用于实时性要求比较高的场景，比如核反应堆的控制。</p>
<p>select 可移植性更好，几乎被所有主流平台所支持。</p>
<p><strong>poll 应用场景</strong></p>
<p>poll 没有最大描述符数量的限制，如果平台支持并且对实时性要求不高，应该使用 poll 而不是 select。</p>
<p><strong>epoll 应用场景</strong></p>
<p>只需要运行在 Linux 平台上，有大量的描述符需要同时轮询，并且这些连接最好是长连接。</p>
<p>需要同时监控小于 1000 个描述符，就没有必要使用 epoll，因为这个应用场景下并不能体现 epoll 的优势。</p>
<p>需要监控的描述符状态变化多，而且都是非常短暂的，也没有必要使用 epoll。因为 epoll 中的所有描述符都存储在内核中，造成每次需要对描述符的状态改变都需要通过 epoll_ctl() 进行系统调用，频繁系统调用降低效率。并且 epoll 的描述符存储在内核，不容易调试。</p>
<hr>
<p>版权声明：本文为知乎博主「玩转Linux内核」的原创文章，遵循CC 4.0 BY-SA版权协议，转载请附上原文出处链接及本声明。<br>原文链接：<a href="https://zhuanlan.zhihu.com/p/477292559">https://zhuanlan.zhihu.com/p/477292559</a></p>
]]></content>
      <categories>
        <category>linux-doc</category>
      </categories>
      <tags>
        <tag>Linux</tag>
      </tags>
  </entry>
  <entry>
    <title>Linux内核编译与开发</title>
    <url>/2023/01/15/linux-docs/Linux%E5%86%85%E6%A0%B8%E7%BC%96%E8%AF%91%E4%B8%8E%E5%BC%80%E5%8F%91/</url>
    <content><![CDATA[<h2 id="1、Linux内核简介"><a href="#1、Linux内核简介" class="headerlink" title="1、Linux内核简介"></a><strong>1、Linux内核简介</strong></h2><p><strong>linux kernel map：</strong></p>
<p><img src="https://pic3.zhimg.com/80/v2-6bacced1d82334518e1b3ef705d840d2_720w.webp" alt="img"></p>
<p><strong>linux 系统体系结构：</strong></p>
<p><img src="https://pic1.zhimg.com/80/v2-7cc8b2e7574aed2dab109c6accdfa9a8_720w.webp" alt="img"></p>
<p><strong>linux kernel体系结构：</strong><br>arm有7种工作模式，x86也实现了4个不同级别RING0-RING3,RING0级别最高，<br>这样linux用户代码运行在RING3下，内核运行在RING0,这样系统本身就得到了<br>充分的保护</p>
<p><strong>用户空间(用户模式)转到内核空间(系统模式)方法：</strong><br>·系统调用<br>·硬件中断</p>
<p><strong>linux kernel 体系结构：</strong></p>
<p><img src="https://pic1.zhimg.com/80/v2-751fa81f9b734d40245468e86b84ce4c_720w.webp" alt="img"></p>
<p><strong>虚拟文件系统VFS:</strong><br>VFS(虚拟文件系统)隐藏各种文件系统的具体细节，为文件操作提供统一的接口</p>
<h2 id="2、Linux内核源代码"><a href="#2、Linux内核源代码" class="headerlink" title="2、Linux内核源代码"></a><strong>2、Linux内核源代码</strong></h2><p>linux内核下载***<a href="https://link.zhihu.com/?target=http://www.kernel.org">http://www.kernel.org</a>***<br><strong>目录结构:</strong><br>解压linux kernel tar后目录<br>·arch:根据cpu体系结构不同而分的代码<br>·block:部分块设备驱动程序<br>·crypto:加密，压缩，CRC校验算法<br>·documentation:内核文档<br>·drivers:设备驱动程序<br>·fs(虚拟文件系统vfs):文件系统<br>·include:内核所需的头文件，(与平台无关的头文件在include&#x2F;linux中)<br>·lib:库文件代码(与平台相关的)<br>·mm:实现内存管理，与硬件体系结构无关的(与硬件体系结构相关的在arch中)<br>·net:网络协议的代码<br>·samples:一些内核编程的范例<br>·scripts:配置内核的脚本<br>·security:SElinux的模块<br>·sound:音频设备的驱动程序<br>·usr:cpio命令实现，用于制作根文件系统的命令(文件系统与内核放到一块的命令)<br>·virt:内核虚拟机</p>
<p><strong>linux DOC 编译生成:</strong></p>
<p>linux源根目录&#x2F;Documentation&#x2F;00-INDEX:目录索引<br>linux源根目录&#x2F;Documentation&#x2F;HOWTO:指南<br>·生成linux内核帮助文档:在linux源根目录(Documentation) 执行make htmldocs</p>
<p>ubuntu16下需要执行sudo apt-get install xmlto安装插件才可生成doc文档</p>
<p>后面开发中经常要改的是arch，drivers中的代码</p>
<h2 id="3、Linux内核配置与编译"><a href="#3、Linux内核配置与编译" class="headerlink" title="3、Linux内核配置与编译"></a><strong>3、Linux内核配置与编译</strong></h2><p><strong>清理文件(在linux源码根目录):</strong><br>·make clean:只清理所有产生的文件<br>·make mrproper:清理所有产生的文件与config配置文件<br>·make distclean:清理所有产生的文件与config配置文件，并且编辑过的与补丁文件<br>↓<br><strong>配置(收集硬件信息如cpu型号，网卡等…):</strong><br>·make config:基于文本模式的交互配置<br>·make menuconfig:基于文本模式的菜单模式(推荐使用)<br>·make oldconfig:使用已有的.config,但会询问新增的配置项<br>·make xconfig:图形化的配置(需要安装图形化系统)<br><strong>配置方法：</strong><br>1)使用make menuconfig操作方法：<br>1&gt;按y:编译&gt;连接&gt;镜像文件<br>2&gt;按m:编译<br>3&gt;按n:什么都不做<br>4&gt;按”空格键”:y,n轮换<br>配置完并保存后会在linux源码根目录下生成一个.config文件<br>注意：在ubuntu11上要执行apt-get install libncurses5-dev来安装支持包<br>2)利用已有的配置文件模板(.config)<br>1&gt;linux源码根目录&#x2F;arch&#x2F;&lt;cpu架构&gt;&#x2F;configs&#x2F;&lt;具体某一的CPU文件&gt;，把里面对应的文件copy并改名为.config至linux源码根目录下<br>2&gt;利用当前运行已有的文件(要用ls &#x2F;boot&#x2F; -a查看)把&#x2F;boot&#x2F;config-2.6.18-53.e15拷贝并改名为.config至linux源码根目录下执行以上操作就可以用make menuconfig在拷贝<br>.config文件上面修改文件了<br>↓<br><strong>编译内核:</strong><br>1)make zImage<br>2)make bzImage<br>区别:在X86平台上，zimage只能用于小于512k的内核<br>获取详细编译信息：make zimage V&#x3D;1 或 make bzimage V&#x3D;1<br>编译好的内核在：arch&#x2F;<cpu>&#x2F;boot&#x2F;目录下<br>注意：在把.config配置文件cp到根目录编译内核前，必须进入make menuconfig并保存退出(否则生不了效)<br>↓<br><strong>编译并安装模块:</strong></p>
<p>1)编译内核模块:make modules<br>2)安装内核模块:make modules_install INSTALL_MOD_PATH&#x3D;&#x2F;lib&#x2F;modules<br>更换本机器内核:将编译好的内核模块从内核源码目录copy至&#x2F;lib&#x2F;modules下<br>制作init ramdisk():输入执行命令mkinitrd initrd-2.6.39(任意) 2.6.39(可通过查询&#x2F;lib&#x2F;modules下的目录得到)<br>注意：<br>mkinitrd命令为redhat里面的,ubuntu的命令为:mkinitramfs -k &#x2F;lib&#x2F;modules&#x2F;模块安装位置 -o initrd-2.6.39(任意) 2.6.39(可通过查询&#x2F;lib&#x2F;modules下的目录得到)<br>如果ubuntu里面没有mkinitramfs命令可以用apt-get install initrd-tools进行安装<br>↓<br><strong>安装内核模块:</strong><br>1)手动<br>1&gt;cp linux根目录&#x2F;arch&#x2F;x86&#x2F;boot&#x2F;bzImage &#x2F;boot&#x2F;mylinux-2.6.39<br>2&gt;cp linux根目录&#x2F;initrd-2.6.39 &#x2F;boot&#x2F;initrd-2.6.39<br>最后修改&#x2F;etc&#x2F;grub.conf或&#x2F;etc&#x2F;lilo.conf文件<br>2)自动<br>1&gt;make install:这个命令会自动完成上面的操作(查看当前内核版本：uname -r)<br>-—————————————————————————-</p>
<h2 id="4、linux内核模块开发"><a href="#4、linux内核模块开发" class="headerlink" title="4、linux内核模块开发"></a><strong>4、linux内核模块开发</strong></h2><p>描述：<br>linux内核组件非常庞大，内核ximage并不包含某组件，而是在该组件需要被使用的时候，动态的添加到正在运行的内核中(也可以卸载)，这种机制叫做“内核模块”的机制。内核模块通常通过使用makefile文件对模块进行编译</p>
<p><strong>模块安装与卸载:</strong><br>1)加载：insmod hello.ko<br>2)卸载：rmmod hello<br>3)查看：lsmod<br>4)加载(自动寻找模块依赖)：modprobe hello<br>modprobe会根据文件&#x2F;lib&#x2F;modules&#x2F;version&#x2F;modules.dep来查看要加载的模块，看它是否还依赖于其他模块，如果是,会先找到这些模块，把它们先加载到内核</p>
<p><strong>实例分析：</strong><br>1)moduleDep&#x2F;1(一个模块的编译)</p>
<figure class="highlight text"><table><tr><td class="code"><pre><span class="line">#include &lt;linux/module.h&gt;</span><br><span class="line">#include &lt;linux/init.h&gt;</span><br><span class="line"></span><br><span class="line">//模块入口函数</span><br><span class="line">//__init:表示代码段中的子段,里面的内容只运行一次并且回收内存.</span><br><span class="line">static int __init hello_init(void)</span><br><span class="line">&#123;</span><br><span class="line">    printk(KERN_EMERG &quot;hello world!\n&quot;);</span><br><span class="line">    return 0;</span><br><span class="line">&#125;</span><br><span class="line">//模块卸载函数</span><br><span class="line">//__exit:</span><br><span class="line">static void __exit hello_exit(void)</span><br><span class="line">&#123;</span><br><span class="line">    printk(KERN_EMERG &quot;hello exit!\n&quot;);</span><br><span class="line">&#125;</span><br><span class="line">//内核符号导出 函数</span><br><span class="line">int add_integar(int a,int b)</span><br><span class="line">&#123;</span><br><span class="line">    return a+b;</span><br><span class="line">&#125;</span><br><span class="line">int sub_integar(int a,int b)</span><br><span class="line">&#123;</span><br><span class="line">    return a-b;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">module_init(hello_init);</span><br><span class="line">module_exit(hello_exit);</span><br><span class="line">//函数导出</span><br><span class="line">EXPORT_SYMBOL(add_integar);</span><br><span class="line">EXPORT_SYMBOL(sub_integar);</span><br></pre></td></tr></table></figure>

<p>makefile:</p>
<figure class="highlight text"><table><tr><td class="code"><pre><span class="line">#第一次执行KERNELRELEASE是空的,所以执行else里面的</span><br><span class="line">ifneq ($(KERNELRELEASE),)</span><br><span class="line"></span><br><span class="line">obj-m :=hello.o</span><br><span class="line"></span><br><span class="line">#else块</span><br><span class="line">else</span><br><span class="line"></span><br><span class="line">KDIR:= /lib/modules/2.6.18-53.el5/build</span><br><span class="line"></span><br><span class="line">all:</span><br><span class="line">#KDIR    依赖内核模块源代码路径(内核编译安装路径)</span><br><span class="line">#PWD     表示内核代码在哪(当前目录)</span><br><span class="line">#modules 编译的是模块</span><br><span class="line">    make -C $(KDIR) M=$(PWD) modules </span><br><span class="line"></span><br><span class="line">clean:</span><br><span class="line">    rm -f *.ko *.o *.mod.o *.mod.c *.symvers *.order</span><br><span class="line"></span><br><span class="line">endif</span><br></pre></td></tr></table></figure>

<p>2)moduleDep&#x2F;2(两个模块的编译)</p>
<figure class="highlight text"><table><tr><td class="code"><pre><span class="line">#include &lt;linux/module.h&gt;</span><br><span class="line">#include &lt;linux/init.h&gt;</span><br><span class="line">//模块可选信息</span><br><span class="line">MODULE_LICENSE(&quot;GPL&quot;);//许可证声明</span><br><span class="line">MODULE_AUTHOR(&quot;liyuan&quot;);//作者声明</span><br><span class="line">MODULE_DESCRIPTION(&quot;This module is a param example.&quot;);//模块描述</span><br><span class="line">MODULE_VERSION(&quot;V1.0&quot;);//模块别名</span><br><span class="line">MODULE_ALIAS(&quot;a simple module&quot;);//模块别名</span><br><span class="line"></span><br><span class="line">//模块参数</span><br><span class="line">static char *name = &quot;liyuan arg&quot;;</span><br><span class="line">static int age = 30;</span><br><span class="line">//S_IRUGO是参数权限，也可以用数字</span><br><span class="line">module_param(age,int,S_IRUGO);</span><br><span class="line">module_param(name,charp,S_IRUGO);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">//使用外部文件函数</span><br><span class="line">extern int add(int a,int b);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">//声明 外部内核符号 函数</span><br><span class="line">extern int add_integar(int a,int b);</span><br><span class="line">extern int sub_integar(int a,int b);</span><br><span class="line"></span><br><span class="line">static int __init mains_init(void)</span><br><span class="line">&#123;</span><br><span class="line">     //多文件编译</span><br><span class="line"></span><br><span class="line">    printk(KERN_EMERG&quot;param hi&quot;);</span><br><span class="line">    int vle=add(1,2);</span><br><span class="line">    printk(KERN_EMERG&quot;add value:%d\n&quot;,vle);</span><br><span class="line">    //模块参数</span><br><span class="line"></span><br><span class="line">     printk(KERN_EMERG&quot; name : %s\n&quot;,name);</span><br><span class="line">     printk(KERN_EMERG&quot; age : %d\n&quot;,age);</span><br><span class="line"></span><br><span class="line">    //使用其他模块的函数(内核符号导出)</span><br><span class="line">    int adds=add_integar(3,1);</span><br><span class="line">    int subs=sub_integar(3,1);</span><br><span class="line">    printk(KERN_EMERG&quot; add_integar : %d\n&quot;,adds);</span><br><span class="line">    printk(KERN_EMERG&quot; sub_integar : %d\n&quot;,subs);</span><br><span class="line">    return 0;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">static void __exit mains_exit(void)</span><br><span class="line">&#123;</span><br><span class="line">    printk(&quot;param exit!&quot;);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">module_init(mains_init);</span><br><span class="line">module_exit(mains_exit);</span><br></pre></td></tr></table></figure>

<p>add.c</p>
<figure class="highlight text"><table><tr><td class="code"><pre><span class="line">int add(int a,int b)</span><br><span class="line">&#123;</span><br><span class="line">    return a+b;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>makefile</p>
<figure class="highlight text"><table><tr><td class="code"><pre><span class="line">ifneq ($(KERNELRELEASE),)</span><br><span class="line">#两个以上内核源文件 生成单独的内核模块名ma</span><br><span class="line"></span><br><span class="line">#内核ma</span><br><span class="line">obj-m :=ma.o</span><br><span class="line">#下面的ma-objs前面必须和上面一样为ma</span><br><span class="line">ma-objs := mains.o add.o</span><br><span class="line"></span><br><span class="line">else</span><br><span class="line"></span><br><span class="line">KDIR:= /lib/modules/2.6.18-53.el5/build</span><br><span class="line"></span><br><span class="line">all:</span><br><span class="line">        make -C $(KDIR) M=$(PWD) modules </span><br><span class="line">clean:</span><br><span class="line">    rm -f *.ko *.o *.mod.o *.mod.c *.symvers *.order</span><br><span class="line"></span><br><span class="line">endif</span><br></pre></td></tr></table></figure>

<p><strong>运行带参模块</strong>：insmod hello.ko name&#x3D;yuan age&#x3D;12<br>内核符号导出(&#x2F;proc&#x2F;kallsyms记录了内核中所有导出的符号的名字与地址):<br>一个内核模块的运行依赖另一个内核模块的函数实现，必须先运行第一个内核模块，这样就需要进行内核符号导出。</p>
<p><strong>注意：</strong><br>错误信息:disagrees about version of symbol struct_module insmod:error inserting …<br>开发内核模块时会出现，内核模块不匹配的情况.是你当前运行的linux内核与编译连接所依赖的<br>内核版本不匹配，解决方法：<br>·使用modprobe –force-modversion强行插入<br>·可使用uname -r进行查看当前运行的内核版本</p>
<p><strong>printk内核打印:</strong><br>在&lt;linux&#x2F;kernel.h&gt;中printk有8个优先级，按优先级递减的是：<br>·KERN_EMERG 0<br>用于紧急的消息，常常是那些崩溃的消息<br>·KERN_ALERT 1<br>需要立刻行动的消息<br>·KERN_CRIT 2<br>严重情况<br>·KERN_ERR 3<br>错误情况<br>·KERN_WARNING(printk默认级别) 4<br>有问题的警告<br>·KERN_NOTICE 5<br>正常情况，但是仍然值得注意<br>·KERN_INFO 6<br>信息消息<br>·KERN_DEBUG 7<br>用作调试消息</p>
<p>不管是哪个级别的都会在&#x2F;var&#x2F;log&#x2F;messages里面打印出来(messages可以删除后，运行内核进行测试内核打印情况)控制台打印(优先级配置&#x2F;proc&#x2F;sys&#x2F;kernel&#x2F;printk)</p>
<p>6 4 1 7<br>·Console_loglevel<br>·Default_message_loglevel<br>·Minimum_console_level<br>·Default_console_loglevel</p>
<p>在vm+redhat安装2.6.39内核时出现的错误<br>启动时报could not find filesystem ‘&#x2F;dev&#x2F;root’<br>解决方法<br>a.通过make menuconfig选中以下对应的选项<br>General setup –&gt;<br>[<em>] enable deprecated sysfs features to support old userspace tools<br>成功时下面那个也</em>了的<br>b.修改.config文件<br>修改.config文件中CONFIG_SYSFS_DEPRECATED_V2，将原本被注释掉的<br>CONFIG_SYSFS_DEPRECATED_V2 改成CONFIG_SYSFS_DEPRECATED_V2&#x3D;y</p>
<hr>
<p>版权声明：本文为知乎博主「<a href="https://www.zhihu.com/people/linuxwang-xian-sheng">极致Linux内核</a>」的原创文章，遵循CC 4.0 BY-SA版权协议，转载请附上原文出处链接及本声明。</p>
<p>原文链接：<a href="https://zhuanlan.zhihu.com/p/549065925">https://zhuanlan.zhihu.com/p/549065925</a></p>
]]></content>
      <categories>
        <category>linux-doc</category>
      </categories>
      <tags>
        <tag>Linux</tag>
      </tags>
  </entry>
  <entry>
    <title>Linux内核虚拟文件系统</title>
    <url>/2023/01/15/linux-docs/Linux%E5%86%85%E6%A0%B8%E8%99%9A%E6%8B%9F%E6%96%87%E4%BB%B6%E7%B3%BB%E7%BB%9F/</url>
    <content><![CDATA[<h2 id="1、虚拟文件系统的作用"><a href="#1、虚拟文件系统的作用" class="headerlink" title="1、虚拟文件系统的作用"></a><strong>1、虚拟文件系统的作用</strong></h2><p>虚拟文件系统(VFS)是linux内核和存储设备之间的抽象层，主要有以下好处。</p>
<p>- 简化了应用程序的开发：应用通过统一的系统调用访问各种存储介质</p>
<p>- 简化了新文件系统加入内核的过程：新文件系统只要实现VFS的各个接口即可，不需要修改内核部分</p>
<h2 id="2、虚拟文件系统的4个主要对象"><a href="#2、虚拟文件系统的4个主要对象" class="headerlink" title="2、虚拟文件系统的4个主要对象"></a><strong>2、虚拟文件系统的4个主要对象</strong></h2><p>虚拟文件中的4个主要对象，具体每个对象的含义参见如下的详细介绍。</p>
<h3 id="2-1超级块"><a href="#2-1超级块" class="headerlink" title="2.1超级块"></a><strong>2.1超级块</strong></h3><p>超级块(super_block)主要存储文件系统相关的信息，这是个针对文件系统级别的概念。</p>
<p>它一般存储在磁盘的特定扇区中，但是对于那些基于内存的文件系统(比如proc,sysfs)，超级块是在使用时创建在内存中的。</p>
<p>超级块的定义在<em>：&lt;linux&#x2F;fs.h&gt;</em></p>
<figure class="highlight text"><table><tr><td class="code"><pre><span class="line">/* </span><br><span class="line"> * 超级块结构中定义的字段非常多，</span><br><span class="line"> * 这里只介绍一些重要的属性</span><br><span class="line"> */</span><br><span class="line">struct super_block &#123;</span><br><span class="line">    struct list_head    s_list;               /* 指向所有超级块的链表 */</span><br><span class="line">    const struct super_operations    *s_op; /* 超级块方法 */</span><br><span class="line">    struct dentry        *s_root;           /* 目录挂载点 */</span><br><span class="line">    struct mutex        s_lock;            /* 超级块信号量 */</span><br><span class="line">    int            s_count;                   /* 超级块引用计数 */</span><br><span class="line"></span><br><span class="line">    struct list_head    s_inodes;           /* inode链表 */</span><br><span class="line">    struct mtd_info        *s_mtd;            /* 存储磁盘信息 */</span><br><span class="line">    fmode_t            s_mode;                /* 安装权限 */</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">/*</span><br><span class="line"> * 其中的 s_op 中定义了超级块的操作方法</span><br><span class="line"> * 这里只介绍一些相对重要的函数</span><br><span class="line"> */</span><br><span class="line">struct super_operations &#123;</span><br><span class="line">       struct inode *(*alloc_inode)(struct super_block *sb); /* 创建和初始化一个索引节点对象 */</span><br><span class="line">    void (*destroy_inode)(struct inode *);                /* 释放给定的索引节点 */</span><br><span class="line"></span><br><span class="line">       void (*dirty_inode) (struct inode *);                 /* VFS在索引节点被修改时会调用这个函数 */</span><br><span class="line">    int (*write_inode) (struct inode *, int);             /* 将索引节点写入磁盘，wait表示写操作是否需要同步 */</span><br><span class="line">    void (*drop_inode) (struct inode *);                  /* 最后一个指向索引节点的引用被删除后，VFS会调用这个函数 */</span><br><span class="line">    void (*delete_inode) (struct inode *);                /* 从磁盘上删除指定的索引节点 */</span><br><span class="line">    void (*put_super) (struct super_block *);             /* 卸载文件系统时由VFS调用，用来释放超级块 */</span><br><span class="line">    void (*write_super) (struct super_block *);           /* 用给定的超级块更新磁盘上的超级块 */</span><br><span class="line">    int (*sync_fs)(struct super_block *sb, int wait);     /* 使文件系统中的数据与磁盘上的数据同步 */</span><br><span class="line">    int (*statfs) (struct dentry *, struct kstatfs *);    /* VFS调用该函数获取文件系统状态 */</span><br><span class="line">    int (*remount_fs) (struct super_block *, int *, char *); /* 指定新的安装选项重新安装文件系统时，VFS会调用该函数 */</span><br><span class="line">    void (*clear_inode) (struct inode *);                 /* VFS调用该函数释放索引节点，并清空包含相关数据的所有页面 */</span><br><span class="line">    void (*umount_begin) (struct super_block *);          /* VFS调用该函数中断安装操作 */</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h3 id="2-2索引节点"><a href="#2-2索引节点" class="headerlink" title="2.2索引节点"></a><strong>2.2索引节点</strong></h3><p>索引节点是VFS中的核心概念，它包含内核在操作文件或目录时需要的全部信息。</p>
<p>一个索引节点代表文件系统中的一个文件(这里的文件不仅是指我们平时所认为的普通的文件，还包括目录，特殊设备文件等等)。</p>
<p>索引节点和超级块一样是实际存储在磁盘上的，当被应用程序访问到时才会在内存中创建。</p>
<p>索引节点定义在<em>：&lt;linux&#x2F;fs.h&gt;</em></p>
<figure class="highlight text"><table><tr><td class="code"><pre><span class="line">/* </span><br><span class="line"> * 索引节点结构中定义的字段非常多，</span><br><span class="line"> * 这里只介绍一些重要的属性</span><br><span class="line"> */</span><br><span class="line">struct inode &#123;</span><br><span class="line">    struct hlist_node    i_hash;     /* 散列表，用于快速查找inode */</span><br><span class="line">    struct list_head    i_list;        /* 索引节点链表 */</span><br><span class="line">    struct list_head    i_sb_list;  /* 超级块链表超级块  */</span><br><span class="line">    struct list_head    i_dentry;   /* 目录项链表 */</span><br><span class="line">    unsigned long        i_ino;      /* 节点号 */</span><br><span class="line">    atomic_t        i_count;        /* 引用计数 */</span><br><span class="line">    unsigned int        i_nlink;    /* 硬链接数 */</span><br><span class="line">    uid_t            i_uid;          /* 使用者id */</span><br><span class="line">    gid_t            i_gid;          /* 使用组id */</span><br><span class="line">    struct timespec        i_atime;    /* 最后访问时间 */</span><br><span class="line">    struct timespec        i_mtime;    /* 最后修改时间 */</span><br><span class="line">    struct timespec        i_ctime;    /* 最后改变时间 */</span><br><span class="line">    const struct inode_operations    *i_op;  /* 索引节点操作函数 */</span><br><span class="line">    const struct file_operations    *i_fop;    /* 缺省的索引节点操作 */</span><br><span class="line">    struct super_block    *i_sb;              /* 相关的超级块 */</span><br><span class="line">    struct address_space    *i_mapping;     /* 相关的地址映射 */</span><br><span class="line">    struct address_space    i_data;         /* 设备地址映射 */</span><br><span class="line">    unsigned int        i_flags;            /* 文件系统标志 */</span><br><span class="line">    void            *i_private;             /* fs 私有指针 */</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">/*</span><br><span class="line"> * 其中的 i_op 中定义了索引节点的操作方法</span><br><span class="line"> * 这里只介绍一些相对重要的函数</span><br><span class="line"> */</span><br><span class="line">struct inode_operations &#123;</span><br><span class="line">    /* 为dentry对象创造一个新的索引节点 */</span><br><span class="line">    int (*create) (struct inode *,struct dentry *,int, struct nameidata *);</span><br><span class="line">    /* 在特定文件夹中寻找索引节点，该索引节点要对应于dentry中给出的文件名 */</span><br><span class="line">    struct dentry * (*lookup) (struct inode *,struct dentry *, struct nameidata *);</span><br><span class="line">    /* 创建硬链接 */</span><br><span class="line">    int (*link) (struct dentry *,struct inode *,struct dentry *);</span><br><span class="line">    /* 从一个符号链接查找它指向的索引节点 */</span><br><span class="line">    void * (*follow_link) (struct dentry *, struct nameidata *);</span><br><span class="line">    /* 在 follow_link调用之后，该函数由VFS调用进行清除工作 */</span><br><span class="line">    void (*put_link) (struct dentry *, struct nameidata *, void *);</span><br><span class="line">    /* 该函数由VFS调用，用于修改文件的大小 */</span><br><span class="line">    void (*truncate) (struct inode *);</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h3 id="2-3目录项"><a href="#2-3目录项" class="headerlink" title="2.3目录项"></a><strong>2.3目录项</strong></h3><p>和超级块和索引节点不同，目录项并不是实际存在于磁盘上的。</p>
<p>在使用的时候在内存中创建目录项对象，其实通过索引节点已经可以定位到指定的文件，</p>
<p>但是索引节点对象的属性非常多，在查找，比较文件时，直接用索引节点效率不高，所以引入了目录项的概念。</p>
<p>路径中的每个部分都是一个目录项，比如路径： &#x2F;mnt&#x2F;cdrom&#x2F;foo&#x2F;bar 其中包含5个目录项，&#x2F; mnt cdrom foo bar</p>
<p>每个目录项对象都有3种状态：被使用，未使用和负状态</p>
<p>- 被使用：对应一个有效的索引节点，并且该对象由一个或多个使用者</p>
<p>- 未使用：对应一个有效的索引节点，但是VFS当前并没有使用这个目录项</p>
<p>- 负状态：没有对应的有效索引节点（可能索引节点被删除或者路径不存在了）</p>
<p>目录项的目的就是提高文件查找，比较的效率，所以访问过的目录项都会缓存在slab中。</p>
<p>slab中缓存的名称一般就是 dentry，可以通过如下命令查看：</p>
<figure class="highlight text"><table><tr><td class="code"><pre><span class="line">[wangyubin@localhost kernel]$ sudo cat /proc/slabinfo | grep dentry</span><br><span class="line">dentry            212545 212625    192   21    1 : tunables    0    0    0 : slabdata  10125  10125      0</span><br></pre></td></tr></table></figure>

<p>目录项定义在<em>：&lt;linux&#x2F;dcache.h&gt;</em></p>
<figure class="highlight text"><table><tr><td class="code"><pre><span class="line">/* 目录项对象结构 */</span><br><span class="line">struct dentry &#123;</span><br><span class="line">    atomic_t d_count;       /* 使用计数 */</span><br><span class="line">    unsigned int d_flags;   /* 目录项标识 */</span><br><span class="line">    spinlock_t d_lock;        /* 单目录项锁 */</span><br><span class="line">    int d_mounted;          /* 是否登录点的目录项 */</span><br><span class="line">    struct inode *d_inode;    /* 相关联的索引节点 */</span><br><span class="line">    struct hlist_node d_hash;    /* 散列表 */</span><br><span class="line">    struct dentry *d_parent;    /* 父目录的目录项对象 */</span><br><span class="line">    struct qstr d_name;         /* 目录项名称 */</span><br><span class="line">    struct list_head d_lru;        /* 未使用的链表 */</span><br><span class="line">    /*</span><br><span class="line">     * d_child and d_rcu can share memory</span><br><span class="line">     */</span><br><span class="line">    union &#123;</span><br><span class="line">        struct list_head d_child;    /* child of parent list */</span><br><span class="line">         struct rcu_head d_rcu;</span><br><span class="line">    &#125; d_u;</span><br><span class="line">    struct list_head d_subdirs;    /* 子目录链表 */</span><br><span class="line">    struct list_head d_alias;    /* 索引节点别名链表 */</span><br><span class="line">    unsigned long d_time;        /* 重置时间 */</span><br><span class="line">    const struct dentry_operations *d_op; /* 目录项操作相关函数 */</span><br><span class="line">    struct super_block *d_sb;    /* 文件的超级块 */</span><br><span class="line">    void *d_fsdata;            /* 文件系统特有数据 */</span><br><span class="line"></span><br><span class="line">    unsigned char d_iname[DNAME_INLINE_LEN_MIN];    /* 短文件名 */</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">/* 目录项相关操作函数 */</span><br><span class="line">struct dentry_operations &#123;</span><br><span class="line">    /* 该函数判断目录项对象是否有效。VFS准备从dcache中使用一个目录项时会调用这个函数 */</span><br><span class="line">    int (*d_revalidate)(struct dentry *, struct nameidata *);</span><br><span class="line">    /* 为目录项对象生成hash值 */</span><br><span class="line">    int (*d_hash) (struct dentry *, struct qstr *);</span><br><span class="line">    /* 比较 qstr 类型的2个文件名 */</span><br><span class="line">    int (*d_compare) (struct dentry *, struct qstr *, struct qstr *);</span><br><span class="line">    /* 当目录项对象的 d_count 为0时，VFS调用这个函数 */</span><br><span class="line">    int (*d_delete)(struct dentry *);</span><br><span class="line">    /* 当目录项对象将要被释放时，VFS调用该函数 */</span><br><span class="line">    void (*d_release)(struct dentry *);</span><br><span class="line">    /* 当目录项对象丢失其索引节点时（也就是磁盘索引节点被删除了），VFS会调用该函数 */</span><br><span class="line">    void (*d_iput)(struct dentry *, struct inode *);</span><br><span class="line">    char *(*d_dname)(struct dentry *, char *, int);</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h3 id="2-4文件对象"><a href="#2-4文件对象" class="headerlink" title="2.4文件对象"></a><strong>2.4文件对象</strong></h3><p>文件对象表示进程已打开的文件，从用户角度来看，我们在代码中操作的就是一个文件对象。</p>
<p>文件对象反过来指向一个目录项对象（目录项反过来指向一个索引节点）</p>
<p>其实只有目录项对象才表示一个已打开的实际文件，虽然一个文件对应的文件对象不是唯一的，但其对应的索引节点和目录项对象却是唯一的。</p>
<p>文件对象的定义在*: &lt;linux&#x2F;fs.h&gt;*</p>
<figure class="highlight text"><table><tr><td class="code"><pre><span class="line">/* </span><br><span class="line"> * 文件对象结构中定义的字段非常多，</span><br><span class="line"> * 这里只介绍一些重要的属性</span><br><span class="line"> */</span><br><span class="line">struct file &#123;</span><br><span class="line">    union &#123;</span><br><span class="line">        struct list_head    fu_list;    /* 文件对象链表 */</span><br><span class="line">        struct rcu_head     fu_rcuhead; /* 释放之后的RCU链表 */</span><br><span class="line">    &#125; f_u;</span><br><span class="line">    struct path        f_path;             /* 包含的目录项 */</span><br><span class="line">    const struct file_operations    *f_op; /* 文件操作函数 */</span><br><span class="line">    atomic_long_t        f_count;        /* 文件对象引用计数 */</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">/*</span><br><span class="line"> * 其中的 f_op 中定义了文件对象的操作方法</span><br><span class="line"> * 这里只介绍一些相对重要的函数</span><br><span class="line"> */</span><br><span class="line">struct file_operations &#123;</span><br><span class="line">    /* 用于更新偏移量指针,由系统调用lleek()调用它 */</span><br><span class="line">    loff_t (*llseek) (struct file *, loff_t, int);</span><br><span class="line">    /* 由系统调用read()调用它 */</span><br><span class="line">    ssize_t (*read) (struct file *, char __user *, size_t, loff_t *);</span><br><span class="line">    /* 由系统调用write()调用它 */</span><br><span class="line">    ssize_t (*write) (struct file *, const char __user *, size_t, loff_t *);</span><br><span class="line">    /* 由系统调用 aio_read() 调用它 */</span><br><span class="line">    ssize_t (*aio_read) (struct kiocb *, const struct iovec *, unsigned long, loff_t);</span><br><span class="line">    /* 由系统调用 aio_write() 调用它 */</span><br><span class="line">    ssize_t (*aio_write) (struct kiocb *, const struct iovec *, unsigned long, loff_t);</span><br><span class="line">    /* 将给定文件映射到指定的地址空间上,由系统调用 mmap 调用它 */</span><br><span class="line">    int (*mmap) (struct file *, struct vm_area_struct *);</span><br><span class="line">    /* 创建一个新的文件对象,并将它和相应的索引节点对象关联起来 */</span><br><span class="line">    int (*open) (struct inode *, struct file *);</span><br><span class="line">    /* 当已打开文件的引用计数减少时,VFS调用该函数 */</span><br><span class="line">    int (*flush) (struct file *, fl_owner_t id);</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h3 id="2-5四个对象之间关系图"><a href="#2-5四个对象之间关系图" class="headerlink" title="2.5四个对象之间关系图"></a><strong>2.5四个对象之间关系图</strong></h3><p>上面分别介绍了4种对象分别的属性和方法,下面用图来展示这4个对象的和VFS之间关系以及4个对象之间的关系。</p>
<p>(这个图是根据我自己的理解画出来的,如果由错误请帮忙指出,谢谢!)</p>
<p><img src="https://pic1.zhimg.com/80/v2-47c81e353571a8203518a88ee90f82b8_720w.webp" alt="img"></p>
<p><img src="https://pic3.zhimg.com/80/v2-16eb8240205240f709b4a18b26d532ae_720w.webp" alt="img"></p>
<h2 id="3、文件系统相关的数据结构"><a href="#3、文件系统相关的数据结构" class="headerlink" title="3、文件系统相关的数据结构"></a><strong>3、文件系统相关的数据结构</strong></h2><p>处理上面4个主要的对象之外，VFS中还有2个专门针对文件系统的2个对象，</p>
<p>- struct file_system_type: 用来描述文件系统的类型（比如ext3,ntfs等等）</p>
<p>- struct vfsmount : 描述一个安装文件系统的实例</p>
<p>file_system_type 结构体位于<em>：&lt;linux&#x2F;fs.h&gt;</em></p>
<figure class="highlight text"><table><tr><td class="code"><pre><span class="line">struct file_system_type &#123;</span><br><span class="line">    const char *name;   /* 文件系统名称 */</span><br><span class="line">    int fs_flags;       /* 文件系统类型标志 */</span><br><span class="line">    /* 从磁盘中读取超级块,并且在文件系统被安装时,在内存中组装超级块对象 */</span><br><span class="line">    int (*get_sb) (struct file_system_type *, int,</span><br><span class="line">               const char *, void *, struct vfsmount *);</span><br><span class="line">    /* 终止访问超级块 */</span><br><span class="line">    void (*kill_sb) (struct super_block *);</span><br><span class="line">    struct module *owner;           /* 文件系统模块 */</span><br><span class="line">    struct file_system_type * next; /* 链表中下一个文件系统类型 */</span><br><span class="line">    struct list_head fs_supers;     /* 超级块对象链表 */</span><br><span class="line"></span><br><span class="line">    /* 下面都是运行时的锁 */</span><br><span class="line">    struct lock_class_key s_lock_key;</span><br><span class="line">    struct lock_class_key s_umount_key;</span><br><span class="line"></span><br><span class="line">    struct lock_class_key i_lock_key;</span><br><span class="line">    struct lock_class_key i_mutex_key;</span><br><span class="line">    struct lock_class_key i_mutex_dir_key;</span><br><span class="line">    struct lock_class_key i_alloc_sem_key;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>每种文件系统,不管由多少个实例安装到系统中,还是根本没有安装到系统中,都只有一个 file_system_type 结构。</p>
<p>当文件系统被实际安装时，会在安装点创建一个 vfsmount 结构体。</p>
<p>结构体代表文件系统的实例，也就是文件系统被安装几次，就会创建几个 vfsmount</p>
<p>vfsmount 的定义参见<em>：&lt;linux&#x2F;mount.h&gt;</em></p>
<figure class="highlight text"><table><tr><td class="code"><pre><span class="line">struct vfsmount &#123;</span><br><span class="line">    struct list_head mnt_hash;      /* 散列表 */</span><br><span class="line">    struct vfsmount *mnt_parent;    /* 父文件系统，也就是要挂载到哪个文件系统 */</span><br><span class="line">    struct dentry *mnt_mountpoint;    /* 安装点的目录项 */</span><br><span class="line">    struct dentry *mnt_root;        /* 该文件系统的根目录项 */</span><br><span class="line">    struct super_block *mnt_sb;        /* 该文件系统的超级块 */</span><br><span class="line">    struct list_head mnt_mounts;    /* 子文件系统链表 */</span><br><span class="line">    struct list_head mnt_child;        /* 子文件系统链表 */</span><br><span class="line">    int mnt_flags;                  /* 安装标志 */</span><br><span class="line">    /* 4 bytes hole on 64bits arches */</span><br><span class="line">    const char *mnt_devname;        /* 设备文件名 e.g. /dev/dsk/hda1 */</span><br><span class="line">    struct list_head mnt_list;      /* 描述符链表 */</span><br><span class="line">    struct list_head mnt_expire;    /* 到期链表的入口 */</span><br><span class="line">    struct list_head mnt_share;        /* 共享安装链表的入口 */</span><br><span class="line">    struct list_head mnt_slave_list;/* 从安装链表 */</span><br><span class="line">    struct list_head mnt_slave;        /* 从安装链表的入口 */</span><br><span class="line">    struct vfsmount *mnt_master;    /* 从安装链表的主人 */</span><br><span class="line">    struct mnt_namespace *mnt_ns;    /* 相关的命名空间 */</span><br><span class="line">    int mnt_id;            /* 安装标识符 */</span><br><span class="line">    int mnt_group_id;        /* 组标识符 */</span><br><span class="line">    /*</span><br><span class="line">     * We put mnt_count &amp; mnt_expiry_mark at the end of struct vfsmount</span><br><span class="line">     * to let these frequently modified fields in a separate cache line</span><br><span class="line">     * (so that reads of mnt_flags wont ping-pong on SMP machines)</span><br><span class="line">     */</span><br><span class="line">    atomic_t mnt_count;         /* 使用计数 */</span><br><span class="line">    int mnt_expiry_mark;        /* 如果标记为到期，则为 True */</span><br><span class="line">    int mnt_pinned;             /* &quot;钉住&quot;进程计数 */</span><br><span class="line">    int mnt_ghosts;             /* &quot;镜像&quot;引用计数 */</span><br><span class="line">#ifdef CONFIG_SMP</span><br><span class="line">    int *mnt_writers;           /* 写者引用计数 */</span><br><span class="line">#else</span><br><span class="line">    int mnt_writers;            /* 写者引用计数 */</span><br><span class="line">#endif</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h2 id="4、进程相关的数据结构"><a href="#4、进程相关的数据结构" class="headerlink" title="4、进程相关的数据结构"></a><strong>4、进程相关的数据结构</strong></h2><p>以上介绍的都是在内核角度看到的 VFS 各个结构，所以结构体中包含的属性非常多。</p>
<p>而从进程的角度来看的话，大多数时候并不需要那么多的属性，所有VFS通过以下3个结构体和进程紧密联系在一起。</p>
<p>- struct files_struct ：由进程描述符中的 files 目录项指向，所有与单个进程相关的信息(比如打开的文件和文件描述符)都包含在其中。</p>
<p>- struct fs_struct ：由进程描述符中的 fs 域指向，包含文件系统和进程相关的信息。</p>
<p>- struct mmt_namespace ：由进程描述符中的 mmt_namespace 域指向。</p>
<p>struct files_struct 位于<em>：&lt;linux&#x2F;fdtable.h&gt;</em></p>
<figure class="highlight text"><table><tr><td class="code"><pre><span class="line">struct files_struct &#123;</span><br><span class="line">    atomic_t count;      /* 使用计数 */</span><br><span class="line">    struct fdtable *fdt; /* 指向其他fd表的指针 */</span><br><span class="line">    struct fdtable fdtab;/* 基 fd 表 */</span><br><span class="line">    spinlock_t file_lock ____cacheline_aligned_in_smp; /* 单个文件的锁 */</span><br><span class="line">    int next_fd;                                       /* 缓存下一个可用的fd */</span><br><span class="line">    struct embedded_fd_set close_on_exec_init;         /* exec()时关闭的文件描述符链表 */</span><br><span class="line">    struct embedded_fd_set open_fds_init;              /* 打开的文件描述符链表 */</span><br><span class="line">    struct file * fd_array[NR_OPEN_DEFAULT];           /* 缺省的文件对象数组 */</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>struct fs_struct 位于<em>：&lt;linux&#x2F;fs_struct.h&gt;</em></p>
<figure class="highlight text"><table><tr><td class="code"><pre><span class="line">struct fs_struct &#123;</span><br><span class="line">    int users;               /* 用户数目 */</span><br><span class="line">    rwlock_t lock;           /* 保护结构体的读写锁 */</span><br><span class="line">    int umask;               /* 掩码 */</span><br><span class="line">    int in_exec;             /* 当前正在执行的文件 */</span><br><span class="line">    struct path root, pwd;   /* 根目录路径和当前工作目录路径 */</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>struct mmt_namespace 位于<em>：&lt;linux&#x2F;mmt_namespace.h&gt;</em></p>
<p>但是在2.6内核之后似乎没有这个结构体了，而是用 struct nsproxy 来代替。</p>
<p>以下是 struct task_struct 结构体中关于文件系统的3个属性。</p>
<p>struct task_struct 的定义位于<em>：&lt;linux&#x2F;sched.h&gt;</em></p>
<figure class="highlight text"><table><tr><td class="code"><pre><span class="line">/* filesystem information */</span><br><span class="line">    struct fs_struct *fs;</span><br><span class="line">/* open file information */</span><br><span class="line">    struct files_struct *files;</span><br><span class="line">/* namespaces */</span><br><span class="line">    struct nsproxy *nsproxy;</span><br></pre></td></tr></table></figure>

<h2 id="5、小结"><a href="#5、小结" class="headerlink" title="5、小结"></a><strong>5、小结</strong></h2><p>VFS 统一了文件系统的实现框架，使得在linux上实现新文件系统的工作变得简单。</p>
<p>目前linux内核中已经支持60多种文件系统，具体支持的文件系统可以查看 内核源码 fs 文件夹下的内容。</p>
<hr>
<p>版权声明：本文为知乎博主「<a href="https://www.zhihu.com/people/linuxwang-xian-sheng">极致Linux内核</a>」的原创文章，遵循CC 4.0 BY-SA版权协议，转载请附上原文出处链接及本声明。</p>
<p>原文链接：<a href="https://zhuanlan.zhihu.com/p/549601357">https://zhuanlan.zhihu.com/p/549601357</a></p>
]]></content>
      <categories>
        <category>linux-doc</category>
      </categories>
      <tags>
        <tag>Linux</tag>
      </tags>
  </entry>
  <entry>
    <title>Linux操作系统ARM体系结构处理器机制原理与实现</title>
    <url>/2023/01/15/linux-docs/Linux%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9FARM%E4%BD%93%E7%B3%BB%E7%BB%93%E6%9E%84%E5%A4%84%E7%90%86%E5%99%A8%E6%9C%BA%E5%88%B6%E5%8E%9F%E7%90%86%E4%B8%8E%E5%AE%9E%E7%8E%B0/</url>
    <content><![CDATA[<h2 id="ARM-的概念"><a href="#ARM-的概念" class="headerlink" title="ARM 的概念"></a>ARM 的概念</h2><p>ARM(Advanced RISC Machine)，既可以认为是一个公司的名字，也可以认为是对一类微处理器的通称，还可以认为是一种技术的名字。<br>ARM 公司并不生产芯片也不销售芯片，它只出售芯片技术授权。其合作公司针对不同需求搭配各类硬件部件，比如 UART、SDI、I2C 等，从而设计出不同的 SoC 芯片。</p>
<h2 id="ARM-的应用场景"><a href="#ARM-的应用场景" class="headerlink" title="ARM 的应用场景"></a>ARM 的应用场景</h2><p>基于 ARM 的处理器具有高速度、低功耗、价格低等优点被广泛应用于以下领域：</p>
<ul>
<li>为通信、消费电子、成像设备等产品，提供可运行复杂操作系统的开放应用平台；</li>
<li>在海量存储、汽车电子、工业控制和网络应用等领域，提供实时嵌入式应用；</li>
<li>安全系统，比如信用卡、SIM 卡等。</li>
</ul>
<h2 id="ARM的技术特征"><a href="#ARM的技术特征" class="headerlink" title="ARM的技术特征"></a>ARM的技术特征</h2><p>ARM 架构支持 32 位的 <strong>ARM 指令集</strong>和 16 位的 <strong>Thumb 指令集</strong>（大大减小了代码的存储空间）。</p>
<p>这里先以一个例子解释一下架构、核、处理器和芯片之间的特征：S3C2440，这是一款SoC芯片，注意，它不是cpu。<br>2440和我们熟知的51单片机有点类似，都属于嵌入式，嵌入式的发展到目前经历了三个阶段，分别是SCM、MCU、SoC。<br>51属于SCM或MCU，而2440就属于SoC了，先来看看51单片机的内部结构。</p>
<p><img src="https://pic1.zhimg.com/80/v2-3902214bd712c07886cec5c0faafd3a4_720w.webp" alt="img"></p>
<p>其内部结构可以简单的分成两部分：cpu和外设。</p>
<p><strong>我们再看一下再来看2440的内部结构：</strong></p>
<p><img src="https://pic2.zhimg.com/80/v2-3c72a4461c239fb5b1f48c4f47337c9d_720w.webp" alt="img"></p>
<p>arm920t就是它的处理器，处理器和核在我看来在这里是一个概念，只不过一个是硬概念，一个是软概念。这里的920t就既是处理器又是核。而三星做的就是除了这个cpu外其他的东西。</p>
<h2 id="RM版本系列"><a href="#RM版本系列" class="headerlink" title="RM版本系列"></a>RM版本系列</h2><p><strong>ARM版本Ⅰ：V1版架构。</strong></p>
<p>该版架构只在原型机ARM1出现过，只有26位的寻址空间，没有用于商业产品。</p>
<p><strong>其基本性能有:</strong></p>
<ul>
<li>基本的数据处理指令（无乘法）；</li>
<li>基于字节、半字和字的Load&#x2F;Store指令;</li>
<li>转移指令，包括子程序调用及链接指令；</li>
<li>供操作系统使用的软件中断指令SWI； 寻址空间：64MB（226）。</li>
</ul>
<p><strong>ARM版本Ⅱ： V2版架构</strong></p>
<p>该版架构对V1版进行了扩展，例如ARM2和ARM3（V2a）架构。包含了对32位乘法指令和协处理器指令的支持。 版本2a是版本2的变种，ARM3芯片采用了版本2a，是第一片采用片上Cache的ARM处理器。同样为26位寻址空间，现在已经废弃不再使用。</p>
<p><strong>V2版架构与版本V1相比，增加了以下功能：</strong></p>
<ul>
<li>乘法和乘加指令；</li>
<li>支持协处理器操作指令；</li>
<li>快速中断模式；</li>
<li>SWP&#x2F;SWPB的最基本存储器与寄存器交换指令;</li>
<li>寻址空间：64MB。</li>
</ul>
<p><strong>ARM版本Ⅲ ： V3版架构</strong></p>
<p>ARM作为独立的公司，在1990年设计的第一个微处理器采用的是版本3的ARM6。它作为IP核、独立的处理器、具有片上高速缓存、MMU和写缓冲的集成CPU。 变种版本有3G和3M。版本3G是不与版本2a向前兼容的版本3，版本3M引入了有符号和无符号数乘法和乘加指令，这些指令产生全部64位结果。</p>
<p><strong>V3版架构（ 目前已废弃 ）对ARM体系结构作了较大的改动：</strong></p>
<ul>
<li>寻址空间增至32位（4GB）；</li>
<li>当前程序状态信息从原来的R15寄存器移到当前程序状态寄存器CPSR（Current Program Status Register）中；</li>
<li>增加了程序状态保存寄存器SPSR（Saved Program Status Register）；</li>
<li>增加了两种异常模式，使操作系统代码可方便地使用数据访问中止异常、指令预取中止异常和未定义指令异常；</li>
<li>增加了MRS&#x2F;MSR指令，以访问新增的CPSR&#x2F;SPSR寄存器；</li>
<li>增加了从异常处理返回的指令功能。</li>
</ul>
<p><strong>ARM版本Ⅳ ： V4版架构</strong></p>
<p>V4版架构在V3版上作了进一步扩充，V4版架构是目前应用最广的ARM体系结构，ARM7、ARM8、ARM9和StrongARM都采用该架构。 V4不再强制要求与26位地址空间兼容，而且还明确了哪些指令会引起未定义指令异常。</p>
<p><strong>指令集中增加了以下功能：</strong></p>
<ul>
<li>符号化和非符号化半字及符号化字节的存&#x2F;取指令；</li>
<li>增加了T变种，处理器可工作在Thumb状态，增加了16位Thumb指令集；</li>
<li>完善了软件中断SWI指令的功能；</li>
<li>处理器系统模式引进特权方式时使用用户寄存器操作;</li>
<li>把一些未使用的指令空间捕获为未定义指令</li>
</ul>
<p><strong>ARM版本Ⅴ ： V5版架构</strong></p>
<p>V5版架构是在V4版基础上增加了一些新的指令，ARM10和Xscale都采用该版架构。</p>
<p><strong>这些新增命令有：</strong></p>
<ul>
<li>带有链接和交换的转移BLX指令；</li>
<li>计数前导零CLZ指令；</li>
<li>BRK中断指令；</li>
<li>增加了数字信号处理指令（V5TE版）；</li>
<li>为协处理器增加更多可选择的指令；</li>
<li>改进了ARM&#x2F;Thumb状态之间的切换效率；</li>
<li>E—增强型DSP指令集，包括全部算法操作和16位乘法操作；</li>
<li>J—-支持新的JAVA，提供字节代码执行的硬件和优化软件加速功能。</li>
</ul>
<p><strong>ARM版本Ⅵ ： V6版架构</strong></p>
<p>V6版架构是2001年发布的，首先在2002年春季发布的ARM11处理器中使用。在降低耗电量地同时，还强化了图形处理性能。通过追加有效进行多媒体处理的SIMD(Single Instruction, Multiple Data，单指令多数据 )功能，将语音及图像的处理功能提高到了原型机的4倍。</p>
<p><strong>此架构在V5版基础上增加了以下功能：</strong></p>
<ul>
<li>THUMBTM：35%代码压缩；</li>
<li>DSP扩充：高性能定点DSP功能；</li>
<li>JazelleTM：Java性能优化，可提高8倍；</li>
<li>Media扩充：音&#x2F;视频性能优化，可提高4倍</li>
</ul>
<p><strong>ARM版本ⅤⅡ：V7版架构</strong></p>
<p>V7架构是在ARMv6架构的基础上诞生的。该架构采用了Thumb-2技术,它是在ARM的Thumb代码压缩技术的基础上发展起来的, 并且保持了对现存ARM解决方案的完整的代码兼容性。</p>
<p>Thumb-2技术比纯32位代码少使用31％的内存,减小了系统开销。同时能够提供比已有的基于Thumb技术的解决方案高出38％的性能。</p>
<p>ARMv7架构还采用了NEON技术,将DSP和媒体处理能力提高了近4倍 , 并支持改良的浮点运算, 满足下一代3D图形、游戏物理应用以及传统嵌入式控制应用的需求。此外,ARMv7还支持改良的运行环境,以迎合不断增加的JIT(Just In Time)和DAC(DynamicAdaptive Compilation)技术的使用。</p>
<p><strong>ARM版本ⅤⅢ：V8版架构</strong></p>
<p>这是一个新的IP核，针对高性能的嵌入式信号处理应用而设计的，v8架构是在32位ARM架构上进行开发的，将被首先用于对扩展虚拟地址和64位数据处理技术有更高要求的产品领域，如企业应用、高档消费电子产品。</p>
<p>ARMv8架构包含两个执行状态：AArch64和AArch32。AArch64执行状态针对64位处理技术，引入了一个全新指令集A64；而AArch32执行状态将支持现有的ARM指令集。</p>
<p>目前的ARMv7架构的主要特性都将在ARMv8架构中得以保留或进一步拓展，如：TrustZone技术、虚拟化技术及NEON advanced SIMD技术，等。</p>
<p><img src="https://pic3.zhimg.com/80/v2-c25eb8ccafb9e9518fa31f444c42e4de_720w.webp" alt="img"></p>
<p>其中左侧的就是架构，右侧的是处理器，也可以叫核。arm首个最成功的cpu是ARM7TDMI，是基于ARMv4的。ARM架构包含了下述RISC特性：</p>
<ul>
<li>读取&#x2F;储存 架构</li>
<li>不支援地址不对齐内存存取（ARMv6内核现已支援）</li>
<li>正交指令集（任意存取指令可以任意的寻址方式存取数据Orthogonal instruction set）</li>
<li>大量的16 × 32-bit 寄存器阵列（register file）</li>
<li>固定的32 bits 操作码（opcode）长度，降低编码数量所产生的耗费，减轻解码和流水线化的负担。</li>
<li>大多均为一个CPU周期执行。不同版本的架构会有所调整。</li>
</ul>
<p>和三星相同的其他和arm合作的各大厂商通常会把它的CPU和各类外围IP都放到一起，然后自己拿着图纸去流片，生产出来的也是一个正方形，下面有很多引脚，这个东西不仅包含了CPU，还包含了其他的控制器，这个东西就叫做SOC(system on chip)。从英文来看，所谓的四核SOC什么的，本意就不是单指CPU，而是四核系统。</p>
<p>所以目前各大厂商所做的事情，就是买来ARM的授权，得到ARM处理器的源代码，而后自己搞一些外围IP(或者买或者自己设计)，组成一个SOC后，去流片。不同的SOC，架构不同(就是CPU如何和IP联系起来，有的以总线为核心，有的以DDR为核心)，所以，海思是拥有自主产权的SOC架构。可是，无论任何厂商，再怎么折腾，都没有怎么动过CPU，ARM核心就好好的呆在那里，那就是中央处理器。</p>
<p><img src="https://pic4.zhimg.com/80/v2-b8ac9e00374fc700f49bbff716a67c67_720w.webp" alt="img"></p>
<p><strong>理器</strong></p>
<ul>
<li>ARM Cortex-A ：为传统的、基于虚拟存储的操作系统和应用程序而设计，支持 ARM、Thumb 和 Thumb-2 指令集；</li>
<li>ARM Cortex-R：针对实时系统设计，支持 ARM、Thumb 和 Thumb-2 指令集；</li>
<li>ARM Cortex-M：为对 价格敏感的产品设计，只支持 Thumb-2 指令集。</li>
</ul>
<h2 id="ARM命名规则"><a href="#ARM命名规则" class="headerlink" title="ARM命名规则"></a>ARM命名规则</h2><p>第一个数字：系列名称：eg.ARM7、ARM9</p>
<p>第二个数字：Memory system</p>
<figure class="highlight text"><table><tr><td class="code"><pre><span class="line">2：带有MMU</span><br><span class="line"></span><br><span class="line">4：带有MPU</span><br><span class="line"></span><br><span class="line">6：无MMU与MPU</span><br><span class="line">12345</span><br></pre></td></tr></table></figure>

<p>第三个数字：Memory size</p>
<figure class="highlight text"><table><tr><td class="code"><pre><span class="line">0：标准Cache（4-128k）</span><br><span class="line"></span><br><span class="line">2：减小的Cache</span><br><span class="line"></span><br><span class="line">6：可变的Cache</span><br><span class="line">12345</span><br></pre></td></tr></table></figure>

<p>第四个字符：</p>
<figure class="highlight text"><table><tr><td class="code"><pre><span class="line">T：表示支持Thumb指令集</span><br><span class="line"></span><br><span class="line">D：表示支持片上调试（Debug）</span><br><span class="line"></span><br><span class="line">M：表示内嵌硬件乘法器（Multiplier）</span><br><span class="line"></span><br><span class="line">I ：支持片上断点和调试点</span><br><span class="line"></span><br><span class="line">E：表示支持增强型DSP功能</span><br><span class="line"></span><br><span class="line">J ：表示支持Jazelle技术，即Java加速器</span><br><span class="line"></span><br><span class="line">S：表示全合成式</span><br></pre></td></tr></table></figure>

<hr>
<p>版权声明：本文为知乎博主「玩转Linux内核」的原创文章，遵循CC 4.0 BY-SA版权协议，转载请附上原文出处链接及本声明。<br>原文链接：<a href="https://zhuanlan.zhihu.com/p/449582466">https://zhuanlan.zhihu.com/p/449582466</a></p>
]]></content>
      <categories>
        <category>linux-doc</category>
      </categories>
      <tags>
        <tag>Linux</tag>
      </tags>
  </entry>
  <entry>
    <title>Linux操作系统ARM指令集与汇编语言程序设计</title>
    <url>/2023/01/15/linux-docs/Linux%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9FARM%E6%8C%87%E4%BB%A4%E9%9B%86%E4%B8%8E%E6%B1%87%E7%BC%96%E8%AF%AD%E8%A8%80%E7%A8%8B%E5%BA%8F%E8%AE%BE%E8%AE%A1/</url>
    <content><![CDATA[<h2 id="一、实验目的"><a href="#一、实验目的" class="headerlink" title="一、实验目的"></a>一、实验目的</h2><p>1.了解并掌握ARM汇编指令集</p>
<p>2.应用ARM指令集编写一个程序操控开发板上的LED灯</p>
<h2 id="二、实验要求"><a href="#二、实验要求" class="headerlink" title="二、实验要求"></a>二、实验要求</h2><p>应用ARM汇编指令集编写程序，实现正常状态下开发板上的LED灯不亮，按下一个按键之后开发板上的LED灯进入流水灯模式。</p>
<h2 id="三、实验原理"><a href="#三、实验原理" class="headerlink" title="三、实验原理"></a>三、实验原理</h2><p><strong>四个LED灯的电路如下图所示：</strong></p>
<p><img src="https://pic1.zhimg.com/80/v2-614cfeecea624d60bcfd150387828214_720w.webp" alt="img"></p>
<p><img src="https://pic1.zhimg.com/80/v2-614cfeecea624d60bcfd150387828214_720w.webp" alt="img"></p>
<p><strong>四个按键电路图如下所示：</strong></p>
<p><img src="https://pic3.zhimg.com/80/v2-f42013cca1e1d4acbdf4a01b6cf2fc42_720w.webp" alt="img"></p>
<p><img src="https://pic3.zhimg.com/80/v2-82d3485cc2fb992c64a639852770d812_720w.webp" alt="img"></p>
<p><img src="https://pic4.zhimg.com/80/v2-09e73b394ae37b3209c7aa62b448c90f_720w.webp" alt="img"></p>
<p><strong>将LED灯的控制地址放入一个寄存器中，并将其设置为输出模式:</strong></p>
<p><img src="https://pic4.zhimg.com/80/v2-d5010fee1006340b9416d2b9038ab67b_720w.webp" alt="img"></p>
<p><img src="https://pic2.zhimg.com/80/v2-6b960d906551a8fdf50be58d586440d1_720w.webp" alt="img"></p>
<p>把按键控制地址的内容全置零，为输入模式（复位值为0，此步骤可省略）。</p>
<h2 id="四、实验结果"><a href="#四、实验结果" class="headerlink" title="四、实验结果"></a>四、实验结果</h2><p>将生成的二进制代码用烧写脚本烧写到SD卡中，插入开发板的SD卡槽，从SD卡启动，按下按键即开启LED流水灯模式。</p>
<h2 id="五、结果分析"><a href="#五、结果分析" class="headerlink" title="五、结果分析"></a>五、结果分析</h2><p>通过掩码取出按键数据地址中的值的状态来判断按键是否按下，若按下则跳转到LED流水灯的程序当中。</p>
<p>流水灯程序即顺序的程序结构，依次点亮LED灯，延时并熄灭，达到流水效果。</p>
<h2 id="六、附录：实验源代码"><a href="#六、附录：实验源代码" class="headerlink" title="六、附录：实验源代码"></a>六、附录：实验源代码</h2><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">.text</span><br><span class="line">.globl _start</span><br><span class="line">_start:</span><br><span class="line">	<span class="comment">// Set GPM4CON[0:3]as output</span></span><br><span class="line">	ldr r1, =<span class="number">0x110002E0</span> @GPM4CON address 					</span><br><span class="line">	ldr r0, =<span class="number">0x00001111</span></span><br><span class="line">	str r0, [r1]</span><br><span class="line">	<span class="comment">//Set GPX3CON[2:5] as input</span></span><br><span class="line">	ldr r1, =<span class="number">0x11000C60</span> @GPX3CON address</span><br><span class="line">	mov r0, #<span class="number">0</span></span><br><span class="line">	str r0,[r1]			@<span class="keyword">default</span> is input.So,<span class="keyword">this</span> section canbe omitted</span><br><span class="line">Key_led:</span><br><span class="line">	<span class="comment">//Read the state of keys</span></span><br><span class="line">	ldr r1, =<span class="number">0x11000C64</span> @GPX3DAT address-&gt;keys</span><br><span class="line">	ldr r3, =<span class="number">0xFFFFFFC3</span> @Key mask</span><br><span class="line">	ldr r0, [r1] 		@ Read the state of keys</span><br><span class="line">	orr r0, r0,r3		@ get the bits of keys</span><br><span class="line">	mov r0,r0,ROR #<span class="number">2</span>	@ align to the led bits</span><br><span class="line">	cmp r0, #<span class="number">0xFFFFFFFE</span></span><br><span class="line">	beq led_blink</span><br><span class="line">	bl Key_led</span><br><span class="line">led_blink:</span><br><span class="line">	ldr r1, =<span class="number">0x110002E4</span></span><br><span class="line">	mov r0, #<span class="number">0xE</span></span><br><span class="line">	str r0, [r1]</span><br><span class="line">	bl delay</span><br><span class="line">	ldr r1, =<span class="number">0x110002E4</span></span><br><span class="line">	mov r0, #<span class="number">0xD</span></span><br><span class="line">	str r0, [r1]</span><br><span class="line">	bl delay</span><br><span class="line">	ldr r1, =<span class="number">0x110002E4</span></span><br><span class="line">	mov r0, #<span class="number">0xB</span></span><br><span class="line">	str r0, [r1]</span><br><span class="line">	bl delay</span><br><span class="line">	ldr r1, =<span class="number">0x110002E4</span></span><br><span class="line">	mov r0, #<span class="number">0x7</span></span><br><span class="line">	str r0, [r1]</span><br><span class="line">	bl delay</span><br><span class="line">	bl Key_led</span><br><span class="line">delay:</span><br><span class="line">	mov r0, #<span class="number">0x200000</span></span><br><span class="line">delay_loop:</span><br><span class="line">	cmp r0, #<span class="number">0</span></span><br><span class="line">	sub r0, r0, #<span class="number">1</span></span><br><span class="line">	bne delay_loop</span><br><span class="line">	mov pc, lr</span><br></pre></td></tr></table></figure>

<hr>
<p>版权声明：本文为知乎博主「玩转Linux内核」的原创文章，遵循CC 4.0 BY-SA版权协议，转载请附上原文出处链接及本声明。<br>原文链接：<a href="https://zhuanlan.zhihu.com/p/449816076">https://zhuanlan.zhihu.com/p/449816076</a></p>
]]></content>
      <categories>
        <category>linux-doc</category>
      </categories>
      <tags>
        <tag>Linux</tag>
      </tags>
  </entry>
  <entry>
    <title>Linux操作系统IO机制原理(流程图详解)</title>
    <url>/2023/01/15/linux-docs/Linux%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9FIO%E6%9C%BA%E5%88%B6%E5%8E%9F%E7%90%86(%E6%B5%81%E7%A8%8B%E5%9B%BE%E8%AF%A6%E8%A7%A3)/</url>
    <content><![CDATA[<p>前言：我们之前的文章提到了操作系统的三个抽象，它们分别是进程、地址空间和文件，除此之外，操作系统还要控制所有的 I&#x2F;O 设备。操作系统必须向设备发送命令，捕捉中断并处理错误。它还应该在设备和操作系统的其余部分之间提供一个简单易用的接口。操作系统如何管理 I&#x2F;O 是我们接下来的重点。</p>
<p>不同的人对 I&#x2F;O 硬件的理解也不同。对于电子工程师而言，I&#x2F;O 硬件就是芯片、导线、电源和其他组成硬件的物理设备。而我们程序员眼中的 I&#x2F;O 其实就是硬件提供给软件的接口，比如硬件接受到的命令、执行的操作以及反馈的错误。我们着重探讨的是如何对硬件进行编程，而不是其工作原理。</p>
<h2 id="1，I-O-设备"><a href="#1，I-O-设备" class="headerlink" title="1，I&#x2F;O 设备"></a>1，I&#x2F;O 设备</h2><p>什么是 I&#x2F;O 设备？I&#x2F;O 设备又叫做输入&#x2F;输出设备，它是人类用来和计算机进行通信的外部硬件。输入&#x2F;输出设备能够向计算机发送数据（输出）并从计算机接收数据（输入）。</p>
<p>I&#x2F;O 设备(I&#x2F;O devices)可以分成两种：块设备(block devices) 和 字符设备(character devices)。</p>
<h2 id="2，块设备"><a href="#2，块设备" class="headerlink" title="2，块设备"></a>2，块设备</h2><p>块设备是一个能存储固定大小块信息的设备，它支持以固定大小的块，扇区或群集读取和（可选）写入数据。每个块都有自己的物理地址。通常块的大小在 512 - 65536 之间。所有传输的信息都会以连续的块为单位。块设备的基本特征是每个块都较为对立，能够独立的进行读写。常见的块设备有 硬盘、蓝光光盘、USB盘与字符设备相比，块设备通常需要较少的引脚。</p>
<p><img src="https://pic4.zhimg.com/80/v2-103bd5a2722497532b208b3a32728bcf_720w.webp" alt="img"></p>
<h3 id="2-1块设备的缺点"><a href="#2-1块设备的缺点" class="headerlink" title="2.1块设备的缺点"></a>2.1块设备的缺点</h3><p>基于给定固态存储器的块设备比基于相同类型的存储器的字节寻址要慢一些，因为必须在块的开头开始读取或写入。所以，要读取该块的任何部分，必须寻找到该块的开始，读取整个块，如果不使用该块，则将其丢弃。要写入块的一部分，必须寻找到块的开始，将整个块读入内存，修改数据，再次寻找到块的开头处，然后将整个块写回设备。</p>
<p><strong>字符设备</strong></p>
<p>另一类 I&#x2F;O 设备是字符设备。字符设备以字符为单位发送或接收一个字符流，而不考虑任何块结构。字符设备是不可寻址的，也没有任何寻道操作。常见的字符设备有 打印机、网络设备、鼠标、以及大多数与磁盘不同的设备。</p>
<p><img src="https://pic2.zhimg.com/80/v2-f05ebda6e42d4272f0bfe9e443944675_720w.webp" alt="img"></p>
<p><strong>下面显示了一些常见设备的数据速率：</strong></p>
<p><img src="https://pic4.zhimg.com/80/v2-be1dafc6c52d744492cca831dd2cf0b3_720w.webp" alt="img"></p>
<h3 id="2-2设备控制器"><a href="#2-2设备控制器" class="headerlink" title="2.2设备控制器"></a>2.2设备控制器</h3><p>首先需要先了解一下设备控制器的概念：</p>
<p>设备控制器是处理 CPU 传入和传出信号的系统。设备通过插头和插座连接到计算机，并且插座连接到设备控制器。设备控制器从连接的设备处接收数据，并将其存储在控制器内部的一些特殊目的寄存器(special purpose registers) 也就是本地缓冲区中。</p>
<p>特殊用途寄存器，顾名思义是仅为一项任务而设计的寄存器。例如，cs，ds，gs 和其他段寄存器属于特殊目的寄存器，因为它们的存在是为了保存段号。 eax，ecx 等是一般用途的寄存器，因为你可以无限制地使用它们。 例如，你不能移动 ds，但是可以移动 eax，ebx。</p>
<ol>
<li>通用目的寄存器比如有：eax、ecx、edx、ebx、esi、edi、ebp、esp</li>
<li>特殊目的寄存器比如有：cs、ds、ss、es、fs、gs、eip、flag</li>
</ol>
<p>每个设备控制器都会有一个应用程序与之对应，设备控制器通过应用程序的接口通过中断与操作系统进行通信。设备控制器是硬件，而设备驱动程序是软件。</p>
<p>I&#x2F;O 设备通常由机械组件(mechanical component)和电子组件(electronic component)构成。电子组件被称为 设备控制器(device controller)或者 适配器(adapter)。在个人计算机上，它通常采用可插入（PCIe）扩展插槽的主板上的芯片或印刷电路卡的形式。</p>
<p><img src="https://pic3.zhimg.com/80/v2-3d15c55972868c0c3093847c95b373d2_720w.webp" alt="img"></p>
<p><strong>机械设备就是它自己，它的组成如下：</strong></p>
<p><img src="https://pic4.zhimg.com/80/v2-207b863a1b2266e7653405ca9cfcbd7b_720w.webp" alt="img"></p>
<p>控制器卡上通常会有一个连接器，通向设备本身的电缆可以插入到这个连接器中，很多控制器可以操作 2 个、4 个设置 8 个相同的设备。</p>
<p>控制器与设备之间的接口通常是一个低层次的接口。例如，磁盘可能被格式化为 2,000,000 个扇区，每个磁道 512 字节。然而，实际从驱动出来的却是一个串行的比特流，从一个前导符(preamble)开始，然后是一个扇区中的 4096 位，最后是一个校验和 或 ECC（错误码，Error-Correcting Code）。前导符是在对磁盘进行格式化的时候写上去的，它包括柱面数和扇区号，扇区大小以及类似的数据，此外还包含同步信息。</p>
<p>控制器的任务是把串行的位流转换为字节块，并进行必要的错误校正工作。字节块通常会在控制器内部的一个缓冲区按位进行组装，然后再对校验和进行校验并证明字节块没有错误后，再将它复制到内存中。</p>
<h2 id="3，内存映射-I-O"><a href="#3，内存映射-I-O" class="headerlink" title="3，内存映射 I&#x2F;O"></a>3，内存映射 I&#x2F;O</h2><p>每个控制器都会有几个寄存器用来和 CPU 进行通信。通过写入这些寄存器，操作系统可以命令设备发送数据，接收数据、开启或者关闭设备等。通过从这些寄存器中读取信息，操作系统能够知道设备的状态，是否准备接受一个新命令等。</p>
<p>为了控制寄存器，许多设备都会有数据缓冲区(data buffer)，来供系统进行读写。例如，在屏幕上显示一个像素的常规方法是使用一个视频 RAM，这一 RAM 基本上只是一个数据缓冲区，用来供程序和操作系统写入数据。</p>
<p>那么问题来了，CPU 如何与设备寄存器和设备数据缓冲区进行通信呢？存在两个可选的方式。第一种方法是，每个控制寄存器都被分配一个 I&#x2F;O 端口(I&#x2F;O port)号，这是一个 8 位或 16 位的整数。所有 I&#x2F;O 端口的集合形成了受保护的 I&#x2F;O 端口空间，以便普通用户程序无法访问它（只有操作系统可以访问）。使用特殊的 I&#x2F;O 指令像是</p>
<figure class="highlight text"><table><tr><td class="code"><pre><span class="line">IN REG,PORT</span><br></pre></td></tr></table></figure>

<p>CPU 可以读取控制寄存器 PORT 的内容并将结果放在 CPU 寄存器 REG 中。类似的，使用</p>
<figure class="highlight text"><table><tr><td class="code"><pre><span class="line">OUT PORT,REG</span><br></pre></td></tr></table></figure>

<p>CPU 可以将 REG 的内容写到控制寄存器中。大多数早期计算机，包括几乎所有大型主机，如 IBM 360 及其所有后续机型，都是以这种方式工作的。</p>
<p>控制寄存器是一个处理器寄存器而改变或控制的一般行为 CPU 或其他数字设备。控制寄存器执行的常见任务包括中断控制，切换寻址模式，分页控制和协处理器控制。</p>
<p><strong>在这一方案中，内存地址空间和 I&#x2F;O 地址空间是不相同的，如下图所示：</strong></p>
<p><img src="https://pic1.zhimg.com/80/v2-dafea15314a0290645f33fc6d663985c_720w.webp" alt="img"></p>
<p><strong>指令：</strong></p>
<figure class="highlight text"><table><tr><td class="code"><pre><span class="line">IN R0,4</span><br></pre></td></tr></table></figure>

<p>和</p>
<figure class="highlight text"><table><tr><td class="code"><pre><span class="line">MOV R0,4</span><br></pre></td></tr></table></figure>

<p>这一设计中完全不同。<strong>前者读取 I&#x2F;O端口 4 的内容并将其放入 R0，而后者读取存储器字 4 的内容并将其放入 R0</strong>。这些示例中的 4 代表不同且不相关的地址空间。</p>
<p>第二个方法是 PDP-11 引入的，</p>
<p><strong>什么是 PDP-11?</strong></p>
<p><img src="https://pic1.zhimg.com/80/v2-8ba9068643c0116f7fd47ecfed111e24_720w.webp" alt="img"></p>
<p>它将<strong>所有控制寄存器映射到内存空间</strong>中，如下图所示：</p>
<p><img src="https://pic3.zhimg.com/80/v2-a969368ece6403b14d29a2c422bec2ca_720w.webp" alt="img"></p>
<p><code>内存映射的 I/O</code>是在 CPU 与其连接的外围设备之间交换数据和指令的一种方式，这种方式是处理器和 IO 设备共享同一<code>内存位置</code>的内存，即处理器和 IO 设备使用内存地址进行映射。</p>
<p>在大多数系统中，分配给控制寄存器的地址位于或者靠近地址的顶部附近。</p>
<p><strong>下面是采用的一种混合方式：</strong></p>
<p><img src="https://pic4.zhimg.com/80/v2-8266dabbc6bdce4fed65881932284a6f_720w.webp" alt="img"></p>
<p>这种方式具有与内存映射 I&#x2F;O 的数据缓冲区，而控制寄存器则具有单独的 I&#x2F;O 端口。x86 采用这一体系结构。在 IBM PC 兼容机中，除了 0 到 64K - 1 的 I&#x2F;O 端口之外，640 K 到 1M - 1 的内存地址保留给设备的数据缓冲区。</p>
<p>这些方案是如何工作的呢？当 CPU 想要读入一个字的时候，无论是从内存中读入还是从 I&#x2F;O 端口读入，它都要将需要的地址放到总线地址线上，然后在总线的一条控制线上调用一个 READ 信号。还有第二条信号线来表明需要的是 I&#x2F;O 空间还是内存空间。如果是内存空间，内存将响应请求。如果是 I&#x2F;O 空间，那么 I&#x2F;O 设备将响应请求。如果只有内存空间，那么每个内存模块和每个 I&#x2F;O 设备都会将地址线和它所服务的地址范围进行比较。如果地址落在这一范围之内，它就会响应请求。绝对不会出现地址既分配给内存又分配给 I&#x2F;O 设备，所以不会存在歧义和冲突。</p>
<p><strong>内存映射 I&#x2F;O 的优点和缺点：</strong></p>
<p>这两种寻址控制器的方案具有不同的优缺点。先来看一下内存映射 I&#x2F;O 的优点。</p>
<ol>
<li>第一，如果需要特殊的 I&#x2F;O 指令读写设备控制寄存器，那么访问这些寄存器需要使用汇编代码，因为在 C 或 C++ 中不存在执行 IN 和 OUT指令的方法。调用这样的过程增加了 I&#x2F;O 的开销。在内存映射中，控制寄存器只是内存中的变量，在 C 语言中可以和其他变量一样进行寻址。</li>
<li>第二，对于内存映射 I&#x2F;O ，不需要特殊的保护机制就能够阻止用户进程执行 I&#x2F;O 操作。操作系统需要保证的是禁止把控制寄存器的地址空间放在用户的虚拟地址中就可以了。</li>
<li>第三，对于内存映射 I&#x2F;O，可以引用内存的每一条指令也可以引用控制寄存器，便于引用。</li>
</ol>
<p>在计算机设计中，几乎所有的事情都要权衡。内存映射 I&#x2F;O 也是一样，它也有自己的缺点。首先，大部分计算机现在都会有一些对于内存字的缓存。缓存一个设备控制寄存器的代价是很大的。为了避免这种内存映射 I&#x2F;O 的情况，硬件必须有选择性的禁用缓存，例如，在每个页面上禁用缓存，这个功能为硬件和操作系统增加了额外的复杂性，因此必须选择性的进行管理。</p>
<p>第二点，如果仅仅只有一个地址空间，那么所有的内存模块(memory modules)和所有的 I&#x2F;O 设备都必须检查所有的内存引用来推断出谁来进行响应。</p>
<p>什么是内存模块？在计算中，存储器模块是其上安装有存储器集成电路的印刷电路板。</p>
<p><img src="https://pic4.zhimg.com/80/v2-c729b9c647a4cee07d73dca1672d27a7_720w.webp" alt="img"></p>
<p><strong>如果计算机是一种单总线体系结构的话，如下图所示：</strong></p>
<p><img src="https://pic2.zhimg.com/80/v2-c14783f47b14aca66ff4725e269ce4a5_720w.webp" alt="img"></p>
<p>让每个内存模块和 I&#x2F;O 设备查看每个地址是简单易行的。</p>
<p>然而，现代个人计算机的趋势是专用的高速内存总线，如下图所示：</p>
<p><img src="https://pic4.zhimg.com/80/v2-4a77648e5065b7eba73639d61a871c27_720w.webp" alt="img"></p>
<p>装备这一总线是为了优化内存访问速度，x86 系统还可以有多种总线（内存、PCIe、SCSI 和 USB）。如下图所示：</p>
<p><img src="https://pic2.zhimg.com/80/v2-29cfe64c20d7467d962e20068411026d_720w.webp" alt="img"></p>
<p>在内存映射机器上使用单独的内存总线的麻烦之处在于，I&#x2F;O 设备无法通过内存总线查看内存地址，因此它们无法对其进行响应。此外，必须采取特殊的措施使内存映射 I&#x2F;O 工作在具有多总线的系统上。一种可能的方法是首先将全部内存引用发送到内存，如果内存响应失败，CPU 再尝试其他总线。</p>
<p>第二种设计是在内存总线上放一个探查设备，放过所有潜在指向所关注的 I&#x2F;O 设备的地址。此处的问题是，I&#x2F;O 设备可能无法以内存所能达到的速度处理请求。</p>
<p>第三种可能的设计是在内存控制器中对地址进行过滤，这种设计与上图所描述的设计相匹配。这种情况下，内存控制器芯片中包含在引导时预装载的范围寄存器。这一设计的缺点是需要在引导时判定哪些内存地址而不是真正的内存地址。因而，每一设计都有支持它和反对它的论据，所以折中和权衡是不可避免的。</p>
<p><strong>直接内存访问</strong></p>
<p>无论一个 CPU 是否具有内存映射 I&#x2F;O，它都需要寻址设备控制器以便与它们交换数据。CPU 可以从 I&#x2F;O 控制器每次请求一个字节的数据，但是这么做会浪费 CPU 时间，所以经常会用到一种称为直接内存访问(Direct Memory Access) 的方案。为了简化，我们假设 CPU 通过单一的系统总线访问所有的设备和内存，该总线连接 CPU 、内存和 I&#x2F;O 设备，如下图所示</p>
<p><img src="https://pic4.zhimg.com/80/v2-4dd0d9ffd9a6f689646225d22b897197_720w.webp" alt="img"></p>
<p>现代操作系统实际更为复杂，但是原理是相同的。如果硬件有DMA 控制器，那么操作系统只能使用 DMA。有时这个控制器会集成到磁盘控制器和其他控制器中，但这种设计需要在每个设备上都装有一个分离的 DMA 控制器。单个的 DMA 控制器可用于向多个设备传输，这种传输往往同时进行。</p>
<p>不管 DMA 控制器的物理地址在哪，它都能够独立于 CPU 从而访问系统总线，如上图所示。它包含几个可由 CPU 读写的寄存器，其中包括一个内存地址寄存器，字节计数寄存器和一个或多个控制寄存器。控制寄存器指定要使用的 I&#x2F;O 端口、传送方向（从 I&#x2F;O 设备读或写到 I&#x2F;O 设备）、传送单位（每次一个字节或者每次一个字）以及在一次突发传送中要传送的字节数。</p>
<p>为了解释 DMA 的工作原理，我们首先看一下不使用 DMA 该如何进行磁盘读取。</p>
<p>首先，控制器从磁盘驱动器串行地、一位一位的读一个块（一个或多个扇区），直到将整块信息放入控制器的内部缓冲区。</p>
<p>读取校验和以保证没有发生读错误。然后控制器会产生一个中断，当操作系统开始运行时，它会重复的从控制器的缓冲区中一次一个字节或者一个字地读取该块的信息，并将其存入内存中。</p>
<hr>
<p>版权声明：本文为知乎博主「玩转Linux内核」的原创文章，遵循CC 4.0 BY-SA版权协议，转载请附上原文出处链接及本声明。<br>原文链接：<a href="https://zhuanlan.zhihu.com/p/434511399">https://zhuanlan.zhihu.com/p/434511399</a></p>
]]></content>
      <categories>
        <category>linux-doc</category>
      </categories>
      <tags>
        <tag>Linux</tag>
      </tags>
  </entry>
  <entry>
    <title>Linux操作系统内存管理RAID磁盘阵列与配置</title>
    <url>/2023/01/15/linux-docs/Linux%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E5%86%85%E5%AD%98%E7%AE%A1%E7%90%86RAID%E7%A3%81%E7%9B%98%E9%98%B5%E5%88%97%E4%B8%8E%E9%85%8D%E7%BD%AE/</url>
    <content><![CDATA[<h2 id="1、RAID磁盘阵列"><a href="#1、RAID磁盘阵列" class="headerlink" title="1、RAID磁盘阵列"></a>1、RAID磁盘阵列</h2><p>简称：独立冗余磁盘阵列</p>
<p>把多块独立的物理硬盘按不同的方式组合起来形成一个硬盘组（逻辑硬盘）。从而提供比单个硬盘更高的存储性能和提供数据备份技术。</p>
<h3 id="1-1RAID级别"><a href="#1-1RAID级别" class="headerlink" title="1.1RAID级别"></a>1.1RAID级别</h3><p>组成磁盘阵列的不同方式称为RAID级别（RAID Levels）</p>
<p><strong>常用的RAID级别：</strong></p>
<p>RAID0、RAID1、RAID5、RAID6、RAID1+0等</p>
<p>①、RAID 0（条带化存储）</p>
<ol>
<li>RAID 0连续以位或字节为单位分割数据，并行读&#x2F;写于多个磁盘上，因此具有很高的数据传输率，但它没有数据冗余。</li>
<li>RAID 0只是单纯地提高性能，并没有为数据的可靠性提供保证，而且其中的一个磁盘失效将影响到所有数据</li>
<li>RAID 0不能应用于数据安全性要求高的场合</li>
</ol>
<p>②、RAID 1（镜像存储）</p>
<ul>
<li>通过磁盘数据镜像实现数据冗余，在成对的独立磁盘上产生互为备份的数据</li>
<li>当原始数据繁忙时，可直接从镜像拷贝中读取数据，因此RAID 1可以提高读取性能</li>
<li>RAID 1是磁盘阵列中单位成本最高的。但提供了很高的数据安全性和可用性。当一个磁盘失效时，系统可以自动切换到镜像磁盘上读写，而不需要重组失效的数据。</li>
</ul>
<p>③、RAID 5</p>
<ul>
<li>N(N≥3)块盘组成阵列，一份数据产生N-1个条带，同时还有一份校验数据，共N份数据在N块盘上循环均衡存储</li>
<li>N块盘同时读写，读性能很高，但由于有校验机制的问题，写性能相对不高</li>
<li>（N-1）&#x2F;N 磁盘利用率</li>
<li>可靠性高，允许坏一块盘，不影响所有数据</li>
</ul>
<p>④、RAID 6</p>
<ul>
<li>N（N≥4）块盘组成阵列，（N-2）&#x2F;N 磁盘利用率</li>
<li>与RAID 5相比，RAID 6增加了第二块独立的奇偶校验信息块</li>
<li>两个独立的奇偶系统使用不同的算法，即使两块磁盘同时失效也不会影响数据的使用</li>
<li>相对于RAID 5有更大的“写损失”，因此写性能较差</li>
</ul>
<p>⑤、RAID 1+0(先做镜像，再做条带)</p>
<ul>
<li>N (偶数，N&gt;&#x3D;4)。块盘两两镜像后，再组合成一个RAID 0</li>
<li>N&#x2F;2磁盘利用率</li>
<li>N&#x2F;2块盘同时写入，N块盘同时读取</li>
<li>性能高，可靠性高</li>
</ul>
<p>⑥、RAID 0+1(先做条带，再做镜像)</p>
<p>读写性能与RAID 10相同</p>
<p>安全性低于RAID 10</p>
<p><img src="https://pic1.zhimg.com/80/v2-3af4a5d53438b5675fccb5c4e59ad8b4_720w.webp" alt="img"></p>
<h2 id="2、创建软-RAID-磁盘阵列实验"><a href="#2、创建软-RAID-磁盘阵列实验" class="headerlink" title="2、创建软 RAID 磁盘阵列实验"></a>2、创建软 RAID 磁盘阵列实验</h2><p><strong>1、检查是否已安装mdadm 软件包</strong></p>
<p><img src="https://pic2.zhimg.com/80/v2-07e14384ea2796426306b78a16e2cb85_720w.webp" alt="img"></p>
<p><strong>2、先关闭虚拟机，然后编辑虚拟机设置，添加4块硬盘，每块分配40G，点击确认后开启虚拟机</strong></p>
<p><img src="https://pic2.zhimg.com/80/v2-da6b4b1a67b20524e30997498144f001_720w.webp" alt="img"></p>
<p><strong>3、我们使用xshell来进行连接，使用fdisk -l来查看分区情况</strong></p>
<p><img src="https://pic3.zhimg.com/80/v2-5e60c0f2344221b30cebb7e272880aae_720w.webp" alt="img"></p>
<p><strong>4、对分区进行管理，创建分区并修改分区类型，这里示范一个&#x2F;dev&#x2F;sdb，其余的操作一样，就不示范了</strong></p>
<p><img src="https://pic3.zhimg.com/80/v2-cccf6811a3aa526774d0f2c6865778aa_720w.webp" alt="img"></p>
<p><strong>5、使用fdisk -l看一下分区情况，是否全部转换完成</strong></p>
<p><img src="https://pic3.zhimg.com/80/v2-c5314db4d9bfbe88465dde7d5428dbde_720w.webp" alt="img"></p>
<p><strong>6、验证一下磁盘是否已做raid，然后开始创建raid，这里我们创建一个raid名为md0，级别使用RAID5，然后-l3设置使用三个磁盘，-x1使用一块备份磁盘，再进行查看创建速度。</strong></p>
<p><img src="https://pic3.zhimg.com/80/v2-887d7e3d66e1f9c40ee65bd0014d32e2_720w.webp" alt="img"></p>
<p><strong>7、这里已经创建好了，我们开始验证一下</strong></p>
<p><img src="https://pic2.zhimg.com/80/v2-1e889ee7e3cc46bb421dda188944b291_720w.webp" alt="img"></p>
<p><strong>8、我们模拟让它坏掉一个磁盘，来测试一下备份磁盘是否会自动顶上</strong></p>
<p><img src="https://pic1.zhimg.com/80/v2-11ac37fcb3db5e8346ecca6e4ae76314_720w.webp" alt="img"></p>
<p><strong>9、想使用起来得先进行格式化，再进行挂载，我接着尝试了一下在格式化和挂载之后备用磁盘是否还能自动顶上，实验结果：可以。</strong></p>
<p><img src="https://pic4.zhimg.com/80/v2-471b24d8561b269c443c53bd91b99143_720w.webp" alt="img"></p>
<h2 id="3、创建软-RAID-磁盘阵列步骤命令"><a href="#3、创建软-RAID-磁盘阵列步骤命令" class="headerlink" title="3、创建软 RAID 磁盘阵列步骤命令"></a>3、创建软 RAID 磁盘阵列步骤命令</h2><p><strong>1、检查是否已安装mdadm 软件包</strong></p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">rpm -q mdadm</span><br><span class="line">yum install -y mdadm</span><br></pre></td></tr></table></figure>

<p>2、使用fdisk工具将新磁盘设备&#x2F;dev&#x2F;sdb、&#x2F;dev&#x2F;sdc、&#x2F;dev&#x2F;sdd、&#x2F;dev&#x2F;sde划分出主分区sdb1、sdc1、sdd1、sde1，并且把分区类型的 ID 标记号改为“fd”</p>
<figure class="highlight text"><table><tr><td class="code"><pre><span class="line">fdisk /dev/sdb</span><br><span class="line">fdisk /dev/sdc</span><br></pre></td></tr></table></figure>

<p><strong>3、创建 RAID 设备</strong></p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">#创建RAID5</span><br><span class="line">mdadm -C -v /dev/md0 [-a yes] -l5 -n3 /dev/sd[bcd]<span class="number">1</span> -x1          /dev/sde1</span><br></pre></td></tr></table></figure>

<ul>
<li>-C：表示新建；</li>
<li>-v：显示创建过程中的详细信息。</li>
<li>&#x2F;dev&#x2F;md0：创建 RAID5 的名称。</li>
<li>-a yes：–auto，表示如果有什么设备文件没有存在的话就自动创建，可省略。</li>
<li>-l：指定 RAID 的级别，l5 表示创建 RAID5。</li>
<li>-n：指定使用几块硬盘创建 RAID，n3 表示使用 3 块硬盘创建 RAID。</li>
<li>&#x2F;dev&#x2F;sd[bcd]1：指定使用这四块磁盘分区去创建 RAID。</li>
<li>-x：指定使用几块硬盘做RAID的热备用盘，x1表示保留1块空闲的硬盘作备用</li>
<li>&#x2F;dev&#x2F;sde1：指定用作于备用的磁盘</li>
</ul>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">cat /proc/mdstat		#还能查看创建RAID的进度</span><br><span class="line">或者</span><br><span class="line">mdadm -D /dev/md0       #查看RAID磁盘详细信息</span><br><span class="line">mdadm -E /dev/sd[b-e]<span class="number">1</span>  #检查磁盘是否已做RAID</span><br></pre></td></tr></table></figure>

<p><strong>4、创建并挂载文件系统</strong></p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">mkfs -t xfs /dev/md0</span><br><span class="line">mkdir /myraid</span><br><span class="line">mount /dev/md0 /myraid/</span><br><span class="line">df -Th</span><br><span class="line">cp /etc/fstab /etc/fstab.bak</span><br><span class="line">vim /etc/fstab</span><br><span class="line">/dev/md0      /myraid        xfs   	 defaults   <span class="number">0</span>  <span class="number">0</span></span><br></pre></td></tr></table></figure>

<p><strong>5、实现故障恢复</strong></p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">mdadm /dev/md0 -f /dev/sdb1 		#模拟/dev/sdb1 故障</span><br><span class="line">mdadm -D /dev/md0					#查看发现sde1已顶替sdb1</span><br></pre></td></tr></table></figure>

<p><strong>mdadm命令其它常用选项：</strong></p>
<ul>
<li>-r：移除设备</li>
<li>-a：添加设备</li>
<li>-S：停止RAID</li>
<li>-A：启动RAID</li>
</ul>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">mdadm -S /dev/md0</span><br><span class="line">mdadm /dev/md0 -r /dev/sdb1</span><br></pre></td></tr></table></figure>

<hr>
<p>版权声明：本文为知乎博主「玩转Linux内核」的原创文章，遵循CC 4.0 BY-SA版权协议，转载请附上原文出处链接及本声明。<br>原文链接：<a href="https://zhuanlan.zhihu.com/p/448266123">https://zhuanlan.zhihu.com/p/448266123</a></p>
]]></content>
      <categories>
        <category>linux-doc</category>
      </categories>
      <tags>
        <tag>Linux</tag>
      </tags>
  </entry>
  <entry>
    <title>Linux操作系统内存管理之磁盘高速缓存机制</title>
    <url>/2023/01/15/linux-docs/Linux%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E5%86%85%E5%AD%98%E7%AE%A1%E7%90%86%E4%B9%8B%E7%A3%81%E7%9B%98%E9%AB%98%E9%80%9F%E7%BC%93%E5%AD%98%E6%9C%BA%E5%88%B6/</url>
    <content><![CDATA[<p>前言：相信通过前面的虚拟文件系统VFS及一个具体的Ext2文件系统博文，大家对基本的VFS体系有一个大致的掌握了吧。从本章开始，我们将讨论一些VFS底层的技术细节，磁盘高速缓存就是其中一个重要的技术。磁盘高速缓存是一种软件机制，它允许系统把通常存放在磁盘上的一些数据保留在RAM中，以便对那些数据的进一步访问而不用再访问磁盘。</p>
<p>因为对同一磁盘数据的反复访问频繁发生，所以磁盘高速缓存对系统性能至关重要。与磁盘交互的用户进程有权反复请求读或写同一磁盘数据。此外，不同的进程可能也需要在不同的时间访问相同的磁盘数据。例如，你可以使用cp命令拷贝一个文本文件，然后调用你喜欢的编辑器修改它。为了满足你的请求，命令shell将创建两个不同的进程，它们在不同的时间访问同一个文件。</p>
<p>我们曾在前面的博文中提到过其他的磁盘高速缓存：目录项高速缓存和索引节点高速缓存，前者存放的是描述文件系统路径名的目录项对象，而后者存放的是描述磁盘索引节点的索引节点对象。不过要注意，目录项对象和索引结节点对象不只是存放一些磁盘块内容的缓冲区，而是还加了一些内核感兴趣的其他信息，这些内容并不是从磁盘的某一个块上读取出来的；由此而知，目录项高速缓存和索引节点高速缓存是特殊的磁盘高速缓存，但不是属于我们这里讲的磁盘高速缓存概念的范围。</p>
<p>我们这里介绍的磁盘高速缓存其实是磁盘高速缓存——一种对完整的数据页进行操作的磁盘高速缓存，下面我们就从这个概念开始入手：</p>
<h2 id="1，页高速缓存"><a href="#1，页高速缓存" class="headerlink" title="1，页高速缓存"></a>1，页高速缓存</h2><p>页高速缓存（page cache）是Linux内核所使用的主要磁盘高速缓存。在绝大多数情况下，内核在读写磁盘时都会引用页面高速缓存。新页被追加到页高速缓存以满足用户态进程的读写请求。如果页不在高速缓存中，新页就被加到高速缓存中，然后用从磁盘读出的数据填充它。如果内存有足够的空闲空间，就让该页在高速缓存中长期保留，使其他进程在使用该页时不再访问磁盘。</p>
<p>同样，在把一页数据写到块设备之前，内核首先检查对应的页是否已经在高速缓存中；如果不在，就要先在其中增加一个新项，并用要写到磁盘中的数据填充该项。I&#x2F;O数据的传送并不是马上开始，而是要延迟几秒之后才对磁盘进行更新，从而使进程有机会对要写入磁盘的数据做进一步的修改（换句话说，就是内核执行延迟的写操作）。</p>
<p>内核的代码和内核数据结构不必从磁盘读，也不必写入磁盘（如果要在关机后恢复系统的所有状态——其实几乎不会出现这种情况，可以执行“挂起到磁盘”操作（hibernation)，RAM的全部内容保存到交换区，时此我们不做更多的讨论。），因此，在高速缓存中的也面可能是下面的类型：</p>
<ul>
<li>含有普通文件数据的页面。我们会在后面的博文描述内核如何处理它们的读、写和内存映射操作。</li>
<li>含有目录的页。其实，Linux采用与普通文件类似的方式操作目录文件。</li>
<li>含有直接从块设备文件（跳过文件系统层）读出的数据的页。内核处理这种页与处理含有普通文件的页使用相同的函数集合。</li>
<li>含有用户态进程数据的页面，但页中的数据已经被交换到磁盘。内核可能会强行在页高速缓存中保留一些页面，而这些页面中的数据已经被写到交换区（可能是普通文件或磁盘分区）。</li>
<li>-属于特殊文件系统文件的页，如共享内存的进程间通信（Interprocess Communication, IPC）所使用的特殊文件系统shm。</li>
</ul>
<p>从上面我们可以得出结论，页高速缓存中的每个页所包含的数据肯定属于某个文件。这个文件（或者更准确地说是文件的索引节点）就称为页的所有者（owner）。（即使含有换出数据的页面都属于同一个所有者，即使它们涉及不同的交换区。）</p>
<p>几乎所有的文件读写和写操作都依赖于页面的高速缓存。只有在O_DIRECT标志被置位而进程打开文件的情况下才会出现例外：此时，I&#x2F;O数据的传送绕过了页高速缓而使用了进程用户态地址空间的缓冲区；少数数据库应用软件为了能采用自己的磁盘高速缓存算法而使用了O_DIRECT标志。</p>
<p>页面高速缓存中的信息单位显然是一个完整的数据页。一个页中包含的磁盘块在物理上不一定是相邻的，所以不能用设备号和块号来识别它，取而代之的是，通过页的所有者和所有者数据中的索引（通常是一个索引节点和在相应文件中的偏移量）来识别页高速缓存中的页。</p>
<h2 id="2，address-space对象"><a href="#2，address-space对象" class="headerlink" title="2，address_space对象"></a>2，address_space对象</h2><p>页高速缓存的核心数据结构是address_space对象，它是一个嵌入在页所有者的索引节点对象中的数据结构（页被换出可能会引起缺页异常，这些被换出的页拥有不在任何索引节点中的公共address_space对象）。高速缓存中的许多页可能属于同一个所有者，从而可能被链接到同一个address_space对象。该对象还在所有者的页面和对这些页面的操作之间建立起链接关系。</p>
<p>每个页描述符都包括两个字段mapping和index，把页链接到页高速缓存的。mapping字段指向拥有页的索引节点的address_space对象，index字段表示在所有者的地址空间中以页大小为单位的偏移量，也就是在所有者的磁盘映像中页中数据的位置。在页面高速缓存中查找页面时使用这两个字段。</p>
<p>值得庆幸的是，页面高速缓存可以包含同一磁盘数据的多个副本。例如，可以用下述方式访问普通文件的同一4KB的数据块：</p>
<ul>
<li>读文件；因此，数据就包含在普通文件的索引节点所拥有的页面中。</li>
<li>从文件所在的设备文件（磁盘分区）读取块。因此，数据就包含在块设备文件的主索引节点所拥有的页中。</li>
</ul>
<p>因此，两个不同address_space对象所引用的两个不同的页中出现了相同的磁盘数据。address_space对象包含如下所示：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">struct</span> <span class="title class_">address_space</span> &#123;</span><br><span class="line">        <span class="keyword">struct</span> <span class="title class_">inode</span>  *host;  <span class="comment">/* 指向拥有该对象的索引节点的指针（如果存在） */</span></span><br><span class="line">        <span class="keyword">struct</span> <span class="title class_">radix_tree_root</span> page_tree; <span class="comment">/* 表示拥有者页的基树（radix tree）的根 */</span></span><br><span class="line">        <span class="type">rwlock_t</span>  tree_lock; <span class="comment">/* 保护基树的自旋锁 */</span></span><br><span class="line">        <span class="type">unsigned</span> <span class="type">int</span>  i_mmap_writable;<span class="comment">/* 地址空间中共享内存映射的个数 */</span></span><br><span class="line">        <span class="keyword">struct</span> <span class="title class_">prio_tree_root</span> i_mmap;  <span class="comment">/* radix优先搜索树的根 */</span></span><br><span class="line">        <span class="keyword">struct</span> <span class="title class_">list_head</span> i_mmap_nonlinear;<span class="comment">/* 地址空间中非线性内存区的链表 */</span></span><br><span class="line">        <span class="type">spinlock_t</span>  i_mmap_lock; <span class="comment">/* 保护radix优先搜索树的自旋锁 */</span></span><br><span class="line">        <span class="type">unsigned</span> <span class="type">int</span>  truncate_count; <span class="comment">/* 截断文件时使用的顺序计数器 */</span></span><br><span class="line">        <span class="type">unsigned</span> <span class="type">long</span>  nrpages; <span class="comment">/* 所有者的页总数 */</span></span><br><span class="line">        <span class="type">pgoff_t</span>   writeback_index;<span class="comment">/* 最后一次回写操作所作用的页的索引 */</span></span><br><span class="line">        <span class="type">const</span> <span class="keyword">struct</span> <span class="title class_">address_space_operations</span> *a_ops; <span class="comment">/* 对所有者页进行操作的方法 */</span></span><br><span class="line">        <span class="type">unsigned</span> <span class="type">long</span>  flags;  <span class="comment">/* 错误位和内存分配器的标志 */</span></span><br><span class="line">        <span class="keyword">struct</span> <span class="title class_">backing_dev_info</span> *backing_dev_info; <span class="comment">/* 指向拥有所有者数据的块设备的backing_dev_info的指针 */</span></span><br><span class="line">        <span class="type">spinlock_t</span>  private_lock; <span class="comment">/* 通常是管理private_list链表时使用的自旋锁 */</span></span><br><span class="line">        <span class="keyword">struct</span> <span class="title class_">list_head</span> private_list; <span class="comment">/* 通常是与索引节点相关的间接块的脏缓冲区的链表*/</span></span><br><span class="line">        <span class="keyword">struct</span> <span class="title class_">address_space</span> *assoc_mapping; <span class="comment">/* 通常是指向间接块所在块设备的address_space对象的指针 */</span></span><br><span class="line">&#125; __attribute__((<span class="built_in">aligned</span>(<span class="built_in">sizeof</span>(<span class="type">long</span>))));</span><br></pre></td></tr></table></figure>

<p>如果页高速缓存中页的所有者是一个文件，address_space对象就嵌入在VFS索引节点对象的i_data字段中。索引节点的i_mapping字段总是指向索引节点的数据页所有者的address_space对象。address_space对象的host字段指向其所有者的索引节点对象。</p>
<p>因此，如果页属于一个文件（存放在Ext3文件系统中），那么页的所有者就是文件的索引节点，而且相应的address_space对象存放在VFS索引节点对象的i_data字段中。索引节点的i_mapping字段指向同一个索引节点的i_data字段，而address_space对象的host字段也指向这个索引节点。</p>
<p>不过，有些时候情况会更复杂。如果页中包含的数据来自块设备文件，即页含有存放着块设备的“原始”数据，那么就把address_space对象嵌入到与该块设备相关的特殊文件系统bdev中文件的“主”索引节点中（块设备描述符的bd_inode字段引用这个索引节点，参见“块设备”博文）。因此，块设备文件对应索引节点的i_mapping字段指向主索引节点中的address_space对象。相应地，address_space对象的host字段指向主索引节点。这样，从块设备读取数据的所有页具有相同的address_space对象，即使这些数据位于不同地块设备文件。</p>
<p>i_mmap, i_mmap_writable, i_mmap_nonlinear和i_mmap_lock字段涉及内存映射和反映射，我们将在后面的博文讨论这些主题。</p>
<p>backing_dev_info字段指向backing_dev_info描述符，后者是对所有者的数据所在块设备进行有关描述的数据结构。</p>
<p>private_list字段是普通链表的首部，文件系统在实现其特定功能时可以随意使用。例如，Ext2文件系统利用这个链表收集与索引节点相关的“间接”块的脏缓冲区。当刷新操作把索引节点强行写入磁盘时，内核也同时刷新该链表中的所有缓冲区。此外，Ext2文件系统在assoc_mapping字段中存放指向间接块所在块设备的address_space对象，并使用assoc_mapping-&gt;private_lock自旋锁保护多处理器系统中的间接块链表。</p>
<p>address_space对象的关键字段是a_ops,它指向一个类型为address_space_operations的表，表中定义了对所有者的页进行处理的各种方法：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">struct</span> <span class="title class_">address_space_operations</span> &#123;</span><br><span class="line"><span class="comment">/* 写操作（从页写到所有者的磁盘映像） */</span></span><br><span class="line"> <span class="built_in">int</span> (*writepage)(<span class="keyword">struct</span> page *page, <span class="keyword">struct</span> writeback_control *wbc);</span><br><span class="line"><span class="comment">/* 读操作（从所有者的磁盘映像读到页） */</span></span><br><span class="line"> <span class="built_in">int</span> (*readpage)(<span class="keyword">struct</span> file *, <span class="keyword">struct</span> page *);</span><br><span class="line"><span class="comment">/* 如果对所有者页进行的操作已准备好，则立刻开始I/O数据的传输 */</span></span><br><span class="line"> <span class="built_in">void</span> (*sync_page)(<span class="keyword">struct</span> page *);</span><br><span class="line"></span><br><span class="line"> <span class="comment">/* Write back some dirty pages from this mapping. */</span></span><br><span class="line"><span class="comment">/* 把指定数量的所有者脏页写回磁盘 */</span></span><br><span class="line"> <span class="built_in">int</span> (*writepages)(<span class="keyword">struct</span> address_space *, <span class="keyword">struct</span> writeback_control *);</span><br><span class="line"></span><br><span class="line"> <span class="comment">/* Set a page dirty.  Return true if this dirtied it */</span></span><br><span class="line"><span class="comment">/* 把所有者的页设置为脏页 */</span></span><br><span class="line"> <span class="built_in">int</span> (*set_page_dirty)(<span class="keyword">struct</span> page *page);</span><br><span class="line"><span class="comment">/* 从磁盘中读所有者页的链表 */</span></span><br><span class="line"> <span class="built_in">int</span> (*readpages)(<span class="keyword">struct</span> file *filp, <span class="keyword">struct</span> address_space *mapping,</span><br><span class="line">   <span class="keyword">struct</span> list_head *pages, <span class="type">unsigned</span> nr_pages);</span><br><span class="line"></span><br><span class="line"> <span class="comment">/*</span></span><br><span class="line"><span class="comment">  * ext3 requires that a successful prepare_write() call be followed</span></span><br><span class="line"><span class="comment">  * by a commit_write() call - they must be balanced</span></span><br><span class="line"><span class="comment">  */</span></span><br><span class="line"><span class="comment">/* 为写操作做准备（由磁盘文件系统使用） */</span></span><br><span class="line"> <span class="built_in">int</span> (*prepare_write)(<span class="keyword">struct</span> file *, <span class="keyword">struct</span> page *, <span class="type">unsigned</span>, <span class="type">unsigned</span>);</span><br><span class="line"><span class="comment">/* 完成写操作（由磁盘文件系统使用） */</span></span><br><span class="line"> <span class="built_in">int</span> (*commit_write)(<span class="keyword">struct</span> file *, <span class="keyword">struct</span> page *, <span class="type">unsigned</span>, <span class="type">unsigned</span>);</span><br><span class="line"></span><br><span class="line"> <span class="comment">/* Unfortunately this kludge is needed for FIBMAP. Don&#x27;t use it */</span></span><br><span class="line"><span class="comment">/* 从文件块索引中获取逻辑块号 */</span></span><br><span class="line"> <span class="built_in">sector_t</span> (*bmap)(<span class="keyword">struct</span> address_space *, <span class="type">sector_t</span>);</span><br><span class="line"><span class="comment">/* 使所有者的页无效（截断文件时使用） */</span></span><br><span class="line"> <span class="built_in">void</span> (*invalidatepage) (<span class="keyword">struct</span> page *, <span class="type">unsigned</span> <span class="type">long</span>);</span><br><span class="line"><span class="comment">/* 由日志文件系统使用以准备释放页 */</span></span><br><span class="line"> <span class="built_in">int</span> (*releasepage) (<span class="keyword">struct</span> page *, <span class="type">gfp_t</span>);</span><br><span class="line"><span class="comment">/* 所有者页的直接I/O传输（绕过页高速缓存） */</span></span><br><span class="line"> <span class="built_in">ssize_t</span> (*direct_IO)(<span class="type">int</span>, <span class="keyword">struct</span> kiocb *, <span class="type">const</span> <span class="keyword">struct</span> iovec *iov,</span><br><span class="line">   <span class="type">loff_t</span> offset, <span class="type">unsigned</span> <span class="type">long</span> nr_segs);</span><br><span class="line"> <span class="keyword">struct</span> <span class="title class_">page</span>* (*get_xip_page)(<span class="keyword">struct</span> address_space *, <span class="type">sector_t</span>,</span><br><span class="line">   <span class="type">int</span>);</span><br><span class="line"> <span class="comment">/* migrate the contents of a page to the specified target */</span></span><br><span class="line"> <span class="built_in">int</span> (*migratepage) (<span class="keyword">struct</span> address_space *,</span><br><span class="line">   <span class="keyword">struct</span> page *, <span class="keyword">struct</span> page *);</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>其中最重要的方法是readpage, writepage, prepare_write和commit_write。我们将在后面的博文对它们进行讨论。在绝大多数情况下，这些方法把所有者的索引节点对象和访问物理设备的低级驱动程序联系起来。例如，为普通文件的索引节点实现readpage方法的函数知道如何确定文件页的对应块在物理磁盘设备上的位置。</p>
<h2 id="3，基树"><a href="#3，基树" class="headerlink" title="3，基树"></a>3，基树</h2><p>Linux支持大到几个TB的文件。访问大文件时，页面高速缓存中可能充满太多的文件页，以至于顺序扫描这些页要消耗大量的时间。为了实现页高速缓存的高效查找，Linux2.6采用了大量的搜索树，其中每个address_space对象对应一棵搜索树。</p>
<p>address_space对象的page_tree字段是基数（radix tree）的根，它包含指向所有者的描述符的指针。通过它，内核能够通过快速搜索操作来确定所需要的页是否在高速缓存中。当查找所需要的页时，内核把页索（page-&gt;index）引转换为基数中的路径，并快速找到页描述符所（或应当）在的位置。如果找到，内核可以从基树获得页描述符，而且还可以很快确定所找到的页是否是脏页（也就是应当被刷新到磁盘的页），以及其数据的I&#x2F;O传送是否正在进行。</p>
<p>基树的每个节点可以有多到64个指针指向其他节点或页描述符。底层节点存放指向页描述符的指针（叶子节点），而上层的节点存放指向其他节点（孩子节点）的指针。每个节点由radix_tree_node数据结构表示，它包括三个字段：slots是包括64个指针数组，count是记录节点中非空指针数量的计数器，tags是二维的标志数组：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">struct</span> <span class="title class_">radix_tree_node</span> &#123;</span><br><span class="line">       <span class="type">unsigned</span> <span class="type">int</span> count;</span><br><span class="line">       <span class="type">void</span>  *slots[RADIX_TREE_MAP_SIZE];</span><br><span class="line">       <span class="type">unsigned</span> <span class="type">long</span> tags[RADIX_TREE_MAX_TAGS][RADIX_TREE_TAG_LONGS];</span><br><span class="line">&#125;;</span><br><span class="line"><span class="meta">#<span class="keyword">define</span> RADIX_TREE_MAP_SIZE (1UL &lt;&lt; RADIX_TREE_MAP_SHIFT)   <span class="comment">/* 64 */</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> RADIX_TREE_MAP_SHIFT 3</span></span><br></pre></td></tr></table></figure>

<p>树根由radix_tree_root数据结构表示，他有三个字段：height表示树的当前深度（不包括叶子节点的层数），gfp_mask指定为新节点请求内存时所用的标志，mode指向与树中第一层节点相应的数据结构radix_tree_node（如果有的话）：</p>
<figure class="highlight text"><table><tr><td class="code"><pre><span class="line">struct radix_tree_root &#123;</span><br><span class="line">       unsigned int  height;</span><br><span class="line">       gfp_t   gfp_mask;</span><br><span class="line">       struct radix_tree_node *rnode;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>我们来看一个简单的例子。如果树中的索引都小于63，那么树的深度就等于1，因为可能存在的64个叶子可以都存放在第一层的节点中[如图（a）所示]。不过，如果与索引131相应的新页的描述符肯定存放在页高速缓存中，那么树的深度就增加为2，这样基树就可以查找多达4095个索引[如图（b）所示]。</p>
<p><img src="https://pic1.zhimg.com/v2-581d5df5ada220ff33988f22ab524998_b.jpg" alt="动图封面"></p>
<p>回顾一下分页系统是如何利用页表实现线性地址到物理地址转换的，从而理解如何实现页表查找。线性地址最高20位分成两个10位的字段：第一个字段是页目录中的偏移量，而第二个字段是某个页目录项所指向的页表中的偏移量。</p>
<p>技术中使用类似的方法。页索引相当于线性地址，不过页索引中要考虑的字段的数量依赖于基数的深度。如果基数的深度为1，就只能表示从0<del>63范围的索引，因此页索引得第6位被解释为slots数组的下标，每个下标对应第一层的一个节点。如果基数的深度为2，就可以表示从0</del>4095范围的索引，页索引得第12位分成两个6位的字段，高位的字段用于表示第一层节点数组的下标，而低位的字段用于表示第二层数组的下标。依此类推，如果深度等于6，页索引得最高两位（因为page-&gt;index是32位的）表示第一层节点数组的下标，接下来的6位表示第二层节点数组的下标，这样一直到最低6位，它们表示第六层节点数组的下标。</p>
<p>如果基树的最大索引小于应该增加的页的索引，那么内核相应地增加树的深度；基树的中间节点依赖于索引得值。</p>
<hr>
<p>版权声明：本文为知乎博主「玩转Linux内核」的原创文章，遵循CC 4.0 BY-SA版权协议，转载请附上原文出处链接及本声明。<br>原文链接：<a href="https://zhuanlan.zhihu.com/p/448258669">https://zhuanlan.zhihu.com/p/448258669</a></p>
]]></content>
      <categories>
        <category>linux-doc</category>
      </categories>
      <tags>
        <tag>Linux</tag>
      </tags>
  </entry>
  <entry>
    <title>Linux操作系统基础的常用命令</title>
    <url>/2023/01/15/linux-docs/Linux%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E5%9F%BA%E7%A1%80%E7%9A%84%E5%B8%B8%E7%94%A8%E5%91%BD%E4%BB%A4/</url>
    <content><![CDATA[<h2 id="1，Linux简介"><a href="#1，Linux简介" class="headerlink" title="1，Linux简介"></a>1，Linux简介</h2><p>Linux是一种自由和开放源码的操作系统，存在着许多不同的Linux版本，但它们都使用了Linux内核。Linux可安装在各种计算机硬件设备中，比如手机、平板电脑、路由器、台式计算机。</p>
<h3 id="1-1Linux介绍"><a href="#1-1Linux介绍" class="headerlink" title="1.1Linux介绍"></a>1.1Linux介绍</h3><p>Linux出现于1991年，是由芬兰赫尔辛基大学学生Linus Torvalds和后来加入的众多爱好者共同开发完成</p>
<h3 id="1-2Linux特点"><a href="#1-2Linux特点" class="headerlink" title="1.2Linux特点"></a>1.2Linux特点</h3><p>多用户，多任务，丰富的网络功能，可靠的系统安全，良好的可移植性，具有标准兼容性，良好的用户界面，出色的速度性能</p>
<h3 id="1-3开源"><a href="#1-3开源" class="headerlink" title="1.3开源"></a>1.3开源</h3><p>CentOS</p>
<ol>
<li>主流：目前的Linux操作系统主要应用于生产环境，主流企业级Linux系统仍旧是RedHat或者CentOS</li>
<li>免费：RedHat 和CentOS差别不大，基于Red Hat Linux 提供的可自由使用源代码的企业CentOS是一个级Linux发行版本</li>
<li>更新方便：CentOS独有的yum命令支持在线升级，可以即时更新系统，不像RedHat 那样需要花钱购买支持服务！</li>
</ol>
<h3 id="1-4Linux目录结构"><a href="#1-4Linux目录结构" class="headerlink" title="1.4Linux目录结构"></a>1.4Linux目录结构</h3><p><img src="https://pic2.zhimg.com/80/v2-0ba0cffb7f05d4eccec30210c8e64851_720w.webp" alt="img"></p>
<ul>
<li>bin (binaries)存放二进制可执行文件</li>
<li>sbin (super user binaries)存放二进制可执行文件，只有root才能访问</li>
<li>etc (etcetera)存放系统配置文件</li>
<li>usr (unix shared resources)用于存放共享的系统资源</li>
<li>home 存放用户文件的根目录</li>
<li>root 超级用户目录</li>
<li>dev (devices)用于存放设备文件</li>
<li>lib (library)存放跟文件系统中的程序运行所需要的共享库及内核模块</li>
<li>mnt (mount)系统管理员安装临时文件系统的安装点</li>
<li>boot 存放用于系统引导时使用的各种文件</li>
<li>tmp (temporary)用于存放各种临时文件</li>
<li>var (variable)用于存放运行时需要改变数据的文件</li>
</ul>
<h2 id="2，Linux常用命令"><a href="#2，Linux常用命令" class="headerlink" title="2，Linux常用命令"></a>2，Linux常用命令</h2><h3 id="2-1命令格式：命令-选项-参数"><a href="#2-1命令格式：命令-选项-参数" class="headerlink" title="2.1命令格式：命令 -选项 参数"></a>2.1命令格式：命令 -选项 参数</h3><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">如：ls  -la  /usr</span><br><span class="line"></span><br><span class="line">ls：显示文件和目录列表(list)</span><br></pre></td></tr></table></figure>

<p><strong>常用参数：</strong></p>
<figure class="highlight text"><table><tr><td class="code"><pre><span class="line">-l		(long)</span><br><span class="line">-a	(all)         注意隐藏文件、特殊目录.和..   </span><br><span class="line">-t		(time)</span><br></pre></td></tr></table></figure>

<h3 id="2-2Linux命令的分类"><a href="#2-2Linux命令的分类" class="headerlink" title="2.2Linux命令的分类"></a>2.2Linux命令的分类</h3><p>内部命令：属于Shell解析器的一部分</p>
<figure class="highlight text"><table><tr><td class="code"><pre><span class="line">cd 切换目录（change directory）</span><br><span class="line">pwd 显示当前工作目录（print working directory）</span><br><span class="line">help 帮助</span><br></pre></td></tr></table></figure>

<p><strong>外部命令：独立于Shell解析器之外的文件程序</strong></p>
<figure class="highlight text"><table><tr><td class="code"><pre><span class="line">ls 显示文件和目录列表（list）</span><br><span class="line">mkdir 创建目录（make directoriy）</span><br><span class="line">cp 复制文件或目录（copy）</span><br></pre></td></tr></table></figure>

<p><strong>查看帮助文档</strong></p>
<figure class="highlight text"><table><tr><td class="code"><pre><span class="line">内部命令：help + 命令（help cd）</span><br><span class="line">外部命令：man + 命令（man ls）</span><br></pre></td></tr></table></figure>

<h3 id="2-3操作文件或目录常用命令"><a href="#2-3操作文件或目录常用命令" class="headerlink" title="2.3操作文件或目录常用命令"></a>2.3操作文件或目录常用命令</h3><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">pwd 显示当前工作目录（print working directory）</span><br><span class="line">touch 创建空文件				                    </span><br><span class="line">mkdir 创建目录（make directoriy）</span><br><span class="line">-p 父目录不存在情况下先生成父目录 （parents）            </span><br><span class="line">cp 复制文件或目录（copy）</span><br><span class="line">-r 递归处理，将指定目录下的文件与子目录一并拷贝（recursive）     </span><br><span class="line">mv 移动文件或目录、文件或目录改名（move）</span><br><span class="line"></span><br><span class="line">rm 删除文件（remove）</span><br><span class="line">-r 同时删除该目录下的所有文件（recursive）</span><br><span class="line">-f 强制删除文件或目录（force）</span><br><span class="line">rmdir 删除空目录（remove directoriy）</span><br><span class="line">cat显示文本文件内容 （catenate）</span><br><span class="line">more、less 分页显示文本文件内容</span><br><span class="line">head、tail查看文本中开头或结尾部分的内容</span><br><span class="line">head -n  <span class="number">5</span>  a.log 查看a.log文件的前<span class="number">5</span>行</span><br><span class="line">tail  -F b.log 循环读取（follow）</span><br></pre></td></tr></table></figure>

<p><strong>常用命令</strong></p>
<figure class="highlight text"><table><tr><td class="code"><pre><span class="line">wc 统计文本的行数、字数、字符数（word count）</span><br><span class="line">-m 统计文本字符数</span><br><span class="line">-w 统计文本字数</span><br><span class="line">-l 统计文本行数</span><br><span class="line">find 在文件系统中查找指定的文件</span><br><span class="line">find /etc/ -name &quot;aaa&quot;</span><br><span class="line">grep 在指定的文本文件中查找指定的字符串</span><br><span class="line">ln 建立链接文件（link）</span><br><span class="line">-s 对源文件建立符号连接，而非硬连接（symbolic）</span><br><span class="line"></span><br><span class="line">top 显示当前系统中耗费资源最多的进程 </span><br><span class="line">ps 显示瞬间的进程状态</span><br><span class="line">-e /-A 显示所有进程，环境变量</span><br><span class="line">-f 全格式</span><br><span class="line">-a 显示所有用户的所有进程（包括其它用户）</span><br><span class="line">-u 按用户名和启动时间的顺序来显示进程</span><br><span class="line">-x 显示无控制终端的进程</span><br><span class="line">kill 杀死一个进程</span><br><span class="line">kill -9 pid</span><br><span class="line">df 显示文件系统磁盘空间的使用情况</span><br><span class="line"></span><br><span class="line">du 显示指定的文件（目录）已使用的磁盘空间的总</span><br><span class="line">-h文件大小以K，M，G为单位显示（human-readable）</span><br><span class="line">-s只显示各档案大小的总合（summarize）</span><br><span class="line">free 显示当前内存和交换空间的使用情况 </span><br><span class="line">netstat 显示网络状态信息</span><br><span class="line">-a 显示所有连接和监听端口</span><br><span class="line">-t (tcp)仅显示tcp相关选项</span><br><span class="line">-u (udp)仅显示udp相关选项</span><br><span class="line">-n 拒绝显示别名，能显示数字的全部转化成数字。</span><br><span class="line">-p 显示建立相关链接的程序名</span><br><span class="line">ifconfig 网卡网络配置详解 </span><br><span class="line">ping 测试网络的连通性 </span><br></pre></td></tr></table></figure>

<p><strong>备份压缩命令</strong></p>
<figure class="highlight text"><table><tr><td class="code"><pre><span class="line">gzip 压缩（解压）文件或目录，压缩文件后缀为gz </span><br><span class="line">bzip2 压缩（解压）文件或目录，压缩文件后缀为bz2 </span><br><span class="line">tar 文件、目录打（解）包</span><br></pre></td></tr></table></figure>

<p><strong>gzip命令</strong></p>
<figure class="highlight text"><table><tr><td class="code"><pre><span class="line">命令格式：gzip [选项] 压缩（解压缩）的文件名</span><br><span class="line">-d将压缩文件解压（decompress）</span><br><span class="line">-l显示压缩文件的大小，未压缩文件的大小，压缩比（list）</span><br><span class="line">-v显示文件名和压缩比（verbose）</span><br><span class="line">-num用指定的数字num调整压缩的速度，-1或--fast表示最快压缩方法（低压缩比），-9或--best表示最慢压缩方法（高压缩比）。系统缺省值为6</span><br></pre></td></tr></table></figure>

<p><strong>bzip2命令</strong></p>
<figure class="highlight text"><table><tr><td class="code"><pre><span class="line">命令格式：bzip2 [-cdz] 文档名</span><br><span class="line">-c将压缩的过程产生的数据输出到屏幕上</span><br><span class="line">-d解压缩的参数（decompress）</span><br><span class="line">-z压缩的参数（compress）</span><br><span class="line">-num 用指定的数字num调整压缩的速度，-1或--fast表示最快压缩方法（低压缩比），-9或--best表示最慢压缩方法（高压缩比）。系统缺省值为6</span><br></pre></td></tr></table></figure>

<p><strong>tar命令</strong></p>
<figure class="highlight text"><table><tr><td class="code"><pre><span class="line">-c 建立一个压缩文件的参数指令（create）</span><br><span class="line">-x 解开一个压缩文件的参数指令（extract）</span><br><span class="line">-z 是否需要用 gzip 压缩</span><br><span class="line">-j 是否需要用 bzip2 压缩</span><br><span class="line">-v 压缩的过程中显示文件（verbose）</span><br><span class="line">-f 使用档名，在 f 之后要立即接档名（file）</span><br></pre></td></tr></table></figure>

<p><strong>关机&#x2F;重启命令</strong></p>
<figure class="highlight text"><table><tr><td class="code"><pre><span class="line">shutdown系统关机 </span><br><span class="line">-r 关机后立即重启</span><br><span class="line">-h 关机后不重新启动</span><br><span class="line">halt 关机后关闭电源 shutdown -h</span><br><span class="line">reboot 重新启动 shutdown -r</span><br></pre></td></tr></table></figure>

<p><strong>学习Linux的好习惯</strong></p>
<ul>
<li>善于查看man page（manual）等帮助文档</li>
<li>利用好Tab键</li>
<li>掌握好一些快捷键</li>
</ul>
<figure class="highlight text"><table><tr><td class="code"><pre><span class="line">ctrl + c（停止当前进程）</span><br><span class="line">ctrl + r（查看命令历史）</span><br><span class="line">ctrl + l（清屏，与clear命令作用相同）</span><br></pre></td></tr></table></figure>

<hr>
<p>版权声明：本文为知乎博主「玩转Linux内核」的原创文章，遵循CC 4.0 BY-SA版权协议，转载请附上原文出处链接及本声明。<br>原文链接：<a href="https://zhuanlan.zhihu.com/p/434528439">https://zhuanlan.zhihu.com/p/434528439</a></p>
]]></content>
      <categories>
        <category>linux-doc</category>
      </categories>
      <tags>
        <tag>Linux</tag>
      </tags>
  </entry>
  <entry>
    <title>Linux操作系统处理器调度基本准则和实现</title>
    <url>/2023/01/15/linux-docs/Linux%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E5%A4%84%E7%90%86%E5%99%A8%E8%B0%83%E5%BA%A6%E5%9F%BA%E6%9C%AC%E5%87%86%E5%88%99%E5%92%8C%E5%AE%9E%E7%8E%B0/</url>
    <content><![CDATA[<h2 id="1，基本概念"><a href="#1，基本概念" class="headerlink" title="1，基本概念"></a>1，基本概念</h2><p>在多道程序系统中，进程的数量往往多于处理机的个数，进程争用处理机的情况就在所难免。处理机调度是对处理机进行分配，就是从就绪队列中，按照一定的算法（公平、低效）选择一个进程并将处理机分配给它运行，以实现进程并发地执行。</p>
<p>处理机调度是多道程序操作系统的基础，它是操作系统设计的核心问题。</p>
<h2 id="2，调度的层次"><a href="#2，调度的层次" class="headerlink" title="2，调度的层次"></a>2，调度的层次</h2><p>一个作业从提交开始直到完成，往往要经历以下三级调度，如图2-4所示。</p>
<p>\1) 作业调度。又称高级调度，.其主要任务是按一定的原则从外存上处于后备状态的作业中挑选一个（或多个）作业，给它（们）分配内存、输入&#x2F;输出设备等必要的资源，并建立相应的进程，以使它（们）获得竞争处理机的权利。简言之，就是内存与辅存之间的调度。对于每个作业只调入一次、调出一次。</p>
<p>多道批处理系统中大多配有作业调度，而其他系统中通常不需要配置作业调度。作业调度的执行频率较低，通常为几分钟一次。</p>
<p>\2) 中级调度。又称内存调度。引入中级调度是为了提高内存利用率和系统吞吐量。为此，应使那些暂时不能运行的进程，调至外存等待，把此时的进程状态称为挂起状态。当它们已具备运行条件且内存又稍有空闲时，由中级调度来决定，把内存上的那些已具备运行条件的就绪进程，再重新调入内存，并修改其状态为就绪状态，挂在就绪队列上等待。</p>
<p>\3) 进程调度。又称为低级调度，其主要任务是按照某种方法和策略从就绪队列中选取一个进程，将处理机分配给它。进程调度是操作系统中最基本的一种调度，在一般操作系统中都必须配置进程调度。进程调度的频率很高，一般几十毫秒一次。</p>
<p><img src="https://pic3.zhimg.com/80/v2-77b56e9018fb16c38b3d69cce8295e6e_720w.webp" alt="img"></p>
<h2 id="3，三级调度的联系"><a href="#3，三级调度的联系" class="headerlink" title="3，三级调度的联系"></a>3，三级调度的联系</h2><p>作业调度从外存的后备队列中选择一批作业进入内存，为它们建立进程，这些进程被送入就绪队列，进程调度从就绪队列中选出一个进程，并把其状态改为运行状态，把CPU分配给它。中级调度是为了提高内存的利用率，系统将那些暂时不能运行的进程挂起来。当内存空间宽松时，通过中级调度选择具备运行条件的进程，将其唤醒。</p>
<p>\1) 作业调度为进程活动做准备，进程调度使进程正常活动起来，中级调度将暂时不能运行的进程挂起，中级调度处于作业调度和进程调度之间。</p>
<p>\2) 作业调度次数少，中级调度次数略多，进程调度频率最高。</p>
<p>\3) 进程调度是最基本的，不可或缺的。</p>
<h2 id="4，调度的时机、切换与过程"><a href="#4，调度的时机、切换与过程" class="headerlink" title="4，调度的时机、切换与过程"></a>4，调度的时机、切换与过程</h2><p>进程调度和切换程序是操作系统内核程序。当请求调度的事件发生后，才可能会运行进程调度程序，当调度了新的就绪进程后，才会去进行进程间的切换。理论上这三件事情应该顺序执行，但在实际设计中，在操作系统内核程序运行时，如果某时发生了引起进程调度的因素，并不一定能够马上进行调度与切换。</p>
<p>现代操作系统中，不能进行进程的调度与切换的情况有以下几种情况。</p>
<p>\1) 在处理中断的过程中：中断处理过程复杂，在实现上很难做到进程切换，而且中断处理是系统工作的一部分，逻辑上不属于某一进程，不应被剥夺处理机资源。</p>
<p>\2) 进程在操作系统内核程序临界区中：进入临界区后，需要独占式地访问共享数据，理论上必须加锁，以防止其他并行程序进入，在解锁前不应切换到其他进程运行，以加快该共享数据的释放。</p>
<p>\3) 其他需要完全屏蔽中断的原子操作过程中：如加锁、解锁、中断现场保护、恢复等原子操作。在原子过程中，连中断都要屏蔽，更不应该进行进程调度与切换。</p>
<p>如果在上述过程中发生了引起调度的条件，并不能马上进行调度和切换，应置系统的请求调度标志，直到上述过程结束后才进行相应的调度与切换。</p>
<p><strong>应该进行进程调度与切换的情况有：</strong></p>
<p>\1) 当发生引起调度条件，且当前进程无法继续运行下去时，可以马上进行调度与切换。如果操作系统只在这种情况下进行进程调度，就是非剥夺调度。</p>
<p>\2) 当中断处理结束或自动处理结束后，返回被中断进程的用户态程序执行现场前，若置上请求调度标志，即可马上进行进程调度与切换。如果操作系统支持这种情况下的运行调度程序，就实现了剥夺方式的调度。</p>
<p>进程切换往往在调度完成后立刻发生，它要求保存原进程当前切换点的现场信息，恢复被调度进程的现场信息。现场切换时，操作系统内核将原进程的现场信息推入到当前进程的内核堆栈来保存它们，并更新堆栈指针。内核完成从新进程的内核栈中装入新进程的现场信息、更新当前运行进程空间指针、重设PC寄存器等相关工作之后，开始运行新的进程。</p>
<h2 id="5，进程调度方式"><a href="#5，进程调度方式" class="headerlink" title="5，进程调度方式"></a>5，进程调度方式</h2><p>所谓进程调度方式是指当某一个进程正在处理机上执行时，若有某个更为重要或紧迫的进程需要处理，即有优先权更髙的进程进入就绪队列，此时应如何分配处理机。</p>
<p><strong>通常有以下两种进程调度方式：</strong></p>
<p>\1) 非剥夺调度方式，又称非抢占方式。是指当一个进程正在处理机上执行时，即使有某个更为重要或紧迫的进程进入就绪队列，仍然让正在执行的进程继续执行，直到该进程完成或发生某种事件而进入阻塞状态时，才把处理机分配给更为重要或紧迫的进程。</p>
<p>在非剥夺调度方式下，一旦把CPU分配给一个进程，那么该进程就会保持CPU直到终止或转换到等待状态。这种方式的优点是实现简单、系统开销小，适用于大多数的批处理系统，但它不能用于分时系统和大多数的实时系统。</p>
<p>\2) 剥夺调度方式，又称抢占方式。是指当一个进程正在处理机上执行时，若有某个更为重要或紧迫的进程需要使用处理机，则立即暂停正在执行的进程，将处理机分配给这个更为重要或紧迫的进程。.</p>
<p>采用剥夺式的调度，对提高系统吞吐率和响应效率都有明显的好处。但“剥夺”不是一种任意性行为，必须遵循一定的原则，主要有：优先权、短进程优先和时间的原则等。</p>
<p><strong>调度的基本准则</strong></p>
<p>不同的调度算法具有不同的特性，在选择调度算法时，必须考虑算法所具有的特性。为了比较处理机调度算法的性能，人们提出很多评价准则，下面介绍主要的几种：</p>
<p>\1) CPU利用率。CPU是计算机系统中最重要和昂贵的资源之一，所以应尽可能使CPU 保持“忙”状态，使这一资源利用率最高。</p>
<p>\2) 系统吞吐量。表示单位时间内CPU完成作业的数量。长作业需要消耗较长的处理机时间，因此会降低系统的吞吐量。而对于短作业，它们所需要消耗的处理机时间较短，因此能提高系统的吞吐量。调度算法和方式的不同，也会对系统的吞吐量产生较大的影响。</p>
<p>\3) 周转时间。是指从作业提交到作业完成所经历的时间，包括作业等待、在就绪队列中排队、在处迤机上运行以及进行输入&#x2F;输出操作所花费时间的总和。</p>
<p>作业的周转时间可用公式表示如下：</p>
<p>周转时间 &#x3D; 作业完成时间 - 作业提交时间</p>
<p>平均周转时间是指多个作业周转时间的平均值：</p>
<p>平均周转时间 &#x3D; (作业1的周转时间 + … + 作业 n 的周转时间) &#x2F; n</p>
<p>带权周转时间是指作业周转时间与作业实际运行时间的比值：</p>
<p>平均带权周转时间是指多个作业带权周转时间的平均值：</p>
<p>平均带权周转时间 &#x3D; (作业1的带权周转时间 + … + 作业 n 的带权周转时间) &#x2F; n</p>
<p>\4) 等待时间。&#x3D;开始时间—提交时间。</p>
<p>是指进程处于等待处理机状态时间之和，等待时间越长，用户满意度越低。处理机调度算法实际上并不影响作业执行或输入&#x2F;输出操作的时间，只影响作业在就绪队列中等待所花的时间。因此，衡量一个调度算法的优劣常常只需简单地考察等待时间。</p>
<p>\5) 响应时间。是指从用户提交请求到系统首次产生响应所用的时间。在交互式系统中，周转时间不可能是最好的评价准则，一般采用响应时间作为衡量调度算法的重要准则之一。从用户角度看，调度策略应尽量降低响应时间，使响应时间处在用户能接受的范围之内。</p>
<p>要想得到一个满足所有用户和系统要求的算法几乎是不可能的。设计调度程序，一方面要满足特定系统用户的要求（如某些实时和交互进程快速响应要求)，另一方面要考虑系统整体效率（如减少整个系统进程平均周转时间），同时还要考虑调度算法的开销。</p>
<p><strong>操作系统典型调度算法</strong></p>
<p>在操作系统中存在多种调度算法，其中有的调度算法适用于作业调度，有的调度算法适用于进程调度，有的调度算法两者都适用。下面介绍几种常用的调度算法。</p>
<p>先来先服务(FCFS)调度算法</p>
<p>FCFS调度算法是一种最简单的调度算法，该调度算法既可以用于作业调度也可以用于进程调度。</p>
<p>在作业调度中，算法每次从后备作业队列中选择最先进入该队列的一个或几个作业，将它们调入内存，分配必要的资源，创建进程并放入就绪队列。</p>
<p>在进程调度中，FCFS调度算法每次从就绪队列中选择最先进入该队列的进程，将处理机分配给它，使之投入运行，直到完成或因某种原因而阻塞时才释放处理机。</p>
<p>下面通过一个实例来说明FCFS调度算法的性能。假设系统中有4个作业，它们的提交时间分别是8、8.4、8.8、9，运行时间依次是2、1、0.5、0.2，系统釆用FCFS调度算法，这组作业的平均等待时间、平均周转时间和平均带权周转时间见表2-3。</p>
<p><img src="https://pic2.zhimg.com/80/v2-bfcc2b660295833a818246f7289d58f5_720w.webp" alt="img"></p>
<p>平均等待时间 t &#x3D; (0+1.6+2.2+2.5)&#x2F;4&#x3D;1.575</p>
<p>平均周转时间 T &#x3D; (2+2.6+2.7+2.7)&#x2F;4&#x3D;2.5</p>
<p>平均带权周转时间 W &#x3D; (1+2.6+5.牡13.5)&#x2F;4&#x3D;5.625</p>
<p>FCFS调度算法属于不可剥夺算法。从表面上看，它对所有作业都是公平的，但若一个长作业先到达系统，就会使后面许多短作业等待很长时间，因此它不能作为分时系统和实时系统的主要调度策略。但它常被结合在其他调度策略中使用。例如，在使用优先级作为调度策略的系统中，往往对多个具有相同优先级的进程按FCFS原则处理。</p>
<p>FCFS调度算法的特点是算法简单，但效率低；对长作业比较有利，但对短作业不利（相对SJF和高响应比）；有利于CPU繁忙型作业，而不利于I&#x2F;O繁忙型作业。</p>
<p><strong>短作业优先(SJF)调度算法</strong></p>
<p>短作业（进程）优先调度算法（Shortest Job First ）是指对短作业（进程）优先调度的算法。短作业优先(SJF)调度算法是从后备队列中选择一个或若干个估计运行时间最短的作业，将它们调入内存运行。而短进程优先(SPF)调度算法，则是从就绪队列中选择一个估计运行时间最短的进程，将处理机分配给它，使之立即执行，直到完成或发生某事件而阻塞时，才释放处理机。</p>
<p>例如，考虑表2-3中给出的一组作业，若系统采用短作业优先调度算法，其平均等待时间、平均周转时间和平均带权周转时间见表2-4。</p>
<p><img src="https://pic4.zhimg.com/80/v2-5c0175372e39ae8f8793cff359bb4a5b_720w.webp" alt="img"></p>
<p>平均等待时间 t &#x3D; (0+2.3+1.4+1)&#x2F;4&#x3D;1.175</p>
<p>平均周转时间 T &#x3D; (2+3.3+1.9+1.2)&#x2F;4&#x3D;2.1</p>
<p>平均带权周转时间 W &#x3D; (1+3.3+3.8+6)&#x2F;4&#x3D;3.525</p>
<p><strong>SJF调度算法也存在不容忽视的缺点：</strong></p>
<p>该算法对长作业不利，由表2-3和表2-4可知，SJF调度算法中长作业的周转时间会增加。更严重的是，如果有一长作业进入系统的后备队列，由于调度程序总是优先调度那些 (即使是后进来的）短作业，将导致长作业长期不被调度（“饥饿”现象，注意区分“死锁”。后者是系统环形等待，前者是调度策略问题）。</p>
<p>该算法完全未考虑作业的紧迫程度，因而不能保证紧迫性作业会被及时处理。</p>
<p>由于作业的长短只是根据用户所提供的估计执行时间而定的，而用户又可能会有意或无意地缩短其作业的估计运行时间，致使该算法不一定能真正做到短作业优先调度。</p>
<p>注意，SJF调度算法的平均等待时间、平均周转时间最少。</p>
<p><strong>优先级调度算法</strong></p>
<p>优先级调度算法又称优先权调度算法，该算法既可以用于作业调度，也可以用于进程调度，该算法中的优先级用于描述作业运行的紧迫程度。</p>
<p>在作业调度中，优先级调度算法每次从后备作业队列中选择优先级最髙的一个或几个作业，将它们调入内存，分配必要的资源，创建进程并放入就绪队列。在进程调度中，优先级调度算法每次从就绪队列中选择优先级最高的进程，将处理机分配给它，使之投入运行。</p>
<p>根据新的更高优先级进程能否抢占正在执行的进程，可将该调度算法分为：</p>
<p>非剥夺式优先级调度算法。当某一个进程正在处理机上运行时，即使有某个更为重要或紧迫的进程进入就绪队列，仍然让正在运行的进程继续运行，直到由于其自身的原因而主动让出处理机时（任务完成或等待事件），才把处理机分配给更为重要或紧迫的进程。</p>
<p>剥夺式优先级调度算法。当一个进程正在处理机上运行时，若有某个更为重要或紧迫的进程进入就绪队列，则立即暂停正在运行的进程，将处理机分配给更重要或紧迫的进程。</p>
<p>而根据进程创建后其优先级是否可以改变，可以将进程优先级分为以下两种：</p>
<p>静态优先级。优先级是在创建进程时确定的，且在进程的整个运行期间保持不变。确定静态优先级的主要依据有进程类型、进程对资源的要求、用户要求。</p>
<p>动态优先级。在进程运行过程中，根据进程情况的变化动态调整优先级。动态调整优先级的主要依据为进程占有CPU时间的长短、就绪进程等待CPU时间的长短。</p>
<p><strong>高响应比优先调度算法</strong></p>
<p>高响应比优先调度算法主要用于作业调度，该算法是对FCFS调度算法和SJF调度算法的一种综合平衡，同时考虑每个作业的等待时间和估计的运行时间。在每次进行作业调度时，先计算后备作业队列中每个作业的响应比，从中选出响应比最高的作业投入运行。</p>
<p><strong>响应比的变化规律可描述为：</strong></p>
<p><img src="https://pic4.zhimg.com/80/v2-1978d0bf574b9b79b75844e99af5b6c7_720w.webp" alt="img"></p>
<p><strong>根据公式可知：</strong></p>
<p>当作业的等待时间相同时，则要求服务时间越短，其响应比越高，有利于短作业。</p>
<p>当要求服务时间相同时，作业的响应比由其等待时间决定，等待时间越长，其响应比越高，因而它实现的是先来先服务。</p>
<p>对于长作业，作业的响应比可以随等待时间的增加而提高，当其等待时间足够长时，其响应比便可升到很高，从而也可获得处理机。克服了饥饿状态，兼顾了长作业。</p>
<p><strong>时间片轮转调度算法</strong></p>
<p>时间片轮转调度算法主要适用于分时系统。在这种算法中，系统将所有就绪进程按到达时间的先后次序排成一个队列，进程调度程序总是选择就绪队列中第一个进程执行，即先来先服务的原则，但仅能运行一个时间片，如100ms。在使用完一个时间片后，即使进程并未完成其运行，它也必须释放出（被剥夺）处理机给下一个就绪的进程，而被剥夺的进程返回到就绪队列的末尾重新排队，等候再次运行。</p>
<p>在时间片轮转调度算法中，时间片的大小对系统性能的影响很大。如果时间片足够大，以至于所有进程都能在一个时间片内执行完毕，则时间片轮转调度算法就退化为先来先服务调度算法。如果时间片很小，那么处理机将在进程间过于频繁切换，使处理机的开销增大，而真正用于运行用户进程的时间将减少。因此时间片的大小应选择适当。</p>
<p>时间片的长短通常由以下因素确定：系统的响应时间、就绪队列中的进程数目和系统的处理能力。</p>
<p>多级反馈队列调度算法（集合了前几种算法的优点）</p>
<p>多级反馈队列调度算法是时间片轮转调度算法和优先级调度算法的综合和发展，如图2-5 所示。通过动态调整进程优先级和时间片大小，多级反馈队列调度算法可以兼顾多方面的系统目标。例如，为提高系统吞吐量和缩短平均周转时间而照顾短进程；为获得较好的I&#x2F;O设备利用率和缩短响应时间而照顾I&#x2F;O型进程；同时，也不必事先估计进程的执行时间。</p>
<p><img src="https://pic4.zhimg.com/80/v2-8383c3074d90931ecde577f89368508b_720w.webp" alt="img"></p>
<p><strong>多级反馈队列调度算法的实现思想如下：</strong></p>
<p>应设置多个就绪队列，并为各个队列赋予不同的优先级，第1级队列的优先级最高，第2级队列次之，其余队列的优先级逐次降低。</p>
<p>赋予各个队列中进程执行时间片的大小也各不相同，在优先级越高的队列中，每个进程的运行时间片就越小。例如，第2级队列的时间片要比第1级队列的时间片长一倍， ……第i+1级队列的时间片要比第i级队列的时间片长一倍。</p>
<p>当一个新进程进入内存后，首先将它放入第1级队列的末尾，按FCFS原则排队等待调度。当轮到该进程执行时，如它能在该时间片内完成，便可准备撤离系统；如果它在一个时间片结束时尚未完成，调度程序便将该进程转入第2级队列的末尾，再同样地按FCFS 原则等待调度执行；如果它在第2级队列中运行一个时间片后仍未完成，再以同样的方法放入第3级队列……如此下去，当一个长进程从第1级队列依次降到第 n 级队列后，在第 n 级队列中便釆用时间片轮转的方式运行。</p>
<p>仅当第1级队列为空时，调度程序才调度第2级队列中的进程运行；仅当第1 ~ (i-1)级队列均为空时，才会调度第i级队列中的进程运行。如果处理机正在执行第i级队列中的某进程时，又有新进程进入优先级较高的队列（第 1 ~ (i-1)中的任何一个队列），则此时新进程将抢占正在运行进程的处理机，即由调度程序把正在运行的进程放回到第i级队列的末尾，把处理机分配给新到的更高优先级的进程。</p>
<p><strong>多级反馈队列的优势有：</strong></p>
<ul>
<li>终端型作业用户：短作业优先。</li>
<li>短批处理作业用户：周转时间较短。</li>
<li>长批处理作业用户：经过前面几个队列得到部分执行，不会长期得不到处理。</li>
</ul>
<hr>
<p>版权声明：本文为知乎博主「玩转Linux内核」的原创文章，遵循CC 4.0 BY-SA版权协议，转载请附上原文出处链接及本声明。<br>原文链接：<a href="https://zhuanlan.zhihu.com/p/447737355">https://zhuanlan.zhihu.com/p/447737355</a></p>
]]></content>
      <categories>
        <category>linux-doc</category>
      </categories>
      <tags>
        <tag>Linux</tag>
      </tags>
  </entry>
  <entry>
    <title>Linux操作系统学习——内核初始化</title>
    <url>/2023/01/15/linux-docs/Linux%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E5%AD%A6%E4%B9%A0%E2%80%94%E2%80%94%E5%86%85%E6%A0%B8%E5%88%9D%E5%A7%8B%E5%8C%96/</url>
    <content><![CDATA[<h2 id="一-前言"><a href="#一-前言" class="headerlink" title="一. 前言"></a>一. 前言</h2><p>  前文分析到Linux内核正式启动，完成了实模式到保护模式的切换，并做好了各种准备工作。下来就要看开始内核初始化工作了，源码位置位于init&#x2F;main.c中的start_kernel()，源码如附录所示。这包括了一系列重要的初始化工作，本文会介绍其中一部分较为重要的，但是详细的介绍依然会留在后文各个模块的源码学习中单独进行。本文的目的在于承接上文给出一个从内核启动到各个模块开始运转的过程介绍，而不是详细的各部分内容介绍。</p>
<ul>
<li><p>创建0号进程：INIT_TASK(init_task)</p>
</li>
<li><p>异常处理类中断服务程序挂接：trap_init()</p>
</li>
<li><p>内存初始化：mm_init()</p>
</li>
<li><p>调度器初始化sched_init()</p>
</li>
<li><p>剩余初始化：rest_init()</p>
</li>
</ul>
<h2 id="二-0号进程的创建"><a href="#二-0号进程的创建" class="headerlink" title="二. 0号进程的创建"></a>二. 0号进程的创建</h2><p>  start_kernel()上来就会运行 set_task_stack_end_magic(&amp;init_task)创建初始进程。init_task的定义是 struct task_struct init_task &#x3D; INIT_TASK(init_task)。它是系统创建的第一个进程，我们称为 0 号进程。这是唯一一个没有通过 fork 或者 kernel_thread产生的进程，是进程列表的第一个。</p>
<p>  如下所示为init_task的定义，这里只节选了部分，采用了gcc的结构体初始化方式为其进行了直接赋值生成。</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * Set up the first task table, touch at your own risk!. Base=0,</span></span><br><span class="line"><span class="comment"> * limit=0x1fffff (=2MB)</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">task_struct</span> <span class="title">init_task</span></span></span><br><span class="line"><span class="class">#<span class="title">ifdef</span> <span class="title">CONFIG_ARCH_TASK_STRUCT_ON_STACK</span></span></span><br><span class="line"><span class="class">    __<span class="title">init_task_data</span></span></span><br><span class="line"><span class="class">#<span class="title">endif</span></span></span><br><span class="line"><span class="class">=</span> &#123;</span><br><span class="line">    ......</span><br><span class="line">    .state             = <span class="number">0</span>,</span><br><span class="line">    .<span class="built_in">stack</span>             = init_stack,</span><br><span class="line">    .usage             = REFCOUNT_INIT(<span class="number">2</span>),</span><br><span class="line">    .flags             = PF_KTHREAD,</span><br><span class="line">    .prio             = MAX_PRIO - <span class="number">20</span>,</span><br><span class="line">    .static_prio     = MAX_PRIO - <span class="number">20</span>,</span><br><span class="line">    .normal_prio     = MAX_PRIO - <span class="number">20</span>,</span><br><span class="line">    .policy             = SCHED_NORMAL,</span><br><span class="line">    .cpus_ptr         = &amp;init_task.cpus_mask,</span><br><span class="line">    .cpus_mask         = CPU_MASK_ALL,</span><br><span class="line">    .nr_cpus_allowed = NR_CPUS,</span><br><span class="line">    .mm                 = <span class="literal">NULL</span>,</span><br><span class="line">    .active_mm         = &amp;init_mm,</span><br><span class="line">    ......</span><br><span class="line">    .thread_pid         = &amp;init_struct_pid,</span><br><span class="line">    .thread_group     = LIST_HEAD_INIT(init_task.thread_group),</span><br><span class="line">    .thread_node     = LIST_HEAD_INIT(init_signals.thread_head),</span><br><span class="line">    ......</span><br><span class="line">&#125;;</span><br><span class="line">EXPORT_SYMBOL(init_task);</span><br></pre></td></tr></table></figure>
<p>  而 set_task_stack_end_magic(&amp;init_task)函数的源码如下，主要是通过end_of_stack()获取栈边界地址，然后把栈底地址设置为STACK_END_MAGIC，作为栈溢出的标记。每个进程创建的时候，系统会为这个进程创建2个页大小的内核栈。</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">set_task_stack_end_magic</span><span class="params">(<span class="keyword">struct</span> task_struct *tsk)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">unsigned</span> <span class="type">long</span> *stackend;</span><br><span class="line"></span><br><span class="line">    stackend = end_of_stack(tsk);</span><br><span class="line">    *stackend = STACK_END_MAGIC;    <span class="comment">/* for overflow detection */</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>  init_task是静态定义的一个进程，也就是说当内核被放入内存时，它就已经存在，它没有自己的用户空间，一直处于内核空间中运行，并且也只处于内核空间运行。0号进程用于包括内存、页表、必要数据结构、信号、调度器、硬件设备等的初始化。当它执行到最后（剩余初始化）时，将start_kernel中所有的初始化执行完成后，会在内核中启动一个kernel_init内核线程和一个kthreadd内核线程，kernel_init内核线程执行到最后会通过execve系统调用执行转变为我们所熟悉的init进程，而kthreadd内核线程是内核用于管理调度其他的内核线程的守护线程。在最后init_task将变成一个idle进程，用于在CPU没有进程运行时运行它，它在此时仅仅用于空转。</p>
<h2 id="三-中断初始化"><a href="#三-中断初始化" class="headerlink" title="三. 中断初始化"></a>三. 中断初始化</h2><p>  由代码可见，trap_init()设置了很多的中断门（Interrupt Gate)，用于处理各种中断，如系统调用的中断门set_system_intr_gate(IA32_SYSCALL_VECTOR, entry_INT80_32)。</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">trap_init</span><span class="params">(<span class="type">void</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">int</span> i;</span><br><span class="line">    <span class="comment">//设置系统的硬件中断 中断位于kernel/asm.s 或 system_call.s</span></span><br><span class="line">    set_trap_gate(<span class="number">0</span>,÷_error);<span class="comment">//0中断，位于/kernel/asm.s 19行</span></span><br><span class="line">    set_trap_gate(<span class="number">1</span>,&amp;debug);</span><br><span class="line">    set_trap_gate(<span class="number">2</span>,&amp;nmi);</span><br><span class="line">    set_system_gate(<span class="number">3</span>,&amp;int3);    <span class="comment">/* int3-5 can be called from all */</span></span><br><span class="line">    set_system_gate(<span class="number">4</span>,&amp;overflow);</span><br><span class="line">    set_system_gate(<span class="number">5</span>,&amp;bounds);</span><br><span class="line">    set_trap_gate(<span class="number">6</span>,&amp;invalid_op);</span><br><span class="line">    set_trap_gate(<span class="number">7</span>,&amp;device_not_available);</span><br><span class="line">    set_trap_gate(<span class="number">8</span>,&amp;double_fault);</span><br><span class="line">    set_trap_gate(<span class="number">9</span>,&amp;coprocessor_segment_overrun);</span><br><span class="line">    set_trap_gate(<span class="number">10</span>,&amp;invalid_TSS);</span><br><span class="line">    set_trap_gate(<span class="number">11</span>,&amp;segment_not_present);</span><br><span class="line">    set_trap_gate(<span class="number">12</span>,&amp;stack_segment);</span><br><span class="line">    set_trap_gate(<span class="number">13</span>,&amp;general_protection);</span><br><span class="line">    set_trap_gate(<span class="number">14</span>,&amp;page_fault);</span><br><span class="line">    set_trap_gate(<span class="number">15</span>,&amp;reserved);</span><br><span class="line">    set_trap_gate(<span class="number">16</span>,&amp;coprocessor_error);</span><br><span class="line">    <span class="keyword">for</span> (i=<span class="number">17</span>;i&lt;<span class="number">48</span>;i++)</span><br><span class="line">        set_trap_gate(i,&amp;reserved);</span><br><span class="line">    set_trap_gate(<span class="number">45</span>,&amp;irq13);</span><br><span class="line">    outb_p(inb_p(<span class="number">0x21</span>)&amp;<span class="number">0xfb</span>,<span class="number">0x21</span>);</span><br><span class="line">    outb(inb_p(<span class="number">0xA1</span>)&amp;<span class="number">0xdf</span>,<span class="number">0xA1</span>);</span><br><span class="line">    set_trap_gate(<span class="number">39</span>,¶llel_interrupt);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="四-内存初始化"><a href="#四-内存初始化" class="headerlink" title="四. 内存初始化"></a>四. 内存初始化</h2><p>  内存相关的初始化内容放在mm_init()中进行，代码如下所示</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">// init/main.c</span></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * Set up kernel memory allocators</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="type">static</span> <span class="type">void</span> __init <span class="title function_">mm_init</span><span class="params">(<span class="type">void</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">     * page_ext requires contiguous pages,</span></span><br><span class="line"><span class="comment">     * bigger than MAX_ORDER unless SPARSEMEM.</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    page_ext_init_flatmem();</span><br><span class="line">    mem_init();</span><br><span class="line">    kmem_cache_init();</span><br><span class="line">    pgtable_init();</span><br><span class="line">    vmalloc_init();</span><br><span class="line">    ioremap_huge_init();</span><br><span class="line">    <span class="comment">/* Should be run before the first non-init thread is created */</span></span><br><span class="line">    init_espfix_bsp();</span><br><span class="line">    <span class="comment">/* Should be run after espfix64 is set up. */</span></span><br><span class="line">    pti_init();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>  调用的函数功能基本如名字所示，主要进行了以下初始化设置：</p>
<ul>
<li>page_ext_init_flatmem()和cgroup的初始化相关，该部分是docker技术的核心部分</li>
<li>mem_init()初始化内存管理的伙伴系统</li>
<li>kmem_cache_init()完成内核slub内存分配体系的初始化，相关的还有buffer_init</li>
<li>pgtable_init()完成页表初始化，包括页表锁ptlock_init()和</li>
<li>vmalloc_init()完成vmalloc的初始化</li>
<li>ioremap_huge_init() ioremap实现I&#x2F;O内存资源由物理地址映射到虚拟地址空间，此处为其功能的初始化</li>
<li>init_espfix_bsp()和pti_init()完成PTI（page table isolation）的初始化</li>
</ul>
<p>  此处不展开说明这些函数，留待后面内存管理部分详细分析各个部分。</p>
<h2 id="五-调度器初始化"><a href="#五-调度器初始化" class="headerlink" title="五. 调度器初始化"></a>五. 调度器初始化</h2><p>  调度器初始化通过sched_init()完成，其主要工作包括</p>
<ul>
<li>对相关数据结构分配内存：如初始化waitqueues数组，根据调度方式FAIR&#x2F;RT设置alloc_size，调用kzalloc分配空间</li>
<li>初始化root_task_group：根据FAIR&#x2F;RT的不同，将kzalloc分配的空间用于其初始化，主要结构task_group包含以下几个重要组成部分：se, rt_se, cfs_rq 以及 rt_rq。其中cfs_rq和rt_rq表示run queue，即一种特殊的per-cpu结构体用于内核调度器存储激活的线程。</li>
<li>调用for_each_possible_cpu()初始化每个possibleCPU（存储于cpu_possible_mask为图中）的runqueue队列(包括其中的cfs队列和实时进程队列)，rq结构体是调度进程的基本数据结构，调度器用rq决定下一个将要被调度的进程。详细介绍会在调度一节进行。</li>
<li>调用set_load_weight(&amp;init_task)，将init_task进程转变为idle进程</li>
<li>需要说明的是init_task在这里会被转变为idle进程，但是它还会继续执行初始化工作，相当于这里只是给init_task挂个idle进程的名号，它其实还是init_task进程，只有到最后init_task进程开启了kernel_init和kthreadd进程之后，才转变为真正意义上的idle进程。</li>
</ul>
<h2 id="六-剩余初始化"><a href="#六-剩余初始化" class="headerlink" title="六. 剩余初始化"></a>六. 剩余初始化</h2><p>  rest_init是非常重要的一步，主要包括了区分内核态和用户态、初始化1号进程和初始化2号进程。</p>
<h3 id="6-1-内核态和用户态"><a href="#6-1-内核态和用户态" class="headerlink" title="6.1 内核态和用户态"></a>6.1 内核态和用户态</h3><p>  在运行用户进程之前，尚需要完成一件事：区分内核态和用户态。x86 提供了分层的权限机制，把区域分成了四个 Ring，越往里权限越高，越往外权限越低。操作系统很好地利用了这个机制，将能够访问关键资源的代码放在 Ring0，我们称为内核态（Kernel Mode）；将普通的程序代码放在 Ring3，我们称为用户态（User Mode）。</p>
<p><img src="https://user-images.githubusercontent.com/87457873/128179077-86195ad6-7e0c-429f-b977-d9539a912405.png" alt="image"></p>
<h3 id="6-2-初始化1号进程"><a href="#6-2-初始化1号进程" class="headerlink" title="6.2 初始化1号进程"></a>6.2 初始化1号进程</h3><p>  rest_init() 的一大工作是，用 kernel_thread(kernel_init, NULL, CLONE_FS)创建第二个进程，这个是 1 号进程。1 号进程对于操作系统来讲，有“划时代”的意义，因为它将运行一个用户进程，并从此开始形成用户态进程树。这里主要需要分析的是如何完成从内核态到用户态切换的过程。kernel_thread()代码如下所示，可见其中最主要的是第一个参数指针函数fn决定了栈中的内容，根据fn的不同将生成1号进程和后面的2号进程。</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * Create a kernel thread.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="type">pid_t</span> <span class="title function_">kernel_thread</span><span class="params">(<span class="type">int</span> (*fn)(<span class="type">void</span> *), <span class="type">void</span> *arg, <span class="type">unsigned</span> <span class="type">long</span> flags)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">kernel_clone_args</span> <span class="title">args</span> =</span> &#123;</span><br><span class="line">        .flags        = ((flags | CLONE_VM | CLONE_UNTRACED) &amp; ~CSIGNAL),</span><br><span class="line">        .exit_signal    = (flags &amp; CSIGNAL),</span><br><span class="line">        .<span class="built_in">stack</span>        = (<span class="type">unsigned</span> <span class="type">long</span>)fn,</span><br><span class="line">        .stack_size    = (<span class="type">unsigned</span> <span class="type">long</span>)arg,</span><br><span class="line">    &#125;;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> _do_fork(&amp;args);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>  kernel_thread() 的参数是一个函数 kernel_init()，核心代码如下：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="keyword">if</span> (ramdisk_execute_command) </span><br><span class="line">&#123; </span><br><span class="line">    ret = run_init_process(ramdisk_execute_command);</span><br><span class="line">    ...... </span><br><span class="line">&#125;</span><br><span class="line">...... </span><br><span class="line"><span class="keyword">if</span> (!try_to_run_init_process(<span class="string">&quot;/sbin/init&quot;</span>) || </span><br><span class="line">    !try_to_run_init_process(<span class="string">&quot;/etc/init&quot;</span>)  || </span><br><span class="line">    !try_to_run_init_process(<span class="string">&quot;/bin/init&quot;</span>)  || </span><br><span class="line">    !try_to_run_init_process(<span class="string">&quot;/bin/sh&quot;</span>)) </span><br><span class="line">   <span class="keyword">return</span> <span class="number">0</span>;</span><br></pre></td></tr></table></figure>
<p>  这就说明，1 号进程运行的是一个文件。如果我们打开 run_init_process() 函数，会发现它调用的是 do_execve()。</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">static</span> <span class="type">int</span> <span class="title function_">run_init_process</span><span class="params">(<span class="type">const</span> <span class="type">char</span> *init_filename)</span></span><br><span class="line">&#123; </span><br><span class="line">    argv_init[<span class="number">0</span>] = init_filename; </span><br><span class="line">    <span class="keyword">return</span> do_execve(getname_kernel(init_filename), </span><br><span class="line">                     (<span class="type">const</span> <span class="type">char</span> __user *<span class="type">const</span> __user *)argv_init, </span><br><span class="line">                     (<span class="type">const</span> <span class="type">char</span> __user *<span class="type">const</span> __user *)envp_init);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>  接着会进行一系列的调用：do_execve-&gt;do_execveat_common-&gt;exec_binprm-&gt;search_binary_handler，这里search_binary_handler()主要是加载ELF文件（Executable and Linkable Format，可执行与可链接格式），代码如下</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">search_binary_handler</span><span class="params">(<span class="keyword">struct</span> linux_binprm *bprm)</span></span><br><span class="line">&#123; </span><br><span class="line">    ...... </span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">linux_binfmt</span> *<span class="title">fmt</span>;</span> </span><br><span class="line">    ...... </span><br><span class="line">    retval = fmt-&gt;load_binary(bprm); </span><br><span class="line">    ......</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>  load_binary先调用load_elf_binary，最后调用start_thread</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">void</span></span><br><span class="line"><span class="title function_">start_thread</span><span class="params">(<span class="keyword">struct</span> pt_regs *regs, <span class="type">unsigned</span> <span class="type">long</span> new_ip, <span class="type">unsigned</span> <span class="type">long</span> new_sp)</span></span><br><span class="line">&#123;</span><br><span class="line">    set_user_gs(regs, <span class="number">0</span>);</span><br><span class="line">    regs-&gt;fs  = <span class="number">0</span>;</span><br><span class="line">    regs-&gt;ds  = __USER_DS;</span><br><span class="line">    regs-&gt;es  = __USER_DS;</span><br><span class="line">    regs-&gt;ss  = __USER_DS;</span><br><span class="line">    regs-&gt;cs  = __USER_CS;</span><br><span class="line">    regs-&gt;ip  = new_ip;</span><br><span class="line">    regs-&gt;sp  = new_sp;</span><br><span class="line">    regs-&gt;flags  = X86_EFLAGS_IF;</span><br><span class="line">    force_iret();</span><br><span class="line">&#125;</span><br><span class="line">EXPORT_SYMBOL_GPL(start_thread);</span><br></pre></td></tr></table></figure>
<p>  这个结构就是在系统调用的时候，内核中保存用户态运行上下文的，里面将用户态的代码段 CS 设置为 __USER_CS，将用户态的数据段 DS 设置为 __USER_DS，以及指令指针寄存器 IP、栈指针寄存器 SP。这里相当于补上了原来系统调用里，保存寄存器的一个步骤。最后的 iret 是干什么的呢？它是用于从系统调用中返回。这个时候会恢复寄存器。从哪里恢复呢？按说是从进入系统调用的时候，保存的寄存器里面拿出。好在上面的函数补上了寄存器。CS 和指令指针寄存器 IP 恢复了，指向用户态下一个要执行的语句。DS 和函数栈指针 SP 也被恢复了，指向用户态函数栈的栈顶。所以，下一条指令，就从用户态开始运行了。</p>
<p>  经过上述过程，我们完成了从内核态切换到用户态。而此时代码其实还在运行 kernel_init函数，会调用</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="keyword">if</span> (!ramdisk_execute_command)</span><br><span class="line">    ramdisk_execute_command = <span class="string">&quot;/init&quot;</span>;</span><br></pre></td></tr></table></figure>
<p>  结合上面的init程序，这里出现了第二个init。这是有其存在的必要性的：上文提到的 init 程序是在文件系统上的，文件系统一定是在一个存储设备上的，例如硬盘。Linux 访问存储设备，要有驱动才能访问。如果存储系统数目很有限，那驱动可以直接放到内核里面，反正前面我们加载过内核到内存里了，现在可以直接对存储系统进行访问。但是存储系统越来越多了，如果所有市面上的存储系统的驱动都默认放进内核，内核就太大了。这该怎么办呢？</p>
<p>  我们只好先弄一个基于内存的文件系统。内存访问是不需要驱动的，这个就是 ramdisk。这个时候，ramdisk 是根文件系统。然后，我们开始运行 ramdisk 上的 &#x2F;init。等它运行完了就已经在用户态了。&#x2F;init 这个程序会先根据存储系统的类型加载驱动，有了驱动就可以设置真正的根文件系统了。有了真正的根文件系统，ramdisk 上的 &#x2F;init 会启动文件系统上的 init。接下来就是各种系统的初始化。启动系统的服务，启动控制台，用户就可以登录进来了。</p>
<h3 id="6-3-初始化2号进程"><a href="#6-3-初始化2号进程" class="headerlink" title="6.3 初始化2号进程"></a>6.3 初始化2号进程</h3><p>  rest_init 另一大事情就是创建第三个进程，就是 2 号进程。kernel_thread(kthreadd, NULL, CLONE_FS | CLONE_FILES)又一次使用 kernel_thread 函数创建进程。这里需要指出一点，函数名 thread 可以翻译成“线程”，这也是操作系统很重要的一个概念。从内核态来看，无论是进程，还是线程，我们都可以统称为任务（Task），都使用相同的数据结构，平放在同一个链表中。这里的函数kthreadd，负责所有内核态的线程的调度和管理，是内核态所有线程运行的祖先。</p>
<p>  kthreadd，即2号进程，用于内核态线程的管理，是一个守护线程。其源码如下所示，运行流程包括</p>
<ul>
<li>初始化了task结构，并将该线程设置为允许任意CPU运行。</li>
<li>进入循环，将线程状态设置为TASK_INTERRUPTIBLE，如果当前kthread_create_list为空，没有要创建的线程，则执行schedule()让出CPU资源。</li>
<li>如果需要创建，则设置为TASK_RUNNING状态，加上锁spin_lock，从链表中取得kthread_create_info 结构的地址，在上文中已经完成插入操作(将kthread_create_info结构中的 list 成员加到链表中，此时根据成员 list 的偏移获得 create)</li>
<li>调用create_kthread(create)完成线程的创建</li>
</ul>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">kthreadd</span><span class="params">(<span class="type">void</span> *unused)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">task_struct</span> *<span class="title">tsk</span> =</span> current;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* Setup a clean context for our children to inherit. */</span></span><br><span class="line">    set_task_comm(tsk, <span class="string">&quot;kthreadd&quot;</span>);</span><br><span class="line">    ignore_signals(tsk);</span><br><span class="line">    set_cpus_allowed_ptr(tsk, cpu_all_mask);</span><br><span class="line">    set_mems_allowed(node_states[N_MEMORY]);</span><br><span class="line"></span><br><span class="line">    current-&gt;flags |= PF_NOFREEZE;</span><br><span class="line">    cgroup_init_kthreadd();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (;;) &#123;</span><br><span class="line">        set_current_state(TASK_INTERRUPTIBLE);</span><br><span class="line">        <span class="keyword">if</span> (list_empty(&amp;kthread_create_list))</span><br><span class="line">            schedule();</span><br><span class="line">        __set_current_state(TASK_RUNNING);</span><br><span class="line"></span><br><span class="line">        spin_lock(&amp;kthread_create_lock);</span><br><span class="line">        <span class="keyword">while</span> (!list_empty(&amp;kthread_create_list)) &#123;</span><br><span class="line">            <span class="class"><span class="keyword">struct</span> <span class="title">kthread_create_info</span> *<span class="title">create</span>;</span></span><br><span class="line"></span><br><span class="line">            create = list_entry(kthread_create_list.next,</span><br><span class="line">                        <span class="keyword">struct</span> kthread_create_info, <span class="built_in">list</span>);</span><br><span class="line">            list_del_init(&amp;create-&gt;<span class="built_in">list</span>);</span><br><span class="line">            spin_unlock(&amp;kthread_create_lock);</span><br><span class="line"></span><br><span class="line">            create_kthread(create);</span><br><span class="line"></span><br><span class="line">            spin_lock(&amp;kthread_create_lock);</span><br><span class="line">        &#125;</span><br><span class="line">        spin_unlock(&amp;kthread_create_lock);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>  而create_kthread(create)函数做了一件让人意外的事情：调用了kernel_thread()，所以又回到了创建1号进程和2号进程的函数上，这次的回调函数为kthread，该函数才会真正意义上分配内存、初始化一个新的内核线程。</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">static</span> <span class="type">void</span> <span class="title function_">create_kthread</span><span class="params">(<span class="keyword">struct</span> kthread_create_info *create)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">int</span> pid;</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">ifdef</span> CONFIG_NUMA</span></span><br><span class="line">    current-&gt;pref_node_fork = create-&gt;node;</span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line">    <span class="comment">/* We want our own signal handler (we take no signals by default). */</span></span><br><span class="line">    pid = kernel_thread(kthread, create, CLONE_FS | CLONE_FILES | SIGCHLD);</span><br><span class="line">    <span class="keyword">if</span> (pid &lt; <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="comment">/* If user was SIGKILLed, I release the structure. */</span></span><br><span class="line">        <span class="class"><span class="keyword">struct</span> <span class="title">completion</span> *<span class="title">done</span> =</span> xchg(&amp;create-&gt;done, <span class="literal">NULL</span>);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (!done) &#123;</span><br><span class="line">            kfree(create);</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        create-&gt;result = ERR_PTR(pid);</span><br><span class="line">        complete(done);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>  下面是kthread的源码，这里有个很重要的地方：新创建的线程由于执行了 schedule() 调度，此时并没有执行，直到我们使用wake_up_process(p)唤醒新创建的线程。线程被唤醒后, 会接着执行最后一段threadfn(data)</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">static</span> <span class="type">int</span> <span class="title function_">kthread</span><span class="params">(<span class="type">void</span> *_create)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">/* Copy data: it&#x27;s on kthread&#x27;s stack */</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">kthread_create_info</span> *<span class="title">create</span> =</span> _create;</span><br><span class="line">    <span class="type">int</span> (*threadfn)(<span class="type">void</span> *data) = create-&gt;threadfn;</span><br><span class="line">    <span class="type">void</span> *data = create-&gt;data;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">completion</span> *<span class="title">done</span>;</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">kthread</span> *<span class="title">self</span>;</span></span><br><span class="line">    <span class="type">int</span> ret;</span><br><span class="line"></span><br><span class="line">    self = kzalloc(<span class="keyword">sizeof</span>(*self), GFP_KERNEL);</span><br><span class="line">    set_kthread_struct(self);</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* If user was SIGKILLed, I release the structure. */</span></span><br><span class="line">    done = xchg(&amp;create-&gt;done, <span class="literal">NULL</span>);</span><br><span class="line">    <span class="keyword">if</span> (!done) &#123;</span><br><span class="line">        kfree(create);</span><br><span class="line">        do_exit(-EINTR);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (!self) &#123;</span><br><span class="line">        create-&gt;result = ERR_PTR(-ENOMEM);</span><br><span class="line">        complete(done);</span><br><span class="line">        do_exit(-ENOMEM);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    self-&gt;data = data;</span><br><span class="line">    init_completion(&amp;self-&gt;exited);</span><br><span class="line">    init_completion(&amp;self-&gt;parked);</span><br><span class="line">    current-&gt;vfork_done = &amp;self-&gt;exited;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* OK, tell user we&#x27;re spawned, wait for stop or wakeup */</span></span><br><span class="line">    __set_current_state(TASK_UNINTERRUPTIBLE);</span><br><span class="line">    create-&gt;result = current;</span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">     * Thread is going to call schedule(), do not preempt it,</span></span><br><span class="line"><span class="comment">     * or the creator may spend more time in wait_task_inactive().</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    preempt_disable();</span><br><span class="line">    complete(done);</span><br><span class="line">    schedule_preempt_disabled();</span><br><span class="line">    preempt_enable();</span><br><span class="line"></span><br><span class="line">    ret = -EINTR;</span><br><span class="line">    <span class="keyword">if</span> (!test_bit(KTHREAD_SHOULD_STOP, &amp;self-&gt;flags)) &#123;</span><br><span class="line">        cgroup_kthread_ready();</span><br><span class="line">        __kthread_parkme(self);</span><br><span class="line">        ret = threadfn(data);</span><br><span class="line">    &#125;</span><br><span class="line">    do_exit(ret);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>  由此，我们可以总结一下第2号进程的工作流程：</p>
<ul>
<li><p>第2号进程kthreadd进程由第0号进程通过kernel_thread()创建，并始终运行在内核空间, 负责所有内核线程的调度和管理</p>
</li>
<li><p>第2号进程会循环检测kthread_create_list全局链表, 当我们调用kernel_thread创建内核线程时，新线程会被加入到此链表中，因此所有的内核线程都是直接或者间接的以kthreadd为父进程</p>
</li>
<li><p>检测到新线程创建，则调用kernel_thread()创建线程，其回调为kthread</p>
</li>
<li><p>kthread在创建完后调用schedule()让出CPU资源，而不是直接运行。等待收到wake_up_process(p)的唤醒后再继续执行threadfn(data)。</p>
<p>因此</p>
</li>
<li><p>任何一个内核线程入口都是 kthread()</p>
</li>
<li><p>通过kthread_create()创建的内核线程不会立刻运行，需要手工 wake up.</p>
</li>
<li><p>通过kthread_create() 创建的内核线程有可能不会执行相应线程函数threadfn而直接退出</p>
</li>
</ul>
<p>  回到rest_init()，当完成了1号2号进程的创建后，我们将0号进程真正归位idle进程，结束rest_init()，也正事结束了start_kernel()函数，由此，内核初始化全部完成。</p>
<h2 id="七-总结"><a href="#七-总结" class="headerlink" title="七. 总结"></a>七. 总结</h2><p>  <br>  本文介绍了内核初始化的几个重要部分，其实还有很多初始化没有介绍，如cgroup初始化、虚拟文件系统初始化、radix树初始化、rcu初始化、计时器和时间初始化、架构初始化等等，这些会在后面有针对性的单独介绍。</p>
]]></content>
      <categories>
        <category>linux-doc</category>
      </categories>
      <tags>
        <tag>Linux</tag>
      </tags>
  </entry>
  <entry>
    <title>Linux操作系统学习——内核运行</title>
    <url>/2023/01/15/linux-docs/Linux%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E5%AD%A6%E4%B9%A0%E2%80%94%E2%80%94%E5%86%85%E6%A0%B8%E8%BF%90%E8%A1%8C/</url>
    <content><![CDATA[<h2 id="一-前言"><a href="#一-前言" class="headerlink" title="一. 前言"></a>一. 前言</h2><p>  <br>  上文中，我们分析了从按下电源键到BootLoader完成加载的过程。加载完成之后，就要正式启动Linux内核了，而在这之前首先要完成从实模式到保护模式的切换。本文主要分析以下几部分内容</p>
<ul>
<li>新旧中断的交替</li>
<li>打开A20</li>
<li>进入main函数</li>
<li>内核初始化</li>
</ul>
<p>  其实整个过程中还有很多内容，比如检查各种硬件设备等，在此略过不提。下面就开始潜入Linux源码的海洋畅游啦。</p>
<h2 id="二-新旧中断的交替"><a href="#二-新旧中断的交替" class="headerlink" title="二. 新旧中断的交替"></a>二. 新旧中断的交替</h2><p>  在实模式下的中断显然不可以和保护模式的中断同日而语，因此我们需要关闭旧的中断（cli）并确立新的中断（sti）。main函数能够适应保护模式的中断服务体系被重建完毕才会打开中断，而那时候响应中断的服务程序将不再是BIOS提供的中断服务程序，取而代之的是由系统自身提供的中断服务程序。</p>
<p>  cli、sti总是在一个完整操作过程的两头出现，目的是避免中断在此期间的介入。接下来的代码将为操作系统进入保护模式做准备。此处即将进行实模式下中断向量表和保护模式下中断描述符表（IDT）的交接工作。试想，如果没有cli，又恰好发生中断，如用户不小心碰了一下键盘，中断就要切进来，就不得不面对实模式的中断机制已经废除、保护模式的中断机制尚未完成的尴尬局面，结果就是系统崩溃。cli、sti保证了这个过程中，IDT能够完整创建，以避免不可预料中断的进入造成IDT创建不完整或新老中断机制混用。</p>
<pre><code>#boot/setup.s
……
do _move：
mov es,ax！destination segment
add ax，#0x1000
cmp ax，#0x9000
jz end_move
mov ds,ax！source segment
sub di,di
sub si,si
mov cx，#0x8000
rep
movsw
jmp do_move
</code></pre>
<p>  如上代码主要完成了一项工作：将位于0x10000处的内核程序复制至内存地址起始位置0x00000处。在上一节我们分析了实模式中的存储分布图，在此位置原来存放着由BIOS建立的中断向量表及BIOS数据区。这个复制动作将BIOS中断向量表和BIOS数据区完全覆盖，使它们不复存在。这样做的好处如下：</p>
<p>1、废除BIOS的中断向量表，等同于废除了BIOS提供的实模式下的中断服务程序。<br><br>2、收回刚刚结束使用寿命的程序所占内存空间。<br><br>3、让内核代码占据内存物理地址最开始的、天然的、有利的位置。<br></p>
<p>  此时，重要角色要登场了，他们就是中断描述符表IDT和全局描述符表GDT。</p>
<ul>
<li>GDT（Global Descriptor Table，全局描述符表），在系统中唯一的存放段寄存器内容（段描述符）的数组，配合程序进行保护模式下的段寻址。它在操作系统的进程切换中具有重要意义，可理解为所有进程的总目录表，其中存放每一个任务（task）局部描述符表（LDT, Local Descriptor Table）地址和任务状态段（TSS, Task Structure Segment）地址，完成进程中各段的寻址、现场保护与现场恢复。GDTR是GDT基地址寄存器，当程序通过段寄存器引用一个段描述符时，需要取得GDT的入口，GDTR标识的即为此入口。在操作系统对GDT的初始化完成后，可以用LGDT（Load GDT）指令将GDT基地址加载至GDTR。</li>
<li>IDT（Interrupt Descriptor Table，中断描述符表），保存保护模式下所有中断服务程序的入口地址，类似于实模式下的中断向量表。IDTR（IDT基地址寄存器），保存IDT的起始地址。</li>
</ul>
<p>  32位的中断机制和16位的中断机制，在原理上有比较大的差别。最明显的是16位的中断机制用的是中断向量表，中断向量表的起始位置在0x00000处，这个位置是固定的；32位的中断机制用的是中断描述符表（IDT），位置是不固定的，可以由操作系统的设计者根据设计要求灵活安排，由IDTR来锁定其位置。GDT是保护模式下管理段描述符的数据结构，对操作系统自身的运行以及管理、调度进程有重大意义。</p>
<p>  此时此刻内核尚未真正运行起来，还没有进程，所以现在创建的GDT第一项为空，第二项为内核代码段描述符，第三项为内核数据段描述符，其余项皆为空。IDT虽然已经设置，实为一张空表，原因是目前已关中断，无需调用中断服务程序。此处反映的是数据“够用即得”的思想。</p>
<p>创建这两个表的过程可理解为是分两步进行的：</p>
<p>1、在设计内核代码时，已经将两个表写好，并且把需要的数据也写好。此处的数据区域是在内核源代码中设定、编译并直接加载至内存形成的一块数据区域。专用寄存器的指向由程序中的lidt和lgdt指令完成<br><br>2、将专用寄存器（IDTR、GDTR）指向表。</p>
<h2 id="三-A20"><a href="#三-A20" class="headerlink" title="三. A20"></a>三. A20</h2><p>  A20启用是一个标志性的动作，由上文提到的lzma_decompress.img 调用 real_to_prot启动。打开A20，意味着CPU可以进行32位寻址，最大寻址空间为4 GB。注意图1-19中内存条范围的变化：从5个F扩展到8个F，即0xFFFFFFFF(4 GB)。</p>
<p>  实模式下，当程序寻址超过0xFFFFF时，CPU将“回滚”至内存地址起始处寻址（注意，在只有20根地址线的条件下，0xFFFFF+1&#x3D;0x00000，最高位溢出）。例如，系统的段寄存器（如CS）的最大允许地址为0xFFFF，指令指针（IP）的最大允许段内偏移也为0xFFFF，两者确定的最大绝对地址为0x10FFEF，这将意味着程序中可产生的实模式下的寻址范围比1 MB多出将近64 KB（一些特殊寻址要求的程序就利用了这个特点）。这样，此处对A20地址线的启用相当于关闭CPU在实模式下寻址的“回滚”机制。如下所示为利用此特点来验证A20地址线是否确实已经打开。注意此处代码并不在此时运行，而是在后续head运行过程中为了检测是否处于保护模式中使用。</p>
<pre><code>#boot/head.s
……
xorl %eax，%eax
1：incl%eax#check that A20 really IS enabled
movl %eax，0x000000#loop forever if it isn&#39;t
cmpl %eax，0x100000
je 1b
……
</code></pre>
<p>  A20如果没打开，则计算机处于20位的寻址模式，超过0xFFFFF寻址必然“回滚”。一个特例是0x100000会回滚到0x000000，也就是说，地址0x100000处存储的值必然和地址0x000000处存储的值完全相同。通过在内存0x000000位置写入一个数据，然后比较此处和1 MB（0x100000，注意，已超过实模式寻址范围）处数据是否一致，就可以检验A20地址线是否已打开。</p>
<h2 id="四-进入main函数"><a href="#四-进入main函数" class="headerlink" title="四. 进入main函数"></a>四. 进入main函数</h2><p>  这里涉及到一个硬件知识：在X86体系中，采用的终端控制芯片名为8259A，此芯片，是可以用程序控制的中断控制器。单个的8259A能管理8级向量优先级中断，在不增加其他电路的情况下，最多可以级联成64级的向量优先级中断系统。CPU在保护模式下，int 0x00～int 0x1F被Intel保留作为内部（不可屏蔽）中断和异常中断。如果不对8259A进行重新编程，int 0x00～int 0x1F中断将被覆盖。例如，IRQ0（时钟中断）为8号（int 0x08）中断，但在保护模式下此中断号是Intel保留的“Double Fault”（双重故障）。因此，必须通过8259A编程将原来的IRQ0x00～IRQ0x0F对应的中断号重新分布，即在保护模式下，IRQ0x00～IRQ0x0F的中断号是int 0x20～int 0x2F。</p>
<p>  setup程序通过下面代码将CPU工作方式设为保护模式。这里涉及到一个CR0寄存器：0号32位控制寄存器，放系统控制标志。第0位为PE（Protected Mode Enable，保护模式使能）标志，置1时CPU工作在保护模式下，置0时为实模式。将CR0寄存器第0位（PE）置1，即设定处理器工作方式为保护模式。CPU工作方式转变为保护模式，一个重要的特征就是要根据GDT决定后续执行哪里的程序。前文提到GDT初始时已写好了数据，这些将用来完成从setup程序到head程序的跳转。</p>
<pre><code>#boot/setup.s
mov ax，#0x0001！protected mode（PE）bit
lmsw ax！This is it！
jmpi 0，8！jmp offset 0 of segment 8（cs）
</code></pre>
<p>  head程序是进入main之前的最后一步了。head在空间创建了内核分页机制，即在0x000000的位置创建了页目录表、页表、缓冲区、GDT、IDT，并将head程序已经执行过的代码所占内存空间覆盖。这意味着head程序自己将自己废弃，main函数即将开始执行。具体的分页机制因为较为复杂，所以打算放在后续介绍内存管理的部分再单独介绍。</p>
<p>  head构造IDT，使中断机制的整体架构先搭建起来（实际的中断服务程序挂接则在main函数中完成），并使所有中断服务程序指向同一段只显示一行提示信息就返回的服务程序。从编程技术上讲，这种初始化操作，既可以防止无意中覆盖代码或数据而引起的逻辑混乱，也可以对开发过程中的误操作给出及时的提示。IDT有256个表项，实际只使用了几十个，对于误用未使用的中断描述符，这样的提示信息可以提醒开发人员注意错误。</p>
<p>  除此之外，head程序要废除已有的GDT，并在内核中的新位置重新创建GDT。原来GDT所在的位置是设计代码时在setup.s里面设置的数据，将来这个setup模块所在的内存位置会在设计缓冲区时被覆盖。如果不改变位置，将来GDT的内容肯定会被缓冲区覆盖掉，从而影响系统的运行。这样一来，将来整个内存中唯一安全的地方就是现在head.s所在的位置了。</p>
<p>  下来步骤主要包括</p>
<p>1、初始化段寄存器和堆栈</p>
<p>2、主要包括将DS和ES寄存器指向相同的地址，并将DS和CS设置为相同的值。</p>
<p>3、清零eflag寄存器以及内核未初始化数据区</p>
<p>4、调用decompress_kernel()解压内核映像并跳转至0X00100000处。</p>
<p>5、段寄存器初始化为最终值并填充BSS字段为0</p>
<p>初始化临时内核页表</p>
<p>  最终完成了分页机制初始化后，PG（Paging) 标志位将会置1，表示地址映射模式采取分页机制，最终跳转至main函数，内核开始初始化工作。</p>
<h2 id="五-内核初始化"><a href="#五-内核初始化" class="headerlink" title="五. 内核初始化"></a>五. 内核初始化</h2><p>  注意，至此为止，我们尚未打开中断，而必须通过main函数完成一系列的初始化后才会打开新的中断，从而使内核正式运行起来。该部分主要包括：</p>
<p>1、为进程0建立内核态堆栈</p>
<p>2、清零eflags寄存器</p>
<p>3、调用setup_idt()用空的中断处理程序填充IDT</p>
<p>4、把BIOS中获得的参数传递给第一个页框</p>
<p>5、用GDT和IDT表填充寄存器</p>
<p>  完成这些之后，内核就正式运行，开始创建0号进程了。</p>
<h2 id="六-总结"><a href="#六-总结" class="headerlink" title="六. 总结"></a>六. 总结</h2><p>  本文介绍了实模式到保护模式的整个切换过程，完成了内核的加载并开始正式准备创建0号进程。后续将继续分析启动内核创建0号、1号、2号进程的整个过程。本文介绍过程中忽略了很多汇编代码以及一些虽然很重要但是不属于基本流程的知识，有兴趣了解的可以根据文中链接、文末的源码和参考资料进行更深入的学习研究。</p>
]]></content>
      <categories>
        <category>linux-doc</category>
      </categories>
      <tags>
        <tag>Linux</tag>
      </tags>
  </entry>
  <entry>
    <title>Linux操作系统学习——启动</title>
    <url>/2023/01/15/linux-docs/Linux%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E5%AD%A6%E4%B9%A0%E2%80%94%E2%80%94%E5%90%AF%E5%8A%A8/</url>
    <content><![CDATA[<h2 id="一-前言"><a href="#一-前言" class="headerlink" title="一. 前言"></a>一. 前言</h2><p>  Linux操作系统内核是服务端学习的根基，也是提高编程能力、源码阅读能力和进阶知识学习能力的重要部分，本文开始将记录Linux操作系统中的各个部分源码学习历程。</p>
<p>  关于如何学习源码，个人觉得可以从以下角度入手，有效地提高阅读和学习的效率。（学习语言就不说了，这是基本功。学习IDE推荐Source Insight或者Visual Studio，网站源码阅读推荐woboq）</p>
<ul>
<li><p>理解代码的组织结构。 以Linux源码举例，首先你得知道操作系统分为哪几个部分，他们单独做了什么功能，如何进行配合完成更为具体的功能。建立整体的印象有助于后续深入学习的时候方便理解，毕竟代码是用的不是看的，理解他的作用有利于理解为什么要这么做。</p>
</li>
<li><p>深入各个模块学习</p>
<ul>
<li>模块接口： 这里推荐微软的画图工具visio或者思维导图xmind，用其画图可以将各个模块的接口列出，并绘制各个模块之间的关系，通过了解接口可以清楚各个模块之间的关系，即绘制模块组织图</li>
<li>工作流程：通过上面一步得到各模块间的关系，然后实际用断点或log等方式看一看整体的工作流程，在模块组织图的基础上绘制程序流程图</li>
<li>模块粘合层：我们的代码有很多都是用来粘合代码的，比如中间件（middleware）、Promises 模式、回调（Callback）、代理委托、依赖注入等。这些代码模块间的粘合技术是非常重要的，因为它们会把本来平铺直述的代码给分裂开来，让你不容易看明白它们的关系。这些可以作为程序流程图的补充，让其中本来无法顺畅衔接的地方变得通畅无阻。</li>
<li>模块具体实现 ：这是最难得地方，涉及到大量具体源码的学习。深入细节容易迷失在细节的海洋里，因此需要有一些重点去关注，将非重点的内容省略。通过学习绘制模块具体架构图和模块的算法时序图，可以帮助你更好的掌握源码的精髓。</li>
</ul>
</li>
<li><p>需要关注的包括</p>
<ul>
<li>代码逻辑。代码有两种逻辑，一种是业务逻辑，这种逻辑是真正的业务处理逻辑；另一种是控制逻辑，这种逻辑只是用控制程序流转的，不是业务逻辑。比如：flag 之类的控制变量，多线程处理的代码，异步控制的代码，远程通讯的代码，对象序列化反序列化的代码等。这两种逻辑你要分开，很多代码之所以混乱就是把这两种逻辑混在一起了。</li>
<li>重要的算法。一般来说，我们的代码里会有很多重要的算法，我说的并不一定是什么排序或是搜索算法，可能会是一些其它的核心算法，比如一些索引表的算法，全局唯一 ID 的算法、信息推荐的算法、统计算法、通读算法（如 Gossip）等。这些比较核心的算法可能会非常难读，但它们往往是最有技术含量的部分。</li>
<li>底层交互。有一些代码是和底层系统的交互，一般来说是和操作系统或是 JVM 的交互。因此，读这些代码通常需要一定的底层技术知识，不然，很难读懂。</li>
</ul>
</li>
<li><p>可以忽略的包括</p>
<ul>
<li>出错处理。根据二八原则，20% 的代码是正常的逻辑，80% 的代码是在处理各种错误，所以，你在读代码的时候，完全可以把处理错误的代码全部删除掉，这样就会留下比较干净和简单的正常逻辑的代码。排除干扰因素，可以更高效地读代码。</li>
<li>数据处理。只要你认真观察，就会发现，我们好多代码就是在那里倒腾数据。比如 DAO、DTO，比如 JSON、XML，这些代码冗长无聊，不是主要逻辑，可以不理。</li>
</ul>
</li>
<li><p>忽略过多的实现细节。在第一遍阅读源码时，已弄懂整体流程为主，至于具体的实现细节先简单的理清处过一遍，不用过于纠结。当梳理清楚全部的框架逻辑后，第二遍再深入的学习研究各个模块的实现，此时应该解决第一遍中的疑惑。第三遍可以跳出代码的实现，来看Linux的设计思路、编程艺术和演进之路。</p>
</li>
<li><p>重在实践。Linux的代码都是可以调试的，看很多遍也许不如跟着调试走一遍，然后再自己修改修改做一些小测试。</p>
</li>
<li><p>传授知识。当你能将知识讲述给别人听，并让别人听懂时，你已经可以自豪的说洞悉了这些知识。所以不妨从一个小的例子开始自说自话，看能不能自圆其说，甚至写成博客、做成PPT给大家讲解。</p>
</li>
</ul>
<p>  说了一大堆的废话，下面就正式开始操作系统的深入学习记录之旅了。</p>
<h2 id="二-混沌初开"><a href="#二-混沌初开" class="headerlink" title="二. 混沌初开"></a>二. 混沌初开</h2><p>  本文分析从按下电源键到加载BIOS以及后续bootloader的整个过程。犹如盘古开天辟地一般，该过程将混沌的操作系统世界分为清晰的内核态和用户态，并经历从实模式到保护模式的变化。这里先简单介绍一下名词，便于后续理解。</p>
<ul>
<li>实模式（Real Mode)：又名 Real Address Mode，在此模式下地址访问的是真实地内存地址所在位置。在此模式下，可以使用20位（1MB）的地址空间，软件可以不受限制的操作所有地址的空间和IO设备。</li>
<li>保护模式（Protected Mode)：又名 Protected Virtual Address Mode，采用虚拟内存、页等机制对内存进行了保护，比起实模式更为安全可靠，同时也增加了灵活性和扩展性。</li>
</ul>
<h3 id="2-1-从启动电源到BIOS"><a href="#2-1-从启动电源到BIOS" class="headerlink" title="2.1 从启动电源到BIOS"></a>2.1 从启动电源到BIOS</h3><p>  <br>  当我们按下电源键，主板会发向电源组发出信号，接收到信号后，电源会提供合适的电压给计算机。当主板收到电源正常启动的信号后，主板会启动CPU。CPU重置所有寄存器数据，并设置初始化数据，这个初始化数据在X86架构里如下所示：</p>
<pre><code>IP          0xfff0
CS selector 0xf000
CS base     0xffff0000
IP/EIP (Instruction Pointer) : 指令指针寄存器，记录将要执行的指令在代码段内的偏移地址
CS（Code Segment Register）：代码段寄存器，指向CPU当前执行代码在内存中的区域（定义了存放代码的存储器的起始地址）
</code></pre>
<p>  <br>  实模式采取内存段来管理 0 - 0xFFFFF的这1M内存空间，但是由于只有16位寄存器，所以最大地址只能表示为0xFFFFF（64KB)，因此不得不采取将内存按段划分为64KB的方式来充分利用1M空间。也就是上所示的，采取段选择子 + 偏移量的表示法。这种方法在保护模式中对于页的设计上也沿用了下来，可谓祖传的智慧了。具体的计算公式如下所示：</p>
<pre><code>PhysicalAddress = Segment Selector * 16 + Offset
</code></pre>
<p>  该部分由硬件完成，通过计算访问0XFFFF0，如果该位置没有可执行代码则计算机无法启动。如果有，则执行该部分代码，这里也就是我们故事的开始，BIOS程序了。</p>
<h3 id="2-2-BIOS到BootLoader"><a href="#2-2-BIOS到BootLoader" class="headerlink" title="2.2 BIOS到BootLoader"></a>2.2 BIOS到BootLoader</h3><p>  BIOS执行程序存储在ROM中，起始位置为0XFFFF0，当CS:IP指向该位置时，BIOS开始执行。BIOS主要包括以下内存映射：</p>
<pre><code>0x00000000 - 0x000003FF - Real Mode Interrupt Vector Table
0x00000400 - 0x000004FF - BIOS Data Area
0x00000500 - 0x00007BFF - Unused
0x00007C00 - 0x00007DFF - Our Bootloader
0x00007E00 - 0x0009FFFF - Unused
0x000A0000 - 0x000BFFFF - Video RAM (VRAM) Memory
0x000B0000 - 0x000B7777 - Monochrome Video Memory
0x000B8000 - 0x000BFFFF - Color Video Memory
0x000C0000 - 0x000C7FFF - Video ROM BIOS
0x000C8000 - 0x000EFFFF - BIOS Shadow Area
0x000F0000 - 0x000FFFFF - System BIOS
</code></pre>
<p> <br> 其中最重要的莫过于中断向量表和中断服务程序。BIOS程序在内存最开始的位置（0x00000）用1 KB的内存空间（0x00000～0x003FF）构建中断向量表，在紧挨着它的位置用256字节的内存空间构建BIOS数据区（0x00400～0x004FF），并在大约57 KB以后的位置（0x0E05B）加载了8 KB左右的与中断向量表相应的若干中断服务程序。中断向量表中有256个中断向量，每个中断向量占4字节，其中两个字节是CS的值，两个字节是IP的值。每个中断向量都指向一个具体的中断服务程序。</p>
<p> BIOS程序会选择一个启动设备，并将控制权转交给启动扇区中的代码。主要工作即使用中断向量和中断服务程序完成BootLoader的加载，最终将boot.img加载至0X7C00的位置启动。Linux内核通过Boot Protocol定义如何实现该引导程序，有如GRUB 2和syslinux等具体实现方式，这里仅介绍GRUB2。</p>
<h3 id="2-3-BootLoader的工作"><a href="#2-3-BootLoader的工作" class="headerlink" title="2.3 BootLoader的工作"></a>2.3 BootLoader的工作</h3><p>  boot.img由boot.S编译而成，512字节，安装在启动盘的第一个扇区，即MBR。由于空间有限，其代码十分简单，仅仅是起到一个引导的作用，指向后续的核心镜像文件，即core.img。core.img包括很多重要的部分，如lzma_decompress.img、diskboot.img、kernel.img等，结构如下图。</p>
<p><img src="https://user-images.githubusercontent.com/87457873/128177703-cd37ad73-edd7-4c6f-8b05-158760d2dab2.png" alt="image"></p>
<p>整个加载流程如下：</p>
<p>1、boot.img加载core.img的第一个扇区，即diskboot.img，对应代码为diskboot.S<br><br>2、diskboot.img加载core.img的其他部分模块，先是解压缩程序 lzma_decompress.img，再往下是 kernel.img，最后是各个模块 module 对应的映像。这里需要注意，它不是 Linux 的内核，而是 grub 的内核。注意，lzma_decompress.img 对应的代码是 startup_raw.S，本来 kernel.img 是压缩过的，现在执行的时候，需要解压缩。<br><br>3、加载完core之后，启动grub_main函数。<br><br>4、grub_main函数初始化控制台，计算模块基地址，设置 root 设备，读取 grub 配置文件，加载模块。最后，将 GRUB 置于 normal 模式，在这个模式中，grub_normal_execute (from grub-core&#x2F;normal&#x2F;main.c) 将被调用以完成最后的准备工作，然后显示一个菜单列出所用可用的操作系统。当某个操作系统被选择之后，grub_menu_execute_entry 开始执行，它将调用 GRUB 的 boot 命令，来引导被选中的操作系统。<br><br>  <br>  在这之前，我们所有遇到过的程序都非常非常小，完全可以在实模式下运行，但是随着我们加载的东西越来越大，实模式这 1M 的地址空间实在放不下了，所以在真正的解压缩之前，lzma_decompress.img 做了一个重要的决定，就是调用 real_to_prot，切换到保护模式，这样就能在更大的寻址空间里面，加载更多的东西。</p>
<p>  开机时的16位实模式与内核启动的main函数执行需要的32位保护模式之间有很大的差距，这个差距谁来填补？head.S做的就是这项工作。就像 kernel boot protocol 所描述的，引导程序必须填充 kernel setup header （位于 kernel setup code 偏移 0x01f1 处） 的必要字段，这些均在head.S中定义。在这期间，head程序打开A20，打开pe、pg，废弃旧的、16位的中断响应机制，建立新的32位的IDT……这些工作都做完了，计算机已经处在32位的保护模式状态了，调用32位内核的一切条件已经准备完毕，这时顺理成章地调用main函数。后面的操作就可以用32位编译的main函数完成，从而正式启动内核，进入波澜壮阔的Linux内核操作系统之中。</p>
<h2 id="三-总结"><a href="#三-总结" class="headerlink" title="三. 总结"></a>三. 总结</h2><p>  本文介绍了从按下电源开关至加载完毕BootLoader的整个过程，后续将继续分析从实模式进入保护模式，从而启动内核创建0号、1号、2号进程的整个过程。本文介绍过程中忽略了很多汇编代码以及一些虽然很重要但是不属于基本流程的知识，有兴趣了解的可以根据文中链接、文末的源码和参考资料进行更深入的学习研究。</p>
]]></content>
      <categories>
        <category>linux-doc</category>
      </categories>
      <tags>
        <tag>Linux</tag>
      </tags>
  </entry>
  <entry>
    <title>Linux操作系统段式存储管理、 段页式存储管理</title>
    <url>/2023/01/15/linux-docs/Linux%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E6%AE%B5%E5%BC%8F%E5%AD%98%E5%82%A8%E7%AE%A1%E7%90%86%E3%80%81%20%E6%AE%B5%E9%A1%B5%E5%BC%8F%E5%AD%98%E5%82%A8%E7%AE%A1%E7%90%86/</url>
    <content><![CDATA[<h2 id="1、段式存储管理"><a href="#1、段式存储管理" class="headerlink" title="1、段式存储管理"></a>1、段式存储管理</h2><h3 id="1-1分段"><a href="#1-1分段" class="headerlink" title="1.1分段"></a>1.1分段</h3><ul>
<li>进程的地址空间：按照程序自身的逻辑关系划分为若干个段，每个段都有一个段名（在低级语言中，程序员使用段名来编程），每段从0开始编址。</li>
<li>内存分配规则：以段为单位进行分配，每个段在内存中占连续空间，但各段之间可以不相邻。</li>
</ul>
<p><img src="https://pic3.zhimg.com/80/v2-0b9b91ad1f8f67e7e15a0fc719bc1502_720w.webp" alt="img"></p>
<ul>
<li>分段系统的逻辑地址结构由段号（段名）和段内地址（段内偏移量）所组成。</li>
</ul>
<p><img src="https://pic1.zhimg.com/80/v2-918b6a6b3e75201ee2d205365b162f18_720w.webp" alt="img"></p>
<h3 id="1-2段表"><a href="#1-2段表" class="headerlink" title="1.2段表"></a>1.2段表</h3><p><img src="https://pic2.zhimg.com/80/v2-9cb62088c79fd7e8f31b17fad2d1d8bd_720w.webp" alt="img"></p>
<ul>
<li>每一个程序设置一个段表，放在内存,属于进程的现场信息</li>
</ul>
<h3 id="1-3地址变换"><a href="#1-3地址变换" class="headerlink" title="1.3地址变换"></a>1.3地址变换</h3><p><img src="https://pic2.zhimg.com/80/v2-d0a5d7ae823e2c0de3196de7d181d849_720w.webp" alt="img"></p>
<p><img src="https://pic3.zhimg.com/80/v2-6449d02941134e902da8ff539a929fce_720w.webp" alt="img"></p>
<h3 id="1-4段的保护"><a href="#1-4段的保护" class="headerlink" title="1.4段的保护"></a>1.4段的保护</h3><ul>
<li>越界中断处理</li>
</ul>
<p>1.进程在执行过程中，有时需要扩大分段，如数据段。由于要访问的地址超出原有的段长，所以发越界中断。操作系统处理中断时 ，首先判断该段的“扩充位”，如可扩充，则增加段的长度；否则按出错处理</p>
<ul>
<li>缺段中断处理</li>
</ul>
<ol>
<li>检查内存中是否有足够的空闲空间<br>①若有，则装入该段，修改有关数据结构，中断返回<br>②若没有，检查内存中空闲区的总和是否满足要求，是则应采用紧缩技术，转 ① ；否则，淘汰一（些）段，转①</li>
</ol>
<h3 id="1-5段的动态连接"><a href="#1-5段的动态连接" class="headerlink" title="1.5段的动态连接"></a>1.5段的动态连接</h3><ol>
<li>为何要进行段的动态链接？</li>
<li>大型程序由若干程序段，若干数据段组成</li>
<li>进程的某些程序段在进程运行期间可能根本不用</li>
<li>互斥执行的程序段没有必要同时驻留内存</li>
<li>有些程序段执行一次后不再用到</li>
<li>静态链接花费时间，浪费空间</li>
</ol>
<ul>
<li>在一个程序运行开始时，只将主程序段装配好并调入主存。其它各段的装配是在主程序段运行过程中逐步进行的。每当需要调用一个新段时，再将这个新段装配好，并与主程序段连接。<br>页式存储管理：难以完成动态链接，其逻辑地址是一维的</li>
</ul>
<h3 id="1-6信息的保护与共享"><a href="#1-6信息的保护与共享" class="headerlink" title="1.6信息的保护与共享"></a>1.6信息的保护与共享</h3><ul>
<li>这里主要与页式存储管理进行一下对比。</li>
<li>分段比分页更容易实现信息的共享和保护。</li>
</ul>
<p><img src="https://pic1.zhimg.com/80/v2-8e41f75bf364037e526db0f656082c48_720w.webp" alt="img"></p>
<ul>
<li>纯代码举例：比如，有一个代码段只是简单的输出“Hello World!”。</li>
</ul>
<p><img src="https://pic3.zhimg.com/80/v2-bc3414d6cfe0c16d679779b1f0217f26_720w.webp" alt="img"></p>
<h3 id="1-7页式系统与段式系统的对比"><a href="#1-7页式系统与段式系统的对比" class="headerlink" title="1.7页式系统与段式系统的对比"></a>1.7页式系统与段式系统的对比</h3><p><img src="https://pic2.zhimg.com/80/v2-a8a0f2c4f0bd8f666f321b565d41f095_720w.webp" alt="img"></p>
<ul>
<li>补充：</li>
<li>段长是可变的，页的大小是固定的。</li>
</ul>
<ol>
<li>分段存储：段内地址W字段溢出将产生越界中断。</li>
<li>分页存储：段内地址W字段溢出会自动加入到页号中。</li>
</ol>
<h3 id="1-8总结"><a href="#1-8总结" class="headerlink" title="1.8总结"></a>1.8总结</h3><p><img src="https://pic1.zhimg.com/80/v2-6db3da902a93c013e81a2c67d9093b44_720w.webp" alt="img"></p>
<h2 id="2、段页式存储管理"><a href="#2、段页式存储管理" class="headerlink" title="2、段页式存储管理"></a>2、段页式存储管理</h2><h3 id="2-1分页、分段的有缺点分析"><a href="#2-1分页、分段的有缺点分析" class="headerlink" title="2.1分页、分段的有缺点分析"></a>2.1分页、分段的有缺点分析</h3><p><img src="https://pic3.zhimg.com/80/v2-20513fde9949e32446b67e53ad670b7e_720w.webp" alt="img"></p>
<h3 id="2-2基本思想"><a href="#2-2基本思想" class="headerlink" title="2.2基本思想"></a>2.2基本思想</h3><ul>
<li>用户程序划分：按段式划分（对用户来讲，按段的逻辑关系进行划分；对系统讲，按页划分每一段）</li>
<li>逻辑地址：</li>
</ul>
<p><img src="https://pic4.zhimg.com/80/v2-b1839841926eb05069b042989e8cfd3f_720w.webp" alt="img"></p>
<ul>
<li>内存划分：按页式存储管理方案</li>
<li>内存分配：以页为单位进行分配</li>
</ul>
<p><img src="https://pic2.zhimg.com/80/v2-572d543c9b5da3027966ded34d56dfd1_720w.webp" alt="img"></p>
<h3 id="2-3逻辑地址结构"><a href="#2-3逻辑地址结构" class="headerlink" title="2.3逻辑地址结构"></a>2.3逻辑地址结构</h3><p><img src="https://pic1.zhimg.com/80/v2-f49ff2368aa4983ffe010a1b5c1f04fc_720w.webp" alt="img"></p>
<h3 id="2-4段表页表"><a href="#2-4段表页表" class="headerlink" title="2.4段表页表"></a>2.4段表页表</h3><p><img src="https://pic3.zhimg.com/80/v2-89c049df540ee806c93e1635e2f72d7a_720w.webp" alt="img"></p>
<h3 id="2-5地址转换"><a href="#2-5地址转换" class="headerlink" title="2.5地址转换"></a>2.5地址转换</h3><p><img src="https://pic3.zhimg.com/80/v2-f83f355d2c2b1da2c9a25a73176fb896_720w.webp" alt="img"></p>
<h3 id="2-6评价"><a href="#2-6评价" class="headerlink" title="2.6评价"></a>2.6评价</h3><ul>
<li>优点：</li>
</ul>
<ol>
<li>保留了分段和请求分页存储管理的全部优点</li>
<li>提供了虚存空间，能更有效利用主存</li>
</ol>
<ul>
<li>缺点：</li>
</ul>
<ol>
<li><p>增加了硬件成本</p>
</li>
<li><p>系统复杂度较大</p>
</li>
</ol>
<h3 id="2-7总结"><a href="#2-7总结" class="headerlink" title="2.7总结"></a>2.7总结</h3><p><img src="https://pic1.zhimg.com/80/v2-7495c4ec766121e40fe80b7a42160108_720w.webp" alt="img"></p>
<hr>
<p>版权声明：本文为知乎博主「Linux内核库」的原创文章，遵循CC 4.0 BY-SA版权协议，转载请附上原文 出处链接及本声明。 </p>
<p>原文链接：<a href="https://zhuanlan.zhihu.com/p/466602063">https://zhuanlan.zhihu.com/p/466602063</a></p>
]]></content>
      <categories>
        <category>linux-doc</category>
      </categories>
      <tags>
        <tag>Linux</tag>
      </tags>
  </entry>
  <entry>
    <title>Linux操作系统汇编指令入门级整理知识点</title>
    <url>/2023/01/15/linux-docs/Linux%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E6%B1%87%E7%BC%96%E6%8C%87%E4%BB%A4%E5%85%A5%E9%97%A8%E7%BA%A7%E6%95%B4%E7%90%86%E7%9F%A5%E8%AF%86%E7%82%B9/</url>
    <content><![CDATA[<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>我们大都是被高级语言惯坏了的一代，源源不断的新特性正在逐步添加到各类高级语言之中，汇编作为最接近机器指令的低级语言，已经很少被直接拿来写程序了，不过我还真的遇到了一个，那是之前的一个同事，因为在写代码时遇到了成员函数权限及可见性的问题，导致他无法正确调用想执行的函数，结果他就开始在 C++ 代码里嵌入汇编了，绕过了种种限制终于如愿以偿，但是读代码的时候我们傻眼了…</p>
<p>因为项目是跨平台的，代码推送的 Linux 编译的时候他才发现，汇编代码的语法在 Linux 和 Windows 上居然是不一样的，结果他又用一个判断平台的宏定义“完美”地解决了，最终这些代码肯定是重写了啊，因为可读性太差了，最近在学习左值、右值、左引用和右引用的时候，总是有人用程序编译生成的中间汇编代码来解释问题，看得我迷迷糊糊，所以决定熟悉一下简单的汇编指令，边学习边记录，方便今后忘记了可以直接拿来复习。</p>
<h2 id="什么是汇编语言"><a href="#什么是汇编语言" class="headerlink" title="什么是汇编语言"></a>什么是汇编语言</h2><p>汇编语言是最接近机器语言的编程语言，引用百科中的一段话解释为：</p>
<p>汇编语言（assembly language）是一种用于电子计算机、微处理器、微控制器或其他可编程器件的低级语言，亦称为符号语言。在汇编语言中，用助记符代替机器指令的操作码，用地址符号或标号代替指令或操作数的地址。汇编语言又被称为第二代计算机语言。</p>
<h2 id="汇编语言产生的原因"><a href="#汇编语言产生的原因" class="headerlink" title="汇编语言产生的原因"></a>汇编语言产生的原因</h2><p>对于绝大多数人来说，二进制程序是不可读的，当然有人可以读，比如第一代程序员，但这类人快灭绝了，直接看二进制不容易看出来究竟做了什么事情，比如最简单的加法指令二进制表示为 00000011，如果它混在一大串01字符串中就很难把它找出来，所以汇编语言主要就是为了解决二进制编码的可读性问题。</p>
<h2 id="汇编与二进制的关系"><a href="#汇编与二进制的关系" class="headerlink" title="汇编与二进制的关系"></a>汇编与二进制的关系</h2><p>换句话来说，汇编语言就是把给机器看的二进制编码翻译成人话，汇编指令是机器指令的助记符，与机器指令是一一对应的关系，是一种便于阅读和记忆的书写格式。有效地解决了机器指令编写程序难度大的问题，并且使用编译器，可以很方便地把汇编程序转译成机器指令程序，比如之前提到的 00000011 加法指令，对应的汇编指令是 ADD，在调用汇编器时就会把 ADD 翻译成 00000011。</p>
<h2 id="寄存器"><a href="#寄存器" class="headerlink" title="寄存器"></a>寄存器</h2><p>说到汇编指令不得不提到寄存器，寄存器本身是用来存数据的，因为 CPU 本身只负责逻辑运算，数据需要单独储存在其他的地方，但是对于不熟悉寄存器的人来说会有疑惑，数据不是存在硬盘上吗？或者说数据不是存在内存中吗？这些想法都没错，那么寄存器是用来做什么的呢？</p>
<h2 id="寄存器作用"><a href="#寄存器作用" class="headerlink" title="寄存器作用"></a>寄存器作用</h2><p>其实硬盘、内存都是用来存储数据的，但是 CPU 的运算速度远高于内存的读写速度，更不用说从硬盘上取数据了，所以为了避免被拖慢速度影响效率，CPU 都自带一级缓存和二级缓存，一些 CPU 甚至增加了三级缓存，从这些缓存中读写数据要比内存快很多，但是还是无法使用飞速运转的 CPU，所以才会有寄存器的存在。</p>
<p>寄存器不是后来增加的，在最初的计算中就已经设计出来，相比而言，多级缓存出现得更晚一些，通常那些最频繁读写的数据都会被放在寄存器里面，CPU 优先读写寄存器，再通过寄存器、缓存跟内存来交换数据，达到缓冲的目的，因为可以通过名称访问寄存器，这样访问速度是最快的，因此也被称为零级缓存。</p>
<h2 id="存取速度比较"><a href="#存取速度比较" class="headerlink" title="存取速度比较"></a>存取速度比较</h2><p>通过上面的叙述我们可以知道存取速度从高到低分别是: 寄存器 &gt; 1级缓存 &gt; 2级缓存 &gt; 3级缓存 &gt; 内存 &gt; 硬盘，关于它们的存取速度，举个例子很容易就能明白了，比如我们做菜（CPU工作）时，取手中（寄存器）正拿着的肉和蔬菜肯定是最快的，如果没有就需要把案板上（1级缓存）处理好的菜拿过来，如果案板上没有就在更远一点的洗菜池（2级缓存）中找一找，还没找到的话就要到冰箱（3级缓存）中看一看了，这时发现家里真没有，那去楼下的菜店（内存）去买点吧，转了一圈发现没有想要的，最后还是开车去农贸市场（硬盘）买吧。</p>
<p>通过上面这个例子应该能明白它们的速度关系了，既然缓存这么快，为什么不用缓存代替内存，或者将2、3级缓存都换成1级缓存呢？这里边有一个成本问题，速度越快对应着价格越高，如果你买过机械硬盘和固态硬盘应该很容易就理解了。</p>
<p><strong>寄存器分类</strong></p>
<p>常用的 x86 CPU 寄存器有8个：EAX 、EBX、ECX、EDX、EDI、ESI、EBP、ESP，据说现在寄存器总数已经超过100个了，等我找到相关资料再来补充，上面这几个寄存器是最常用的，这些名字也常常出现在汇编的代码中。</p>
<p>我们常说的32位、64位 CPU 是指数据总线的宽度或根数，而寄存器是暂存数据和中间结果的单元，因此寄存器的位数也就是处理数据的长度与数据总线的根数是相同的，所以32位 CPU 对应的寄存器也应该是32位的。</p>
<p><strong>常用寄存器用途</strong></p>
<p>上面提到大8个寄存器都有其特定的用途，我们以32位 CPU 为例简单说明下这些寄存器的作用，整理如下表：</p>
<p><img src="https://pic4.zhimg.com/80/v2-55215e20944d5e1a161253e73eddaa07_720w.webp" alt="img"></p>
<h2 id="寄存器EAX、AX、AH、AL的关系"><a href="#寄存器EAX、AX、AH、AL的关系" class="headerlink" title="寄存器EAX、AX、AH、AL的关系"></a>寄存器EAX、AX、AH、AL的关系</h2><p>在上面的图标中每个常用寄存器后面还有其他的名字，它们是同一个寄存器不同用法下的不同名字，比如在32位 CPU 上，EAX是32位的寄存器，而AX是EAX的低16位，AH是AX的高8位，而AL是AX的低8位，它们的对照关系如下:</p>
<figure class="highlight text"><table><tr><td class="code"><pre><span class="line">00000000 00000000 00000000 00000000</span><br><span class="line">|===============EAX===============|---4个字节</span><br><span class="line">                  |======AX=======|---2个字节</span><br><span class="line">                  |==AH===|-----------1个字节</span><br><span class="line">                          |===AL==|---1个字节</span><br></pre></td></tr></table></figure>

<h2 id="汇编语言指令"><a href="#汇编语言指令" class="headerlink" title="汇编语言指令"></a>汇编语言指令</h2><p>终于说到汇编常用指令了，因为 linux 和 windows 下面的汇编语法是有些不同的，所以下面我们先通过 windows 下的汇编指令来简单学习一下，后续再来比较两者的不同。</p>
<p><strong>数据传送指令</strong></p>
<p><img src="https://pic1.zhimg.com/80/v2-b07d3b818f23726324ea8bf8b4285fc8_720w.webp" alt="img"></p>
<p><strong>算术运算指令</strong></p>
<p><img src="https://pic4.zhimg.com/80/v2-53d1634b99b2b1138880c5bd15aeb5f7_720w.webp" alt="img"></p>
<p><strong>逻辑运算指令</strong></p>
<p><img src="https://pic1.zhimg.com/80/v2-e338b2f72046695650f87da0fc156fd4_720w.webp" alt="img"></p>
<p><strong>循环控制指令</strong></p>
<p><img src="https://pic4.zhimg.com/80/v2-fab8c1d3ed5c2ada334bd6c9cc71e6fb_720w.webp" alt="img"></p>
<p><strong>循环控制指令</strong></p>
<p><img src="https://pic1.zhimg.com/80/v2-38df884cc758cc13e540fdd5be9ceee4_720w.webp" alt="img"></p>
<p><strong>linux 和 windows 下汇编的区别</strong></p>
<p>前面说到 linux 和 windows 下面的汇编语法是不同的，其实两种语法的不同和系统不同没有绝对的关系，一般在 linux 上会使用 gcc&#x2F;g++ 编译器，而在 windows 上会使用微软的 cl 也就是 MSBUILD，所以产生不同的代码是因为编译器不同，gcc 下采用的是AT&amp;T的汇编语法格式，MSBUILD 采用的是Intel汇编语法格式。</p>
<p><img src="https://pic4.zhimg.com/80/v2-3a8b07ae4490e7fdfe5984df4f004cd3_720w.webp" alt="img"></p>
<p><strong>总结</strong></p>
<ul>
<li>汇编指令是机器指令的助记符，与机器指令是一一对应的</li>
<li>AT&amp;T的汇编语法格式和Intel汇编语法格式的是不同的</li>
<li>常用寄存器：EAX 、EBX、ECX、EDX、EDI、ESI、EBP、ESP</li>
<li>存取速度从高到低分别是: 寄存器 &gt; 1级缓存 &gt; 2级缓存 &gt; 3级缓存 &gt; 内存 &gt; 硬盘</li>
<li>常用的汇编指令：mov、je、jmp、call、add、sub、inc、dec、and、or</li>
</ul>
<hr>
<p>版权声明：本文为知乎博主「玩转Linux内核」的原创文章，遵循CC 4.0 BY-SA版权协议，转载请附上原文出处链接及本声明。<br>原文链接：<a href="https://zhuanlan.zhihu.com/p/449787476">https://zhuanlan.zhihu.com/p/449787476</a></p>
]]></content>
      <categories>
        <category>linux-doc</category>
      </categories>
      <tags>
        <tag>Linux</tag>
      </tags>
  </entry>
  <entry>
    <title>Linux操作系统汇编语言基础知识(图文代码)</title>
    <url>/2023/01/15/linux-docs/Linux%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E6%B1%87%E7%BC%96%E8%AF%AD%E8%A8%80%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86(%E5%9B%BE%E6%96%87%E4%BB%A3%E7%A0%81)/</url>
    <content><![CDATA[<h2 id="1、什么是汇编语言，它在计算机语言中的地位？"><a href="#1、什么是汇编语言，它在计算机语言中的地位？" class="headerlink" title="1、什么是汇编语言，它在计算机语言中的地位？"></a>1、什么是汇编语言，它在计算机语言中的地位？</h2><figure class="highlight text"><table><tr><td class="code"><pre><span class="line">汇编语言是程序设计语言的基础语言，是唯一可以直接与计算机硬件打交道的语言</span><br></pre></td></tr></table></figure>

<h2 id="2、汇编语言与源程序、汇编程序、汇编的关系？"><a href="#2、汇编语言与源程序、汇编程序、汇编的关系？" class="headerlink" title="2、汇编语言与源程序、汇编程序、汇编的关系？"></a>2、汇编语言与源程序、汇编程序、汇编的关系？</h2><p><img src="https://pic1.zhimg.com/80/v2-b9c8c1f5adce7fab60ba6010280982cc_720w.webp" alt="img"></p>
<h2 id="3、汇编语言的特点"><a href="#3、汇编语言的特点" class="headerlink" title="3、汇编语言的特点"></a>3、汇编语言的特点</h2><ul>
<li>\1) 汇编语言与机器指令一一对应，可充分理解计算机的操作过程汇编语言指令是机器指令的符号表示</li>
<li>\2) 汇编语言是靠近机器的语言编程时要求熟悉机器硬件系统，可充分利用机器硬件中的全部功能，发挥机器的特点在计算机系统中，某些功能由汇编语言程序实现：实时过程控制系统、系统初始化、实际的输入输出设备操作</li>
<li>\3) 汇编语言程序的效率高于高级语言效率，指的是用汇编语言编写的源程序在汇编后所得的目标程序效率高时间域的高效率：运行速度快；空间域的高效率：目标代码占用存储空间少</li>
</ul>
<h2 id="4、汇编语言与高级语言的比较"><a href="#4、汇编语言与高级语言的比较" class="headerlink" title="4、汇编语言与高级语言的比较"></a>4、汇编语言与高级语言的比较</h2><p><img src="https://pic2.zhimg.com/80/v2-e147e0cdc60a6b243dae382353af0ad9_720w.webp" alt="img"></p>
<h2 id="5、进制转换"><a href="#5、进制转换" class="headerlink" title="5、进制转换"></a>5、进制转换</h2><figure class="highlight text"><table><tr><td class="code"><pre><span class="line">（略）</span><br></pre></td></tr></table></figure>

<h2 id="6、数据组织单位"><a href="#6、数据组织单位" class="headerlink" title="6、数据组织单位"></a>6、数据组织单位</h2><blockquote>
<p>\1) 位（bit）<br>是计算机中表示信息的最小单位，符号b，是一个二进制位，每一位用0或1表示<br>\2) 字节（Byte）<br>8位二进制数为一个字节<br>\3) 字（Word）<br>若干个字节为一个字，一般一个字包含两个字节<br>范围0000H<del>FFFFH<br>\4) 双字（Double Word）<br>两个字节为一个字，四个字节为连个字，称为双字<br>范围00000000H</del>FFFFFFFFH<br>\5) 字长<br>机器字的长度为字长，即计算机中每个字所包含的位数，由机器数据总线数决定<br>例如，数据总线数为64位，机器字长为64位，即每个字有8个字节<br>\6) 数据字与指令字<br>数据字：在存储单元中存储的是数据<br>指令字：在存储单元中存储的是指令<br>无论是数据字还是指令字，在存储单元中都是以二进制的形式存放的</p>
</blockquote>
<p><strong>7、BCD码</strong></p>
<p>两种存储方式：组合型（1个字节表示2个BCD码）；非组合型（1个字节表示1个BCD码）</p>
<p><strong>8、80X86计算机组织结构</strong></p>
<p>微型计算机的硬件系统主要由3个主要部分组成：</p>
<ul>
<li>1)中央处理器CPU（运算器、控制器、寄存器）</li>
<li>2)输入输出设备</li>
<li>3)存储器</li>
</ul>
<p><strong>9、80X86 CPU的寄存器</strong></p>
<p>寄存器分为3类：</p>
<ul>
<li>1)通用寄存器</li>
<li>2)控制寄存器</li>
<li>3)段寄存器</li>
</ul>
<p>8个8位通用寄存器：AL,AH,BL,BH,CL,CH,DL,DH</p>
<p>8个16位通用寄存器：AX,BX,CX,DX,SI,DI,BP,SP</p>
<p>8个32位通用寄存器：EAX,EBX,ECX,EDX,ESI,EDI,EBP,ESP</p>
<p><img src="https://pic1.zhimg.com/80/v2-0631762f84d53592ee29dcc490ff3994_720w.webp" alt="img"></p>
<blockquote>
<p>说明：1）指针寄存器（SP,ESP,BP,EBP）<br>SP,ESP为堆栈指针寄存器，存放当前堆栈段栈顶的偏移地址，<br>是根据指令自动移动的，要想随机读取</p>
<p>堆栈段中的数据，必须通过BP或EBP基址指针寄存器来读取。<br>2）控制寄存器（IP,EIP,FLAGS,EFLAGS）<br>IP,EIP为指令指针寄存器，用于存放当前正在执行的指令的<br>下一条指令的偏移地址，该寄存器所指的为代码段的偏移地址。<br>FLAGS为标识寄存器，表示程序运行时的状态和一些特殊控制</p>
</blockquote>
<p>3）段寄存器</p>
<p>代码和数据是分开存放，代码存放在代码段，数据存放在数据段</p>
<p><strong>10、内存组织结构</strong></p>
<p>1）内存的地址<br>在存储器中内存单元的基本单位是<em>字节</em>，每个字节都有一个唯一的地址</p>
<p><img src="https://pic3.zhimg.com/80/v2-5cf385fec47048719360e4f84cb0a67a_720w.webp" alt="img"></p>
<p><strong>2）存储单元的内容</strong></p>
<p>一个存储单元存放的信息为存储单元的内容</p>
<ol>
<li>分为：字节单元、字节单元、双字单元</li>
<li>双字：需要两个16位寄存器，通常为DX:AX,DX高位，AX低位</li>
</ol>
<p><img src="https://pic3.zhimg.com/80/v2-422fd8d4b3b9a5a5b914c8c118a428f6_720w.webp" alt="img"></p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="number">3</span>)堆栈</span><br><span class="line">堆栈是内存中一块特定的区域，其中数据按照*先进后出*原则</span><br><span class="line">作用：暂存数据、子程序调用与返回、调用中断处理程序、从中断处理程序返回</span><br><span class="line">位置：堆栈段地址存放于SS寄存器中，偏移地址存放在堆栈指针寄存器（<span class="built_in">SP</span>(<span class="number">16</span>位)/<span class="built_in">ESP</span>(<span class="number">32</span>位)），</span><br><span class="line">他们永远指向栈顶</span><br><span class="line">	初始化：堆栈的初始化时通过设置SS及SP/ESP值来完成的，可以由编译系统自动完成，也可以在程序</span><br><span class="line">中通过伪指令显示地定义</span><br></pre></td></tr></table></figure>

<p><strong>11、实模式</strong></p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="number">1</span>)介绍</span><br><span class="line">	</span><br><span class="line">	只有<span class="number">8086</span>/<span class="number">8088</span>工作在实模式下；</span><br><span class="line">	<span class="number">80286</span>以上的微处理器工作在实模式和保护模式下；</span><br><span class="line">	在实模式下微处理器只能寻址<span class="number">1</span>MB的存储空间；</span><br><span class="line">	<span class="number">80286</span>以上系统的微处理器在加点或复位时都以实模式方式开始工作</span><br><span class="line"></span><br><span class="line"><span class="number">2</span>）内存地址的分段</span><br><span class="line"></span><br><span class="line">	*为什么要分段？*</span><br><span class="line">	<span class="number">8086</span>/<span class="number">8088</span>地址总线为<span class="number">20</span>根，可访问的地址为：<span class="number">2</span>^<span class="number">20</span>=<span class="number">1048576</span>=<span class="number">1</span>M</span><br><span class="line">	<span class="number">8086</span>/<span class="number">8088</span>内部寄存器都是<span class="number">16</span>位的，可以直接处理<span class="number">16</span>位长度的存储地址，<span class="number">16</span>位地址的寻址<span class="number">2</span>^<span class="number">16</span>=<span class="number">64</span>K</span><br><span class="line">	为了把寻址范围扩大到<span class="number">1</span>MB，实模式存储器地址均采用存储空间的分段技术来解决寻址<span class="number">1</span>MB的存储空间</span><br><span class="line">	提出了段地址和偏移地址合成<span class="number">20</span>位物理地址的概念</span><br><span class="line">	</span><br><span class="line">	*分段方法？*</span><br><span class="line">	<span class="number">16</span>位段地址+<span class="number">16</span>位段内地址---&gt;<span class="number">20</span>位物理地址</span><br><span class="line">	地址的组合：物理地址=段地址*<span class="number">16</span>D(或<span class="number">10</span>H)+偏移地址，（段地址*<span class="number">16</span>D--二进制段地址左移<span class="number">4</span>位）</span><br><span class="line">	存放段地址：<span class="number">16</span>位段地址寄存器（CS、DS、SS、ES）</span><br><span class="line">	存放偏移地址：<span class="number">16</span>位指针寄存器（IP、SP）</span><br><span class="line">	在<span class="number">1</span>MB存储器中可以有<span class="number">64</span>K个段，每个段最多<span class="number">64</span>KB，最小为<span class="number">16</span>KB</span><br><span class="line">	</span><br><span class="line"></span><br><span class="line">	*物理地址、段地址、段内地址、逻辑地址的区别？*</span><br><span class="line">	物理地址：与内存单元一一对应的<span class="number">20</span>位二进制数,<span class="number">1</span>MB=<span class="number">00000</span>H~FFFFFH</span><br><span class="line">		    每个物理地址代表一个唯一的内存单元</span><br><span class="line">	</span><br><span class="line">	段地址：将<span class="number">1</span>MB的内存空间分为长<span class="number">64</span>KB的程序区和数据区称为段</span><br><span class="line">		  每个段用<span class="number">1</span>个<span class="number">16</span>位二进制地址表示</span><br><span class="line">		  段地址存放在段寄存器中</span><br><span class="line">		  代码段：用于存放源程序的二进制程序代码，该段的段地址放在CS中</span><br><span class="line">		  数据段：存放操作数据的，该段的段地址放在DS中</span><br><span class="line">		  堆栈段：堆栈用的存储区，该段的段地址放在SS中</span><br><span class="line">		  附加段：该段的段地址放在ES中</span><br><span class="line">	</span><br><span class="line">	段内地址：<span class="number">16</span>位二进制段内地址为偏移地址</span><br><span class="line">   （偏移地址）不同段内的偏移地址存放在不同的寄存器中，段寄存器与装偏移地址的寄存器按一定要求组合</span><br></pre></td></tr></table></figure>

<p><img src="https://pic1.zhimg.com/80/v2-7ea71c556f95e10dde7137a275c01748_720w.webp" alt="img"></p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">逻辑地址：用段地址和偏移地址来表示内存单元的地址为逻辑地址，例如，段地址：偏移地址</span><br><span class="line">	*逻辑地址与物理地址的换算关系？*</span><br><span class="line">	物理地址 = 段地址*<span class="number">16</span>D（<span class="number">10</span>H）+偏移地址</span><br><span class="line">	逻辑地址 = 段地址：偏移地址</span><br><span class="line">	例子：逻辑地址，<span class="number">1111</span>H:<span class="number">2222</span>H</span><br><span class="line">物理地址，<span class="number">1111</span>H*<span class="number">10</span>H+<span class="number">2222</span>H = <span class="number">13332</span>H</span><br><span class="line">假设<span class="number">1111</span>H为代码段地址，<span class="number">2222</span>H在指针寄存器IP中，示意图如下：</span><br></pre></td></tr></table></figure>

<p><img src="https://pic3.zhimg.com/80/v2-65c8fa036b5b5f4ca807f594e426308a_720w.webp" alt="img"></p>
<p><strong>内存分配方法？</strong></p>
<p>代码段、数据段、堆栈段的大小，是以节为最小单位分配内存区域的16字节&#x3D;2个字&#x3D;1节，节的边界地址就是能够被16整除的地址偏移地址（段内地址）是从0000H开始的例子：假设程序分配的内存区从6100H开始，程序长度1020字节，操作数510字节，堆栈段250字节则代码段长度为1024D&#x3D;400H，数据段长度为512D&#x3D;200H，堆栈段长度为256D&#x3D;100H</p>
<p><strong>示意图如下：</strong></p>
<p><img src="https://pic4.zhimg.com/80/v2-f3c4bf9aa6606ce79db198b30797dc4f_720w.webp" alt="img"></p>
<p><strong>段与段之间的关系？</strong></p>
<p>8088&#x2F;8086 CPU把1MB的存储空间划分成若干逻辑段每个段的起始地址必须是能够被16整除的数逻辑段的最大长度为64KB 1MB的存储空间最多可以分成64K个逻辑段，当每个逻辑段为16KB时段与段之间可以相邻、分离、重叠、部分重叠</p>
<p><strong>12、保护模式</strong></p>
<figure class="highlight text"><table><tr><td class="code"><pre><span class="line">1）保护模式存储器寻址机制</span><br><span class="line">	在保护模式下，逻辑地址=选择符+偏移地址</span><br><span class="line">	与实模式不同，实模式的段寄存器存放段基地址，而保护模式的段寄存器存放选择符</span><br><span class="line">	保护模式下，通过选择描述符表中的描述符，间接地形成段基地址</span><br><span class="line">	保护模式的偏移地址最大可以是32位，最大段长可以从16KB扩展到4GB</span><br><span class="line">2)描述符</span><br><span class="line">	描述符包括，段在寄存器中的位置，段的长度，访问权限</span><br><span class="line">	由基地址、段界限、访问权限、附加字段组成</span><br><span class="line">		基地址：指定段的起始地址</span><br><span class="line">		段界限：存放该段的最大偏移地址</span><br><span class="line">		访问权限：说明该段在系统中的功能和一些控制信息</span><br><span class="line">		附加字段：描述该段的一些属性</span><br><span class="line">	描述符的内容是由系统自动设置的</span><br><span class="line">	由于段寄存器是16位的，描述符是64位的</span><br><span class="line">	故将64位的段描述符放按顺序存放形成一个段描述符表，放在内存中</span><br><span class="line">	而在段寄存器中实际存放的是要选择的段描述符表的序号，类似于数组中的下标</span><br></pre></td></tr></table></figure>

<p><strong>13、存储器管理机制</strong></p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="number">1</span>）分段管理机制</span><br><span class="line">		①虚拟存储器：在有限的物理存储器上获取更大的使用空间</span><br><span class="line">			*虚拟存储器是如何实现存储的？*</span><br><span class="line">			在程序执行期间的任意时刻，虚拟存储器系统自动吧程序分成许多小块即程序段</span><br><span class="line">			将某个程序段存放到物理存储器中，其他程序段放在磁盘中</span><br><span class="line">			当程序要访问到哪个程序段时，就把哪个程序段引导到物理存储器中</span><br><span class="line">		</span><br><span class="line">		②分段管理：将<span class="number">4</span>GB的存储空间分成若干独立的受保护的存储空间块</span><br><span class="line">			每个应用程序可以使用这些存储空间块</span><br><span class="line">	</span><br><span class="line">	<span class="number">2</span>）分页管理机制</span><br><span class="line">①线性地址空间：每个进程都有相同大小的<span class="number">4</span>GB线性空间</span><br><span class="line">用分段管理机制实现虚拟地址空间到线性地址空间的映射，实现把二维的</span><br><span class="line">虚拟地址转换为一维的线性地址</span><br><span class="line"></span><br><span class="line">②分页存储管理：把线性地址空间和物理地址空间分别划分为大小相同的块，每块长为<span class="number">4</span>KB</span><br><span class="line">这样的块称为页，通过分页管理机制实现线性地址空间到物理地址空间的</span><br><span class="line">映射，实现线性地址到物理地址的转换</span><br></pre></td></tr></table></figure>

<hr>
<p>版权声明：本文为知乎博主「玩转Linux内核」的原创文章，遵循CC 4.0 BY-SA版权协议，转载请附上原文出处链接及本声明。<br>原文链接：<a href="https://zhuanlan.zhihu.com/p/449157752">https://zhuanlan.zhihu.com/p/449157752</a></p>
]]></content>
      <categories>
        <category>linux-doc</category>
      </categories>
      <tags>
        <tag>Linux</tag>
      </tags>
  </entry>
  <entry>
    <title>Linux操作系统进程同步的几种方式及基本原理</title>
    <url>/2023/01/15/linux-docs/Linux%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E8%BF%9B%E7%A8%8B%E5%90%8C%E6%AD%A5%E7%9A%84%E5%87%A0%E7%A7%8D%E6%96%B9%E5%BC%8F%E5%8F%8A%E5%9F%BA%E6%9C%AC%E5%8E%9F%E7%90%86/</url>
    <content><![CDATA[<h2 id="1，进程同步的几种方式"><a href="#1，进程同步的几种方式" class="headerlink" title="1，进程同步的几种方式"></a>1，进程同步的几种方式</h2><h3 id="1-1信号量"><a href="#1-1信号量" class="headerlink" title="1.1信号量"></a>1.1信号量</h3><p>用于进程间传递信号的一个整数值。在信号量上只有三种操作可以进行：初始化，P操作和V操作，这三种操作都是原子操作。</p>
<p><strong>P操作(递减操作)可以用于阻塞一个进程，V操作(增加操作)可以用于解除阻塞一个进程。</strong></p>
<p>基本原理是两个或多个进程可以通过简单的信号进行合作，一个进程可以被迫在某一位置停止，直到它接收到一个特定的信号。该信号即为信号量s。</p>
<p>为通过信号量s传送信号，进程可执行原语semSignal(s);为通过信号量s接收信号，进程可执行原语semWait(s);如果相应的信号仍然没有发送，则进程会被阻塞，直到发送完为止。</p>
<p><strong>可把信号量视为一个具有整数值的变量，在它之上定义三个操作：</strong></p>
<ul>
<li>一个信号量可以初始化为非负数</li>
<li>semWait操作使信号量s减1.若值为负数，则执行semWait的进程被阻塞。否则进程继续执行。</li>
<li>semSignal操作使信号量加1，若值大于或等于零，则被semWait操作阻塞的进程被解除阻塞。</li>
</ul>
<h3 id="1-2管程"><a href="#1-2管程" class="headerlink" title="1.2管程"></a>1.2管程</h3><p>管程是由一个或多个过程、一个初始化序列和局部数据组成的软件模块，<strong>其主要特点如下：</strong></p>
<ul>
<li>局部数据变量只能被管程的过程访问，任何外部过程都不能访问。</li>
<li>一个进程通过调用管程的一个过程进入管程。</li>
<li>在任何时候，只能有一个进程在管程中执行，调用管程的任何其他进程都被阻塞，以等待管程可用。</li>
</ul>
<p>管程通过使用条件变量提供对同步的支持，这些条件变量包含在管程中，并且只有在管程中才能被访问。有两个函数可以操作条件变量：</p>
<ul>
<li>cwait(c)：调用进程的执行在条件c上阻塞，管程现在可被另一个进程使用。</li>
<li>csignal(c)：恢复执行在cwait之后因为某些条件而阻塞的进程。如果有多个这样的进程，选择其中一个；如果没有这样的进程，什么以不做。</li>
</ul>
<h3 id="1-3消息传递"><a href="#1-3消息传递" class="headerlink" title="1.3消息传递"></a>1.3消息传递</h3><p><strong>消息传递的实际功能以一对原语的形式提供：</strong></p>
<ul>
<li>send(destination,message)</li>
<li>receive(source,message)</li>
</ul>
<p>这是进程间进程消息传递所需要的最小操作集。</p>
<p>一个进程以消息的形式给另一个指定的目标进程发送消息；</p>
<p>进程通过执行receive原语接收消息，receive原语中指明发送消息的源进程和消息。</p>
<h2 id="2、进程互斥"><a href="#2、进程互斥" class="headerlink" title="2、进程互斥"></a>2、进程互斥</h2><p>由于进程具有独立性和异步性等并发特征，计算机的资源有限，导致了进程之间的资源竞争和共享，也导致了对进程执行过程的制约。</p>
<p><strong>1.临界区相关概念：</strong><br><strong>临界资源</strong>：也就是一次只允许一个进程操作使用的计算机资源，这里的资源可以是物理资源，也可以是逻辑上的变量等。<br><strong>临界区</strong>：把不允许多个并发进程交叉执行的一段程序称为临界区（critical region）或临界部分（critical section）。<br><strong>当一个进程使用该临界资源时，其他需要访问该资源的进程必须阻塞，直到占用者释放该资源。</strong></p>
<p><strong>2、间接制约</strong><br>把这种由于共享某一公有资源而引起的在临界区内不允许并发进程交叉执行的现象，称为由共享公有资源而造成的对并发进程执行速度的间接制约。这里的“间接”二字主要是指各种并发进程的速度受公有资源的制约，而非进程之间的直接制约。</p>
<p><strong>3.进程互斥</strong><br>在并发进程中，一个或多个进程要对公用资源进行访问时，必须确保该资源处于空闲状态，也就是说，在并发进程中，临界区只允许一个进程进入，而其他进程阻塞，等待该共享临界资源释放。</p>
<p><strong>4.并发进程之间必须满足以下特征：</strong></p>
<ul>
<li><strong>平等竞争：</strong>即各并发进程享有平等地、独立地竞争共有资源的权利，且在不采取任何措施的条件下，在临界区内任意指令结束时，其他并发进程可以进入临界区。</li>
<li><strong>互斥使用</strong>：当并发进程中的时候 多个进程同时申请进入临界区时，它只允许一个进程进入临界区。</li>
<li><strong>不可独占：</strong>当进程不在临界区后，它不能阻止其他进程进入临界区。</li>
<li><strong>有限等待：</strong>也就是在就绪队列中的进程等待资源时间必须是有限的。并发进程中的某个进程从申请进入临界区时开始，应在有限时间内得以进入临界区。</li>
</ul>
<h2 id="3、互斥的实现"><a href="#3、互斥的实现" class="headerlink" title="3、互斥的实现"></a>3、互斥的实现</h2><h3 id="2-1互斥的加锁实现"><a href="#2-1互斥的加锁实现" class="headerlink" title="2.1互斥的加锁实现"></a>2.1互斥的加锁实现</h3><p>对互斥的临界区进行加锁处理，即当一个进程进入了 临界区之后，对此临界区进行加锁，直到该进程退出临界区为止。而其他并发进程在申请进入临界区之前，必须测试该临界区是否加锁，如果是，则阻塞等待！<br>加锁实现是系统的原语：lock(key[S])和Unlock(key([S]))均保持原子操作。系统实现时锁定位key[S]总是设置在公有资源所对应的数据结构中的。</p>
<h3 id="2-2互斥加锁实现的缺点"><a href="#2-2互斥加锁实现的缺点" class="headerlink" title="2.2互斥加锁实现的缺点"></a>2.2互斥加锁实现的缺点</h3><p>1.在进行锁测试和定位中将耗费CPU资源<br>2、进程加锁实现可能会对进程不公平，<strong>例如：</strong></p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">进程A:</span><br><span class="line"><span class="built_in">lock</span>(key[S])</span><br><span class="line">&lt;S&gt;</span><br><span class="line"><span class="built_in">unlock</span>(key[S])</span><br><span class="line">Goto A</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">进程B：</span><br><span class="line"><span class="built_in">lock</span>(key[S])</span><br><span class="line">&lt;S&gt;</span><br><span class="line"><span class="built_in">unlock</span>(key[S])</span><br><span class="line">Goto B</span><br></pre></td></tr></table></figure>

<p>如上面所示，进程A和B之间的一个进程运行到Goto之后，会使得另一个进程无法得到处理机资源运行。而处于永久饥饿状态（starvation）。</p>
<p>分析可以知道，一个进程能否进入临界区取决于进程自己调用lock过程去测试相应的锁定位。也就是说，每个进程能否进入临界区是依靠进程自己的测试判断。这样，没有获得执行机会的进程当然无法判断，从而出现不公平现象。</p>
<p>那么是否有办法解决这个问题呢？当然，很明显，办法是有的，我们可以为临界区设置一个管理员，由这个管理员来管理相应临界区的公有资源，它代表可用资源的实体，这个管理员就是<strong>信号量</strong>。</p>
<h3 id="2-3信号量和P、V操作"><a href="#2-3信号量和P、V操作" class="headerlink" title="2.3信号量和P、V操作"></a>2.3信号量和P、V操作</h3><p>信号量和P、V原语是荷兰科学家E. W. Dijkstra提出来的。<br>**P原语：**P是荷兰语Proberen（**<em>测试</em>）的首字母。为阻塞原因，负责把当前进程由运行状态转换为阻塞状态，直到另外一个进程唤醒它。操作方法：申请一个空闲资源（把信号量减1），若成功，则退出；若失败，则该进程会被阻塞；</p>
<p><strong>V原语</strong>：V是荷兰语Verhogen（<strong>增加</strong>）的首字母。为<strong>唤醒原语</strong>，负责把一个被阻塞的进程唤醒，它有一个参数表，存放着等待被唤醒的进程信息。操作为：释放一个被占用的资源（把信号量加1），如果发现有被阻塞的进程，则选择一个唤醒之。</p>
<p><strong>【信号量semaphore】</strong> 在操作系统中，信号量sem是一个整数。</p>
<ul>
<li><strong>sem &gt;&#x3D; 0时</strong>，代表可供并发进程使用的资源实体数；</li>
<li><strong>sem &lt; 0时</strong>，表示正在等待使用临界区的进程数。</li>
</ul>
<p>显然，用于互斥的信号量sem的初值应该大于0，而建立一个信号量必须说明所建信号量代表的意义，赋初值，以及建立相应的数据结构，以便指向那些等待使用该临界区的进程。sem初值为1。</p>
<p><strong>【P、V原语】</strong><br>信号量的数值仅能由P、V原语操作改变。采用P、V原语，可以把类名为S的临界区描述为：When S do P(sem) 临界区 V(sem) od。</p>
<ul>
<li>一次<strong>P原语操作使信号量sem减1</strong></li>
<li>一次<strong>V原语操作使信号量sem加1</strong></li>
</ul>
<p><strong>P原语操作：</strong></p>
<p>sem减1；<br>若sem减1后仍大于或等于0，则P原语返回，该进程继续执行；<br>若sem减1后小于0，则该进程被阻塞后进入与该信号相对应的队列中，然后转进程调度。</p>
<p><strong>V原语操作：</strong></p>
<p>sem加1；<br>若相加结果大于0，V原语停止执行，该进程返回调用处，继续执行；<br>若相加结果小于或等于0，则从该信号的等待队列中唤醒一个等待进程，然后再返回原进程继续执行或转进程调度。</p>
<p><strong>这里给出一个使用加锁法的软件实现方法来实现P、V原语：</strong></p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="built_in">P</span>(sem):</span><br><span class="line">    begin</span><br><span class="line">        封锁中断;</span><br><span class="line">        <span class="built_in">lock</span>(lockbit)</span><br><span class="line">        val[sem]=val[sem]<span class="number">-1</span></span><br><span class="line">        <span class="keyword">if</span> val[sem]&lt;<span class="number">0</span></span><br><span class="line">            保护当前进程CPU现场</span><br><span class="line">            当前进程状态置为“等待”</span><br><span class="line">            将当前进程插入信号sem等待队列</span><br><span class="line">            转进程调度</span><br><span class="line">        fi</span><br><span class="line">        <span class="built_in">unlock</span>(lockbit);开放中断</span><br><span class="line">    <span class="function">end</span></span><br><span class="line"><span class="function"><span class="title">V</span><span class="params">(sem)</span>:</span></span><br><span class="line"><span class="function">    begin</span></span><br><span class="line"><span class="function">        封锁中断;</span></span><br><span class="line">        <span class="built_in">lock</span>(lockbit)</span><br><span class="line">        val[sem]=val[sem]+<span class="number">1</span></span><br><span class="line">        <span class="keyword">if</span> val[sem]&lt;=<span class="number">0</span></span><br><span class="line">            local k</span><br><span class="line">            从sem等待队列中选取一个等待进程，将其指针置入k中</span><br><span class="line">            将k插入就绪队列</span><br><span class="line">            进程状态置位“就绪”</span><br><span class="line">        fi</span><br><span class="line">        <span class="built_in">unlock</span>(lockbit);开放中断</span><br><span class="line">    end</span><br></pre></td></tr></table></figure>

<p><strong>2.3用P、V原语实现进程互斥</strong><br>设信号量sem是用于互斥的信号量，且其初始值为1表示没有并发进程使用该临界区。显然，由前面论述可知，只要把临界区置于P(sem)和V(sem)之间，即可实现进程之间的互斥。</p>
<p>用信号量实现两个并发进程PA和PB互斥的描述如下：<br>（1）设sem为互斥信号量，其取值范围为（1，0，-1）。其中sem&#x3D;1表示进程PA和PB都未进入类名为S的临界区，sem&#x3D;0表示进程PA或PB已进入类名为S的临界区，sem&#x3D;-1表示进程PA和PB中，一个进程已进入临界区，而另一个进程等待进入该临界区。<br>（2）实现过程：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">Pa:</span><br><span class="line">    <span class="built_in">P</span>(sem)</span><br><span class="line">    &lt;S&gt;</span><br><span class="line">    <span class="built_in">V</span>(sem)</span><br><span class="line">    .</span><br><span class="line">    .</span><br><span class="line">    .</span><br><span class="line">Pb:</span><br><span class="line">    <span class="built_in">P</span>(sem)</span><br><span class="line">    &lt;S&gt;</span><br><span class="line">    <span class="built_in">V</span>(sem)</span><br><span class="line">    .</span><br><span class="line">    .</span><br><span class="line">    .</span><br></pre></td></tr></table></figure>

<h2 id="4，进程互斥的软件实现方法："><a href="#4，进程互斥的软件实现方法：" class="headerlink" title="4，进程互斥的软件实现方法："></a>4，进程互斥的软件实现方法：</h2><p><strong>1，单标志法</strong></p>
<p>1）在进入区只检查，不上锁</p>
<p>2）在退出区把临界资源的使用权交给另一个进程</p>
<p>3）主要问题：不遵循空闲让进的原则</p>
<p><img src="https://pic2.zhimg.com/80/v2-6ccd4b5e0f74b262a55f9e2358fb0105_720w.webp" alt="img"></p>
<p><strong>2，双标志先检查</strong></p>
<p>1）在进入区先检查后上锁，退出区解锁</p>
<p>2）主要问题：不遵循原则等待原则</p>
<p><img src="https://pic3.zhimg.com/80/v2-0eb596552a0dc05c88a8945b3ea51f36_720w.webp" alt="img"></p>
<p><strong>3，双标志后检查</strong></p>
<p>1）在进入区先</p>
<p>上锁后检查，退出区解锁</p>
<p>2）主要问题：不遵循空闲让进，有限等待原则，可能导致饥饿</p>
<p><img src="https://pic4.zhimg.com/80/v2-3f779d28ca87b1b176d791d1e57b8e17_720w.webp" alt="img"></p>
<p><strong>4，Peterson算法</strong></p>
<p>1）在进入区主动争取——》主动谦让——》检查对方是否想进，己方是否谦让</p>
<p>2）主要问题：不遵循让则等待原则，会发送忙等</p>
<p><img src="https://pic2.zhimg.com/80/v2-c3e7d49c7278ff24cdb25e45139c1221_720w.webp" alt="img"></p>
<h2 id="5、进程同步"><a href="#5、进程同步" class="headerlink" title="5、进程同步"></a>5、进程同步</h2><p><strong>【进程间的直接制约】</strong>：一组在异步环境下的并发进程，各自的执行结果互为对方的执行条件，从而限制各进程的执行速度的过程称为并发进程间的直接制约。这里的异步环境主要是指各并发进程的执行起始时间的随机性和执行速度的独立性。</p>
<p><strong>【进程间的同步】</strong>：把异步环境下的一组并发进程因直接制约而互相发送消息而进行互相合作、互相等待，使得各进程按一定的速度执行的过程称为进程间的同步。具有同步关系的一组并发进程称为合作进程，合作进程间相互发送的信号称为消息或事件。<br><strong>用消息实现进程同步：</strong></p>
<blockquote>
<p>用<br>wait(消息名)<br>表示进程等待合作进程发来的消息。<br>用<br>signal(消息名)<br>表示向合作进程发送消息。<br>过程wait的功能是等待到消息名为true的进程继续执行，而signal的功能则是向合作进程发送合作进程所需要的消息名，并将其值置为true。</p>
</blockquote>
<p><strong>进程互斥和进程同步】</strong>：<br>进程同步不同于进程互斥，进程互斥时它们的执行顺序可以是任意的。一般来说，也可以把个进程之间发送的消息作为信号量看待。与进程互斥时不同的是，这里的信号量只与制约进程及被制约进程有关，而不是与整租并发进程有关。因此，称该信号量为私用信号量（private semaphore）。一个进程Pi的私用信号量semi是从制约进程发送来的进程Pi的执行条件所需要的信息。与私用信号量相对应，称互斥时使用的信号量为公用信号量。</p>
<p>【<strong>用P、V原语实现进程同步】：</strong><br>首先为各并发进程设置私用信号量，然后为私用信号量赋初值，最后利用P、V原语和私用信号量规定各进程的执行顺序。</p>
<hr>
<p>版权声明：本文为知乎博主「玩转Linux内核」的原创文章，遵循CC 4.0 BY-SA版权协议，转载请附上原文出处链接及本声明。<br>原文链接：<a href="https://zhuanlan.zhihu.com/p/447720544">https://zhuanlan.zhihu.com/p/447720544</a></p>
]]></content>
      <categories>
        <category>linux-doc</category>
      </categories>
      <tags>
        <tag>Linux</tag>
      </tags>
  </entry>
  <entry>
    <title>Linux操作系统进程的状态和转换(五态模型)</title>
    <url>/2023/01/15/linux-docs/Linux%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E8%BF%9B%E7%A8%8B%E7%9A%84%E7%8A%B6%E6%80%81%E5%92%8C%E8%BD%AC%E6%8D%A2(%E4%BA%94%E6%80%81%E6%A8%A1%E5%9E%8B)/</url>
    <content><![CDATA[<h2 id="1、进程的状态和装换"><a href="#1、进程的状态和装换" class="headerlink" title="1、进程的状态和装换"></a>1、进程的状态和装换</h2><h3 id="1-1进程的三态模型"><a href="#1-1进程的三态模型" class="headerlink" title="1.1进程的三态模型"></a>1.1进程的三态模型</h3><p><strong>按进程在执行过程中的不同情况至少要定义三种状态：</strong></p>
<ul>
<li>运行（running）态：进程占有处理器正在运行的状态。进程已获得CPU，其程序正在执行。在单处理机系统中，只有一个进程处于执行状态； 在多处理机系统中，则有多个进程处于执行状态。</li>
<li>就绪（ready）态：进程具备运行条件，等待系统分配处理器以便运行的状态。当进程已分配到除CPU以外的所有必要资源后，只要再获得CPU，便可立即执行，进程这时的状态称为就绪状态。在一个系统中处于就绪状态的进程可能有多个，通常将它们排成一个队列，称为就绪队列。</li>
<li>等待（wait）态：又称阻塞态或睡眠态，指进程不具备运行条件，正在等待某个时间完成的状态。也称为等待或睡眠状态，一个进程正在等待某一事件发生（例如请求I&#x2F;O而等待I&#x2F;O完成等）而暂时停止运行，这时即使把处理机分配给进程也无法运行，故称该进程处于阻塞状态。</li>
</ul>
<p><img src="https://pic1.zhimg.com/80/v2-9d41935db8f3c558cc4904278295ae30_720w.webp" alt="img"></p>
<p><strong>引起进程状态转换的具体原因如下：</strong></p>
<ul>
<li>运行态→等待态：等待使用资源；</li>
<li>如等待外设传输；等待人工干预。</li>
<li>等待态→就绪态：资源得到满足；</li>
<li>如外设传输结束；人工干预完成。</li>
<li>运行态→就绪态：运行时间片到；</li>
</ul>
<p><strong>出现有更高优先权进程。就绪态—→运行态：CPU 空闲时选择一个就绪进程。</strong></p>
<h3 id="1-2-进程的五态模型"><a href="#1-2-进程的五态模型" class="headerlink" title="1.2 进程的五态模型"></a>1.2 进程的五态模型</h3><p>五态模型在三态模型的基础上增加了新建态（new）和终止态（exit）：</p>
<ul>
<li>新建态：对应于进程被创建时的状态，尚未进入就绪队列。创建一个进程需要通过两个步骤：1.为新进程分配所需要的资源和建立必要的管理信息。2.设置该进程为就绪态，并等待被调度执行。</li>
<li>终止态：指进程完成任务到达正常结束点，或出现无法克服的错误而异常终止，或被操作系统及有终止权的进程所终止时所处的状态。处于终止态的进程不再被调度执行，下一步将被系统撤销，最终从系统中消失。终止一个进程需要两个步骤：1.先对操作系统或相关的进程进行善后处理（如抽取信息）。2.然后回收占用的资源并被系统删除。</li>
</ul>
<p><img src="https://pic3.zhimg.com/80/v2-4a98dc88b067603584f3c0d6a688b4f6_720w.webp" alt="img"></p>
<p><strong>引起进程状态转换的具体原因如下：</strong></p>
<ul>
<li>NULL→新建态：执行一个程序，创建一个子进程。</li>
<li>新建态→就绪态：当操作系统完成了进程创建的必要操作，并且当前系统的性能和虚拟内存的容量均允许。</li>
<li>运行态→终止态：当一个进程到达了自然结束点，或是出现了无法克服的错误，或是被操作系统所终结，或是被其他有终止权的进程所终结。</li>
<li>运行态→就绪态：运行时间片到；出现有更高优先权进程。</li>
<li>运行态→等待态：等待使用资源；如等待外设传输；等待人工干预。</li>
<li>就绪态→终止态：未在状态转换图中显示，但某些操作系统允许父进程终结子进程。</li>
<li>等待态→终止态：未在状态转换图中显示，但某些操作系统允许父进程终结子进程。</li>
<li>终止态→NULL：完成善后操作。</li>
</ul>
<h3 id="1-3-进程的七态模型"><a href="#1-3-进程的七态模型" class="headerlink" title="1.3 进程的七态模型"></a>1.3 进程的七态模型</h3><p>三态模型和五态模型都是假设所有进程都在内存中的事实上有序不断的创建进程，当系统资源尤其是内存资源已经不能满足进程运行的要求时，必须把某些进程挂起（suspend），对换到磁盘对换区中，释放它占有的某些资源，暂时不参与低级调度。起到平滑系统操作负荷的目的。</p>
<blockquote>
<p>引起进程挂起的原因是多样的，主要有：<br>1.终端用户的请求。当终端用户在自己的程序运行期间发现有可疑问题时，希望暂停使自己的程序静止下来。亦即，使正在执行的进程暂停执行；若此时用户进程正处于就绪状态而未执行，则该进程暂不接受调度，以便用户研究其执行情况或对程序进行修改。我们把这种静止状态成为“挂起状态”。 2.父进程的请求。有时父进程希望挂起自己的某个子进程，以便考察和修改子进程，或者协调各子进程间的活动。 3.负荷调节的需要。当实时系统中的工作负荷较重，已可能影响到对实时任务的控制时，可由系统把一些不重要的进程挂起，以保证系统能正常运行。 4.操作系统的需要。操作系统有时希望挂起某些进程，以便检查运行中的资源使用情况或进行记账。 5.对换的需要。为了缓和内存紧张的情况，将内存中处于阻塞状态的进程换至外存上。</p>
</blockquote>
<p>七态模型在五态模型的基础上增加了挂起就绪态（ready suspend）和挂起等待态（blocked suspend）。</p>
<ul>
<li>挂起就绪态：进程具备运行条件，但目前在外存中，只有它被对换到内存才能被调度执行。</li>
<li>挂起等待态：表明进程正在等待某一个事件发生且在外存中。</li>
</ul>
<p><img src="https://pic3.zhimg.com/80/v2-03cd4971e9b96643bc50267bdb924d42_720w.webp" alt="img"></p>
<p><strong>引起进程状态转换的具体原因如下：</strong></p>
<p>等待态→挂起等待态：操作系统根据当前资源状况和性能要求，可以决定把等待态进程对换出去成为挂起等待态。</p>
<p>挂起等待态→挂起就绪态：引起进程等待的事件发生之后，相应的挂起等待态进程将转换为挂起就绪态挂起就绪态→就绪态：当内存中没有就绪态进程，或者挂起就绪态进程具有比就绪态进程更高的优先级，系统将把挂起就绪态进程转换成就绪态。</p>
<p>就绪态→挂起就绪态：操作系统根据当前资源状况和性能要求，也可以决定把就绪态进程对换出去成为挂起就绪态。</p>
<p>挂起等待态→等待态：当一个进程等待一个事件时，原则上不需要把它调入内存。但是在下面一种情况下，这一状态变化是可能的。当一个进程退出后，主存已经有了一大块自由空间,而某个挂起等待态进程具有较高的优先级并且操作系统已经得知导致它阻塞的事件即将结束，此时便发生了这一状态变化。</p>
<p>运行态→挂起就绪态：当一个具有较高优先级的挂起等待态进程的等待事件结束后，它需要抢占 CPU，而此时主存空间不够，从而可能导致正在运行的进程转化为挂起就绪态。另外处于运行态的进程也可以自己挂起自己。</p>
<p>新建态→挂起就绪态：考虑到系统当前资源状况和性能要求，可以决定新建的进程将被对换出去成为挂起就绪态。</p>
<p>挂起进程等同于不在内存中的进程，因此挂起进程将不参与低级调度直到它们被调换进内存。</p>
<p><strong>挂起进程具有如下特征：</strong></p>
<ul>
<li>该进程不能立即被执行</li>
<li>挂起进程可能会等待一个事件，但所等待的事件是独立于挂起条件的，事件结束并不能导致进程具备执行条件。 （等待事件结束后进程变为挂起就绪态）</li>
<li>进程进入挂起状态是由于操作系统、父进程或进程本身阻止它的运行。</li>
<li>结束进程挂起状态的命令只能通过操作系统或父进程发出。</li>
</ul>
<hr>
<p>版权声明：本文为知乎博主「玩转Linux内核」的原创文章，遵循CC 4.0 BY-SA版权协议，转载请附上原文出处链接及本声明。<br>原文链接：<a href="https://zhuanlan.zhihu.com/p/447668827">https://zhuanlan.zhihu.com/p/447668827</a></p>
]]></content>
      <categories>
        <category>linux-doc</category>
      </categories>
      <tags>
        <tag>Linux</tag>
      </tags>
  </entry>
  <entry>
    <title>Linux操作系统通过实战理解CPU上下文切换</title>
    <url>/2023/01/15/linux-docs/Linux%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E9%80%9A%E8%BF%87%E5%AE%9E%E6%88%98%E7%90%86%E8%A7%A3CPU%E4%B8%8A%E4%B8%8B%E6%96%87%E5%88%87%E6%8D%A2/</url>
    <content><![CDATA[<blockquote>
<p>前言：Linux是一个多任务的操作系统，可以支持远大于CPU数量的任务同时运行，但是我们都知道这其实是一个错觉，真正是系统在很短的时间内将CPU轮流分配给各个进程，给用户造成多任务同时运行的错觉。所以这就是有一个问题，在每次运行进程之前CPU都需要知道进程从哪里加载、从哪里运行，也就是说需要系统提前帮它设置好CPU寄存器和程序计数器。</p>
</blockquote>
<h2 id="1、CPU上下文"><a href="#1、CPU上下文" class="headerlink" title="1、CPU上下文"></a>1、CPU上下文</h2><p>CPU上下文其实是一些环境正是有这些环境的支撑，任务得以运行，而这些环境的硬件条件便是CPU寄存器和程序计数器。CPU寄存器是CPU内置的容量非常小但是速度极快的存储设备，程序计数器则是CPU在运行任何任务时必要的，里面记录了当前运行任务的行数等信息，这就是CPU上下文。</p>
<p><img src="https://pic2.zhimg.com/80/v2-2963c5a54a0fbef8dc07b8dbf93cd5c5_720w.webp" alt="img"></p>
<h2 id="2、CPU上下文切换"><a href="#2、CPU上下文切换" class="headerlink" title="2、CPU上下文切换"></a>2、CPU上下文切换</h2><p>根据任务的不同，CPU的上下文切换就可以分为进程上下文切换、线程上下文切换、中断上下文切换<br>，进程上下文切换。</p>
<p><strong>在Linux中，Linux按照特权等级，将进程的运行空间分为内核空间和用户空间：</strong></p>
<ul>
<li>内核空间具有最高权限，可以直接访问所有资源</li>
<li>用户空间只能访问受限资源，不能直接访问内存等硬件设备，要想访问这些特权资源，必须通过系统调用</li>
</ul>
<p>对于一个进程来说，一般是运行在用户态的，但是当需要访问内存、磁盘等硬件设备的时候需要陷入到内核态中，也就是要从用户态到内核态的转变，而这种转变需要通过系统调用来实现，例如一个打开文件的操作，需要调用open()打开文件，read()读取文件内容，write()将文件内容输出到控制台，最后close()关闭文件，这就是系统调用</p>
<p><strong>在系统调用的过程中同样发发生了CPU上下文切换：</strong></p>
<ul>
<li>CPU寄存器里面原来用户态的指令位置，需要先保存起来，接着运行内核态代码</li>
<li>CPU寄存器需要更新为内核态指令的位置，执行内核态代码</li>
</ul>
<p>系统调用结束后，CPU寄存器需要恢复原来保存的用户态，然后切换为用户空间，所以一次系统调用的过程，会发生两次的CPU上下文切换但是我们一般说系统调用是特权模式切换而不是上下文切换，因为这里没有涉及到虚拟内存等这些进程用户态的资源，也不会切换进程是属于进程之内的上下文切换，进程是由内核来管理和调度的，进程的切换只能发生在内核态，所以进程的上下文包含了虚拟内存、栈、全局变量等用户空间的资源，还包含了内核堆栈、寄存器等内核空间的状态，所以进程的上下文切换要比系统调用更多一步，保存该进程的虚拟内存、栈等用户空间的资源，进程上下文切换一般需要几十纳秒到数微秒的CPU时间，当进程上下文切换次数比较多的情况下爱，将导致CPU将大量的时间耗费在寄存器、内核栈即虚拟内存等资源的保存和恢复上，另外，Linux通过TLB快表来管理虚拟内存到物理内存的映射关系，当虚拟内存更新之后，需要刷新缓存，在这多处理系统上是很复杂的，因为多个处理器共享一个缓存。</p>
<p>下面再来说说什么时候会进行进程的上下文切换，其实就是进程在被调度的时候需要切换上下文，可能是主动地，也有可能是被动的</p>
<ul>
<li>系统进程正常调度算法导致进程上下文切换，例如目前使用的时间片轮转算法，当一个进程的时间片耗尽之后，CPU会进项进程的调度切换到其他进程</li>
<li>进程在资源不足的时候，会被挂起例如在等待IO或者内存不足的时候，会主动挂起，并且等待系统调度其他进程</li>
<li>当进程通过一些睡眠函数sleep()主动挂起的时候，也会重新调度</li>
<li>当有高优先级的进程运行时，当前进程也会被挂起</li>
<li>当发生硬件中断时，CPU上的进程会被中断挂起</li>
</ul>
<h2 id="3、线程上下文切换"><a href="#3、线程上下文切换" class="headerlink" title="3、线程上下文切换"></a>3、线程上下文切换</h2><p>线程是调度的基本单位，而进程则是资源拥有的基本单位，也就是说对于内核中的任务调度是以线程为单位，但是进程只是给线程提供了虚拟内存、全局变量等资源，进程与线程之间的区别这里不再介绍<br>那么线程上下文的切换，其实分为两种情况：</p>
<ul>
<li>前后两个线程属于不同进程，因为资源不共享，所以这时候的线程上下文切换和进程上下文切换是一致的</li>
<li>前后两个线程属于同一个进程，因为虚拟内存是共享的，所以在切换的时候，虚拟内存这些资源保持不动，只有切换线程的私有数据、寄存器等不共享的资源</li>
</ul>
<p>所以同进程内的线程切换要比多进程内的线程切换消耗更少的资源</p>
<h2 id="4、中断上下文切换"><a href="#4、中断上下文切换" class="headerlink" title="4、中断上下文切换"></a>4、中断上下文切换</h2><p>中断是为了快速响应硬件的事件，简单来shu就是计算机停下当前的事情，去处理其他的事情，然后在回来继续执行之前的任务，例如我们在调用print函数的时候，其实汇编的底层会帮我们调用一条 int 0x80的指令，便是调用0x80号中断<br>当然，中断要先将当前进程的状态保存下来，这样中断结束后进程仍然可以从原来的状态恢复运行，中断上下文的切换并不涉及进程的用户态，所以当中断程序打断了正在处于用户态的进程，不需要保存和恢复这个进程的虚拟内存、全局变量等用户态资源，只需要保存和恢复这个进程的内核态中的资源包括CPU寄存器、内核堆栈等<br>对于同一个CPU来说，中断处理比进程拥有更高的优先级，所以中断上下文切换并不会与进程上下文切换同时发生，一般来说中断程序都执行比较快短小精悍，以便快速结束执行之前的任务。当中断上下文切换次数比较多的时候，会耗费大量的CPU<br>怎么查看系统上下文<br>上面已经介绍到CPU上下文切换分为进程上下文切换、线程上下文切换、中断上下文切换，那么过多的上下文切换会把CPU的时间消耗在寄存器、内核栈以及虚拟内存等数据的保存和恢复上，缩短进程真正运行的时间，成为系统性能大幅下降的一个因素<br>所以我们可以使用vmstat这个工具来查询系统的上下文切换情况，vmstat是一个常用的系统性能分析工具，可以用来分析CPU上下文切换和中断的次数</p>
<p><img src="https://pic4.zhimg.com/80/v2-bf160f70fcfe5753af65f76e656a0777_720w.webp" alt="img"></p>
<p><strong>需要特别关注的是：</strong></p>
<ul>
<li>cs(context switch)：每秒上下文切换的次数</li>
<li>in(interrupt)：每秒中断的次数</li>
<li>r(Running or Runnable)：就绪队列的长度，也就是正在运行和等待CPU的进程</li>
<li>b(Blocked)：处于不可中断睡眠状态的进程数</li>
</ul>
<p>vmstat是给出整个系统总体的上下文切换情况，要想查看每个进程的详细情况就需要使用pidstat，加上-w选项就可以查看进程上下文切换的情况</p>
<p><img src="https://pic2.zhimg.com/80/v2-7811dcde8e3be5d12c688f76db226ce1_720w.webp" alt="img"></p>
<p><strong>需要特别关注的是：</strong></p>
<ul>
<li>cswch(voluntary context switches)：表示每秒自愿上下文切换的次数</li>
<li>nvcswch(non voluntary context switches)：表示每秒非自愿上下文切换的次数</li>
</ul>
<p><strong>这两个概念的分别含义：</strong></p>
<ul>
<li>自愿上下文切换：进程无法获取所需的资源，导致的上下文切换，例如IO、内存等资源不足时，就会发生自愿上下文切换</li>
<li>非自愿上下文切换：进程由于时间片已到等时间，被系统强制调度，进而发生的上下文切换，例如大量的进程都在争抢CPU时，就容易发生非自愿上下文切换</li>
</ul>
<p>实战分析<br>通过上面的工具已经可以初步查看到系统上下文切换的次数，但是当系统上下文切换的次数为多少时是不正常的呢？<br>案例使用sysbench工具来模拟多线程调度切换的情况，sysbench是一个多线程的基准测试工具，可以模拟上下文切换过多的问题<br>首先在第一个终端运行stsbench，模拟多线程切换问题<br># 以 10 个线程运行 5 分钟的基准测试，模拟多线程切换的问题 sysbench –threads&#x3D;10 –max-time&#x3D;300 threads run<br>然后在第二个终端运行vmstat，每1秒查看上下文切换的情况</p>
<p><img src="https://pic3.zhimg.com/80/v2-024f1d916271998f8beaafcc0851008e_720w.webp" alt="img"></p>
<p><strong>可以观察到如下指标：</strong></p>
<ul>
<li>r列：就绪队列的长度已经到了8左右，已经超过了2个cpu，所以会有大量的CPU竞争</li>
<li>us(user)列和sy(system)列，这两列的CPU使用率已经到达100%，并且大量是由sy造成的，说明CPU主要是被内核占用了</li>
<li>in(interrupt)：in列的数值也到了解决1万，所以中断处理也是一个问题</li>
</ul>
<p>那我们接着使用pidstat来查看是那一个进程出现了问题，由于pidstat默认是显示进程的指标数据，但是我们使用sysbench模拟的线程的数据，所以需要加上-t选项<br>gpw@gopuwe:~$ pidstat -wt</p>
<p><img src="https://pic3.zhimg.com/80/v2-f864f377ff15110fefb80aeeeec3ae9e_720w.webp" alt="img"></p>
<p>所以到这里可以分析出是sysbench的子线程的上下文切换次数有很多<br>还有一个问题，在使用vmstat的时候，发现in指标的数据也比较多，那么我们需要找出是什么类型的中断导致了中断上升，中断肯定是发生在内核态，但是pidstat只是一个进程的性能分析工具，并不提供任何关于中断的详细信息<br>我们可以从&#x2F;proc&#x2F;interrupts这个只读文件中读取，&#x2F;proc是一个虚拟文件系统，用于内核空间和用户空间之间的通信，&#x2F;proc&#x2F;interrupts则提供了一个只读的中断使用情况，可以使用cat命令查看&#x2F;proc&#x2F;interrupts可以发现变化速度最快的是重调度中断RES，这个中断类型表示唤醒空闲状态的CPU来调度新的任务运行，也被成为处理器中断<br>那么到底上下文切换的次数为多少合适呢？<br>这个数值其实取决于系统本身的 CPU 性能，在我看来，如果系统的上下文切换次数比较稳<br>定，那么从数百到一万以内，都应该算是正常的。但当上下文切换次数超过一万次，或者切<br>换次数出现数量级的增长时，就很可能已经出现了性能问题，这个时候还要根据上下文切换的类型，做具体的分析，例如：</p>
<ul>
<li>自愿上下文切换变多了，说明进程都在等待资源，有可能发生了 I&#x2F;O 等其他问题；</li>
<li>非自愿上下文切换变多了，说明进程都在被强制调度，也就是都在争抢 CPU，说明 CPU的确成了瓶颈；</li>
<li>中断次数变多了，说明 CPU 被中断处理程序占用，还需要通过查看 &#x2F;proc&#x2F;interrupts 文件</li>
</ul>
<hr>
<p>版权声明：本文为知乎博主「玩转Linux内核」的原创文章，遵循CC 4.0 BY-SA版权协议，转载请附上原文出处链接及本声明。<br>原文链接：<a href="https://zhuanlan.zhihu.com/p/452839400">https://zhuanlan.zhihu.com/p/452839400</a></p>
]]></content>
      <categories>
        <category>linux-doc</category>
      </categories>
      <tags>
        <tag>Linux</tag>
      </tags>
  </entry>
  <entry>
    <title>Linux用户空间与内核空间通信(Netlink通信机制)</title>
    <url>/2023/01/15/linux-docs/Linux%E7%94%A8%E6%88%B7%E7%A9%BA%E9%97%B4%E4%B8%8E%E5%86%85%E6%A0%B8%E7%A9%BA%E9%97%B4%E9%80%9A%E4%BF%A1(Netlink%E9%80%9A%E4%BF%A1%E6%9C%BA%E5%88%B6)/</url>
    <content><![CDATA[<h2 id="1，什么是Netlink通信机制"><a href="#1，什么是Netlink通信机制" class="headerlink" title="1，什么是Netlink通信机制"></a>1，什么是Netlink通信机制</h2><p>Netlink是linux提供的用于内核和用户态进程之间的通信方式。但是注意虽然Netlink主要用于用户空间和内核空间的通信，但是也能用于用户空间的两个进程通信。只是进程间通信有其他很多方式，一般不用Netlink。除非需要用到Netlink的广播特性时。</p>
<p><strong>那么Netlink有什么优势呢？</strong></p>
<p>一般来说用户空间和内核空间的通信方式有三种：&#x2F;proc、ioctl、Netlink。而前两种都是单向的，但是Netlink可以实现双工通信。Netlink协议基于BSD socket和AF_NETLINK地址簇(address family)，使用32位的端口号寻址(以前称作PID)，每个Netlink协议(或称作总线，man手册中则称之为netlink family)，通常与一个或一组内核服务&#x2F;组件相关联，如NETLINK_ROUTE用于获取和设置路由与链路信息、NETLINK_KOBJECT_UEVENT用于内核向用户空间的udev进程发送通知等。</p>
<p><strong>netlink具有以下特点：</strong></p>
<ul>
<li>① 支持全双工、异步通信(当然同步也支持)</li>
<li>② 用户空间可使用标准的BSD socket接口(但netlink并没有屏蔽掉协议包的构造与解析过程，推荐使用libnl等第三方库)</li>
<li>③ 在内核空间使用专用的内核API接口</li>
<li>④ 支持多播(因此支持“总线”式通信，可实现消息订阅)</li>
<li>⑤ 在内核端可用于进程上下文与中断上下文</li>
</ul>
<h2 id="2，用户态数据结构"><a href="#2，用户态数据结构" class="headerlink" title="2，用户态数据结构"></a>2，用户态数据结构</h2><p><strong>首先看一下几个重要的数据结构的关系：</strong></p>
<p><img src="https://pic4.zhimg.com/80/v2-96d22312a35be5bec7c90d6455c1e8a7_720w.webp" alt="img"></p>
<p><strong>1.struct msghdr</strong></p>
<p>msghdr这个结构在socket变成中就会用到，并不算Netlink专有的，这里不在过多说明。只说明一下如何更好理解这个结构的功能。我们知道socket消息的发送和接收函数一般有这几对：recv／send、readv／writev、recvfrom／sendto。当然还有recvmsg／sendmsg，前面三对函数各有各的特点功能，而recvmsg／sendmsg就是要囊括前面三对的所有功能，当然还有自己特殊的用途。msghdr的前两个成员就是为了满足recvfrom／sendto的功能，中间两个成员msg_iov和msg_iovlen则是为了满足readv／writev的功能，而最后的msg_flags则是为了满足recv／send中flag的功能，剩下的msg_control和msg_controllen则是满足recvmsg／sendmsg特有的功能。</p>
<p><strong>2.struct sockaddr_ln</strong></p>
<p>struct sockaddr_ln为Netlink的地址，和我们通常socket编程中的sockaddr_in作用一样，他们的结构对比如下：</p>
<p><img src="https://pic4.zhimg.com/80/v2-05e9137ab14f9208bdbcc18909e3e7b7_720w.webp" alt="img"></p>
<p><strong>struct sockaddr_nl的详细定义和描述如下：</strong></p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">struct</span> <span class="title class_">sockaddr_nl</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">sa_family_t</span> nl_family; <span class="comment">/*该字段总是为AF_NETLINK */</span></span><br><span class="line">    <span class="type">unsigned</span> <span class="type">short</span> nl_pad; <span class="comment">/* 目前未用到，填充为0*/</span></span><br><span class="line">    __u32 nl_pid; <span class="comment">/* process pid */</span></span><br><span class="line">    __u32 nl_groups; <span class="comment">/* multicast groups mask */</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>(1) nl_pid：在Netlink规范里，PID全称是Port-ID(32bits)，其主要作用是用于唯一的标识一个基于netlink的socket通道。通常情况下nl_pid都设置为当前进程的进程号。前面我们也说过，Netlink不仅可以实现用户-内核空间的通信还可使现实用户空间两个进程之间，或内核空间两个进程之间的通信。该属性为0时一般指内核。</p>
<p>(2) nl_groups：如果用户空间的进程希望加入某个多播组，则必须执行bind()系统调用。该字段指明了调用者希望加入的多播组号的掩码(注意不是组号，后面我们会详细讲解这个字段)。如果该字段为0则表示调用者不希望加入任何多播组。对于每个隶属于Netlink协议域的协议，最多可支持32个多播组(因为nl_groups的长度为32比特)，每个多播组用一个比特来表示。</p>
<p><strong>3.struct nlmsghdr</strong></p>
<p>Netlink的报文由消息头和消息体构成，struct nlmsghdr即为消息头。消息头定义在文件里，由结构体nlmsghdr表示：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">struct</span> <span class="title class_">nlmsghdr</span></span><br><span class="line">&#123;</span><br><span class="line">    __u32 nlmsg_len; <span class="comment">/* Length of message including header */</span></span><br><span class="line">    __u16 nlmsg_type; <span class="comment">/* Message content */</span></span><br><span class="line">    __u16 nlmsg_flags; <span class="comment">/* Additional flags */</span></span><br><span class="line">    __u32 nlmsg_seq; <span class="comment">/* Sequence number */</span></span><br><span class="line">    __u32 nlmsg_pid; <span class="comment">/* Sending process PID */</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p><strong>消息头中各成员属性的解释及说明：</strong></p>
<p>(1) nlmsg_len：整个消息的长度，按字节计算。包括了Netlink消息头本身。</p>
<p>(2) nlmsg_type：消息的类型，即是数据还是控制消息。目前(内核版本2.6.21)Netlink仅支持四种类型的控制消息，如下：</p>
<ul>
<li>a) NLMSG_NOOP-空消息，什么也不做；</li>
<li>b) NLMSG_ERROR-指明该消息中包含一个错误；</li>
<li>c) NLMSG_DONE-如果内核通过Netlink队列返回了多个消息，那么队列的最后一条消息的类型为NLMSG_DONE，其余所有消息的nlmsg_flags属性都被设置NLM_F_MULTI位有效。</li>
<li>d) NLMSG_OVERRUN-暂时没用到。</li>
</ul>
<p>(3) nlmsg_flags：附加在消息上的额外说明信息，如上面提到的NLM_F_MULTI。</p>
<h2 id="3，用户空间Netlink-socket-API"><a href="#3，用户空间Netlink-socket-API" class="headerlink" title="3，用户空间Netlink socket API"></a>3，用户空间Netlink socket API</h2><p><strong>1.创建socket</strong></p>
<p>int socket(int domain, int type, int protocol)</p>
<p>domain指代地址族,即AF_NETLINK;</p>
<p>套接字类型为SOCK_RAW或SOCK_DGRAM,因为netlink是一个面向数据报的服务;</p>
<p>protocol选择该套接字使用哪种netlink特征。</p>
<p><strong>以下是几种预定义的协议类型:</strong></p>
<ul>
<li>NETLINK_ROUTE,</li>
<li>NETLINK_FIREWALL,</li>
<li>NETLINK_APRD,</li>
<li>NETLINK_ROUTE6_FW。</li>
</ul>
<p>可以非常容易的添加自己的netlink协议。为每一个协议类型最多可以定义32个多播组。每一个多播组用一个bitmask来表示,1&lt;&lt;i(0&lt;&#x3D;i&lt;&#x3D; 31),这在一组进程和内核进程协同完成一项任务时非常有用。发送多播netlink消息可以减少系统调用的数量,同时减少用来维护多播组成员信息的负担。</p>
<p><strong>2.地址绑定bind()</strong></p>
<p>bind(fd, (struct sockaddr*)&amp;, nladdr, sizeof(nladdr));</p>
<p><strong>3.发送netlink消息</strong></p>
<p>为了发送一条netlink消息到内核或者其他的用户空间进程,另外一个struct sockaddr_nl nladdr需要作为目的地址,这和使用sendmsg()发送一个UDP包是一样的。</p>
<ul>
<li>如果该消息是发送至内核的,那么nl_pid和nl_groups都置为0.</li>
<li>如果消息是发送给另一个进程的单播消息,nl_pid是另外一个进程的pid值而nl_groups为零。</li>
<li>如果消息是发送给一个或多个多播组的多播消息,所有的目的多播组必须bitmask必须or起来从而形成nl_groups域。sendmsg(fd, &amp;, msg, 0);</li>
</ul>
<p><strong>4.接收netlink消息</strong></p>
<p>一个接收程序必须分配一个足够大的内存用于保存netlink消息头和消息负载。然后其填充struct msghdr msg,再使用标准的recvmsg()函数来接收netlink消息。</p>
<p>当消息被正确的接收之后,nlh应该指向刚刚接收到的netlink消息的头。nladdr应该包含接收消息的目的地址,其中包括了消息发送者的pid和多播组。同时,宏NLMSG_DATA(nlh),定义在netlink.h中,返回一个指向netlink消息负载的指针。调用close(fd)关闭fd描述符所标识的socket；recvmsg(fd, &amp;, msg, 0);</p>
<h2 id="4、内核空间Netlink-socket-API"><a href="#4、内核空间Netlink-socket-API" class="headerlink" title="4、内核空间Netlink socket API"></a>4、内核空间Netlink socket API</h2><p><strong>1.创建 netlink socket</strong></p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">struct</span> <span class="title class_">sock</span> *<span class="built_in">netlink_kernel_create</span>(<span class="keyword">struct</span> net *net,</span><br><span class="line">                                   <span class="type">int</span> unit,<span class="type">unsigned</span> <span class="type">int</span> groups,</span><br><span class="line">                                   <span class="built_in">void</span> (*input)(<span class="keyword">struct</span> sk_buff *skb),</span><br><span class="line">                                   <span class="keyword">struct</span> mutex *cb_mutex,<span class="keyword">struct</span> <span class="keyword">module</span> *<span class="keyword">module</span>);</span><br></pre></td></tr></table></figure>

<p><strong>参数说明：</strong></p>
<ul>
<li>(1) net：是一个网络名字空间namespace，在不同的名字空间里面可以有自己的转发信息库，有自己的一套net_device等等。默认情况下都是使用 init_net这个全局变量。</li>
<li>(2) unit：表示netlink协议类型，如NETLINK_TEST、NETLINK_SELINUX。</li>
<li>(3) groups：多播地址。</li>
<li>(4) input：为内核模块定义的netlink消息处理函数，当有消 息到达这个netlink socket时，该input函数指针就会被引用，且只有此函数返回时，调用者的sendmsg才能返回。</li>
<li>(5) cb_mutex：为访问数据时的互斥信号量。</li>
<li>(6) module： 一般为THIS_MODULE。</li>
</ul>
<p><strong>2.发送单播消息 netlink_unicast</strong></p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span> <span class="title">netlink_unicast</span><span class="params">(<span class="keyword">struct</span> sock *ssk, <span class="keyword">struct</span> sk_buff *skb, u32 pid, <span class="type">int</span> nonblock)</span></span></span><br></pre></td></tr></table></figure>

<p><strong>参数说明：</strong></p>
<ul>
<li>(1) ssk：为函数 netlink_kernel_create()返回的socket。</li>
<li>(2) skb：存放消息，它的data字段指向要发送的netlink消息结构，而 skb的控制块保存了消息的地址信息，宏NETLINK_CB(skb)就用于方便设置该控制块。</li>
<li>(3) pid：为接收此消息进程的pid，即目标地址，如果目标为组或内核，它设置为 0。</li>
<li>(4) nonblock：表示该函数是否为非阻塞，如果为1，该函数将在没有接收缓存可利用时立即返回；而如果为0，该函数在没有接收缓存可利用定时睡眠。</li>
</ul>
<p><strong>3.发送广播消息 netlink_broadcast</strong></p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span> <span class="title">netlink_broadcast</span><span class="params">(<span class="keyword">struct</span> sock *ssk, <span class="keyword">struct</span> sk_buff *skb, u32 pid, u32 group, <span class="type">gfp_t</span> allocation)</span></span></span><br></pre></td></tr></table></figure>

<p>前面的三个参数与 netlink_unicast相同，参数group为接收消息的多播组，该参数的每一个位代表一个多播组，因此如果发送给多个多播组，就把该参数设置为多个多播组组ID的位或。参数allocation为内核内存分配类型，一般地为GFP_ATOMIC或GFP_KERNEL，GFP_ATOMIC用于原子的上下文（即不可以睡眠），而GFP_KERNEL用于非原子上下文。</p>
<p><strong>4.释放 netlink socket</strong></p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span> <span class="title">netlink_broadcast</span><span class="params">(<span class="keyword">struct</span> sock *ssk, <span class="keyword">struct</span> sk_buff *skb, u32 pid, u32 group, <span class="type">gfp_t</span> allocation)</span></span></span><br></pre></td></tr></table></figure>

<h2 id="5、用户态"><a href="#5、用户态" class="headerlink" title="5、用户态"></a>5、用户态</h2><p><strong>范例一</strong></p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/stat.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/socket.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/types.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;asm/types.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;linux/netlink.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;linux/socket.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;errno.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> MAX_PAYLOAD 1024 <span class="comment">// maximum payload size</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> NETLINK_TEST 25 <span class="comment">//自定义的协议</span></span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">(<span class="type">int</span> argc, <span class="type">char</span>* argv[])</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">int</span> state;</span><br><span class="line">    <span class="keyword">struct</span> <span class="title class_">sockaddr_nl</span> src_addr, dest_addr;</span><br><span class="line">    <span class="keyword">struct</span> <span class="title class_">nlmsghdr</span> *nlh = <span class="literal">NULL</span>; <span class="comment">//Netlink数据包头</span></span><br><span class="line">    <span class="keyword">struct</span> <span class="title class_">iovec</span> iov;</span><br><span class="line">    <span class="keyword">struct</span> <span class="title class_">msghdr</span> msg;</span><br><span class="line">    <span class="type">int</span> sock_fd, retval;</span><br><span class="line">    <span class="type">int</span> state_smg = <span class="number">0</span>;</span><br><span class="line">    <span class="comment">// Create a socket</span></span><br><span class="line">    sock_fd = <span class="built_in">socket</span>(AF_NETLINK, SOCK_RAW, NETLINK_TEST);</span><br><span class="line">    <span class="keyword">if</span>(sock_fd == <span class="number">-1</span>)&#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;error getting socket: %s&quot;</span>, <span class="built_in">strerror</span>(errno));</span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// To prepare binding</span></span><br><span class="line">    <span class="built_in">memset</span>(&amp;src_addr, <span class="number">0</span>, <span class="built_in">sizeof</span>(src_addr));</span><br><span class="line">    src_addr.nl_family = AF_NETLINK;</span><br><span class="line">    src_addr.nl_pid = <span class="number">100</span>; <span class="comment">//A：设置源端端口号</span></span><br><span class="line">    src_addr.nl_groups = <span class="number">0</span>;</span><br><span class="line">    <span class="comment">//Bind</span></span><br><span class="line">    retval = <span class="built_in">bind</span>(sock_fd, (<span class="keyword">struct</span> sockaddr*)&amp;src_addr, <span class="built_in">sizeof</span>(src_addr));</span><br><span class="line">    <span class="keyword">if</span>(retval &lt; <span class="number">0</span>)&#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;bind failed: %s&quot;</span>, <span class="built_in">strerror</span>(errno));</span><br><span class="line">        <span class="built_in">close</span>(sock_fd);</span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// To orepare create mssage</span></span><br><span class="line">    nlh = (<span class="keyword">struct</span> nlmsghdr *)<span class="built_in">malloc</span>(<span class="built_in">NLMSG_SPACE</span>(MAX_PAYLOAD));</span><br><span class="line">    <span class="keyword">if</span>(!nlh)&#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;malloc nlmsghdr error!\n&quot;</span>);</span><br><span class="line">        <span class="built_in">close</span>(sock_fd);</span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">&#125;</span><br><span class="line">    <span class="built_in">memset</span>(&amp;dest_addr,<span class="number">0</span>,<span class="built_in">sizeof</span>(dest_addr));</span><br><span class="line">    dest_addr.nl_family = AF_NETLINK;</span><br><span class="line">    dest_addr.nl_pid = <span class="number">0</span>; <span class="comment">//B：设置目的端口号</span></span><br><span class="line">    dest_addr.nl_groups = <span class="number">0</span>;</span><br><span class="line">    nlh-&gt;nlmsg_len = <span class="built_in">NLMSG_SPACE</span>(MAX_PAYLOAD);</span><br><span class="line">    nlh-&gt;nlmsg_pid = <span class="number">100</span>; <span class="comment">//C：设置源端口</span></span><br><span class="line">    nlh-&gt;nlmsg_flags = <span class="number">0</span>;</span><br><span class="line">    <span class="built_in">strcpy</span>(<span class="built_in">NLMSG_DATA</span>(nlh),<span class="string">&quot;Hello you!&quot;</span>); <span class="comment">//设置消息体</span></span><br><span class="line">    iov.iov_base = (<span class="type">void</span> *)nlh;</span><br><span class="line">    iov.iov_len = <span class="built_in">NLMSG_SPACE</span>(MAX_PAYLOAD);</span><br><span class="line">    <span class="comment">//Create mssage</span></span><br><span class="line">    <span class="built_in">memset</span>(&amp;msg, <span class="number">0</span>, <span class="built_in">sizeof</span>(msg));</span><br><span class="line">    msg.msg_name = (<span class="type">void</span> *)&amp;dest_addr;</span><br><span class="line">    msg.msg_namelen = <span class="built_in">sizeof</span>(dest_addr);</span><br><span class="line">    msg.msg_iov = &amp;iov;</span><br><span class="line">    msg.msg_iovlen = <span class="number">1</span>;</span><br><span class="line">    <span class="comment">//send message</span></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;state_smg\n&quot;</span>);</span><br><span class="line">    state_smg = <span class="built_in">sendmsg</span>(sock_fd,&amp;msg,<span class="number">0</span>);</span><br><span class="line">    <span class="keyword">if</span>(state_smg == <span class="number">-1</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;get error sendmsg = %s\n&quot;</span>,<span class="built_in">strerror</span>(errno));</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">memset</span>(nlh,<span class="number">0</span>,<span class="built_in">NLMSG_SPACE</span>(MAX_PAYLOAD));</span><br><span class="line">    <span class="comment">//receive message</span></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;waiting received!\n&quot;</span>);</span><br><span class="line">    <span class="keyword">while</span>(<span class="number">1</span>)&#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;In while recvmsg\n&quot;</span>);</span><br><span class="line">        state = <span class="built_in">recvmsg</span>(sock_fd, &amp;msg, <span class="number">0</span>);</span><br><span class="line">        <span class="keyword">if</span>(state&lt;<span class="number">0</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">&quot;state&lt;1&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;Received message: %s\n&quot;</span>,(<span class="type">char</span> *) <span class="built_in">NLMSG_DATA</span>(nlh));</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">close</span>(sock_fd);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>上面程序首先向内核发送一条消息；“Hello you”，然后进入循环一直等待读取内核的回复，并将收到的回复打印出来。如果看上面程序感觉很吃力，那么应该首先复习一下UDP中使用sendmsg的用法，特别时struct msghdr的结构要清楚，这里再赘述。</p>
<p><strong>下面主要分析与UDP发送数据包的不同点：</strong></p>
<ul>
<li>\1. socket地址结构不同，UDP为sockaddr_in，Netlink为struct sockaddr_nl；</li>
<li>\2. 与UDP发送数据相比，Netlink多了一个消息头结构struct nlmsghdr需要我们构造。</li>
</ul>
<p>注意代码注释中的A、B、C三处分别设置了pid。首先解释一下什么是pid，网上很多文章把这个字段说成是进程的pid，其实这完全是望文生义。这里的pid和进程pid没有什么关系，仅仅相当于UDP的port。对于UDP来说port和ip标示一个地址，那对我们的NETLINK_TEST协议（注意Netlink本身不是一个协议）来说，pid就唯一标示了一个地址。所以你如果用进程pid做为标示当然也是可以的。当然同样的pid对于NETLINK_TEST协议和内核定义的其他使用Netlink的协议是不冲突的（就像TCP的80端口和UDP的80端口）。</p>
<p>下面分析这三处设置pid分别有什么作用，首先A和B位置的比较好理解，这是在地址（sockaddr_nl）上进行的设置，就是相当于设置源地址和目的地址（其实是端口），只是注意B处设置pid为0，0就代表是内核，可以理解为内核专用的pid，那么用户进程就不能用0做为自己的pid吗？这个只能说如果你非要用也是可以的，只是会产生一些问题，后面在分析。</p>
<p>接下来看为什么C处的消息头仍然需要设置pid呢？这里首先要知道一个前提：内核不会像UDP一样根据我们设置的原、目的地址为我们构造消息头，所以我们不在包头写入我们自己的地址（pid），那内核怎么知道是谁发来的报文呢？当然如果内核只是处理消息不需要回复进程的话舍不设置这个消息头pid都可以。</p>
<p>所以每个pid的设置功能不同：A处的设置是要设置发送者的源地址，有人会说既然源地址又不会自动填充到报文中，我们为什么还要设置这个，因为你还可能要接收回复啊。就像寄信，你连“门牌号”都没有，即使你在写信时候写上你的地址是100号，对方回信目的地址也是100号，但是邮局发现根本没有这个地址怎么可能把信送到你手里呢？所以A的主要作用是注册源地址，保证可以收到回复，如果不需要回复当然可以简单将pid设置为0；B处自然就是收信人的地址，pid为0代表内核的地址，假如有一个进程在101号上注册了地址，并调用了recvmsg，如果你将B处的pid设置为101，那数据包就发给了另一个进程，这就实现了使用Netlink进行进程间通信；C相当于你在信封上写的源地址，通常情况下这个应该和你的真实地址（A）处注册的源地址相同，当然你要是不想收到回信，又想恶搞一下或者有特殊需求，你可以写成其他进程注册的pid（比如101）。这和我们现实中寄信是一样的，你给你朋友写封情书，把写信人写成你的另一个好基友，然后后果你懂得……</p>
<p>好了，有了这个例子我们就大概知道用户态怎么使用Netlink了。</p>
<h2 id="6、内核态程序"><a href="#6、内核态程序" class="headerlink" title="6、内核态程序"></a>6、内核态程序</h2><p>范例一</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;linux/init.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;linux/module.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;linux/timer.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;linux/time.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;linux/types.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;net/sock.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;net/netlink.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> NETLINK_TEST 25</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> MAX_MSGSIZE 1024</span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">stringlength</span><span class="params">(<span class="type">char</span> *s)</span></span>;</span><br><span class="line"><span class="type">int</span> err;</span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">sock</span> *nl_sk = <span class="literal">NULL</span>;</span><br><span class="line"><span class="type">int</span> flag = <span class="number">0</span>;</span><br><span class="line"><span class="comment">//向用户态进程回发消息</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">sendnlmsg</span><span class="params">(<span class="type">char</span> *message, <span class="type">int</span> pid)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">struct</span> <span class="title class_">sk_buff</span> *skb_1;</span><br><span class="line">    <span class="keyword">struct</span> <span class="title class_">nlmsghdr</span> *nlh;</span><br><span class="line">    <span class="type">int</span> len = <span class="built_in">NLMSG_SPACE</span>(MAX_MSGSIZE);</span><br><span class="line">    <span class="type">int</span> slen = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">if</span>(!message || !nl_sk)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">return</span> ;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">printk</span>(KERN_ERR <span class="string">&quot;pid:%d\n&quot;</span>,pid);</span><br><span class="line">    skb_1 = <span class="built_in">alloc_skb</span>(len,GFP_KERNEL);</span><br><span class="line">    <span class="keyword">if</span>(!skb_1)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">printk</span>(KERN_ERR <span class="string">&quot;my_net_link:alloc_skb error\n&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    slen = <span class="built_in">stringlength</span>(message);</span><br><span class="line">    nlh = <span class="built_in">nlmsg_put</span>(skb_1,<span class="number">0</span>,<span class="number">0</span>,<span class="number">0</span>,MAX_MSGSIZE,<span class="number">0</span>);</span><br><span class="line">    <span class="built_in">NETLINK_CB</span>(skb_1).pid = <span class="number">0</span>;</span><br><span class="line">    <span class="built_in">NETLINK_CB</span>(skb_1).dst_group = <span class="number">0</span>;</span><br><span class="line">    message[slen]= <span class="string">&#x27;\0&#x27;</span>;</span><br><span class="line">    <span class="built_in">memcpy</span>(<span class="built_in">NLMSG_DATA</span>(nlh),message,slen+<span class="number">1</span>);</span><br><span class="line">    <span class="built_in">printk</span>(<span class="string">&quot;my_net_link:send message &#x27;%s&#x27;.\n&quot;</span>,(<span class="type">char</span> *)<span class="built_in">NLMSG_DATA</span>(nlh));</span><br><span class="line">    <span class="built_in">netlink_unicast</span>(nl_sk,skb_1,pid,MSG_DONTWAIT);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">stringlength</span><span class="params">(<span class="type">char</span> *s)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">int</span> slen = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span>(; *s; s++)</span><br><span class="line">    &#123;</span><br><span class="line">        slen++;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> slen;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//接收用户态发来的消息</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">nl_data_ready</span><span class="params">(<span class="keyword">struct</span> sk_buff *__skb)</span></span></span><br><span class="line"><span class="function"> </span>&#123;</span><br><span class="line">     <span class="keyword">struct</span> <span class="title class_">sk_buff</span> *skb;</span><br><span class="line">     <span class="keyword">struct</span> <span class="title class_">nlmsghdr</span> *nlh;</span><br><span class="line">     <span class="type">char</span> str[<span class="number">100</span>];</span><br><span class="line">     <span class="keyword">struct</span> <span class="title class_">completion</span> cmpl;</span><br><span class="line">     <span class="built_in">printk</span>(<span class="string">&quot;begin data_ready\n&quot;</span>);</span><br><span class="line">     <span class="type">int</span> i=<span class="number">10</span>;</span><br><span class="line">     <span class="type">int</span> pid;</span><br><span class="line">     skb = <span class="built_in">skb_get</span> (__skb);</span><br><span class="line">     <span class="keyword">if</span>(skb-&gt;len &gt;= <span class="built_in">NLMSG_SPACE</span>(<span class="number">0</span>))</span><br><span class="line">     &#123;</span><br><span class="line">         nlh = <span class="built_in">nlmsg_hdr</span>(skb);</span><br><span class="line">         <span class="built_in">memcpy</span>(str, <span class="built_in">NLMSG_DATA</span>(nlh), <span class="built_in">sizeof</span>(str));</span><br><span class="line">         <span class="built_in">printk</span>(<span class="string">&quot;Message received:%s\n&quot;</span>,str) ;</span><br><span class="line">         pid = nlh-&gt;nlmsg_pid;</span><br><span class="line">         <span class="keyword">while</span>(i--)</span><br><span class="line">        &#123;<span class="comment">//我们使用completion做延时，每3秒钟向用户态回发一个消息</span></span><br><span class="line">            <span class="built_in">init_completion</span>(&amp;cmpl);</span><br><span class="line">            <span class="built_in">wait_for_completion_timeout</span>(&amp;cmpl,<span class="number">3</span> * HZ);</span><br><span class="line">            <span class="built_in">sendnlmsg</span>(<span class="string">&quot;I am from kernel!&quot;</span>,pid);</span><br><span class="line">        &#125;</span><br><span class="line">         flag = <span class="number">1</span>;</span><br><span class="line">         <span class="built_in">kfree_skb</span>(skb);</span><br><span class="line">    &#125;</span><br><span class="line"> &#125;</span><br><span class="line"><span class="comment">// Initialize netlink</span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">netlink_init</span><span class="params">(<span class="type">void</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    nl_sk = <span class="built_in">netlink_kernel_create</span>(&amp;init_net, NETLINK_TEST, <span class="number">1</span>,</span><br><span class="line">                                 nl_data_ready, <span class="literal">NULL</span>, THIS_MODULE);</span><br><span class="line">    <span class="keyword">if</span>(!nl_sk)&#123;</span><br><span class="line">        <span class="built_in">printk</span>(KERN_ERR <span class="string">&quot;my_net_link: create netlink socket error.\n&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">printk</span>(<span class="string">&quot;my_net_link_4: create netlink socket ok.\n&quot;</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">static</span> <span class="type">void</span> <span class="title">netlink_exit</span><span class="params">(<span class="type">void</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(nl_sk != <span class="literal">NULL</span>)&#123;</span><br><span class="line">        <span class="built_in">sock_release</span>(nl_sk-&gt;sk_socket);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">printk</span>(<span class="string">&quot;my_net_link: self module exited\n&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">module_init</span>(netlink_init);</span><br><span class="line"><span class="built_in">module_exit</span>(netlink_exit);</span><br><span class="line"><span class="built_in">MODULE_AUTHOR</span>(<span class="string">&quot;zhao_h&quot;</span>);</span><br><span class="line"><span class="built_in">MODULE_LICENSE</span>(<span class="string">&quot;GPL&quot;</span>);</span><br></pre></td></tr></table></figure>

<p>附上内核代码的Makefile文件：</p>
<figure class="highlight text"><table><tr><td class="code"><pre><span class="line">ifneq ($(KERNELRELEASE),)</span><br><span class="line">obj-m :=netl.o</span><br><span class="line">else</span><br><span class="line">KERNELDIR ?=/lib/modules/$(shell uname -r)/build</span><br><span class="line">PWD :=$(shell pwd)</span><br><span class="line">default:</span><br><span class="line">$(MAKE) -C $(KERNELDIR) M=$(PWD) modules</span><br><span class="line">endif</span><br></pre></td></tr></table></figure>

<p>我们将内核模块insmod后，运行用户态程序，结果如下：</p>
<p><img src="https://pic4.zhimg.com/80/v2-6437cb1fc76f77b7a302356ce2003603_720w.webp" alt="img"></p>
<p>这个结果复合我们的预期，但是运行过程中打印出“state_smg”卡了好久才输出了后面的结果。这时候查看客户进程是处于D状态的（不了解D状态的同学可以google一下）。这是为什么呢？因为进程使用Netlink向内核发数据是同步，内核向进程发数据是异步。什么意思呢？也就是用户进程调用sendmsg发送消息后，内核会调用相应的接收函数，但是一定到这个接收函数执行完用户态的sendmsg才能够返回。我们在内核态的接收函数中调用了10次回发函数，每次都等待3秒钟，所以内核接收函数30秒后才返回，所以我们用户态程序的sendmsg也要等30秒后才返回。相反，内核回发的数据不用等待用户程序接收，这是因为内核所发的数据会暂时存放在一个队列中。</p>
<p>再来回到之前的一个问题，用户态程序的源地址（pid）可以用0吗？我把上面的用户程序的A和C处pid都改为了0，结果一运行就死机了。为什么呢？我们看一下内核代码的逻辑，收到用户消息后，根据消息中的pid发送回去，而pid为0，内核并不认为这是用户程序，认为是自身，所有又将回发的10个消息发给了自己（内核），这样就陷入了一个死循环，而用户态这时候进程一直处于D。</p>
<p>另外一个问题，如果同时启动两个用户进程会是什么情况？答案是再调用bind时出错：“Address already in use”，这个同UDP一样，同一个地址同一个port如果没有设置SO_REUSEADDR两次bind就会出错，之后我用同样的方式再Netlink的socket上设置了SO_REUSEADDR，但是并没有什么效果。</p>
<h2 id="7、用户态"><a href="#7、用户态" class="headerlink" title="7、用户态"></a>7、用户态</h2><p><strong>范例二</strong></p>
<p>之前我们说过UDP可以使用sendmsg／recvmsg也可以使用sendto／recvfrom，那么Netlink同样也可以使用sendto／recvfrom。<strong>具体实现如下：</strong></p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/stat.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/socket.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/types.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;asm/types.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;linux/netlink.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;linux/socket.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;errno.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> MAX_PAYLOAD 1024 <span class="comment">// maximum payload size</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> NETLINK_TEST 25</span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">(<span class="type">int</span> argc, <span class="type">char</span>* argv[])</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">struct</span> <span class="title class_">sockaddr_nl</span> src_addr, dest_addr;</span><br><span class="line">    <span class="keyword">struct</span> <span class="title class_">nlmsghdr</span> *nlh = <span class="literal">NULL</span>;</span><br><span class="line">    <span class="type">int</span> sock_fd, retval;</span><br><span class="line">    <span class="type">int</span> state,state_smg = <span class="number">0</span>;</span><br><span class="line">    <span class="comment">// Create a socket</span></span><br><span class="line">    sock_fd = <span class="built_in">socket</span>(AF_NETLINK, SOCK_RAW, NETLINK_TEST);</span><br><span class="line">    <span class="keyword">if</span>(sock_fd == <span class="number">-1</span>)&#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;error getting socket: %s&quot;</span>, <span class="built_in">strerror</span>(errno));</span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// To prepare binding</span></span><br><span class="line">    <span class="built_in">memset</span>(&amp;src_addr, <span class="number">0</span>, <span class="built_in">sizeof</span>(src_addr));</span><br><span class="line">    src_addr.nl_family = AF_NETLINK;</span><br><span class="line">    src_addr.nl_pid = <span class="number">100</span>;</span><br><span class="line">    src_addr.nl_groups = <span class="number">0</span>;</span><br><span class="line">    <span class="comment">//Bind</span></span><br><span class="line">    retval = <span class="built_in">bind</span>(sock_fd, (<span class="keyword">struct</span> sockaddr*)&amp;src_addr, <span class="built_in">sizeof</span>(src_addr));</span><br><span class="line">    <span class="keyword">if</span>(retval &lt; <span class="number">0</span>)&#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;bind failed: %s&quot;</span>, <span class="built_in">strerror</span>(errno));</span><br><span class="line">        <span class="built_in">close</span>(sock_fd);</span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// To orepare create mssage head</span></span><br><span class="line">    nlh = (<span class="keyword">struct</span> nlmsghdr *)<span class="built_in">malloc</span>(<span class="built_in">NLMSG_SPACE</span>(MAX_PAYLOAD));</span><br><span class="line">    <span class="keyword">if</span>(!nlh)&#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;malloc nlmsghdr error!\n&quot;</span>);</span><br><span class="line">        <span class="built_in">close</span>(sock_fd);</span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">memset</span>(&amp;dest_addr,<span class="number">0</span>,<span class="built_in">sizeof</span>(dest_addr));</span><br><span class="line">    dest_addr.nl_family = AF_NETLINK;</span><br><span class="line">    dest_addr.nl_pid = <span class="number">0</span>;</span><br><span class="line">    dest_addr.nl_groups = <span class="number">0</span>;</span><br><span class="line">    nlh-&gt;nlmsg_len = <span class="built_in">NLMSG_SPACE</span>(MAX_PAYLOAD);</span><br><span class="line">    nlh-&gt;nlmsg_pid = <span class="number">100</span>;</span><br><span class="line">    nlh-&gt;nlmsg_flags = <span class="number">0</span>;</span><br><span class="line">    <span class="built_in">strcpy</span>(<span class="built_in">NLMSG_DATA</span>(nlh),<span class="string">&quot;Hello you!&quot;</span>);</span><br><span class="line">    <span class="comment">//send message</span></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;state_smg\n&quot;</span>);</span><br><span class="line">    <span class="built_in">sendto</span>(sock_fd,nlh,<span class="built_in">NLMSG_LENGTH</span>(MAX_PAYLOAD),<span class="number">0</span>,(<span class="keyword">struct</span> sockaddr*)(&amp;dest_addr),<span class="built_in">sizeof</span>(dest_addr));</span><br><span class="line">    <span class="keyword">if</span>(state_smg == <span class="number">-1</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;get error sendmsg = %s\n&quot;</span>,<span class="built_in">strerror</span>(errno));</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">memset</span>(nlh,<span class="number">0</span>,<span class="built_in">NLMSG_SPACE</span>(MAX_PAYLOAD));</span><br><span class="line">    <span class="comment">//receive message</span></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;waiting received!\n&quot;</span>);</span><br><span class="line"><span class="keyword">while</span>(<span class="number">1</span>)&#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;In while recvmsg\n&quot;</span>);</span><br><span class="line">state=<span class="built_in">recvfrom</span>(sock_fd,nlh,<span class="built_in">NLMSG_LENGTH</span>(MAX_PAYLOAD),<span class="number">0</span>,<span class="literal">NULL</span>,<span class="literal">NULL</span>);</span><br><span class="line">        <span class="keyword">if</span>(state&lt;<span class="number">0</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">&quot;state&lt;1&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;Received message: %s\n&quot;</span>,(<span class="type">char</span> *) <span class="built_in">NLMSG_DATA</span>(nlh));</span><br><span class="line">        <span class="built_in">memset</span>(nlh,<span class="number">0</span>,<span class="built_in">NLMSG_SPACE</span>(MAX_PAYLOAD));</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">close</span>(sock_fd);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>熟悉UDP编程的同学看到这个程序一定很熟悉，除了多了一个Netlink消息头的设置。但是我们发现程序中调用了bind函数，这个函数再UDP编程中的客户端不是必须的，因为我们不需要把UDP socket与某个地址关联，同时再发送UDP数据包时内核会为我们分配一个随即的端口。但是对于Netlink必须要有这一步bind，因为Netlink内核可不会为我们分配一个pid。再强调一遍消息头（nlmsghdr）中的pid是告诉内核接收端要回复的地址，但是这个地址存不存在内核并不关心，这个地址只有用户端调用了bind后才存在。</p>
<p>我们看到这两个例子都是用户态首先发起的，那Netlink是否支持内核态主动发起的情况呢？</p>
<p>当然是可以的，只是内核一般需要事件触发，这里，只要和用户态约定号一个地址（pid），内核直接调用netlink_unicast就可以了。</p>
<hr>
<p>版权声明：本文为知乎博主「玩转Linux内核」的原创文章，遵循CC 4.0 BY-SA版权协议，转载请附上原文出处链接及本声明。<br>原文链接：<a href="https://zhuanlan.zhihu.com/p/458996875">https://zhuanlan.zhihu.com/p/458996875</a></p>
]]></content>
      <categories>
        <category>linux-doc</category>
      </categories>
      <tags>
        <tag>Linux</tag>
      </tags>
  </entry>
  <entry>
    <title>QEMU调试Linux内核环境搭建</title>
    <url>/2023/01/15/linux-docs/QEMU%E8%B0%83%E8%AF%95Linux%E5%86%85%E6%A0%B8%E7%8E%AF%E5%A2%83%E6%90%AD%E5%BB%BA/</url>
    <content><![CDATA[<p>一个最小可运行Linux操作系统需要内核镜像bzImage和rootfs，本文整理了其制作、安装过程，调试命令，以及如何添加共享磁盘。</p>
<h2 id="1、编译内核源码"><a href="#1、编译内核源码" class="headerlink" title="1、编译内核源码"></a>1、编译内核源码</h2><p>从 The Linux Kernel Archives 网站下载内核源码，本文下载的版本为4.14.191，4.14.191源码下载。</p>
<p>使用wget获取源码。</p>
<blockquote>
<p>wget <a href="https://link.zhihu.com/?target=https://mirrors.edge.kernel.org/pub/linux/kernel/v4.x/linux-4.14.191.tar.gz">https://mirrors.edge.kernel.org/pub/linux/kernel/v4.x/linux-4.14.191.tar.gz</a></p>
</blockquote>
<p>解压源码：</p>
<blockquote>
<p>tar -xvf linux-4.14.191.tar.gz</p>
</blockquote>
<p>解压后进入源码根目录linux-4.14.191，指定编译的架构，依次执行下面的命令，打开配置菜单。</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="number">1</span>cd linux<span class="number">-4.14</span><span class="number">.191</span></span><br><span class="line"><span class="number">2</span></span><br><span class="line"><span class="number">3</span><span class="keyword">export</span> ARCH=x86</span><br><span class="line"><span class="number">4</span></span><br><span class="line"><span class="number">5</span>make x86_64_defconfig</span><br><span class="line"><span class="number">6</span></span><br><span class="line"><span class="number">7</span>make menuconfig</span><br></pre></td></tr></table></figure>

<p>在配置菜单中，启用内核debug，关闭地址随机化，不然断点处无法停止。</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="number">1</span>Kernel hacking  ---&gt; </span><br><span class="line"><span class="number">2</span>    [*] Kernel debugging</span><br><span class="line"><span class="number">3</span>    Compile-time checks <span class="keyword">and</span> compiler options  ---&gt;</span><br><span class="line"><span class="number">4</span>        [*] Compile the kernel with debug info</span><br><span class="line"><span class="number">5</span>        [*]   Provide GDB scripts <span class="keyword">for</span> kernel debuggin</span><br><span class="line"><span class="number">6</span></span><br><span class="line"><span class="number">7</span></span><br><span class="line"><span class="number">8</span>Processor type <span class="keyword">and</span> features ----&gt;</span><br><span class="line"><span class="number">9</span>    [] <span class="function">Randomize the address of the kernel <span class="title">image</span> <span class="params">(KASLR)</span></span></span><br></pre></td></tr></table></figure>

<p>开始编译内核，-j 指定并行编译作业数。最终生成<br>linux-4.14.191&#x2F;arch&#x2F;x86_64&#x2F;boot&#x2F;bzImage文件。</p>
<figure class="highlight text"><table><tr><td class="code"><pre><span class="line">1make -j 20</span><br></pre></td></tr></table></figure>

<p>内核编译完成。</p>
<h2 id="2、配置Busybox"><a href="#2、配置Busybox" class="headerlink" title="2、配置Busybox"></a>2、配置Busybox</h2><p>启动内核还需要一个具有根文件系统的磁盘镜像文件，根文件系统中提供可供交互的shell程序以及一些常用工具命令。</p>
<p>我们借助busybox工具来制作根文件系统。</p>
<p>本文使用1.32.0版本，下载busybox。</p>
<p>解压：</p>
<blockquote>
<p>tar -jxvf busybox-1.32.0.tar.bz2</p>
</blockquote>
<p>进入busybox根目录，配置编译选项。</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="number">1</span>cd busybox<span class="number">-1.32</span><span class="number">.0</span></span><br><span class="line"><span class="number">2</span>make menuconfig</span><br></pre></td></tr></table></figure>

<p>把busybox配置为静态编译。</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="number">1</span> Settings  ---&gt;</span><br><span class="line"><span class="number">2</span> [*] <span class="function">Build BusyBox as a <span class="type">static</span> <span class="title">binary</span> <span class="params">(no shared libs)</span></span></span><br></pre></td></tr></table></figure>

<p>配置如下图所示。</p>
<p><img src="https://pic3.zhimg.com/80/v2-e0d428c6416d550ea8a9a63f312829f2_720w.webp" alt="img"></p>
<h2 id="3、制作rootfs"><a href="#3、制作rootfs" class="headerlink" title="3、制作rootfs"></a>3、制作rootfs</h2><p>接下来制作rootfs镜像文件，并把busybox安装到其中。</p>
<p>使用dd命令创建文件，并格式化为ext4文件系统。</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="number">1</span>szp@r420-PowerEdge-R420:~/busybox<span class="number">-1.32</span><span class="number">.0</span>$ dd <span class="keyword">if</span>=/dev/zero of=rootfs.img bs=<span class="number">1</span>M count=<span class="number">10</span></span><br><span class="line"><span class="number">2</span></span><br><span class="line"><span class="number">3</span>szp@r420-PowerEdge-R420:~/busybox<span class="number">-1.32</span><span class="number">.0</span>$ mkfs.ext4 rootfs.img</span><br></pre></td></tr></table></figure>

<p>创建用于挂载该镜像文件的目录fs，挂载后才能往里面写入busybox。<br>使用mount命令将rootfs.img挂载到fs目录，编译busybox并写入fs目录中。</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="number">1</span>szp@r420-PowerEdge-R420:~$ mkdir fs</span><br><span class="line"><span class="number">2</span></span><br><span class="line"><span class="number">3</span>szp@r420-PowerEdge-R420:~/busybox<span class="number">-1.32</span><span class="number">.0</span>$ sudo mount -t ext4 -o loop rootfs.img ./fs</span><br><span class="line"><span class="number">4</span></span><br><span class="line"><span class="number">5</span>szp@r420-PowerEdge-R420:~/busybox<span class="number">-1.32</span><span class="number">.0</span>$ sudo make install CONFIG_PREFIX=./fs</span><br></pre></td></tr></table></figure>

<p>接下来对写入的busybox进行补充配置。</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="number">1</span>szp@r420-PowerEdge-R420:~/busybox<span class="number">-1.32</span><span class="number">.0</span>/fs$ sudo mkdir proc dev etc home mnt</span><br><span class="line"><span class="number">2</span></span><br><span class="line"><span class="number">3</span>szp@r420-PowerEdge-R420:~/busybox<span class="number">-1.32</span><span class="number">.0</span>/fs$ sudo cp -r ../examples/bootfloppy/etc<span class="comment">/* etc/</span></span><br><span class="line"><span class="comment">4</span></span><br><span class="line"><span class="comment">5szp@r420-PowerEdge-R420:~/busybox-1.32.0$ sudo chmod -R 777 fs/</span></span><br></pre></td></tr></table></figure>

<p>制作完成的rootfs目录如下：</p>
<p><img src="https://pic1.zhimg.com/80/v2-1ba6139f5be23b5ff1fa7dff3127a1b4_720w.webp" alt="img"></p>
<p>最后，卸载rootfs.img</p>
<figure class="highlight text"><table><tr><td class="code"><pre><span class="line">1szp@r420-PowerEdge-R420:~/busybox-1.32.0$ sudo umount fs</span><br></pre></td></tr></table></figure>

<p>至此，一个带有rootfs的磁盘镜像制作完成。</p>
<h2 id="4、启动qemu"><a href="#4、启动qemu" class="headerlink" title="4、启动qemu"></a>4、启动qemu</h2><p>使用如下命令启动无GUI的qemu，参数含义如下：</p>
<blockquote>
<p>-kernel # 指定编译好的内核镜像<br>-hda # 指定硬盘<br>-append “root&#x3D;&#x2F;dev&#x2F;sda” 指示根文件系统 console&#x3D;ttyS0 把QEMU的输入输出定向到当前终端上<br>-nographic 不使用图形输出窗口<br>-s 是-gdb tcp::1234缩写，监听1234端口，在GDB中可以通过target remote localhost:1234连接</p>
</blockquote>
<figure class="highlight text"><table><tr><td class="code"><pre><span class="line">1qemu-system-x86_64 -kernel ./linux-4.14.191/arch/x86_64/boot/bzImage  -hda ./busybox-1.32.0/rootfs.img  -append &quot;root=/dev/sda console=ttyS0&quot; -nographic</span><br></pre></td></tr></table></figure>

<p>启动后如下图：</p>
<p><img src="https://pic1.zhimg.com/80/v2-a1ac8883734a813038ac49d0d63df87c_720w.webp" alt="img"></p>
<p>Ctrl+A 松开后按C退出qemu。</p>
<h2 id="5、内核函数调试"><a href="#5、内核函数调试" class="headerlink" title="5、内核函数调试"></a>5、内核函数调试</h2><p>启动命令中添加-s参数与-S参数启动qemu。</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="number">1</span>szp@r420-PowerEdge-R420:~$ qemu-system-x86_64 -kernel ~/linux<span class="number">-4.14</span><span class="number">.191</span>/arch/x86_64/boot/bzImage  -hda ~/busybox<span class="number">-1.32</span><span class="number">.0</span>/rootfs.img  -append <span class="string">&quot;root=/dev/sda console=ttyS0&quot;</span> -s -S  -smp <span class="number">1</span> -nographic</span><br></pre></td></tr></table></figure>

<p>启动gdb远程调试。vmlinux文件在编译后的内核源码根目录下。</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="number">1</span>szp@r420-PowerEdge-R420:~$ gdb ./linux<span class="number">-4.14</span><span class="number">.191</span>/vmlinux </span><br><span class="line"><span class="number">2</span></span><br><span class="line"><span class="number">3</span>(gdb) target remote localhost:<span class="number">1234</span></span><br></pre></td></tr></table></figure>

<p>在new_sync_read函数添加断点，continue。</p>
<p><img src="https://pic3.zhimg.com/80/v2-9f2418155c69bb0e89d153dbbef6b182_720w.webp" alt="img"></p>
<p>在系统中执行ls命令，触发new_sync_read函数，</p>
<p><img src="https://pic4.zhimg.com/80/v2-36b0951bcc8ec68e8177fddc2e5e9637_720w.webp" alt="img"></p>
<p><img src="https://pic3.zhimg.com/80/v2-dd247f3ca0bfb7363441dec1457aa9ae_720w.webp" alt="img"></p>
<p>至此，完成了qemu环境下使用gdb进行内核函数的调试。</p>
<h2 id="6、添加共享磁盘"><a href="#6、添加共享磁盘" class="headerlink" title="6、添加共享磁盘"></a>6、添加共享磁盘</h2><p>有时候需要在宿主机和qemu虚拟机之间共享文件，添加一个共享磁盘将有助于该项工作。</p>
<p>创建64MB磁盘镜像文件，并格式化为ext4，作为共享磁盘备用。</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="number">1</span>szp@r420-PowerEdge-R420:~/shadisk$ dd <span class="keyword">if</span>=/dev/zero of=ext4.img bs=<span class="number">512</span> count=<span class="number">131072</span></span><br><span class="line"><span class="number">2</span></span><br><span class="line"><span class="number">3</span>szp@r420-PowerEdge-R420:~/shadisk$ mkfs.ext4 ext4.img</span><br></pre></td></tr></table></figure>

<p>修改qemu启动命令，使用-hdb增加一个磁盘。</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="number">1</span>qemu-system-x86_64 -kernel ~/linux<span class="number">-4.14</span><span class="number">.191</span>/arch/x86_64/boot/bzImage  -hda ~/busybox<span class="number">-1.32</span><span class="number">.0</span>/rootfs.img  -append <span class="string">&quot;root=/dev/sda console=ttyS0&quot;</span> -s  -smp <span class="number">1</span> -nographic -hdb ~/shadisk/ext4.img</span><br></pre></td></tr></table></figure>

<p>进入qemu系统后使用mount命令挂载sdb到mnt目录。</p>
<p><img src="https://pic2.zhimg.com/80/v2-75de138afb8ed66bfae152adae30f499_720w.webp" alt="img"></p>
<p>在原系统中挂载ext4.img，实现qemu与原系统的文件共享。</p>
<figure class="highlight text"><table><tr><td class="code"><pre><span class="line">1szp@r420-PowerEdge-R420:~/shadisk$ sudo mount -t ext4 -o loop ext4.img ./share</span><br></pre></td></tr></table></figure>

<p><img src="https://pic1.zhimg.com/80/v2-6f41a473063998d324e96b784c3dec98_720w.webp" alt="img"></p>
<p>至此，可以在宿主机器share目录下，与qemu中的虚拟机器进行文件共享。</p>
<hr>
<p>版权声明：本文为知乎博主「玩转Linux内核」的原创文章，遵循CC 4.0 BY-SA版权协议，转载请附上原文出处链接及本声明。<br>原文链接：<a href="https://zhuanlan.zhihu.com/p/499637419">https://zhuanlan.zhihu.com/p/499637419</a></p>
]]></content>
      <categories>
        <category>linux-doc</category>
      </categories>
      <tags>
        <tag>Linux</tag>
      </tags>
  </entry>
  <entry>
    <title>任务空间管理</title>
    <url>/2023/01/15/linux-docs/%E4%BB%BB%E5%8A%A1%E7%A9%BA%E9%97%B4%E7%AE%A1%E7%90%86/</url>
    <content><![CDATA[<h2 id="一-前言"><a href="#一-前言" class="headerlink" title="一. 前言"></a>一. 前言</h2><p>  从本文开始，我们进入内存部分的学习。首先会接着前面的任务task_struct讲解任务空间管理结构体mm_struct，并简单介绍物理内存和虚拟内存的相关知识，关于详细的基础知识和概念可以参照CSAPP一书，这里不会做过多的赘述，而是默认在已了解其映射关系的基础上进行的学习。在后文中，会继续介绍物理内存的管理以及用户态和内核态的内存映射。</p>
<h2 id="二-基本概念梳理"><a href="#二-基本概念梳理" class="headerlink" title="二. 基本概念梳理"></a>二. 基本概念梳理</h2><ul>
<li>CPU、缓存、内存、主存的架构是源于越快的设备越贵，因此出于节约（qiong)考虑设计了多层架构，CPU中有了MMU</li>
<li>物理内存有限，多进程共享物理内存存在安全问题，因此出现了虚拟内存的设计</li>
<li>虚拟内存根据ELF的结构进行了相应的设计，存在堆、映射区、栈、数据段等部分</li>
<li>考虑到虚拟内存的结构，出现了堆的申请即动态内存</li>
<li>虚拟内存为每个进程分配单独的地址空间，映射到物理内存上执行，因此有了物理内存和虚拟内存的映射方法：页</li>
<li>为了管理虚拟内存，出现了页表和多级页表</li>
<li>为了加速映射，出现了CPU中的TLB</li>
<li>为了满足共享的需求，出现了内存映射中的共享内存</li>
<li>由于内存碎片的存在，出现了碎片管理的设计以及垃圾回收器</li>
</ul>
<h2 id="三-进程内存管理"><a href="#三-进程内存管理" class="headerlink" title="三. 进程内存管理"></a>三. 进程内存管理</h2><p>  <br>  对于一个进程来说，需要考虑用户态和内核态两部分需要存储在内核内的各个结构</p>
<p>  用户态包括</p>
<ul>
<li>代码段</li>
<li>全局变量</li>
<li>常量字符串</li>
<li>函数栈，包括函数调用，局部变量，函数参数等</li>
<li>堆：malloc 分配的内存等</li>
<li>内存映射，如 glibc 的调用， glibc 的代码是以 so 文件的形式存在的，也需要放在内存里面。</li>
</ul>
<p>  内核态包括</p>
<ul>
<li>内核部分的代码</li>
<li>内核中全局变量</li>
<li>task_struct</li>
<li>内核栈</li>
<li>在内核里面也有动态分配的内存</li>
<li>虚拟地址到物理地址的映射表</li>
</ul>
<p>  进程在内核态中通过task_struct管理，而task_struct中关于内存有如下成员变量</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">mm_struct</span>		*<span class="title">mm</span>;</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">mm_struct</span>		*<span class="title">active_mm</span>;</span></span><br><span class="line"><span class="comment">/* Per-thread vma caching: */</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">vmacache</span>			<span class="title">vmacache</span>;</span></span><br></pre></td></tr></table></figure>
<p>  其中mm_struct结构体也较为复杂，我们将分步介绍。首先我们来看看内核态和用户态的地址划分。这里highest_vm_end存储当前虚拟内存地址的最大地址，而task_size则是用户态的大小。</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">mm_struct</span> &#123;</span></span><br><span class="line">......</span><br><span class="line">    <span class="type">unsigned</span> <span class="type">long</span> task_size;	<span class="comment">/* size of task vm space */</span></span><br><span class="line">    <span class="type">unsigned</span> <span class="type">long</span> highest_vm_end;	<span class="comment">/* highest vma end address */</span></span><br><span class="line">......</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>  task_size定义如下，从注释可见用户态分配了4G虚拟内存中的3G空间，而64位因为空间巨大因此在内核态和用户态中间还保留了空闲区域进行隔离，用户态仅使用47位，即128TB。内核态同样分配128TB，位于最高位。</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">ifdef</span> CONFIG_X86_32</span></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * User space process size: 3GB (default).</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> TASK_SIZE    PAGE_OFFSET</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> TASK_SIZE_MAX    TASK_SIZE</span></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">config PAGE_OFFSET</span></span><br><span class="line"><span class="comment">        hex</span></span><br><span class="line"><span class="comment">        default 0xC0000000</span></span><br><span class="line"><span class="comment">        depends on X86_32</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="meta">#<span class="keyword">else</span></span></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * User space process size. 47bits minus one guard page.</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> TASK_SIZE_MAX  ((1UL &lt;&lt; 47) - PAGE_SIZE)</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> TASK_SIZE    (test_thread_flag(TIF_ADDR32) ? \</span></span><br><span class="line"><span class="meta">          IA32_PAGE_OFFSET : TASK_SIZE_MAX)</span></span><br><span class="line">......</span><br></pre></td></tr></table></figure>
<h3 id="3-1-用户态内存结构"><a href="#3-1-用户态内存结构" class="headerlink" title="3.1 用户态内存结构"></a>3.1 用户态内存结构</h3><p>  在用户态，mm_struct有着以下成员变量</p>
<ul>
<li>mmap_base：内存映射的起始地址</li>
<li>mmap_legacy_base：表示映射的基址，在32位中为固定的TASK_UNMAPPED_BASE，而在64位中，存在一个虚拟地址随机映射机制，因此为TASK_UNMAPPED_BASE + mmap_rnd()</li>
<li>hiwater_rss：RSS的高水位使用情况</li>
<li>hiwater_vm：高水位虚拟内存使用情况</li>
<li>total_vm：映射的总页数</li>
<li>locked_vm：被锁定不能换出的页数</li>
<li>pinned_vm：不能换出也不能移动的页数</li>
<li>data_vm：存放数据的页数</li>
<li>exec_vm：存放可执行文件的页数</li>
<li>stack_vm：存放栈的页数</li>
<li>arg_lock：引入spin_lock用于保护对下面区域变量们的并行访问</li>
<li>start_code 和 end_code： 可执行代码的开始和结束位置</li>
<li>start_data 和 end_data ：已初始化数据的开始位置和结束位置</li>
<li>start_brk ：堆的起始位置</li>
<li>brk ：堆当前的结束位置</li>
<li>start_stack ：栈的起始位置，栈的结束位置在寄存器的栈顶指针中</li>
<li>arg_start 和 arg_end ：参数列表的位置，位于栈中最高地址的地方。</li>
<li>env_start 和 env_end ：环境变量的位置，位于栈中最高地址的地方。</li>
</ul>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">mm_struct</span> &#123;</span></span><br><span class="line">......    </span><br><span class="line">    <span class="type">unsigned</span> <span class="type">long</span> mmap_base;	<span class="comment">/* base of mmap area */</span></span><br><span class="line">    <span class="type">unsigned</span> <span class="type">long</span> mmap_legacy_base;	<span class="comment">/* base of mmap area in bottom-up allocations */</span>    </span><br><span class="line">......</span><br><span class="line">    <span class="type">unsigned</span> <span class="type">long</span> hiwater_rss; <span class="comment">/* High-watermark of RSS usage */</span></span><br><span class="line">    <span class="type">unsigned</span> <span class="type">long</span> hiwater_vm;  <span class="comment">/* High-water virtual memory usage */</span></span><br><span class="line">    <span class="type">unsigned</span> <span class="type">long</span> total_vm;	   <span class="comment">/* Total pages mapped */</span></span><br><span class="line">    <span class="type">unsigned</span> <span class="type">long</span> locked_vm;   <span class="comment">/* Pages that have PG_mlocked set */</span></span><br><span class="line">    <span class="type">atomic64_t</span>    pinned_vm;   <span class="comment">/* Refcount permanently increased */</span></span><br><span class="line">    <span class="type">unsigned</span> <span class="type">long</span> data_vm;	   <span class="comment">/* VM_WRITE &amp; ~VM_SHARED &amp; ~VM_STACK */</span></span><br><span class="line">    <span class="type">unsigned</span> <span class="type">long</span> exec_vm;	   <span class="comment">/* VM_EXEC &amp; ~VM_WRITE &amp; ~VM_STACK */</span></span><br><span class="line">    <span class="type">unsigned</span> <span class="type">long</span> stack_vm;	   <span class="comment">/* VM_STACK */</span>    </span><br><span class="line">    <span class="type">spinlock_t</span> arg_lock; <span class="comment">/* protect the below fields */</span></span><br><span class="line">    <span class="type">unsigned</span> <span class="type">long</span> start_code, end_code, start_data, end_data;</span><br><span class="line">    <span class="type">unsigned</span> <span class="type">long</span> start_brk, brk, start_stack;</span><br><span class="line">    <span class="type">unsigned</span> <span class="type">long</span> arg_start, arg_end, env_start, env_end;</span><br><span class="line">    <span class="type">unsigned</span> <span class="type">long</span> saved_auxv[AT_VECTOR_SIZE]; <span class="comment">/* for /proc/PID/auxv */</span>    </span><br><span class="line">......</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>  根据这些成员变量，我们可以规划出用户态中各个部分的位置，但是我们还需要一个结构体描述这些区域的属性，即vm_area_struct</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">mm_struct</span> &#123;</span></span><br><span class="line">......    </span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">vm_area_struct</span> *<span class="title">mmap</span>;</span>		<span class="comment">/* list of VMAs */</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">rb_root</span> <span class="title">mm_rb</span>;</span>  </span><br><span class="line">......    </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>  vm_area_struct的具体结构体定义如下所示，实际是通过vm_next和vm_prev组合而成的双向链表，即通过一系列的vm_area_struct来表述一个进程在用户态分配的各个区域的内容。</p>
<ul>
<li>vm_start和vm_end表述该块区域的开始和结束为止</li>
<li>vm_rb对应一颗红黑树，这颗红黑树将所有vm_area_struct组合起来，便于增删查找。</li>
<li>rb_subtree_gap存储当前区域和上个区域之间的间隔，用于后续分配使用。</li>
<li>vm_mm指向该结构体所属的vm_struct</li>
<li>vm_page_prot管理该页的接入权限，vm_flags为标记位</li>
<li>rb和rb_subtree_last：有空余位置的区间树结构</li>
<li>ano_vma 和 ano_vma_chain：匿名映射。虚拟内存区域可以映射到物理内存，也可以映射到文件，映射到物理内存的时候称为匿名映射，映射到文件需要vm_file指定被映射文件，vm_pgoff存储偏移量。</li>
<li>vm_opts：指向该结构体的函数指针，用于处理该结构体</li>
<li>vm_private_data：私有数据存储</li>
</ul>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * This struct defines a memory VMM memory area. There is one of these</span></span><br><span class="line"><span class="comment"> * per VM-area/task.  A VM area is any part of the process virtual memory</span></span><br><span class="line"><span class="comment"> * space that has a special rule for the page-fault handlers (ie a shared</span></span><br><span class="line"><span class="comment"> * library, the executable area etc).</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">vm_area_struct</span> &#123;</span></span><br><span class="line">    <span class="comment">/* The first cache line has the info for VMA tree walking. */</span></span><br><span class="line">    <span class="type">unsigned</span> <span class="type">long</span> vm_start;		<span class="comment">/* Our start address within vm_mm. */</span></span><br><span class="line">    <span class="type">unsigned</span> <span class="type">long</span> vm_end;		<span class="comment">/* The first byte after our end address</span></span><br><span class="line"><span class="comment">                       within vm_mm. */</span></span><br><span class="line">    <span class="comment">/* linked list of VM areas per task, sorted by address */</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">vm_area_struct</span> *<span class="title">vm_next</span>, *<span class="title">vm_prev</span>;</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">rb_node</span> <span class="title">vm_rb</span>;</span></span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">     * Largest free memory gap in bytes to the left of this VMA.</span></span><br><span class="line"><span class="comment">     * Either between this VMA and vma-&gt;vm_prev, or between one of the</span></span><br><span class="line"><span class="comment">     * VMAs below us in the VMA rbtree and its -&gt;vm_prev. This helps</span></span><br><span class="line"><span class="comment">     * get_unmapped_area find a free area of the right size.</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="type">unsigned</span> <span class="type">long</span> rb_subtree_gap;</span><br><span class="line">    <span class="comment">/* Second cache line starts here. */</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">mm_struct</span> *<span class="title">vm_mm</span>;</span>	<span class="comment">/* The address space we belong to. */</span></span><br><span class="line">    <span class="type">pgprot_t</span> vm_page_prot;		<span class="comment">/* Access permissions of this VMA. */</span></span><br><span class="line">    <span class="type">unsigned</span> <span class="type">long</span> vm_flags;		<span class="comment">/* Flags, see mm.h. */</span></span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">     * For areas with an address space and backing store,</span></span><br><span class="line"><span class="comment">     * linkage into the address_space-&gt;i_mmap interval tree.</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> &#123;</span></span><br><span class="line">        <span class="class"><span class="keyword">struct</span> <span class="title">rb_node</span> <span class="title">rb</span>;</span></span><br><span class="line">        <span class="type">unsigned</span> <span class="type">long</span> rb_subtree_last;</span><br><span class="line">    &#125; shared;</span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">     * A file&#x27;s MAP_PRIVATE vma can be in both i_mmap tree and anon_vma</span></span><br><span class="line"><span class="comment">     * list, after a COW of one of the file pages.	A MAP_SHARED vma</span></span><br><span class="line"><span class="comment">     * can only be in the i_mmap tree.  An anonymous MAP_PRIVATE, stack</span></span><br><span class="line"><span class="comment">     * or brk vma (with NULL file) can only be in an anon_vma list.</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">list_head</span> <span class="title">anon_vma_chain</span>;</span> <span class="comment">/* Serialized by mmap_sem &amp; page_table_lock */</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">anon_vma</span> *<span class="title">anon_vma</span>;</span>	<span class="comment">/* Serialized by page_table_lock */</span></span><br><span class="line">    <span class="comment">/* Function pointers to deal with this struct. */</span></span><br><span class="line">    <span class="type">const</span> <span class="class"><span class="keyword">struct</span> <span class="title">vm_operations_struct</span> *<span class="title">vm_ops</span>;</span></span><br><span class="line">    <span class="comment">/* Information about our backing store: */</span></span><br><span class="line">    <span class="type">unsigned</span> <span class="type">long</span> vm_pgoff;		<span class="comment">/* Offset (within vm_file) in PAGE_SIZE</span></span><br><span class="line"><span class="comment">                       units */</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">file</span> * <span class="title">vm_file</span>;</span>		<span class="comment">/* File we map to (can be NULL). */</span></span><br><span class="line">    <span class="type">void</span> * vm_private_data;		<span class="comment">/* was vm_pte (shared mem) */</span></span><br><span class="line">    <span class="type">atomic_long_t</span> swap_readahead_info;</span><br><span class="line"><span class="meta">#<span class="keyword">ifndef</span> CONFIG_MMU</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">vm_region</span> *<span class="title">vm_region</span>;</span>	<span class="comment">/* NOMMU mapping region */</span></span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">ifdef</span> CONFIG_NUMA</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">mempolicy</span> *<span class="title">vm_policy</span>;</span>	<span class="comment">/* NUMA policy for the VMA */</span></span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">vm_userfaultfd_ctx</span> <span class="title">vm_userfaultfd_ctx</span>;</span></span><br><span class="line">&#125; __randomize_layout;</span><br></pre></td></tr></table></figure>
<p>  对一个mm_struct来说，其众多的vm_area_struct会在ELF文件加载，即load_elf_binary()时构造。该函数在解析ELF文件格式后，就会进行内存映射的建立，主要包括</p>
<ul>
<li>调用 setup_new_exec，设置内存映射区 mmap_base</li>
<li>调用 setup_arg_pages，设置栈的 vm_area_struct，这里面设置了 mm-&gt;arg_start 是指向栈底的，current-&gt;mm-&gt;start_stack 就是栈底</li>
<li>elf_map 会将 ELF 文件中的代码部分映射到内存中来</li>
<li>set_brk 设置了堆的 vm_area_struct，这里面设置了 current-&gt;mm-&gt;start_brk &#x3D; current-&gt;mm-&gt;brk，也即堆里面还是空的</li>
<li>load_elf_interp 将依赖的 so 映射到内存中的内存映射区域</li>
</ul>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">static</span> <span class="type">int</span> <span class="title function_">load_elf_binary</span><span class="params">(<span class="keyword">struct</span> linux_binprm *bprm)</span></span><br><span class="line">&#123;</span><br><span class="line">......</span><br><span class="line">    setup_new_exec(bprm);</span><br><span class="line">......</span><br><span class="line">    <span class="comment">/* Do this so that we can load the interpreter, if need be.  We will</span></span><br><span class="line"><span class="comment">       change some of these later */</span>    </span><br><span class="line">    retval = setup_arg_pages(bprm, randomize_stack_top(STACK_TOP),</span><br><span class="line">         executable_stack);</span><br><span class="line">......</span><br><span class="line">    error = elf_map(bprm-&gt;file, load_bias + vaddr, elf_ppnt,</span><br><span class="line">        elf_prot, elf_flags, total_size);</span><br><span class="line">......</span><br><span class="line">    <span class="comment">/* Calling set_brk effectively mmaps the pages that we need</span></span><br><span class="line"><span class="comment">     * for the bss and break sections.  We must do this before</span></span><br><span class="line"><span class="comment">     * mapping in the interpreter, to make sure it doesn&#x27;t wind</span></span><br><span class="line"><span class="comment">     * up getting placed where the bss needs to go.</span></span><br><span class="line"><span class="comment">     */</span>    </span><br><span class="line">    retval = set_brk(elf_bss, elf_brk, bss_prot);</span><br><span class="line">......</span><br><span class="line">    elf_entry = load_elf_interp(&amp;loc-&gt;interp_elf_ex,</span><br><span class="line">              interpreter,</span><br><span class="line">              &amp;interp_map_addr,</span><br><span class="line">              load_bias, interp_elf_phdata);</span><br><span class="line">......</span><br><span class="line">    current-&gt;mm-&gt;end_code = end_code;</span><br><span class="line">    current-&gt;mm-&gt;start_code = start_code;</span><br><span class="line">    current-&gt;mm-&gt;start_data = start_data;</span><br><span class="line">    current-&gt;mm-&gt;end_data = end_data;</span><br><span class="line">    current-&gt;mm-&gt;start_stack = bprm-&gt;p;</span><br><span class="line">......</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="3-2-内核态结构"><a href="#3-2-内核态结构" class="headerlink" title="3.2 内核态结构"></a>3.2 内核态结构</h3><p>  由于32位和64位系统空间大小差距过大，因此结构上也有一些区别。我们这里分别讨论二者的结构。</p>
<h4 id="3-2-1-32位内核态结构"><a href="#3-2-1-32位内核态结构" class="headerlink" title="3.2.1 32位内核态结构"></a>3.2.1 32位内核态结构</h4><p>  内核态的虚拟空间和进程是无关的，即所有进程通过系统调用进入内核后，看到的虚拟地址空间是一样的。如下图所示为32位内核态虚拟空间分布图。</p>
<p><img src="https://user-images.githubusercontent.com/87457873/128136124-77efb3fa-d616-49a4-90e3-93f47a64eca3.png" alt="image"></p>
<p>1、直接映射区</p>
<p>前896M为直接映射区，该区域用于和物理内存进行直接映射。虚拟内存地址减去 3G，就得到对应的物理内存的位置。在内核里面，有两个宏：</p>
<ul>
<li>__pa(vaddr) 返回与虚拟地址 vaddr 相关的物理地址；</li>
<li>__va(paddr) 则计算出对应于物理地址 paddr 的虚拟地址。</li>
</ul>
<p>  对于该部分虚拟地址的访问，同样采取分页的方式进行，但是页表地址比较简单，直接一一对应即可。</p>
<p>  在系统启动的时候，物理内存的前 1M 已经被占用了，从 1M 开始加载内核代码段，然后就是内核的全局变量、BSS 等，也是 ELF 里面涵盖的。这样内核的代码段，全局变量，BSS 也就会被映射到 3G 后的虚拟地址空间里面。具体的物理内存布局可以查看 &#x2F;proc&#x2F;iomem，具体会因为每个人的系统、配置等产生区别。</p>
<p>2、high_memory<br><br>  高端内存的名字来源于x86架构中将物理地址空间划分三部分：ZONE_DMA、ZONE_NORMAL和ZONE_HIGHMEM。ZONE_HIGHMEM即为高端内存。</p>
<p>  高端内存是内存管理模块看待物理内存的称谓，指的也即896M直接映射区上面的区域。内核中除了内存管理模块外，其余均操作虚拟地址。而内存管理模块会直接操作物理地址，进行虚拟地址的分配和映射。其存在的意义是以32位系统有限的内核空间去访问无限的物理内存空间：借用这段逻辑地址空间，建立映射到想访问的那段物理内存（即填充内核页表），临时用一会，用完后归还。</p>
<p>3、内核动态映射空间（noncontiguous memory allocation）<br><br>  在VMALLOC_START和VMALLOC_END之间的区域称之为内核动态映射空间，对应于用户态进程malloc申请内存一样，在内核态可以通过vmalloc来申请。内核态有单独的页表管理，和用户态分开。</p>
<p>4、持久内核映射区（permanent kernel mapping）<br><br>  PKMAP_BASE 到 FIXADDR_START 的空间称为持久内核映射，这个地址范围是 4G-8M 到 4G-4M 之间。使用 alloc_pages() 函数的时候，在物理内存的高端内存得到 struct page 结构，可以调用 kmap() 将其映射到这个区域。因为允许永久映射的数量有限，当不再需要高端内存时，应该解除映射，这可以通过kunmap()函数来完成。</p>
<p>5、固定映射区<br><br>  FIXADDR_START 到 FIXADDR_TOP(0xFFFF F000) 的空间，称为固定映射区域，主要用于满足特殊需求。</p>
<p>6、临时映射区（temporary kernel mapping）<br><br>  临时内核映射通过kmap_atomic和kunmap_atomic实现，主要用于当需要写入物理内存或主存时的操作，如写入文件时使用。</p>
<h4 id="3-2-2-64位内核态结构"><a href="#3-2-2-64位内核态结构" class="headerlink" title="3.2.2 64位内核态结构"></a>3.2.2 64位内核态结构</h4><p>  64位内核态因为空间巨大，所以不需要像32位一样精打细算，直接分出很多的空闲区域做保护，结构如下图所示</p>
<p><img src="https://user-images.githubusercontent.com/87457873/128136164-88490bdb-e064-4fc3-bfcc-f2eadbbb5e73.png" alt="image"></p>
<ul>
<li>从 0xffff800000000000 开始就是内核的部分，只不过一开始有 8T 的空档区域。</li>
<li>从 __PAGE_OFFSET_BASE(0xffff880000000000) 开始的 64T 的虚拟地址空间是直接映射区域，也就是减去 PAGE_OFFSET 就是物理地址。虚拟地址和物理地址之间的映射在大部分情况下还是会通过建立页表的方式进行映射。</li>
<li>从 VMALLOC_START（0xffffc90000000000）开始到 VMALLOC_END（0xffffe90000000000）的 32T 的空间是给 vmalloc 的。</li>
<li>从 VMEMMAP_START（0xffffea0000000000）开始的 1T 空间用于存放物理页面的描述结构 struct page 的。</li>
<li>从 __START_KERNEL_map（0xffffffff80000000）开始的 512M 用于存放内核代码段、全局变量、BSS 等。这里对应到物理内存开始的位置，减去 __START_KERNEL_map 就能得到物理内存的地址。这里和直接映射区有点像，但是不矛盾，因为直接映射区之前有 8T 的空当区域，早就过了内核代码在物理内存中加载的位置。</li>
</ul>
<h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>  本文比较详细的分析了内存在用户态和内核态的结构，以此为基础，后文可以开始分析内存的管理、映射了。</p>
]]></content>
      <categories>
        <category>linux-doc</category>
      </categories>
      <tags>
        <tag>Linux</tag>
      </tags>
  </entry>
  <entry>
    <title>你真的理解Linux中断机制嘛</title>
    <url>/2023/01/15/linux-docs/%E4%BD%A0%E7%9C%9F%E7%9A%84%E7%90%86%E8%A7%A3Linux%E4%B8%AD%E6%96%AD%E6%9C%BA%E5%88%B6%E5%98%9B/</url>
    <content><![CDATA[<p>Linux中断是指在CPU正常运行期间，由于内外部事件或由程序预先安排的事件引起的CPU暂时停止正在运行的程序，转而为该内部或外部事件或预先安排的事件服务的程序中去，服务完毕后再返回去继续运行被暂时中断的程序。</p>
<p>进程的不可中断状态是系统的一种保护机制，可以保证硬件的交互过程不被意外打断。所以，短时间的不可中断状态是很正常的。但是，当进程长时间都处于不可中断状态时，你就需要提起注意力确认下是不是磁盘I&#x2F;O存在问题，相关的进程和磁盘设备是否工作正常。</p>
<p>今天我们详细了解一下中断的机制，进而对其中的软中断进行一个剖析。</p>
<h2 id="概念解释"><a href="#概念解释" class="headerlink" title="概念解释"></a>概念解释</h2><p>（1）中断：是一种异步的事件处理机制，可以提高系统的并发处理能力。</p>
<p>（2）如何解决中断处理程序执行过长和中断丢失的问题：<br><br>Linux 将中断处理过程分成了两个阶段，也就是上半部和下半部。<br><br>上半部用来快速处理中断，它在中断禁止模式下运行，主要处理跟硬件紧密相关的或时间敏感的工作。也就是我们常说的硬中断，特点是快速执行。<br><br>下半部用来延迟处理上半部未完成的工作，通常以内核线程的方式运行。也就是我们常说的软中断，特点是延迟执行。</p>
<p>（3）proc 文件系统：是一种内核空间和用户空间进行通信的机制，可以用来查看内核的数据结构，或者用来动态修改内核的配置。<br><br>&#x2F;proc&#x2F;softirqs 提供了软中断的运行情况；<br><br>&#x2F;proc&#x2F;interrupts 提供了硬中断的运行情况。<br></p>
<p>（4）硬中断：硬中断是由硬件产生的，比如，像磁盘，网卡，键盘，时钟等。每个设备或设备集都有它自己的IRQ（中断请求）。基于IRQ，CPU可以将相应的请求分发到对应的硬件驱动上。硬中断可以直接中断CPU，引起内核中相关的代码被触发。</p>
<p>（5）软中断：软中断仅与内核相关，由当前正在运行的进程所产生。 通常，软中断是一些对I&#x2F;O的请求，这些请求会调用内核中可以调度I&#x2F;O发生的程序。 软中断并不会直接中断CPU，也只有当前正在运行的代码（或进程）才会产生软中断。这种中断是一种需要内核为正在运行的进程去做一些事情（通常为I&#x2F;O）的请求。<br>除了iowait(等待I&#x2F;O的CPU使用率)升高，软中断(softirq)CPU使用率升高也是最常见的一种性能问题。</p>
<h2 id="查看软中断和内核线程"><a href="#查看软中断和内核线程" class="headerlink" title="查看软中断和内核线程"></a>查看软中断和内核线程</h2><p>小伙伴们肯定好奇该怎么查看系统里有哪些软中断？接下来将教给大家方法。<br><br>前面有提到过proc文件系统，它是一种内核空间和用户空间进行通信的机制， 可以用来查看内核的数据结构，或者用来动态修改内核的配置。</p>
<ul>
<li>&#x2F;proc&#x2F;softirqs 提供了软中断的运行情况；</li>
<li>&#x2F;proc&#x2F;interrupts 提供了硬中断的运行情况。</li>
</ul>
<p>（1）如何查看各种类型软中断在不同 CPU上的累积运行次数：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">$ cat /proc/softirqs</span><br><span class="line">                    CPU0       CPU1       CPU2       CPU3</span><br><span class="line">          HI:     276180     286764    2509097     254357</span><br><span class="line">       TIMER:    1550133    1285854    1440533    1812909</span><br><span class="line">      NET_TX:     102895         16         15         57</span><br><span class="line">      NET_RX:        155        178        115    1619192</span><br><span class="line">       BLOCK:       1713      15048     251826       1082</span><br><span class="line">    IRQ_POLL:          0          0          0          0</span><br><span class="line">     TASKLET:          9         63          6       2830</span><br><span class="line">       SCHED:    1484942    1207449    1310735    1724911</span><br><span class="line">     HRTIMER:          0          0          0          0</span><br><span class="line">         RCU:     690954     685825     787447     878963</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>软中断的类型：对应第1列，包含了10个类别，分别对应不同的工作类型。比如说NET_RX 表示网络接收中断，而 NET_TX 表示网络发送中 断。</p>
<p>同一种软中断类型在不同CPU上的分布情况：对应每一行，正常情况下，同一种中断类型在不同CPU上的累计次数基本在同一个数量级。但是也有例外，比如TASKLET</p>
<p>拓展：什么是TASKLET？<br></p>
<ul>
<li>TASKLET是最常用的软中断实现机制，每个TASKLET只会运行一次就会结束，并且只在调用它的函数所在的CPU上运行，不能并行而只能串行执行。</li>
<li>多个不同类型的TASKLET可以并行在多个CPU上。</li>
<li>软中断是静态，只能支持有限的几种软中断类型，一旦内核编译好之后就不能改变；而TASKLET灵活很多，可以通过添加内核模块的方式在运行时修改。</li>
</ul>
<p>（2）如何查看软中断内核线程的运行状况？<br><br>软中断是以内核线程的方式运行的，每个CPU都会对应一个软中断内核线程，查看的方式如下：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">$ ps -ef|grep softirq</span><br><span class="line">root    7    2  0 Nov04 ?    00:00:53 [ksoftirqd/0]</span><br><span class="line">root   16    2  0 Nov04 ?    00:00:51 [ksoftirqd/1]</span><br><span class="line">root   22    2  0 Nov04 ?    00:00:53 [ksoftirqd/2]</span><br><span class="line">root   28    2  0 Nov04 ?    00:00:53 [ksoftirqd/3]</span><br></pre></td></tr></table></figure>

<p>这些线程的名字外面都有中括号，这说明 ps 无法获取它们的命令行参数 （cmline）。</p>
<p>一般来说，ps 的输出中，名字括在中括号里的，一般都是内核线程。</p>
<p>（3）如何查看硬中断运行情况</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">$ cat /proc/interrupts </span><br><span class="line">           CPU0       CPU1       CPU2       CPU3            </span><br><span class="line">  0:         33          0          0          0      IO-APIC-edge      timer</span><br><span class="line">  1:         10          0          0          0      IO-APIC-edge      i8042</span><br><span class="line">  4:        325          0          0          0      IO-APIC-edge      serial</span><br><span class="line">  8:          1          0          0          0      IO-APIC-edge      rtc0</span><br><span class="line">  9:          0          0          0          0      IO-APIC-fasteoi   acpi</span><br><span class="line"> 10:          0          0          0          0      IO-APIC-fasteoi   virtio3</span><br><span class="line"> 40:          0          0          0          0      PCI-MSI-edge      virtio1-config</span><br><span class="line"> 41:   16669006          0          0          0      PCI-MSI-edge      virtio1-requests</span><br><span class="line"> 42:          0          0          0          0      PCI-MSI-edge      virtio2-config</span><br><span class="line"> 43:   59166530          0          0          0      PCI-MSI-edge      virtio2-requests</span><br><span class="line"> 44:          0          0          0          0      PCI-MSI-edge      virtio0-config</span><br><span class="line"> 45:    6689988          0          0          0      PCI-MSI-edge      virtio0-input.0</span><br><span class="line"> 46:          0          0          0          0      PCI-MSI-edge      virtio0-output.0</span><br><span class="line"> 47: 2093616484          0          0          0      PCI-MSI-edge      peth1-TxRx-0</span><br><span class="line"> 48:          5 2045859720          0          0      PCI-MSI-edge      peth1-TxRx-1</span><br><span class="line"> 49:         81          0          0          0      PCI-MSI-edge      peth1</span><br><span class="line">NMI:          0          0          0          0      Non-maskable interrupts</span><br><span class="line">LOC: 2936184495  965056330 1641503935 1442909354      Local timer interrupts</span><br><span class="line">SPU:          0          0          0          0      Spurious interrupts</span><br><span class="line">PMI:          0          0          0          0      Performance monitoring interrupts</span><br><span class="line">IWI:   53775871   47387196   47737572   44243915      IRQ work interrupts</span><br><span class="line">RTR:          0          0          0          0      APIC ICR read retries</span><br><span class="line">RES: 1198594562  964481221  966552350  902484234      Rescheduling interrupts</span><br><span class="line">CAL: 4294967071       4438  430547422  419910155      Function call interrupts</span><br><span class="line">TLB: 1206563963   65932469 1378887038 1028081848      TLB shootdowns</span><br><span class="line">TRM:          0          0          0          0      Thermal event interrupts</span><br><span class="line">THR:          0          0          0          0      Threshold APIC interrupts</span><br><span class="line">MCE:          0          0          0          0      Machine check exceptions</span><br><span class="line">MCP:      65623      65623      65623      65623      Machine check polls</span><br><span class="line">ERR:          0</span><br></pre></td></tr></table></figure>

<h2 id="工具与技巧"><a href="#工具与技巧" class="headerlink" title="工具与技巧"></a>工具与技巧</h2><p><img src="https://user-images.githubusercontent.com/87457873/127655271-080f7e53-f2b0-4797-bbbc-972f77afb8a0.png" alt="image"></p>
<p>（1）sar 是一个系统活动报告工具，既可以实时查看系统的当前活动，又可以配置保存和报告历史统计数据。<br><br>命令：sar -n DEV 1<br><br>含义：-n DEV 1 表示显示网络收发的报告，间隔1秒输出一组数据<br></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">$ sar -n DEV 1</span><br><span class="line">16:01:21       IFACE   rxpck/s   txpck/s    rxkB/s    txkB/s   rxcmp/s   txcmp/s  rxmcst/s   %ifutil</span><br><span class="line">16:01:22        eth0  12605.00   6304.00    664.86    358.11      0.00      0.00      0.00      0.01</span><br><span class="line">16:01:22     docker0   6302.00  12604.00    270.79    664.66      0.00      0.00      0.00      0.00</span><br><span class="line">16:01:22          lo      0.00      0.00      0.00      0.00      0.00      0.00      0.00      0.00</span><br><span class="line">16:01:22 veth9f6bbcd   6302.00  12604.00    356.95    664.66      0.00      0.00      0.00      0.05</span><br></pre></td></tr></table></figure>

<p>第1列：表示报告的时间</p>
<p>第2列：IFACE 表示网卡</p>
<p>第3，4列：rxpck&#x2F;s 和 txpck&#x2F;s 分别表示每秒接收、发送的网络帧数，也就是 PPS</p>
<p>第5，6列：rxkB&#x2F;s 和 txkB&#x2F;s 分别表示每秒接收、发送的千字节数，也就是 BPS。</p>
<p>（2）tcpdump 是一个常用的网络抓包工具，常用来分析各种网络问题。</p>
<p>命令：tcpdump -i eth0 -n tcp port 80<br><br>含义：-i eth0 只抓取eth0网卡，-n不解析协议名和主机名<br><br>           tcp port 80表示只抓取tcp协议并且端口号为80的网络帧</p>
]]></content>
      <categories>
        <category>linux-doc</category>
      </categories>
      <tags>
        <tag>Linux</tag>
      </tags>
  </entry>
  <entry>
    <title>浅谈Linux内核之CPU缓存</title>
    <url>/2023/01/15/linux-docs/%E6%B5%85%E8%B0%88Linux%E5%86%85%E6%A0%B8%E4%B9%8BCPU%E7%BC%93%E5%AD%98/</url>
    <content><![CDATA[<h2 id="一、什么是CPU缓存"><a href="#一、什么是CPU缓存" class="headerlink" title="一、什么是CPU缓存"></a>一、什么是CPU缓存</h2><h3 id="1-CPU缓存的来历"><a href="#1-CPU缓存的来历" class="headerlink" title="1. CPU缓存的来历"></a>1. CPU缓存的来历</h3><p>众所周知,CPU是计算机的大脑，它负责执行程序的指令，而内存负责存数据, 包括程序自身的数据。在很多年前，CPU的频率与内存总线的频率在同一层面上。内存的访问速度仅比寄存器慢一些。但是，这一局面在上世纪90年代被打破了。CPU的频率大大提升，但内存总线的频率与内存芯片的性能却没有得到成比例的提升。并不是因为造不出更快的内存，只是因为太贵了。内存如果要达到目前CPU那样的速度，那么它的造价恐怕要贵上好几个数量级。所以，CPU的运算速度要比内存读写速度快很多，这样会使CPU花费很长的时间等待数据的到来或把数据写入到内存中。所以，为了解决CPU运算速度与内存读写速度不匹配的矛盾，就出现了CPU缓存。</p>
<h3 id="2-CPU缓存的概念"><a href="#2-CPU缓存的概念" class="headerlink" title="2. CPU缓存的概念"></a>2. CPU缓存的概念</h3><p>CPU缓存是位于CPU与内存之间的临时数据交换器，它的容量比内存小的多但是交换速度却比内存要快得多。CPU缓存一般直接跟CPU芯片集成或位于主板总线互连的独立芯片上。</p>
<p>为了简化与内存之间的通信，高速缓存控制器是针对数据块，而不是字节进行操作的。高速缓存其实就是一组称之为缓存行(Cache Line)的固定大小的数据块组成的，典型的一行是64字节。</p>
<h3 id="3-CPU缓存的意义"><a href="#3-CPU缓存的意义" class="headerlink" title="3. CPU缓存的意义"></a>3. CPU缓存的意义</h3><p>CPU往往需要重复处理相同的数据、重复执行相同的指令，如果这部分数据、指令CPU能在CPU缓存中找到，CPU就不需要从内存或硬盘中再读取数据、指令，从而减少了整机的响应时间。所以，缓存的意义满足以下两种局部性原理：</p>
<ul>
<li>时间局部性（Temporal Locality）：如果一个信息项正在被访问，那么在近期它很可能还会被再次访问。</li>
<li>空间局部性（Spatial Locality）：如果一个存储器的位置被引用，那么将来他附近的位置也会被引用。</li>
</ul>
<h2 id="二、CPU的三级缓存"><a href="#二、CPU的三级缓存" class="headerlink" title="二、CPU的三级缓存"></a>二、CPU的三级缓存</h2><h3 id="1-CPU的三级缓存"><a href="#1-CPU的三级缓存" class="headerlink" title="1. CPU的三级缓存"></a>1. CPU的三级缓存</h3><p>随着多核CPU的发展，CPU缓存通常分成了三个级别：L1，L2，L3。级别越小越接近CPU，所以速度也更快，同时也代表着容量越小。L1 是最接近CPU的, 它容量最小（例如：32K），速度最快，每个核上都有一个 L1 缓存，L1 缓存每个核上其实有两个 L1 缓存, 一个用于存数据的 L1d Cache（Data Cache），一个用于存指令的 L1i Cache（Instruction Cache）。L2 缓存 更大一些（例如：256K），速度要慢一些, 一般情况下每个核上都有一个独立的L2 缓存; L3 缓存是三级缓存中最大的一级（例如3MB），同时也是最慢的一级, 在同一个CPU插槽之间的核共享一个 L3 缓存。<br>下面是三级缓存的处理速度参考表：</p>
<p><img src="https://user-images.githubusercontent.com/87457873/127453978-b6efc19f-57ce-4ff2-8482-f27d96b72be9.png" alt="image"></p>
<p>下图是Intel Core i5-4285U的CPU三级缓存示意图：</p>
<p><img src="https://user-images.githubusercontent.com/87457873/127454008-18cedbb6-d8ef-44ae-bd2e-f2f9431f54cb.png" alt="image"></p>
<p>就像数据库缓存一样，获取数据时首先会在最快的缓存中找数据，如果缓存没有命中(Cache miss) 则往下一级找, 直到三级缓存都找不到时，那只有向内存要数据了。一次次地未命中，代表取数据消耗的时间越长。</p>
<h3 id="2-带有高速缓存CPU执行计算的流程"><a href="#2-带有高速缓存CPU执行计算的流程" class="headerlink" title="2. 带有高速缓存CPU执行计算的流程"></a>2. 带有高速缓存CPU执行计算的流程</h3><p>1、程序以及数据被加载到主内存<br><br>2、指令和数据被加载到CPU的高速缓存<br><br>3、CPU执行指令，把结果写到高速缓存<br><br>4、高速缓存中的数据写回主内存<br></p>
<p>目前流行的多级缓存结构如下图：</p>
<p><img src="https://user-images.githubusercontent.com/87457873/127454127-03acfae2-3840-4577-9ebf-cda2197e3593.png" alt="image"></p>
<h2 id="三、CPU缓存一致性协议-MESI"><a href="#三、CPU缓存一致性协议-MESI" class="headerlink" title="三、CPU缓存一致性协议(MESI)"></a>三、CPU缓存一致性协议(MESI)</h2><p>MESI（Modified Exclusive Shared Or Invalid）(也称为伊利诺斯协议，是因为该协议由伊利诺斯州立大学提出的）是一种广泛使用的支持写回策略的缓存一致性协议。为了保证多个CPU缓存中共享数据的一致性，定义了缓存行(Cache Line)的四种状态，而CPU对缓存行的四种操作可能会产生不一致的状态，因此缓存控制器监听到本地操作和远程操作的时候，需要对地址一致的缓存行的状态进行一致性修改，从而保证数据在多个缓存之间保持一致性。</p>
<h3 id="1-MESI协议中的状态"><a href="#1-MESI协议中的状态" class="headerlink" title="1. MESI协议中的状态"></a>1. MESI协议中的状态</h3><p>CPU中每个缓存行（Cache line)使用4种状态进行标记，使用2bit来表示:</p>
<p><img src="https://user-images.githubusercontent.com/87457873/127454198-26389284-d2f8-4a14-b456-4391c535f031.png" alt="image"></p>
<blockquote>
<p>注意：对于M和E状态而言总是精确的，他们在和该缓存行的真正状态是一致的，而S状态可能是非一致的。如果一个缓存将处于S状态的缓存行作废了，而另一个缓存实际上可能已经独享了该缓存行，但是该缓存却不会将该缓存行升迁为E状态，这是因为其它缓存不会广播他们作废掉该缓存行的通知，同样由于缓存并没有保存该缓存行的copy的数量，因此（即使有这种通知）也没有办法确定自己是否已经独享了该缓存行。</p>
</blockquote>
<p>从上面的意义看来E状态是一种投机性的优化：如果一个CPU想修改一个处于S状态的缓存行，总线事务需要将所有该缓存行的copy变成invalid状态，而修改E状态的缓存不需要使用总线事务。</p>
<p>MESI状态转换图：</p>
<p><img src="https://user-images.githubusercontent.com/87457873/127454295-b75dab6b-7651-463d-a349-678554190ff9.png" alt="image"></p>
<p>下图表示了当一个缓存行(Cache line)的调整的状态的时候，另外一个缓存行(Cache line)需要调整的状态。</p>
<p><img src="https://user-images.githubusercontent.com/87457873/127454315-abbd52dd-ae50-48b9-90d4-4cbe5cad4158.png" alt="image"></p>
<p>举个示例：</p>
<blockquote>
<p>假设cache 1 中有一个变量x &#x3D; 0的 Cache line 处于S状态(共享)。<br>那么其他拥有x变量的 cache 2、cache 3 等x的 Cache line调整为S状态（共享）或者调整为I状态（无效）。</p>
</blockquote>
<h3 id="2-多核缓存协同操作"><a href="#2-多核缓存协同操作" class="headerlink" title="2. 多核缓存协同操作"></a>2. 多核缓存协同操作</h3><h4 id="1-内存变量"><a href="#1-内存变量" class="headerlink" title="(1) 内存变量"></a>(1) 内存变量</h4><p>假设有三个CPU A、B、C，对应三个缓存分别是cache a、b、c。在主内存中定义了x的引用值为0。</p>
<p><img src="https://user-images.githubusercontent.com/87457873/127454433-35da78e6-e703-40a2-a155-ec8149912fd4.png" alt="image"></p>
<h4 id="2-单核读取"><a href="#2-单核读取" class="headerlink" title="(2) 单核读取"></a>(2) 单核读取</h4><p>执行流程是：</p>
<ul>
<li>CPU A发出了一条指令，从主内存中读取x。</li>
<li>从主内存通过 bus 读取到 CPU A 的缓存中（远端读取 Remote read）,这时该 Cache line 修改为 E 状态（独享）。</li>
</ul>
<p><img src="https://user-images.githubusercontent.com/87457873/127454495-13991bd9-7470-4edf-a8d6-25c03b588a41.png" alt="image"></p>
<h4 id="3-双核读取"><a href="#3-双核读取" class="headerlink" title="(3) 双核读取"></a>(3) 双核读取</h4><p>执行流程是：</p>
<ul>
<li>CPU A发出了一条指令，从主内存中读取x。</li>
<li>CPU A从主内存通过bus读取到 cache a 中并将该 Cache line 设置为E状态。</li>
<li>CPU B发出了一条指令，从主内存中读取x。</li>
<li>CPU B试图从主内存中读取x时，CPU A检测到了地址冲突。这时CPU A对相关数据做出响应。此时x存储于 cache a 和 cache b 中，x在 chche a 和 cache b 中都被设置为S状态(共享)。</li>
</ul>
<p><img src="https://user-images.githubusercontent.com/87457873/127454570-432140ac-3156-4f47-bde4-36f1c6ac742c.png" alt="image"></p>
<h4 id="4-修改数据"><a href="#4-修改数据" class="headerlink" title="(4) 修改数据"></a>(4) 修改数据</h4><p>执行流程是：</p>
<ul>
<li>CPU A 计算完成后发指令需要修改x.</li>
<li>CPU A 将x设置为M状态（修改）并通知缓存了x的 CPU B, CPU B 将本地 cache b 中的x设置为I状态(无效)</li>
<li>CPU A 对x进行赋值。</li>
</ul>
<p><img src="https://user-images.githubusercontent.com/87457873/127454663-0a77e17c-d538-4f22-beed-21f2748e0de3.png" alt="image"></p>
<h4 id="5-同步数据"><a href="#5-同步数据" class="headerlink" title="(5) 同步数据"></a>(5) 同步数据</h4><p>那么执行流程是：</p>
<ul>
<li>CPU B 发出了要读取x的指令。</li>
<li>CPU B 通知CPU A,CPU A将修改后的数据同步到主内存时cache a 修改为E（独享）</li>
<li>CPU A同步CPU B的x,将cache a和同步后cache b中的x设置为S状态（共享）。</li>
</ul>
<h3 id="3-CPU-存储模型简介"><a href="#3-CPU-存储模型简介" class="headerlink" title="3. CPU 存储模型简介"></a>3. CPU 存储模型简介</h3><p>MESI协议为了保证多个 CPU cache 中共享数据的一致性，定义了 Cache line 的四种状态，而 CPU 对 cache 的4种操作可能会产生不一致状态，因此 cache 控制器监听到本地操作和远程操作的时候，需要对地址一致的 Cache line 状态做出一定的修改，从而保证数据在多个cache之间流转的一致性。</p>
<p>但是，缓存的一致性消息传递是要时间的，这就使得状态切换会有更多的延迟。某些状态的切换需要特殊的处理，可能会阻塞处理器。这些都将会导致各种各样的稳定性和性能问题。比如你需要修改本地缓存中的一条信息，那么你必须将I（无效）状态通知到其他拥有该缓存数据的CPU缓存中，并且等待确认。等待确认的过程会阻塞处理器，这会降低处理器的性能。因为这个等待远远比一个指令的执行时间长的多。所以，为了为了避免这种阻塞导致时间的浪费，引入了存储缓存(Store Buffer)和无效队列(Invalidate Queue)。</p>
<h4 id="1-存储缓存"><a href="#1-存储缓存" class="headerlink" title="(1) 存储缓存"></a>(1) 存储缓存</h4><p>在没有存储缓存时，CPU 要写入一个量，有以下情况：</p>
<ul>
<li>量不在该 CPU 缓存中，则需要发送 Read Invalidate 信号，再等待此信号返回，之后再写入量到缓存中。</li>
<li>量在该 CPU 缓存中，如果该量的状态是 Exclusive 则直接更改。而如果是 Shared 则需要发送 Invalidate 消息让其它 CPU 感知到这一更改后再更改。</li>
</ul>
<p>这些情况中，很有可能会触发该 CPU 与其它 CPU 进行通讯，接着需要等待它们回复。这会浪费大量的时钟周期！为了提高效率，可以使用异步的方式去处理：先将值写入到一个 Buffer 中，再发送通讯的信号，等到信号被响应，再应用到 cache 中。并且此 Buffer 能够接受该 CPU 读值。这个 Buffer 就是 Store Buffer。而不须要等待对某个量的赋值指令的完成才继续执行下一条指令，直接去 Store Buffer 中读该量的值，这种优化叫Store Forwarding。</p>
<h4 id="2-无效队列"><a href="#2-无效队列" class="headerlink" title="(2) 无效队列"></a>(2) 无效队列</h4><p>同理，解决了主动发送信号端的效率问题，那么，接受端 CPU 接受到 Invalidate 信号后如果立即采取相应行动(去其它 CPU 同步值)，再返回响应信号，则时钟周期也太长了，此处也可优化。接受端 CPU 接受到信号后不是立即采取行动，而是将 Invalidate 信号插入到一个队列 Queue 中，立即作出响应。等到合适的时机，再去处理这个 Queue 中的 Invalidate 信号，并作相应处理。这个 Queue 就是Invalidate Queue。</p>
<h2 id="四、乱序执行"><a href="#四、乱序执行" class="headerlink" title="四、乱序执行"></a>四、乱序执行</h2><p>乱序执行（out-of-orderexecution）：是指CPU允许将多条指令不按程序规定的顺序分开发送给各相应电路单元处理的技术。这样将根据各电路单元的状态和各指令能否提前执行的具体情况分析后，将能提前执行的指令立即发送给相应电路。</p>
<p>这好比请A、B、C三个名人为晚会题写横幅“春节联欢晚会”六个大字，每人各写两个字。如果这时在一张大纸上按顺序由A写好”春节”后再交给B写”联欢”，然后再由C写”晚会”，那么这样在A写的时候，B和C必须等待，而在B写的时候C仍然要等待而A已经没事了。</p>
<p>但如果采用三个人分别用三张纸同时写的做法， 那么B和C都不必须等待就可以同时各写各的了，甚至C和B还可以比A先写好也没关系（就象乱序执行），但当他们都写完后就必须重新在横幅上（自然可以由别人做，就象CPU中乱序执行后的重新排列单元）按”春节联欢晚会”的顺序排好才能挂出去。</p>
<p>所以，CPU 为什么会有乱序执行优化？本质原因是CPU为了效率，将长费时的操作“异步”执行，排在后面的指令不等前面的指令执行完毕就开始执行后面的指令。而且允许排在前面的长费时指令后于排在后面的指令执行完。</p>
<p>CPU 执行乱序主要有以下几种：</p>
<ul>
<li>**写写乱序(store store)**：a&#x3D;1;b&#x3D;2; -&gt; b&#x3D;2;a&#x3D;1;</li>
<li>**写读乱序(store load)**：a&#x3D;1;load(b); -&gt; load(b);a&#x3D;1;</li>
<li>**读读乱序(load load)**：load(a);load(b); -&gt; load(b);load(a);</li>
<li>**读写乱序(load store)**：load(a);b&#x3D;2; -&gt; b&#x3D;2;load(a);</li>
</ul>
<p>总而言之，CPU的乱序执行优化指的是处理器为提高运算速度而做出违背代码原有顺序的优化。</p>
]]></content>
      <categories>
        <category>linux-doc</category>
      </categories>
      <tags>
        <tag>Linux</tag>
      </tags>
  </entry>
  <entry>
    <title>系统调用</title>
    <url>/2023/01/15/linux-docs/%E7%B3%BB%E7%BB%9F%E8%B0%83%E7%94%A8/</url>
    <content><![CDATA[<h2 id="一-前言"><a href="#一-前言" class="headerlink" title="一. 前言"></a>一. 前言</h2><p>  通过前面几篇文章，我们分析了从按下电源键到内核启动、完成初始化的整个过程。在后面的文章中我们将分别深入剖析Linux内核各个重要部分的源码。考虑到后面的部分我们会从用户态的代码开始入手一步一步深入，因此在分析这些之前，我们需要仔细看一看如何实现一个从用户态到内核态再回到用户态的系统调用的全过程，即系统调用的实现。</p>
<p>  本文的说明顺序如下：</p>
<ul>
<li>首先从一个简单的例子开始分析glibc中对应的调用</li>
<li>针对32位和64位中调用的结构不同会分开两部分单独介绍，会介绍整个调用至完成的过程。即用户态-&gt;内核态-&gt;用户态</li>
<li>在整个调用过程中最重要的一步是中间访问系统调用表，该部分为了描述清楚单独拉出来最后介绍</li>
</ul>
<h2 id="二-GLIBC标准库的调用"><a href="#二-GLIBC标准库的调用" class="headerlink" title="二. GLIBC标准库的调用"></a>二. GLIBC标准库的调用</h2><p>  让我们从一个简单的程序开始</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">(<span class="type">int</span> argc, <span class="type">char</span> **argv)</span></span><br><span class="line">&#123;</span><br><span class="line">    FILE *fp;</span><br><span class="line">    <span class="type">char</span> buff[<span class="number">255</span>];</span><br><span class="line"></span><br><span class="line">    fp = fopen(<span class="string">&quot;test.txt&quot;</span>, <span class="string">&quot;r&quot;</span>);</span><br><span class="line">    fgets(buff, <span class="number">255</span>, fp);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%s\n&quot;</span>, buff);</span><br><span class="line">    fclose(fp);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>  如上所示的程序主要调用了glibc中的函数，然后在其上进行了封装而成。比如fopen实际使用的是open，这里我们就以该函数为例来说明整个调用过程。首先open函数的系统调用在syscalls.list表中定义</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"># File name Caller Syscall name Args Strong name Weak names</span><br><span class="line">open - open Ci:siv __libc_open __open open</span><br></pre></td></tr></table></figure>
<p>  根据此配置文件，glibc会调用脚本make_syscall.sh将其封装为宏，如SYSCALL_NAME open的形式。这些宏会通过T_PSEUDO来调用（位于syscall-template.S），而实际上使用的则是DO_CALL(syscall_name, args)</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">T_PSEUDO (SYSCALL_SYMBOL, SYSCALL_NAME, SYSCALL_NARGS)</span><br><span class="line">    ret</span><br><span class="line"><span class="title function_">T_PSEUDO_END</span> <span class="params">(SYSCALL_SYMBOL)</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> T_PSEUDO(SYMBOL, NAME, N)    PSEUDO (SYMBOL, NAME, N)</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> PSEUDO(name, syscall_name, args)      \</span></span><br><span class="line"><span class="meta">    .text;                                    \</span></span><br><span class="line"><span class="meta">    ENTRY (name)                              \</span></span><br><span class="line"><span class="meta">    DO_CALL (syscall_name, args);             \</span></span><br><span class="line"><span class="meta">    cmpl $-4095, %eax;                        \</span></span><br><span class="line"><span class="meta">    jae SYSCALL_ERROR_LABEL</span></span><br></pre></td></tr></table></figure>
<h3 id="2-1-32位系统调用过程"><a href="#2-1-32位系统调用过程" class="headerlink" title="2.1 32位系统调用过程"></a>2.1 32位系统调用过程</h3><p>  考虑到32位和64位代码结构有一些区别，因此这里需要分开讨论。在32位系统中，DO_CALL()位于i386 目录下的sysdep.h文件中</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">/* Linux takes system call arguments in registers:</span></span><br><span class="line"><span class="comment">  syscall number  %eax       call-clobbered</span></span><br><span class="line"><span class="comment">  arg 1    %ebx       call-saved</span></span><br><span class="line"><span class="comment">  arg 2    %ecx       call-clobbered</span></span><br><span class="line"><span class="comment">  arg 3    %edx       call-clobbered</span></span><br><span class="line"><span class="comment">  arg 4    %esi       call-saved</span></span><br><span class="line"><span class="comment">  arg 5    %edi       call-saved</span></span><br><span class="line"><span class="comment">  arg 6    %ebp       call-saved</span></span><br><span class="line"><span class="comment">......</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> DO_CALL(syscall_name, args)               \</span></span><br><span class="line"><span class="meta">    PUSHARGS_##args                               \</span></span><br><span class="line"><span class="meta">    DOARGS_##args                                 \</span></span><br><span class="line"><span class="meta">    movl $SYS_ify (syscall_name), %eax;           \</span></span><br><span class="line"><span class="meta">    ENTER_KERNEL                                  \</span></span><br><span class="line"><span class="meta">    POPARGS_##args</span></span><br></pre></td></tr></table></figure>
<p>  这里，我们将请求参数放在寄存器里面，根据系统调用的名称，得到系统调用号，放在寄存器 eax 里面，然后执行ENTER_KERNEL。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"># define ENTER_KERNEL int $0x80</span><br></pre></td></tr></table></figure>
<p>  ENTER_KERNEL实际调用的是80软中断，以此陷入内核。这些中断在trap_init()中被定义并初始化。在前文中对trap_init()已有一些简单的叙述，后面在中断部分会再详细介绍。</p>
<p>  初始化好的中断表会等待到中断触发，触发的时候则调用对应的回调函数，这里的话就是entry_INT80_32。该中断首先通过push和SAVE_ALL保存所有的寄存器，存储在pt_regs中，然后调用do_syscall_32_irqs_on()函数。该函数将系统调用号从eax里面取出来，然后根据系统调用号，在系统调用表中找到相应的函数进行调用，并将寄存器中保存的参数取出来，作为函数参数。最后调用INTERRUPT_RETURN，实际使用的是iret指令将原来用户保存的现场包含代码段、指令指针寄存器等恢复，并返回至用户态执行。</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">ENTRY(entry_INT80_32)</span><br><span class="line">    ASM_CLAC</span><br><span class="line">    pushl   %eax                    <span class="comment">/* pt_regs-&gt;orig_ax */</span></span><br><span class="line">    SAVE_ALL pt_regs_ax=$-ENOSYS    <span class="comment">/* save rest */</span></span><br><span class="line">    movl    %esp, %eax</span><br><span class="line">    call    do_syscall_32_irqs_on</span><br><span class="line">.Lsyscall_32_done:</span><br><span class="line">......</span><br><span class="line">.Lirq_return:</span><br><span class="line">  INTERRUPT_RETURN</span><br><span class="line">     </span><br><span class="line">......     </span><br><span class="line"></span><br><span class="line"><span class="type">static</span> __always_inline <span class="type">void</span> do_syscall_32_irqs_on(<span class="keyword">struct</span> pt_regs *regs)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">struct</span> thread_info *ti = current_thread_info();</span><br><span class="line">    <span class="type">unsigned</span> <span class="type">int</span> nr = (<span class="type">unsigned</span> <span class="type">int</span>)regs-&gt;orig_ax;</span><br><span class="line">......</span><br><span class="line">    <span class="keyword">if</span> (likely(nr &lt; IA32_NR_syscalls)) &#123;</span><br><span class="line">        regs-&gt;ax = ia32_sys_call_table[nr](</span><br><span class="line">            (<span class="type">unsigned</span> <span class="type">int</span>)regs-&gt;bx, (<span class="type">unsigned</span> <span class="type">int</span>)regs-&gt;cx,</span><br><span class="line">            (<span class="type">unsigned</span> <span class="type">int</span>)regs-&gt;dx, (<span class="type">unsigned</span> <span class="type">int</span>)regs-&gt;si,</span><br><span class="line">            (<span class="type">unsigned</span> <span class="type">int</span>)regs-&gt;di, (<span class="type">unsigned</span> <span class="type">int</span>)regs-&gt;bp);</span><br><span class="line">    &#125;</span><br><span class="line">    syscall_return_slowpath(regs);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="2-2-64位系统调用过程"><a href="#2-2-64位系统调用过程" class="headerlink" title="2.2 64位系统调用过程"></a>2.2 64位系统调用过程</h3><p>  对于64位系统来说，DO_CALL位于x86_64 目录下的 sysdep.h 文件中</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">/* The Linux/x86-64 kernel expects the system call parameters in</span></span><br><span class="line"><span class="comment">   registers according to the following table:</span></span><br><span class="line"><span class="comment">    syscall number  rax</span></span><br><span class="line"><span class="comment">    arg 1    rdi</span></span><br><span class="line"><span class="comment">    arg 2    rsi</span></span><br><span class="line"><span class="comment">    arg 3    rdx</span></span><br><span class="line"><span class="comment">    arg 4    r10</span></span><br><span class="line"><span class="comment">    arg 5    r8</span></span><br><span class="line"><span class="comment">    arg 6    r9</span></span><br><span class="line"><span class="comment">......</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> DO_CALL(syscall_name, args)                \</span></span><br><span class="line"><span class="meta">  lea SYS_ify (syscall_name), %rax;                \</span></span><br><span class="line"><span class="meta">  syscall</span></span><br></pre></td></tr></table></figure>
<p>  和之前一样，还是将系统调用名称转换为系统调用号，放到寄存器rax。这里是真正进行调用，不是用中断了，而是改用syscall指令了。并且，通过注释我们也可以知道，传递参数的寄存器也变了。syscall指令还使用了一种特殊的寄存器，我们叫特殊模块寄存器（Model Specific Registers，简称 MSR）。这种寄存器是 CPU 为了完成某些特殊控制功能为目的的寄存器，其中就有系统调用。</p>
<p>  在系统初始化的时候，trap_init() 除了初始化上面的中断模式，这里面还会调用 cpu_init-&gt;syscall_init()。这里面有这样的代码：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">wrmsrl(MSR_LSTAR, (<span class="type">unsigned</span> <span class="type">long</span>)entry_SYSCALL_64);</span><br></pre></td></tr></table></figure>
<p>  rdmsr() 和 wrmsr() 是用来读写特殊模块寄存器的。MSR_LSTAR 就是这样一个特殊的寄存器，当 syscall 指令调用的时候，会从这个寄存器里面拿出函数地址来调用，也就是调用 entry_SYSCALL_64。在 arch&#x2F;x86&#x2F;entry&#x2F;entry_64.S中定义了 entry_SYSCALL_64函数。</p>
<p>  该函数开始于一条宏：SWAPGS_UNSAFE_STACK，其定义如下，主要是交换当前GS基寄存器中的值和特殊模块寄存器中包含的值，即进入内核栈。</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">define</span> SWAPGS_UNSAFE_STACK    swapgs</span></span><br></pre></td></tr></table></figure>
<p>  对于旧的栈，我们会将其存于rsp_scratch，并将栈指针移至当前进程的栈顶。</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">movq    %rsp, PER_CPU_VAR(rsp_scratch)</span><br><span class="line">movq    <span class="title function_">PER_CPU_VAR</span><span class="params">(cpu_current_top_of_stack)</span>, %rsp</span><br></pre></td></tr></table></figure>
<p>  下一步，我们将栈段和旧的栈指针压入栈中</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">pushq    $__USER_DS</span><br><span class="line">pushq    <span class="title function_">PER_CPU_VAR</span><span class="params">(rsp_scratch)</span></span><br></pre></td></tr></table></figure>
<p>  接下来，我们需要打开中断并保存很多寄存器到 pt_regs 结构里面，例如用户态的代码段、数据段、保存参数的寄存器，并校验当前线程的信息_TIF_WORK_SYSCALL_ENTRY，这里涉及到Linux的debugging和tracing技术，会单独在后文中详细分析。该部分代码具体如下所示。</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">ENTRY(entry_SYSCALL_64)</span><br><span class="line">    <span class="comment">/* Construct struct pt_regs on stack */</span></span><br><span class="line">    pushq   $__USER_DS                      <span class="comment">/* pt_regs-&gt;ss */</span></span><br><span class="line">    pushq   <span class="title function_">PER_CPU_VAR</span><span class="params">(rsp_scratch)</span>        <span class="comment">/* pt_regs-&gt;sp */</span></span><br><span class="line">    pushq   %r11                            <span class="comment">/* pt_regs-&gt;flags */</span></span><br><span class="line">    pushq   $__USER_CS                      <span class="comment">/* pt_regs-&gt;cs */</span></span><br><span class="line">    pushq   %rcx                            <span class="comment">/* pt_regs-&gt;ip */</span></span><br><span class="line">    pushq   %rax                            <span class="comment">/* pt_regs-&gt;orig_ax */</span></span><br><span class="line">    pushq   %rdi                            <span class="comment">/* pt_regs-&gt;di */</span></span><br><span class="line">    pushq   %rsi                            <span class="comment">/* pt_regs-&gt;si */</span></span><br><span class="line">    pushq   %rdx                            <span class="comment">/* pt_regs-&gt;dx */</span></span><br><span class="line">    pushq   %rcx                            <span class="comment">/* pt_regs-&gt;cx */</span></span><br><span class="line">    pushq   $-ENOSYS                        <span class="comment">/* pt_regs-&gt;ax */</span></span><br><span class="line">    pushq   %r8                             <span class="comment">/* pt_regs-&gt;r8 */</span></span><br><span class="line">    pushq   %r9                             <span class="comment">/* pt_regs-&gt;r9 */</span></span><br><span class="line">    pushq   %r10                            <span class="comment">/* pt_regs-&gt;r10 */</span></span><br><span class="line">    pushq   %r11                            <span class="comment">/* pt_regs-&gt;r11 */</span></span><br><span class="line">    sub     $<span class="params">(<span class="number">6</span>*<span class="number">8</span>)</span>, %rsp                    <span class="comment">/* pt_regs-&gt;bp, bx, r12-15 not saved */</span></span><br><span class="line">    movq    <span class="title function_">PER_CPU_VAR</span><span class="params">(current_task)</span>, %r11</span><br><span class="line">    testl   $_TIF_WORK_SYSCALL_ENTRY|_TIF_ALLWORK_MASK, <span class="title function_">TASK_TI_flags</span><span class="params">(%r11)</span></span><br><span class="line">    jnz     entry_SYSCALL64_slow_path</span><br></pre></td></tr></table></figure>
<p>  各寄存器的作用如下所示：</p>
<ul>
<li>rax：系统调用数目</li>
<li>rcx：函数返回的用户空间地址</li>
<li>r11：寄存器标记</li>
<li>rdi：系统调用回调函数的第一个参数</li>
<li>rsi：系统调用回调函数的第二个参数</li>
<li>rdx：系统调用回调函数的第三个参数</li>
<li>r10：系统调用回调函数的第四个参数</li>
<li>r8 ：系统调用回调函数的第五个参数</li>
<li>r9 ：系统调用回调函数的第六个参数</li>
<li>rbp,rbx,r12-r15：通用的callee-preserved寄存器</li>
</ul>
<p>  在此之后，其实存在着两个处理分支：entry_SYSCALL64_slow_path 和 entry_SYSCALL64_fast_path，这里是根据_TIF_WORK_SYSCALL_ENTRY判断的结果进行选择，这里涉及到ptrace部分的知识，暂时先不介绍了，会在后面单独开一文详细研究。如果设置了_TIF_ALLWORK_MASK或者_TIF_WORK_SYSCALL_ENTRY，则跳转至slow_path，否则继续运行fast_path。</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">define</span> _TIF_WORK_SYSCALL_ENTRY \</span></span><br><span class="line"><span class="meta">    (_TIF_SYSCALL_TRACE | _TIF_SYSCALL_EMU | _TIF_SYSCALL_AUDIT |   \</span></span><br><span class="line"><span class="meta">    _TIF_SECCOMP | _TIF_SINGLESTEP | _TIF_SYSCALL_TRACEPOINT |     \</span></span><br><span class="line"><span class="meta">    _TIF_NOHZ)</span></span><br></pre></td></tr></table></figure>

<h4 id="2-2-1-fastpath分支"><a href="#2-2-1-fastpath分支" class="headerlink" title="2.2.1 fastpath分支"></a>2.2.1 fastpath分支</h4><p>  该分支主要分为以下部分内容</p>
<ul>
<li>再次检测TRACE部分，如果有标记则跳转至slow_path</li>
<li>检测__SYSCALL_MASK，如果CONFIG_X86_X32_ABI未设置我们就比较rax寄存器的值和最大系统调用数__NR_syscall_max，否则则标记eax寄存器为__x32_SYSCALL_BIT，再进行比较</li>
<li>ja指令会在CF和ZF设置为0时进行跳转，即如果不满足条件则会跳转至-ENOSYS，否则继续执行</li>
<li>将第四个参数从r10放入rcx以保持x86_64 C ABI编译</li>
<li>执行sys_call_table，去系统调用表中查找系统调用</li>
</ul>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">entry_SYSCALL_64_fastpath:</span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">     * Easy case: enable interrupts and issue the syscall.  If the syscall</span></span><br><span class="line"><span class="comment">     * needs pt_regs, we&#x27;ll call a stub that disables interrupts again</span></span><br><span class="line"><span class="comment">     * and jumps to the slow path.</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    TRACE_IRQS_ON</span><br><span class="line">    <span class="title function_">ENABLE_INTERRUPTS</span><span class="params">(CLBR_NONE)</span></span><br><span class="line">    </span><br><span class="line"><span class="meta">#<span class="keyword">if</span> __SYSCALL_MASK == ~0</span></span><br><span class="line">    cmpq	$__NR_syscall_max, %rax</span><br><span class="line"><span class="meta">#<span class="keyword">else</span></span></span><br><span class="line">    andl	$__SYSCALL_MASK, %eax</span><br><span class="line">    cmpl	$__NR_syscall_max, %eax</span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line"></span><br><span class="line">    ja	1f				<span class="comment">/* return -ENOSYS (already in pt_regs-&gt;ax) */</span></span><br><span class="line">    movq	%r10, %rcx</span><br><span class="line"></span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">    * This call instruction is handled specially in stub_ptregs_64.</span></span><br><span class="line"><span class="comment">    * It might end up jumping to the slow path.  If it jumps, RAX</span></span><br><span class="line"><span class="comment">    * and all argument registers are clobbered.</span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line">    call	*<span class="title function_">sys_call_table</span><span class="params">(, %rax, <span class="number">8</span>)</span></span><br><span class="line">    </span><br><span class="line">......</span><br><span class="line"><span class="meta"># <span class="keyword">ifdef</span> CONFIG_X86_X32_ABI</span></span><br><span class="line"><span class="meta">#  <span class="keyword">define</span> __SYSCALL_MASK (~(__X32_SYSCALL_BIT))</span></span><br><span class="line"><span class="meta"># <span class="keyword">else</span></span></span><br><span class="line"><span class="meta">#  <span class="keyword">define</span> __SYSCALL_MASK (~0)</span></span><br><span class="line"><span class="meta"># <span class="keyword">endif</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> __X32_SYSCALL_BIT    0x40000000</span></span><br></pre></td></tr></table></figure>

<h4 id="2-2-2-slow-path分支"><a href="#2-2-2-slow-path分支" class="headerlink" title="2.2.2 slow_path分支"></a>2.2.2 slow_path分支</h4><p>  slow_path部分的源码如下</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">entry_SYSCALL64_slow_path:</span><br><span class="line">    <span class="comment">/* IRQs are off. */</span></span><br><span class="line">    SAVE_EXTRA_REGS</span><br><span class="line">    movq    %rsp, %rdi</span><br><span class="line">    call    do_syscall_64           <span class="comment">/* returns with IRQs disabled */</span></span><br></pre></td></tr></table></figure>

<p>  slow_path会调用entry_SYSCALL64_slow_pat-&gt;do_syscall_64()，执行完毕后恢复寄存器，最后调用USERGS_SYSRET64，实际使用sysretq指令返回。</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">return_from_SYSCALL_64:</span><br><span class="line">    RESTORE_EXTRA_REGS</span><br><span class="line">    TRACE_IRQS_IRETQ</span><br><span class="line">    movq  <span class="title function_">RCX</span><span class="params">(%rsp)</span>, %rcx</span><br><span class="line">    movq  <span class="title function_">RIP</span><span class="params">(%rsp)</span>, %r11</span><br><span class="line">    movq  <span class="title function_">R11</span><span class="params">(%rsp)</span>, %r11</span><br><span class="line">......</span><br><span class="line">syscall_return_via_sysret:</span><br><span class="line">    <span class="comment">/* rcx and r11 are already restored (see code above) */</span></span><br><span class="line">    RESTORE_C_REGS_EXCEPT_RCX_R11</span><br><span class="line">    movq  <span class="title function_">RSP</span><span class="params">(%rsp)</span>, %rsp</span><br><span class="line">    USERGS_SYSRET64</span><br></pre></td></tr></table></figure>
<p>  在 do_syscall_64 里面，从 rax里面拿出系统调用号，然后根据系统调用号，在系统调用表 sys_call_table 中找到相应的函数进行调用，并将寄存器中保存的参数取出来，作为函数参数。</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">__visible <span class="type">void</span> <span class="title function_">do_syscall_64</span><span class="params">(<span class="keyword">struct</span> pt_regs *regs)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">thread_info</span> *<span class="title">ti</span> =</span> current_thread_info();</span><br><span class="line">    <span class="type">unsigned</span> <span class="type">long</span> nr = regs-&gt;orig_ax;</span><br><span class="line">......</span><br><span class="line">    <span class="keyword">if</span> (likely((nr &amp; __SYSCALL_MASK) &lt; NR_syscalls)) &#123;</span><br><span class="line">        regs-&gt;ax = sys_call_table[nr &amp; __SYSCALL_MASK](</span><br><span class="line">                    regs-&gt;di, regs-&gt;si, regs-&gt;dx,</span><br><span class="line">                    regs-&gt;r10, regs-&gt;r8, regs-&gt;r9);</span><br><span class="line">    &#125;</span><br><span class="line">    syscall_return_slowpath(regs);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>  至此，32位和64位又回到了同样的位置：查找系统调用表sys_call_table。</p>
<h2 id="三-系统调用表的生成"><a href="#三-系统调用表的生成" class="headerlink" title="三. 系统调用表的生成"></a>三. 系统调用表的生成</h2><p>  32位和64位的sys_call_table均位于arch&#x2F;x86&#x2F;entry&#x2F;syscalls&#x2F;目录下，分别为syscall_32.tbl和syscall_64.tbl。如下所示为32位和64位中open函数的定义</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="number">5</span> i386 open sys_open compat_sys_open</span><br><span class="line"></span><br><span class="line"><span class="number">2</span> common open sys_open</span><br></pre></td></tr></table></figure>
<p>  第一列的数字是系统调用号。可以看出，32 位和 64 位的系统调用号是不一样的。第三列是系统调用的名字，第四列是系统调用在内核的实现函数。不过，它们都是以 sys_ 开头。系统调用在内核中的实现函数要有一个声明。声明往往在 include&#x2F;linux&#x2F;syscalls.h文件中。例如 sys_open 是这样声明的：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">asmlinkage <span class="type">long</span> <span class="title function_">sys_open</span><span class="params">(<span class="type">const</span> <span class="type">char</span> __user *filename,</span></span><br><span class="line"><span class="params">                                <span class="type">int</span> flags, <span class="type">umode_t</span> mode)</span>;</span><br></pre></td></tr></table></figure>
<p>  真正的实现这个系统调用，一般在一个.c 文件里面，例如 sys_open 的实现在 fs&#x2F;open.c 里面。其中采用了宏的方式对函数名进行了封装，实际拆开是一样的。</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">SYSCALL_DEFINE3(open, <span class="type">const</span> <span class="type">char</span> __user *, filename, <span class="type">int</span>, flags, <span class="type">umode_t</span>, mode)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">if</span> (force_o_largefile())</span><br><span class="line">        flags |= O_LARGEFILE;</span><br><span class="line">    <span class="keyword">return</span> do_sys_open(AT_FDCWD, filename, flags, mode);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">......</span><br><span class="line"></span><br><span class="line">asmlinkage <span class="type">long</span> <span class="title function_">sys_open</span><span class="params">(<span class="type">const</span> <span class="type">char</span> __user * filename, <span class="type">int</span> flags, <span class="type">int</span> mode)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">long</span> ret;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">if</span> (force_o_largefile())</span><br><span class="line">        flags |= O_LARGEFILE;</span><br><span class="line">    </span><br><span class="line">    ret = do_sys_open(AT_FDCWD, filename, flags, mode);</span><br><span class="line">    asmlinkage_protect(<span class="number">3</span>, ret, filename, flags, mode);</span><br><span class="line">    <span class="keyword">return</span> ret;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>  其中SYSCALL_DEFINE3 是一个宏系统调用最多六个参数，根据参数的数目选择宏。具体是这样定义如下所示，首先使用SYSCALL_METADATA()宏解决syscall_metada结构体的初始化，该结构体包括了不同的有用区域包括系统调用的名字、系统调用表中对应的序号、系统调用的参数、参数类型链表等。</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">define</span> SYSCALL_DEFINE1(name, ...) SYSCALL_DEFINEx(1, _##name, __VA_ARGS__)</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> SYSCALL_DEFINE2(name, ...) SYSCALL_DEFINEx(2, _##name, __VA_ARGS__)</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> SYSCALL_DEFINE3(name, ...) SYSCALL_DEFINEx(3, _##name, __VA_ARGS__)</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> SYSCALL_DEFINE4(name, ...) SYSCALL_DEFINEx(4, _##name, __VA_ARGS__)</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> SYSCALL_DEFINE5(name, ...) SYSCALL_DEFINEx(5, _##name, __VA_ARGS__)</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> SYSCALL_DEFINE6(name, ...) SYSCALL_DEFINEx(6, _##name, __VA_ARGS__)</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> SYSCALL_DEFINEx(x, sname, ...)                          		\</span></span><br><span class="line"><span class="meta">        SYSCALL_METADATA(sname, x, __VA_ARGS__)                 		\</span></span><br><span class="line"><span class="meta">        __SYSCALL_DEFINEx(x, sname, __VA_ARGS__)</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> __PROTECT(...) asmlinkage_protect(__VA_ARGS__)</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> __SYSCALL_DEFINEx(x, name, ...)                                 \</span></span><br><span class="line"><span class="meta">        asmlinkage long sys##name(__MAP(x,__SC_DECL,__VA_ARGS__))       \</span></span><br><span class="line"><span class="meta">                __attribute__((alias(__stringify(SyS##name))));         \</span></span><br><span class="line"><span class="meta">        static inline long SYSC##name(__MAP(x,__SC_DECL,__VA_ARGS__));  \</span></span><br><span class="line"><span class="meta">        asmlinkage long SyS##name(__MAP(x,__SC_LONG,__VA_ARGS__));      \</span></span><br><span class="line"><span class="meta">        asmlinkage long SyS##name(__MAP(x,__SC_LONG,__VA_ARGS__))       \</span></span><br><span class="line"><span class="meta">        &#123;                                                               \</span></span><br><span class="line"><span class="meta">                long ret = SYSC##name(__MAP(x,__SC_CAST,__VA_ARGS__));  \</span></span><br><span class="line"><span class="meta">                __MAP(x,__SC_TEST,__VA_ARGS__);                         \</span></span><br><span class="line"><span class="meta">                __PROTECT(x, ret,__MAP(x,__SC_ARGS,__VA_ARGS__));       \</span></span><br><span class="line"><span class="meta">                return ret;                                             \</span></span><br><span class="line"><span class="meta">        &#125;                                                               \</span></span><br><span class="line"><span class="meta">        static inline long SYSC##name(__MAP(x,__SC_DECL,__VA_ARGS__)</span></span><br><span class="line"></span><br><span class="line">..........</span><br><span class="line">    </span><br><span class="line"><span class="meta">#<span class="keyword">define</span> SYSCALL_METADATA(sname, nb, ...)                             \</span></span><br><span class="line"><span class="meta">    ...                                                              \</span></span><br><span class="line"><span class="meta">    ...                                                              \</span></span><br><span class="line"><span class="meta">    ...                                                              \</span></span><br><span class="line"><span class="meta">    struct syscall_metadata __used                                   \</span></span><br><span class="line"><span class="meta">              __syscall_meta_##sname = &#123;                             \</span></span><br><span class="line"><span class="meta">                    .name           = <span class="string">&quot;sys&quot;</span>#sname,                   \</span></span><br><span class="line"><span class="meta">                    .syscall_nr     = -1,                            \</span></span><br><span class="line"><span class="meta">                    .nb_args        = nb,                            \</span></span><br><span class="line"><span class="meta">                    .types          = nb ? types_##sname : NULL,     \</span></span><br><span class="line"><span class="meta">                    .args           = nb ? args_##sname : NULL,      \</span></span><br><span class="line"><span class="meta">                    .enter_event    = &amp;event_enter_##sname,          \</span></span><br><span class="line"><span class="meta">                    .exit_event     = &amp;event_exit_##sname,           \</span></span><br><span class="line"><span class="meta">                    .enter_fields   = LIST_HEAD_INIT(__syscall_meta_##sname.enter_fields), 				   \</span></span><br><span class="line"><span class="meta">             &#125;;                                                                            																		\</span></span><br><span class="line"><span class="meta"></span></span><br><span class="line">    <span class="type">static</span> <span class="class"><span class="keyword">struct</span> <span class="title">syscall_metadata</span> __<span class="title">used</span>                            \</span></span><br><span class="line"><span class="class">              __<span class="title">attribute__</span>((<span class="title">section</span>(&quot;__<span class="title">syscalls_metadata</span>&quot;)))        \</span></span><br><span class="line"><span class="class">             *__<span class="title">p_syscall_meta_</span>##<span class="title">sname</span> =</span> &amp;__syscall_meta_#<span class="meta">#sname;</span></span><br></pre></td></tr></table></figure>
<p>  在编译的过程中，需要根据 syscall_32.tbl 和 syscall_64.tbl 生成自己的syscalls_32.h 和 syscalls_64.h。生成方式在 arch&#x2F;x86&#x2F;entry&#x2F;syscalls&#x2F;Makefile 中。这里面会使用两个脚本</p>
<p>第一个脚本arch&#x2F;x86&#x2F;entry&#x2F;syscalls&#x2F;syscallhdr.sh，会在文件中生成 #define __NR_open；</p>
<p>第二个脚本 arch&#x2F;x86&#x2F;entry&#x2F;syscalls&#x2F;syscalltbl.sh，会在文件中生成__SYSCALL(__NR_open, sys_open)。</p>
<p>这样最终生成syscalls_32.h 和 syscalls_64.h 就保存了系统调用号和系统调用实现函数之间的对应关系，如下所示</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">__SYSCALL_COMMON(<span class="number">0</span>, sys_read, sys_read)</span><br><span class="line">__SYSCALL_COMMON(<span class="number">1</span>, sys_write, sys_write)</span><br><span class="line">__SYSCALL_COMMON(<span class="number">2</span>, sys_open, sys_open)</span><br><span class="line">__SYSCALL_COMMON(<span class="number">3</span>, sys_close, sys_close)</span><br><span class="line">__SYSCALL_COMMON(<span class="number">5</span>, sys_newfstat, sys_newfstat)</span><br><span class="line">...</span><br><span class="line">...</span><br><span class="line">...</span><br></pre></td></tr></table></figure>
<p>  其中__SYSCALL_COMMON宏定义如下，主要是将对应的数字序号和系统调用名对应</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">define</span> __SYSCALL_COMMON(nr, sym, compat) __SYSCALL_64(nr, sym, compat)</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> __SYSCALL_64(nr, sym, compat) [nr] = sym,</span></span><br></pre></td></tr></table></figure>
<p>  最终形成的表如下</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">asmlinkage <span class="type">const</span> <span class="type">sys_call_ptr_t</span> sys_call_table[__NR_syscall_max+<span class="number">1</span>] = &#123;</span><br><span class="line">    [<span class="number">0</span> ... __NR_syscall_max] = &amp;sys_ni_syscall,</span><br><span class="line">    [<span class="number">0</span>] = sys_read,</span><br><span class="line">    [<span class="number">1</span>] = sys_write,</span><br><span class="line">    [<span class="number">2</span>] = sys_open,</span><br><span class="line">    ...</span><br><span class="line">    ...</span><br><span class="line">    ...</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>  最后，所有的系统调用会存储在arch&#x2F;x86&#x2F;entry&#x2F;目录下的syscall_32.c和syscall_64.c中，里面包含了syscalls_32.h 和 syscalls_64.h 头文件，其形式如下：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">__visible <span class="type">const</span> <span class="type">sys_call_ptr_t</span> ia32_sys_call_table[__NR_syscall_compat_max+<span class="number">1</span>] = &#123;</span><br><span class="line">        <span class="comment">/*</span></span><br><span class="line"><span class="comment">         * Smells like a compiler bug -- it doesn&#x27;t work</span></span><br><span class="line"><span class="comment">         * when the &amp; below is removed.</span></span><br><span class="line"><span class="comment">         */</span></span><br><span class="line">        [<span class="number">0</span> ... __NR_syscall_compat_max] = &amp;sys_ni_syscall,</span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;asm/syscalls_32.h&gt;</span></span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* System call table for x86-64. */</span></span><br><span class="line">asmlinkage <span class="type">const</span> <span class="type">sys_call_ptr_t</span> sys_call_table[__NR_syscall_max+<span class="number">1</span>] = &#123;</span><br><span class="line">  <span class="comment">/*</span></span><br><span class="line"><span class="comment">   * Smells like a compiler bug -- it doesn&#x27;t work</span></span><br><span class="line"><span class="comment">   * when the &amp; below is removed.</span></span><br><span class="line"><span class="comment">   */</span></span><br><span class="line">  [<span class="number">0</span> ... __NR_syscall_max] = &amp;sys_ni_syscall,</span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;asm/syscalls_64.h&gt;</span></span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>  其中__NR_syscall_max宏定义规定了最大系统调用数量，该数量取决于操作系统的架构，在X86下定义如下</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">define</span> __NR_syscall_max 547</span></span><br></pre></td></tr></table></figure>

<p>  这里还需要注意sys_call_ptr_t表示指向系统调用表的指针，定义为函数指针</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="title function_">void</span> <span class="params">(*<span class="type">sys_call_ptr_t</span>)</span><span class="params">(<span class="type">void</span>)</span>;</span><br></pre></td></tr></table></figure>
<p>  系统调用表数组中的每一个系统调用均会指向sys_ni_syscall，该函数表示一个未实现的系统调用（not-implement），从而系统调用表的初始化。</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">asmlinkage <span class="type">long</span> <span class="title function_">sys_ni_syscall</span><span class="params">(<span class="type">void</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">return</span> -ENOSYS;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">ENOSYS Function not <span class="title function_">implemented</span> <span class="params">(POSIX<span class="number">.1</span>)</span></span><br></pre></td></tr></table></figure>
<p>  由此，整个系统调用表的生成过程就全部说明完了，而在实际产生系统调用的时候，过程则刚好相反：</p>
<ul>
<li>用户态调用syscall</li>
<li>syscall导致中断，程序由用户态陷入内核态</li>
<li>内核C函数执行syscalls_32&#x2F;64.c，并由此获得对应关系最终在对应的源码中找到函数实现</li>
<li>针对对应的sys_syscall_name函数，做好调用准备工作，如初始化系统调用入口、保存寄存器、切换新的栈、构造新的task以备中断回调等。</li>
<li>调用函数实现</li>
<li>切换寄存器、栈，返回用户态</li>
</ul>
<h2 id="四-总结"><a href="#四-总结" class="headerlink" title="四. 总结"></a>四. 总结</h2><p>  本文较为深入的分析了系统调用的整个过程，并着重分析了系统调用表的形成和使用原理，如有遗漏错误还请多多指正。</p>
]]></content>
      <categories>
        <category>linux-doc</category>
      </categories>
      <tags>
        <tag>Linux</tag>
      </tags>
  </entry>
  <entry>
    <title>计算机Intel CPU体系结构分析</title>
    <url>/2023/01/15/linux-docs/%E8%AE%A1%E7%AE%97%E6%9C%BAIntel%20CPU%E4%BD%93%E7%B3%BB%E7%BB%93%E6%9E%84%E5%88%86%E6%9E%90/</url>
    <content><![CDATA[<p>前段meldown漏洞事件的影响，那段时间也正好在读Paul的论文关于内存屏障的知识，其中有诸多细节想不通，便陷入无尽的煎熬和冥想中，看了<strong>《计算机系统结构》、《深入理解计算机系统》、《大话处理器》</strong>等经典书籍，也在google上搜了一大堆资料，前前后后、断断续续地折腾了一个多月，终于想通了，现在把自己的思想心得记录下来，希望对有这方面困惑的朋友有些帮助。</p>
<p><strong>本文主要关注以下几个问题。</strong></p>
<ul>
<li>什么是CPU的流水线？为什么需要流水线？</li>
<li>为什么需要内存屏障？在只有单个Core的CPU中是否还需要内存屏障？</li>
<li>什么是乱序执行？分为几种？</li>
<li>MOB和ROB是干什么的？</li>
<li>load buffer和store buffer的功能是什么？</li>
<li>x86和arm、power中的memory model有什么区别？</li>
<li>MESI主要是做什么的？</li>
<li>meldown漏洞的原理是什么？</li>
</ul>
<h2 id="1、CPU指令的执行过程"><a href="#1、CPU指令的执行过程" class="headerlink" title="1、CPU指令的执行过程"></a>1、CPU指令的执行过程</h2><p>几乎所有的冯·诺伊曼型计算机的CPU，其工作都可以分为 5 个阶段：取指令、指令译码、执行指令、访存取数、结果写回。</p>
<p><img src="https://pic4.zhimg.com/80/v2-63100d63d3db8c0e7586460a16767be7_720w.webp" alt="img"></p>
<h3 id="1-1取指令阶段"><a href="#1-1取指令阶段" class="headerlink" title="1.1取指令阶段"></a>1.1取指令阶段</h3><p>取指令（Instruction Fetch，IF）阶段是将一条指令从主存中取到指令寄存器的过程。 程序计数器 PC 中的数值，用来指示当前指令在主存中的位置。当一条指令被取出后，PC 中的数值将根据指令字长度而自动递增：若为单字长指令，则(PC)+1-&gt;PC；若为双字长指令，则(PC)+2-&gt;PC，依此类推。</p>
<h3 id="1-2指令译码阶段"><a href="#1-2指令译码阶段" class="headerlink" title="1.2指令译码阶段"></a>1.2指令译码阶段</h3><p>取出指令后，计算机立即进入指令译码（Instruction Decode，ID）阶段。 在指令译码阶段，指令译码器按照预定的指令格式，对取回的指令进行拆分和解释，识别区分出不同的指令类别以及各种获取操作数的方法。在组合逻辑控制的计算机中，指令译码器对不同的指令操作码产生不同的控制电位，以形成不同的微操作序列；在微程序控制的计算机中，指令译码器用指令操作码来找到执行该指令的微程序的入口，并从此入口开始执行。 在传统的设计里，CPU中负责指令译码的部分是无法改变的。不过，在众多运用微程序控制技术的新型 CPU 中，微程序有时是可重写的。</p>
<h3 id="1-3执行指令阶段"><a href="#1-3执行指令阶段" class="headerlink" title="1.3执行指令阶段"></a>1.3执行指令阶段</h3><p>在取指令和指令译码阶段之后，接着进入执行指令（Execute，EX）阶段。 此阶段的任务是完成指令所规定的各种操作，具体实现指令的功能。为此，CPU 的不同部分被连接起来，以执行所需的操作。 例如，如果要求完成一个加法运算，算术逻辑单元 ALU 将被连接到一组输入和一组输出，输入端提供需要相加的数值，输出端将含有最后的运算结果。</p>
<h3 id="1-4访存取数阶段"><a href="#1-4访存取数阶段" class="headerlink" title="1.4访存取数阶段"></a>1.4访存取数阶段</h3><p>根据指令需要，有可能要访问主存，读取操作数，这样就进入了访存取数（Memory，MEM）阶段。 此阶段的任务是：根据指令地址码，得到操作数在主存中的地址，并从主存中读取该操作数用于运算。</p>
<h3 id="1-5结果写回阶段"><a href="#1-5结果写回阶段" class="headerlink" title="1.5结果写回阶段"></a>1.5结果写回阶段</h3><p>作为最后一个阶段，结果写回（Writeback，WB）阶段把执行指令阶段的<strong>运行结果</strong>数据“写回”到<strong>某种存储形式</strong>：结果数据经常被写到CPU<strong>内部寄存器</strong>中，以便<strong>被后续的指令快速地存取</strong>；在有些情况下， 结果数据<strong>也可被写入相对较慢、但较廉价且容量较大的主存</strong>。许多指令还会改变程序<strong>状态字寄存器中标志位</strong> 的状态，这些标志位标识着不同的操作结果，可被用来影响程序的动作。</p>
<p>在指令执行完毕、结果数据写回之后，若无意外事件（如结果溢出等）发生，计算机就接着从程序计数器PC中取得下一条指令地址，开始新一轮的循环，下一个指令周期将顺序取出下一条指令。</p>
<p>许多新型 CPU 可以同时取出、译码和执行多条指令，体现并行处理的特性。</p>
<h2 id="2、CPU指令流水线"><a href="#2、CPU指令流水线" class="headerlink" title="2、CPU指令流水线"></a>2、CPU指令流水线</h2><p>在任一条指令的执行过程中，各个功能部件都会随着指令执行的进程而呈现出时忙时闲的现象。要加快计算机的工作速度，就应使各个功能部件并行工作，即以各自可能的高速度同时、不停地工作，使得各部件的操作在时间上重叠进行，实现流水式作业。 从原理上说，计算机的流水线（Pipeline）工作方式就是将<strong>一个计算任务细分成若干个子任务</strong>，<strong>每个子任务都由专门的功能部件进行处理</strong>，一个计算任务的各个子任务由流水线上各个功能部件轮流进行处理 （即各子任务在流水线的各个功能阶段并发执行），最终完成工作。这样，<strong>不必等到上一个计算任务完成， 就可以开始下一个计算任务的执行</strong>。 流水线的硬件基本结构如图2所示。流水线由一系列串联的功能部件（Si）组成，各个功能部件之间设有高速缓冲寄存器（L），以暂时保存上一功能部件对子任务处理的结果，同时又能够接受新的处理任务。在一个统一的时钟（C）控制下，计算任务从功能部件的一个功能段流向下一个功能段。在流水线中， 所有功能段同时对不同的数据进行不同的处理，各个处理步骤并行地操作。</p>
<p><img src="https://pic2.zhimg.com/80/v2-e96a7181e97ce16f1f16db8b30197e25_720w.webp" alt="img"></p>
<p>当任务连续不断地输入流水线时，在流水线的输出端便连续不断地输出执行结果，流水线达到不间断流水的稳定状态，从而实现了<strong>子任务级的并行</strong>。</p>
<p>当指令流不能顺序执行时，流水过程会中断（即断流）。为了保证流水过程的工作效率，流水过程不应经常断流。在一个流水过程中，实现各个<strong>流水过程的各个功能段所需要的时间应该尽可能保持相等</strong>，以避免产生瓶颈，导致流水线断流。</p>
<p>流水线技术本质上是将一个<strong>重复的时序过程分解成若干个子过程</strong>，而每一个<strong>子过程都可有效地在其专用功能段上与其他子过程同时执行</strong>。采用流水线技术通过硬件实现并行操作后，就某一条指令而言，其执行速度并没有加快，但就程序执行过程的整体而言，程序执行速度大大加快。</p>
<p>流水线技术适合于大量的重复性的处理。</p>
<p>前面我提到过CPU 中一个指令周期的任务分解。假设指令周期包含取指令（IF）、指令译码（ID）、 指令执行（EX）、访存取数（MEM）、结果写回（WB）5 个子过程（过程段），流水线由这 5个串联的过程段 组成，各个过程段之间设有高速缓冲寄存器，以暂时保存上一个过程段的任务处理的结果，在统一的时钟信号控制下，数据从一个过程段流向相邻的过程段。</p>
<p><strong>非流水计算机的时空图如下:</strong></p>
<p><img src="https://pic4.zhimg.com/80/v2-7053dac68ed51ac513cbd48df2ab1577_720w.webp" alt="img"></p>
<h3 id="2-1标量流水计算机工作方式"><a href="#2-1标量流水计算机工作方式" class="headerlink" title="2.1标量流水计算机工作方式"></a>2.1标量流水计算机工作方式</h3><p>标量（Scalar）流水计算机是<strong>只有一条指令流水线</strong>的计算机。图4表示标量流水计算机的时空图。</p>
<p><img src="https://pic4.zhimg.com/80/v2-c9c14648d76880292638e94a17ff2cd3_720w.webp" alt="img"></p>
<p>当流水线满载时，<strong>每一个时钟周期可以执行 2 条以上的指令</strong>。因此，图5中仅用了 9 个时钟周期就完成了10条指令，<strong>每条指令平均用时 0.9 个时钟周期</strong>。 超标量流水计算机是时间并行技术和空间并行技术的综合应用。</p>
<h2 id="3、指令的相关性"><a href="#3、指令的相关性" class="headerlink" title="3、指令的相关性"></a>3、指令的相关性</h2><p>指令流水线的一个特点是流水线中的各条指令之间存在一些相关性，使得指令的执行受到影响。要使流水线发挥高效率，就要使流水线连续不断地流动，尽量不出现断流的情况。然而，由于<strong>流水过程中存在的相关性冲突，断流现象是不可避免的</strong>。</p>
<h3 id="3-1数据相关"><a href="#3-1数据相关" class="headerlink" title="3.1数据相关"></a>3.1数据相关</h3><p>在流水计算机中，指令的处理是重叠进行的，前一条指令还没有结束，第二、三条指令就陆续开始工 作。由于多条指令的重叠处理，当<strong>后继指令所需的操作数刚好是前一条指令的运算结果时，便发生数据相关冲突</strong>。由于这两条指令的执行顺序直接影响到操作系统读取的内容，必须等前一条指令执行完毕后才能执行后一条指令。在这种情况下，这两条指令就是与数据相关的。因此，<strong>数据相关是由于指令之间存在数据依赖性而引起的</strong>。根据指令间对同一寄存器读和写操作的先后次序关系，可将数据相关性分为<strong>写后读（Read-AfterWrite，RAW）相关、读后写（Write-After-Read，WAR）相关、写后写（Write-After-Write，WAW）相关</strong>三种类型。</p>
<p><strong>解决数据相关冲突的办法如下：</strong></p>
<p><strong>⑴采用编译的方法</strong> 编译程序通过在两条相关指令之间插入其他不相关的指令（或空操作指令）而推迟指令的执行，使数据相关消失，从而产生没有相关性的程序代码。这种方式简单，但降低了运行效率。</p>
<p><strong>⑵由硬件监测相关性的存在</strong>，采用数据旁路技术设法解决数据相关 当前一条指令要写入寄存器而下一条指令要读取同一个寄存器时，在前一条指令执行完毕、结果数据还未写入寄存器前，由内部数据通路把该结果数据直接传递给下一条指令，也就是说，下一条指令所需的 操作数不再通过读取寄存器获得，而是直接获取。这种方式效率较高，但控制也较为复杂。</p>
<h3 id="3-2资源相关"><a href="#3-2资源相关" class="headerlink" title="3.2资源相关"></a>3.2资源相关</h3><p>所谓资源相关，是指<strong>多条指令进入流水线后在同一机器周期内争用同一个功能部件</strong>所发生的冲突。 例如，在图 4所示的标量流水计算机中，<strong>在第 4 个时钟周期时，第 1 条指令处于访存取数（MEM） 阶段，而第 4 条指令处于取指令（IF）阶段</strong>。如果<strong>数据和指令存放在同一存储器中</strong>，<strong>且存储器只有一个端口</strong>，这样便会发生这两条指令争用存储器的资源相关冲突。 因为每一条指令都可能需要 2 次访问存储器（读指令和读写数据），在指令流水过程中，可能会有 2 条件同时需要访问存储器，导致资源相关冲突解决资源相关冲突的一般办法是增加资源，例如增设一个存储器，将指令和数据分别放在两个存储器中。</p>
<h3 id="3-3控制相关"><a href="#3-3控制相关" class="headerlink" title="3.3控制相关"></a>3.3控制相关</h3><p>控制相关冲突是由<strong>转移指令</strong>引起的。当执行转移指令时，依据转移条件的产生结果，可能顺序取下一 条指令，也可能转移到新的目标地址取指令。<strong>若转移到新的目标地址取指令，则指令流水线将被排空</strong>，并等待转移指令形成下一条指令的地址，以便读取新的指令，这就使得流水线发生断流。 为了减小转移指令对流水线性能的影响，通常采用以下两种转移处理技术：</p>
<p><strong>⑴延迟转移法</strong> 由<strong>编译程序重排指令序列来实现</strong>。其基本思想是“<strong>先执行再转移</strong>”，即发生转移时并不排空指令流水线，而是<strong>继续完成下几条指令</strong>。如果这些后继指令是与该转移指令结果无关的有用指令，那么延迟损失时间片正好得到了有效的利用。</p>
<p><strong>⑵转移预测法</strong> 用硬件的方法来实现。<strong>依据指令过去的行为来预测将来的行为</strong>，即<strong>选择出现概率较高的分支进行预取</strong>。通过使用转移取和顺序取两路指令选取队列以及目标指令 Cache，可将转移预测提前到取指令阶段进行，以获得良好的效果。</p>
<h2 id="4、指令的动态执行技术"><a href="#4、指令的动态执行技术" class="headerlink" title="4、指令的动态执行技术"></a>4、指令的动态执行技术</h2><h3 id="4-1指令调度"><a href="#4-1指令调度" class="headerlink" title="4.1指令调度"></a>4.1指令调度</h3><p>为了减少指令相关性对执行速度的影响，可以在保证程序正确性的前提下，调整指令的顺序，即进行指令调度。 指令调度<strong>可以由编译程序进行</strong>，<strong>也可以由硬件在执行的时候进行</strong>，分别称为<strong>静态指令调度</strong>和<strong>动态指令调度</strong>。<strong>静态指令调度是指编译程序通过调整指令的顺序来减少流水线的停顿</strong>，提高程序的执行速度；<strong>动态 指令调度用硬件方法调度指令的执行以减少流水线停顿</strong>。</p>
<p>流水线中一直采用的<strong>有序（in-order）指令启动是限制流水线性能的主要因素之一</strong>。如果有<strong>一条指令在流水线中停顿了，则其后的指令就都不能向前流动了</strong>，这样，如果相邻的两条指令存在相关性，流水线就将发生停顿，如果有多个功能部件，这些部件就有可能被闲置。消除这种限制流水线性能的因素从而提高指令执行速度，其<strong>基本思想就是允许指令的执行是无序的（out-of-order，也称乱序）</strong>，也就是说，<strong>在保持指令间、数据间的依赖关系的前提下，允许不相关的指令的执行顺序与程序的原有顺序有所不同</strong>，这一思想是实行动态指令调度的前提。</p>
<h3 id="4-2乱序执行技术"><a href="#4-2乱序执行技术" class="headerlink" title="4.2乱序执行技术"></a>4.2乱序执行技术</h3><p>乱序执行（Out-of-order Execution）是以乱序方式执行指令，即 CPU 允许将多条指令不按程序规定的顺序而分开发送给各相应电路单元进行处理。这样，根据各个电路单元的状态和各指令能否提前执行的具体情况分析，将能够提前执行的指令立即发送给相应电路单元予以执行，在这期间不按规定顺序执行指令；然后由<strong>重新排列单元将各执行单元的结果按指令顺序重新排列</strong>。乱序执行的目的，就是为了<strong>使 CPU 内部电路满负荷运转，并相应提高 CPU 运行程序的速度</strong>。</p>
<p>实现乱序执行的关键在于<strong>取消传统的“取指”和“执行”两个阶段之间指令需要线性排列的限制</strong>，而使用一个<strong>指令缓冲池</strong>来开辟一个较长的指令窗口，<strong>允许执行单元在一个较大的范围内调遣和执行已译码的程序指令流</strong>。</p>
<h3 id="4-3分支预测"><a href="#4-3分支预测" class="headerlink" title="4.3分支预测"></a>4.3分支预测</h3><p>分支预测（Branch Prediction）是对程序的流程进行预测，然后读取其中一个分支的指令。采用分支预测的主要目的是为了提高 CPU的运算速度。 <strong>分支预测的方法有静态预测和动态预测两类</strong>：静态预测方法比较简单，如预测永远不转移、预测永远转移、预测后向转移等等，它并不根据执行时的条件和历史信息来进行预测，因此预测的准确性不可能很高；<strong>动态预测</strong>方法则<strong>根据同一条转移指令过去的转移情况来预测未来的转移情况</strong>。 由于程序中的条件分支是根据程序指令在流水线处理后的结果来执行的，所以当 CPU 等待指令结果时， 流水线的前级电路也处于等待分支指令的空闲状态，这样必然出现时钟周期的浪费。如果 CPU 能在前条指令结果出来之前就预测到分支是否转移，那么就可以提前执行相应的指令，这样就避免了流水线的空闲等待，也就相应提高了 CPU 的运算速度。但另一方面，<strong>一旦前条指令结果出来后证明分支预测是错误的，那么就必须将已经装入流水线执行的指令和结果全部清除，然后再装入正确的指令重新处理，这样就比不进行分支预测而是等待结果再执行新指令还要慢了</strong>。</p>
<p>因此，<strong>分支预测的错误并不会导致结果的错误，而只是导致流水线的停顿</strong>，如果能够保持较高的预测 准确率，分支预测就能提高流水线的性能。</p>
<h2 id="5、实例分析"><a href="#5、实例分析" class="headerlink" title="5、实例分析"></a>5、实例分析</h2><p>前面的知识只是一个理论基础铺垫，下面我们就结合一款真实的CPU架构进行对应分析，图6和图7分别是x86和ARM体系结构的内核架构图（都是具有OoOE特性的CPU架构），可以看到他们基本的组成都是一样的（虽然x86是CISC而ARM是RISC，但是现代x86内部也是先把CISC翻译成RISC的），因此我在这里就只分析x86结构。</p>
<p><img src="https://pic2.zhimg.com/80/v2-0b6a85bd6005abb83d34d5d86a37c159_720w.webp" alt="img"></p>
<p><img src="https://pic4.zhimg.com/80/v2-f5c98a4a7652df95b7cae41e343f32db_720w.webp" alt="img"></p>
<h3 id="5-1取指令阶段（IF）"><a href="#5-1取指令阶段（IF）" class="headerlink" title="5.1取指令阶段（IF）"></a>5.1取指令阶段（IF）</h3><p>处理器在执行指令之前，必须先装载指令。指令会先保存在 L1 缓存的 I-cache (Instruction-cache)指令缓存当中，Nehalem指令拾取单元使用 128bit 带宽的通道从 I-cache 中读取指令。这个 I-cache 的大小为 32KB，采用了 4 路组相连，在后面的存取单元介绍中我们可以得知这种比 Core 更少的集合关联数量是为了降低延迟。</p>
<p>为了适应超线程技术，RIP(Relative Instruction Point，相对指令指针)的数量也从一个增加到了两个，每个线程单独使用一个。</p>
<p><img src="https://pic1.zhimg.com/80/v2-49c745b8dc93b9bc9eeed9a08c9d1148_720w.webp" alt="img"></p>
<p>指令拾取单元<strong>包含了分支预测器</strong>(Branch Predictor)，<strong>分支预测是在 Pentium Pro 处理器开始加入的功能，预测如 if then 这样的语句的将来走向</strong>，<strong>提前读取相关的指令并执行的技术</strong>，可以明显地提升性能。指令拾取单元<strong>也包含了 Hardware Prefetcher</strong>，<strong>根据历史操作预先加载以后会用到的指令来提高性能</strong>，这会在后面得到详细的介绍。</p>
<p>当分支预测器决定了走向一个分支之后，<strong>它使用 BTB(Branch Target Buffer，分支目标缓冲区)来保存预测指令的地址</strong>。Nehalem 从以前的一级 BTB 升级到了两个级别，这是为了适应很大体积的程序(数据库以及 ERP 等应用，跳转分支将会跨过很大的区域并具有很多的分支)。Intel 并没有提及 BTB 详细的结构。与BTB 相对的 RSB(Return Stack Buffer，返回堆栈缓冲区)也得到了提升，RSB 用来保存一个函数或功能调用结束之后的返回地址，通过<strong>重命名</strong>的 RSB 来避免多次推测路径导致的入口&#x2F;出口破坏。<strong>RSB 每个线程都有一个，一个核心就拥有两个，以适应超线程技术的存在</strong>。</p>
<p>指令拾取单元<strong>使用预测指令的地址来拾取指令</strong>，它通过访问 L1 ITLB 里的索引来继续访问 L1 ICache，128 条目的小页面 L1 ITLB 按照两个线程静态分区，每个线程可以获得 64 个条目，这个数目比 Core 2 地少。当关闭超线程时，单独的线程将可以获得全部的 TLB 资 源。除了小页面 TLB 之外，Nehalem 还每个线程拥有 7 个条目的全关联(Full Associativity) 大页面 ITLB，这些 TLB 用于访问 2M&#x2F;4M 的大容量页面，每个线程独立，因此关闭超线程不会让你得到 14 个大页面 ITLB 条目。</p>
<p>指令拾取单元通过 128bit 的总线将指令从 L1 ICache 拾取到一个 16Bytes(刚好就是 128bit)的预解码拾取缓冲区。128 位的带宽让人有些迷惑不解，Opteron 一早就已经使用 了 256bit 的指令拾取带宽。最重要的是，L1D 和 L1I 都是通过 256bit 的带宽连接到 L2 Cache 的。</p>
<p>由于一般的CISC x86指令都小于4Bytes（32位x86指令;x86指令的特点就是不等长)， 因此一次可以拾取 4 条以上的指令，而预解码拾取缓冲区的输出带宽是 6 指令每时钟周期， 因此可以看出指令拾取带宽确实有些不协调，特别是考虑到 64 位应用下指令会长一些的情 况下(解码器的输入输出能力是 4 指令每时钟周期，因此 32 位下问题不大)。</p>
<p><strong>指令拾取结束后会送到 18 个条目的指令队列</strong>，在 Core 架构，送到的是 LSD 循环流缓冲区，在后面可以看到，Nehalem 通过将 LSD 移动后更靠后的位置来提高性能。</p>
<h3 id="5-2指令译码阶段（ID）"><a href="#5-2指令译码阶段（ID）" class="headerlink" title="5.2指令译码阶段（ID）"></a>5.2指令译码阶段（ID）</h3><p>再将指令充填到可容纳 18 条目的指令队列之后，就可以进行解码工作了。解码是类 RISC (精简指令集或简单指令集)处理器导致的一项设计，从 Pentium Pro 开始在 IA 架构出现。 处理器接受的是 x86 指令(CISC 指令，复杂指令集)，而在执行引擎内部执行的却不是x86 指令，而是一条一条的类 RISC 指令，Intel 称之为 Micro Operation——micro-op，或者写 为 μ-op，一般用比较方便的写法来替代掉希腊字母:u-op 或者 uop。相对地，一条一条地 x86 指令就称之为 Macro Operation或 macro-op。</p>
<p><strong>RISC 架构的特点就是指令长度相等，执行时间恒定(通常为一个时钟周期)<strong>，因此处理器设计起来就很简单，可以通过深长的流水线达到很高的频率，IBM 的 Power6 就可以轻松地达到 4.7GHz 的起步频率。和 RISC 相反，</strong>CISC 指令的长度不固定，执行时间也不固定</strong>，因此 Intel 的 RISC&#x2F;CISC 混合处理器架构就要通过解码器 将 x86 指令翻译为 uop，从而<strong>获得 RISC 架构的长处，提升内部执行效率</strong>。</p>
<p>和 Core 一样，Nehalem 的解码器也是 4 个（3 个简单解码器加 1 个复杂解码器）。简单解码器可以将一条 x86 指令(包括大部分 SSE 指令在内)翻译为一条 uop，而复杂解码器则将一些特别的(单条)x86 指令翻译为 1~4 条 uops——在极少数的情况下，某些指令需要通过 额外的可编程 microcode 解码器解码为更多的 uops(有些时候甚至可以达到几百个，因为 一些 IA 指令很复杂，并且可以带有很多的前缀&#x2F;修改量，当然这种情况很少见)，下图 Complex Decoder 左方的 ucode 方块就是这个解码器，这个解码器可以通过一些途径进行升级或者扩展，实际上就是通过主板 Firmware 里面的 Microcode ROM 部分。</p>
<p>之所以具有两种解码器，是因为仍然是关于 RISC&#x2F;CISC 的一个事实: 大部分情况下(90%) 的时间内处理器都在运行少数的指令，其余的时间则运行各式各样的复杂指令(不幸的是， 复杂就意味着较长的运行时间)，RISC 就是将这些复杂的指令剔除掉，只留下最经常运行的指令(所谓的精简指令集)，然而被剔除掉的那些指令虽然实现起来比较麻烦，却在某些领域确实有其价值，RISC 的做法就是将这些麻烦都交给软件，CISC 的做法则是像现在这样: 由硬件设计完成。因此 RISC 指令集对编译器要求很高，而 CISC 则很简单。对编程人员的要求也类似。</p>
<p><img src="https://pic2.zhimg.com/80/v2-ac2a4396441f20d17b0609d3135ec7c5_720w.webp" alt="img"></p>
<h3 id="5-3循环流检测"><a href="#5-3循环流检测" class="headerlink" title="5.3循环流检测"></a>5.3循环流检测</h3><p>在解码为 uop 之后 Nehalem 会将它们都存放在一个叫做 uop LSD Buffer 的缓存区。在Core 2 上，这个 LSD Buffer 是出现在解码器前方的，Nehalem 将其移动到解码器后方，并相对加大了缓冲区的条目。Core 2 的 LSD 缓存区可以保存 18 个 x86 指令而 Nehalem 可以保 存 28 个 uop，从前文可以知道，<strong>大部分 x86 指令都可以解码为一个 uop，少部分可以解码 为 1~4 个 uop</strong>，因此 Nehalem 的 LSD 缓冲区基本上可以相当于保存 21~23 条x86 指令，比 Core 2 要大上一些。</p>
<p><img src="https://pic4.zhimg.com/80/v2-2a079f1da4cfc3206d8424efcae9055f_720w.webp" alt="img"></p>
<p>LSD 循环流监测器也包含在解码部分，它的作用是: <strong>假如程序使用的循环段(如 for..do&#x2F;do..while 等)少于 28 个 uops，那么 Nehalem 就可以将这个循环保存起来，不再需要重新通过取指单元、分支预测操作，以及解码器</strong>，Core 2 的 LSD 放在解码器前方，因此无法省下解码器的工作。</p>
<p>Nehalem LSD 的工作比较像 NetBurst 架构的 Trace Cache，其也是保存 uops，作用也是部分地去掉一些严重的循环，不过由于 Trace Cache 与此同时担当着类似于 Core&#x2F;Nehalem 架构的 Reorder Buffer 乱序缓冲区的作用，容量比较大(可以保存 12k uops，准确的大小 是 20KB)，因此在 cache miss 的时候后果严重(特别是在 SMT 同步多线程之后，miss 增加 倍的情况下)，LSD 的小数目设计显然会好得多。不过笔者认为 28 个 uop 条目有些少，特 别是考虑到 SMT 技术带来的两条线程都同时使用这个 LSD 的时候。</p>
<p>在 LSD 之后，Nehalem 将会进行 Micro-ops Fusion，这也是前端(The Front-End)的最后一个功能，在这些工作都做完之后，uops 就可以准备进入执行引擎了。</p>
<h3 id="5-4乱序执行指令阶段（OoOE）"><a href="#5-4乱序执行指令阶段（OoOE）" class="headerlink" title="5.4乱序执行指令阶段（OoOE）"></a>5.4乱序执行指令阶段（OoOE）</h3><p><strong>OoOE— Out-of-Order Execution 乱序执行也是在 Pentium Pro 开始引入的</strong>，它有些类似于多线程的概念。<strong>乱序执行是为了直接提升 ILP(Instruction Level Parallelism)指令级并行化的设计</strong>，在多个执行单元的超标量设计当中，一系列的执行单元可以<strong>同时运行</strong>一些<strong>没有数据关联性的若干指令</strong>，<strong>只有需要等待其他指令运算结果的数据会按照顺序执行</strong>，从而总体提升了运行效率。乱序执行引擎是一个很重要的部分，需要进行复杂的调度管理。</p>
<p>首先，在乱序执行架构中，<strong>不同的指令可能都会需要用到相同的通用寄存器(GPR，General Purpose Registers)<strong>，特别是在指令需要改写该通用寄存器的情况下——为了让这些指令们能并行工作，处理器需要准备解决方法。一般的 <strong>RISC 架构准备了大量的GPR</strong>， 而</strong>x86 架构天生就缺乏 GPR</strong>(x86具有8个GPR，x86-64 具有 16 个，一般 RISC 具有 32 个，IA64 则具有 128 个)，为此 Intel 开始引入**重命名寄存器(Rename Register)**，不同的指令可以通过具有名字相同但实际不同的寄存器来解决。</p>
<p>此外，为了 SMT 同步多线程，这些寄存器还要准备双份，每个线程具有独立的一份。</p>
<p><img src="https://pic1.zhimg.com/80/v2-2aeaa12d26252a3f51a6f566e8049a98_720w.webp" alt="img"></p>
<p>乱序执行从Allocator定位器开始，<strong>Allocator 管理着RAT(Register Alias Table，寄存器别名表)<strong>、</strong>ROB(Re-Order Buffer，重排序缓冲区)<strong>和 <strong>RRF(Retirement Register File，退回寄存器文件)<strong>。在 <strong>Allocator 之前，流水线都是顺序执行的</strong>，在 <strong>Allocator 之后，就可以进入乱序执行阶段了</strong>。在每一个线程方面，Nehalem 和 Core 2 架构相似，</strong>RAT 将重命名的、虚拟的寄存器(称为 Architectural Register 或 Logical Register)指向ROB 或者RRF</strong>。</strong>RAT 是一式两份,每个线程独立</strong>，<strong>每个 RAT 包含了 128 各重命名寄存器</strong>。<strong>RAT 指向在 ROB 里面的最近的执行寄存器状态，或者指向RRF保存的最终的提交状态。</strong></p>
<p><strong>ROB(Re-Order Buffer，重排序缓冲区)<strong>是一个非常重要的部件，</strong>它是将乱序执行完毕的指令们按照程序编程的原始顺序重新排序的一个队列</strong>，以<strong>保证所有的指令都能够逻辑上实现正确的因果关系</strong>。<strong>打乱了次序的指令们(分支预测、硬件预取)依次插入这个队列</strong>，当一条指令通过 RAT 发往下一个阶段确实执行的时候这条指令(包括寄存器状态在内)将被加入 ROB 队列的一端，<strong>执行完毕的指令(包括寄存器状态)将从 ROB 队列的另一端移除(期间这些指令的数据可以被一些中间计算结果刷新)<strong>，因为</strong>调度器是 In-Order 顺序的，这个队列（ROB）也就是顺序的</strong>。<strong>从 ROB 中移出一条指令就意味着指令执行完毕了，这个阶段叫做 Retire 回退</strong>，相应地 ROB 往往也叫做 Retirement Unit(回退单元)，并将其画为<strong>流水线的最后一部分</strong>。</p>
<p>在一些超标量设计中，<strong>Retire 阶段会将 ROB 的数据写入 L1D 缓存（这是将MOB集成到ROB的情况）</strong>，而在另一些设计里， <strong>写入 L1D 缓存由另外的队列完成</strong>。例如，Core&#x2F;Nehalem 的这个操作就由 **MOB(Memory Order Buffer，内存重排序缓冲区)**来完成。</p>
<p>ROB 是乱序执行引擎架构中都存在的一个缓冲区，<strong>重新排序指令的目的是将指令们的寄存器状态依次提交到RRF退回寄存器文件当中</strong>，<strong>以确保具有因果关系的指令们在乱序执行中可以得到正确的数据</strong>。<strong>从执行单元返回的数据会将先前由调度器加入ROB 的指令刷新数据部分</strong>并<strong>标志为结束(Finished)<strong>，再经过其他检查通过后才能</strong>标志为完毕(Complete)<strong>，</strong>一旦标志为完毕，它就可以提交数据并删除重命名项目并退出ROB 了</strong>。提交状态的工作由 Retirement Unit(回退单元)完成，<strong>它将确实完毕的指令包含的数据写入RRF(“确实” 的意思是，非猜测执性、具备正确因果关系，程序可以见到的最终的寄存器状态)<strong>。和 RAT 一样，</strong>RRF 也同时具有两个，每个线程独立。</strong>Core&#x2F;Nehalem 的 Retirement Unit 回退单元每时钟周期可以执行 4 个 uops 寄存器文件写入，和 RAT 每时钟 4 个 uops 的重命名一致。</p>
<p>由于 ROB 里面保存的指令数目是如此之大(128 条目)，因此一些人认为它的作用是用来从中挑选出不相关的指令来进入执行单元，这多少是受到一些文档中的 Out-of-Order Window 乱序窗口这个词的影响(后面会看到ROB 会和 MOB 一起被计入乱序窗口资源中)。</p>
<p>ROB 确实具有 RS 的一部分相似的作用，不过，<strong>ROB 里面的指令是调度器（dispacher）通过 RAT发往 RS 的同时发往ROB的（里面包含着正常顺序的指令和猜测执行的指令，但是乱序执行并不是从ROB中乱序挑选的），也就是说，在“乱序”之前，ROB 的指令就已经确定了</strong>。<strong>指令并不是在 ROB 当中乱序挑选的(这是在RS当中进行)，ROB 担当的是流水线的最终阶段: 一个指令的 Retire回退单元;以及担当中间计算结果的缓冲区。</strong><br><strong>RS(Reservation Station，中继站): 等待源数据</strong>到来以进行OoOE乱序执行(<strong>没有数据的指令将在 RS 等待</strong>)， <strong>ROB(ReOrder Buffer，重排序缓冲区): 等待结果到达</strong>以进行 Retire 指令回退 (<strong>没有结果的指令将在 ROB等待</strong>)。</p>
<p>Nehalem 的 128 条目的 <strong>ROB 担当中间计算结果的缓冲区</strong>，<strong>它保存着猜测执行的指令及其数据</strong>，<strong>猜测执行允许预先执行方向未定的分支指令</strong>。在大部分情况下，猜测执行工作良好——<strong>分支猜对了，因此其在 ROB 里产生的结果被标志为已结束，可以立即地被后继指令使用而不需要进行 L1 Data Cache 的 Load 操作</strong>(这也是 ROB 还有另一个重要用处，典型的 x86 应用中 <strong>Load 操作是如此频繁</strong>，达到了几乎占 1&#x2F;3 的地步，<strong>因此 ROB 可以避免大量的Cache Load 操作，作用巨大</strong>)。在剩下的不幸的情况下，分支<strong>未能按照如期的情况进行</strong>，这时猜测的<strong>分支指令段将被清除</strong>，相应指令们的<strong>流水线阶段清空</strong>，对应的<strong>寄存器状态也就全都无效</strong>了，这种<strong>无效的寄存器状态不会也不能出现在 RRF 里面。</strong></p>
<p>重命名技术并不是没有代价的，在获得前面所说的众多的优点之后，它令指令在发射的时候需要扫描额外的地方来寻找到正确的寄存器状态，不过总体来说这种代价是非常值得的。RAT可以在每一个时钟周期重命名 4 个 uops 的寄存器，<strong>经过重命名的指令在读取到正确的操作数并发射到统一的RS(Reservation Station，中继站，Intel 文档翻译为保留站点) 上。RS 中继站保存了所有等待执行的指令。</strong></p>
<p>和 Core 2 相比，Nehalem 的 ROB 大小和 RS 大小都得到了提升，ROB 重排序缓冲区从 96 条目提升到 128 条目(鼻祖 Pentium Pro 具有 40 条)，RS 中继站从 32 提升到 36(Pentium Pro 为 20)，它们都在两个线程(超线程中的线程)内共享，不过采用了不同的策略:ROB 是采用了静态的分区方法，而 RS 则采用了动态共享，因为有时候会有一条线程内的指令因 等待数据停滞，这时另一个线程就可以获得更多的 RS 资源。停滞的指令不会发现 RS，但是仍然会占用 ROB 条目。由于 ROB 是静态分区，因此在开启 HTT 在这情况下，每一个线程只能 分到 64 条，不算多，在一些极少数的应用上，我们应该可以观察到一些应用开启 HTT 后悔 速度降低，尽管可能非常微小。</p>
<h3 id="5-5执行单元"><a href="#5-5执行单元" class="headerlink" title="5.5执行单元"></a>5.5执行单元</h3><p>在为 SMT 做好准备工作并打乱指令的执行顺序之后（指的是分支预测、硬件预取），uops 通过每时钟周期 4 条的速度进入 Reservation Station 中继站(保留站)，总共 36 条目的中继站 uops 就开始等待超标量(Superscaler)执行引擎乱序执行了。自从 Pentium 开始，Intel 就开始在处理器里面采用了超标量设计(Pentium 是两路超标量处理器)，<strong>超标量的意思就是多个执行单元</strong>，它可以<strong>同时执行多条没有相互依赖性的指令</strong>，从而达到提升 <strong>ILP 指令级别并行化</strong>的目的。Nehalem 具备 6 个执行端口，每个执行端口具有多个不同的单元以执行不同的任务，然而同一时间只能有一条指令(uop)进入执行端口，因此也可以认为 Nehalem 有 6 个“执行单元”，在每个时钟周期内可以执行最多 6 个操作(或者说，6 条指令)，和 Core 一样。</p>
<p><img src="https://pic1.zhimg.com/80/v2-0a719f329b1307641861bb5a3ab00fc8_720w.webp" alt="img"></p>
<p>36 条目的中继站指令在分发器的管理下，<strong>挑选出尽量多的可以同时执行的指令(也就是乱序执行的意思)<strong>——最多 6 条——发送到执行端口。 这些执行端口并</strong>不都是用于计算</strong>，实际上，<strong>有三个执行端口是专门用来执行内存相关的操作的，只有剩下的三个是计算端口</strong>，因此，在这一点上 Nehalem 实际上是跟 Core 架构一 样的，这也可以解释为什么有些情况下，Nehalem 和 Core 相比没有什么性能提升。</p>
<p><strong>计算操作分为两种</strong>: 使用 ALU(Arithmetic Logic Unit，算术逻辑单元)的<strong>整数(Integer) 运算</strong>和使用 FPU(Floating Point Unit，浮点运算单元)的<strong>浮点(Floating Point)运算</strong>。SSE 指令(包括 SSE1 到 SSE4)是一种特例，它虽然有整数也有浮点，然而它们使用的都是 128bit 浮点寄存器，使用的也大部分是 FPU 电路。在 Nehalem 中，三个计算机端口都可以做整数运算(包括 MMX)或者SSE 运算(浮点运算不太一样，只有两个端口可以进行浮点 ADD 和 MUL&#x2F;DIV 运算，因此每个时钟周期最多进行 2 个浮点计算，这也是目前 Intel 处理器浮点性能不如整数性能突出的原因)，不过每一个执行端口都不是完全一致:只有端口 0 有浮点乘和除功能，<strong>只有端口 5 有分支能力(这个执行单元将会与分支预测单元连接)<strong>，其他 FP&#x2F;SSE 能力也不尽相同，这些不对称之处都由统一的分发器来理解，并进行指令的调度管理。</strong>没有采用完全对称的设计可能是基于统计学上的考虑</strong>。和 Core 一样，Nehalem 的也没有采用 Pentium 4 那样的 2 倍频的 ALU 设计(在 Pentium 4，ALU 的运算频率是 CPU 主频的两倍， 因此整数性能明显要比浮点性能突出)。</p>
<p>不幸的是，虽然可以同时执行的指令很多，然而在流水线架构当中运行速度并不是最 “宽”的单元来决定的，而是由最“窄”的单元来决定的。这就是木桶原理，Opteron的解码器后端只能每时钟周期输出 3 条 uops，而 Nehalem&#x2F;Core2 则能输出 4 条，因此它们的实际最大每时钟运行指令数是 3&#x2F;4，而不是 6。同样地，多少路超标量在这些乱序架构处理器中也不再按照运算单元来划分，Core Duo 及之前(到 Pentium Pro 为止)均为三路超标量处理器，Core 2&#x2F;Nehalem 则为四路超标量处理器。可见在微架构上，Nehalem&#x2F;Core 显然是 要比其他处理器快一些。顺便说一下，这也是 Intel 在超线程示意图中，使用 4 个宽度的方 块来表示而不是 6 个方块的原因。</p>
<h3 id="5-6存取单元"><a href="#5-6存取单元" class="headerlink" title="5.6存取单元"></a>5.6存取单元</h3><p>运算需要用到数据，也会生成数据，<strong>这些数据存取操作就是存取单元所做的事情</strong>，实际 上，Nehalem 和 Core 的存取单元没什么变化，仍然是 3 个。</p>
<p>这<strong>三个存取单元</strong>中，<strong>一个用于所有的 Load 操作(地址和数据)，一个用于 Store 地址，一个用于 Store 数据</strong>，前两个与数据相关的单元带有 AGU(Address Generation Unit，地址生成单元)功能(NetBurst架构使用快速 ALU 来进行地址生成)。</p>
<p><img src="https://pic2.zhimg.com/80/v2-7c84a0e256be51660725149645db76f9_720w.webp" alt="img"></p>
<p>在乱序架构中，<strong>存取操作也可以打乱进行</strong>。<strong>类似于指令预取一样</strong>，<strong>Load&#x2F;Store 操作也可以提前进行以降低延迟的影响，提高性能</strong>。然而，<strong>由于Store操作会修改数据影响后继的Load 操作，而指令却不会有这种问题(寄存器依赖性问题通过ROB解决)，因此数据的乱序操作更为复杂。</strong></p>
<p><img src="https://pic2.zhimg.com/80/v2-14b4639b8fe33990f1fe3ad1da9e98d9_720w.webp" alt="img"></p>
<p>如上图所示，第一条 ALU 指令的运算结果要 Store 在地址 Y(第二条指令)，而第九条 指令是从地址 Y Load 数据，显然在第二条指令执行完毕之前，无法移动第九条指令，否则将会产生错误的结果。同样，如果CPU也不知道第五条指令会使用什么地址，所以它也无法确定是否可以把第九条指令移动到第五条指令附近。</p>
<p><img src="https://pic3.zhimg.com/80/v2-3dd0067135e1be6734ac3355091a483e_720w.webp" alt="img"></p>
<p><strong>内存数据相依性预测功能(Memory Disambiguation)可以预测哪些指令是具有依赖性的或者使用相关的地址(地址混淆，Alias)<strong>，</strong>从而决定哪些 Load&#x2F;Store 指令是可以提前的</strong>， 哪些是不可以提前的。<strong>可以提前的指令在其后继指令需要数据之前就开始执行、读取数据到ROB当中</strong>，<strong>这样后继指令就可以直接从中使用数据，从而避免访问了无法提前 Load&#x2F;Store 时访问 L1 缓存带来的延迟(3~4 个时钟周期)。</strong></p>
<p>不过，为了<strong>要判断一个 Load 指令所操作的地址没有问题，缓存系统需要检查处于 in-flight 状态(处理器流水线中所有未执行的指令)的 Store 操作</strong>，这是一个耗费资源的过程。在 NetBurst 微架构中，通过<strong>把一条 Store 指令分解为两个 uops——一个用于计算地址、一个用于真正的存储数据，这种方式可以提前预知 Store 指令所操作的地址</strong>，初步地<strong>解决了数据相关性问题</strong>。在 NetBurst 微架构中，Load&#x2F;Store 乱序操作的算法遵循以下几条 原则:</p>
<ul>
<li>如果一个对于<strong>未知地址</strong>进行操作的 Store 指令处于 in-flight 状态，那么所有的人 Load 指令都要被延迟</li>
<li>在操作<strong>相同地址</strong>的 Store 指令之前 Load 指令不能继续执行</li>
<li>一个 <strong>Store 指令不能移动到另外一个地方 Store 指令之前（指的是在RS中不能先挑选执行后面的一条store指令，注意这只是说某一种架构不允许重排store，其实还是有很多架构如Alpha等是松散内存模型，允许不相关的store重排序的，这一块就牵扯到memory models知道相关知识了，建议参考这里）</strong></li>
</ul>
<p>这种原则下的问题也很明显，比如第一条原则会在一条处于等待状态的 Store 指令所操作的地址未确定之前，就延迟所有的时间 Load 操作，显然<strong>过于保守了</strong>。实际上，<strong>地址冲突问题是极少发生的</strong>。根据某些机构的研究，在一个Alpha EV6 处理器中最多可以允许 512 条指令处于 in-flight 状态，但是其中的 97%以上的 Load 和 Store 指令都不会存在地址冲突问题。<br>基于这种理念，<strong>Core 微架构采用了大胆的做法</strong>，<strong>它令 Load 指令总是提前进行</strong>，除非新加入的动态混淆预测器(Dynamic Alias Predictor)预测到了该 Load 指令不能被移动到 Store 指令附近。这个预测是根据历史行为来进行的，据说准确率超过 90%。<br><strong>在执行了预 Load 之后，一个冲突监测器会扫描出来 MOB 的 Store 队列</strong>，检查该<strong>是否有Store操作与该 Load 冲突</strong>。在很不幸的情况下(1%<del>2%)，<strong>发现了冲突，那么该 Load 操作作废</strong>、 <strong>流水线清除并重新进行 Load 操作</strong>。这样大约会损失 20 个时钟周期的时间，然而从整体上看， Core 微架构的激进 Load&#x2F;Store 乱序策略确实很有效地提升了性能，因为<strong>Load 操作占据了通常程序的 1&#x2F;3 左右，并且 Load 操作可能会导致巨大的延迟</strong>(在命中的情况下，Core 的 L1D Cache 延迟为 3 个时钟周期，Nehalem 则为 4 个。L1 未命中时则会访问 L2 缓存，一般为 10</del>12 个时钟周期。访问 L3 通常需要 30~40 个时钟周期，访问主内存则可以达到最多约 100 个时钟周期)。<strong>Store 操作并不重要，什么时候写入到 L1 乃至主内存并不会影响到执行性能。</strong></p>
<p><img src="https://pic1.zhimg.com/80/v2-49e087508bedc82b3e47b0acd1fc896c_720w.webp" alt="img"></p>
<p>如上图所示，我们需要载入地址 X 的数据，加 1 之后保存结果;载入地址 Y 的数据，加1 之后保存结果;载入地址 Z 的数据，加 1 之后保存结果。如果根据 Netburst 的基本准则， 在第三条指令未决定要存储在什么地址之前，处理器是不能移动第四条指令和第七条指令的。实际上，它们之间并没有依赖性。因此，Core 微架构中则<strong>“大胆”的将第四条指令和第七条指令分别移动到第二和第三指令的并行位置</strong>，这种行为是<strong>基于一定的猜测的基础上的“投机”行为，如果猜测的对的话(几率在 90%以上)，完成所有的运算只要5个周期，相比之前的9个周期几乎快了一倍。</strong></p>
<p>和为了顺序提交到寄存器而需要 ROB 重排序缓冲区的存在一样，在乱序架构中，多个<strong>打乱了顺序的 Load 操作和Store操作也需要按顺序提交到内存</strong>，<strong>MOB(Memory Reorder Buffer， 内存在重排序缓冲区)就是起到这样一个作用的重排序缓冲区</strong>(介于 Load&#x2F;Store 单元 与 L1D Cache 之间的部件，有时候也称之为LSQ)，MOB 通过一个 128bit 位宽的 Load 通道与一个 128bit 位宽的 Store 通道与双口 L1D Cache 通信。<strong>和 ROB 一样，MOB的内容按照 Load&#x2F;Store 指令实际的顺序加入队列的一端</strong>，<strong>按照提交到 L1 DCache 的顺序从队列的另一端移除</strong>。ROB 和 MOB 实际上形成了一个分布式的 Order Buffer 结构，有些处理器上只存在 ROB，兼备了 MOB 的功能（把MOB看做ROB的一部分可能更好理解）。</p>
<p>和ROB 一样，<strong>Load&#x2F;Store 单元的乱序存取操作会在 MOB 中间按照原始程序顺序排列</strong>，以提供正确的数据，<strong>内存数据依赖性检测功能也在里面实现(内存数据依赖性的检测比指令寄存器间的依赖性检测要复杂的多)<strong>。</strong>MOB 的 Load&#x2F;Store 操作结果也会直接反映到 ROB当中（中间结果）</strong>。</p>
<p><strong>MOB还附带了数据预取(Data Prefetch)功能</strong>，它会<strong>猜测未来指令会使用到的数据</strong>，并<strong>预先从L1D Cache 缓存 Load入MOB 中</strong>(Data Prefetcher 也会对 L2 至系统内存的数据进行这样的操作)， <strong>这样 MOB 当中的数据有些在 ROB 中是不存在的</strong>(这有些像 ROB 当中的 Speculative Execution 猜测执行，MOB 当中也存在着“Speculative Load Execution 猜测载入”，<strong>只不过失败的猜测执行会导致管线停顿，而失败的猜测载入仅仅会影响到性能，然而前端时间发生的Meltdown漏洞却造成了严重的安全问题</strong>)。<strong>MOB包括了Load Buffers和Store Buffers。</strong></p>
<p>在秩序执行中我们可以看到很多缓冲区性质的东西: <strong>RAT 寄存器别名表、ROB 重排序缓冲 区、RS 中继站、MOB 内存重排序缓冲区(包括 load buffer 载入缓冲和 store buffer 存储缓冲)<strong>。在</strong>超线程</strong>的作 用下，<strong>RAT是一式两份</strong>，包含了 128 重命名寄存器; 128 条目的 ROB、48 条目的 LB 和 32 条目的 SB 都 每个线程 64 个 ROB、24 个 LB 和 16 个 SB; <strong>RS 则是在两个线程中动态共享</strong>。可见，虽然整体数量增加了，然而就单个线程而言，获得的资源并没有 提升。这会影响到 HTT 下单线程下的性能。</p>
<h2 id="6、缓存（cache）"><a href="#6、缓存（cache）" class="headerlink" title="6、缓存（cache）"></a>6、缓存（cache）</h2><p>通常缓存具有两种设计:非独占和独占，Nehalem 处理器的 L3 采用了非独占高速缓存 设计(或者说“包含式”，L3 包含了 L1&#x2F;L2 的内容)，这种方式在 Cache Miss 的时候比独 占式具有更好的性能，而在缓存命中的时候需要检查不同的核心的缓存一致性。Nehalem 并 采用了“内核有效”数据位的额外设计，降低了这种检查带来的性能影响。随着核心数目的 逐渐增多(多线程的加入也会增加 Cache Miss 率)，对缓存的压力也会继续增大，因此这 种种方式会比较符合未来的趋势。在后面可以看到，这种设计也是考虑到了多处理器协作的情况(此时 Miss 率会很容易地增加)。这可以看作是 Nehalem 与以往架构的基础不同:之前的架构都是来源于移动处理设计，而 Nehalem 则同时为企业、桌面和移动考虑而设计。</p>
<p>在 L3 缓存命中的时候(单处理器上是最通常的情况，多处理器下则不然)，处理器检查内核有效位看看是否其他内核也有请求的缓存页面内容，决定是否需要对内核进行侦听。</p>
<p>在NUMA架构中，多个处理器中的同一个缓存页面必定在其中一个处理器中属于 F 状态(可以修改的状态)，这个页面在这个处理器中没有理由不可以多核心共享(可以多核心共享就意味着这个能进入修改状态的页面的多个有效位被设置为一)。MESIF协议应该是工作在核心(L1+L2)层面而不是处理器(L3)层面，这样同一处理器里多个核心共享的页面，只有其中一个是出于 F 状态(可以修改的状态)。见后面对 NUMA 和 MESIF 的解析。(L1&#x2F;L2&#x2F;L3 同步应该是不需要 MESIF 的同步机制)</p>
<p>在 L3 缓存未命中的时候(多数处理器下会频繁发生)，处理器决定进行内存存取，按照 页面的物理位置，它分为近端内存存取(本地内存空间)和远端内存存取(地址在其他处理 器的内存的空间):</p>
<p>关于缓存Cache架构原理和Cache一致性MESI的原理不是本文的重点，此处不再赘述。</p>
<h2 id="7、总结"><a href="#7、总结" class="headerlink" title="7、总结"></a>7、总结</h2><p>之前一直存在疑惑是因为看了Paul的论文，有两点，一个是CPU在猜测执行时，如果猜测乱序执行的是一条store指令，并且store指令要操作的地址和之前正处于in-flight状态的store指令没有相关关系，那么意味着这条猜测执行的store会直接更新DCache，如果后期发现猜测执行错误，那么此时是没有办法回滚的（因为数据已经写入DCache），而对于猜测执行的load就不会造成这么严重的问题，顶多就是提前把主内存的内容读到DCache中（但是前段时间发生的<strong>Meltdown漏洞</strong>就是利用了该特性）；第二个疑问就是，类似于x86手册中说了store指令（参见memory model）是不允许重排执行的，那还会还会存在Paul的论文所描述的问题现象（讲store store barrier那里）吗，理论上store指令都是顺序提交结果到内存的。</p>
<p>对于第一个疑惑，其答案就是，处于猜测执行阶段的store指令是<strong>不允许提交</strong>的（commit）,因为猜测执行之前的代码还没有提交（时刻记住 <strong>按顺序执行、按顺序提交</strong> 贯穿全文），而一旦猜测执行之前的代码提交，也就可以验证猜测执行是否成功，此时如果猜测成功就执行commit，store数据到DCache（但是还是允许提前load数据到DCache），否则就直接丢弃猜测执行的结果（直接丢弃load buffer里面的数据）。也有些CPU架构中，对于store类型的指令是不允许猜测执行的，因此也不会有问题。</p>
<p>对于第二个疑惑，对于允许store重排的CPU架构来说，虽然内存读写指令在RS、MOB中都是按照编程顺序存放的，但是对于前后两条不相关的store指令而言，store指令就会乱序执行，但是虽然可以乱序执行（执行的结果反映在MOB中），但是依然必须<strong>顺序提交MOB中的结果</strong>。而对于x86这种不允许store重排的CPU而言，store只能按顺序执行，并且在MOB中被标记，并等待顺序提交。进入提交阶段后，MOB中store buffer中的store直连会按照编程顺序一条一条进行提交（即写数据到DCache），但是如果前一条store指令操作的数据不在本地cahce中，此时该store指令就无法被立即写入DCache，需要等待cache层MESI协议把数据同步过来，这是相当耗时的。而如果恰巧后一条store指令（前提是与前一条store不存在地址冲突）操作的数据就在本地cache中，此时如果允许后一条store指令先提交（这样可以大大的降低CPU的等待时间），则就会出现store乱序的问题（Paul的论文描述的现象，注意，这并不是真正的store乱序，store结果依然还是按照编程顺序进行提交的）。因此，如果这个结果正好违背业务逻辑，解决方式就是显示的在两条store之间添加store store内存屏障，这样后一条store在作用到cache之前，会先等待store buffer被排空，这样就不会存在store“乱序”执行的现象，说白了，这个问题导致的原因，就是这个<strong>store buffer在提交时是否是FIFO的（即队列必须严格的先进先出）</strong>。如果store buffer是FIFO类型的（如x86 CPU），那么就不会存在该现象。x86体系结构中store指令的确是不会被乱序执行的，所以的确不会发生Paul的论文描述的问题。</p>
<p>由于load指令一般是允许乱序执行的，也就是load指令会在RS中被乱序dispatch到执行引擎（计算地址等），因此Memory Subsystem中的load buffer就用来暂存这些提前执行的load指令结果，如果乱序执行出现错误、或者分支预测错误，直接丢弃load buffer中的内容即可，但是load操作也是带有副作用的，就是它会导致数据被load到cache上，很容易被<strong>Meltdown漏洞 利用。</strong></p>
<p><strong>最后概括下乱序执行的含义</strong></p>
<ul>
<li>现代处理器采用指令并行技术,在不存在数据依赖性的前提下,处理器可以改变语句对应的机器指令的执行顺序来提高处理器执行速度</li>
<li>现代处理器采用内部缓存技术,导致数据的变化不能及时反映在主存所带来的乱序.</li>
<li>现代编译器为优化而重新安排语句的执行顺序</li>
</ul>
<p>整个乱序执行的过程为：经过取值、译码、寄存器重命名之后的指令，被<strong>顺序</strong>送到保留站（如果是一般的指令还会<strong>顺序发到ROB</strong>，即重排序缓冲区，如果是内存store&#x2F;load指令，会按<strong>顺序放入MOB</strong>，即内存重排序缓冲区，有时候MOB就包含在ROB中），在保留站中的指令，一旦源操作数已经ready，并且当前有空闲的硬件单元，那么这个指令就可以执行，而<strong>不需要等待前面的指令完成</strong>，这就造成了乱序执行的效果。乱序执行中的指令，产生的寄存器修改不会修改最终的物理寄存器，而只会修改自己重命名的私有寄存器（中间检结果反应在ROB中）。同样，如果是内存存取操作（store&#x2F;load）乱序执行，也只会把结果暂存到MOB中（MOB包含store buffer和load buffer）。 因此乱序执行的结果还是未生效的，乱序执行后，需要按照顺序提交ROB和MOB中的结果（其实就是对这些缓冲区中的entry做个commit的标记，表示这些entry可以被应用到寄存区或者被写入内存）。ROB和MOB除了可以暂存中间结果、保证按序提交，还会应用于指令间的依赖分析、分支预测、硬件预取等功能。</p>
<p><img src="https://pic3.zhimg.com/80/v2-c8e92d494971ca6a63ce74346834c382_720w.webp" alt="img"></p>
<hr>
<p>版权声明：本文为知乎博主「玩转Linux内核」的原创文章，遵循CC 4.0 BY-SA版权协议，转载请附上原文出处链接及本声明。<br>原文链接：<a href="https://zhuanlan.zhihu.com/p/436340295">https://zhuanlan.zhihu.com/p/436340295</a></p>
]]></content>
      <categories>
        <category>linux-doc</category>
      </categories>
      <tags>
        <tag>Linux</tag>
      </tags>
  </entry>
  <entry>
    <title>嵌入式软件命名常用英文集</title>
    <url>/2024/10/22/%E5%B5%8C%E5%85%A5%E5%BC%8F/%E5%B5%8C%E5%85%A5%E5%BC%8F%E8%BD%AF%E4%BB%B6%E5%91%BD%E5%90%8D%E5%B8%B8%E7%94%A8%E8%8B%B1%E6%96%87%E9%9B%86/</url>
    <content><![CDATA[<h1 id="代码的可读性，首先从命名开始"><a href="#代码的可读性，首先从命名开始" class="headerlink" title="代码的可读性，首先从命名开始"></a>代码的可读性，首先从命名开始</h1><h2 id="软件开发中的命名，尤其是约定俗成的词汇应该优先使用，本文整理了500个常用英文以便推进规范化。"><a href="#软件开发中的命名，尤其是约定俗成的词汇应该优先使用，本文整理了500个常用英文以便推进规范化。" class="headerlink" title="软件开发中的命名，尤其是约定俗成的词汇应该优先使用，本文整理了500个常用英文以便推进规范化。"></a>软件开发中的命名，尤其是约定俗成的词汇应该优先使用，本文整理了500个常用英文以便推进规范化。</h2><table>
<thead>
<tr>
<th>序号</th>
<th>英文</th>
<th>缩写</th>
<th>中文</th>
<th>备注&#x2F;关联</th>
</tr>
</thead>
<tbody><tr>
<td>0</td>
<td>abstract</td>
<td>abs</td>
<td>抽象的</td>
<td></td>
</tr>
<tr>
<td>1</td>
<td>access</td>
<td>acc</td>
<td>存取，访问</td>
<td></td>
</tr>
<tr>
<td>2</td>
<td>account</td>
<td></td>
<td>账户</td>
<td></td>
</tr>
<tr>
<td>3</td>
<td>acknowledge</td>
<td>ack</td>
<td>“承认</td>
<td>应答”</td>
</tr>
<tr>
<td>4</td>
<td>acquisition</td>
<td>acq</td>
<td>获取</td>
<td></td>
</tr>
<tr>
<td>5</td>
<td>action</td>
<td></td>
<td>动作</td>
<td></td>
</tr>
<tr>
<td>6</td>
<td>activate</td>
<td></td>
<td>激活</td>
<td></td>
</tr>
<tr>
<td>7</td>
<td>actual</td>
<td>act</td>
<td>实际</td>
<td></td>
</tr>
<tr>
<td>8</td>
<td>adaptation</td>
<td>adapt</td>
<td>适应</td>
<td></td>
</tr>
<tr>
<td>9</td>
<td>adapter</td>
<td></td>
<td>适配器</td>
<td></td>
</tr>
<tr>
<td>10</td>
<td>add</td>
<td>add</td>
<td>添加</td>
<td>sub</td>
</tr>
<tr>
<td>11</td>
<td>add-in</td>
<td></td>
<td>插件</td>
<td></td>
</tr>
<tr>
<td>12</td>
<td>address</td>
<td>addr</td>
<td>地址</td>
<td></td>
</tr>
<tr>
<td>13</td>
<td>administration，administrator</td>
<td>admin</td>
<td>管理，管理员</td>
<td></td>
</tr>
<tr>
<td>14</td>
<td>advanced</td>
<td></td>
<td>高级的</td>
<td></td>
</tr>
<tr>
<td>15</td>
<td>advertisement</td>
<td>adv</td>
<td>广播</td>
<td>BLE</td>
</tr>
<tr>
<td>16</td>
<td>agent</td>
<td></td>
<td>代理</td>
<td></td>
</tr>
<tr>
<td>17</td>
<td>algorithm</td>
<td>alg</td>
<td>算法</td>
<td></td>
</tr>
<tr>
<td>18</td>
<td>allocate</td>
<td>alloc</td>
<td>分配、配置</td>
<td></td>
</tr>
<tr>
<td>19</td>
<td>alternate</td>
<td>alt</td>
<td>交替</td>
<td></td>
</tr>
<tr>
<td>20</td>
<td>analog-to-digital converter</td>
<td>adc</td>
<td>模数转换器</td>
<td></td>
</tr>
<tr>
<td>21</td>
<td>analysis</td>
<td>anal</td>
<td>分析</td>
<td></td>
</tr>
<tr>
<td>22</td>
<td>answer</td>
<td>ans</td>
<td>答案</td>
<td></td>
</tr>
<tr>
<td>23</td>
<td>append</td>
<td></td>
<td>附加</td>
<td></td>
</tr>
<tr>
<td>24</td>
<td>application</td>
<td>app</td>
<td>应用程序</td>
<td></td>
</tr>
<tr>
<td>25</td>
<td>architecture</td>
<td>arch</td>
<td>架构</td>
<td></td>
</tr>
<tr>
<td>26</td>
<td>argument</td>
<td>arg</td>
<td>参数</td>
<td>param</td>
</tr>
<tr>
<td>27</td>
<td>array</td>
<td>arr</td>
<td>数组</td>
<td></td>
</tr>
<tr>
<td>28</td>
<td>assertion</td>
<td>assert</td>
<td>断言</td>
<td></td>
</tr>
<tr>
<td>29</td>
<td>assign</td>
<td></td>
<td>赋值</td>
<td></td>
</tr>
<tr>
<td>30</td>
<td>asynchronous</td>
<td></td>
<td>异步的</td>
<td>UART</td>
</tr>
<tr>
<td>31</td>
<td>attachment</td>
<td>attach</td>
<td>附件</td>
<td></td>
</tr>
<tr>
<td>32</td>
<td>attribute</td>
<td>attr</td>
<td>特性，属性</td>
<td></td>
</tr>
<tr>
<td>33</td>
<td>authorization</td>
<td></td>
<td>授权</td>
<td></td>
</tr>
<tr>
<td>34</td>
<td>automatic</td>
<td>auto</td>
<td>自动的</td>
<td></td>
</tr>
<tr>
<td>35</td>
<td>auxiliary</td>
<td>aux</td>
<td>辅助</td>
<td></td>
</tr>
<tr>
<td>36</td>
<td>available</td>
<td>avail</td>
<td>可用的</td>
<td></td>
</tr>
<tr>
<td>37</td>
<td>average</td>
<td>avg</td>
<td>平均值</td>
<td></td>
</tr>
<tr>
<td>38</td>
<td>back</td>
<td>bk</td>
<td>后退</td>
<td></td>
</tr>
<tr>
<td>39</td>
<td>background</td>
<td>bg</td>
<td>背景</td>
<td></td>
</tr>
<tr>
<td>40</td>
<td>backup</td>
<td></td>
<td>备份</td>
<td></td>
</tr>
<tr>
<td>41</td>
<td>base type</td>
<td></td>
<td>基类型</td>
<td></td>
</tr>
<tr>
<td>42</td>
<td>batch</td>
<td></td>
<td>批处理</td>
<td></td>
</tr>
<tr>
<td>43</td>
<td>begin</td>
<td>begin</td>
<td>开始</td>
<td>end</td>
</tr>
<tr>
<td>44</td>
<td>binary</td>
<td></td>
<td>二进制</td>
<td></td>
</tr>
<tr>
<td>45</td>
<td>binding</td>
<td></td>
<td>绑定</td>
<td></td>
</tr>
<tr>
<td>46</td>
<td>bit</td>
<td>bit</td>
<td>位</td>
<td></td>
</tr>
<tr>
<td>47</td>
<td>block</td>
<td></td>
<td>块，区块</td>
<td></td>
</tr>
<tr>
<td>48</td>
<td>bootloader</td>
<td>bl</td>
<td>启动加载器</td>
<td></td>
</tr>
<tr>
<td>49</td>
<td>boundary</td>
<td>bound</td>
<td>边界</td>
<td></td>
</tr>
<tr>
<td>50</td>
<td>breakpoint</td>
<td></td>
<td>断点</td>
<td></td>
</tr>
<tr>
<td>51</td>
<td>bridge</td>
<td>bridge</td>
<td>桥</td>
<td></td>
</tr>
<tr>
<td>52</td>
<td>broadcast</td>
<td>bc</td>
<td>广播</td>
<td>adv</td>
</tr>
<tr>
<td>53</td>
<td>buffer</td>
<td>buff</td>
<td>缓冲区</td>
<td>cache</td>
</tr>
<tr>
<td>54</td>
<td>built-in</td>
<td></td>
<td>内置</td>
<td></td>
</tr>
<tr>
<td>55</td>
<td>bus</td>
<td></td>
<td>总线</td>
<td></td>
</tr>
<tr>
<td>56</td>
<td>business</td>
<td></td>
<td>业务</td>
<td></td>
</tr>
<tr>
<td>57</td>
<td>button</td>
<td>btn</td>
<td>按钮</td>
<td></td>
</tr>
<tr>
<td>58</td>
<td>cache</td>
<td></td>
<td>缓存</td>
<td>buff</td>
</tr>
<tr>
<td>59</td>
<td>calculate</td>
<td>calc</td>
<td>计算</td>
<td></td>
</tr>
<tr>
<td>60</td>
<td>calibration</td>
<td>calib</td>
<td>校准</td>
<td></td>
</tr>
<tr>
<td>61</td>
<td>callback</td>
<td>cb</td>
<td>回调</td>
<td></td>
</tr>
<tr>
<td>62</td>
<td>capacity</td>
<td>cap</td>
<td>容量</td>
<td></td>
</tr>
<tr>
<td>63</td>
<td>category</td>
<td>cat</td>
<td>类别</td>
<td></td>
</tr>
<tr>
<td>64</td>
<td>certification</td>
<td>cert</td>
<td>认证</td>
<td></td>
</tr>
<tr>
<td>65</td>
<td>change</td>
<td>chg</td>
<td>改变</td>
<td></td>
</tr>
<tr>
<td>66</td>
<td>channel</td>
<td>ch</td>
<td>通道</td>
<td></td>
</tr>
<tr>
<td>67</td>
<td>characteristic</td>
<td>charac</td>
<td>特征</td>
<td></td>
</tr>
<tr>
<td>68</td>
<td>check</td>
<td>chk</td>
<td>检测</td>
<td></td>
</tr>
<tr>
<td>69</td>
<td>checksum</td>
<td>checksum</td>
<td>校验和</td>
<td></td>
</tr>
<tr>
<td>70</td>
<td>circulation</td>
<td>circ</td>
<td>循环</td>
<td></td>
</tr>
<tr>
<td>71</td>
<td>clean</td>
<td></td>
<td>清理</td>
<td></td>
</tr>
<tr>
<td>72</td>
<td>click</td>
<td>clk</td>
<td>点击</td>
<td></td>
</tr>
<tr>
<td>73</td>
<td>client</td>
<td>client</td>
<td>客户端</td>
<td>server</td>
</tr>
<tr>
<td>74</td>
<td>clock</td>
<td>clk</td>
<td>时钟</td>
<td></td>
</tr>
<tr>
<td>75</td>
<td>clone</td>
<td></td>
<td>克隆</td>
<td></td>
</tr>
<tr>
<td>76</td>
<td>close</td>
<td>close</td>
<td>关闭</td>
<td>open</td>
</tr>
<tr>
<td>77</td>
<td>collection</td>
<td></td>
<td>集合</td>
<td></td>
</tr>
<tr>
<td>78</td>
<td>color</td>
<td>clr</td>
<td>颜色</td>
<td></td>
</tr>
<tr>
<td>79</td>
<td>column</td>
<td>col</td>
<td>列</td>
<td>row</td>
</tr>
<tr>
<td>80</td>
<td>combine</td>
<td>comb</td>
<td>组合</td>
<td></td>
</tr>
<tr>
<td>81</td>
<td>command</td>
<td>cmd</td>
<td>命令</td>
<td></td>
</tr>
<tr>
<td>82</td>
<td>comment</td>
<td></td>
<td>注释</td>
<td></td>
</tr>
<tr>
<td>83</td>
<td>commit</td>
<td></td>
<td>提交</td>
<td></td>
</tr>
<tr>
<td>84</td>
<td>common</td>
<td>com</td>
<td>公共的</td>
<td></td>
</tr>
<tr>
<td>85</td>
<td>communication</td>
<td>comm</td>
<td>通信</td>
<td></td>
</tr>
<tr>
<td>86</td>
<td>comparison</td>
<td>comp</td>
<td>比较</td>
<td></td>
</tr>
<tr>
<td>87</td>
<td>compensation</td>
<td>comp</td>
<td>补偿</td>
<td></td>
</tr>
<tr>
<td>88</td>
<td>compiler</td>
<td></td>
<td>编译器</td>
<td></td>
</tr>
<tr>
<td>89</td>
<td>completion</td>
<td>complet</td>
<td>完成</td>
<td></td>
</tr>
<tr>
<td>90</td>
<td>component</td>
<td>com</td>
<td>组件</td>
<td></td>
</tr>
<tr>
<td>91</td>
<td>condition</td>
<td>cond</td>
<td>条件</td>
<td></td>
</tr>
<tr>
<td>92</td>
<td>configuration</td>
<td>config</td>
<td>配置</td>
<td>set</td>
</tr>
<tr>
<td>93</td>
<td>confirmation</td>
<td>confirm</td>
<td>确认</td>
<td></td>
</tr>
<tr>
<td>94</td>
<td>connect</td>
<td>conn</td>
<td>连接</td>
<td>disconnect</td>
</tr>
<tr>
<td>95</td>
<td>console</td>
<td></td>
<td>控制台</td>
<td></td>
</tr>
<tr>
<td>96</td>
<td>consolidation</td>
<td>consol</td>
<td>合并</td>
<td></td>
</tr>
<tr>
<td>97</td>
<td>constant</td>
<td>const</td>
<td>常量</td>
<td></td>
</tr>
<tr>
<td>98</td>
<td>consumption</td>
<td>consump</td>
<td>消费</td>
<td></td>
</tr>
<tr>
<td>99</td>
<td>container</td>
<td>cont</td>
<td>容器</td>
<td></td>
</tr>
<tr>
<td>100</td>
<td>content</td>
<td>cont</td>
<td>内容</td>
<td></td>
</tr>
<tr>
<td>101</td>
<td>context</td>
<td></td>
<td>上下文</td>
<td></td>
</tr>
<tr>
<td>102</td>
<td>continue</td>
<td>continue</td>
<td>继续</td>
<td></td>
</tr>
<tr>
<td>103</td>
<td>control</td>
<td>ctrl</td>
<td>“控制</td>
<td>控件”</td>
</tr>
<tr>
<td>104</td>
<td>conversion</td>
<td>conv</td>
<td>转换</td>
<td></td>
</tr>
<tr>
<td>105</td>
<td>convert</td>
<td></td>
<td>使转变</td>
<td></td>
</tr>
<tr>
<td>106</td>
<td>coordinates</td>
<td>coord</td>
<td>坐标系</td>
<td></td>
</tr>
<tr>
<td>107</td>
<td>copy</td>
<td>cpy</td>
<td>复制</td>
<td></td>
</tr>
<tr>
<td>108</td>
<td>count</td>
<td>cnt</td>
<td>计数</td>
<td></td>
</tr>
<tr>
<td>109</td>
<td>cover</td>
<td></td>
<td>覆盖、涵盖</td>
<td></td>
</tr>
<tr>
<td>110</td>
<td>create</td>
<td>create</td>
<td>创建</td>
<td>delete，destroy</td>
</tr>
<tr>
<td>111</td>
<td>current</td>
<td>“I</td>
<td>curr”</td>
<td>“电流</td>
</tr>
<tr>
<td>112</td>
<td>“custom</td>
<td>customer”</td>
<td>cust</td>
<td>定制、自定义</td>
</tr>
<tr>
<td>113</td>
<td>data</td>
<td>data</td>
<td>数据</td>
<td></td>
</tr>
<tr>
<td>114</td>
<td>database</td>
<td>db</td>
<td>数据库</td>
<td></td>
</tr>
<tr>
<td>115</td>
<td>deadline</td>
<td>deadln</td>
<td>截止日期</td>
<td></td>
</tr>
<tr>
<td>116</td>
<td>decode</td>
<td>dec</td>
<td>解码</td>
<td>encode</td>
</tr>
<tr>
<td>117</td>
<td>decrease</td>
<td>dec</td>
<td>减少</td>
<td></td>
</tr>
<tr>
<td>118</td>
<td>decrement</td>
<td>dec</td>
<td>递减</td>
<td>inc</td>
</tr>
<tr>
<td>119</td>
<td>decrypt</td>
<td>decrypt</td>
<td>解密</td>
<td>encrypt</td>
</tr>
<tr>
<td>120</td>
<td>default</td>
<td>def</td>
<td>默认</td>
<td></td>
</tr>
<tr>
<td>121</td>
<td>delay</td>
<td>delay</td>
<td>延迟</td>
<td></td>
</tr>
<tr>
<td>122</td>
<td>delete</td>
<td>del</td>
<td>删除</td>
<td>create</td>
</tr>
<tr>
<td>123</td>
<td>delivery</td>
<td>deliv</td>
<td>交付</td>
<td></td>
</tr>
<tr>
<td>124</td>
<td>demonstration</td>
<td>demo</td>
<td>示范</td>
<td></td>
</tr>
<tr>
<td>125</td>
<td>description</td>
<td>desc</td>
<td>描述</td>
<td></td>
</tr>
<tr>
<td>126</td>
<td>design</td>
<td>des</td>
<td>设计</td>
<td></td>
</tr>
<tr>
<td>127</td>
<td>destination</td>
<td>dest</td>
<td>预定，指定</td>
<td></td>
</tr>
<tr>
<td>128</td>
<td>destroy</td>
<td>destroy</td>
<td>销毁</td>
<td>create</td>
</tr>
<tr>
<td>129</td>
<td>detection</td>
<td>detect</td>
<td>检测</td>
<td></td>
</tr>
<tr>
<td>130</td>
<td>development</td>
<td>dev</td>
<td>开发</td>
<td></td>
</tr>
<tr>
<td>131</td>
<td>device</td>
<td>dev</td>
<td>设备</td>
<td></td>
</tr>
<tr>
<td>132</td>
<td>dialog</td>
<td>dlg</td>
<td>对话框</td>
<td></td>
</tr>
<tr>
<td>133</td>
<td>dictionary</td>
<td>dict</td>
<td>字典</td>
<td></td>
</tr>
<tr>
<td>134</td>
<td>difference，different</td>
<td>diff</td>
<td>差异</td>
<td></td>
</tr>
<tr>
<td>135</td>
<td>direction</td>
<td>direct</td>
<td>方向</td>
<td></td>
</tr>
<tr>
<td>136</td>
<td>directory</td>
<td>dir</td>
<td>目录</td>
<td></td>
</tr>
<tr>
<td>137</td>
<td>disable</td>
<td>dis</td>
<td>禁用</td>
<td>enable</td>
</tr>
<tr>
<td>138</td>
<td>disconnect</td>
<td>disc</td>
<td>断开连接</td>
<td></td>
</tr>
<tr>
<td>139</td>
<td>display</td>
<td>disp</td>
<td>显示</td>
<td></td>
</tr>
<tr>
<td>140</td>
<td>distance</td>
<td>dist</td>
<td>距离</td>
<td></td>
</tr>
<tr>
<td>141</td>
<td>document</td>
<td>doc</td>
<td>文档</td>
<td></td>
</tr>
<tr>
<td>142</td>
<td>domain</td>
<td>dom</td>
<td>领域</td>
<td></td>
</tr>
<tr>
<td>143</td>
<td>down</td>
<td>dn</td>
<td>向下</td>
<td></td>
</tr>
<tr>
<td>144</td>
<td>download</td>
<td>dl</td>
<td>下载</td>
<td></td>
</tr>
<tr>
<td>145</td>
<td>driver</td>
<td>drv</td>
<td>驱动</td>
<td></td>
</tr>
<tr>
<td>146</td>
<td>duration</td>
<td>dur</td>
<td>持续时间</td>
<td></td>
</tr>
<tr>
<td>147</td>
<td>dynamic</td>
<td>dyn</td>
<td>动态的</td>
<td></td>
</tr>
<tr>
<td>148</td>
<td>effectiveness</td>
<td>effect</td>
<td>有效性</td>
<td></td>
</tr>
<tr>
<td>149</td>
<td>efficiency</td>
<td>eff</td>
<td>效率</td>
<td></td>
</tr>
<tr>
<td>150</td>
<td>electronic mail</td>
<td>email</td>
<td>电子邮件</td>
<td></td>
</tr>
<tr>
<td>151</td>
<td>element</td>
<td>elem</td>
<td>元素</td>
<td></td>
</tr>
<tr>
<td>152</td>
<td>embedded system</td>
<td>微信公众号</td>
<td>嵌入式系统</td>
<td>重点关注</td>
</tr>
<tr>
<td>153</td>
<td>emergency</td>
<td>emerg</td>
<td>紧急情况</td>
<td></td>
</tr>
<tr>
<td>154</td>
<td>emphasis</td>
<td>emph</td>
<td>强调</td>
<td></td>
</tr>
<tr>
<td>155</td>
<td>enable</td>
<td>en</td>
<td>使能</td>
<td>disable</td>
</tr>
<tr>
<td>156</td>
<td>encode</td>
<td>enc</td>
<td>编码</td>
<td>decode</td>
</tr>
<tr>
<td>157</td>
<td>encrypt</td>
<td>encrypt</td>
<td>加密</td>
<td>decrypt</td>
</tr>
<tr>
<td>158</td>
<td>end</td>
<td>end</td>
<td>结束</td>
<td></td>
</tr>
<tr>
<td>159</td>
<td>enhancement</td>
<td>enhance</td>
<td>增强</td>
<td></td>
</tr>
<tr>
<td>160</td>
<td>enter</td>
<td></td>
<td>进入</td>
<td>exit</td>
</tr>
<tr>
<td>161</td>
<td>entity</td>
<td></td>
<td>实体</td>
<td></td>
</tr>
<tr>
<td>162</td>
<td>environment</td>
<td>env</td>
<td>运行环境</td>
<td></td>
</tr>
<tr>
<td>163</td>
<td>equipment</td>
<td>equip</td>
<td>设备</td>
<td></td>
</tr>
<tr>
<td>164</td>
<td>error</td>
<td>err</td>
<td>错误</td>
<td></td>
</tr>
<tr>
<td>165</td>
<td>event</td>
<td>event</td>
<td>事件</td>
<td></td>
</tr>
<tr>
<td>166</td>
<td>example</td>
<td>ex</td>
<td>示例</td>
<td></td>
</tr>
<tr>
<td>167</td>
<td>exception</td>
<td>except</td>
<td>例外</td>
<td></td>
</tr>
<tr>
<td>168</td>
<td>exchange</td>
<td>exch</td>
<td>交换</td>
<td></td>
</tr>
<tr>
<td>169</td>
<td>execute</td>
<td>exec</td>
<td>执行</td>
<td></td>
</tr>
<tr>
<td>170</td>
<td>exist</td>
<td>exist</td>
<td>存在</td>
<td></td>
</tr>
<tr>
<td>171</td>
<td>exit</td>
<td></td>
<td>退出</td>
<td>enter</td>
</tr>
<tr>
<td>172</td>
<td>expansion</td>
<td>expans</td>
<td>扩展</td>
<td></td>
</tr>
<tr>
<td>173</td>
<td>expect</td>
<td>exp</td>
<td>期望</td>
<td></td>
</tr>
<tr>
<td>174</td>
<td>experiment</td>
<td>expmt</td>
<td>实验</td>
<td></td>
</tr>
<tr>
<td>175</td>
<td>explanation</td>
<td>expl</td>
<td>解释</td>
<td></td>
</tr>
<tr>
<td>176</td>
<td>export</td>
<td>exp</td>
<td>“出口</td>
<td>导出”</td>
</tr>
<tr>
<td>177</td>
<td>extension</td>
<td>ext</td>
<td>扩展</td>
<td></td>
</tr>
<tr>
<td>178</td>
<td>external</td>
<td>ext</td>
<td>外部的</td>
<td></td>
</tr>
<tr>
<td>179</td>
<td>failure</td>
<td>fail</td>
<td>失败</td>
<td>ok</td>
</tr>
<tr>
<td>180</td>
<td>feedback</td>
<td>fb</td>
<td>反馈</td>
<td></td>
</tr>
<tr>
<td>181</td>
<td>field</td>
<td>field</td>
<td>域</td>
<td></td>
</tr>
<tr>
<td>182</td>
<td>file</td>
<td>fl</td>
<td>文件</td>
<td></td>
</tr>
<tr>
<td>183</td>
<td>firmware</td>
<td>fw</td>
<td>固件</td>
<td></td>
</tr>
<tr>
<td>184</td>
<td>first</td>
<td>first</td>
<td>第一位</td>
<td></td>
</tr>
<tr>
<td>185</td>
<td>flag</td>
<td>flag</td>
<td>标志位</td>
<td>万能</td>
</tr>
<tr>
<td>186</td>
<td>flush</td>
<td></td>
<td>刷新</td>
<td>file write</td>
</tr>
<tr>
<td>187</td>
<td>focus</td>
<td>foc</td>
<td>焦点</td>
<td></td>
</tr>
<tr>
<td>188</td>
<td>font</td>
<td></td>
<td>字体</td>
<td></td>
</tr>
<tr>
<td>189</td>
<td>force</td>
<td></td>
<td>强制</td>
<td></td>
</tr>
<tr>
<td>190</td>
<td>format</td>
<td>fmt</td>
<td>格式</td>
<td></td>
</tr>
<tr>
<td>191</td>
<td>forward</td>
<td>fwd</td>
<td>转发，向前</td>
<td></td>
</tr>
<tr>
<td>192</td>
<td>foundation</td>
<td>found</td>
<td>基础</td>
<td></td>
</tr>
<tr>
<td>193</td>
<td>frame</td>
<td>frm</td>
<td>帧率</td>
<td></td>
</tr>
<tr>
<td>194</td>
<td>framework</td>
<td>framewk</td>
<td>框架</td>
<td></td>
</tr>
<tr>
<td>195</td>
<td>frequency</td>
<td>freq</td>
<td>频率</td>
<td></td>
</tr>
<tr>
<td>196</td>
<td>function</td>
<td>func</td>
<td>函数</td>
<td></td>
</tr>
<tr>
<td>197</td>
<td>general purpose input&#x2F;output</td>
<td>gpio</td>
<td>通用输入输出端口</td>
<td></td>
</tr>
<tr>
<td>198</td>
<td>generate</td>
<td>gen</td>
<td>生成</td>
<td></td>
</tr>
<tr>
<td>199</td>
<td>generation</td>
<td>gener</td>
<td>代</td>
<td></td>
</tr>
<tr>
<td>200</td>
<td>get</td>
<td>get</td>
<td>获取</td>
<td>“set</td>
</tr>
<tr>
<td>201</td>
<td>global</td>
<td></td>
<td>全局的</td>
<td></td>
</tr>
<tr>
<td>202</td>
<td>group</td>
<td>grp</td>
<td>组</td>
<td></td>
</tr>
<tr>
<td>203</td>
<td>handle</td>
<td>hdl</td>
<td>句柄</td>
<td></td>
</tr>
<tr>
<td>204</td>
<td>handler</td>
<td></td>
<td>处理器</td>
<td></td>
</tr>
<tr>
<td>205</td>
<td>handshake</td>
<td>hdsk</td>
<td>握手</td>
<td></td>
</tr>
<tr>
<td>206</td>
<td>hardware</td>
<td>HW</td>
<td>硬件</td>
<td></td>
</tr>
<tr>
<td>207</td>
<td>header</td>
<td>hdr</td>
<td>头部</td>
<td>tail</td>
</tr>
<tr>
<td>208</td>
<td>heap</td>
<td>heap</td>
<td>堆</td>
<td></td>
</tr>
<tr>
<td>209</td>
<td>high</td>
<td>high</td>
<td>高</td>
<td>low</td>
</tr>
<tr>
<td>210</td>
<td>highlight</td>
<td>highlt</td>
<td>强调</td>
<td></td>
</tr>
<tr>
<td>211</td>
<td>hook</td>
<td></td>
<td>钩子</td>
<td></td>
</tr>
<tr>
<td>212</td>
<td>horizontal</td>
<td>horz</td>
<td>水平的</td>
<td>vertical</td>
</tr>
<tr>
<td>213</td>
<td>identifier</td>
<td>ID</td>
<td>标识符，身份</td>
<td></td>
</tr>
<tr>
<td>214</td>
<td>idle</td>
<td></td>
<td>空闲时间</td>
<td></td>
</tr>
<tr>
<td>215</td>
<td>image</td>
<td>img</td>
<td>图像</td>
<td></td>
</tr>
<tr>
<td>216</td>
<td>implementation</td>
<td>implement</td>
<td>实施</td>
<td></td>
</tr>
<tr>
<td>217</td>
<td>import</td>
<td></td>
<td>导入</td>
<td>export</td>
</tr>
<tr>
<td>218</td>
<td>importance</td>
<td>imp</td>
<td>重要性</td>
<td></td>
</tr>
<tr>
<td>219</td>
<td>include</td>
<td>incl</td>
<td>包含头文件</td>
<td></td>
</tr>
<tr>
<td>220</td>
<td>inclusion</td>
<td>inclus</td>
<td>包含</td>
<td></td>
</tr>
<tr>
<td>221</td>
<td>increase</td>
<td>inc</td>
<td>增加</td>
<td></td>
</tr>
<tr>
<td>222</td>
<td>incremental</td>
<td>inc</td>
<td>递增</td>
<td>dec</td>
</tr>
<tr>
<td>223</td>
<td>index</td>
<td>idx，ind</td>
<td>索引</td>
<td></td>
</tr>
<tr>
<td>224</td>
<td>information</td>
<td>info</td>
<td>信息</td>
<td></td>
</tr>
<tr>
<td>225</td>
<td>initialize</td>
<td>init</td>
<td>初始化</td>
<td>deinit</td>
</tr>
<tr>
<td>226</td>
<td>input</td>
<td>in</td>
<td>输入</td>
<td>output</td>
</tr>
<tr>
<td>227</td>
<td>insert</td>
<td>insert</td>
<td>插入</td>
<td></td>
</tr>
<tr>
<td>228</td>
<td>installation</td>
<td>install</td>
<td>安装</td>
<td></td>
</tr>
<tr>
<td>229</td>
<td>instance</td>
<td>inst</td>
<td>实例</td>
<td></td>
</tr>
<tr>
<td>230</td>
<td>instruction</td>
<td>instruct</td>
<td>指令</td>
<td>cmd</td>
</tr>
<tr>
<td>231</td>
<td>instrument</td>
<td>instr</td>
<td>工具</td>
<td></td>
</tr>
<tr>
<td>232</td>
<td>integration</td>
<td>int</td>
<td>整合</td>
<td></td>
</tr>
<tr>
<td>233</td>
<td>integrity</td>
<td>integr</td>
<td>完整性</td>
<td></td>
</tr>
<tr>
<td>234</td>
<td>interface</td>
<td>iface</td>
<td>接口</td>
<td></td>
</tr>
<tr>
<td>235</td>
<td>internal</td>
<td>int</td>
<td>内部的</td>
<td></td>
</tr>
<tr>
<td>236</td>
<td>international</td>
<td>inter</td>
<td>国际的</td>
<td></td>
</tr>
<tr>
<td>237</td>
<td>interrupt</td>
<td>intr</td>
<td>“中断</td>
<td>中断请求IRQ”</td>
</tr>
<tr>
<td>238</td>
<td>interval</td>
<td>interv</td>
<td>间隔</td>
<td></td>
</tr>
<tr>
<td>239</td>
<td>introduce</td>
<td>intro</td>
<td>介绍</td>
<td></td>
</tr>
<tr>
<td>240</td>
<td>item</td>
<td>item</td>
<td>项、条款、项目</td>
<td></td>
</tr>
<tr>
<td>241</td>
<td>iterate</td>
<td></td>
<td>迭代</td>
<td></td>
</tr>
<tr>
<td>242</td>
<td>key</td>
<td>key</td>
<td>键值</td>
<td></td>
</tr>
<tr>
<td>243</td>
<td>language</td>
<td>lang</td>
<td>语言</td>
<td></td>
</tr>
<tr>
<td>244</td>
<td>last</td>
<td>last</td>
<td>最后的</td>
<td></td>
</tr>
<tr>
<td>245</td>
<td>length</td>
<td>“len</td>
<td>not l”</td>
<td>长度</td>
</tr>
<tr>
<td>246</td>
<td>level</td>
<td>level</td>
<td>电平</td>
<td></td>
</tr>
<tr>
<td>247</td>
<td>library</td>
<td>lib</td>
<td>静态库</td>
<td></td>
</tr>
<tr>
<td>248</td>
<td>lifetime</td>
<td></td>
<td>生命期、寿命</td>
<td></td>
</tr>
<tr>
<td>249</td>
<td>limitation</td>
<td>limit</td>
<td>限制</td>
<td></td>
</tr>
<tr>
<td>250</td>
<td>link</td>
<td>lnk</td>
<td>链接</td>
<td></td>
</tr>
<tr>
<td>251</td>
<td>list</td>
<td>lst</td>
<td>列表</td>
<td></td>
</tr>
<tr>
<td>252</td>
<td>load</td>
<td></td>
<td>装载、加载</td>
<td></td>
</tr>
<tr>
<td>253</td>
<td>location</td>
<td>loc</td>
<td>位置</td>
<td></td>
</tr>
<tr>
<td>254</td>
<td>lock</td>
<td>lock</td>
<td>锁</td>
<td>unlock</td>
</tr>
<tr>
<td>255</td>
<td>log</td>
<td>log</td>
<td>日志</td>
<td></td>
</tr>
<tr>
<td>256</td>
<td>logical</td>
<td>logic</td>
<td>逻辑的</td>
<td></td>
</tr>
<tr>
<td>257</td>
<td>login</td>
<td></td>
<td>登录</td>
<td></td>
</tr>
<tr>
<td>258</td>
<td>loop</td>
<td>loop</td>
<td>循环</td>
<td></td>
</tr>
<tr>
<td>259</td>
<td>low</td>
<td>low</td>
<td>低</td>
<td>high</td>
</tr>
<tr>
<td>260</td>
<td>macro</td>
<td>macro</td>
<td>宏</td>
<td></td>
</tr>
<tr>
<td>261</td>
<td>mailbox</td>
<td>mbx</td>
<td>邮箱</td>
<td></td>
</tr>
<tr>
<td>262</td>
<td>mask</td>
<td>mask</td>
<td>“屏蔽码</td>
<td>掩码”</td>
</tr>
<tr>
<td>263</td>
<td>master</td>
<td>mst</td>
<td>主机</td>
<td>I2C</td>
</tr>
<tr>
<td>264</td>
<td>mathematics</td>
<td>math</td>
<td>数学</td>
<td></td>
</tr>
<tr>
<td>265</td>
<td>maximum</td>
<td>max</td>
<td>最大值</td>
<td>min</td>
</tr>
<tr>
<td>266</td>
<td>medium</td>
<td>medium</td>
<td>中</td>
<td></td>
</tr>
<tr>
<td>267</td>
<td>membership</td>
<td>member</td>
<td>成员</td>
<td></td>
</tr>
<tr>
<td>268</td>
<td>memory</td>
<td>mem</td>
<td>内存</td>
<td></td>
</tr>
<tr>
<td>269</td>
<td>memory leak</td>
<td></td>
<td>内存泄漏</td>
<td></td>
</tr>
<tr>
<td>270</td>
<td>menu</td>
<td></td>
<td>菜单</td>
<td></td>
</tr>
<tr>
<td>271</td>
<td>message</td>
<td>msg</td>
<td>消息</td>
<td></td>
</tr>
<tr>
<td>272</td>
<td>metadata</td>
<td></td>
<td>元数据</td>
<td></td>
</tr>
<tr>
<td>273</td>
<td>methodology</td>
<td>method</td>
<td>方法</td>
<td></td>
</tr>
<tr>
<td>274</td>
<td>microphone</td>
<td>mic</td>
<td>麦克风</td>
<td></td>
</tr>
<tr>
<td>275</td>
<td>middle</td>
<td>mid</td>
<td>中间</td>
<td></td>
</tr>
<tr>
<td>276</td>
<td>middleware</td>
<td></td>
<td>中间件</td>
<td></td>
</tr>
<tr>
<td>277</td>
<td>minimum</td>
<td>min</td>
<td>最小值</td>
<td>max</td>
</tr>
<tr>
<td>278</td>
<td>mode</td>
<td>mode</td>
<td>模式</td>
<td></td>
</tr>
<tr>
<td>279</td>
<td>modem</td>
<td></td>
<td>调制解调器</td>
<td></td>
</tr>
<tr>
<td>280</td>
<td>modify</td>
<td>modify</td>
<td>修改</td>
<td></td>
</tr>
<tr>
<td>281</td>
<td>module</td>
<td>mod</td>
<td>模块</td>
<td></td>
</tr>
<tr>
<td>282</td>
<td>multi</td>
<td></td>
<td>多种</td>
<td></td>
</tr>
<tr>
<td>283</td>
<td>multiply</td>
<td>mul</td>
<td>相乘</td>
<td></td>
</tr>
<tr>
<td>284</td>
<td>native</td>
<td></td>
<td>原生的、本地的</td>
<td></td>
</tr>
<tr>
<td>285</td>
<td>network</td>
<td>“net</td>
<td>nw”</td>
<td>网络</td>
</tr>
<tr>
<td>286</td>
<td>new</td>
<td>new</td>
<td>新的</td>
<td></td>
</tr>
<tr>
<td>287</td>
<td>next</td>
<td>next</td>
<td>后一个</td>
<td></td>
</tr>
<tr>
<td>288</td>
<td>nominal</td>
<td>nom</td>
<td>理论值</td>
<td></td>
</tr>
<tr>
<td>289</td>
<td>nonvolatile</td>
<td>nv</td>
<td>非易失性的</td>
<td></td>
</tr>
<tr>
<td>290</td>
<td>notify</td>
<td>notify</td>
<td>通知</td>
<td></td>
</tr>
<tr>
<td>291</td>
<td>number</td>
<td>num</td>
<td>数字</td>
<td></td>
</tr>
<tr>
<td>292</td>
<td>object</td>
<td>obj</td>
<td>对象</td>
<td></td>
</tr>
<tr>
<td>293</td>
<td>offset</td>
<td>offset</td>
<td>偏移</td>
<td></td>
</tr>
<tr>
<td>294</td>
<td>old</td>
<td>old</td>
<td>旧的</td>
<td>new</td>
</tr>
<tr>
<td>295</td>
<td>opcode</td>
<td>opc</td>
<td>操作码</td>
<td></td>
</tr>
<tr>
<td>296</td>
<td>open</td>
<td>open</td>
<td>打开</td>
<td>close</td>
</tr>
<tr>
<td>297</td>
<td>operation</td>
<td>op</td>
<td>操作</td>
<td></td>
</tr>
<tr>
<td>298</td>
<td>option</td>
<td>opt</td>
<td>选择</td>
<td></td>
</tr>
<tr>
<td>299</td>
<td>organization</td>
<td>org</td>
<td>组织</td>
<td></td>
</tr>
<tr>
<td>300</td>
<td>orientation</td>
<td>orient</td>
<td>方向</td>
<td></td>
</tr>
<tr>
<td>301</td>
<td>origin</td>
<td>org</td>
<td>起源</td>
<td></td>
</tr>
<tr>
<td>302</td>
<td>output</td>
<td>out</td>
<td>输出</td>
<td>input</td>
</tr>
<tr>
<td>303</td>
<td>overflow</td>
<td>overflow</td>
<td>溢出</td>
<td></td>
</tr>
<tr>
<td>304</td>
<td>overload</td>
<td></td>
<td>重载</td>
<td></td>
</tr>
<tr>
<td>305</td>
<td>override</td>
<td></td>
<td>重写</td>
<td></td>
</tr>
<tr>
<td>306</td>
<td>owner，ownership</td>
<td>own</td>
<td>拥有</td>
<td></td>
</tr>
<tr>
<td>307</td>
<td>package</td>
<td>pkg</td>
<td>打包</td>
<td></td>
</tr>
<tr>
<td>308</td>
<td>packet</td>
<td>pkt</td>
<td>包</td>
<td></td>
</tr>
<tr>
<td>309</td>
<td>parameter</td>
<td>param</td>
<td>参数</td>
<td></td>
</tr>
<tr>
<td>310</td>
<td>parity</td>
<td>parity</td>
<td>奇偶校验</td>
<td></td>
</tr>
<tr>
<td>311</td>
<td>parse</td>
<td></td>
<td>解析</td>
<td></td>
</tr>
<tr>
<td>312</td>
<td>part</td>
<td></td>
<td>部件</td>
<td></td>
</tr>
<tr>
<td>313</td>
<td>password</td>
<td>“pass</td>
<td>psw”</td>
<td>密码</td>
</tr>
<tr>
<td>314</td>
<td>payment</td>
<td>pay</td>
<td>支付</td>
<td></td>
</tr>
<tr>
<td>315</td>
<td>peak</td>
<td>peak</td>
<td>峰值</td>
<td></td>
</tr>
<tr>
<td>316</td>
<td>performance</td>
<td>perform</td>
<td>表现</td>
<td></td>
</tr>
<tr>
<td>317</td>
<td>performance</td>
<td>perf</td>
<td>性能</td>
<td></td>
</tr>
<tr>
<td>318</td>
<td>period</td>
<td>period</td>
<td>周期</td>
<td></td>
</tr>
<tr>
<td>319</td>
<td>permission</td>
<td>perm</td>
<td>许可</td>
<td></td>
</tr>
<tr>
<td>320</td>
<td>perspective</td>
<td>persp</td>
<td>角度</td>
<td></td>
</tr>
<tr>
<td>321</td>
<td>phase</td>
<td>phase</td>
<td>相位</td>
<td></td>
</tr>
<tr>
<td>322</td>
<td>picture</td>
<td>pic</td>
<td>图片</td>
<td></td>
</tr>
<tr>
<td>323</td>
<td>planning</td>
<td>plan</td>
<td>计划</td>
<td></td>
</tr>
<tr>
<td>324</td>
<td>platform</td>
<td>plat</td>
<td>平台</td>
<td></td>
</tr>
<tr>
<td>325</td>
<td>point</td>
<td>pt</td>
<td>点</td>
<td></td>
</tr>
<tr>
<td>326</td>
<td>pointer</td>
<td>ptr</td>
<td>指针</td>
<td></td>
</tr>
<tr>
<td>327</td>
<td>policy</td>
<td>pol</td>
<td>政策</td>
<td></td>
</tr>
<tr>
<td>328</td>
<td>popup</td>
<td></td>
<td>弹出</td>
<td></td>
</tr>
<tr>
<td>329</td>
<td>port</td>
<td>port</td>
<td>端口</td>
<td></td>
</tr>
<tr>
<td>330</td>
<td>position</td>
<td>pos</td>
<td>位置</td>
<td></td>
</tr>
<tr>
<td>331</td>
<td>postfix</td>
<td></td>
<td>后缀</td>
<td>suffix</td>
</tr>
<tr>
<td>332</td>
<td>power</td>
<td>P，pwr</td>
<td>功率，电源</td>
<td></td>
</tr>
<tr>
<td>333</td>
<td>prefix</td>
<td>pfx</td>
<td>前缀</td>
<td></td>
</tr>
<tr>
<td>334</td>
<td>preparation</td>
<td>pre</td>
<td>准备</td>
<td></td>
</tr>
<tr>
<td>335</td>
<td>pressure</td>
<td>press</td>
<td>压力</td>
<td></td>
</tr>
<tr>
<td>336</td>
<td>prevention</td>
<td>prevent</td>
<td>预防</td>
<td></td>
</tr>
<tr>
<td>337</td>
<td>previous</td>
<td>prev</td>
<td>前一个</td>
<td>next</td>
</tr>
<tr>
<td>338</td>
<td>print</td>
<td>prn</td>
<td>打印</td>
<td></td>
</tr>
<tr>
<td>339</td>
<td>priority</td>
<td>prio</td>
<td>优先级</td>
<td></td>
</tr>
<tr>
<td>340</td>
<td>private</td>
<td>priv</td>
<td>私有的</td>
<td></td>
</tr>
<tr>
<td>341</td>
<td>privilege</td>
<td>priv</td>
<td>特权</td>
<td></td>
</tr>
<tr>
<td>342</td>
<td>procedure</td>
<td>proced</td>
<td>程序，步骤</td>
<td></td>
</tr>
<tr>
<td>343</td>
<td>process</td>
<td>proc</td>
<td>进程</td>
<td></td>
</tr>
<tr>
<td>344</td>
<td>production</td>
<td>produc</td>
<td>生产</td>
<td></td>
</tr>
<tr>
<td>345</td>
<td>program</td>
<td>prog</td>
<td>程序</td>
<td></td>
</tr>
<tr>
<td>346</td>
<td>progress</td>
<td>prog</td>
<td>进展</td>
<td></td>
</tr>
<tr>
<td>347</td>
<td>project</td>
<td>proj</td>
<td>项目、工程</td>
<td></td>
</tr>
<tr>
<td>348</td>
<td>properties</td>
<td></td>
<td>性能</td>
<td></td>
</tr>
<tr>
<td>349</td>
<td>property</td>
<td>prop</td>
<td>属性</td>
<td></td>
</tr>
<tr>
<td>350</td>
<td>protected</td>
<td>prot</td>
<td>受保护</td>
<td></td>
</tr>
<tr>
<td>351</td>
<td>protocol</td>
<td></td>
<td>协议</td>
<td></td>
</tr>
<tr>
<td>352</td>
<td>public</td>
<td>pub</td>
<td>公共的</td>
<td></td>
</tr>
<tr>
<td>353</td>
<td>pull-down</td>
<td>pd</td>
<td>下拉</td>
<td></td>
</tr>
<tr>
<td>354</td>
<td>pull-up</td>
<td>pu</td>
<td>上拉</td>
<td></td>
</tr>
<tr>
<td>355</td>
<td>quantity</td>
<td>quant</td>
<td>数量</td>
<td></td>
</tr>
<tr>
<td>356</td>
<td>queue</td>
<td>qu</td>
<td>队列</td>
<td></td>
</tr>
<tr>
<td>357</td>
<td>range</td>
<td></td>
<td>范围、区间</td>
<td></td>
</tr>
<tr>
<td>358</td>
<td>ratio</td>
<td>ratio</td>
<td>比率</td>
<td></td>
</tr>
<tr>
<td>359</td>
<td>raw</td>
<td></td>
<td>未经处理的</td>
<td></td>
</tr>
<tr>
<td>360</td>
<td>reaction</td>
<td>react</td>
<td>反应</td>
<td></td>
</tr>
<tr>
<td>361</td>
<td>read</td>
<td>read</td>
<td>读取</td>
<td></td>
</tr>
<tr>
<td>362</td>
<td>readonly</td>
<td></td>
<td>只读</td>
<td></td>
</tr>
<tr>
<td>363</td>
<td>ready</td>
<td>rdy</td>
<td>准备</td>
<td></td>
</tr>
<tr>
<td>364</td>
<td>reality</td>
<td>real</td>
<td>现实</td>
<td></td>
</tr>
<tr>
<td>365</td>
<td>receive</td>
<td>rcv</td>
<td>接收</td>
<td>send</td>
</tr>
<tr>
<td>366</td>
<td>reception</td>
<td>recept</td>
<td>接待</td>
<td></td>
</tr>
<tr>
<td>367</td>
<td>recommendation</td>
<td>recommend</td>
<td>推荐</td>
<td></td>
</tr>
<tr>
<td>368</td>
<td>record</td>
<td></td>
<td>记录</td>
<td></td>
</tr>
<tr>
<td>369</td>
<td>recovery</td>
<td>recovery</td>
<td>恢复</td>
<td></td>
</tr>
<tr>
<td>370</td>
<td>rect</td>
<td>rc</td>
<td>矩形</td>
<td></td>
</tr>
<tr>
<td>371</td>
<td>recycling</td>
<td>recycl</td>
<td>回收</td>
<td></td>
</tr>
<tr>
<td>372</td>
<td>redefine</td>
<td></td>
<td>重定义</td>
<td></td>
</tr>
<tr>
<td>373</td>
<td>redundancy</td>
<td>redund</td>
<td>冗余</td>
<td></td>
</tr>
<tr>
<td>374</td>
<td>refactoring</td>
<td></td>
<td>重构</td>
<td></td>
</tr>
<tr>
<td>375</td>
<td>reference</td>
<td>ref</td>
<td>“引用</td>
<td>参考”</td>
</tr>
<tr>
<td>376</td>
<td>region</td>
<td>region</td>
<td>地区</td>
<td></td>
</tr>
<tr>
<td>377</td>
<td>register</td>
<td>reg</td>
<td>“注册</td>
<td>寄存器”</td>
</tr>
<tr>
<td>378</td>
<td>regression</td>
<td>rgr</td>
<td>回归</td>
<td></td>
</tr>
<tr>
<td>379</td>
<td>regulation</td>
<td>regul</td>
<td>规定</td>
<td></td>
</tr>
<tr>
<td>380</td>
<td>rejection</td>
<td>reject</td>
<td>拒绝</td>
<td></td>
</tr>
<tr>
<td>381</td>
<td>release</td>
<td>rel</td>
<td>发布</td>
<td></td>
</tr>
<tr>
<td>382</td>
<td>reminder</td>
<td>remind</td>
<td>提醒</td>
<td></td>
</tr>
<tr>
<td>383</td>
<td>remote</td>
<td></td>
<td>远程</td>
<td></td>
</tr>
<tr>
<td>384</td>
<td>removal</td>
<td>rm</td>
<td>移除</td>
<td>delete</td>
</tr>
<tr>
<td>385</td>
<td>repetition</td>
<td>repet</td>
<td>重复</td>
<td></td>
</tr>
<tr>
<td>386</td>
<td>request</td>
<td>req</td>
<td>请求</td>
<td></td>
</tr>
<tr>
<td>387</td>
<td>reservation</td>
<td>reserv</td>
<td>预订</td>
<td></td>
</tr>
<tr>
<td>388</td>
<td>reserved</td>
<td>rsvd</td>
<td>保留</td>
<td></td>
</tr>
<tr>
<td>389</td>
<td>resolution</td>
<td>res</td>
<td>分辨率</td>
<td></td>
</tr>
<tr>
<td>390</td>
<td>resource</td>
<td>res</td>
<td>资源</td>
<td></td>
</tr>
<tr>
<td>391</td>
<td>response</td>
<td>rsp</td>
<td>回复</td>
<td></td>
</tr>
<tr>
<td>392</td>
<td>restriction</td>
<td>restrict</td>
<td>限制</td>
<td></td>
</tr>
<tr>
<td>393</td>
<td>result</td>
<td>res</td>
<td>结果</td>
<td></td>
</tr>
<tr>
<td>394</td>
<td>resume</td>
<td>resume</td>
<td>恢复</td>
<td>suspend</td>
</tr>
<tr>
<td>395</td>
<td>retention</td>
<td>retent</td>
<td>保留</td>
<td></td>
</tr>
<tr>
<td>396</td>
<td>return</td>
<td>ret</td>
<td>返回</td>
<td></td>
</tr>
<tr>
<td>397</td>
<td>ringbuffer</td>
<td></td>
<td>环形缓冲区</td>
<td></td>
</tr>
<tr>
<td>398</td>
<td>risk</td>
<td>risk</td>
<td>风险</td>
<td></td>
</tr>
<tr>
<td>399</td>
<td>row</td>
<td>row</td>
<td>行</td>
<td></td>
</tr>
<tr>
<td>400</td>
<td>safety</td>
<td>saf</td>
<td>安全</td>
<td></td>
</tr>
<tr>
<td>401</td>
<td>sample</td>
<td>sampl</td>
<td>样本</td>
<td></td>
</tr>
<tr>
<td>402</td>
<td>sampling</td>
<td>samp</td>
<td>采样</td>
<td></td>
</tr>
<tr>
<td>403</td>
<td>save</td>
<td></td>
<td>保存</td>
<td></td>
</tr>
<tr>
<td>404</td>
<td>scale</td>
<td>scale</td>
<td>比例尺</td>
<td></td>
</tr>
<tr>
<td>405</td>
<td>scan</td>
<td></td>
<td>扫描</td>
<td>“BLE</td>
</tr>
<tr>
<td>406</td>
<td>schedule</td>
<td>sched</td>
<td>“调度</td>
<td>安排”</td>
</tr>
<tr>
<td>407</td>
<td>scheme</td>
<td>sch</td>
<td>方案</td>
<td></td>
</tr>
<tr>
<td>408</td>
<td>scope</td>
<td>scope</td>
<td>范围</td>
<td></td>
</tr>
<tr>
<td>409</td>
<td>screen</td>
<td>scr</td>
<td>屏幕</td>
<td></td>
</tr>
<tr>
<td>410</td>
<td>search</td>
<td></td>
<td>查找</td>
<td>scan</td>
</tr>
<tr>
<td>411</td>
<td>second</td>
<td>sec</td>
<td>秒、第二</td>
<td></td>
</tr>
<tr>
<td>412</td>
<td>secrecy</td>
<td>secret</td>
<td>保密</td>
<td></td>
</tr>
<tr>
<td>413</td>
<td>select</td>
<td>sel</td>
<td>选择</td>
<td></td>
</tr>
<tr>
<td>414</td>
<td>semaphore</td>
<td>sem</td>
<td>信号量</td>
<td></td>
</tr>
<tr>
<td>415</td>
<td>send</td>
<td>send</td>
<td>发送</td>
<td></td>
</tr>
<tr>
<td>416</td>
<td>sensor</td>
<td>sensor</td>
<td>传感器</td>
<td></td>
</tr>
<tr>
<td>417</td>
<td>separation</td>
<td>separ</td>
<td>分离</td>
<td></td>
</tr>
<tr>
<td>418</td>
<td>sequence</td>
<td>seq</td>
<td>序列</td>
<td></td>
</tr>
<tr>
<td>419</td>
<td>serial</td>
<td></td>
<td>串行</td>
<td></td>
</tr>
<tr>
<td>420</td>
<td>server</td>
<td>svr</td>
<td>服务</td>
<td></td>
</tr>
<tr>
<td>421</td>
<td>set</td>
<td>set</td>
<td>设置，集合</td>
<td></td>
</tr>
<tr>
<td>422</td>
<td>sharing</td>
<td>shar</td>
<td>分享</td>
<td></td>
</tr>
<tr>
<td>423</td>
<td>shift</td>
<td>shift</td>
<td>移位</td>
<td></td>
</tr>
<tr>
<td>424</td>
<td>signal</td>
<td>sig</td>
<td>信号</td>
<td></td>
</tr>
<tr>
<td>425</td>
<td>simplicity</td>
<td>simpl</td>
<td>简单</td>
<td></td>
</tr>
<tr>
<td>426</td>
<td>simulation</td>
<td>simul</td>
<td>模拟</td>
<td></td>
</tr>
<tr>
<td>427</td>
<td>situation</td>
<td>situat</td>
<td>情况</td>
<td></td>
</tr>
<tr>
<td>428</td>
<td>size</td>
<td>sz</td>
<td>大小</td>
<td></td>
</tr>
<tr>
<td>429</td>
<td>skew</td>
<td>skew</td>
<td>偏斜</td>
<td></td>
</tr>
<tr>
<td>430</td>
<td>skill</td>
<td>skill</td>
<td>技能</td>
<td></td>
</tr>
<tr>
<td>431</td>
<td>slave</td>
<td>slv</td>
<td>从机</td>
<td>“master</td>
</tr>
<tr>
<td>432</td>
<td>slope</td>
<td>slope</td>
<td>斜率</td>
<td></td>
</tr>
<tr>
<td>433</td>
<td>software</td>
<td>SW</td>
<td>软件</td>
<td></td>
</tr>
<tr>
<td>434</td>
<td>solution</td>
<td>solut</td>
<td>解决方法</td>
<td></td>
</tr>
<tr>
<td>435</td>
<td>source</td>
<td>src</td>
<td>源头</td>
<td></td>
</tr>
<tr>
<td>436</td>
<td>space</td>
<td>space</td>
<td>空间</td>
<td></td>
</tr>
<tr>
<td>437</td>
<td>stability</td>
<td>stabil</td>
<td>稳定性</td>
<td></td>
</tr>
<tr>
<td>438</td>
<td>stack</td>
<td>stk</td>
<td>栈</td>
<td></td>
</tr>
<tr>
<td>439</td>
<td>standard</td>
<td>std</td>
<td>标准</td>
<td></td>
</tr>
<tr>
<td>440</td>
<td>start</td>
<td>start</td>
<td>开始</td>
<td>stop</td>
</tr>
<tr>
<td>441</td>
<td>state</td>
<td>state</td>
<td>状态</td>
<td></td>
</tr>
<tr>
<td>442</td>
<td>statistic</td>
<td>stats</td>
<td>统计</td>
<td></td>
</tr>
<tr>
<td>443</td>
<td>status</td>
<td>status</td>
<td>状态</td>
<td></td>
</tr>
<tr>
<td>444</td>
<td>step</td>
<td>step</td>
<td>步进</td>
<td></td>
</tr>
<tr>
<td>445</td>
<td>stop</td>
<td>stop</td>
<td>停止</td>
<td>start</td>
</tr>
<tr>
<td>446</td>
<td>storage</td>
<td>stor</td>
<td>存储</td>
<td></td>
</tr>
<tr>
<td>447</td>
<td>stream</td>
<td>stm</td>
<td>流</td>
<td></td>
</tr>
<tr>
<td>448</td>
<td>string</td>
<td>str</td>
<td>字符串</td>
<td></td>
</tr>
<tr>
<td>449</td>
<td>subtract</td>
<td>sub</td>
<td>减去</td>
<td>add</td>
</tr>
<tr>
<td>450</td>
<td>suffix</td>
<td>sfx</td>
<td>后缀</td>
<td>postfix</td>
</tr>
<tr>
<td>451</td>
<td>summation</td>
<td>sum</td>
<td>求和</td>
<td></td>
</tr>
<tr>
<td>452</td>
<td>support</td>
<td></td>
<td>支持</td>
<td></td>
</tr>
<tr>
<td>453</td>
<td>surplus</td>
<td>surpl</td>
<td>剩余</td>
<td>freesize</td>
</tr>
<tr>
<td>454</td>
<td>suspend</td>
<td>suspend</td>
<td>“暂停</td>
<td>挂起”</td>
</tr>
<tr>
<td>455</td>
<td>switch</td>
<td>sw</td>
<td>开关</td>
<td></td>
</tr>
<tr>
<td>456</td>
<td>symbol</td>
<td></td>
<td>记号</td>
<td></td>
</tr>
<tr>
<td>457</td>
<td>synchronize</td>
<td>sync</td>
<td>同步</td>
<td></td>
</tr>
<tr>
<td>458</td>
<td>syntax</td>
<td></td>
<td>语法</td>
<td></td>
</tr>
<tr>
<td>459</td>
<td>system</td>
<td>sys</td>
<td>系统</td>
<td></td>
</tr>
<tr>
<td>460</td>
<td>table</td>
<td>tbl</td>
<td>表</td>
<td></td>
</tr>
<tr>
<td>461</td>
<td>target</td>
<td>tar</td>
<td>目标</td>
<td></td>
</tr>
<tr>
<td>462</td>
<td>temperature</td>
<td>temp</td>
<td>温度</td>
<td></td>
</tr>
<tr>
<td>463</td>
<td>temporary</td>
<td>temp</td>
<td>临时</td>
<td></td>
</tr>
<tr>
<td>464</td>
<td>terminal</td>
<td>term</td>
<td>终端</td>
<td></td>
</tr>
<tr>
<td>465</td>
<td>terminate</td>
<td>term</td>
<td>终止</td>
<td></td>
</tr>
<tr>
<td>466</td>
<td>test</td>
<td>test</td>
<td>测试</td>
<td></td>
</tr>
<tr>
<td>467</td>
<td>text</td>
<td>txt</td>
<td>文本</td>
<td></td>
</tr>
<tr>
<td>468</td>
<td>threshold</td>
<td>thresh</td>
<td>阈值</td>
<td></td>
</tr>
<tr>
<td>469</td>
<td>time</td>
<td>t</td>
<td>时间</td>
<td></td>
</tr>
<tr>
<td>470</td>
<td>timer</td>
<td>timer</td>
<td>定时器</td>
<td></td>
</tr>
<tr>
<td>471</td>
<td>total</td>
<td>tot</td>
<td>总共</td>
<td></td>
</tr>
<tr>
<td>472</td>
<td>transfer</td>
<td>trf</td>
<td>转移</td>
<td></td>
</tr>
<tr>
<td>473</td>
<td>transmission</td>
<td>trans</td>
<td>传输</td>
<td></td>
</tr>
<tr>
<td>474</td>
<td>trigger</td>
<td>trig</td>
<td>触发</td>
<td></td>
</tr>
<tr>
<td>475</td>
<td>underflow</td>
<td>underflow</td>
<td>下溢</td>
<td></td>
</tr>
<tr>
<td>476</td>
<td>unknown</td>
<td>unk</td>
<td>未知</td>
<td></td>
</tr>
<tr>
<td>477</td>
<td>unlock</td>
<td>unlock</td>
<td>解锁</td>
<td>lock</td>
</tr>
<tr>
<td>478</td>
<td>up</td>
<td>up</td>
<td>向上</td>
<td></td>
</tr>
<tr>
<td>479</td>
<td>update</td>
<td>upd</td>
<td>更新</td>
<td></td>
</tr>
<tr>
<td>480</td>
<td>upgrade</td>
<td>upg</td>
<td>升级</td>
<td></td>
</tr>
<tr>
<td>481</td>
<td>urgent</td>
<td>urg</td>
<td>紧急</td>
<td></td>
</tr>
<tr>
<td>482</td>
<td>user</td>
<td>usr</td>
<td>用户</td>
<td></td>
</tr>
<tr>
<td>483</td>
<td>util</td>
<td>util</td>
<td>工具</td>
<td>tool</td>
</tr>
<tr>
<td>484</td>
<td>valid</td>
<td>vld</td>
<td>有效的</td>
<td></td>
</tr>
<tr>
<td>485</td>
<td>validation</td>
<td>val</td>
<td>验证</td>
<td></td>
</tr>
<tr>
<td>486</td>
<td>value</td>
<td>val</td>
<td>值</td>
<td></td>
</tr>
<tr>
<td>487</td>
<td>variable</td>
<td>var</td>
<td>变量</td>
<td></td>
</tr>
<tr>
<td>488</td>
<td>vector</td>
<td>vec</td>
<td>向量</td>
<td></td>
</tr>
<tr>
<td>489</td>
<td>vendor</td>
<td></td>
<td>厂商</td>
<td>manufacturer</td>
</tr>
<tr>
<td>490</td>
<td>verification</td>
<td>vrf</td>
<td>验证</td>
<td></td>
</tr>
<tr>
<td>491</td>
<td>version</td>
<td>ver</td>
<td>版本</td>
<td></td>
</tr>
<tr>
<td>492</td>
<td>vertical</td>
<td>vert</td>
<td>垂直的</td>
<td>horizontal</td>
</tr>
<tr>
<td>493</td>
<td>virtual</td>
<td>virt</td>
<td>虚拟</td>
<td></td>
</tr>
<tr>
<td>494</td>
<td>voltage</td>
<td>volt</td>
<td>电压</td>
<td></td>
</tr>
<tr>
<td>495</td>
<td>watchdog</td>
<td>wdt</td>
<td>看门狗</td>
<td></td>
</tr>
<tr>
<td>496</td>
<td>weight</td>
<td>wt</td>
<td>权重</td>
<td></td>
</tr>
<tr>
<td>497</td>
<td>width</td>
<td>wid</td>
<td>宽度</td>
<td>length</td>
</tr>
<tr>
<td>498</td>
<td>window</td>
<td>win</td>
<td>窗口</td>
<td></td>
</tr>
<tr>
<td>499</td>
<td>word</td>
<td>word</td>
<td>字</td>
<td></td>
</tr>
<tr>
<td>500</td>
<td>write</td>
<td>write</td>
<td>写入</td>
<td>read</td>
</tr>
</tbody></table>
]]></content>
      <categories>
        <category>嵌入式</category>
      </categories>
      <tags>
        <tag>常用英文集</tag>
      </tags>
  </entry>
  <entry>
    <title>Linux中的内存管理机制</title>
    <url>/2023/01/15/linux-docs/%E5%86%85%E5%AD%98%E7%AE%A1%E7%90%86/Linux%E4%B8%AD%E7%9A%84%E5%86%85%E5%AD%98%E7%AE%A1%E7%90%86%E6%9C%BA%E5%88%B6/</url>
    <content><![CDATA[<p>程序在运行时所有的数据结构的分配都是在堆和栈上进行的，而堆和栈都是建立在内存之上。内存作为现代计算机运行的核心，CPU可以直接访问的通用存储只有内存和处理器内置的寄存器，所有的代码都需要装载到内存之后才能让CPU通过指令寄存器找到相应的地址进行访问。</p>
<h2 id="地址空间和MMU"><a href="#地址空间和MMU" class="headerlink" title="地址空间和MMU"></a>地址空间和MMU</h2><p>内存管理单元(MMU)是硬件提供的最底层的内存管理机制，是CPU的一部分，用来管理内存的控制线路，提供把虚拟地址映射为物理地址的能力。</p>
<p>在x86体系结构下，CPU对内存的寻址都是通过分段方式进行的。其工作流程为：CPU生成逻辑地址并交给分段单元。分段单元为每个逻辑地址生成一个线性地址。然后线性地址交给分页单元，以生成内存的物理地址。因此也就是分段和分页单元组成了内存管理单元(MMU)。</p>
<p><img src="https://user-images.githubusercontent.com/87457873/127829473-f0b75808-a851-4bbe-8902-c785d29f80cc.png" alt="image"></p>
<p>其中： + 虚拟地址：在段中的偏移地址 + 线性地址：在某个段中“基地址+偏移地址”得出的地址 + 物理地址：在x86中，MMU还提供了分页机制，假如没有开启分页机制，那么线性地址就等于物理地址；否则还需要经过分页机制换算后线性地址才能转换成物理地址。 一个段是由“基地址+段界限（该段长度）+类型”组成，主要确定了段的起始地址，段的界限长度和确定段的属性如是否可读、可写、段的基本粒度单位、表述该段是数据段还是代码段等。 分段允许进程的物理地址空间是非连续的，分页则是提供这一优势的另外一种内存管理方案，并且<strong>分页避免了外部碎片和紧缩，分段却不可以</strong>。在x86体系中MMU支持多级的分页模型，主要分为以下三种情况： 1. 32为系统分为2级分页模型 2. 32位系统开启了物理地址扩展模式（PAE），则分为3级分页模型 3. 64位系统分为4级分页模型 80x86的分页机制由CR0中的PG位开启，若PG&#x3D;0则禁用分页机制，也就是直接将线性地址作为物理地址。32位的线性地址主要分为三个部分：</p>
<p><img src="https://user-images.githubusercontent.com/87457873/127829505-dfe80b4a-5b4e-4710-9014-141fda4f1e2d.png" alt="image"></p>
<ul>
<li>22-31位指向页目录表中的某一项，页目录表中的每一项存有4子节地址指向页表。所以页表目录大小为4 * 2<sup>10</sup> &#x3D; 4K</li>
<li>12-21位指向页表中的某一项，页表大小与页目录表相同为4K</li>
<li>一个物理页为4K，刚好0-11位指向页表中的偏移，一个页表刚好4K(2<sup>12</sup>)</li>
</ul>
<p>页表和页目录表可以存放在内存的任何地方，当分页机制开启后，需要让CR3寄存器指向页目录表的起始地址。</p>
<blockquote>
<p>CR0-CR4这五个寄存器为系统内的控制寄存器，与分页机制密切相关。<br>CR0控制寄存器是一些特殊的寄存器，可以控制CPU的一些重要特性；<br>CR1是未定义的控制寄存器，供将来使用；<br>CR2是页故障线性地址寄存器，保存最后一次出现页故障的全32位线性地址；<br>CR3是页目录基址寄存器，保存页目录表的物理地址（页目录表总是放在4k为单位的存储器边界上，因此其低12位总为0不起作用，即使写上内容也不会被理会）<br>CR4在Pentium系列（包括486后期版本）处理器中才出现，处理事务包括何时启用虚拟8086模式等。</p>
</blockquote>
<h3 id="Linux中的分段与分页"><a href="#Linux中的分段与分页" class="headerlink" title="Linux中的分段与分页"></a>Linux中的分段与分页</h3><p>MMU在保护模式下分段数据主要定义在GDT中。</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">//arch/x86/kernel/cpu/common.c</span></span><br><span class="line"></span><br><span class="line">DEFINE_PER_CPU_PAGE_ALIGNED(<span class="keyword">struct</span> gdt_page, gdt_page) = &#123; .gdt = &#123;</span><br><span class="line">...</span><br><span class="line">    [GDT_ENTRY_KERNEL_CS]       = GDT_ENTRY_INIT(<span class="number">0xc09a</span>, <span class="number">0</span>, <span class="number">0xfffff</span>), <span class="comment">//代码段</span></span><br><span class="line">    [GDT_ENTRY_KERNEL_DS]       = GDT_ENTRY_INIT(<span class="number">0xc092</span>, <span class="number">0</span>, <span class="number">0xfffff</span>), <span class="comment">//数据段</span></span><br><span class="line">    [GDT_ENTRY_DEFAULT_USER_CS] = GDT_ENTRY_INIT(<span class="number">0xc0fa</span>, <span class="number">0</span>, <span class="number">0xfffff</span>),</span><br><span class="line">    [GDT_ENTRY_DEFAULT_USER_DS] = GDT_ENTRY_INIT(<span class="number">0xc0f2</span>, <span class="number">0</span>, <span class="number">0xfffff</span>),</span><br><span class="line">...</span><br><span class="line">&#125; &#125;;</span><br><span class="line">EXPORT_PER_CPU_SYMBOL_GPL(gdt_page);</span><br></pre></td></tr></table></figure>

<p>通过代码可知道这些段的基地址都是0，界限为4G。说明Linux只定义了一个段，并没有真正利用分段机制。</p>
<p>Linux中只用了一个段，而且基地址从0开始，那么在程序中使用的虚地址就是线性地址了。Linux为了兼容64位、32位及其PAE扩展情况，在代码中通过4级分页机制来做兼容。</p>
<h2 id="Linux的内存分配与管理"><a href="#Linux的内存分配与管理" class="headerlink" title="Linux的内存分配与管理"></a>Linux的内存分配与管理</h2><p>在32位的x86设备中，Linux为每个进程分配的虚拟地址空间都是0-4GB，其中</p>
<ul>
<li>0-3GB用于用户态使用</li>
<li>3GB-3GB+896MB映射到物理地址的0-896MB处，作为内核态地址空间</li>
<li>3GB+896MB-4GB之间的128MB空间用于vmalloc保留区域，该区域用于kmalloc、kmap固定地址映射等功能，可以让内核访问高端物理地址空间</li>
</ul>
<p><img src="https://user-images.githubusercontent.com/87457873/127830151-38a9f1b1-7a64-49f6-9c04-5b1945683368.png" alt="image"></p>
<p>Linux中进程的地址空间由mm_struct来描述，一个进程只会有一个mm_struct。系统中的内核态是共享的，不会发生缺页中断或者访问用户进程空间，所以内核线程的task_struct-&gt;mm为NULL。</p>
<p>页表的分配分为两个部分：</p>
<p>1、内核页表，也就是在系统启动中，最后会在paging_init函数中，把ZONE_DMA和ZONE_NORMAL区域的物理页面与虚拟地址空间的3GB-3GB+896MB进行直接映射<br><br>2、内核高端地址和用户态地址，都是通过MMU机制修改线性地址（虚拟地址）和物理地址的映射关系，然后刷新页表缓存来达到的<br></p>
<blockquote>
<p>物理内存中ZONE_DMA的范围是0-16MB，该区域的物理页面专门供IO设备的DMA使用，之所以要单独管理DMA的物理页面，是因为DMA使用物理地址访问内存不经过MMU，并且需要连续的缓冲区。为了能够提供物理上的连续缓冲区，必须从物理地址专门划分出一段区域用于DMA。 ZONE_NORMAL的范围是16MB-896MB，该区域的物理页面是内核能够直接使用的。 ZONE_HIGHMEM的范围是896MB-结束，该区域即高端内存，内核不能直接使用。</p>
</blockquote>
<h3 id="伙伴系统"><a href="#伙伴系统" class="headerlink" title="伙伴系统"></a>伙伴系统</h3><p>对于物理内存经过频繁地申请和释放后会产生外部碎片，Linux通过伙伴系统来解决外部碎片的问题。</p>
<p>满足:<br><br>1.具有相同的大小；<br><br>2.物理地址连续条件的两个块为伙伴。主要实现思路位伙伴系统在申请内存的时候让最小的块满足申请的需求，在归还的时候，尽量让连续的小块内存伙伴合并成大块，降低外部碎片出现的可能性。<br></p>
<p>在Linux系统中伙伴系统维护了11个块链表，每个块链表分别包含了大小为2<sup>0</sup>-2<sup>11</sup>个连续的物理页。对1024个页的最大请求对应着4MB大小的连续RAM块。每个快的第一个页框的物理地址就是该块大小的整数倍。如大小为16个页框的块，其起始地址为16×2<sup>12</sup>(2<sup>12</sup>&#x3D;4KB这是一个页的大小)的倍数。</p>
<p>系统在初始化的时候把内各节点各区域都释放到伙伴系统中，每个区域还维护了per-cpu高速缓存来处理单页的分配，各个区域都通过伙伴算法进行物理内存的分配。</p>
<h3 id="slab分配器"><a href="#slab分配器" class="headerlink" title="slab分配器"></a>slab分配器</h3><p>Linux系统通过伙伴算法解决了外部碎片的问题，此外还提供了slab分配器来处理内部碎片的问题。slab分配器也是一种内存预分配机制，是一种空间换时间的做法，并且其假定从slab分配器中获得的内存都是比页还小的小内存块。</p>
<p><img src="https://user-images.githubusercontent.com/87457873/127836300-b01190fe-eaef-4fba-9118-ae7b14ce9409.png" alt="image"></p>
<p>slab的设计思想就是把若干的页框合在一起形成一大存储块——slab，并在这个slab中只存储同一类数据，这样就可以在这个slab内部打破页的界限，以该类型数据的大小来定义分配粒度，存放多个数据，这样就可以尽可能地减少页内碎片了。在Linux中，多个存储同类数据的slab的集合叫做一类对象的缓冲区——cache。注意，这不是硬件的那个cache，只是借用这个名词而已。</p>
<p>Linux中slab的可分为以下三种状态：</p>
<p>1、slabs_full：该链表中slab已经完全分配出去<br><br>2、slabs_free：该链表中的slab都是空闲可分配状态<br><br>3、labs_partial：该链表中的slab部分已经被分配出去了<br></p>
<p>其中slab代表物理地址连续的内存块，由1-N个物理页面组成，在一个slab中可以分配多个object对象。</p>
<p>slab的优点：</p>
<ul>
<li>内核通常依赖于对小对象的分配，它们会在系统生命周期内进行无数次分配。slab 缓存分配器通过对类似大小的对象进行缓存而提供这种功能，从而避免了常见的碎片问题；</li>
<li>slab 分配器还支持通用对象的初始化，从而避免了为同一目的而对一个对象重复进行初始化；</li>
<li>slab 分配器还可以支持硬件缓存对齐和着色，这允许不同缓存中的对象占用相同的缓存行，从而提高缓存的利用率并获得更好的性能。</li>
</ul>
<p>slab的缺点：</p>
<ul>
<li>较多复杂的队列管理。在slab分配器中存在众多的队列，例如针对处理器的本地缓存队列，slab中空闲队列，每个slab处于一个特定状态的队列之中。</li>
<li>slab管理数据和队列的存储开销比较大。每个slab需要一个struct slab数据结构和一个管理者kmem_bufctl_t型的数组。当对象体积较小时，该数组将造成较大的开销（比如对象大小为32字节时，将浪费1&#x2F;8空间）。同时，缓冲区针对节点和处理器的队列也会浪费不少内存。</li>
<li>缓冲区回收、性能调试调优比较复杂。</li>
</ul>
<h3 id="内核态内存管理"><a href="#内核态内存管理" class="headerlink" title="内核态内存管理"></a>内核态内存管理</h3><p>根据之前的的Linux的内存管理机制，即伙伴系统和slab分配器。对于内核态的内存分配主要通过函数kmalloc和vmalloc完成。</p>
<p><img src="https://user-images.githubusercontent.com/87457873/127831151-76b0c09b-b383-4281-9443-eb8a9a14b0c4.png" alt="image"></p>
<p>其中kmalloc函数可以为内核申请连续物理地址的内存空间，由于kmalloc是基于slab分配器实现的，所以比较适合较小块的内存申请。kmalloc函数的调用过程为：<code>kmalloc-&gt;__kmalloc-&gt;__do_kmalloc</code>，其中<code>__do_kmalloc</code>的实现主要分为两步：</p>
<p>1、通过<code>kmalloc_slab</code>找到一个合适的<code>kmem_cache</code>缓存<br><br>2、通过<code>slab_alloc</code>向slab分配器申请对象内存空间<br></p>
<p>Linux提供的vmalloc函数可以获得连续的虚拟空间，但是其物理内存不一定连续。vmalloc函数的调用过程为：<code>vmalloc-&gt;__vmalloc_node_flags-&gt;__vmalloc_node-&gt;__vmalloc_node_range</code>。其中<code>__vmalloc_node_range</code>函数也分为两步：</p>
<p>1、通过<code>__get_vm_area_node</code>分配一个可用的虚拟地址空间<br><br>2、<code>__vmalloc_node_range</code>通过<code>alloc_pages</code>一页一页申请物理内存，再为刚才申请的虚拟地址空间分配物理页表映射<br></p>
]]></content>
      <categories>
        <category>linux-doc 内存管理</category>
      </categories>
      <tags>
        <tag>Linux</tag>
      </tags>
  </entry>
  <entry>
    <title>Linux内存管理机制</title>
    <url>/2023/01/15/linux-docs/%E5%86%85%E5%AD%98%E7%AE%A1%E7%90%86/Linux%E5%86%85%E5%AD%98%E7%AE%A1%E7%90%86%E6%9C%BA%E5%88%B6/</url>
    <content><![CDATA[<h2 id="1、背景"><a href="#1、背景" class="headerlink" title="1、背景"></a>1、背景</h2><ul>
<li>本文试图通过linux内核源码分析linux的内存管理机制，并且对比内核提供的几个分配内存的接口函数。然后聊下slab层的用法以及接口函数。</li>
</ul>
<h2 id="2、内核分配内存与用户态分配内存"><a href="#2、内核分配内存与用户态分配内存" class="headerlink" title="2、内核分配内存与用户态分配内存"></a>2、内核分配内存与用户态分配内存</h2><ul>
<li>内核分配内存与用户态分配内存显然是不同的，内核不可以像用户态那样奢侈的使用内存，内核使用内存一定是谨小慎微的。并且，在用户态如果出现内存溢出因为有内存保护机制，可能只是一个报错或警告，而在内核态若出现内存溢出后果就会严重的多（毕竟再没有管理者了）。</li>
</ul>
<h2 id="3、页"><a href="#3、页" class="headerlink" title="3、页"></a>3、页</h2><ul>
<li>我们知道处理器处理数据的基本单位是字。而内核把页作为内存管理的基本单位。那么，页在内存中是如何描述的？</li>
<li>内核用struct page结构体表示系统中的每一个物理页：</li>
</ul>
<p><img src="https://pic4.zhimg.com/80/v2-77cb4c8e04103730a7ce581f149f60df_720w.webp" alt="img"></p>
<ul>
<li>flags存放页的状态，如该页是不是脏页。</li>
<li>_count域表示该页的使用计数，如果该页未被使用，就可以在新的分配中使用它。</li>
<li>要注意的是，page结构体描述的是物理页而非逻辑页，描述的是内存页的信息而不是页中数据。</li>
<li>实际上每个物理页面都由一个page结构体来描述，有的人可能会惊讶说那这得需要多少内存呢？我们可以来算一下，若一个struct page占用40字节内存，一个页有8KB，内存大小为4G的话，共有524288个页面，需要刚好20MB的大小来存放结构体。这相对于4G的内存根本九牛一毛。</li>
</ul>
<h2 id="4、区"><a href="#4、区" class="headerlink" title="4、区"></a>4、区</h2><ul>
<li>有些页是有特定用途的。比如内存中有些页是专门用于DMA的。</li>
<li>内核使用区的概念将具有相似特性的页进行分组。区是一种逻辑上的分组的概念，而没有物理上的意义。</li>
<li>区的实际使用和分布是与体系结构相关的。在x86体系结构中主要分为3个区：ZONE_DMA，ZONE_NORMAL，ZONE_HIGHMEM。</li>
<li>ZONE_DMA区中的页用来进行DMA时使用。ZONE_HIGHMEM是高端内存，其中的页不能永久的映射到内核地址空间，也就是说，没有虚拟地址。剩余的内存就属于ZONE_NORMAL区。</li>
<li>我们可以看一下描述区的结构体struct zone（在linux&#x2F;mmzone.h中定义）。</li>
</ul>
<p><img src="https://pic1.zhimg.com/80/v2-f614dbdf9b08631eabf3158ceef5ff78_720w.webp" alt="img"></p>
<ul>
<li>这个结构体比较长，我只截取了一部分出来。</li>
<li>实际上不是所有的体系结构都定义了全部区，有些64位的体系结构，比如Intel的x86-64体系结构可以映射和处理64位的内存空间，所以其没有ZONE_HIGHMEM区。而有些体系结构中的所有地址都可用于DMA，所以这些体系结构就没有ZONE_DMA区。</li>
</ul>
<h2 id="5、内核中内存分配接口"><a href="#5、内核中内存分配接口" class="headerlink" title="5、内核中内存分配接口"></a>5、内核中内存分配接口</h2><ul>
<li>我们现在已经大体了解了内核中的页与区的概念及描述。接下来我们就可以来看看内核中有哪些内存分配与释放的接口。在内核中，我们正是通过这些接口来分配与释放内存的。首先我们来看看以页为单位进行分配的接口函数。</li>
</ul>
<h2 id="6、获得页与释放页"><a href="#6、获得页与释放页" class="headerlink" title="6、获得页与释放页"></a>6、获得页与释放页</h2><ul>
<li>获得页</li>
<li>获得页使用的接口是alloc_pages函数，我们来看下它的源码（位于linux&#x2F;gfp.h中）</li>
</ul>
<p><img src="https://pic1.zhimg.com/80/v2-0cda6b20bf52c617b2845b226c869acc_720w.webp" alt="img"></p>
<ul>
<li>可以看到，该函数返回值是指向page结构体的指针，参数gfp_mask是一个标志，简单来讲就是获得页所使用的行为方式。order参数规定分配多少页面，该函数分配2的order次方个连续的物理页面。返回的指针指向的是第一page页面。</li>
<li>获得页的方式不只一种，我们还可以使用__get_free_pages函数来获得页，该函数和alloc_pages的参数一样，然而它会返回一个虚拟地址。源码如下：</li>
</ul>
<p><img src="https://pic1.zhimg.com/80/v2-f86b5807e6672401ee1d45cebed03d7c_720w.webp" alt="img"></p>
<ul>
<li>可以看到，这个函数其实也是调用了alloc_pages函数，只不过在获得了struct page结构体后使用page_address函数获得了虚拟地址。</li>
<li>另外还有alloc_page函数与__get_free_page函数，都是获得一个页，其实就是将前面两个函数的order分别置为了0而已。这里不赘述了。</li>
<li>我们在使用这些接口获取页的时候可能会面对一个问题，我们获得的这些页若是给用户态用，虽然这些页中的数据都是随机产生的垃圾数据，不过，虽然概率很低，但是也有可能会包含某些敏感信息。所以，更谨慎些，我们可以将获得的页都填充为0。这会用到get_zeroed_page函数。看下它的源码：</li>
</ul>
<p><img src="https://pic2.zhimg.com/80/v2-961c9b8c5be9e8fa14bf2836864fda01_720w.webp" alt="img"></p>
<ul>
<li>这个函数也用到了__get_free_pages函数。只是加了一种叫做__GFP_ZERO的gfp_mask方式。所以，这些获得页的函数最终调用的都是alloc_pages函数。alloc_pages函数是获得页的核心函数。</li>
</ul>
<h3 id="6-1释放页"><a href="#6-1释放页" class="headerlink" title="6.1释放页"></a>6.1释放页</h3><ul>
<li>当我们不再需要某些页时可以使用下面的函数释放它们：</li>
</ul>
<blockquote>
<p>__free_pages（struct page *page, unsigned int order）<br>__free_page<br>free_pages<br>free_page（unsigned long addr, unsigned int order）</p>
</blockquote>
<ul>
<li>这些接口都在linux&#x2F;gfp.h中。</li>
<li>释放页的时候一定要小心谨慎，内核中操作不同于在用户态，若是将地址写错，或是order写错，那么都可能会导致系统的崩溃。若是在用户态进行非法操作，内核作为管理者还会阻止并发出警告，而内核是完全信赖自己的，若是在内核态中有非法操作，那么内核可能会挂掉的。</li>
</ul>
<h2 id="7、kmalloc与vmalloc"><a href="#7、kmalloc与vmalloc" class="headerlink" title="7、kmalloc与vmalloc"></a>7、kmalloc与vmalloc</h2><ul>
<li>前面讲的那些接口都是以页为单位进行内存分配与释放的。而在实际中内核需要的内存不一定是整个页，可能只是以字节为单位的一片区域。这两个函数就是实现这样的目的。不同之处在于，kmalloc分配的是虚拟地址连续，物理地址也连续的一片区域，vmalloc分配的是虚拟地址连续，物理地址不一定连续的一片区域。这里依然需要特别注意的就是使用释放内存的函数kfree与vfree时一定要注意准确释放，否则会发生不可预测的严重后果。</li>
</ul>
<h2 id="8、slab层"><a href="#8、slab层" class="headerlink" title="8、slab层"></a>8、slab层</h2><ul>
<li>分配和释放数据结构是内核中的基本操作。有些多次会用到的数据结构如果频繁分配内存必然导致效率低下。slab层就是用于解决频繁分配和释放数据结构的问题。为便于理解slab层的层次结构，请看下图</li>
</ul>
<p><img src="https://pic4.zhimg.com/80/v2-738dd737f55602e9c58986fd7d126083_720w.webp" alt="img"></p>
<ul>
<li>简单的说，物理内存中有多个高速缓存，每个高速缓存都是一个结构体类型，一个高速缓存中会有一个或多个slab，slab通常为一页，其中存放着数据结构类型的实例化对象。</li>
<li>分配高速缓存的接口是struct kmem_cache kmem_cache_create (const char *name, size_t size, size_t align,unsigned long flags, void (*ctor)(void ))。</li>
<li>它返回的是kmem_cache结构体。第一个参数是缓存的名字，第二个参数是高速缓存中每个对象的大小，第三个参数是slab内第一个对象的偏移量。剩下的就不细说。</li>
<li>总之，这个接口函数为一个结构体分配了高速缓存，那么高速缓存有了，是不是就要为缓存中分配实例化的对象呢？这个接口是</li>
<li>void *kmem_cache_alloc(struct kmem_cache *cachep, gfp_t flags)</li>
<li>参数是kmem_cache结构体，也就是分配好的高速缓存，flags是标志位。</li>
<li>抽象的介绍看着不直观， 我们看个具体的例子。之前我写过一个关于jbd2日志系统的博客，介绍过jbd2的模块初始化过程。其中就提到过jbd2在进行模块初始化的时候是会创建几个高速缓冲区的。如下：</li>
</ul>
<p><img src="https://pic4.zhimg.com/80/v2-a64cc625d9ff3764d6148df5eeb849eb_720w.webp" alt="img"></p>
<p>我们看看第一个创建缓冲区的函数。</p>
<p><img src="https://pic2.zhimg.com/80/v2-8e1fda07352ff6af12cfe3cf02915a11_720w.webp" alt="img"></p>
<ul>
<li>首先是断言缓冲区一定为空的。然后用kmem_cache_create创建了两个缓冲区。两个高速缓冲区就这么创建好了。看下图</li>
</ul>
<p><img src="https://pic1.zhimg.com/80/v2-3f6442ce0e51e1567c3bc48a15c29e58_720w.webp" alt="img"></p>
<ul>
<li>这里用kmem_cache结构体，也就是jbd2_revoke_record_cache高速缓存实例化了一个对象。</li>
</ul>
<h2 id="9、总结"><a href="#9、总结" class="headerlink" title="9、总结"></a>9、总结</h2><ul>
<li>内存管理的linux内核源码我只分析了一小部分，主要是总结了一下内核分配与回收内存的接口函数及其用法。</li>
</ul>
<hr>
<p>版权声明：本文为知乎博主「Linux内核库」的原创文章，遵循CC 4.0 BY-SA版权协议，转载请附上原文 出处链接及本声明。 </p>
<p>原文链接：<a href="https://zhuanlan.zhihu.com/p/503687069">https://zhuanlan.zhihu.com/p/503687069</a></p>
]]></content>
      <categories>
        <category>linux-doc 内存管理</category>
      </categories>
      <tags>
        <tag>Linux</tag>
      </tags>
  </entry>
  <entry>
    <title>Linux内核共享内存原理</title>
    <url>/2023/01/15/linux-docs/%E5%86%85%E5%AD%98%E7%AE%A1%E7%90%86/Linux%E5%86%85%E6%A0%B8%E5%85%B1%E4%BA%AB%E5%86%85%E5%AD%98%E5%8E%9F%E7%90%86/</url>
    <content><![CDATA[<ul>
<li>在Linux系统中，每个进程都有独立的虚拟内存空间，也就是说不同的进程访问同一段虚拟内存地址所得到的数据是不一样的，这是因为不同进程相同的虚拟内存地址会映射到不同的物理内存地址上。</li>
<li>但有时候为了让不同进程之间进行通信，需要让不同进程共享相同的物理内存，Linux通过 <code>共享内存</code> 来实现这个功能。下面先来介绍一下Linux系统的共享内存的使用。</li>
</ul>
<h2 id="1、共享内存使用"><a href="#1、共享内存使用" class="headerlink" title="1、共享内存使用"></a>1、<strong>共享内存使用</strong></h2><h3 id="1-1获取共享内存"><a href="#1-1获取共享内存" class="headerlink" title="1.1获取共享内存"></a><strong>1.1获取共享内存</strong></h3><ul>
<li>要使用共享内存，首先需要使用 <code>shmget()</code> 函数获取共享内存，<code>shmget()</code> 函数的原型如下：</li>
</ul>
<figure class="highlight text"><table><tr><td class="code"><pre><span class="line">int shmget(key_t key, size_t size, int shmflg);</span><br></pre></td></tr></table></figure>

<ol>
<li>参数 <code>key</code> 一般由 <code>ftok()</code> 函数生成，用于标识系统的唯一IPC资源。</li>
<li>参数 <code>size</code> 指定创建的共享内存大小。</li>
<li>参数 <code>shmflg</code> 指定 <code>shmget()</code> 函数的动作，比如传入 <code>IPC_CREAT</code> 表示要创建新的共享内存。</li>
</ol>
<ul>
<li>函数调用成功时返回一个新建或已经存在的的共享内存标识符，取决于shmflg的参数。失败返回-1，并设置错误码。</li>
</ul>
<h3 id="1-2关联共享内存"><a href="#1-2关联共享内存" class="headerlink" title="1.2关联共享内存"></a><strong>1.2关联共享内存</strong></h3><ul>
<li><code>shmget()</code> 函数返回的是一个标识符，而不是可用的内存地址，所以还需要调用 <code>shmat()</code> 函数把共享内存关联到某个虚拟内存地址上。<code>shmat()</code> 函数的原型如下：</li>
</ul>
<figure class="highlight text"><table><tr><td class="code"><pre><span class="line">void *shmat(int shmid, const void *shmaddr, int shmflg);</span><br></pre></td></tr></table></figure>

<ol>
<li>参数 <code>shmid</code> 是 <code>shmget()</code> 函数返回的标识符。</li>
<li>参数 <code>shmaddr</code> 是要关联的虚拟内存地址，如果传入0，表示由系统自动选择合适的虚拟内存地址。</li>
<li>参数 <code>shmflg</code> 若指定了 <code>SHM_RDONLY</code> 位，则以只读方式连接此段，否则以读写方式连接此段。</li>
</ol>
<ul>
<li>函数调用成功返回一个可用的指针（虚拟内存地址），出错返回-1。</li>
</ul>
<h3 id="1-3取消关联共享内存"><a href="#1-3取消关联共享内存" class="headerlink" title="1.3取消关联共享内存"></a>1.3<strong>取消关联共享内存</strong></h3><ul>
<li>当一个进程不需要共享内存的时候，就需要取消共享内存与虚拟内存地址的关联。取消关联共享内存通过 <code>shmdt()</code> 函数实现，原型如下：</li>
</ul>
<figure class="highlight text"><table><tr><td class="code"><pre><span class="line">int shmdt(const void *shmaddr);</span><br></pre></td></tr></table></figure>

<ol>
<li>参数 <code>shmaddr</code> 是要取消关联的虚拟内存地址，也就是 <code>shmat()</code> 函数返回的值。</li>
</ol>
<ul>
<li>函数调用成功返回0，出错返回-1。</li>
</ul>
<h3 id="1-4共享内存使用例子"><a href="#1-4共享内存使用例子" class="headerlink" title="1.4共享内存使用例子"></a><strong>1.4共享内存使用例子</strong></h3><ul>
<li>下面通过一个例子来介绍一下共享内存的使用方法。在这个例子中，有两个进程，分别为 <code>进程A</code> 和 <code>进程B</code>，<code>进程A</code> 创建一块共享内存，然后写入数据，<code>进程B</code> 获取这块共享内存并且读取其内容。</li>
</ul>
<h3 id="1-5进程A"><a href="#1-5进程A" class="headerlink" title="1.5进程A"></a><strong>1.5进程A</strong></h3><figure class="highlight text"><table><tr><td class="code"><pre><span class="line">#include &lt;stdio.h&gt;</span><br><span class="line">#include &lt;unistd.h&gt;</span><br><span class="line">#include &lt;sys/types.h&gt;</span><br><span class="line">#include &lt;sys/ipc.h&gt;</span><br><span class="line">#include &lt;sys/shm.h&gt;</span><br><span class="line"></span><br><span class="line">#define SHM_PATH &quot;/tmp/shm&quot;</span><br><span class="line">#define SHM_SIZE 128</span><br><span class="line"></span><br><span class="line">int main(int argc, char *argv[])</span><br><span class="line">&#123;</span><br><span class="line">    int shmid;</span><br><span class="line">    char *addr;</span><br><span class="line">    key_t key = ftok(SHM_PATH, 0x6666);</span><br><span class="line">    </span><br><span class="line">    shmid = shmget(key, SHM_SIZE, IPC_CREAT|IPC_EXCL|0666);</span><br><span class="line">    if (shmid &lt; 0) &#123;</span><br><span class="line">        printf(&quot;failed to create share memory\n&quot;);</span><br><span class="line">        return -1;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    addr = shmat(shmid, NULL, 0);</span><br><span class="line">    if (addr &lt;= 0) &#123;</span><br><span class="line">        printf(&quot;failed to map share memory\n&quot;);</span><br><span class="line">        return -1;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    sprintf(addr, &quot;%s&quot;, &quot;Hello World\n&quot;);</span><br><span class="line">    </span><br><span class="line">    return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="1-5进程B"><a href="#1-5进程B" class="headerlink" title="1.5进程B"></a><strong>1.5进程B</strong></h3><figure class="highlight text"><table><tr><td class="code"><pre><span class="line">#include &lt;stdio.h&gt;</span><br><span class="line">#include &lt;string.h&gt;</span><br><span class="line">#include &lt;unistd.h&gt;</span><br><span class="line">#include &lt;sys/types.h&gt;</span><br><span class="line">#include &lt;sys/ipc.h&gt;</span><br><span class="line">#include &lt;sys/shm.h&gt;</span><br><span class="line"></span><br><span class="line">#define SHM_PATH &quot;/tmp/shm&quot;</span><br><span class="line">#define SHM_SIZE 128</span><br><span class="line"></span><br><span class="line">int main(int argc, char *argv[])</span><br><span class="line">&#123;</span><br><span class="line">    int shmid;</span><br><span class="line">    char *addr;</span><br><span class="line">    key_t key = ftok(SHM_PATH, 0x6666);</span><br><span class="line">    </span><br><span class="line">    char buf[128];</span><br><span class="line">    </span><br><span class="line">    shmid = shmget(key, SHM_SIZE, IPC_CREAT);</span><br><span class="line">    if (shmid &lt; 0) &#123;</span><br><span class="line">        printf(&quot;failed to get share memory\n&quot;);</span><br><span class="line">        return -1;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    addr = shmat(shmid, NULL, 0);</span><br><span class="line">    if (addr &lt;= 0) &#123;</span><br><span class="line">        printf(&quot;failed to map share memory\n&quot;);</span><br><span class="line">        return -1;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    strcpy(buf, addr, 128);</span><br><span class="line">    printf(&quot;%s&quot;, buf);</span><br><span class="line">    </span><br><span class="line">    return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li>测试时先运行进程A，然后再运行进程B，可以看到进程B会打印出 “Hello World”，说明共享内存已经创建成功并且读取。</li>
</ul>
<h2 id="2、共享内存实现原理"><a href="#2、共享内存实现原理" class="headerlink" title="2、共享内存实现原理"></a><strong>2、共享内存实现原理</strong></h2><ul>
<li>我们先通过一幅图来了解一下共享内存的大概原理，如下图：</li>
</ul>
<p><img src="https://pic4.zhimg.com/80/v2-3209cfa76d596e32532791573ef2973b_720w.webp" alt="img"></p>
<p>图片</p>
<ul>
<li>通过上图可知，共享内存是通过将不同进程的虚拟内存地址映射到相同的物理内存地址来实现的，下面将会介绍Linux的实现方式。</li>
<li>在Linux内核中，每个共享内存都由一个名为 <code>struct shmid_kernel</code> 的结构体来管理，而且Linux限制了系统最大能创建的共享内存为128个。通过类型为 <code>struct shmid_kernel</code> 结构的数组来管理，如下：</li>
</ul>
<figure class="highlight text"><table><tr><td class="code"><pre><span class="line">struct shmid_ds &#123;</span><br><span class="line"> struct ipc_perm  shm_perm; /* operation perms */</span><br><span class="line"> int   shm_segsz; /* size of segment (bytes) */</span><br><span class="line"> __kernel_time_t  shm_atime; /* last attach time */</span><br><span class="line"> __kernel_time_t  shm_dtime; /* last detach time */</span><br><span class="line"> __kernel_time_t  shm_ctime; /* last change time */</span><br><span class="line"> __kernel_ipc_pid_t shm_cpid; /* pid of creator */</span><br><span class="line"> __kernel_ipc_pid_t shm_lpid; /* pid of last operator */</span><br><span class="line"> unsigned short  shm_nattch; /* no. of current attaches */</span><br><span class="line"> unsigned short   shm_unused; /* compatibility */</span><br><span class="line"> void    *shm_unused2; /* ditto - used by DIPC */</span><br><span class="line"> void   *shm_unused3; /* unused */</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">struct shmid_kernel</span><br><span class="line">&#123; </span><br><span class="line"> struct shmid_ds  u;</span><br><span class="line"> /* the following are private */</span><br><span class="line"> unsigned long  shm_npages; /* size of segment (pages) */</span><br><span class="line"> pte_t   *shm_pages; /* array of ptrs to frames -&gt; SHMMAX */ </span><br><span class="line"> struct vm_area_struct *attaches; /* descriptors for attaches */</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">static struct shmid_kernel *shm_segs[SHMMNI]; // SHMMNI等于128</span><br></pre></td></tr></table></figure>

<ul>
<li>从注释可以知道 <code>struct shmid_kernel</code> 结构体各个字段的作用，比如 <code>shm_npages</code> 字段表示共享内存使用了多少个内存页。而 <code>shm_pages</code> 字段指向了共享内存映射的虚拟内存页表项数组等。</li>
<li>另外 <code>struct shmid_ds</code> 结构体用于管理共享内存的信息，而 <code>shm_segs数组</code> 用于管理系统中所有的共享内存。</li>
</ul>
<h3 id="2-1shmget-函数实现"><a href="#2-1shmget-函数实现" class="headerlink" title="2.1shmget() 函数实现"></a><strong>2.1shmget() 函数实现</strong></h3><ul>
<li>通过前面的例子可知，要使用共享内存，首先需要调用 <code>shmget()</code> 函数来创建或者获取一块共享内存。<code>shmget()</code> 函数的实现如下：</li>
</ul>
<figure class="highlight text"><table><tr><td class="code"><pre><span class="line">asmlinkage long sys_shmget (key_t key, int size, int shmflg)</span><br><span class="line">&#123;</span><br><span class="line"> struct shmid_kernel *shp;</span><br><span class="line"> int err, id = 0;</span><br><span class="line"></span><br><span class="line"> down(&amp;current-&gt;mm-&gt;mmap_sem);</span><br><span class="line"> spin_lock(&amp;shm_lock);</span><br><span class="line"> if (size &lt; 0 || size &gt; shmmax) &#123;</span><br><span class="line">  err = -EINVAL;</span><br><span class="line"> &#125; else if (key == IPC_PRIVATE) &#123;</span><br><span class="line">  err = newseg(key, shmflg, size);</span><br><span class="line"> &#125; else if ((id = findkey (key)) == -1) &#123;</span><br><span class="line">  if (!(shmflg &amp; IPC_CREAT))</span><br><span class="line">   err = -ENOENT;</span><br><span class="line">  else</span><br><span class="line">   err = newseg(key, shmflg, size);</span><br><span class="line"> &#125; else if ((shmflg &amp; IPC_CREAT) &amp;&amp; (shmflg &amp; IPC_EXCL)) &#123;</span><br><span class="line">  err = -EEXIST;</span><br><span class="line"> &#125; else &#123;</span><br><span class="line">  shp = shm_segs[id];</span><br><span class="line">  if (shp-&gt;u.shm_perm.mode &amp; SHM_DEST)</span><br><span class="line">   err = -EIDRM;</span><br><span class="line">  else if (size &gt; shp-&gt;u.shm_segsz)</span><br><span class="line">   err = -EINVAL;</span><br><span class="line">  else if (ipcperms (&amp;shp-&gt;u.shm_perm, shmflg))</span><br><span class="line">   err = -EACCES;</span><br><span class="line">  else</span><br><span class="line">   err = (int) shp-&gt;u.shm_perm.seq * SHMMNI + id;</span><br><span class="line"> &#125;</span><br><span class="line"> spin_unlock(&amp;shm_lock);</span><br><span class="line"> up(&amp;current-&gt;mm-&gt;mmap_sem);</span><br><span class="line"> return err;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li><code>shmget()</code> 函数的实现比较简单，首先调用 <code>findkey()</code> 函数查找值为key的共享内存是否已经被创建，<code>findkey()</code> 函数返回共享内存在 <code>shm_segs数组</code> 的索引。如果找到，那么直接返回共享内存的标识符即可。否则就调用 <code>newseg()</code> 函数创建新的共享内存。<code>newseg()</code> 函数的实现也比较简单，就是创建一个新的 <code>struct shmid_kernel</code> 结构体，然后设置其各个字段的值，并且保存到 <code>shm_segs数组</code> 中。</li>
</ul>
<h3 id="2-2shmat-函数实现"><a href="#2-2shmat-函数实现" class="headerlink" title="2.2shmat() 函数实现"></a><strong>2.2shmat() 函数实现</strong></h3><ul>
<li><code>shmat()</code> 函数用于将共享内存映射到本地虚拟内存地址，由于 <code>shmat()</code> 函数的实现比较复杂，所以我们分段来分析这个函数：</li>
</ul>
<figure class="highlight text"><table><tr><td class="code"><pre><span class="line">asmlinkage long sys_shmat (int shmid, char *shmaddr, int shmflg, ulong *raddr)</span><br><span class="line">&#123;</span><br><span class="line"> struct shmid_kernel *shp;</span><br><span class="line"> struct vm_area_struct *shmd;</span><br><span class="line"> int err = -EINVAL;</span><br><span class="line"> unsigned int id;</span><br><span class="line"> unsigned long addr;</span><br><span class="line"> unsigned long len;</span><br><span class="line"></span><br><span class="line"> down(&amp;current-&gt;mm-&gt;mmap_sem);</span><br><span class="line"> spin_lock(&amp;shm_lock);</span><br><span class="line"> if (shmid &lt; 0)</span><br><span class="line">  goto out;</span><br><span class="line"></span><br><span class="line"> shp = shm_segs[id = (unsigned int) shmid % SHMMNI];</span><br><span class="line"> if (shp == IPC_UNUSED || shp == IPC_NOID)</span><br><span class="line">  goto out;</span><br></pre></td></tr></table></figure>

<ul>
<li>上面这段代码主要通过 <code>shmid</code> 标识符来找到共享内存描述符，上面说过系统中所有的共享内存到保存在 <code>shm_segs</code> 数组中。</li>
</ul>
<figure class="highlight text"><table><tr><td class="code"><pre><span class="line">if (!(addr = (ulong) shmaddr)) &#123;</span><br><span class="line"> if (shmflg &amp; SHM_REMAP)</span><br><span class="line">  goto out;</span><br><span class="line"> err = -ENOMEM;</span><br><span class="line"> addr = 0;</span><br><span class="line">again:</span><br><span class="line"> if (!(addr = get_unmapped_area(addr, shp-&gt;u.shm_segsz))) // 获取一个空闲的虚拟内存空间</span><br><span class="line">  goto out;</span><br><span class="line"> if(addr &amp; (SHMLBA - 1)) &#123;</span><br><span class="line">  addr = (addr + (SHMLBA - 1)) &amp; ~(SHMLBA - 1);</span><br><span class="line">  goto again;</span><br><span class="line"> &#125;</span><br><span class="line">&#125; else if (addr &amp; (SHMLBA-1)) &#123;</span><br><span class="line"> if (shmflg &amp; SHM_RND)</span><br><span class="line">  addr &amp;= ~(SHMLBA-1);       /* round down */</span><br><span class="line"> else</span><br><span class="line">  goto out;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li>上面的代码主要找到一个可用的虚拟内存地址，如果在调用 <code>shmat()</code> 函数时没有指定了虚拟内存地址，那么就通过 <code>get_unmapped_area()</code> 函数来获取一个可用的虚拟内存地址。</li>
</ul>
<figure class="highlight text"><table><tr><td class="code"><pre><span class="line">spin_unlock(&amp;shm_lock);</span><br><span class="line">err = -ENOMEM;</span><br><span class="line">shmd = kmem_cache_alloc(vm_area_cachep, SLAB_KERNEL);</span><br><span class="line">spin_lock(&amp;shm_lock);</span><br><span class="line">if (!shmd)</span><br><span class="line"> goto out;</span><br><span class="line">if ((shp != shm_segs[id]) || (shp-&gt;u.shm_perm.seq != (unsigned int) shmid / SHMMNI)) &#123;</span><br><span class="line"> kmem_cache_free(vm_area_cachep, shmd);</span><br><span class="line"> err = -EIDRM;</span><br><span class="line"> goto out;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li>上面的代码主要通过调用 <code>kmem_cache_alloc()</code> 函数创建一个 <code>vm_area_struct</code> 结构，在内存管理一章知道，<code>vm_area_struct</code> 结构用于管理进程的虚拟内存空间。</li>
</ul>
<figure class="highlight text"><table><tr><td class="code"><pre><span class="line"> shmd-&gt;vm_private_data = shm_segs + id;</span><br><span class="line"> shmd-&gt;vm_start = addr;</span><br><span class="line"> shmd-&gt;vm_end = addr + shp-&gt;shm_npages * PAGE_SIZE;</span><br><span class="line"> shmd-&gt;vm_mm = current-&gt;mm;</span><br><span class="line"> shmd-&gt;vm_page_prot = (shmflg &amp; SHM_RDONLY) ? PAGE_READONLY : PAGE_SHARED;</span><br><span class="line"> shmd-&gt;vm_flags = VM_SHM | VM_MAYSHARE | VM_SHARED</span><br><span class="line">    | VM_MAYREAD | VM_MAYEXEC | VM_READ | VM_EXEC</span><br><span class="line">    | ((shmflg &amp; SHM_RDONLY) ? 0 : VM_MAYWRITE | VM_WRITE);</span><br><span class="line"> shmd-&gt;vm_file = NULL;</span><br><span class="line"> shmd-&gt;vm_offset = 0;</span><br><span class="line"> shmd-&gt;vm_ops = &amp;shm_vm_ops;</span><br><span class="line"></span><br><span class="line"> shp-&gt;u.shm_nattch++;     /* prevent destruction */</span><br><span class="line"> spin_unlock(&amp;shm_lock);</span><br><span class="line"> err = shm_map(shmd);</span><br><span class="line"> spin_lock(&amp;shm_lock);</span><br><span class="line"> if (err)</span><br><span class="line">  goto failed_shm_map;</span><br><span class="line"></span><br><span class="line"> insert_attach(shp,shmd);  /* insert shmd into shp-&gt;attaches */</span><br><span class="line"></span><br><span class="line"> shp-&gt;u.shm_lpid = current-&gt;pid;</span><br><span class="line"> shp-&gt;u.shm_atime = CURRENT_TIME;</span><br><span class="line"></span><br><span class="line"> *raddr = addr;</span><br><span class="line"> err = 0;</span><br><span class="line">out:</span><br><span class="line"> spin_unlock(&amp;shm_lock);</span><br><span class="line"> up(&amp;current-&gt;mm-&gt;mmap_sem);</span><br><span class="line"> return err;</span><br><span class="line"> ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li>上面的代码主要是设置刚创建的 <code>vm_area_struct</code> 结构的各个字段，比较重要的是设置其 <code>vm_ops</code> 字段为 <code>shm_vm_ops</code>，<code>shm_vm_ops</code> 定义如下：</li>
</ul>
<figure class="highlight text"><table><tr><td class="code"><pre><span class="line">static struct vm_operations_struct shm_vm_ops = &#123;</span><br><span class="line"> shm_open,  /* open - callback for a new vm-area open */</span><br><span class="line"> shm_close,  /* close - callback for when the vm-area is released */</span><br><span class="line"> NULL,   /* no need to sync pages at unmap */</span><br><span class="line"> NULL,   /* protect */</span><br><span class="line"> NULL,   /* sync */</span><br><span class="line"> NULL,   /* advise */</span><br><span class="line"> shm_nopage,  /* nopage */</span><br><span class="line"> NULL,   /* wppage */</span><br><span class="line"> shm_swapout  /* swapout */</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<ul>
<li><code>shm_vm_ops</code> 的 <code>nopage</code> 回调为 <code>shm_nopage()</code> 函数，也就是说，当发生页缺失异常时将会调用此函数来恢复内存的映射。</li>
<li>从上面的代码可看出，<code>shmat()</code> 函数只是申请了进程的虚拟内存空间，而共享内存的物理空间并没有申请，那么在什么时候申请物理内存呢？答案就是当进程发生缺页异常的时候会调用 <code>shm_nopage()</code> 函数来恢复进程的虚拟内存地址到物理内存地址的映射。</li>
</ul>
<h3 id="2-3shm-nopage-函数实现"><a href="#2-3shm-nopage-函数实现" class="headerlink" title="2.3shm_nopage() 函数实现"></a><strong>2.3shm_nopage() 函数实现</strong></h3><ul>
<li>shm_nopage() 函数是当发生内存缺页异常时被调用的，代码如下：</li>
</ul>
<figure class="highlight text"><table><tr><td class="code"><pre><span class="line">static struct page * shm_nopage(struct vm_area_struct * shmd, unsigned long address, int no_share)</span><br><span class="line">&#123;</span><br><span class="line"> pte_t pte;</span><br><span class="line"> struct shmid_kernel *shp;</span><br><span class="line"> unsigned int idx;</span><br><span class="line"> struct page * page;</span><br><span class="line"></span><br><span class="line"> shp = *(struct shmid_kernel **) shmd-&gt;vm_private_data;</span><br><span class="line"> idx = (address - shmd-&gt;vm_start + shmd-&gt;vm_offset) &gt;&gt; PAGE_SHIFT;</span><br><span class="line"></span><br><span class="line"> spin_lock(&amp;shm_lock);</span><br><span class="line">again:</span><br><span class="line"> pte = shp-&gt;shm_pages[idx]; // 共享内存的页表项</span><br><span class="line"> if (!pte_present(pte)) &#123;   // 如果内存页不存在</span><br><span class="line">  if (pte_none(pte)) &#123;</span><br><span class="line">   spin_unlock(&amp;shm_lock);</span><br><span class="line">   page = get_free_highpage(GFP_HIGHUSER); // 申请一个新的物理内存页</span><br><span class="line">   if (!page)</span><br><span class="line">    goto oom;</span><br><span class="line">   clear_highpage(page);</span><br><span class="line">   spin_lock(&amp;shm_lock);</span><br><span class="line">   if (pte_val(pte) != pte_val(shp-&gt;shm_pages[idx]))</span><br><span class="line">    goto changed;</span><br><span class="line">  &#125; else &#123;</span><br><span class="line">   ...</span><br><span class="line">  &#125;</span><br><span class="line">  shm_rss++;</span><br><span class="line">  pte = pte_mkdirty(mk_pte(page, PAGE_SHARED));   // 创建页表项</span><br><span class="line">  shp-&gt;shm_pages[idx] = pte;                      // 保存共享内存的页表项</span><br><span class="line"> &#125; else</span><br><span class="line">  --current-&gt;maj_flt;  /* was incremented in do_no_page */</span><br><span class="line"></span><br><span class="line">done:</span><br><span class="line"> get_page(pte_page(pte));</span><br><span class="line"> spin_unlock(&amp;shm_lock);</span><br><span class="line"> current-&gt;min_flt++;</span><br><span class="line"> return pte_page(pte);</span><br><span class="line"> ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li>shm_nopage() 函数的主要功能是当发生内存缺页时，申请新的物理内存页，并映射到共享内存中。由于使用共享内存时会映射到相同的物理内存页上，从而不同进程可以共用此块内存。</li>
</ul>
<hr>
<p>版权声明：本文为知乎博主「Linux内核库」的原创文章，遵循CC 4.0 BY-SA版权协议，转载请附上原文 出处链接及本声明。 </p>
<p>原文链接：<a href="https://zhuanlan.zhihu.com/p/493986943">https://zhuanlan.zhihu.com/p/493986943</a></p>
]]></content>
      <categories>
        <category>linux-doc 内存管理</category>
      </categories>
      <tags>
        <tag>Linux</tag>
      </tags>
  </entry>
  <entry>
    <title>Linux内核内存分区式存储管理</title>
    <url>/2023/01/15/linux-docs/%E5%86%85%E5%AD%98%E7%AE%A1%E7%90%86/Linux%E5%86%85%E6%A0%B8%E5%86%85%E5%AD%98%E5%88%86%E5%8C%BA%E5%BC%8F%E5%AD%98%E5%82%A8%E7%AE%A1%E7%90%86/</url>
    <content><![CDATA[<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>分区式存储管理最大的缺点是碎片问题严重，内存利用率低。究其原因，主要在于连续分配的限制，即它要求每个作用在内存中必须占一个连续的分区。</p>
<p><strong>如果允许将一个进程分散地装入到许多不相邻的分区中，便可充分地利用内存，而无需再进行“紧凑”。</strong></p>
<p><strong>基于这一思想，产生了“非连续分配方式”，或者称为“离散分配方式”。</strong></p>
<p><img src="https://pic1.zhimg.com/80/v2-1de81658ba2a37163cdc8f15c3cf57b0_720w.webp" alt="img"></p>
<p><strong>连续分配：</strong>为用户进程分配的必须是一个<strong>连续的内存空间。</strong></p>
<p><strong>非连续分配：</strong>为用户进程分配的可以是一些<strong>分散的内存空间。</strong></p>
<p>分页存储管理的思想：把内存分为一个个相等的小分区，再按照分区大小把进程拆分成一个个小部分。</p>
<p>分页存储管理分为：实分页存储管理和虚分页存储管理</p>
<h2 id="1、实分页式存储管理"><a href="#1、实分页式存储管理" class="headerlink" title="1、实分页式存储管理"></a>1、实分页式存储管理</h2><p>实分页式存储最大的优点是内存利用率高，与目前流行的虚分页存储管理相比，具有实现简单，程序运行快的优点。目前，飞速发展的硬件制造技术使得物理内存越来越大，因此我们认为，实分页式存储管理将是一种最有发展前途的存储管理方式。</p>
<h3 id="1-1基本原理"><a href="#1-1基本原理" class="headerlink" title="1.1基本原理"></a>1.1基本原理</h3><p>假设一个大型饭店，所有的客房都是标准的双人间，部分客房已经住进客人，现在又有一个旅游团要求入住。接待员统计了一下，对旅游团领队说：“贵团全体成员都能住下，两人一个房间，但是不能住在同一楼层了，因为每层空着的客房不够，更没有几个挨着的。请原谅！”。对于这样的安排，一般人不会感到奇怪。因为旅游团本来就是由一位位个人或夫妻等组成的，而饭店的客房本来也是两人一间的，两人一组正好可以住在一个客房里；另外，饭店几乎每天都有入住和退房的客人，想在同一楼层找几间挨着的客房实在不容易。</p>
<p>①将整个系统的内存空间划分成一系列<strong>大小相等的块</strong>，每一块称为一个<strong>物理块</strong>、<strong>物理页</strong>或<strong>实页</strong>，<strong>页架</strong>或<strong>页帧（frame）</strong>，可简称为<strong>块（block）</strong>。所有地块按物理地址递增顺序连续编号为0、1、2、……。<br>这里地块相当于饭店的客房，系统对内存分块相当于饭店把大楼所有的客房都设计成标准的双人间。<br>②每个作业的地址空间也划分成一系列与内存块一样大小地块，每一块称为一个<strong>逻辑页</strong>或<strong>虚页</strong>，也有人叫<strong>页面</strong>，可简称为<strong>页（page）</strong>。所有的页按照逻辑地址递增顺序连续编号为0、1、2、……。<br>这里，作业地址空间分页就相当于把旅游团成员分成两人一组。</p>
<p>③一个作业，只要它的总页数不大于内存中的可用块数，系统就可以对它实施分配。系统装入作业时，以页为单位分配内存，一页分配一个块，作业所有的页所占地块可以不连续。系统同时为这个作业建立一个页号与块号的对照表，称为页表。<br>这就像饭店有个记录客户入住情况的客户登记表一样。另外，饭店安排客户入住是要查看全部客房的使用情况一览表，相应的系统给作业分配内存时要查看主存分配表或者内存块说明表。‘<br>④每个块的大小是固定的，一般是个1&#x2F;2KB～4KB之间的数值（请读者思考：块尺寸为什么太大或太小都不好），而且必须是个2的幂次。<br>对块尺寸这样规定相当于饭店规定客房是双人间。可以设想一下，如果上例中饭店所有的客房都是十人间的话，效益肯定不如全是双人间的好</p>
<p><img src="https://pic3.zhimg.com/80/v2-f1784ec50ced23b196ef09f0cde2ef82_720w.webp" alt="img"></p>
<p><strong>实模式下分页存储管理的基本原理：</strong><br>操作系统<strong>以页框为单位为各个进程分配内存空间</strong>。系统自动地将作业的地址空间分页，将系统的主存空间分块，页与块等大小，在作业运行时，一次性把作业的全部页面装入内存，<strong>各个页所占的内存块可以不连续，也不必按先后顺序，可以放到不相邻的各个页框中</strong>。<br>这实际是个把作业从地址空间映射到存储空间的过程</p>
<h3 id="1-2页表"><a href="#1-2页表" class="headerlink" title="1.2页表"></a>1.2页表</h3><p>页面的划分完全是一种系统硬件的行为，一个逻辑地址放到这种地址结构中，自然就分成了页号和页内单元号两部分。</p>
<p><img src="https://pic3.zhimg.com/80/v2-8eb583876cbdd61655a5de2d8d09243a_720w.webp" alt="img"></p>
<p>页面大小为：4KB</p>
<p>在分页系统中，允许将作业（进程）的任一页装入到内存中的任一可用的物理块中，但进程的地址空间本来是连续的，若把他分页后装入到不相邻的物理块中，要保证系统仍能正确运行，就要<strong>实现从进程的逻辑地址变换为内存的物理地址</strong>。</p>
<p>所以，系统为每个进程建立一张页面映射表，简称页表。</p>
<p><img src="https://pic2.zhimg.com/80/v2-2c55f64e238f0f23130ccaac5dee8b41_720w.webp" alt="img"></p>
<h3 id="1-3地址映射"><a href="#1-3地址映射" class="headerlink" title="1.3地址映射"></a>1.3地址映射</h3><p>在系统中设置地址变换机构，能将用户进程地址空间中的逻辑地址变为内存空间中的物理地址。<br>由于页面和物理块的大小相等，页内偏移地址和块内偏移地址是相同的。无须进行从页内地址到块内地址的转换。<br>地址变换机构的任务，关键是将逻辑地址中的页号转换为内存中的物理块号。物理块号内的偏移地址就是页面内偏移地址。<br>页表的作用就是从页号到物理块号的转换，所以地址变换的任务借助于页表来完成的。</p>
<p><img src="https://pic4.zhimg.com/80/v2-7cbaff5931089ca53224cd756978a4e3_720w.webp" alt="img"></p>
<p><img src="https://pic3.zhimg.com/80/v2-9c392fa4064349c936bbccd8cc9cc6c2_720w.webp" alt="img"></p>
<p><strong>如果题目中是用十进制数表示逻辑地址，则：</strong></p>
<p><img src="https://pic1.zhimg.com/80/v2-97f7b90770d7f3a3d45fff833f4c7218_720w.webp" alt="img"></p>
<p>例题1：有一系统采用页式存储管理，有一作业大小是8KB，页大小为2KB，依次装入内存的第7、9、10、5块，试将虚地址7145，3412转换成内存地址。</p>
<p><img src="https://pic2.zhimg.com/80/v2-124eb561d061227e3ecf56d0e3d2e2cd_720w.webp" alt="img"></p>
<p><strong>虚地址 3412</strong><br>P＝3412 ％ 2048＝1</p>
<p>W＝3412 mod 2048＝1364<br>MA&#x3D;9*2048+1364&#x3D;19796<br>虚地址3412的内存地址是19796</p>
<p><strong>虚地址 7145</strong><br>P＝7145 ％ 2048 ＝3<br>W＝7145 mod 2048 ＝1001<br>MA&#x3D;5*2048+1001&#x3D;11241<br>虚地址7145的内存地址是：11241</p>
<p><img src="https://pic4.zhimg.com/80/v2-95f185565e24cb9a0ee7a67a8cf53e9b_720w.webp" alt="img"></p>
<h3 id="1-4快表"><a href="#1-4快表" class="headerlink" title="1.4快表"></a>1.4快表</h3><p>因为页表是存放在内存中的，<strong>CPU要存取一个数据，需访问主存两次</strong>。<br>第一次：访内存中的页表，找到该页的的物理块号，将此块号与页内地址拼接形成物理地址；<br>第二次：真正访问该物理地址，存取其中的内容。<br>这样就能把程序的执行速度降低一倍。<br>为了提高存取速度，在地址变换机构中增设一组寄存器，用来存放访问的那些页表。</p>
<p><strong>快表是一种放存速度比内存快很多的高速缓冲器。</strong><br><strong>把存放在高速缓冲寄存器中的页表叫快表</strong>，这个高速缓冲寄存器又叫<strong>联想存贮器（TLB）。</strong>与此对应，内存中的页表称为慢表。</p>
<p><strong>当进程访问一页时，系统将页号与快表中的所有项进行并行比较。若访问的页在快表中，即可立即进行地址转换。</strong><br><strong>当被访问的页不在快表中时，去内存中查询页表，同时将页表找到的内存块号与虚页号填入快表中</strong></p>
<p><img src="https://pic3.zhimg.com/80/v2-c84edd02e05af4fd44e3988acb6bf416_720w.webp" alt="img"></p>
<p>例题2：</p>
<p>快表命中率98%，访问时间是10ns， 内存访问时间是100ns， 平均访问时间？<br>平均访问时间&#x3D;98%<em>(10+100)+（1-98%）</em>（10+100+100）</p>
<p><strong>若快表命中</strong></p>
<p>联想寄存器检索时间：10ns<br>访问内存1次取数据时间：100ns<br>取数据总时间：110ns</p>
<p><strong>若快表中未命中</strong><br>联想寄存器检索时间：10ns<br>访问内存1次检索页表时间：100ns<br>访问内存1次取数据时间：100ns<br>取数据总时间：210ns</p>
<h3 id="1-5两级和多级页表"><a href="#1-5两级和多级页表" class="headerlink" title="1.5两级和多级页表"></a>1.5两级和多级页表</h3><p>现代的大多数计算机系统，都支持非常大的逻辑地址空间(232~264)。页表就变得非常大，要占用相当大的内存空间。可以采用两个方法来解决这一问题：</p>
<p>① 采用离散分配方式来解决难以找到一块连续的大内存空间的问题：</p>
<p>② 只将当前需要的部分页表项调入内存，其余的页表项仍驻留在磁盘上，需要时再调入。</p>
<p><img src="https://pic2.zhimg.com/80/v2-03b14fadc94d6d319bfe859e32ed398d_720w.webp" alt="img"></p>
<p><strong>二级页表如何实现地址变换？</strong></p>
<p><img src="https://pic2.zhimg.com/80/v2-e71c7761a80dbf97edce88b67bd21df5_720w.webp" alt="img"></p>
<h3 id="1-6页的分配与回收"><a href="#1-6页的分配与回收" class="headerlink" title="1.6页的分配与回收"></a>1.6页的分配与回收</h3><p>用一张“位示图”构成主存分配表。位示图的每一位与一个主存块对应，其值为0，表示对应的主存块空闲，其值为1，表示对应的主存块已分配。</p>
<p>位示图优点是占用内存空间小，可常驻内存，加快分配进程，但缺点是不够直观。</p>
<p><img src="https://pic4.zhimg.com/80/v2-7b7129ef6bb6539db211ff5113b07fe3_720w.webp" alt="img"></p>
<p><strong>内存分配过程：</strong></p>
<p>计算一个作业所需要的总块数N<br>查位示图，看看是否还有N个空闲块<br>如果有足够的空闲块，则页表长度设为N，可填入PCB中；申请页表区，把页表始址填入PCB<br>依次分配N个空闲块，将块号和页号填入页表<br>修改位示图</p>
<h3 id="1-7存在的问题"><a href="#1-7存在的问题" class="headerlink" title="1.7存在的问题"></a>1.7存在的问题</h3><p>为每个进程配置一张页表，进程逻辑空间非常大，带来的问题？</p>
<p>可以引入<strong>Inverted page tables(放置页表)</strong><br>反置页表 – 按物理块号排序<br>IBM RT; HP Spectrum…<br>反置页表很大，使用Hash表加快检索<br>所有在内存中的并发进程只有一张页表<br>除了Hash表，联想寄存器也被用来存放最近使用过的页表项</p>
<p><img src="https://pic2.zhimg.com/80/v2-ebf8811c48d538ddf386fc0766ee3b1d_720w.webp" alt="img"></p>
<h3 id="1-8分页存储管理方案的评价"><a href="#1-8分页存储管理方案的评价" class="headerlink" title="1.8分页存储管理方案的评价"></a>1.8分页存储管理方案的评价</h3><p><strong>优点：</strong><br>较好地解决了碎片的问题<br>打破了存储分配的连续性要求<br>提高了主存的利用率</p>
<p><strong>缺点</strong>：<br>页内碎片<br>动态地址变换、方案实施需耗用额外的系统资源<br>存储扩充问题没有解决——作业大小受到限制，可用块数小于作业需求时需等待</p>
<h2 id="2、虚拟存储器-Virtual-Memory"><a href="#2、虚拟存储器-Virtual-Memory" class="headerlink" title="2、虚拟存储器(Virtual Memory)"></a>2、虚拟存储器(Virtual Memory)</h2><h3 id="2-1局部性原理-principle-of-locality"><a href="#2-1局部性原理-principle-of-locality" class="headerlink" title="2.1局部性原理(principle of locality)"></a>2.1局部性原理(principle of locality)</h3><p>指程序在执行过程中的一个较短时期，所执行的指令地址和指令的操作数地址，分别局限于一定区域。还可以表现为：<br><strong>时间局部性：</strong>一条指令的一次执行和下次执行，一个数据的一次访问和下次访问都集中在一个较短时期内；<br><strong>空间局部性：</strong>当前指令和邻近的几条指令，当前访问的数据和邻近的数据都集中在一个较小区域内。</p>
<p><strong>局部性原理的具体体现：</strong><br>程序在执行时，大部分是顺序执行的指令，少部分是转移和过程调用指令。<br>过程调用的嵌套深度一般不超过5，因此执行的范围不超过这组嵌套的过程。<br>程序中存在相当多的循环结构，它们由少量指令组成，而被多次执行。<br>程序中存在相当多对一定数据结构的操作，如数组操作，往往局限在较小范围内。</p>
<h3 id="2-2引入虚拟存储技术的好处"><a href="#2-2引入虚拟存储技术的好处" class="headerlink" title="2.2引入虚拟存储技术的好处"></a>2.2引入虚拟存储技术的好处</h3><p>大程序：可在较小的可用内存中执行较大的用户程序；<br>大的用户空间：提供给用户可用的虚拟内存空间通常大于物理内存(real memory)<br>并发：可在内存中容纳更多程序并发执行；<br>易于开发：与覆盖技术比较，不必影响编程时的程序结构</p>
<h3 id="2-3虚拟存储技术的特征"><a href="#2-3虚拟存储技术的特征" class="headerlink" title="2.3虚拟存储技术的特征"></a>2.3虚拟存储技术的特征</h3><p>不连续性：物理内存分配的不连续，虚拟地址空间使用的不连续（数据段和栈段之间的空闲空间，共享段和动态链接库占用的空间）<br>部分交换：与交换技术相比较，虚拟存储的调入和调出是对部分虚拟地址空间进行的；<br>大空间：通过物理内存和快速外存相结合，提供大范围的虚拟地址空间</p>
<h3 id="2-4虚拟存储技术的种类"><a href="#2-4虚拟存储技术的种类" class="headerlink" title="2.4虚拟存储技术的种类"></a>2.4虚拟存储技术的种类</h3><p>虚拟页式<br>虚拟段式<br>虚拟段页式</p>
<h2 id="3、虚拟页式-virtual-paging-存储管理"><a href="#3、虚拟页式-virtual-paging-存储管理" class="headerlink" title="3、虚拟页式(virtual paging)存储管理"></a>3、虚拟页式(virtual paging)存储管理</h2><h3 id="3-1基本原理"><a href="#3-1基本原理" class="headerlink" title="3.1基本原理"></a>3.1基本原理</h3><p>系统自动地将作业的地址空间分页，将系统的主存空间分块，页与块等大小，在作业运行前，只把初始需要的一部分页面装入内存块里，运行中需要访问自己地址空间中的但当前不在内存的页面时产生缺页中断，由缺页中断服务程序将所需的页面调入内存，若此时内存中没有空闲物理块安置请求调入的新页面，则系统按预定的置换策略自动选择一个或一些在内存的页面，把它们换出到外存。</p>
<p>虚拟页式存储管理实际是实分页技术与虚拟存储技术相结合的产物，其分页思想与实分页是一样的。</p>
<p><strong>这里的请求调入和置换功能都是比实分页存储管理增加的内容，是实现虚拟存储的主要功能。</strong></p>
<p>为实现虚拟页式存储管理:<br>需要置<strong>换技术、请求装入技术和大硬盘</strong>支持，另外：<br>页表表目需要增加<strong>外存块号、状态位、访问位或访问字段、修改位、存取控制字段</strong>等。<br><strong>外存块号</strong>指出该页在外存的地址，供调入该页时用；<br><strong>状态位</strong>指示该页是否在内存；<br><strong>访问位或访问字段</strong>则是该页被访问过的标志或被访问过的次数；<br><strong>修改位</strong>表示该页是否被修改过；<br><strong>存取控制字段</strong>则是用来限制页面被安全共享的。</p>
<p>作业1在请求分页系统中的存储映像</p>
<p><img src="https://pic1.zhimg.com/80/v2-91b609d25f9f074773d941efa11b66f0_720w.webp" alt="img"></p>
<p>当执行 “mov r1，[2120］”时<br>CPU产生的虚地址为2120<br>分页机构得 p&#x3D;2，w&#x3D;72（每页1K）<br>查页表。该页中断位i&#x3D;1，发生缺页中断</p>
<p>如主存中有空白块，直接调入<br>如主存中无空白块，则需淘汰该作业在主存中的一页</p>
<h3 id="3-2主存页面分配策略"><a href="#3-2主存页面分配策略" class="headerlink" title="3.2主存页面分配策略"></a>3.2主存页面分配策略</h3><p>在虚拟页式存储管理中，内存分配似实分页方式，但还必须考虑解决下面两个问题：<br>（1）是否对各进程采用平均分配策略？<br>（2）发生缺页中断时，如何为所缺的页面分配内存？</p>
<p>对问题(2)有一下几种做法：</p>
<p>a、平均分配。</p>
<p>b、按进程长度比例分配。</p>
<p>c、按进程优先级分配。</p>
<p>d、按进程长度和优先级别分配。</p>
<p>对问题(2)主要有一下两种做法：</p>
<p>a、固定分配局部置换。</p>
<p>b、可变分配全局置换。</p>
<h3 id="3-3页面调入策略"><a href="#3-3页面调入策略" class="headerlink" title="3.3页面调入策略"></a>3.3页面调入策略</h3><p>（1）请求调入<br>当发生页面故障时进行调度，即当进程访问不在内存的页面引发缺页中断时，由系统根据这种访问请求把所缺页面装入内存。<br><strong>优点：</strong>由请求调入策略装入的页一定会被访问，再加之比较容易实现，故在目前的虚拟存储器中，大多采用此策略。<br><strong>缺点：</strong>每次仅调入一页，增加了磁盘I&#x2F;O的启动频率。</p>
<p>（ 2）预调入<br>&#x3D;&gt;也称先行调度，即一页面被访问前就已经预先置入内存，以减少今后的缺页率。<br>&#x3D;&gt;主要适于进程的许多页存放在外存的连续区域中的情况。有的系统结合请求调入使用，即每次缺页时装入多个页面。<br><strong>优点：</strong>提高调页的I&#x2F;O效率。<br><strong>缺点：</strong>基于预测，若调入的页在以后很少被访问，则效率低。常用于程序装入时的调页。</p>
<p><strong>调入页面的来源：</strong></p>
<p>通常对外存交换区的I&#x2F;O效率比文件区的高。<br>进程装入时，将其全部页面复制到交换区，以后总是从交换区调入。执行时调入速度快，要求交换区空间较大。<br>凡是未被修改的页面，都直接从文件区读入，而被置换时不需调出；已被修改的页面，被置换时需调出到交换区，以后从交换区调入。</p>
<p><strong>存储分配的安全性考虑:</strong><br>把一个页面分配给进程之前，先要清除页面中的数据（如全部填充为0），以免该进程读取前一进程遗留在页面中的数据；</p>
<h3 id="3-4页面调度算法"><a href="#3-4页面调度算法" class="headerlink" title="3.4页面调度算法"></a>3.4页面调度算法</h3><p>由缺页中断服务程序将所需的页面调入内存，若此时内存中没有空闲物理块安置请求调入的新页面，则系统按预定的策略自动选择一个（请求调入策略）或一些（预调入策略）在内存的页面，把它们换出到外存。</p>
<p><strong>a、什么是淘汰策略（置换策略）？</strong></p>
<p>用来选择淘汰哪一页的规则就叫做置换策略，或称淘汰算法。如何决定淘汰哪一页？根据页面在系统中的表现（如：使用的频繁程度、进入系统时间的长短）</p>
<p><strong>b、颠簸</strong><br>颠簸(thrashing)，又称为“抖动”。<br>简单地说，导致系统效率急剧下降的主存和辅存之间的频繁页面置换现像称为“抖动”。<br>现象？<strong>淘汰的页面恰好是不久又要访问的页面。</strong></p>
<p><strong>（1）最佳淘汰算法——OPT(Optimal)</strong><br>这是<strong>Belady贝莱迪</strong>于1966年提出的一种<strong>理论上的算法</strong>。该算法每次都淘汰以后永不使用的，或者过最长的时间后才会被访问的页面。<br>显然，采用<strong>这种算法会保证最低的缺页率，但它是无法实现的</strong>，因为它必须知道页面“将来”的访问情况。不过，该算法仍有一定意义，<strong>可作为衡量其他算法优劣的一个标准</strong>。</p>
<p>假定系统为某个进程分配了三个物理块，进程的访问顺序为7，0，1，2，0，3，0，4，2，3，0，3，2，1，2</p>
<p>采用OPT淘汰算法：</p>
<p><img src="https://pic4.zhimg.com/80/v2-2b09f7a4f32824074caadccb81e85acf_720w.webp" alt="img"></p>
<p><strong>（2）先进先出淘汰算法——FIFO</strong><br>这是最早出现的淘汰算法。<br>总是淘汰<strong>最先进入内存的页面</strong>。它实现简单，只需把进程中已调入内存的页面，按先后次序链成一个<strong>队列</strong>，并设置一个所谓的替换指针，使它<strong>总是指向内存中最老的页面</strong>。<br>缺点：效率不高，因为它与进程实际的运行规律不相适应，比如常用的全局变量所在的页面或者循环体所在页面都可能被它选为淘汰对象。出现bleady现象。</p>
<p>页面进入主存的先后次序：<br>2-&gt;4-&gt;5-&gt;1</p>
<p><img src="https://pic1.zhimg.com/80/v2-e7f65e45e53c457f81db445964f5d63c_720w.webp" alt="img"></p>
<p>当要调入第6页时：<br>置换第2页<br>将第2页改为6<br>替换指针指向第4页4-&gt;5-&gt;1-&gt;6</p>
<p>Belady现象：采用FIFO算法时，如果对一个进程未分配它所要求的全部页面，有时就会出现分配的页面数增多，缺页率反而提高的异常现象。<br>Belady现象的描述：一个进程P要访问M个页，OS分配N个内存页面给进程P；对一个访问序列S，发生缺页次数为PE（S,N）。当N增大时，PE(S, N)时而增大，时而减小。<br>Belady现象的原因：<strong>FIFO算法的置换特征与进程访问内存的动态特征是非常不一致的，即被置换的页面通常并不是进程不会访问的</strong>。</p>
<p>采用FIFO淘汰算法：</p>
<p><img src="https://pic4.zhimg.com/80/v2-4392e40a70cb228820f46d58edd00a97_720w.webp" alt="img"></p>
<p><strong>（3） 最近最久未使用算法 (LRU, Least Recently Used）</strong></p>
<p>根据页面调入内存后的使用情况，选择<strong>内存中最久未使用的页面被置换</strong>。这是局部性原理的合理近似，性能接近最佳算法。<br>OPT算法使用页面将要被访问的时间，LRU算法使用页面最后一次被访问的时间。二者唯一的差别是：OPT是向前看的，而LRU是向后看的。<br>下面给出LRU的实现算法：<br><strong>a、计时法：</strong>对于每一页面增设一个访问时间计时器，每当一个页面被访问时，当时的绝对时钟内容被拷贝到对应的访问时间计时器中，这样系统记录了内存中所有页面最后一次被访问的时间。淘汰时，选取访问时间计时器的值最小的页面。<br><strong>b、堆栈法：</strong>每当进程访问某页面时，便将该页面的页号从栈中移出，将它压入栈顶。栈顶始终是最新被访问的页面的编号。栈底则是最近最久未被使用的页面的页面号。<br><strong>c、多位寄存器法</strong><br>为每页设置一个R位的寄存器<br>每次访问一页时，将该页所对应的寄存器最左位置1<br>每隔时间间隔T，所有寄存器右移一位。<br>选择R值最小的页淘汰。<br>例如，r寄存器共有四位，页面P0、P1、P2在T1、T2、T3时刻的r寄存器内容如下：<br>页面 时刻<br>T1 T2 T3<br>P0 1000 0100 1010<br>P1 1000 1100 0110<br>P2 0000 1000 0100</p>
<p>给某作业分配了三块主存，该作业依次访问的页号为：4，3，0，4，1，1，2，3，2。当访问这些页时，页面淘汰序列变化情况如下</p>
<p><img src="https://pic3.zhimg.com/80/v2-6eb312b2f3da1549d5d8c269b1bfe476_720w.webp" alt="img"></p>
<p>LRU的开销是很大的，必须有硬件的支持，完全由软件实现其速度至少会减少10倍，因此LRU近似算法更实用些</p>
<p><strong>（4）二次机会淘汰算法——SC(Second Chance)淘汰算法</strong><br>这是一种<strong>LRU的近似算法</strong>，是通过对FIFO算法进行简单改造，结合页表中的访问位而得来一种淘汰算法。<br>该算法首先检查位于FIFO链链首的页，如果它的访问位为0，则选择该页淘汰；如果它的访问位为1，则清除其访问位，将它移至FIFO链的链尾，重复此算法的查找过程，直至遇到新链首页是一个访问位为0的较早进入内存的页为止，把它选为被淘汰的页。</p>
<p>为每一个存储块（存储分块表）或页面（页表）设立一个引用位。<br>当访问某页时，就将该页引用位置1<br>页面管理软件周期性地（设周期为T）将所有引用位重新置0<br>在T内，被访问过的页面引用位为1，否则为0<br>选择引用位为0的页面淘汰。</p>
<p><strong>（5）时钟(Clock)淘汰算法</strong><br>二次机会淘汰算法缺点：就是需要把访问位为1的处于链首的页移至链尾，这需要一定的开销。<br>改进的方法：<strong>就是把进程所访问的页面链成一个环形链表，再设一个指针指向最老的页面</strong>，于是形成了一种简单实用的LRU近似算法——时钟淘汰算法。<br>该算法首先检测指针所指的页面，如果它的访问位为0，则淘汰该页，新装入的页插入到此位置，然后指针前进一个位置；如果它的访问位为1，则清除为0，并将指针前进一个位置，继续检查访问位。重复此过程，直到找到访问位为0的页面为止。</p>
<p><strong>访问页号727</strong><br><strong>引发缺页</strong></p>
<p><img src="https://pic3.zhimg.com/80/v2-13f82fa69defe9cbefb68fa801858a02_720w.webp" alt="img"></p>
<p><img src="https://pic1.zhimg.com/80/v2-e0610db42d87eb3007f0d3f1e36976e0_720w.webp" alt="img"></p>
<p><strong>（6）最近未用淘汰算法——NRU(Not Used Recently)淘汰算法</strong><br>它把FIFO算法的思想与页面的<strong>访问位和修改位</strong>结合起来确定一个接近LRU算法的淘汰对象。<br>该算法每次都尽量选择<strong>最近最久未被写过的页面</strong>淘汰，这种干净的页面可以不被写回到磁盘。在实现时，为每一个页面设置初始值0的访问位和修改位。当对某页面执行写操作时，其修改位和访问位均由硬件置成1；当对某页面执行读操作时，只有其访问位被硬件置成1。系统每隔固定时间将所有访问位都清0。</p>
<p>按照下列次序选择被淘汰的页面：<br>①访问位＝０，修改位＝０；直接淘汰；<br>②访问位＝０，修改位＝１；写回外存后淘汰；<br>③访问位＝１，修改位＝０；直接淘汰；<br>④访问位＝１，修改位＝１；写回外存后淘汰；</p>
<p>页面请求序列为：2，3，2，1，5，2，4，5，3，2，5，2<br>内存分配3块<br>用OPT、LRU、FIFO、Clock算法写出页面置换过程</p>
<p><img src="https://pic2.zhimg.com/80/v2-7c2bad5abc86d0986e4057f9a16463f1_720w.webp" alt="img"></p>
<p>时钟clock算法中的箭头是当前指针的位置！</p>
<h3 id="3-5影响缺页中断率的因素"><a href="#3-5影响缺页中断率的因素" class="headerlink" title="3.5影响缺页中断率的因素"></a>3.5影响缺页中断率的因素</h3><p>（1）页面调度算法不合理<br>抖动又叫颠簸，是指一段时间里，页面在内存与外存之间频繁地调度或换入换出，以至于系统用于调度页面所需要的时间比进程实际运行所占用的时间还要多。<br>显然，抖动是由于缺页中断率很高而引起的一种坏现象，它将严重影响系统的效率，甚至可能使系统全面崩溃。<br>（2）分配给作业的内存块数太少<br>作业的缺页中断率与作业所占内存块数成反比。分配给作业的内存块数太少是导致抖动现象发生的最主要的原因，实验分析表明：<strong>对所有的程序来说，要使其有效地工作，它在内存中的页面数不应少于它的总页面数的一半。</strong><br>（3）页面大小的选择不合理<br>虽然缺页中断率与页面尺寸成反比，但页面尺寸却不能一味地求大，它一般在0.5KB~4KB之间，是个实验统计值。因为页面大时，页表较小，占空间少，查表速度快，缺页中断次数少，但页面调度时间长，页内碎片较大。页面小时，恰恰相反。<br>（4）用户程序编制的方法不合适<br>作业的缺页中断率与程序的局部化（包括时间局部化和空间局部化）程度成反比。用户程序编制的方法不合适可能导致程序运行的时空复杂度高，缺页次数多。</p>
<hr>
<p>版权声明：本文为知乎博主「Linux内核库」的原创文章，遵循CC 4.0 BY-SA版权协议，转载请附上原文 出处链接及本声明。 </p>
<p>原文链接：<a href="https://zhuanlan.zhihu.com/p/448029786">https://zhuanlan.zhihu.com/p/448029786</a></p>
]]></content>
      <categories>
        <category>linux-doc 内存管理</category>
      </categories>
      <tags>
        <tag>Linux</tag>
      </tags>
  </entry>
  <entry>
    <title>Linux内核内存管理系统调用</title>
    <url>/2023/01/15/linux-docs/%E5%86%85%E5%AD%98%E7%AE%A1%E7%90%86/Linux%E5%86%85%E6%A0%B8%E5%86%85%E5%AD%98%E7%AE%A1%E7%90%86%E7%B3%BB%E7%BB%9F%E8%B0%83%E7%94%A8/</url>
    <content><![CDATA[<h2 id="1、什么是系统调用"><a href="#1、什么是系统调用" class="headerlink" title="1、什么是系统调用"></a>1、什么是系统调用</h2><p>简单来说，系统调用就是用户程序和硬件设备之间的桥梁。</p>
<p>用户程序在需要的时候，通过系统调用来使用硬件设备。</p>
<p>系统调用的存在，有以下重要的意义:</p>
<p>1）用户程序通过系统调用来使用硬件，而不用关心具体的硬件设备，这样大大简化了用户程序的开发。</p>
<p>比如：用户程序通过write()系统调用就可以将数据写入文件，而不必关心文件是在磁盘上还是软盘上，或者其他存储上。</p>
<p>2）系统调用使得用户程序有更好的可移植性。</p>
<p>只要操作系统提供的系统调用接口相同，用户程序就可在不用修改的情况下，从一个系统迁移到另一个操作系统。</p>
<p>3）系统调用使得内核能更好的管理用户程序，增强了系统的稳定性。</p>
<p>因为系统调用是内核实现的，内核通过系统调用来控制开放什么功能及什么权限给用户程序。</p>
<p>这样可以避免用户程序不正确的使用硬件设备，从而破坏了其他程序。</p>
<p>4）系统调用有效的分离了用户程序和内核的开发。</p>
<p>用户程序只需关心系统调用API，通过这些API来开发自己的应用，不用关心API的具体实现。</p>
<p>内核则只要关心系统调用API的实现，而不必管它们是被如何调用的。</p>
<p>用户程序，系统调用，内核，硬件设备的调用关系如下图：</p>
<p><img src="https://pic4.zhimg.com/80/v2-3b6310a5b0286d44ff7ef95c029339e3_720w.webp" alt="img"></p>
<h2 id="2、Linux上的系统调用实现原理"><a href="#2、Linux上的系统调用实现原理" class="headerlink" title="2、Linux上的系统调用实现原理"></a>2、Linux上的系统调用实现原理</h2><p>要想实现系统调用，主要实现以下几个方面：</p>
<ol>
<li>通知内核调用一个哪个系统调用</li>
<li>用户程序把系统调用的参数传递给内核</li>
<li>用户程序获取内核返回的系统调用返回值</li>
</ol>
<p>下面看看Linux是如何实现上面3个功能的。</p>
<h3 id="2-1通知内核调用一个哪个系统调用"><a href="#2-1通知内核调用一个哪个系统调用" class="headerlink" title="2.1通知内核调用一个哪个系统调用"></a><strong>2.1通知内核调用一个哪个系统调用</strong></h3><p>每个系统调用都有一个系统调用号，系统调用发生时，内核就是根据传入的系统调用号来知道是哪个系统调用的。</p>
<p>在x86架构中，用户空间将系统调用号是放在eax中的，系统调用处理程序通过eax取得系统调用号。</p>
<p>系统调用号定义在内核代码：arch&#x2F;alpha&#x2F;include&#x2F;asm&#x2F;unistd.h 中，可以看出linux的系统调用不是很多。</p>
<h3 id="2-2用户程序把系统调用的参数传递给内核"><a href="#2-2用户程序把系统调用的参数传递给内核" class="headerlink" title="2.2用户程序把系统调用的参数传递给内核"></a><strong>2.2用户程序把系统调用的参数传递给内核</strong></h3><p>系统调用的参数也是通过寄存器传给内核的，在x86系统上，系统调用的前5个参数放在ebx,ecx,edx,esi和edi中，如果参数多的话，还需要用个单独的寄存器存放指向所有参数在用户空间地址的指针。</p>
<p>一般的系统调用都是通过C库(最常用的是glibc库)来访问的，Linux内核提供一个从用户程序直接访问系统调用的方法。</p>
<hr>
<p>版权声明：本文为知乎博主「<a href="https://www.zhihu.com/people/linuxwang-xian-sheng">极致Linux内核</a>」的原创文章，遵循CC 4.0 BY-SA版权协议，转载请附上原文出处链接及本声明。</p>
<p>原文链接：<a href="https://zhuanlan.zhihu.com/p/549908561">https://zhuanlan.zhihu.com/p/549908561</a></p>
]]></content>
      <categories>
        <category>linux-doc 内存管理</category>
      </categories>
      <tags>
        <tag>Linux</tag>
      </tags>
  </entry>
  <entry>
    <title>Linux内核异常处理</title>
    <url>/2023/01/15/linux-docs/%E5%86%85%E5%AD%98%E7%AE%A1%E7%90%86/Linux%E5%86%85%E6%A0%B8%E5%BC%82%E5%B8%B8%E5%A4%84%E7%90%86/</url>
    <content><![CDATA[<ol>
<li>为什么要学习内核：你对技术追求、大厂面试需求、更好地做应用层开发</li>
<li>内核我们要学习内容：内核管理、进程管理、文件系统、操作系统调用、网络协议栈、虚拟化等等。</li>
</ol>
<h2 id="1、异常及非屏蔽中断"><a href="#1、异常及非屏蔽中断" class="headerlink" title="1、异常及非屏蔽中断"></a>1、异常及非屏蔽中断</h2><ul>
<li>异常就是CPU内核出现的中断，在CPU执行特定指令时出现非法情况。非屏蔽中断就是计算机内部硬件出错时引起的异常情况。</li>
</ul>
<p><img src="https://pic1.zhimg.com/80/v2-3ec56aabdcdee71a277a7fe5512b1450_720w.webp" alt="img"></p>
<ul>
<li>Intel把非屏蔽中断作为异常的一种来处理。IntelX86处理器发布大约20种异常。每种异常都会由专门的异常处理程序来处理操作，它们通常把一个UNIX信号发送到引起异常的进程。具体异常处理程序发送的信号如下：</li>
</ul>
<p><img src="https://pic1.zhimg.com/80/v2-683b38bdf0caa852b87c550e04329fa8_720w.webp" alt="img"></p>
<h2 id="2、中断请求初始化分析"><a href="#2、中断请求初始化分析" class="headerlink" title="2、中断请求初始化分析"></a>2、中断请求初始化分析</h2><ul>
<li>由于计算机硬件的限制，很多外部设备不共享中断线，例如，PC配置可以把同一条中断线分配给网卡或图形卡。在Linux系统设计中，专门为每个中断请求IRQ设置一个队列，称为中断请求队列。</li>
<li>中断线、中断请求(IRQ)号及中断向量它们之间关系：中断线是中断请求的一种物理描述，逻辑上对应一个中断请求号（中断号），第n个中断号(IRQn)的缺少中向量是n+32。</li>
</ul>
<h2 id="3、-IRQ队列数据结构"><a href="#3、-IRQ队列数据结构" class="headerlink" title="3、 IRQ队列数据结构"></a>3、 IRQ队列数据结构</h2><ul>
<li>在256个中断向量中，除32个分配给异常以外，还有224个作为中断向量。对于第个IRQ，Linux都用一个irq_desc_t数据结构来描述，我们就把它叫IRQ描述符，224个IRQ形成一个数组irq_desc[]，具体在内核源码分析如下：</li>
</ul>
<p><img src="https://pic2.zhimg.com/80/v2-542e4ea3362bbad570e87e4ff8cf62e1_720w.webp" alt="img"></p>
<h3 id="3-1中断服务例程描述符irqaction"><a href="#3-1中断服务例程描述符irqaction" class="headerlink" title="3.1中断服务例程描述符irqaction"></a>3.1中断服务例程描述符irqaction</h3><ul>
<li>在IRQ描述符中我们看到指针action的结构为irqaction，它是为多个设备能共享一条中断线而设置的一个数据结构。具体内核源码分析如下：</li>
</ul>
<p><img src="https://pic3.zhimg.com/80/v2-ebe9e5c3b5334cbb7b4f5bbdf8b5f606_720w.webp" alt="img"></p>
<h3 id="3-2中断服务例程"><a href="#3-2中断服务例程" class="headerlink" title="3.2中断服务例程"></a>3.2中断服务例程</h3><ul>
<li>具体来讲中断处理程序相当于某个中断向量的总处理程序，每个中断服务例程都有相同的参数：</li>
</ul>
<ol>
<li>IRQ：中断号</li>
<li>dev_id：设备标识符，其类型为void*</li>
<li>regs：指向内核堆栈区的指针。</li>
</ol>
<h3 id="3-3中断请求队列的初始化"><a href="#3-3中断请求队列的初始化" class="headerlink" title="3.3中断请求队列的初始化"></a>3.3中断请求队列的初始化</h3><ul>
<li>在IDT表初始化完成之初，每个中断服务队列还为空。即使打开中断且某个外设中断真的发生，也得不到实际服务，因为CPU虽然通过中断门进入某个中断向量的总处理程序，具体中断服务例程还没有挂入中断请求队列，因此在设备驱动程序的初始化阶段，必须通过request_irq()函数将对应的中断服务例程挂入中断请求队列。具体内核源码如下：</li>
</ul>
<p><img src="https://pic2.zhimg.com/80/v2-78a5cacea36f33c9539e30d6d1167031_720w.webp" alt="img"></p>
<ul>
<li>真正对中断请求队列进行初始化的函数如下：</li>
</ul>
<p><img src="https://pic3.zhimg.com/80/v2-7d3ed5f42b4ee5d4aeac7cc5e977a946_720w.webp" alt="img"></p>
<hr>
<p>版权声明：本文为知乎博主「Linux内核库」的原创文章，遵循CC 4.0 BY-SA版权协议，转载请附上原文 出处链接及本声明。 </p>
<p>原文链接：<a href="https://zhuanlan.zhihu.com/p/475244586">https://zhuanlan.zhihu.com/p/475244586</a></p>
]]></content>
      <categories>
        <category>linux-doc 内存管理</category>
      </categories>
      <tags>
        <tag>Linux</tag>
      </tags>
  </entry>
  <entry>
    <title>Linux内核空间内存申请函数kmalloc.、kzalloc、 vmalloc的区别</title>
    <url>/2023/01/15/linux-docs/%E5%86%85%E5%AD%98%E7%AE%A1%E7%90%86/Linux%E5%86%85%E6%A0%B8%E7%A9%BA%E9%97%B4%E5%86%85%E5%AD%98%E7%94%B3%E8%AF%B7%E5%87%BD%E6%95%B0kmalloc.%E3%80%81kzalloc%E3%80%81%20vmalloc%E7%9A%84%E5%8C%BA%E5%88%AB/</url>
    <content><![CDATA[<ul>
<li>我们都知道在用户空间动态申请内存用的函数是 malloc()，这个函数在各种操作系统上的使用是一致的，对应的用户空间内存释放函数是 free()。注意：动态申请的内存使用完后必须要释放，否则会造成内存泄漏，如果内存泄漏发生在内核空间，则会造成系统崩溃。</li>
<li>那么，在内核空间中如何申请内存呢？一般我们会用到 kmalloc()、kzalloc()、vmalloc() 等，下面我们介绍一下这些函数的使用以及它们之间的区别。</li>
</ul>
<h2 id="1、kmalloc"><a href="#1、kmalloc" class="headerlink" title="1、kmalloc()"></a>1、kmalloc()</h2><ul>
<li><strong>函数原型：</strong></li>
</ul>
<figure class="highlight text"><table><tr><td class="code"><pre><span class="line">void *kmalloc(size_t size, gfp_t flags)；</span><br></pre></td></tr></table></figure>

<ul>
<li>kmalloc() 申请的内存位于物理内存映射区域，而且在物理上也是连续的，它们与真实的物理地址只有一个固定的偏移，因为存在较简单的转换关系，所以对申请的内存大小有限制，不能超过128KB。</li>
<li>较常用的 flags（分配内存的方法）：</li>
</ul>
<ol>
<li>GFP_ATOMIC —— 分配内存的过程是一个原子过程，分配内存的过程不会被（高优先级进程或中断）打断；</li>
<li>GFP_KERNEL —— 正常分配内存；</li>
<li>GFP_DMA —— 给 DMA 控制器分配内存，需要使用该标志（DMA要求分配虚拟地址和物理地址连续）。</li>
</ol>
<ul>
<li>flags 的参考用法：</li>
</ul>
<blockquote>
<p>　|– 进程上下文，可以睡眠　　　　　GFP_KERNEL<br>　|– 进程上下文，不可以睡眠　　　　GFP_ATOMIC<br>　|　　|– 中断处理程序　　　　　　　GFP_ATOMIC<br>　|　　|– 软中断　　　　　　　　　　GFP_ATOMIC<br>　|　　|– Tasklet　　　　　　　　　GFP_ATOMIC<br>　|– 用于DMA的内存，可以睡眠　　　GFP_DMA | GFP_KERNEL<br>　|– 用于DMA的内存，不可以睡眠　　GFP_DMA |GFP_ATOMIC</p>
</blockquote>
<ul>
<li>对应的内存释放函数为：</li>
</ul>
<figure class="highlight text"><table><tr><td class="code"><pre><span class="line">void kfree(const void *objp);</span><br></pre></td></tr></table></figure>

<h2 id="2、kzalloc"><a href="#2、kzalloc" class="headerlink" title="2、kzalloc()"></a>2、kzalloc()</h2><ul>
<li>kzalloc() 函数与 kmalloc() 非常相似，参数及返回值是一样的，可以说是前者是后者的一个变种，因为 kzalloc() 实际上只是额外附加了__GFP_ZERO标志。所以它除了申请内核内存外，还会对申请到的内存内容清零。</li>
</ul>
<figure class="highlight text"><table><tr><td class="code"><pre><span class="line">/** * kzalloc - allocate memory. The memory is set to zero. * @size: how many bytes of memory are required. * @flags: the type of memory to allocate (see kmalloc). */static inline void *kzalloc(size_t size, gfp_t flags)&#123;    return kmalloc(size, flags | __GFP_ZERO);&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li>kzalloc() 对应的内存释放函数也是 kfree()。</li>
</ul>
<h2 id="3、vmalloc"><a href="#3、vmalloc" class="headerlink" title="3、vmalloc()"></a>3、vmalloc()</h2><ul>
<li><strong>函数原型：</strong></li>
</ul>
<figure class="highlight text"><table><tr><td class="code"><pre><span class="line">void *vmalloc(unsigned long size);</span><br></pre></td></tr></table></figure>

<ul>
<li>vmalloc() 函数则会在虚拟内存空间给出一块连续的内存区，但这片连续的虚拟内存在物理内存中并不一定连续。由于 vmalloc() 没有保证申请到的是连续的物理内存，因此对申请的内存大小没有限制，如果需要申请较大的内存空间就需要用此函数了。</li>
<li>对应的内存释放函数为：</li>
</ul>
<figure class="highlight text"><table><tr><td class="code"><pre><span class="line">void vfree(const void *addr);</span><br></pre></td></tr></table></figure>

<ul>
<li>注意：vmalloc() 和 vfree() 可以睡眠，因此不能从中断上下文调用。</li>
</ul>
<h2 id="4、总结"><a href="#4、总结" class="headerlink" title="4、总结"></a>4、总结</h2><ul>
<li>kmalloc()、kzalloc()、vmalloc() 的共同特点是：</li>
</ul>
<ol>
<li>用于申请内核空间的内存；</li>
<li>内存以字节为单位进行分配；</li>
<li>所分配的内存虚拟地址上连续；</li>
</ol>
<ul>
<li>kmalloc()、kzalloc()、vmalloc() 的区别是：</li>
</ul>
<ol>
<li>kzalloc 是强制清零的 kmalloc 操作；（以下描述不区分 kmalloc 和 kzalloc）</li>
<li>kmalloc 分配的内存大小有限制（128KB），而 vmalloc 没有限制；</li>
<li>kmalloc 可以保证分配的内存物理地址是连续的，但是 vmalloc 不能保证；</li>
<li>kmalloc 分配内存的过程可以是原子过程（使用 GFP_ATOMIC），而 vmalloc 分配内存时则可能产生阻塞；</li>
<li>kmalloc 分配内存的开销小，因此 kmalloc 比 vmalloc 要快；</li>
</ol>
<ul>
<li>一般情况下，内存只有在要被 DMA 访问的时候才需要物理上连续，但为了性能上的考虑，内核中一般使用 kmalloc()，而只有在需要获得大块内存时才使用 vmalloc()。例如，当模块被动态加载到内核当中时，就把模块装载到由 vmalloc() 分配的内存上。</li>
</ul>
<hr>
<p>版权声明：本文为知乎博主「Linux内核库」的原创文章，遵循CC 4.0 BY-SA版权协议，转载请附上原文 出处链接及本声明。 </p>
<p>原文链接：<a href="https://zhuanlan.zhihu.com/p/470783392">https://zhuanlan.zhihu.com/p/470783392</a></p>
]]></content>
      <categories>
        <category>linux-doc 内存管理</category>
      </categories>
      <tags>
        <tag>Linux</tag>
      </tags>
  </entry>
  <entry>
    <title>一文了解，Linux内存管理，malloc、free 实现原理</title>
    <url>/2023/01/15/linux-docs/%E5%86%85%E5%AD%98%E7%AE%A1%E7%90%86/%E4%B8%80%E6%96%87%E4%BA%86%E8%A7%A3%EF%BC%8CLinux%E5%86%85%E5%AD%98%E7%AE%A1%E7%90%86%EF%BC%8Cmalloc%E3%80%81free%20%E5%AE%9E%E7%8E%B0%E5%8E%9F%E7%90%86/</url>
    <content><![CDATA[<h2 id="malloc-free-简介"><a href="#malloc-free-简介" class="headerlink" title="malloc &#x2F; free 简介"></a>malloc &#x2F; free 简介</h2><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">void</span> *<span class="title function_">malloc</span><span class="params">(<span class="type">size_t</span> size)</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">free</span><span class="params">(<span class="type">void</span> *ptr)</span></span><br></pre></td></tr></table></figure>
<p><code>malloc</code> 分配指定大小的内存空间，返回一个指向该空间的指针。大小以字节为单位。返回 <code>void*</code> 指针，需要强制类型转换后才能引用其中的值。<br><code>free</code> 释放一个由 <code>malloc</code> 所分配的内存空间。<code>ptr</code> 指向一个要释放内存的内存块，该指针应当是之前调用 <code>malloc</code> 的返回值。</p>
<p>使用示例：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">int</span>* ptr; </span><br><span class="line">ptr = (<span class="type">int</span>*)<span class="built_in">malloc</span>(<span class="number">10</span> * <span class="keyword">sizeof</span>(<span class="type">int</span>)); <span class="comment">/* 进行强制类型转换 */</span> </span><br><span class="line"><span class="built_in">free</span>(ptr);</span><br></pre></td></tr></table></figure>

<h2 id="动态内存分配的系统调用：brk-sbrk"><a href="#动态内存分配的系统调用：brk-sbrk" class="headerlink" title="动态内存分配的系统调用：brk / sbrk"></a>动态内存分配的系统调用：<code>brk / sbrk</code></h2><p>动态分配的内存都在堆中，堆从低地址向高地址增长：</p>
<p><img src="https://user-images.githubusercontent.com/87457873/127428499-f85498fd-aa16-4e44-a419-89d1b852978b.png" alt="image"></p>
<p>Linux 提供了两个系统调用 <code>brk</code> 和 <code>sbrk</code>：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">brk</span><span class="params">(<span class="type">void</span> *addr)</span>;</span><br><span class="line"><span class="type">void</span> *<span class="title function_">sbrk</span><span class="params">(<span class="type">intptr_t</span> increment)</span>;</span><br></pre></td></tr></table></figure>

<p><code>brk</code> 用于返回堆的顶部地址；<code>sbrk</code> 用于扩展堆，通过参数 <code>increment</code> 指定要增加的大小，如果扩展成功，返回 <code>brk</code> 的旧值。如果 <code>increment</code> 为零，返回 <code>brk</code> 的当前值。</p>
<p>我们不会直接通过 <code>brk</code> 或 <code>sbrk</code> 来分配堆内存，而是先通过 <code>sbrk</code> 扩展堆，将这部分空闲内存空间作为缓冲池，然后通过 <code>malloc / free</code> 管理缓冲池中的内存。这是一种池化思想，能够避免频繁的系统调用，提高程序性能。</p>
<h2 id="malloc-free-实现思路"><a href="#malloc-free-实现思路" class="headerlink" title="malloc &#x2F; free 实现思路"></a>malloc &#x2F; free 实现思路</h2><p><code>malloc</code> 使用空闲链表组织堆中的空闲区块，空闲链表有时也用双向链表实现。每个空闲区块都有一个相同的首部，称为“内存控制块” <code>mem_control_block</code>，其中记录了空闲区块的元信息，比如指向下一个分配块的指针、当前分配块的长度、或者当前区块是否已经被分配出去。这个首部对于程序是不可见的，<code>malloc </code>返回的是紧跟在首部后面的地址，即可用空间的起始地址。</p>
<p><code>malloc</code> 分配时会搜索空闲链表，根据匹配原则，找到一个大于等于所需空间的空闲区块，然后将其分配出去，返回这部分空间的指针。如果没有这样的内存块，则向操作系统申请扩展堆内存。注意，返回的指针是从可用空间开始的，而不是从首部开始的：</p>
<p><img src="https://user-images.githubusercontent.com/87457873/127428664-699d5245-d62f-4c8d-b336-21e60107729f.png" alt="image"></p>
<p>malloc 所实际使用的内存匹配算法有很多，执行时间和内存消耗各有不同。到底使用哪个匹配算法，取决于实现。常见的内存匹配算法有：</p>
<ul>
<li>最佳适应法</li>
<li>最差适应法</li>
<li>首次适应法</li>
<li>下一个适应法</li>
</ul>
<p>free 会将区块重新插入到空闲链表中。free 只接受一个指针，却可以释放恰当大小的内存，这是因为在分配的区域的首部保存了该区域的大小。</p>
<h2 id="malloc-的实现方式一：显式空闲链表-整块分配"><a href="#malloc-的实现方式一：显式空闲链表-整块分配" class="headerlink" title="malloc 的实现方式一：显式空闲链表 + 整块分配"></a>malloc 的实现方式一：显式空闲链表 + 整块分配</h2><p>malloc 的实现方式有很多种。最简单的方法是使用一个链表来管理所有已分配和未分配的内存块，在每个内存块的首部记录当前块的大小、当前区块是否已经被分配出去。首部对应这样的结构体：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">mem_control_block</span> &#123;</span></span><br><span class="line">  <span class="type">int</span> is_available; <span class="comment">// 是否可用（如果还没被分配出去，就是 1）</span></span><br><span class="line">  <span class="type">int</span> size;         <span class="comment">// 实际空间的大小</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>使用首次适应法进行分配：遍历整个链表，找到第一个未被分配、大小合适的内存块；如果没有这样的内存块，则向操作系统申请扩展堆内存。</p>
<p>下面是这种实现方式的代码：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">int</span> has_initialized = <span class="number">0</span>;     <span class="comment">// 初始化标志</span></span><br><span class="line"><span class="type">void</span> *managed_memory_start;  <span class="comment">// 指向堆底（内存块起始位置）</span></span><br><span class="line"><span class="type">void</span> *last_valid_address;    <span class="comment">// 指向堆顶</span></span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">malloc_init</span><span class="params">()</span> &#123;</span><br><span class="line">  <span class="comment">// 这里不向操作系统申请堆空间，只是为了获取堆的起始地址</span></span><br><span class="line">  last_valid_address = sbrk(<span class="number">0</span>);</span><br><span class="line">  managed_memory_start = last_valid_address;</span><br><span class="line">  has_initialized = <span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> *<span class="title function_">malloc</span><span class="params">(<span class="type">long</span> numbytes)</span> &#123;</span><br><span class="line">  <span class="type">void</span> *current_location;  <span class="comment">// 当前访问的内存位置</span></span><br><span class="line">  <span class="class"><span class="keyword">struct</span> <span class="title">mem_control_block</span> *<span class="title">current_location_mcb</span>;</span>  <span class="comment">// 只是作了一个强制类型转换</span></span><br><span class="line">  <span class="type">void</span> *memory_location;  <span class="comment">// 这是要返回的内存位置。初始时设为</span></span><br><span class="line">                          <span class="comment">// 0，表示没有找到合适的位置</span></span><br><span class="line">  <span class="keyword">if</span> (!has_initialized) &#123;</span><br><span class="line">    malloc_init();</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">// 要查找的内存必须包含内存控制块，所以需要调整 numbytes 的大小</span></span><br><span class="line">  numbytes = numbytes + <span class="keyword">sizeof</span>(<span class="keyword">struct</span> mem_control_block);</span><br><span class="line">  <span class="comment">// 初始时设为 0，表示没有找到合适的位置</span></span><br><span class="line">  memory_location = <span class="number">0</span>;</span><br><span class="line">  <span class="comment">/* Begin searching at the start of managed memory */</span></span><br><span class="line">  <span class="comment">// 从被管理内存的起始位置开始搜索</span></span><br><span class="line">  <span class="comment">// managed_memory_start 是在 malloc_init 中通过 sbrk() 函数设置的</span></span><br><span class="line">  current_location = managed_memory_start;</span><br><span class="line">  <span class="keyword">while</span> (current_location != last_valid_address) &#123;</span><br><span class="line">    <span class="comment">// current_location 是一个 void 指针，用来计算地址；</span></span><br><span class="line">    <span class="comment">// current_location_mcb 是一个具体的结构体类型</span></span><br><span class="line">    <span class="comment">// 这两个实际上是一个含义</span></span><br><span class="line">    current_location_mcb = (<span class="keyword">struct</span> mem_control_block *)current_location;</span><br><span class="line">    <span class="keyword">if</span> (current_location_mcb-&gt;is_available) &#123;</span><br><span class="line">      <span class="keyword">if</span> (current_location_mcb-&gt;size &gt;= numbytes) &#123;</span><br><span class="line">        <span class="comment">// 找到一个可用、大小适合的内存块</span></span><br><span class="line">        current_location_mcb-&gt;is_available = <span class="number">0</span>;  <span class="comment">// 设为不可用</span></span><br><span class="line">        memory_location = current_location;      <span class="comment">// 设置内存地址</span></span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 否则，当前内存块不可用或过小，移动到下一个内存块</span></span><br><span class="line">    current_location = current_location + current_location_mcb-&gt;size;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">// 循环结束，没有找到合适的位置，需要向操作系统申请更多内存</span></span><br><span class="line">  <span class="keyword">if</span> (!memory_location) &#123;</span><br><span class="line">    <span class="comment">// 扩展堆</span></span><br><span class="line">    sbrk(numbytes);</span><br><span class="line">    <span class="comment">// 新的内存的起始位置就是 last_valid_address 的旧值</span></span><br><span class="line">    memory_location = last_valid_address;</span><br><span class="line">    <span class="comment">// 将 last_valid_address 后移 numbytes，移动到整个内存的最右边界</span></span><br><span class="line">    last_valid_address = last_valid_address + numbytes;</span><br><span class="line">    <span class="comment">// 初始化内存控制块 mem_control_block</span></span><br><span class="line">    current_location_mcb = memory_location;</span><br><span class="line">    current_location_mcb-&gt;is_available = <span class="number">0</span>;</span><br><span class="line">    current_location_mcb-&gt;size = numbytes;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">// 最终，memory_location 保存了大小为 numbyte的内存空间，</span></span><br><span class="line">  <span class="comment">// 并且在空间的开始处包含了一个内存控制块，记录了元信息</span></span><br><span class="line">  <span class="comment">// 内存控制块对于用户而言应该是透明的，因此返回指针前，跳过内存分配块</span></span><br><span class="line">  memory_location = memory_location + <span class="keyword">sizeof</span>(<span class="keyword">struct</span> mem_control_block);</span><br><span class="line">  <span class="comment">// 返回内存块的指针</span></span><br><span class="line">  <span class="keyword">return</span> memory_location;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>对应的free实现：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">free</span><span class="params">(<span class="type">void</span> *ptr)</span> &#123;  <span class="comment">// ptr 是要回收的空间</span></span><br><span class="line">  <span class="class"><span class="keyword">struct</span> <span class="title">mem_control_block</span> *<span class="title">free</span>;</span></span><br><span class="line">  <span class="built_in">free</span> = ptr - <span class="keyword">sizeof</span>(<span class="keyword">struct</span> mem_control_block); <span class="comment">// 找到该内存块的控制信息的地址</span></span><br><span class="line">  <span class="built_in">free</span>-&gt;is_available = <span class="number">1</span>;  <span class="comment">// 该空间置为可用</span></span><br><span class="line">  <span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这种方法的缺点是：</p>
<p>1、已分配和未分配的内存块位于同一个链表中，每次分配都需要从头到尾遍历<br><br>2、采用首次适应法，内存块会被整体分配，容易产生较多内部碎片<br></p>
<h2 id="malloc-的实现方式二：显式空闲链表-按需分配"><a href="#malloc-的实现方式二：显式空闲链表-按需分配" class="headerlink" title="malloc 的实现方式二：显式空闲链表 + 按需分配"></a>malloc 的实现方式二：显式空闲链表 + 按需分配</h2><p>这种实现方式维护一个空闲块链表，只包含未分配的内存块。malloc 分配时会搜索空闲链表，找到第一个大于等于所需空间的空闲区块，然后从该区块的尾部取出所需要的空间，剩余空间还是存在空闲链表中；如果该区块的剩余部分不足以放下首部信息，则直接将其从空闲链表摘除。最后返回这部分空间的指针。<br>下面是这种实现方式的几个示例： </p>
<p><img src="https://user-images.githubusercontent.com/87457873/127428872-9e4ff1c0-97d4-4e0c-898d-4d157749855f.png" alt="image"></p>
<p><img src="https://user-images.githubusercontent.com/87457873/127428877-6f7f9133-c6f6-4ec1-81ae-4bfea33e0a00.png" alt="image"></p>
<p><img src="https://user-images.githubusercontent.com/87457873/127428882-5847bc86-1e21-42c4-b6c2-28ed9d111345.png" alt="image"></p>
<p>通过 free 释放内存时，会将内存块加入到空闲链表中，并将前后相邻的空闲内存合并，这时使用双向链表管理空闲链表就很有用了。</p>
<p>和第一种方式相比，这种方式的优点主要是：<br></p>
<ul>
<li>空闲链表中只包含未被分配的内存块，节省遍历开销</li>
<li>只分配必须大小的空间，避免内存浪费</li>
</ul>
<p>这种方式的缺点是：多次调用 malloc 后，空闲内存被切成很多的小内存片段，产生较多外部碎片，会导致用户在申请内存使用时，找不到足够大的内存空间。这时需要进行内存整理，将连续的空闲内存合并，但是这会降低函数性能。</p>
<p>注意：内存紧凑在这里一般是不可用的，因为这会改变之前 malloc 返回的空间的地址。</p>
<h2 id="malloc-的实现方式三：分离的空闲链表"><a href="#malloc-的实现方式三：分离的空闲链表" class="headerlink" title="malloc 的实现方式三：分离的空闲链表"></a>malloc 的实现方式三：分离的空闲链表</h2><p>上面的两种分配方法，分配时间都和空闲块的数量成线性关系。</p>
<p>另一种实现方式是分离存储，即维护多个空闲链表，其中每个链表中的块有大致相等或者相同的大小。一般常见的是根据 2 的幂来划分块大小。分配时，可以直接在某个空闲链表里搜索合适的块。如果没有找到合适的块与之匹配，就搜索下一个链表，以此类推。</p>
<h3 id="简单分离存储"><a href="#简单分离存储" class="headerlink" title="简单分离存储"></a>简单分离存储</h3><p>每个大小类的空闲链表包含大小相等的块。分配时，从某个空闲链表取下一块，或者向操作系统请求内存片并分割成大小相等的块，形成新的链表。释放时，只需要简单的将块插入到相应空闲链表的前面。<br></p>
<p>优点一是分配和释放只需要在链表头进行操作，都是常数时间，二是因为每个块大小都是固定的，所以只需要一个 next 指针，不需要额外的控制信息，节省空间。缺点是容易造成内部碎片和外部碎片。内部碎片显而易见，因为每个块都是整体分配的，不会被分割。外部碎片在这样的模式下很容易产生：应用频繁地申请和释放较小大小的内存块，由于这些内存块不会合并，所以系统维护了大量小内存块形成的空闲链表，而没有多余空间来分配大内存块，导致产生外部碎片。</p>
<h3 id="分离适配"><a href="#分离适配" class="headerlink" title="分离适配"></a>分离适配</h3><p>这种方法同样维护了多个空闲链表，只不过每个链表中的块是大致相等的大小，比如每个链表中的块大小范围可能是：</p>
<ul>
<li>1</li>
<li>2</li>
<li>3~4</li>
<li>5~8</li>
<li>…</li>
<li>1025~2048</li>
<li>2049~4096</li>
<li>4097~∞</li>
</ul>
<p>在分配的时候，需要先根据申请内存的大小选择适当的空闲链表，然后遍历该链表，根据匹配算法（如首次适应）寻找合适的块。如果找到一个块，将其分割（可选），并将剩余部分插入到适当的空闲链表中。如果找不到合适的块，则查找下一个更大的大小类的空闲链表，以此类推，直到找到或者向操作系统申请额外的堆内存。在释放一个块时，合并前后相邻的空闲块，并将结果放到相应的空闲链表中。</p>
<p>分离适配方法是一种常见的选择，C 标准库中提供的 GNU malloc 包就是采用的这种方法。这种方法既快速，对内存的使用也很有效率。由于搜索被限制在堆的某个部分而不是整个堆，所以搜索时间减少了。内存利用率也得到了改善，避免大量内部碎片和外部碎片。</p>
<h3 id="伙伴系统"><a href="#伙伴系统" class="headerlink" title="伙伴系统"></a>伙伴系统</h3><p>伙伴系统是分离适配的一种特例。它的每个大小类的空闲链表包含大小相等的块，并且大小都是 2 的幂。最开始时，全局只有一个大小为 2m2m 字的空闲块，2m2m 是堆的大小。<br></p>
<p>假设分配的块的大小都是 2 的幂，为了分配一个大小为 2k2k 的块，需要找到大小恰好是 2k2k 的空闲块。如果找到，则整体分配。如果没有找到，则将刚好比它大的块分割成两块，每个剩下的半块（也叫做伙伴）被放置在相应的空闲链表中，以此类推，直到得到大小恰好是 2k2k 的空闲块。释放一个大小为 2k2k 的块时，将其与空闲的伙伴合并，得到新的更大的块，以此类推，直到伙伴已分配时停止合并。<br></p>
<p>伙伴系统分配器的主要优点是它的快速搜索和快速合并。主要缺点是要求块大小为 2 的幂可能导致显著的内部碎片。因此，伙伴系统分配器不适合通用目的的工作负载。然而，对于某些特定应用的工作负载，其中块大小预先知道是 2 的幂，伙伴系统分配器就很有吸引力了。</p>
<h3 id="tcmalloc"><a href="#tcmalloc" class="headerlink" title="tcmalloc"></a>tcmalloc</h3><p>tcmalloc 是 Google 开发的内存分配器，全称 Thread-Caching Malloc，即线程缓存的 malloc，实现了高效的多线程内存管理。<br></p>
<p>tcmalloc 主要利用了池化思想来管理内存分配。对于每个线程，都有自己的私有缓存池，内部包含若干个不同大小的内存块。对于一些小容量的内存申请，可以使用线程的私有缓存；私有缓存不足或大容量内存申请时再从全局缓存中进行申请。在线程内分配时不需要加锁，因此在多线程的情况下可以大大提高分配效率。</p>
<h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>malloc 使用链表管理内存块。malloc 有多种实现方式，在不同场景下可能会使用不同的匹配算法。</p>
<p>malloc 分配的空间中包含一个首部来记录控制信息，因此它分配的空间要比实际需要的空间大一些。这个首部对用户而言是透明的，malloc 返回的是紧跟在首部后面的地址，即可用空间的起始地址。</p>
<p>malloc 分配的函数应该是字对齐的。在 32 位模式中，malloc 返回的块总是 8 的倍数。在 64 位模式中，该地址总是 16 的倍数。最简单的方式是先让堆的起始位置字对齐，然后始终分配字大小倍数的内存。</p>
<p>malloc 只分配几种固定大小的内存块，可以减少外部碎片，简化对齐实现，降低管理成本。</p>
<p>free 只需要传递一个指针就可以释放内存，空间大小可以从首部读取。</p>
]]></content>
      <categories>
        <category>linux-doc 内存管理</category>
      </categories>
      <tags>
        <tag>Linux</tag>
      </tags>
  </entry>
  <entry>
    <title>其他工程问题以及调优</title>
    <url>/2023/01/15/linux-docs/%E5%86%85%E5%AD%98%E7%AE%A1%E7%90%86/%E5%85%B6%E4%BB%96%E5%B7%A5%E7%A8%8B%E9%97%AE%E9%A2%98%E4%BB%A5%E5%8F%8A%E8%B0%83%E4%BC%98/</url>
    <content><![CDATA[<h2 id="其他工程问题以及调优"><a href="#其他工程问题以及调优" class="headerlink" title="其他工程问题以及调优"></a>其他工程问题以及调优</h2><ul>
<li>DMA和cache一致性</li>
<li>内存的cgroup</li>
<li>memcg子系统分析</li>
<li>性能方面的调优： page in&#x2F;out, swap in&#x2F;out</li>
<li>Dirty ratio的一些设置</li>
<li>swappiness</li>
</ul>
<h3 id="DMA和cache一致性"><a href="#DMA和cache一致性" class="headerlink" title="DMA和cache一致性"></a>DMA和cache一致性</h3><p><img src="https://user-images.githubusercontent.com/87457873/127091602-b7e73ed9-d167-4ee2-881b-4b9e252cd344.png" alt="image"></p>
<p>工程中，DMA可以直接在内存和外设进行数据搬移，而CPU访问内存时要经过MMU。DMA访问不到CPU内部的cache，所以会出现cache不一致的问题。因为CPU读写内存时，如果在cache中命中，就不会再访问内存。</p>
<p>当CPU 写memory时，cache有两种算法：write_back ，write_through。一般都采用write_back。cache的硬件，使用LRU算法，把cache中的数据替换到磁盘。</p>
<p><img src="https://user-images.githubusercontent.com/87457873/127091613-fd6f917f-9f0d-4447-8a2f-c09154925ab5.png" alt="image"></p>
<p>cache一致性问题，主要靠以上两类api来解决这个问题。一致性DMA缓冲区api，和流式DMA映射api。CPU通过MMU访问DMA区域，在页表项中可以配置这片区域是否带cache。</p>
<p>现代的SoC，DMA引擎可以自动维护cache的同步。</p>
<h3 id="内存的cgroup"><a href="#内存的cgroup" class="headerlink" title="内存的cgroup"></a>内存的cgroup</h3><p>进程分group，内存也分group。</p>
<p>进程调度时，把一组进程加到一个cgroup，控制这一组进程的CPU权重和最大CPU占用率。在&#x2F;sys&#x2F;fs&#x2F;cgroup&#x2F;memory创建一个目录，把进程放到这个group。可以限制某个group下的进程不用swap，每个group的swapiness都可以配置。</p>
<p>比如，当你把某个group下的swapiness设置为0，那么这个group下进程的匿名页就不允许交换了。<br><br>&#x2F;proc&#x2F;sys&#x2F;vm&#x2F;swapiness是控制全局的swap特性，不影响加到group中的进程。</p>
<p>也可以控制每个group的最大内存消耗为200M，当这个group下进程使用的内存达到200M，就oom。</p>
<p>demo: 演示用memory cgroup来限制进程group内存资源消耗的方法</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">swapoff -a</span><br><span class="line">echo 1 &gt; /proc/sys/vm/overcommit_memory  # 进程申请多少资源，内核都允许</span><br><span class="line"></span><br><span class="line">root@whale:/sys/fs/cgroup/memory# mkdir A</span><br><span class="line">root@whale:/sys/fs/cgroup/memory# cd A</span><br><span class="line">root@whale:/sys/fs/cgroup/memory/A# echo $((200*1024*1024)) &gt; memory.limit_in_bytes</span><br><span class="line"></span><br><span class="line">cgexec -g memory:A ./a.out</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">[  560.618666] Memory cgroup out of memory: Kill process 5062 (a.out) score 977 or sacrifice child</span><br><span class="line">[  560.618817] Killed process 5062 (a.out) total-vm:2052084kB, anon-rss:204636kB, file-rss:1240kB</span><br></pre></td></tr></table></figure>

<h3 id="memory-cgroup子系统分析"><a href="#memory-cgroup子系统分析" class="headerlink" title="memory cgroup子系统分析"></a>memory cgroup子系统分析</h3><p>memcg v1的参数有25个, 通过数据结构 res_counter 来计算。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">~~~</span><br><span class="line">/* * The core object. the cgroup that wishes to account for some </span><br><span class="line">* resource may include this counter into its structures and use </span><br><span class="line">* the helpers described beyond */</span><br><span class="line"></span><br><span class="line">struct res_counter &#123;        </span><br><span class="line">  unsigned long long usage;      /*         * 目前资源消费的级别         */          </span><br><span class="line">  unsigned long long max_usage;        /*         *从counter创建的最大使用值       */      </span><br><span class="line">  unsigned long long limit;       /*         * 不能超过的使用限制       */       </span><br><span class="line">  unsigned long long soft_limit;      /*         * 可以超过使用的限制        */   </span><br><span class="line">  unsigned long long failcnt;        /*         * 尝试消费资源的失败数         */        </span><br><span class="line">  spinlock_t lock;        /*         * the lock to protect all of the above.        </span><br><span class="line">                                              * the routines below consider this to be IRQ-safe         */        </span><br><span class="line">  struct res_counter *parent; /*         * Parent counter, used for hierarchial resource accounting         */     </span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>内存的使用量 mem_cgroup_usage 通过递归RSS和page cache之和来计算。</p>
<p>struct mem_cgroup是负责内存 cgroup 的结构</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">mem_cgroup</span> &#123;</span>        </span><br><span class="line">  <span class="class"><span class="keyword">struct</span> <span class="title">cgroup_subsys_state</span> <span class="title">css</span>;</span> <span class="comment">// 通过css关联cgroup.        </span></span><br><span class="line">  <span class="class"><span class="keyword">struct</span> <span class="title">res_counter</span> <span class="title">res</span>;</span> <span class="comment">// mem统计变量	</span></span><br><span class="line">  res_counter memsw; <span class="comment">// mem+sw的和        </span></span><br><span class="line">  <span class="class"><span class="keyword">struct</span> <span class="title">res_counter</span> <span class="title">kmem</span>;</span> <span class="comment">// 内核内存统计量	...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这些参数的入口都在mm&#x2F;memcontrol.c下，比如说memory.usage_in_bytes的读取调用的是mem_cgroup_read函数, 统计的入口是mem_cgroup_charge_common()，如果统计值超过限制就会在cgroup内进行回收。调用者分别是缺页时调用的mem_cgroup_newpage_charge和 page cache相关的mem_cgroup_cache_charge。</p>
<p>当进程进入缺页异常的时候就会分配具体的物理内存，当物理内存使用超过高水平线以后，换页daemon(kswapd)就会被唤醒用于把内存交换到交换空间以腾出内存，当内存恢复至高水平线以后换页daemon进入睡眠。</p>
<p>缺页异常的入口是 __do_fault，</p>
<p>RSS在page_fault的时候记录，page cache是插入到inode的radix-tree中才记录的。<br><br>RSS在完全unmap的时候减少计数，page cache的page在离开inode的radix-tree才减少计数。<br><br>即使RSS完全unmap，也就是被kswapd给换出，可能作为SwapCache存留在系统中，除非不作为SwapCache，不然还是会被计数。<br><br>一个换入的page不会马上计数，只有被map的时候才会，当进行换页的时候，会预读一些不属于当前进程的page，而不是通过page fault，所以不在换入的时候计数。</p>
<h3 id="脏页写回的“时空”控制"><a href="#脏页写回的“时空”控制" class="headerlink" title="脏页写回的“时空”控制"></a>脏页写回的“时空”控制</h3><p><img src="https://user-images.githubusercontent.com/87457873/127091872-3ed6322c-8a23-4605-ae0d-253151b16f39.png" alt="image"></p>
<p>“脏页”：当进程修改了高速缓存里的数据时，该页就被内核标记为脏页，内核将会在合适的时间把脏页的数据写到磁盘中去，以保持高速缓存中的数据和磁盘中的数据是一致的。</p>
<p>通过时间(dirty_expire_centisecs)和比例，控制Linux脏页返回。</p>
<p>dirty_expire_centisecs：当Linux中脏页的时间到达dirty_expire_centisecs，无论脏页的数量多少，必须立即写回。通过在后台启动进程，进行脏页写回。<br><br>默认时间设置为30s。</p>
<p>dirty_ratio，dirty_background_ratio 基于空间的脏页写回控制。<br><br>不能让内存中存在太多空间的脏页。如果一个进程在循环调用write，当达到dirty_background_ratio后，后台进程就开始写回脏页。默认值5%。当达到第2个阈值dirty_ratio时，应用进程被阻塞。当内存中的脏页在两个阈值之间时，应用程序是不会阻塞。</p>
<h3 id="内存何时回收：水位控制"><a href="#内存何时回收：水位控制" class="headerlink" title="内存何时回收：水位控制"></a>内存何时回收：水位控制</h3><p>脏页写回不是 内存回收。</p>
<p>脏页写回：是保证在内存不在磁盘的数据不要太多。<br><br>水位控制：是指内存何时开始回收。</p>
<p><img src="https://user-images.githubusercontent.com/87457873/127091899-f51d60dd-f6b9-482c-87d8-0a39a7efdc42.png" alt="image"></p>
<p>由&#x2F;pro&#x2F;sys&#x2F;vm&#x2F;min_free_kbytes 控制，根据内存大小算出来的平方根。<br><br>pf_mem_alloc，允许内存达到低水位以下，还可以继续申请。内存的回收，在最低水位以上就开始回收。</p>
<p><img src="https://user-images.githubusercontent.com/87457873/127091930-7f67c72f-e8a4-4304-97e7-5253d040c1f3.png" alt="image"></p>
<p>每个Zone都有自己的三个水位，最小的水位是根据min_free_kbytes控制。5&#x2F;4min_free_kbytes ＝low 3&#x2F;2min_free_kbytes ＝high ,<br><br>Zone的最小内存达到5&#x2F;4的low 水位，Linux开始后台回收内存。直到达到6&#x2F;4的high水位，开始不回收。<br><br>当Zone的最小内存达到min水位，应用程序的写会直接阻塞。</p>
<p>实时操作系统，</p>
<p><img src="https://user-images.githubusercontent.com/87457873/127091968-cfd94cd2-61c1-45a0-a5a8-98f92663c57b.png" alt="image"></p>
<p>当你要开始回收内存时，回收比例通过swappiness越大，越倾向于回收匿名页；swappiness越小，越倾向于回收file-backed的页面。<br><br>当把cgroup中的swapiness设置为0，就不回收匿名页了。<br><br>当你的应用会经常去访问数据malloc的内存，需要把swapiness设置小。dirty的设置，水位的设置都没有一个标准，要看应用使用内存的情况而定。</p>
<p>getdelays工具：用来评估应用等待CPU，内存，IO，的时间。<br><br>linux&#x2F;Documents&#x2F;accounting</p>
<p><img src="https://user-images.githubusercontent.com/87457873/127091991-745c4687-b2f0-4575-b502-a77cc8fd55cf.png" alt="image"></p>
<p>CONFIG_TASK_DELAY_ACCT&#x3D;y<br>CONFIG_TASKSTATS&#x3D;y</p>
<p>vmstat 可以展现给定时间间隔的服务器的状态值，包括Linux的CPU使用率，内存使用，虚拟内存交换情况，IO读写情况。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">vmstat 1</span><br></pre></td></tr></table></figure>
<p>Documents&#x2F;sysctl&#x2F;vm.txt 中有所有参数最细节的描述。</p>
]]></content>
      <categories>
        <category>linux-doc 内存管理</category>
      </categories>
      <tags>
        <tag>Linux</tag>
      </tags>
  </entry>
  <entry>
    <title>内存与IO的交换</title>
    <url>/2023/01/15/linux-docs/%E5%86%85%E5%AD%98%E7%AE%A1%E7%90%86/%E5%86%85%E5%AD%98%E4%B8%8EIO%E7%9A%84%E4%BA%A4%E6%8D%A2/</url>
    <content><![CDATA[<h2 id="内存与I-O的交换"><a href="#内存与I-O的交换" class="headerlink" title="内存与I&#x2F;O的交换"></a>内存与I&#x2F;O的交换</h2><p>堆、栈、代码段是否常驻内存？本文主要介绍两类不同的页面，以及这两类页面如何在内存和磁盘间进行交换？以及内存和磁盘的颠簸行为- swaping，和硬盘的swap分区。</p>
<h3 id="page-cache"><a href="#page-cache" class="headerlink" title="page cache"></a>page cache</h3><p><strong>file-backed的页面</strong>：（有文件背景的页面，比如代码段、比如read&#x2F;write方法读写的文件、比如mmap读写的文件；他们有对应的硬盘文件，因此如果要交换，可以直接和硬盘对应的文件进行交换），此部分页面进page cache。</p>
<p><strong>匿名页</strong>：匿名页，如stack，heap，CoW后的数据段等；他们没有对应的硬盘文件，因此如果要交换，只能交换到虚拟内存-swapfile或者Linux的swap硬盘分区），此部分页面，如果系统内存不充分，可以被swap到swapfile或者硬盘的swap分区。</p>
<p><img src="https://user-images.githubusercontent.com/87457873/127090951-c12b4866-a403-43c5-9cdd-8479b6c7652f.png" alt="image"></p>
<p>内核通过两种方式打开硬盘的文件，<strong>任何时候打开文件，Linux会申请一个page cache，然后把文件读到page cache里。</strong>page cache 是内存针对硬盘的缓存。</p>
<p>Linux读写文件有两种方式：read&#x2F;write 和 mmap</p>
<p>1）read&#x2F;write: read会把内核空间的page cache，往用户空间的buffer拷贝。<br><br>参数 fd, buffer, size ，write只是把用户空间的buffer拷贝到内核空间的page cache。</p>
<p>2）mmap：可以避免内核空间到用户空间拷贝的过程，直接把文件映射成一个虚拟地址指针，指向linux内核申请的page cache。也就知道page cache和硬盘里文件的对应关系。</p>
<p>参数 fd,</p>
<p>文件对于应用程序，只是一部分内存。Linux使用write写文件，只是把文件写进内存，并没有sync。而内存的数据和硬盘交换的功能去完成。</p>
<p>ELF可执行程序的头部会记录，从xxx到xxx是代码段。把代码段映射到虚拟地址，0～3 G, 权限是RX。这段地址映射到内核空间的page cache, 这段page cache又映射到可执行程序。</p>
<p>page cache，会根据LRU算法（最近最少使用）进行替换。</p>
<p>demo演示 page cache会多大程度影响程序执行时间。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">echo 3 &gt; /proc/sys/vm/drop_caches</span><br><span class="line">time python hello.py</span><br><span class="line">\time -v python hello.py</span><br><span class="line"></span><br><span class="line">root@whale:/home/gzzhangyi2015# \time -v python hello.py</span><br><span class="line">Hello World! Love, Python</span><br><span class="line">	Command being timed: &quot;python hello.py&quot;</span><br><span class="line">	User time (seconds): 0.01</span><br><span class="line">	System time (seconds): 0.00</span><br><span class="line">	Percent of CPU this job got: 40%</span><br><span class="line">	Elapsed (wall clock) time (h:mm:ss or m:ss): 0:00.03</span><br><span class="line">	Average shared text size (kbytes): 0</span><br><span class="line">	Average unshared data size (kbytes): 0</span><br><span class="line">	Average stack size (kbytes): 0</span><br><span class="line">	Average total size (kbytes): 0</span><br><span class="line">	Maximum resident set size (kbytes): 6544</span><br><span class="line">	Average resident set size (kbytes): 0</span><br><span class="line">	Major (requiring I/O) page faults: 10</span><br><span class="line">	Minor (reclaiming a frame) page faults: 778</span><br><span class="line">	Voluntary context switches: 54</span><br><span class="line">	Involuntary context switches: 9</span><br><span class="line">	Swaps: 0</span><br><span class="line">	File system inputs: 6528</span><br><span class="line">	File system outputs: 0</span><br><span class="line">	Socket messages sent: 0</span><br><span class="line">	Socket messages received: 0</span><br><span class="line">	Signals delivered: 0</span><br><span class="line">	Page size (bytes): 4096</span><br><span class="line">	Exit status: 0</span><br><span class="line">    </span><br><span class="line">root@whale:/home/gzzhangyi2015# \time -v python hello.py</span><br><span class="line">Hello World! Love, Python</span><br><span class="line">	Command being timed: &quot;python hello.py&quot;</span><br><span class="line">	User time (seconds): 0.01</span><br><span class="line">	System time (seconds): 0.00</span><br><span class="line">	Percent of CPU this job got: 84%</span><br><span class="line">	Elapsed (wall clock) time (h:mm:ss or m:ss): 0:00.01</span><br><span class="line">	Average shared text size (kbytes): 0</span><br><span class="line">	Average unshared data size (kbytes): 0</span><br><span class="line">	Average stack size (kbytes): 0</span><br><span class="line">	Average total size (kbytes): 0</span><br><span class="line">	Maximum resident set size (kbytes): 6624</span><br><span class="line">	Average resident set size (kbytes): 0</span><br><span class="line">	Major (requiring I/O) page faults: 0</span><br><span class="line">	Minor (reclaiming a frame) page faults: 770</span><br><span class="line">	Voluntary context switches: 1</span><br><span class="line">	Involuntary context switches: 4</span><br><span class="line">	Swaps: 0</span><br><span class="line">	File system inputs: 0</span><br><span class="line">	File system outputs: 0</span><br><span class="line">	Socket messages sent: 0</span><br><span class="line">	Socket messages received: 0</span><br><span class="line">	Signals delivered: 0</span><br><span class="line">	Page size (bytes): 4096</span><br><span class="line">	Exit status: 0</span><br></pre></td></tr></table></figure>

<p>总结：Linux有两种方式读取文件，不管以何种方式读文件，都会产生page cache 。</p>
<h3 id="free命令的详细解释"><a href="#free命令的详细解释" class="headerlink" title="free命令的详细解释"></a>free命令的详细解释</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">             total       used       free     shared    buffers     cached</span><br><span class="line">Mem:      49537244    1667532   47869712     146808      21652     421268</span><br><span class="line">-/+ buffers/cache:    1224612   48312632</span><br><span class="line">Swap:      4194300          0    4194300</span><br></pre></td></tr></table></figure>

<p><img src="https://user-images.githubusercontent.com/87457873/127091064-69eb4285-772a-476c-a158-e9263353aa48.png" alt="image"></p>
<p>buffers&#x2F;cache都是文件系统的缓存，当访问ext3&#x2F;ext4,fat等文件系统中的文件，产生cache。当直接访问裸分区（&#x2F;dev&#x2F;sdax）时，产生buffer。</p>
<p>访问裸分区的用户，主要是应用程序直接打开 or 文件系统本身。dd命令 or 硬盘备份 or sd卡，会访问裸分区，产生的缓存就是buffer。而ext4文件系统把硬盘当作裸分区。</p>
<p>buffer和cache没有本质的区别，只是背景的区别。</p>
<p>-&#x2F;+ buffer&#x2F;cache 的公式<br><br>used buffers&#x2F;cache &#x3D; used - buffers - cached<br><br>free buffers&#x2F;cache &#x3D; free + buffers + cached</p>
<p>新版free<br><br>available参数：评估出有多少空闲内存给应用程序使用，free + 可回收的。</p>
<p><img src="https://user-images.githubusercontent.com/87457873/127091093-ea41535c-3f39-4800-83c0-143efe87b4be.png" alt="image"></p>
<h3 id="File-backed和Anonymous-page"><a href="#File-backed和Anonymous-page" class="headerlink" title="File-backed和Anonymous page"></a>File-backed和Anonymous page</h3><ul>
<li><p>File-backed映射把进程的虚拟地址空间映射到files</p>
<ul>
<li>比如 代码段<br></li>
<li>比如 mmap一个字体文件<br></li>
</ul>
</li>
<li><p>Anonymous映射是进程的虚拟地址空间没有映射到任何file<br></p>
<ul>
<li>Stack<br></li>
<li>Heap<br></li>
<li>CoW pages<br></li>
</ul>
</li>
</ul>
<p>anonymous pages(没有任何文件背景)分配一个swapfile文件或者一个swap分区，来进行交换到磁盘的动作。</p>
<p>read&#x2F;write和 mmap 本质上都是有文件背景的映射，把进程的虚拟地址空间映射到files。在内存中的副本，只是一个page cache。是page cache就有可能被踢出内存。CPU 内部的cache，当访问新的内存时，也会被踢出cache。</p>
<p>demo：演示进程的代码段是如何被踢出去的？</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">pidof firefox</span><br><span class="line">cat /proc/&lt;pid&gt;/smaps</span><br><span class="line"></span><br><span class="line">运行 oom.c</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<h3 id="swap以及zRAM"><a href="#swap以及zRAM" class="headerlink" title="swap以及zRAM"></a>swap以及zRAM</h3><p>数据段，在未写过时，有文件背景。在写过之后，变成没有文件背景，就被当作匿名页。linux把swap分区，当作匿名页的文件背景。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">swap(v.)，内存和硬盘之间的颠簸行为。 </span><br><span class="line">swap(n.)，swap分区和swap文件，当作内存中匿名页的交换背景。在windows内，被称作虚拟内存。pagefile.sys</span><br></pre></td></tr></table></figure>
<h3 id="页面回收和LRU"><a href="#页面回收和LRU" class="headerlink" title="页面回收和LRU"></a>页面回收和LRU</h3><p><img src="https://user-images.githubusercontent.com/87457873/127091301-048b087b-5170-45ce-a73f-7a40e4a9de56.png" alt="image"></p>
<p>回收匿名页和 回收有文件背景的页面。<br><br>后台慢慢回收：通过kswapd进程，回收到高水位(high)时，才停止回收。从low -&gt; high<br><br>直接回收：当水位达到min水位，会在两种页面同时进行回收，回收比例通过swappiness越大，越倾向于回收匿名页；swappiness越小，越倾向于回收file-backed的页面。当然，它们的回收方法都是一样的LRU算法。</p>
<h3 id="Linux-Page-Replacement"><a href="#Linux-Page-Replacement" class="headerlink" title="Linux Page Replacement"></a>Linux Page Replacement</h3><p>用LRU算法来进行swap和page cache的页面替换。</p>
<p><img src="https://user-images.githubusercontent.com/87457873/127091361-9715e5bd-5d5d-4ac7-925f-5a222dd37aba.png" alt="image"></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">现在cache的大小是4页，前四次，1，2，3，4文件被一次使用，注意第七次，5文件被使用，系统评估最近最少被使用的文件是3，那么不好意思，3被swap出去，5加载进来，依次类推。</span><br><span class="line"></span><br><span class="line">所以LRU可能会触发page cache或者anonymous页与对应文件的数据交换。</span><br></pre></td></tr></table></figure>

<h3 id="嵌入式系统的zRAM"><a href="#嵌入式系统的zRAM" class="headerlink" title="嵌入式系统的zRAM"></a>嵌入式系统的zRAM</h3><p><img src="https://user-images.githubusercontent.com/87457873/127091410-37251401-19ba-4daa-95ff-a803ade82c3a.png" alt="image"></p>
<p>zRAM: 用内存来做swap分区。从内存中开辟一小段出来，模拟成硬盘分区，做交换分区，交换匿名页，自带透明压缩功能。当应用程序往zRAM写数据时，会自动把匿名页进行压缩。当应用程序访问匿名页时，内存页表里不命中，发生page fault（major）。从zRAM中把匿名页透明解压出来，还到内存。</p>
]]></content>
      <categories>
        <category>linux-doc 内存管理</category>
      </categories>
      <tags>
        <tag>Linux</tag>
      </tags>
  </entry>
  <entry>
    <title>内存的动态申请和释放</title>
    <url>/2023/01/15/linux-docs/%E5%86%85%E5%AD%98%E7%AE%A1%E7%90%86/%E5%86%85%E5%AD%98%E7%9A%84%E5%8A%A8%E6%80%81%E7%94%B3%E8%AF%B7%E5%92%8C%E9%87%8A%E6%94%BE/</url>
    <content><![CDATA[<h2 id="内存的动态申请和释放"><a href="#内存的动态申请和释放" class="headerlink" title="内存的动态申请和释放"></a>内存的动态申请和释放</h2><p>内核空间 和用户空间申请的内存最终和buddy怎么交互？以及在页表映射上的区别？虚拟地址到物理地址，什么时候开始映射？</p>
<h3 id="Buddy的问题"><a href="#Buddy的问题" class="headerlink" title="Buddy的问题"></a>Buddy的问题</h3><p>分配的粒度太大<br>buddy算法把空闲页面分成1，2，4页，buddy算法会明确知道哪一页内存空闲还是被占用？</p>
<p>4k，8k，16k</p>
<p>无论是在应用还是内核，都需要申请很小的内存。</p>
<p>从buddy要到的内存，会进行slab切割。</p>
<h3 id="slab原理："><a href="#slab原理：" class="headerlink" title="slab原理："></a>slab原理：</h3><p>比如在内核中申请8字节的内存，buddy分配4K，分成很多个小的8个字节，每个都是一个object。</p>
<p>slab，slub，slob 是slab机制的三种不同实现算法。</p>
<p>Linux 会针对一些常规的小的内存申请，数据结构，会做slab申请。</p>
<p>cat &#x2F;proc&#x2F;slabinfo 可以看到内核空间小块内存的申请情况，也是slab分配的情况。</p>
<p><num_objs>：每个slab一共可以分出多少个obj，<br><active_objs> ：还可以分配多少个obj，<br>&lt; pagesperslab&gt;：每个slab对应多少个pages，<br>&lt; objperslab&gt;：每个slab可以分出多少个object，<br>&lt; objsize&gt;：每个obj多大，</p>
<p>slab主要分为两类：</p>
<p>一、常用数据结构像 nfsd_drc， UDPv6，TCPv6 ，这些经常申请和释放的数据结构。比如，存在TCPv6的slab，之后申请 TCPv6 数据结构时，会通过这个slab来申请。</p>
<p><img src="https://user-images.githubusercontent.com/87457873/127087302-cc7eee3c-f9a6-4340-8b20-3663bb338a7c.png" alt="image"></p>
<p>二、常规的小内存申请，做的slab。例如 kmalloc-32，kmalloc-64， kmalloc-96， kmalloc-128</p>
<p><img src="https://user-images.githubusercontent.com/87457873/127087333-f0f4f6ef-19fb-4383-9606-26471744d5a7.png" alt="image"></p>
<p><img src="https://user-images.githubusercontent.com/87457873/127087352-9e0e0697-b1f8-45d8-949b-7a7e17b503f8.png" alt="image"></p>
<p>注意，slab申请和分配的都是只针对内核空间，与用户空间申请分配内存无关。用户空间的malloc和free调用的是libc。</p>
<p>slab和buddy的关系？<br><br>1、slab的内存来自于buddy。slab相当于二级管理器。<br><br>2、slab和buddy在算法上，级别是对等的。</p>
<p>两者都是内存分配器，buddy是把内存条分成多个Zone来管理分配，slab是把从buddy拿到的内存，进行管理分配。</p>
<p>同理，malloc 和free也不找buddy拿内存。 malloc 和free不是系统调用，只是c库中的函数。</p>
<h3 id="mallopt"><a href="#mallopt" class="headerlink" title="mallopt"></a>mallopt</h3><p>在C库中有一个api是mallopt，可以控制一系列的选项。</p>
<p><img src="https://user-images.githubusercontent.com/87457873/127087421-6f665ad2-7715-4fa8-a1f7-9e855a299551.png" alt="image"></p>
<p>M_TRIM_THRESHOLD：控制c库把内存还给内核的阈值。<br><br>-1UL 代表最大的正整数。</p>
<p>此处代表应用程序把内存还给c库后，c库并不把内存还给内核。</p>
<p>&lt;\do your RT-thing&gt;<br><br>程序在此处申请内存，都不需要再和内核交互了，此时程序的实时性比较高。</p>
<h3 id="kmalloc-vs-vmalloc-ioremap"><a href="#kmalloc-vs-vmalloc-ioremap" class="headerlink" title="kmalloc vs. vmalloc&#x2F;ioremap"></a>kmalloc vs. vmalloc&#x2F;ioremap</h3><p>内存空间： 内存+寄存器</p>
<p>register –&gt; LDR&#x2F;STR</p>
<p>所有内存空间的东西，CPU去访问，都要通过虚拟地址。<br>CPU –&gt; virt –&gt; mmu –&gt; phys</p>
<p>cpu请求虚拟地址，mmu根据cpu请求的虚拟地址，查页表得物理地址。</p>
<p>buddy算法，管理这一页的使用情况。</p>
<p>两个虚拟地址可以映射到同一个物理地址。</p>
<p><img src="https://user-images.githubusercontent.com/87457873/127087493-e71ab614-ceb1-4a77-9b48-6daad3bf59d9.png" alt="image"></p>
<p>页表 -&gt; 数组，</p>
<p>任何一个虚拟地址，都可以用地址的高20位，作为页表的行号去读对应的页表项。而低12位，是指页内偏移。（由于一页是4K，2^12 足够描述)</p>
<p>kmalloc 和 vmalloc 申请的内存，有什么区别？<br>答：申请之后，是否还要去改页表。一般情况，kmalloc申请内存，不需要再去改页表。同一张页表，几个虚拟地址可以同时映射到同一个物理地址。</p>
<p>寄存器，通过ioremap往vmalloc区域，进行映射。然后改进程的虚拟地址页表。</p>
<p>总结：所有的页，最底层都是用buddy算法进行管理，用虚拟地址找物理地址。理解内存分配和映射的区别，无论是lowmem还是highmem 都可以被vmalloc拿走，也可能被用户拿走，只不过拿走之后，还要把虚拟地址往物理地址再映射一遍。但如果是被kmalloc拿走，一般指低端内存，就不需要再改进程的页表。因为这部分低端内存，已经做好了虚实映射。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">cat /proc/vmallocinfo |grep ioremap</span><br></pre></td></tr></table></figure>
<p>可以看到寄存器中的哪个区域，被映射到哪个虚拟地址。</p>
<p>vmalloc区域主要用来，vmalloc申请的内存从这里找虚拟地址 和 寄存器的ioremap映射。</p>
<h3 id="Linux内存分配的lazy行为"><a href="#Linux内存分配的lazy行为" class="headerlink" title="Linux内存分配的lazy行为"></a>Linux内存分配的lazy行为</h3><p>Linux总是以最lazy的方式，给应用程序分配内存。</p>
<p><img src="https://user-images.githubusercontent.com/87457873/127087582-ece701ed-ea7f-448c-bb2b-f5c6e37b99bf.png" alt="image"></p>
<p>malloc 100M内存成功时，其实并没有真实拿到。只有当100M内存中的任何一页，被写一次的时候，才成功。</p>
<p>vss：虚拟地址空间。 rss：常驻内存空间</p>
<p>malloc 100M内存成功时，Linux把100M内存全部以只读的形式，映射到一个全部清0的页面。</p>
<p>当应用程序写100M中每一页任意字节时，会发出page fault。 linux 内核收到缺页中断后，从硬件寄存器中读取到，包括缺页中断发生的原因和虚拟地址。Linux从内存条申请一页内存，执行cow，把页面重新拷贝到新申请的页表，再把进程页表中的虚拟地址，指向一个新的物理地址，权限也被改成R+W。</p>
<p>调用brk 把8k变成 16k。</p>
<p>针对应用程序的堆、代码、栈、等，会使用lazy分配机制，只有当写内存页时，才会真实请求内存分配页表。但，当内核使用kmalloc申请内存时，就真实的分配相应的内存，不使用lazy机制。</p>
<h3 id="内存OOM"><a href="#内存OOM" class="headerlink" title="内存OOM"></a>内存OOM</h3><p>当真实去写内存时，应用程序并不能拿到真实的内存时。Linux启动OOM，linux在运行时，会对每一个进程进行out-of-memory打分。打分主要基于，耗费的内存。耗费的内存越多，打分越高。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">cat /proc/&lt;pid&gt;/oom_score</span><br></pre></td></tr></table></figure>

<p>demo:</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string.h&gt;</span></span></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">(<span class="type">int</span> argc, <span class="type">char</span> **argv)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">int</span> max = <span class="number">-1</span>;</span><br><span class="line">    <span class="type">int</span> mb = <span class="number">0</span>;</span><br><span class="line">    <span class="type">char</span> *buffer;</span><br><span class="line">    <span class="type">int</span> i;</span><br><span class="line"><span class="meta">#<span class="keyword">define</span> SIZE 2000</span></span><br><span class="line">    <span class="type">unsigned</span> <span class="type">int</span> *p = <span class="built_in">malloc</span>(<span class="number">1024</span> * <span class="number">1024</span> * SIZE);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;malloc buffer: %p\n&quot;</span>, p);</span><br><span class="line">    <span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; <span class="number">1024</span> * <span class="number">1024</span> * (SIZE/<span class="keyword">sizeof</span>(<span class="type">int</span>)); i++) &#123;</span><br><span class="line">        p[i] = <span class="number">123</span>;</span><br><span class="line">        <span class="keyword">if</span> ((i &amp; <span class="number">0xFFFFF</span>) == <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">&quot;%dMB written\n&quot;</span>, i &gt;&gt; <span class="number">18</span>);</span><br><span class="line">            usleep(<span class="number">100000</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    pause();</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>设定条件：</p>
<p>总内存1G<br><br>1、swapoff -a 关掉swap交换<br><br>2、echo 1 &gt; &#x2F;proc&#x2F;sys&#x2F;vm&#x2F;overcommit_memory<br><br>3、内核不去评估系统还有多少空闲内存<br></p>
<p>Linux进行OOM打分，主要是看耗费内存情况，此外还会参考用户权限，比如root权限，打分会减少30分。</p>
<p>还有OOM打分因子：&#x2F;proc&#x2F;pid&#x2F;oom_score_adj （加减）和 &#x2F;proc&#x2F;pid&#x2F;oom_adj （乘除）。</p>
<p><img src="https://user-images.githubusercontent.com/87457873/127087921-c7f64317-9895-4b4e-93fa-4d9f44543a31.png" alt="image"></p>
<h3 id="总结："><a href="#总结：" class="headerlink" title="总结："></a>总结：</h3><p>1、slab的作用，针对在内核空间小内存分配，和常用数据结构的申请。<br><br>2、同样的二次分配器，在用户空间是C库。malloc和free的时候，内存不一定从buddy分配和还给buddy。<br><br>3、kmalloc，vmalloc 和malloc的区别<br></p>
<ul>
<li>kmalloc：申请内存，一般在低端内存区。申请到时，内存已经映射过了，不需要再去改进程的页表。所以，申请到的物理页是连续的。</li>
<li>vmalloc：申请内存，申请到就拿到内存，并且已经修改了进程页表的虚拟地址到物理地址的映射。vmalloc()申请的内存并不保证物理地址的连续。</li>
<li>用户空间的malloc：申请内存，申请到并没有拿到，写的时候才去拿到。拿到之后，才去改页表。申请成功，页表只读，只有到写时，发生page fault，才去buddy拿内存。</li>
<li>kmalloc和vmalloc针对内核空间，malloc针对用户空间。这些内存，可以来自任何一个Zone。</li>
<li>无论是kmalloc，vmalloc还是用户空间的malloc，都可以使用内存条的不同Zone，无论是highmem zone、lowmem zone 和 DMA zone。</li>
</ul>
<p>4、如果在从buddy拿不到内存时，会触发Linux对所有进程进行OOM打分。当Linux出现内存耗尽，就kill一个oom score 最高的那个进程。oom_score，可以根据 oom_adj （-17～25）。</p>
<p>安卓的程序，不停的调整前台和后台进程oom_score，当被切换到后台时，oom_score会被调整的比较大。以保证前台的进程不容易因为oom而kill掉。</p>
]]></content>
      <categories>
        <category>linux-doc 内存管理</category>
      </categories>
      <tags>
        <tag>Linux</tag>
      </tags>
  </entry>
  <entry>
    <title>内存管理之内存映射</title>
    <url>/2023/01/15/linux-docs/%E5%86%85%E5%AD%98%E7%AE%A1%E7%90%86/%E5%86%85%E5%AD%98%E7%AE%A1%E7%90%86%E4%B9%8B%E5%86%85%E5%AD%98%E6%98%A0%E5%B0%84/</url>
    <content><![CDATA[<h2 id="一-前言"><a href="#一-前言" class="headerlink" title="一. 前言"></a>一. 前言</h2><p>  本文为内存部分最后一篇，介绍内存映射。内存映射不仅是物理内存和虚拟内存间的映射，也包括将文件中的内容映射到虚拟内存空间。这个时候，访问内存空间就能够访问到文件里面的数据。而仅有物理内存和虚拟内存的映射，是一种特殊情况。本文首先分析用户态在堆中申请小块内存的brk和申请大块内存的mmap，之后会分析内核态的内存映射机制vmalloc，kmap_atomic，swapper_pg_dir以及内核态缺页异常。</p>
<h2 id="二-用户态内存映射"><a href="#二-用户态内存映射" class="headerlink" title="二. 用户态内存映射"></a>二. 用户态内存映射</h2><p>  用户态调用malloc()会分配堆内存空间，而实际上则是完成了一次用户态的内存映射，根据分配空间的大小，内存映射对应的系统调用主要有brk()和mmap()(当然我们也可以直接调用mmap()来映射文件)。对小块内存（小于 128K），C 标准库使用 brk() 来分配，也就是通过移动堆顶的位置来分配内存。这些内存释放后并不会立刻归还系统，而是被缓存起来，这样就可以重复使用。而大块内存（大于 128K），则直接使用内存映射 mmap() 来分配，也就是在文件映射段找一块空闲内存分配出去。这两种方式，自然各有优缺点。</p>
<p>  brk() 方式的缓存，可以减少缺页异常的发生，提高内存访问效率。不过，由于这些内存没有归还系统，在内存工作繁忙时，频繁的内存分配和释放会造成内存碎片。</p>
<p>  mmap() 方式分配的内存，会在释放时直接归还系统，所以每次 mmap() 都会发生缺页异常。在内存工作繁忙时，频繁的内存分配会导致大量的缺页异常，使内核的管理负担增大。这也是 malloc() 只对大块内存使用 mmap() 的原因。</p>
<h3 id="2-1-小块内存申请"><a href="#2-1-小块内存申请" class="headerlink" title="2.1 小块内存申请"></a>2.1 小块内存申请</h3><p>  brk()系统调用为sys_brk()函数，其参数brk是新的堆顶位置，而mm-&gt;brk是原堆顶位置。该函数主要逻辑如下</p>
<ul>
<li>将原来的堆顶和现在的堆顶按照页对齐地址比较大小，判断是否在同一页中<ul>
<li>如果同一页则不需要分配新页，直接跳转至set_brk，设置mm-&gt;brk为新的brk即可</li>
<li>如果不在同一页<ul>
<li>如果新堆顶小于旧堆顶，则说明不是新分配内存而是释放内存，由此调用__do_munmap()释放</li>
<li>如果是新分配内存，则调用find_vma()，查找vm_area_struct红黑树中原堆顶所在vm_area_struct的下一个结构体，如果在二者之间有足够的空间分配一个页则调用do_brk_flags()分配堆空间。如果不可以则分配失败。</li>
</ul>
</li>
</ul>
</li>
</ul>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">SYSCALL_DEFINE1(brk, <span class="type">unsigned</span> <span class="type">long</span>, brk)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">unsigned</span> <span class="type">long</span> retval;</span><br><span class="line">    <span class="type">unsigned</span> <span class="type">long</span> newbrk, oldbrk, origbrk;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">mm_struct</span> *<span class="title">mm</span> =</span> current-&gt;mm;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">vm_area_struct</span> *<span class="title">next</span>;</span></span><br><span class="line">......</span><br><span class="line">    newbrk = PAGE_ALIGN(brk);</span><br><span class="line">    oldbrk = PAGE_ALIGN(mm-&gt;brk);</span><br><span class="line">    <span class="keyword">if</span> (oldbrk == newbrk) &#123;</span><br><span class="line">        mm-&gt;brk = brk;</span><br><span class="line">        <span class="keyword">goto</span> success;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">     * Always allow shrinking brk.</span></span><br><span class="line"><span class="comment">     * __do_munmap() may downgrade mmap_sem to read.</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">if</span> (brk &lt;= mm-&gt;brk) &#123;</span><br><span class="line">        <span class="type">int</span> ret;</span><br><span class="line">        <span class="comment">/*</span></span><br><span class="line"><span class="comment">         * mm-&gt;brk must to be protected by write mmap_sem so update it</span></span><br><span class="line"><span class="comment">         * before downgrading mmap_sem. When __do_munmap() fails,</span></span><br><span class="line"><span class="comment">         * mm-&gt;brk will be restored from origbrk.</span></span><br><span class="line"><span class="comment">         */</span></span><br><span class="line">        mm-&gt;brk = brk;</span><br><span class="line">        ret = __do_munmap(mm, newbrk, oldbrk-newbrk, &amp;uf, <span class="literal">true</span>);</span><br><span class="line">        <span class="keyword">if</span> (ret &lt; <span class="number">0</span>) &#123;</span><br><span class="line">            mm-&gt;brk = origbrk;</span><br><span class="line">            <span class="keyword">goto</span> out;</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (ret == <span class="number">1</span>) &#123;</span><br><span class="line">            downgraded = <span class="literal">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">goto</span> success;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">/* Check against existing mmap mappings. */</span></span><br><span class="line">    next = find_vma(mm, oldbrk);</span><br><span class="line">    <span class="keyword">if</span> (next &amp;&amp; newbrk + PAGE_SIZE &gt; vm_start_gap(next))</span><br><span class="line">        <span class="keyword">goto</span> out;</span><br><span class="line">    <span class="comment">/* Ok, looks good - let it rip. */</span></span><br><span class="line">    <span class="keyword">if</span> (do_brk_flags(oldbrk, newbrk-oldbrk, <span class="number">0</span>, &amp;uf) &lt; <span class="number">0</span>)</span><br><span class="line">        <span class="keyword">goto</span> out;</span><br><span class="line">    mm-&gt;brk = brk;</span><br><span class="line">success:</span><br><span class="line">    populate = newbrk &gt; oldbrk &amp;&amp; (mm-&gt;def_flags &amp; VM_LOCKED) != <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">if</span> (downgraded)</span><br><span class="line">        up_read(&amp;mm-&gt;mmap_sem);</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">        up_write(&amp;mm-&gt;mmap_sem);</span><br><span class="line">    userfaultfd_unmap_complete(mm, &amp;uf);</span><br><span class="line">    <span class="keyword">if</span> (populate)</span><br><span class="line">        mm_populate(oldbrk, newbrk - oldbrk);</span><br><span class="line">    <span class="keyword">return</span> brk;</span><br><span class="line">out:</span><br><span class="line">    retval = origbrk;</span><br><span class="line">    up_write(&amp;mm-&gt;mmap_sem);</span><br><span class="line">    <span class="keyword">return</span> retval;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>  在 do_brk_flags() 中，调用 find_vma_links() 找到将来的 vm_area_struct 节点在红黑树的位置，找到它的父节点、前序节点。接下来调用 vma_merge()，看这个新节点是否能够和现有树中的节点合并。如果地址是连着的，能够合并，则不用创建新的 vm_area_struct 了，直接跳到 out，更新统计值即可；如果不能合并，则创建新的 vm_area_struct，既加到 anon_vma_chain 链表中，也加到红黑树中。</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> *  this is really a simplified &quot;do_mmap&quot;.  it only handles</span></span><br><span class="line"><span class="comment"> *  anonymous maps.  eventually we may be able to do some</span></span><br><span class="line"><span class="comment"> *  brk-specific accounting here.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="type">static</span> <span class="type">int</span> <span class="title function_">do_brk_flags</span><span class="params">(<span class="type">unsigned</span> <span class="type">long</span> addr, <span class="type">unsigned</span> <span class="type">long</span> len, <span class="type">unsigned</span> <span class="type">long</span> flags, <span class="keyword">struct</span> list_head *uf)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">mm_struct</span> *<span class="title">mm</span> =</span> current-&gt;mm;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">vm_area_struct</span> *<span class="title">vma</span>, *<span class="title">prev</span>;</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">rb_node</span> **<span class="title">rb_link</span>, *<span class="title">rb_parent</span>;</span></span><br><span class="line">......</span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">     * Clear old maps.  this also does some error checking for us</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">while</span> (find_vma_links(mm, addr, addr + len, &amp;prev, &amp;rb_link,</span><br><span class="line">                  &amp;rb_parent)) &#123;</span><br><span class="line">        <span class="keyword">if</span> (do_munmap(mm, addr, len, uf))</span><br><span class="line">            <span class="keyword">return</span> -ENOMEM;</span><br><span class="line">    &#125;</span><br><span class="line">......</span><br><span class="line">    <span class="comment">/* Can we just expand an old private anonymous mapping? */</span></span><br><span class="line">    vma = vma_merge(mm, prev, addr, addr + len, flags,</span><br><span class="line">            <span class="literal">NULL</span>, <span class="literal">NULL</span>, pgoff, <span class="literal">NULL</span>, NULL_VM_UFFD_CTX);</span><br><span class="line">    <span class="keyword">if</span> (vma)</span><br><span class="line">        <span class="keyword">goto</span> out;</span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">     * create a vma struct for an anonymous mapping</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    vma = vm_area_alloc(mm);</span><br><span class="line">    <span class="keyword">if</span> (!vma) &#123;</span><br><span class="line">        vm_unacct_memory(len &gt;&gt; PAGE_SHIFT);</span><br><span class="line">        <span class="keyword">return</span> -ENOMEM;</span><br><span class="line">    &#125;</span><br><span class="line">    vma_set_anonymous(vma);</span><br><span class="line">    vma-&gt;vm_start = addr;</span><br><span class="line">    vma-&gt;vm_end = addr + len;</span><br><span class="line">    vma-&gt;vm_pgoff = pgoff;</span><br><span class="line">    vma-&gt;vm_flags = flags;</span><br><span class="line">    vma-&gt;vm_page_prot = vm_get_page_prot(flags);</span><br><span class="line">    vma_link(mm, vma, prev, rb_link, rb_parent);</span><br><span class="line">out:</span><br><span class="line">    perf_event_mmap(vma);</span><br><span class="line">    mm-&gt;total_vm += len &gt;&gt; PAGE_SHIFT;</span><br><span class="line">    mm-&gt;data_vm += len &gt;&gt; PAGE_SHIFT;</span><br><span class="line">    <span class="keyword">if</span> (flags &amp; VM_LOCKED)</span><br><span class="line">        mm-&gt;locked_vm += (len &gt;&gt; PAGE_SHIFT);</span><br><span class="line">    vma-&gt;vm_flags |= VM_SOFTDIRTY;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="2-2-大内存块申请"><a href="#2-2-大内存块申请" class="headerlink" title="2.2 大内存块申请"></a>2.2 大内存块申请</h3><p>  大块内存的申请通过mmap系统调用实现，mmap既可以实现虚拟内存向物理内存的映射，也可以映射文件到自己的虚拟内存空间。映射文件时，实际是映射虚拟内存到物理内存再到文件。</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">SYSCALL_DEFINE6(mmap, <span class="type">unsigned</span> <span class="type">long</span>, addr, <span class="type">unsigned</span> <span class="type">long</span>, len,</span><br><span class="line">        <span class="type">unsigned</span> <span class="type">long</span>, prot, <span class="type">unsigned</span> <span class="type">long</span>, flags,</span><br><span class="line">        <span class="type">unsigned</span> <span class="type">long</span>, fd, <span class="type">unsigned</span> <span class="type">long</span>, off)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">long</span> error;</span><br><span class="line">    error = -EINVAL;</span><br><span class="line">    <span class="keyword">if</span> (off &amp; ~PAGE_MASK)</span><br><span class="line">        <span class="keyword">goto</span> out;</span><br><span class="line">    error = ksys_mmap_pgoff(addr, len, prot, flags, fd, off &gt;&gt; PAGE_SHIFT);</span><br><span class="line">out:</span><br><span class="line">    <span class="keyword">return</span> error;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>  这里主要调用ksys_mmap_pgoff()函数，这里逻辑如下</p>
<ul>
<li>判断类型是否为匿名映射，如果不是则为文件映射，调用fget()获取文件描述符</li>
<li>如果是匿名映射，判断是否为大页，如果是则进行对齐处理并调用hugetlb_file_setup()获取文件描述符</li>
<li>调用vm_mmap_pgoff()函数找寻可以映射的区域并建立映射</li>
</ul>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">unsigned</span> <span class="type">long</span> <span class="title function_">ksys_mmap_pgoff</span><span class="params">(<span class="type">unsigned</span> <span class="type">long</span> addr, <span class="type">unsigned</span> <span class="type">long</span> len,</span></span><br><span class="line"><span class="params">                  <span class="type">unsigned</span> <span class="type">long</span> prot, <span class="type">unsigned</span> <span class="type">long</span> flags,</span></span><br><span class="line"><span class="params">                  <span class="type">unsigned</span> <span class="type">long</span> fd, <span class="type">unsigned</span> <span class="type">long</span> pgoff)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">file</span> *<span class="title">file</span> =</span> <span class="literal">NULL</span>;</span><br><span class="line">    <span class="type">unsigned</span> <span class="type">long</span> retval;</span><br><span class="line">    <span class="keyword">if</span> (!(flags &amp; MAP_ANONYMOUS)) &#123;</span><br><span class="line">        audit_mmap_fd(fd, flags);</span><br><span class="line">        file = fget(fd);</span><br><span class="line">        <span class="keyword">if</span> (!file)</span><br><span class="line">            <span class="keyword">return</span> -EBADF;</span><br><span class="line">        <span class="keyword">if</span> (is_file_hugepages(file))</span><br><span class="line">            len = ALIGN(len, huge_page_size(hstate_file(file)));</span><br><span class="line">        retval = -EINVAL;</span><br><span class="line">        <span class="keyword">if</span> (unlikely(flags &amp; MAP_HUGETLB &amp;&amp; !is_file_hugepages(file)))</span><br><span class="line">            <span class="keyword">goto</span> out_fput;</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (flags &amp; MAP_HUGETLB) &#123;</span><br><span class="line">        <span class="keyword">struct</span> user_struct *user = <span class="literal">NULL</span>;</span><br><span class="line">        <span class="class"><span class="keyword">struct</span> <span class="title">hstate</span> *<span class="title">hs</span>;</span></span><br><span class="line">        hs = hstate_sizelog((flags &gt;&gt; MAP_HUGE_SHIFT) &amp; MAP_HUGE_MASK);</span><br><span class="line">        <span class="keyword">if</span> (!hs)</span><br><span class="line">            <span class="keyword">return</span> -EINVAL;</span><br><span class="line">        len = ALIGN(len, huge_page_size(hs));</span><br><span class="line">        <span class="comment">/*</span></span><br><span class="line"><span class="comment">         * VM_NORESERVE is used because the reservations will be</span></span><br><span class="line"><span class="comment">         * taken when vm_ops-&gt;mmap() is called</span></span><br><span class="line"><span class="comment">         * A dummy user value is used because we are not locking</span></span><br><span class="line"><span class="comment">         * memory so no accounting is necessary</span></span><br><span class="line"><span class="comment">         */</span></span><br><span class="line">        file = hugetlb_file_setup(HUGETLB_ANON_FILE, len,</span><br><span class="line">                VM_NORESERVE,</span><br><span class="line">                &amp;user, HUGETLB_ANONHUGE_INODE,</span><br><span class="line">                (flags &gt;&gt; MAP_HUGE_SHIFT) &amp; MAP_HUGE_MASK);</span><br><span class="line">        <span class="keyword">if</span> (IS_ERR(file))</span><br><span class="line">            <span class="keyword">return</span> PTR_ERR(file);</span><br><span class="line">    &#125;</span><br><span class="line">    flags &amp;= ~(MAP_EXECUTABLE | MAP_DENYWRITE);</span><br><span class="line">    retval = vm_mmap_pgoff(file, addr, len, prot, flags, pgoff);</span><br><span class="line">out_fput:</span><br><span class="line">    <span class="keyword">if</span> (file)</span><br><span class="line">        fput(file);</span><br><span class="line">    <span class="keyword">return</span> retval;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>  vm_mmap_pgoff()函数调用do_mmap_pgoff()，实际调用do_mmap()函数。这里get_unmapped_area()函数负责寻找可映射的区域，mmap_region()负责映射该区域。</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * The caller must hold down_write(&amp;current-&gt;mm-&gt;mmap_sem).</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="type">unsigned</span> <span class="type">long</span> <span class="title function_">do_mmap</span><span class="params">(<span class="keyword">struct</span> file *file, <span class="type">unsigned</span> <span class="type">long</span> addr,</span></span><br><span class="line"><span class="params">            <span class="type">unsigned</span> <span class="type">long</span> len, <span class="type">unsigned</span> <span class="type">long</span> prot,</span></span><br><span class="line"><span class="params">            <span class="type">unsigned</span> <span class="type">long</span> flags, <span class="type">vm_flags_t</span> vm_flags,</span></span><br><span class="line"><span class="params">            <span class="type">unsigned</span> <span class="type">long</span> pgoff, <span class="type">unsigned</span> <span class="type">long</span> *populate,</span></span><br><span class="line"><span class="params">            <span class="keyword">struct</span> list_head *uf)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">mm_struct</span> *<span class="title">mm</span> =</span> current-&gt;mm;</span><br><span class="line">    <span class="type">int</span> pkey = <span class="number">0</span>;</span><br><span class="line">    *populate = <span class="number">0</span>;</span><br><span class="line">......</span><br><span class="line">    <span class="comment">/* Obtain the address to map to. we verify (or select) it and ensure</span></span><br><span class="line"><span class="comment">     * that it represents a valid section of the address space.</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    addr = get_unmapped_area(file, addr, len, pgoff, flags);</span><br><span class="line">......</span><br><span class="line">    addr = mmap_region(file, addr, len, vm_flags, pgoff, uf);</span><br><span class="line">    <span class="keyword">if</span> (!IS_ERR_VALUE(addr) &amp;&amp;</span><br><span class="line">        ((vm_flags &amp; VM_LOCKED) ||</span><br><span class="line">         (flags &amp; (MAP_POPULATE | MAP_NONBLOCK)) == MAP_POPULATE))</span><br><span class="line">        *populate = len;</span><br><span class="line">    <span class="keyword">return</span> addr;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>  首先来看看寻找映射区的函数get_unmapped_area()。</p>
<ul>
<li>如果是匿名映射，则调用get_umapped_area函数指针，这个函数其实是 arch_get_unmapped_area()。它会调用 find_vma_prev()，在表示虚拟内存区域的 vm_area_struct 红黑树上找到相应的位置。之所以叫 prev，是说这个时候虚拟内存区域还没有建立，找到前一个 vm_area_struct。</li>
<li>如果是映射到一个文件，在 Linux 里面每个打开的文件都有一个 struct file 结构，里面有一个 file_operations用来表示和这个文件相关的操作。如果是我们熟知的 ext4 文件系统，调用的也是get_unmapped_area 函数指针。</li>
</ul>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">unsigned</span> <span class="type">long</span></span><br><span class="line"><span class="title function_">get_unmapped_area</span><span class="params">(<span class="keyword">struct</span> file *file, <span class="type">unsigned</span> <span class="type">long</span> addr, <span class="type">unsigned</span> <span class="type">long</span> len,</span></span><br><span class="line"><span class="params">        <span class="type">unsigned</span> <span class="type">long</span> pgoff, <span class="type">unsigned</span> <span class="type">long</span> flags)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">unsigned</span> <span class="title function_">long</span> <span class="params">(*get_area)</span><span class="params">(<span class="keyword">struct</span> file *, <span class="type">unsigned</span> <span class="type">long</span>,</span></span><br><span class="line"><span class="params">                  <span class="type">unsigned</span> <span class="type">long</span>, <span class="type">unsigned</span> <span class="type">long</span>, <span class="type">unsigned</span> <span class="type">long</span>)</span>;</span><br><span class="line">    <span class="type">unsigned</span> <span class="type">long</span> error = arch_mmap_check(addr, len, flags);</span><br><span class="line">    <span class="keyword">if</span> (error)</span><br><span class="line">        <span class="keyword">return</span> error;</span><br><span class="line">    <span class="comment">/* Careful about overflows.. */</span></span><br><span class="line">    <span class="keyword">if</span> (len &gt; TASK_SIZE)</span><br><span class="line">        <span class="keyword">return</span> -ENOMEM;</span><br><span class="line">    get_area = current-&gt;mm-&gt;get_unmapped_area;</span><br><span class="line">    <span class="keyword">if</span> (file) &#123;</span><br><span class="line">        <span class="keyword">if</span> (file-&gt;f_op-&gt;get_unmapped_area)</span><br><span class="line">            get_area = file-&gt;f_op-&gt;get_unmapped_area;</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (flags &amp; MAP_SHARED) &#123;</span><br><span class="line">        <span class="comment">/*</span></span><br><span class="line"><span class="comment">         * mmap_region() will call shmem_zero_setup() to create a file,</span></span><br><span class="line"><span class="comment">         * so use shmem&#x27;s get_unmapped_area in case it can be huge.</span></span><br><span class="line"><span class="comment">         * do_mmap_pgoff() will clear pgoff, so match alignment.</span></span><br><span class="line"><span class="comment">         */</span></span><br><span class="line">        pgoff = <span class="number">0</span>;</span><br><span class="line">        get_area = shmem_get_unmapped_area;</span><br><span class="line">    &#125;</span><br><span class="line">    addr = get_area(file, addr, len, pgoff, flags);</span><br><span class="line">    <span class="keyword">if</span> (IS_ERR_VALUE(addr))</span><br><span class="line">        <span class="keyword">return</span> addr;</span><br><span class="line">    <span class="keyword">if</span> (addr &gt; TASK_SIZE - len)</span><br><span class="line">        <span class="keyword">return</span> -ENOMEM;</span><br><span class="line">    <span class="keyword">if</span> (offset_in_page(addr))</span><br><span class="line">        <span class="keyword">return</span> -EINVAL;</span><br><span class="line">    error = security_mmap_addr(addr);</span><br><span class="line">    <span class="keyword">return</span> error ? error : addr;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>  mmap_region()首先会再次检测地址空间是否满足要求，然后清除旧的映射，校验内存的可用性，在一切均满足的情况下调用vma_link()将新创建的vm_area_struct结构挂在mm_struct内的红黑树上。</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">unsigned</span> <span class="type">long</span> <span class="title function_">mmap_region</span><span class="params">(<span class="keyword">struct</span> file *file, <span class="type">unsigned</span> <span class="type">long</span> addr,</span></span><br><span class="line"><span class="params">        <span class="type">unsigned</span> <span class="type">long</span> len, <span class="type">vm_flags_t</span> vm_flags, <span class="type">unsigned</span> <span class="type">long</span> pgoff,</span></span><br><span class="line"><span class="params">        <span class="keyword">struct</span> list_head *uf)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">mm_struct</span> *<span class="title">mm</span> =</span> current-&gt;mm;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">vm_area_struct</span> *<span class="title">vma</span>, *<span class="title">prev</span>;</span></span><br><span class="line">    <span class="type">int</span> error;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">rb_node</span> **<span class="title">rb_link</span>, *<span class="title">rb_parent</span>;</span></span><br><span class="line">    <span class="type">unsigned</span> <span class="type">long</span> charged = <span class="number">0</span>;</span><br><span class="line">......</span><br><span class="line">    vma_link(mm, vma, prev, rb_link, rb_parent);</span><br><span class="line">    <span class="comment">/* Once vma denies write, undo our temporary denial count */</span></span><br><span class="line">    <span class="keyword">if</span> (file) &#123;</span><br><span class="line">        <span class="keyword">if</span> (vm_flags &amp; VM_SHARED)</span><br><span class="line">            mapping_unmap_writable(file-&gt;f_mapping);</span><br><span class="line">        <span class="keyword">if</span> (vm_flags &amp; VM_DENYWRITE)</span><br><span class="line">            allow_write_access(file);</span><br><span class="line">    &#125;</span><br><span class="line">    file = vma-&gt;vm_file;</span><br><span class="line">......</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>  vma_link()本身是__vma_link()和__vma_link_file()的包裹函数</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">static</span> <span class="type">void</span> <span class="title function_">vma_link</span><span class="params">(<span class="keyword">struct</span> mm_struct *mm, <span class="keyword">struct</span> vm_area_struct *vma,</span></span><br><span class="line"><span class="params">            <span class="keyword">struct</span> vm_area_struct *prev, <span class="keyword">struct</span> rb_node **rb_link,</span></span><br><span class="line"><span class="params">            <span class="keyword">struct</span> rb_node *rb_parent)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">address_space</span> *<span class="title">mapping</span> =</span> <span class="literal">NULL</span>;</span><br><span class="line">    <span class="keyword">if</span> (vma-&gt;vm_file) &#123;</span><br><span class="line">        mapping = vma-&gt;vm_file-&gt;f_mapping;</span><br><span class="line">        i_mmap_lock_write(mapping);</span><br><span class="line">    &#125;</span><br><span class="line">    __vma_link(mm, vma, prev, rb_link, rb_parent);</span><br><span class="line">    __vma_link_file(vma);</span><br><span class="line">    <span class="keyword">if</span> (mapping)</span><br><span class="line">        i_mmap_unlock_write(mapping);</span><br><span class="line">    mm-&gt;map_count++;</span><br><span class="line">    validate_mm(mm);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>  其中__vma_link()主要是链表和红黑表的插入，这属于基本数据结构操作，不展开讲解。</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">static</span> <span class="type">void</span></span><br><span class="line">__vma_link(<span class="keyword">struct</span> mm_struct *mm, <span class="keyword">struct</span> vm_area_struct *vma,</span><br><span class="line">    <span class="keyword">struct</span> vm_area_struct *prev, <span class="keyword">struct</span> rb_node **rb_link,</span><br><span class="line">    <span class="keyword">struct</span> rb_node *rb_parent)</span><br><span class="line">&#123;</span><br><span class="line">    __vma_link_list(mm, vma, prev, rb_parent);</span><br><span class="line">    __vma_link_rb(mm, vma, rb_link, rb_parent);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>  而__vma_link_file()会对文件映射进行处理，在file结构体中成员f_mapping指向address_space结构体，该结构体中存储红黑树i_mmap挂载vm_area_struct。</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">static</span> <span class="type">void</span> __vma_link_file(<span class="keyword">struct</span> vm_area_struct *vma)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">file</span> *<span class="title">file</span>;</span></span><br><span class="line">    file = vma-&gt;vm_file;</span><br><span class="line">    <span class="keyword">if</span> (file) &#123;</span><br><span class="line">        <span class="class"><span class="keyword">struct</span> <span class="title">address_space</span> *<span class="title">mapping</span> =</span> file-&gt;f_mapping;</span><br><span class="line">        <span class="keyword">if</span> (vma-&gt;vm_flags &amp; VM_DENYWRITE)</span><br><span class="line">            <span class="type">atomic_dec</span>(&amp;file_inode(file)-&gt;i_writecount);</span><br><span class="line">        <span class="keyword">if</span> (vma-&gt;vm_flags &amp; VM_SHARED)</span><br><span class="line">            <span class="type">atomic_inc</span>(&amp;mapping-&gt;i_mmap_writable);</span><br><span class="line">        flush_dcache_mmap_lock(mapping);</span><br><span class="line">        vma_interval_tree_insert(vma, &amp;mapping-&gt;i_mmap);</span><br><span class="line">        flush_dcache_mmap_unlock(mapping);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>  至此，我们完成了用户态内存的映射，但是此处仅在虚拟内存中建立了新的区域，尚未真正访问物理内存。物理内存的访问只有在调度到该进程时才会真正分配，即发生缺页异常时分配。</p>
<p>三. 用户态缺页异常<br>  一旦开始访问虚拟内存的某个地址，如果我们发现，并没有对应的物理页，那就触发缺页中断，调用 do_page_fault()。这里的逻辑如下</p>
<ul>
<li>判断是否为内核缺页中断fault_in_kernel_space()，如果是则调用vmalloc_fault()</li>
<li>如果是用户态缺页异常，则调用find_vma()找到地址所在vm_area_struct区域</li>
<li>调用handle_mm_fault()映射找到的区域</li>
</ul>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * This routine handles page faults.  It determines the address,</span></span><br><span class="line"><span class="comment"> * and the problem, and then passes it off to one of the appropriate</span></span><br><span class="line"><span class="comment"> * routines.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line">asmlinkage <span class="type">void</span> __kprobes <span class="title function_">do_page_fault</span><span class="params">(<span class="keyword">struct</span> pt_regs *regs,</span></span><br><span class="line"><span class="params">                    <span class="type">unsigned</span> <span class="type">long</span> error_code,</span></span><br><span class="line"><span class="params">                    <span class="type">unsigned</span> <span class="type">long</span> address)</span></span><br><span class="line">&#123;</span><br><span class="line">......</span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">     * We fault-in kernel-space virtual memory on-demand. The</span></span><br><span class="line"><span class="comment">     * &#x27;reference&#x27; page table is init_mm.pgd.</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * NOTE! We MUST NOT take any locks for this case. We may</span></span><br><span class="line"><span class="comment">     * be in an interrupt or a critical region, and should</span></span><br><span class="line"><span class="comment">     * only copy the information from the master page table,</span></span><br><span class="line"><span class="comment">     * nothing more.</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">if</span> (unlikely(fault_in_kernel_space(address))) &#123;</span><br><span class="line">        <span class="keyword">if</span> (vmalloc_fault(address) &gt;= <span class="number">0</span>)</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        <span class="keyword">if</span> (notify_page_fault(regs, vec))</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        bad_area_nosemaphore(regs, error_code, address);</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">......</span><br><span class="line">    vma = find_vma(mm, address);</span><br><span class="line">......</span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">     * If for any reason at all we couldn&#x27;t handle the fault,</span></span><br><span class="line"><span class="comment">     * make sure we exit gracefully rather than endlessly redo</span></span><br><span class="line"><span class="comment">     * the fault.</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    fault = handle_mm_fault(vma, address, flags);</span><br><span class="line">......</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>  find_vma()为红黑树查找操作，在此不做展开描述，下面重点看看handle_mm_fault()。这里经过一系列校验之后会根据是否是大页而选择调用hugetlb_fault()或者__handle_mm_fault()</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">vm_fault_t</span> <span class="title function_">handle_mm_fault</span><span class="params">(<span class="keyword">struct</span> vm_area_struct *vma, <span class="type">unsigned</span> <span class="type">long</span> address,</span></span><br><span class="line"><span class="params">        <span class="type">unsigned</span> <span class="type">int</span> flags)</span></span><br><span class="line">&#123;</span><br><span class="line">......</span><br><span class="line">    <span class="keyword">if</span> (unlikely(is_vm_hugetlb_page(vma)))</span><br><span class="line">        ret = hugetlb_fault(vma-&gt;vm_mm, vma, address, flags);</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">        ret = __handle_mm_fault(vma, address, flags);</span><br><span class="line">......</span><br><span class="line">    <span class="keyword">return</span> ret;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>  __handle_mm_fault()完成实际上的映射操作。这里涉及到了由pgd, p4g, pud, pmd, pte组成的五级页表，页表索引填充完后调用handle_pte_fault()创建页表项。</p>
<p><img src="https://user-images.githubusercontent.com/87457873/128139607-d716fd28-4700-424c-815c-d7480f8a16cd.png" alt="image"></p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">tatic <span class="type">vm_fault_t</span> __handle_mm_fault(<span class="keyword">struct</span> vm_area_struct *vma,</span><br><span class="line">        <span class="type">unsigned</span> <span class="type">long</span> address, <span class="type">unsigned</span> <span class="type">int</span> flags)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">vm_fault</span> <span class="title">vmf</span> =</span> &#123;</span><br><span class="line">        .vma = vma,</span><br><span class="line">        .address = address &amp; PAGE_MASK,</span><br><span class="line">        .flags = flags,</span><br><span class="line">        .pgoff = linear_page_index(vma, address),</span><br><span class="line">        .gfp_mask = __get_fault_gfp_mask(vma),</span><br><span class="line">    &#125;;</span><br><span class="line">    <span class="type">unsigned</span> <span class="type">int</span> dirty = flags &amp; FAULT_FLAG_WRITE;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">mm_struct</span> *<span class="title">mm</span> =</span> vma-&gt;vm_mm;</span><br><span class="line">    <span class="type">pgd_t</span> *pgd;</span><br><span class="line">    <span class="type">p4d_t</span> *p4d;</span><br><span class="line">    <span class="type">vm_fault_t</span> ret;</span><br><span class="line">    pgd = pgd_offset(mm, address);</span><br><span class="line">    p4d = p4d_alloc(mm, pgd, address);</span><br><span class="line">......</span><br><span class="line">    vmf.pud = pud_alloc(mm, p4d, address);</span><br><span class="line">......</span><br><span class="line">    vmf.pmd = pmd_alloc(mm, vmf.pud, address);</span><br><span class="line">......</span><br><span class="line">    <span class="keyword">return</span> handle_pte_fault(&amp;vmf);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>  handle_pte_fault()处理以下三种情况</p>
<ul>
<li>页表项从未出现过，即新映射页表项<ul>
<li>匿名页映射，则映射到物理内存页，调用do_anonymous_page()</li>
<li>文件映射，调用do_fault()</li>
</ul>
</li>
<li>页表项曾出现过，则为从物理内存换出的页，调用do_swap_page()换回来</li>
</ul>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * These routines also need to handle stuff like marking pages dirty</span></span><br><span class="line"><span class="comment"> * and/or accessed for architectures that don&#x27;t do it in hardware (most</span></span><br><span class="line"><span class="comment"> * RISC architectures).  The early dirtying is also good on the i386.</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * There is also a hook called &quot;update_mmu_cache()&quot; that architectures</span></span><br><span class="line"><span class="comment"> * with external mmu caches can use to update those (ie the Sparc or</span></span><br><span class="line"><span class="comment"> * PowerPC hashed page tables that act as extended TLBs).</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * We enter with non-exclusive mmap_sem (to exclude vma changes, but allow</span></span><br><span class="line"><span class="comment"> * concurrent faults).</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * The mmap_sem may have been released depending on flags and our return value.</span></span><br><span class="line"><span class="comment"> * See filemap_fault() and __lock_page_or_retry().</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="type">static</span> <span class="type">vm_fault_t</span> <span class="title function_">handle_pte_fault</span><span class="params">(<span class="keyword">struct</span> vm_fault *vmf)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">pte_t</span> entry;</span><br><span class="line">......</span><br><span class="line">        <span class="comment">/*</span></span><br><span class="line"><span class="comment">         * A regular pmd is established and it can&#x27;t morph into a huge</span></span><br><span class="line"><span class="comment">         * pmd from under us anymore at this point because we hold the</span></span><br><span class="line"><span class="comment">         * mmap_sem read mode and khugepaged takes it in write mode.</span></span><br><span class="line"><span class="comment">         * So now it&#x27;s safe to run pte_offset_map().</span></span><br><span class="line"><span class="comment">         */</span></span><br><span class="line">        vmf-&gt;pte = pte_offset_map(vmf-&gt;pmd, vmf-&gt;address);</span><br><span class="line">        vmf-&gt;orig_pte = *vmf-&gt;pte;</span><br><span class="line">......</span><br><span class="line">    <span class="keyword">if</span> (!vmf-&gt;pte) &#123;</span><br><span class="line">        <span class="keyword">if</span> (vma_is_anonymous(vmf-&gt;vma))</span><br><span class="line">            <span class="keyword">return</span> do_anonymous_page(vmf);</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">            <span class="keyword">return</span> do_fault(vmf);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (!pte_present(vmf-&gt;orig_pte))</span><br><span class="line">        <span class="keyword">return</span> do_swap_page(vmf);</span><br><span class="line">......</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="3-1-匿名页映射"><a href="#3-1-匿名页映射" class="headerlink" title="3.1 匿名页映射"></a>3.1 匿名页映射</h3><p>  对于匿名页映射，流程如下</p>
<ul>
<li>调用pte_alloc()分配页表项</li>
<li>通过 alloc_zeroed_user_highpage_movable() 分配一个页，该函数会调用 alloc_pages_vma()，并最终调用 __alloc_pages_nodemask()。该函数是伙伴系统的核心函数，用于分配物理页面，在上文中已经详细分析过了。</li>
<li>调用mk_pte()将新分配的页表项指向分配的页</li>
<li>调用set_pte_at()将页表项加入该页</li>
</ul>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * We enter with non-exclusive mmap_sem (to exclude vma changes,</span></span><br><span class="line"><span class="comment"> * but allow concurrent faults), and pte mapped but not yet locked.</span></span><br><span class="line"><span class="comment"> * We return with mmap_sem still held, but pte unmapped and unlocked.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="type">static</span> <span class="type">vm_fault_t</span> <span class="title function_">do_anonymous_page</span><span class="params">(<span class="keyword">struct</span> vm_fault *vmf)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">vm_area_struct</span> *<span class="title">vma</span> =</span> vmf-&gt;vma;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">mem_cgroup</span> *<span class="title">memcg</span>;</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">page</span> *<span class="title">page</span>;</span></span><br><span class="line">    <span class="type">vm_fault_t</span> ret = <span class="number">0</span>;</span><br><span class="line">    <span class="type">pte_t</span> entry;</span><br><span class="line">......</span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">     * Use pte_alloc() instead of pte_alloc_map().  We can&#x27;t run</span></span><br><span class="line"><span class="comment">     * pte_offset_map() on pmds where a huge pmd might be created</span></span><br><span class="line"><span class="comment">     * from a different thread.</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * pte_alloc_map() is safe to use under down_write(mmap_sem) or when</span></span><br><span class="line"><span class="comment">     * parallel threads are excluded by other means.</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * Here we only have down_read(mmap_sem).</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">if</span> (pte_alloc(vma-&gt;vm_mm, vmf-&gt;pmd))</span><br><span class="line">        <span class="keyword">return</span> VM_FAULT_OOM;</span><br><span class="line">......</span><br><span class="line">    page = alloc_zeroed_user_highpage_movable(vma, vmf-&gt;address);</span><br><span class="line">......</span><br><span class="line">    entry = mk_pte(page, vma-&gt;vm_page_prot);</span><br><span class="line">    <span class="keyword">if</span> (vma-&gt;vm_flags &amp; VM_WRITE)</span><br><span class="line">        entry = pte_mkwrite(pte_mkdirty(entry));</span><br><span class="line">    vmf-&gt;pte = pte_offset_map_lock(vma-&gt;vm_mm, vmf-&gt;pmd, vmf-&gt;address,</span><br><span class="line">            &amp;vmf-&gt;ptl);</span><br><span class="line">......</span><br><span class="line">    set_pte_at(vma-&gt;vm_mm, vmf-&gt;address, vmf-&gt;pte, entry);</span><br><span class="line">......</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> __alloc_zeroed_user_highpage(movableflags, vma, vaddr) \</span></span><br><span class="line"><span class="meta">    alloc_page_vma(GFP_HIGHUSER | __GFP_ZERO | movableflags, vma, vaddr)</span></span><br></pre></td></tr></table></figure>
<h3 id="3-2-文件映射"><a href="#3-2-文件映射" class="headerlink" title="3.2 文件映射"></a>3.2 文件映射</h3><p>  映射文件do_fault()函数调用了fault函数，该函数实际会根据不同的文件系统调用不同的函数，如ext4文件系统中vm_ops指向ext4_file_vm_ops，实际调用ext4_filemap_fault()函数，该函数会调用filemap_fault()完成实际的文件映射操作。</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">static</span> <span class="type">vm_fault_t</span> <span class="title function_">do_fault</span><span class="params">(<span class="keyword">struct</span> vm_fault *vmf)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">vm_area_struct</span> *<span class="title">vma</span> =</span> vmf-&gt;vma;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">mm_struct</span> *<span class="title">vm_mm</span> =</span> vma-&gt;vm_mm;</span><br><span class="line">    <span class="type">vm_fault_t</span> ret;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (!vma-&gt;vm_ops-&gt;fault) &#123;</span><br><span class="line">......</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">vm_fault_t</span> <span class="title function_">ext4_filemap_fault</span><span class="params">(<span class="keyword">struct</span> vm_fault *vmf)</span></span><br><span class="line">&#123;</span><br><span class="line">......</span><br><span class="line">    ret = filemap_fault(vmf);</span><br><span class="line">......</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>file_map_fault()主要逻辑为</p>
<ul>
<li>调用find_ge_page()找到映射文件vm_file对应的物理内存缓存页面</li>
<li>如果找到了，则调用do_async_mmap_readahead()，预读一些数据到内存里面</li>
<li>否则调用pagecache_get_page()分配一个缓存页，将该页加入LRU表中，并在address_space中调用<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">vm_fault_t</span> <span class="title function_">filemap_fault</span><span class="params">(<span class="keyword">struct</span> vm_fault *vmf)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">int</span> error;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">file</span> *<span class="title">file</span> =</span> vmf-&gt;vma-&gt;vm_file;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">file</span> *<span class="title">fpin</span> =</span> <span class="literal">NULL</span>;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">address_space</span> *<span class="title">mapping</span> =</span> file-&gt;f_mapping;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">file_ra_state</span> *<span class="title">ra</span> =</span> &amp;file-&gt;f_ra;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">inode</span> *<span class="title">inode</span> =</span> mapping-&gt;host;</span><br><span class="line">......</span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">     * Do we have something in the page cache already?</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    page = find_get_page(mapping, offset);</span><br><span class="line">    <span class="keyword">if</span> (likely(page) &amp;&amp; !(vmf-&gt;flags &amp; FAULT_FLAG_TRIED)) &#123;</span><br><span class="line">        <span class="comment">/*</span></span><br><span class="line"><span class="comment">         * We found the page, so try async readahead before</span></span><br><span class="line"><span class="comment">         * waiting for the lock.</span></span><br><span class="line"><span class="comment">         */</span></span><br><span class="line">        fpin = do_async_mmap_readahead(vmf, page);</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (!page) &#123;</span><br><span class="line">        <span class="comment">/* No page in the page cache at all */</span></span><br><span class="line">......       </span><br><span class="line">&#125;</span><br><span class="line">    </span><br><span class="line"><span class="keyword">struct</span> page *pagecache_get_page(<span class="keyword">struct</span> address_space *mapping, <span class="type">pgoff_t</span> offset,</span><br><span class="line">    <span class="type">int</span> fgp_flags, <span class="type">gfp_t</span> gfp_mask)</span><br><span class="line">&#123;</span><br><span class="line">......</span><br><span class="line">        page = __page_cache_alloc(gfp_mask);</span><br><span class="line">......</span><br><span class="line">        err = add_to_page_cache_lru(page, mapping, offset, gfp_mask);</span><br><span class="line">......</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
</ul>
<h3 id="3-3-页交换"><a href="#3-3-页交换" class="headerlink" title="3.3 页交换"></a>3.3 页交换</h3><p>  前文提到了我们会通过主动回收或者被动回收的方式将物理内存已映射的页面回收至硬盘中，当数据再次访问时，我们又需要通过do_swap_page()将其从硬盘中读回来。do_swap_page() 函数逻辑流程如下：查找 swap 文件有没有缓存页。如果没有，就调用 swapin_readahead()将 swap 文件读到内存中来形成内存页，并通过 mk_pte() 生成页表项。set_pte_at 将页表项插入页表，swap_free 将 swap 文件清理。因为重新加载回内存了，不再需要 swap 文件了。</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">vm_fault_t</span> <span class="title function_">do_swap_page</span><span class="params">(<span class="keyword">struct</span> vm_fault *vmf)</span></span><br><span class="line">&#123;</span><br><span class="line">......</span><br><span class="line">    entry = pte_to_swp_entry(vmf-&gt;orig_pte);</span><br><span class="line">......</span><br><span class="line">    page = lookup_swap_cache(entry, vma, vmf-&gt;address);</span><br><span class="line">    swapcache = page;</span><br><span class="line">    <span class="keyword">if</span> (!page) &#123;</span><br><span class="line">        <span class="class"><span class="keyword">struct</span> <span class="title">swap_info_struct</span> *<span class="title">si</span> =</span> swp_swap_info(entry);</span><br><span class="line">        <span class="keyword">if</span> (si-&gt;flags &amp; SWP_SYNCHRONOUS_IO &amp;&amp;</span><br><span class="line">                __swap_count(si, entry) == <span class="number">1</span>) &#123;</span><br><span class="line">            <span class="comment">/* skip swapcache */</span></span><br><span class="line">            page = alloc_page_vma(GFP_HIGHUSER_MOVABLE, vma,</span><br><span class="line">                            vmf-&gt;address);</span><br><span class="line">......</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            page = swapin_readahead(entry, GFP_HIGHUSER_MOVABLE,</span><br><span class="line">                        vmf);</span><br><span class="line">            swapcache = page;</span><br><span class="line">        &#125;</span><br><span class="line">......</span><br><span class="line">    pte = mk_pte(page, vma-&gt;vm_page_prot);</span><br><span class="line">......</span><br><span class="line">    set_pte_at(vma-&gt;vm_mm, vmf-&gt;address, vmf-&gt;pte, pte);</span><br><span class="line">    arch_do_swap_page(vma-&gt;vm_mm, vma, vmf-&gt;address, pte, vmf-&gt;orig_pte);</span><br><span class="line">    vmf-&gt;orig_pte = pte;</span><br><span class="line">......</span><br><span class="line">    swap_free(entry);</span><br><span class="line">......</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>  通过以上步骤，用户态的缺页异常就处理完毕了。物理内存中有了页面，页表也建立好了映射。接下来，用户程序在虚拟内存空间里面可以通过虚拟地址顺利经过页表映射的访问物理页面上的数据了。页表一般都很大，只能存放在内存中。操作系统每次访问内存都要折腾两步，先通过查询页表得到物理地址，然后访问该物理地址读取指令、数据。为了加快映射速度，我们引入了 TLB（Translation Lookaside Buffer），我们经常称为快表，专门用来做地址映射的硬件设备。它不在内存中，可存储的数据比较少，但是比内存要快。所以我们可以想象，TLB 就是页表的 Cache，其中存储了当前最可能被访问到的页表项，其内容是部分页表项的一个副本。有了 TLB 之后，我们先查块表，块表中有映射关系，然后直接转换为物理地址。如果在 TLB 查不到映射关系时，才会到内存中查询页表。</p>
<h2 id="四-内核态内存映射及缺页异常"><a href="#四-内核态内存映射及缺页异常" class="headerlink" title="四. 内核态内存映射及缺页异常"></a>四. 内核态内存映射及缺页异常</h2><p>  和用户态使用malloc()类似，内核态也有相应的内存映射函数：vmalloc()可用于分配不连续物理页（使用伙伴系统），kmem_cache_alloc()和kmem_cache_create()使用slub分配器分配小块内存，而kmalloc()类似于malloc()，在分配大内存的时候会使用伙伴系统，分配小内存则使用slub分配器。分配内存后会转换为虚拟地址，保存在内核页表中进行映射，有需要时直接访问。由于vmalloc()会带来虚拟连续页和物理不连续页的映射，因此一般速度较慢，使用较少，相比而言kmalloc()使用的更为频繁。而kmem_cache_alloc()和kmem_cache_create()会分配更为精准的小内存块用于特定任务，因此也比较常用。</p>
<p>  相对于用户态，内核态还有一种特殊的映射：临时映射。内核态高端内存地区为了节省空间会选择临时映射，采用kmap_atomic()实现。如果是 32 位有高端地址的，就需要调用 set_pte 通过内核页表进行临时映射；如果是 64 位没有高端地址的，就调用 page_address，里面会调用 lowmem_page_address。其实低端内存的映射，会直接使用 __va 进行临时映射。</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">void</span> *<span class="title function_">kmap_atomic_prot</span><span class="params">(<span class="keyword">struct</span> page *page, <span class="type">pgprot_t</span> prot)</span></span><br><span class="line">&#123;</span><br><span class="line">......</span><br><span class="line">    <span class="keyword">if</span> (!PageHighMem(page))</span><br><span class="line">        <span class="keyword">return</span> page_address(page);</span><br><span class="line">......</span><br><span class="line">    vaddr = __fix_to_virt(FIX_KMAP_BEGIN + idx);</span><br><span class="line">    set_pte(kmap_pte-idx, mk_pte(page, prot));</span><br><span class="line">......</span><br><span class="line">    <span class="keyword">return</span> (<span class="type">void</span> *)vaddr;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> *<span class="title function_">kmap_atomic</span><span class="params">(<span class="keyword">struct</span> page *page)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">return</span> kmap_atomic_prot(page, kmap_prot);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">static</span> __always_inline <span class="type">void</span> *<span class="title function_">lowmem_page_address</span><span class="params">(<span class="type">const</span> <span class="keyword">struct</span> page *page)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">return</span> page_to_virt(page);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> page_to_virt(x)  __va(PFN_PHYS(page_to_pfn(x)</span></span><br></pre></td></tr></table></figure>
<p>  kmap_atomic ()发现没有页表的时候会直接创建页表进行映射。而 vmalloc ()只分配了内核的虚拟地址。所以访问它的时候，会产生缺页异常。内核态的缺页异常还是会调用 do_page_fault()，最终进入vmalloc_fault()。在这里会实现内核页表项的关联操作，从而完成分配，整体流程和用户态相似。</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">static</span> noinline <span class="type">int</span> <span class="title function_">vmalloc_fault</span><span class="params">(<span class="type">unsigned</span> <span class="type">long</span> address)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">unsigned</span> <span class="type">long</span> pgd_paddr;</span><br><span class="line">    <span class="type">pmd_t</span> *pmd_k;</span><br><span class="line">    <span class="type">pte_t</span> *pte_k;</span><br><span class="line">    <span class="comment">/* Make sure we are in vmalloc area: */</span></span><br><span class="line">    <span class="keyword">if</span> (!(address &gt;= VMALLOC_START &amp;&amp; address &lt; VMALLOC_END))</span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">     * Synchronize this task&#x27;s top level page-table</span></span><br><span class="line"><span class="comment">     * with the &#x27;reference&#x27; page table.</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * Do _not_ use &quot;current&quot; here. We might be inside</span></span><br><span class="line"><span class="comment">     * an interrupt in the middle of a task switch..</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    pgd_paddr = read_cr3_pa();</span><br><span class="line">    pmd_k = vmalloc_sync_one(__va(pgd_paddr), address);</span><br><span class="line">    <span class="keyword">if</span> (!pmd_k)</span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line"></span><br><span class="line">    pte_k = pte_offset_kernel(pmd_k, address);</span><br><span class="line">    <span class="keyword">if</span> (!pte_present(*pte_k))</span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="五-总结"><a href="#五-总结" class="headerlink" title="五. 总结"></a>五. 总结</h2><p>  至此，我们分析了内存物理地址和虚拟地址的映射关系，结合前文页的分配和管理，内存部分的主要功能就算是大致分析清楚了，最后引用极客时间中的一幅图作为总结，算是全部知识点的汇总。</p>
<p><img src="https://user-images.githubusercontent.com/87457873/128139664-95d440a8-a12f-434d-ab5d-5300e30d792f.png" alt="image"></p>
<h2 id="代码资料"><a href="#代码资料" class="headerlink" title="代码资料"></a>代码资料</h2><p>1、<a href="https://code.woboq.org/linux/linux/mm/mmap.c.html#191">brk</a></p>
<p>2、<a href="https://code.woboq.org/linux/linux/mm/mmap.c.html#ksys_mmap_pgoff">mmap</a></p>
<p>3、<a href="https://code.woboq.org/linux/linux/arch/sh/mm/fault.c.html#do_page_fault">page_fault</a></p>
]]></content>
      <categories>
        <category>linux-doc 内存管理</category>
      </categories>
      <tags>
        <tag>Linux</tag>
      </tags>
  </entry>
  <entry>
    <title>内存管理之分页</title>
    <url>/2023/01/15/linux-docs/%E5%86%85%E5%AD%98%E7%AE%A1%E7%90%86/%E5%86%85%E5%AD%98%E7%AE%A1%E7%90%86%E4%B9%8B%E5%88%86%E9%A1%B5/</url>
    <content><![CDATA[<h2 id="一-前言"><a href="#一-前言" class="headerlink" title="一. 前言"></a>一. 前言</h2><p>  上文分析了内存再用户态的结构体mm_struct及各个区域映射的vm_area_struct以及32位和64位的内核态结构体，本文将基于这些结构来分析Linux的内存管理系统。内存管理系统包括虚拟内存和物理内存的分页以及虚拟内存和物理内存的映射。本文将介绍分页机制，而映射则在下文中说明。本文首先简单介绍SMP和NUMA系统，然后对物理内存的节点、区域、页结构进行分析，在此基础上剖析伙伴系统和Slub Allocator的实现原理，最后介绍页面交换。</p>
<h2 id="二-内存模型"><a href="#二-内存模型" class="headerlink" title="二. 内存模型"></a>二. 内存模型</h2><p>  在计算机的发展历程中，内存模型经历了平坦内存模型、SMP和NUMA三种架构。</p>
<ul>
<li>平坦内存模型(Flat Memory Model)，又称线性内存模型，在这种模式下，采取连续的物理地址和页，所以非常容易根据地址获取页号，反之亦然。此种布局非常简单，而且是线性增长，利于使用。但是随着内存需求的增大、进程数的变多、为了安全考虑，这种模型渐渐地无法满足要求。</li>
<li>对称多处理 SMP(Symmetric MultiProcessing)，是一种多处理器的电脑硬件架构，在对称多处理架构下，每个处理器的地位都是平等的，对资源的使用权限相同。现代多数的多处理器系统都采用对称多处理架构。在这个系统中，拥有超过一个以上的处理器，这些处理器都连接到同一个共享的主存上，并由单一操作系统来控制。在对称多处理系统上，在操作系统的支持下，无论进程是处于用户空间，或是内核态，都可以分配到任何一个处理器上运行。因此，进程可以在不同的处理器间移动，达到负载平衡，使系统的效率提升。</li>
<li>非均衡访存模型 NUMA(Non-Uniform Memory Access)。在这种模式下，内存不是一整块。每个 CPU 都有自己的本地内存，CPU 访问本地内存不用过总线，因而速度要快很多，每个 CPU 和内存在一起，称为一个 NUMA 节点。但是，在本地内存不足的情况下，每个 CPU 都可以去另外的 NUMA 节点申请内存，这个时候访问延时就会比较长。</li>
</ul>
<p><img src="https://user-images.githubusercontent.com/87457873/128138153-fce61fa0-babc-41b5-8670-a255ba315b71.png" alt="image"></p>
<h2 id="三-节点、区域和页"><a href="#三-节点、区域和页" class="headerlink" title="三. 节点、区域和页"></a>三. 节点、区域和页</h2><h3 id="3-1-节点"><a href="#3-1-节点" class="headerlink" title="3.1 节点"></a>3.1 节点</h3><p>  这里主要分析NUMA模型。我们将内存分为多个节点对应多个CPU，每个节点再被分成一个一个的区域，每个区域有多个页面。由于页需要全局唯一定位，页还是需要有全局唯一的页号的。但是由于物理内存不是连起来的了，因此页号也就不再连续了。于是内存模型就变成了非连续内存模型。NUMA节点对应的结构为pglist_data，主要包括</p>
<ul>
<li>节点ID node_id</li>
<li>节点区域相关：node_zones，node_zonelists，nr_zones</li>
<li>节点的页数组：node_mam_map</li>
<li>节点的起始页号：node_start_pfn</li>
<li>节点中包含不连续的物理内存地址页数：node_spanned_pages</li>
<li>可用的物理页面数目：node_present_pates</li>
<li>页面回收、交换相关：kswapd_wait，kswapd，kswapd_order，kswapd_failures，kswapd_classzone_idx<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * On NUMA machines, each NUMA node would have a pg_data_t to describe</span></span><br><span class="line"><span class="comment"> * it&#x27;s memory layout. On UMA machines there is a single pglist_data which</span></span><br><span class="line"><span class="comment"> * describes the whole memory.</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * Memory statistics and page replacement data structures are maintained on a</span></span><br><span class="line"><span class="comment"> * per-zone basis.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">pglist_data</span> &#123;</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">zone</span> <span class="title">node_zones</span>[<span class="title">MAX_NR_ZONES</span>];</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">zonelist</span> <span class="title">node_zonelists</span>[<span class="title">MAX_ZONELISTS</span>];</span></span><br><span class="line">    <span class="type">int</span> nr_zones;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">page</span> *<span class="title">node_mem_map</span>;</span>    </span><br><span class="line">    <span class="type">unsigned</span> <span class="type">long</span> node_start_pfn;</span><br><span class="line">    <span class="type">unsigned</span> <span class="type">long</span> node_present_pages; <span class="comment">/* total number of physical pages */</span></span><br><span class="line">    <span class="type">unsigned</span> <span class="type">long</span> node_spanned_pages; <span class="comment">/* total size of physical page range, including holes */</span></span><br><span class="line">    <span class="type">int</span> node_id;</span><br><span class="line">    <span class="type">wait_queue_head_t</span> kswapd_wait;</span><br><span class="line">    <span class="type">wait_queue_head_t</span> pfmemalloc_wait;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">task_struct</span> *<span class="title">kswapd</span>;</span>	<span class="comment">/* Protected by mem_hotplug_begin/end() */</span></span><br><span class="line">    <span class="type">int</span> kswapd_order;</span><br><span class="line">    <span class="class"><span class="keyword">enum</span> <span class="title">zone_type</span> <span class="title">kswapd_classzone_idx</span>;</span></span><br><span class="line">    <span class="type">int</span> kswapd_failures;		<span class="comment">/* Number of &#x27;reclaimed == 0&#x27; runs */</span></span><br><span class="line">......</span><br><span class="line">&#125; <span class="type">pg_data_t</span>;</span><br></pre></td></tr></table></figure></li>
</ul>
<h3 id="3-2-区域"><a href="#3-2-区域" class="headerlink" title="3.2 区域"></a>3.2 区域</h3><p>每个节点可分成一个个的区域，node_zones存储了这些区域，node_zonelist以链表形式存储备用节点和它的内存区域的情况，nr_zones表示区域总数。区域的类型有如下几种，在上节中已简单提过，这里详细说明。</p>
<ul>
<li><p>ZONE_DMA 是指可用于作 DMA（Direct Memory Access，直接内存存取）的内存。DMA 是这样一种机制：要把外设的数据读入内存或把内存的数据传送到外设，原来都要通过 CPU 控制完成，但是这会占用 CPU，影响 CPU 处理其他事情，所以有了 DMA 模式。CPU 只需向 DMA 控制器下达指令，让 DMA 控制器来处理数据的传送，数据传送完毕再把信息反馈给 CPU，这样就可以解放 CPU。对于 64 位系统，有两个 DMA 区域。除了上面说的 ZONE_DMA，还有 ZONE_DMA32。</p>
</li>
<li><p>ZONE_NORMAL 是直接映射区，即内核态前896M空间</p>
</li>
<li><p>ZONE_HIGHMEM 是高端内存区，对于 32 位系统来说超过 896M 的地方，对于 64 位没必要有的一段区域。</p>
</li>
<li><p>ZONE_MOVABLE 是可移动区域，通过将物理内存划分为可移动分配区域和不可移动分配区域来避免内存碎片。</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">enum</span> <span class="title">zone_type</span> &#123;</span></span><br><span class="line"><span class="meta">#<span class="keyword">ifdef</span> CONFIG_ZONE_DMA</span></span><br><span class="line">    ZONE_DMA,</span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">ifdef</span> CONFIG_ZONE_DMA32</span></span><br><span class="line">    ZONE_DMA32,</span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line">    ZONE_NORMAL,</span><br><span class="line"><span class="meta">#<span class="keyword">ifdef</span> CONFIG_HIGHMEM</span></span><br><span class="line">    ZONE_HIGHMEM,</span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line">    ZONE_MOVABLE,</span><br><span class="line">    __MAX_NR_ZONES</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>区域的实现数据结构为zone，主要包括</p>
</li>
<li><p>区域初始页zone_start_pfn</p>
</li>
<li><p>区域总共跨多少页 spanned_pages</p>
</li>
<li><p>区域在物理内存中真实存在的页数present_pages</p>
</li>
<li><p>区域被伙伴系统管理的所有页数managed_pages</p>
</li>
<li><p>冷热页区分per_cpu_pagest：如果一个页被加载到 CPU 高速缓存里面，这就是一个热页（Hot Page），CPU 读起来速度会快很多，如果没有就是冷页（Cold Page）。由于每个 CPU 都有自己的高速缓存，因而 per_cpu_pageset 也是每个 CPU 一个。</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">zone</span> &#123;</span></span><br><span class="line">......</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">pglist_data</span>	*<span class="title">zone_pgdat</span>;</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">per_cpu_pageset</span> __<span class="title">percpu</span> *<span class="title">pageset</span>;</span></span><br><span class="line">......</span><br><span class="line">    <span class="comment">/* zone_start_pfn == zone_start_paddr &gt;&gt; PAGE_SHIFT */</span></span><br><span class="line">    <span class="type">unsigned</span> <span class="type">long</span>		zone_start_pfn;</span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">     * spanned_pages is the total pages spanned by the zone, including</span></span><br><span class="line"><span class="comment">     * holes, which is calculated as:</span></span><br><span class="line"><span class="comment">     * 	spanned_pages = zone_end_pfn - zone_start_pfn;</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * present_pages is physical pages existing within the zone, which</span></span><br><span class="line"><span class="comment">     * is calculated as:</span></span><br><span class="line"><span class="comment">     *	present_pages = spanned_pages - absent_pages(pages in holes);</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * managed_pages is present pages managed by the buddy system, which</span></span><br><span class="line"><span class="comment">     * is calculated as (reserved_pages includes pages allocated by the</span></span><br><span class="line"><span class="comment">     * bootmem allocator):</span></span><br><span class="line"><span class="comment">     *	managed_pages = present_pages - reserved_pages;</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * So present_pages may be used by memory hotplug or memory power</span></span><br><span class="line"><span class="comment">     * management logic to figure out unmanaged pages by checking</span></span><br><span class="line"><span class="comment">     * (present_pages - managed_pages). And managed_pages should be used</span></span><br><span class="line"><span class="comment">     * by page allocator and vm scanner to calculate all kinds of watermarks</span></span><br><span class="line"><span class="comment">     * and thresholds.</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * Locking rules:</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * zone_start_pfn and spanned_pages are protected by span_seqlock.</span></span><br><span class="line"><span class="comment">     * It is a seqlock because it has to be read outside of zone-&gt;lock,</span></span><br><span class="line"><span class="comment">     * and it is done in the main allocator path.  But, it is written</span></span><br><span class="line"><span class="comment">     * quite infrequently.</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * The span_seq lock is declared along with zone-&gt;lock because it is</span></span><br><span class="line"><span class="comment">     * frequently read in proximity to zone-&gt;lock.  It&#x27;s good to</span></span><br><span class="line"><span class="comment">     * give them a chance of being in the same cacheline.</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * Write access to present_pages at runtime should be protected by</span></span><br><span class="line"><span class="comment">     * mem_hotplug_begin/end(). Any reader who can&#x27;t tolerant drift of</span></span><br><span class="line"><span class="comment">     * present_pages should get_online_mems() to get a stable value.</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="type">atomic_long_t</span>		managed_pages;</span><br><span class="line">    <span class="type">unsigned</span> <span class="type">long</span>		spanned_pages;</span><br><span class="line">    <span class="type">unsigned</span> <span class="type">long</span>		present_pages;</span><br><span class="line">    <span class="type">const</span> <span class="type">char</span>		*name;</span><br><span class="line">......</span><br><span class="line">    <span class="type">int</span> initialized;</span><br><span class="line">    <span class="comment">/* Write-intensive fields used from the page allocator */</span></span><br><span class="line">    ZONE_PADDING(_pad1_)</span><br><span class="line">    <span class="comment">/* free areas of different sizes */</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">free_area</span>	<span class="title">free_area</span>[<span class="title">MAX_ORDER</span>];</span></span><br><span class="line">    <span class="comment">/* zone flags, see below */</span></span><br><span class="line">    <span class="type">unsigned</span> <span class="type">long</span>		flags;</span><br><span class="line">    <span class="comment">/* Primarily protects free_area */</span></span><br><span class="line">    <span class="type">spinlock_t</span>		lock;</span><br><span class="line">    <span class="comment">/* Write-intensive fields used by compaction and vmstats. */</span></span><br><span class="line">    ZONE_PADDING(_pad2_)</span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">     * When free pages are below this point, additional steps are taken</span></span><br><span class="line"><span class="comment">     * when reading the number of free pages to avoid per-cpu counter</span></span><br><span class="line"><span class="comment">     * drift allowing watermarks to be breached</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="type">unsigned</span> <span class="type">long</span> percpu_drift_mark;</span><br><span class="line">......</span><br><span class="line">    <span class="type">bool</span>			contiguous;</span><br><span class="line">    ZONE_PADDING(_pad3_)</span><br><span class="line">    <span class="comment">/* Zone statistics */</span></span><br><span class="line">    <span class="type">atomic_long_t</span>		vm_stat[NR_VM_ZONE_STAT_ITEMS];</span><br><span class="line">    <span class="type">atomic_long_t</span>		vm_numa_stat[NR_VM_NUMA_STAT_ITEMS];</span><br><span class="line">&#125; ____cacheline_internodealigned_in_smp;</span><br></pre></td></tr></table></figure></li>
</ul>
<h3 id="3-3-页"><a href="#3-3-页" class="headerlink" title="3.3 页"></a>3.3 页</h3><p>每个区域有很多个页，现在让我们将目光投向页的结构page。页中使用了大量的联合，其原因在于页有着多种不同的使用方式。</p>
<ul>
<li>整页使用方式。在前面介绍过，该种情况也存在两种页，一种是直接映射虚拟地址空间的匿名页（Anonymous Page），另一种则是用于关联文件、然后再和虚拟地址空间建立映射的页，称之为内存映射文件（Memory-mapped File）。对于该种模式，会使用联合里的以下变量<ul>
<li>struct address_space *mapping ：用于内存映射，如果是匿名页，最低位为 1；如果是映射文件，最低位为 0</li>
<li>pgoff_t index ：映射区的偏移量</li>
<li>atomic_t _mapcount：指向该页的页表数</li>
<li>struct list_head lru ：表示这一页应该在一个链表上，例如这个页面被换出，就在换出页的链表中；</li>
<li>compound 相关的变量用于复合页（Compound Page），就是将物理上连续的两个或多个页看成一个独立的大页。</li>
</ul>
</li>
<li>小块内存使用方式。在很多情况下，我们只需要使用少量内存，因此采用了slab allocator技术用于分配小块内存slab。它的基本原理是从内存管理模块申请一整块页，然后划分成多个小块的存储池，用复杂的队列来维护这些小块的状态（状态包括：被分配了 &#x2F; 被放回池子 &#x2F; 应该被回收）。也正是因为 slab allocator 对于队列的维护过于复杂，后来就有了一种不使用队列的分配器 slub allocator，但是里面还是用了很多 带有slab的API ，因为它保留了 slab 的用户接口，可以看成 slab allocator 的另一种实现。该种模式会使用联合里的以下变量<ul>
<li>s_mem ：正在使用的 slab 的第一个对象</li>
<li>freelist ：池子中的空闲对象</li>
<li>rcu_head ：需要释放的列表</li>
</ul>
</li>
<li>小块内存分配器slob，非常简单，常用于小型嵌入式系统</li>
</ul>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">page</span> &#123;</span></span><br><span class="line">    <span class="type">unsigned</span> <span class="type">long</span> flags;		<span class="comment">/* Atomic flags, some possibly updated asynchronously */</span></span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">     * Five words (20/40 bytes) are available in this union.</span></span><br><span class="line"><span class="comment">     * WARNING: bit 0 of the first word is used for PageTail(). That</span></span><br><span class="line"><span class="comment">     * means the other users of this union MUST NOT use the bit to</span></span><br><span class="line"><span class="comment">     * avoid collision and false-positive PageTail().</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="class"><span class="keyword">union</span> &#123;</span></span><br><span class="line">        <span class="class"><span class="keyword">struct</span> &#123;</span>	<span class="comment">/* Page cache and anonymous pages */</span></span><br><span class="line">            <span class="comment">/**</span></span><br><span class="line"><span class="comment">             * @lru: Pageout list, eg. active_list protected by</span></span><br><span class="line"><span class="comment">             * pgdat-&gt;lru_lock.  Sometimes used as a generic list</span></span><br><span class="line"><span class="comment">             * by the page owner.</span></span><br><span class="line"><span class="comment">             */</span></span><br><span class="line">            <span class="class"><span class="keyword">struct</span> <span class="title">list_head</span> <span class="title">lru</span>;</span></span><br><span class="line">            <span class="comment">/* See page-flags.h for PAGE_MAPPING_FLAGS */</span></span><br><span class="line">            <span class="class"><span class="keyword">struct</span> <span class="title">address_space</span> *<span class="title">mapping</span>;</span></span><br><span class="line">            <span class="type">pgoff_t</span> index;		<span class="comment">/* Our offset within mapping. */</span></span><br><span class="line">            <span class="comment">/**</span></span><br><span class="line"><span class="comment">             * @private: Mapping-private opaque data.</span></span><br><span class="line"><span class="comment">             * Usually used for buffer_heads if PagePrivate.</span></span><br><span class="line"><span class="comment">             * Used for swp_entry_t if PageSwapCache.</span></span><br><span class="line"><span class="comment">             * Indicates order in the buddy system if PageBuddy.</span></span><br><span class="line"><span class="comment">             */</span></span><br><span class="line">            <span class="type">unsigned</span> <span class="type">long</span> private;</span><br><span class="line">        &#125;;</span><br><span class="line">        <span class="class"><span class="keyword">struct</span> &#123;</span>	<span class="comment">/* page_pool used by netstack */</span></span><br><span class="line">            <span class="comment">/**</span></span><br><span class="line"><span class="comment">             * @dma_addr: might require a 64-bit value even on</span></span><br><span class="line"><span class="comment">             * 32-bit architectures.</span></span><br><span class="line"><span class="comment">             */</span></span><br><span class="line">            <span class="type">dma_addr_t</span> dma_addr;</span><br><span class="line">        &#125;;</span><br><span class="line">        <span class="class"><span class="keyword">struct</span> &#123;</span>	<span class="comment">/* slab, slob and slub */</span></span><br><span class="line">            <span class="class"><span class="keyword">union</span> &#123;</span></span><br><span class="line">                <span class="class"><span class="keyword">struct</span> <span class="title">list_head</span> <span class="title">slab_list</span>;</span>	<span class="comment">/* uses lru */</span></span><br><span class="line">                <span class="class"><span class="keyword">struct</span> &#123;</span>	<span class="comment">/* Partial pages */</span></span><br><span class="line">                    <span class="class"><span class="keyword">struct</span> <span class="title">page</span> *<span class="title">next</span>;</span></span><br><span class="line">......</span><br><span class="line">                &#125;;</span><br><span class="line">            &#125;;</span><br><span class="line">            <span class="class"><span class="keyword">struct</span> <span class="title">kmem_cache</span> *<span class="title">slab_cache</span>;</span> <span class="comment">/* not slob */</span></span><br><span class="line">            <span class="comment">/* Double-word boundary */</span></span><br><span class="line">            <span class="type">void</span> *freelist;		<span class="comment">/* first free object */</span></span><br><span class="line">            <span class="class"><span class="keyword">union</span> &#123;</span></span><br><span class="line">                <span class="type">void</span> *s_mem;	<span class="comment">/* slab: first object */</span></span><br><span class="line">                <span class="type">unsigned</span> <span class="type">long</span> counters;		<span class="comment">/* SLUB */</span></span><br><span class="line">                <span class="class"><span class="keyword">struct</span> &#123;</span>			<span class="comment">/* SLUB */</span></span><br><span class="line">                    <span class="type">unsigned</span> inuse:<span class="number">16</span>;</span><br><span class="line">                    <span class="type">unsigned</span> objects:<span class="number">15</span>;</span><br><span class="line">                    <span class="type">unsigned</span> frozen:<span class="number">1</span>;</span><br><span class="line">                &#125;;</span><br><span class="line">            &#125;;</span><br><span class="line">        &#125;;</span><br><span class="line">......</span><br><span class="line">        <span class="class"><span class="keyword">struct</span> &#123;</span>	<span class="comment">/* ZONE_DEVICE pages */</span></span><br><span class="line">            <span class="comment">/** @pgmap: Points to the hosting device page map. */</span></span><br><span class="line">            <span class="class"><span class="keyword">struct</span> <span class="title">dev_pagemap</span> *<span class="title">pgmap</span>;</span></span><br><span class="line">            <span class="type">unsigned</span> <span class="type">long</span> hmm_data;</span><br><span class="line">            <span class="type">unsigned</span> <span class="type">long</span> _zd_pad_1;	<span class="comment">/* uses mapping */</span></span><br><span class="line">        &#125;;</span><br><span class="line">        <span class="comment">/** @rcu_head: You can use this to free a page by RCU. */</span></span><br><span class="line">        <span class="class"><span class="keyword">struct</span> <span class="title">rcu_head</span> <span class="title">rcu_head</span>;</span></span><br><span class="line">    &#125;;</span><br><span class="line">......</span><br><span class="line">&#125; _struct_page_alignment;</span><br></pre></td></tr></table></figure>
<h2 id="四-用户态页的分配"><a href="#四-用户态页的分配" class="headerlink" title="四. 用户态页的分配"></a>四. 用户态页的分配</h2><p>  在上节中我们介绍了页按大小分配大致有伙伴系统和小块内存分配的slub分配。本节就这两种展开讨论。</p>
<h3 id="4-1-伙伴系统"><a href="#4-1-伙伴系统" class="headerlink" title="4.1 伙伴系统"></a>4.1 伙伴系统</h3><p>  对于要分配比较大的内存，例如到分配页级别的，可以使用伙伴系统（Buddy System）。伙伴分配机制可以归纳如下。</p>
<ul>
<li>采取多个链表将空闲页组织起来，每个链表中的节点包含的页块数目不同，即第i个链表中的每个节点拥有2^i个页。</li>
<li>当向内核请求分配 (2^(i-1)，2^i]数目的页块时，按照 2^i 页块请求处理，并将其分裂。</li>
<li>如果对应的页块链表中没有空闲页块，那我们就在更大的页块链表中去找，并对其进行分裂。如请求128个页，如果128页块链表无空闲则请求256链表，并将其分裂为两个128链表。</li>
</ul>
<p>  源码实现于alloc_pages()中，传参的定义如注释中所示，order表示分配2的order次方个页，gfp_mask表示分配区域，主要有</p>
<ul>
<li>GFP_USER：用于一个用户进程希望通过内存映射的方式访问某些硬件的缓存，例如显卡缓存</li>
<li>GFP_KERNEL：用于内核中分配页，主要分配 ZONE_NORMAL 区域，也即直接映射区</li>
<li>GFP_HIGHMEM：用于分配高端内存区域</li>
<li>GFP_FS：用于文件映射区</li>
<li>GFP_ATOMIC：表示该页内容不会进入休眠</li>
</ul>
<p>  这里涉及到了一种加快内存速度的技术：交叉存取技术（interleaved memory）。该存储方式会将存储体分为多个模块，每个模块类似于负载均衡逐个写入，这样当前字节被刷新时，可以不影响下一个字节的访问。交叉存储主要补偿DRAM等存储器相对较慢的读写速度。读或写每一个内存块，都需要等待内存块给出ready信号，才能读写下一字节。交叉存储将连续信息分散到各个块中，读写时可以同时等待多个内存块给出ready信号，从而提高了读写的速度。</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">static</span> <span class="keyword">inline</span> <span class="keyword">struct</span> page *</span><br><span class="line"><span class="title function_">alloc_pages</span><span class="params">(<span class="type">gfp_t</span> gfp_mask, <span class="type">unsigned</span> <span class="type">int</span> order)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">return</span> alloc_pages_current(gfp_mask, order);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 	alloc_pages_current - Allocate pages.</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> *	@gfp:</span></span><br><span class="line"><span class="comment"> *		    %GFP_USER   user allocation,</span></span><br><span class="line"><span class="comment"> *      	%GFP_KERNEL kernel allocation,</span></span><br><span class="line"><span class="comment"> *      	%GFP_HIGHMEM highmem allocation,</span></span><br><span class="line"><span class="comment"> *      	%GFP_FS     don&#x27;t call back into a file system.</span></span><br><span class="line"><span class="comment"> *      	%GFP_ATOMIC don&#x27;t sleep.</span></span><br><span class="line"><span class="comment"> *	@order: Power of two of allocation size in pages. 0 is a single page.</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> *	Allocate a page from the kernel page pool.  When not in</span></span><br><span class="line"><span class="comment"> *	interrupt context and apply the current process NUMA policy.</span></span><br><span class="line"><span class="comment"> *	Returns NULL when no page can be allocated.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">struct</span> page *<span class="title function_">alloc_pages_current</span><span class="params">(<span class="type">gfp_t</span> gfp, <span class="type">unsigned</span> order)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">mempolicy</span> *<span class="title">pol</span> =</span> &amp;default_policy;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">page</span> *<span class="title">page</span>;</span></span><br><span class="line">    <span class="keyword">if</span> (!in_interrupt() &amp;&amp; !(gfp &amp; __GFP_THISNODE))</span><br><span class="line">        pol = get_task_policy(current);</span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">     * No reference counting needed for current-&gt;mempolicy</span></span><br><span class="line"><span class="comment">     * nor system default_policy</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">if</span> (pol-&gt;mode == MPOL_INTERLEAVE)</span><br><span class="line">        page = alloc_page_interleave(gfp, order, interleave_nodes(pol));</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">        page = __alloc_pages_nodemask(gfp, order,</span><br><span class="line">                policy_node(gfp, pol, numa_node_id()),</span><br><span class="line">                policy_nodemask(gfp, pol));</span><br><span class="line">    <span class="keyword">return</span> page;</span><br><span class="line">&#125;</span><br><span class="line">EXPORT_SYMBOL(alloc_pages_current);</span><br><span class="line">````</span><br><span class="line">  交叉存取的alloc_page_interleave()函数实际上通过调用__alloc_page()最终也会调用__alloc_pages_nodemask()函数来实现分配。__alloc_pages_nodemask()是伙伴系统的核心方法，它会调用 get_page_from_freelist()在一个循环中轮询区域，先看当前节点的 zone，如果找不到空闲页则再看备用节点的 zone，直到找到为止。</span><br><span class="line">```c</span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * This is the &#x27;heart&#x27; of the zoned buddy allocator.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">page</span> *</span></span><br><span class="line"><span class="class">__<span class="title">alloc_pages_nodemask</span>(<span class="title">gfp_t</span> <span class="title">gfp_mask</span>, <span class="title">unsigned</span> <span class="title">int</span> <span class="title">order</span>, <span class="title">int</span> <span class="title">preferred_nid</span>,</span></span><br><span class="line"><span class="class">                            <span class="title">nodemask_t</span> *<span class="title">nodemask</span>)</span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">page</span> *<span class="title">page</span>;</span></span><br><span class="line">    <span class="type">unsigned</span> <span class="type">int</span> alloc_flags = ALLOC_WMARK_LOW;</span><br><span class="line">    <span class="type">gfp_t</span> alloc_mask; <span class="comment">/* The gfp_t that was actually used for allocation */</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">alloc_context</span> <span class="title">ac</span> =</span> &#123; &#125;;</span><br><span class="line">......</span><br><span class="line">    gfp_mask &amp;= gfp_allowed_mask;</span><br><span class="line">    alloc_mask = gfp_mask;</span><br><span class="line">    <span class="keyword">if</span> (!prepare_alloc_pages(gfp_mask, order, preferred_nid, nodemask, &amp;ac, &amp;alloc_mask, &amp;alloc_flags))</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">    finalise_ac(gfp_mask, &amp;ac);</span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">     * Forbid the first pass from falling back to types that fragment</span></span><br><span class="line"><span class="comment">     * memory until all local zones are considered.</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    alloc_flags |= alloc_flags_nofragment(ac.preferred_zoneref-&gt;zone, gfp_mask);</span><br><span class="line">    <span class="comment">/* First allocation attempt */</span></span><br><span class="line">    page = get_page_from_freelist(alloc_mask, order, alloc_flags, &amp;ac);</span><br><span class="line">......</span><br><span class="line">&#125;</span><br><span class="line">EXPORT_SYMBOL(__alloc_pages_nodemask);</span><br></pre></td></tr></table></figure>
<p>  get_page_from_freelist()函数如下所示，主要调用rmqueue()找寻合适大小的队列，并取出页面。通过rmqueue()-&gt;__rmqueue()-&gt;__rmqueue_smallest()最终来到__rmqueue_smallest()函数</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * get_page_from_freelist goes through the zonelist trying to allocate</span></span><br><span class="line"><span class="comment"> * a page.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="type">static</span> <span class="keyword">struct</span> page *</span><br><span class="line"><span class="title function_">get_page_from_freelist</span><span class="params">(<span class="type">gfp_t</span> gfp_mask, <span class="type">unsigned</span> <span class="type">int</span> order, <span class="type">int</span> alloc_flags,</span></span><br><span class="line"><span class="params">                        <span class="type">const</span> <span class="keyword">struct</span> alloc_context *ac)</span></span><br><span class="line">&#123;	</span><br><span class="line">......</span><br><span class="line">    for_next_zone_zonelist_nodemask(zone, z, ac-&gt;zonelist, ac-&gt;high_zoneidx,</span><br><span class="line">                                ac-&gt;nodemask) &#123;</span><br><span class="line">......</span><br><span class="line">        page = rmqueue(ac-&gt;preferred_zoneref-&gt;zone, zone, order,</span><br><span class="line">                gfp_mask, alloc_flags, ac-&gt;migratetype);</span><br><span class="line">        <span class="keyword">if</span> (page) &#123;</span><br><span class="line">            prep_new_page(page, order, gfp_mask, alloc_flags);</span><br><span class="line">            <span class="comment">/*</span></span><br><span class="line"><span class="comment">             * If this is a high-order atomic allocation then check</span></span><br><span class="line"><span class="comment">             * if the pageblock should be reserved for the future</span></span><br><span class="line"><span class="comment">             */</span></span><br><span class="line">            <span class="keyword">if</span> (unlikely(order &amp;&amp; (alloc_flags &amp; ALLOC_HARDER)))</span><br><span class="line">                reserve_highatomic_pageblock(page, zone, order);</span><br><span class="line">            <span class="keyword">return</span> page;</span><br><span class="line">        &#125; </span><br><span class="line">......</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>  在__rmqueue_smallest()中，实现了伙伴系统的找寻逻辑。从当前的order开始循环，如果page为空则order++，否则从当前链表lru中删除该页块，通过expand()函数将该区域剩余页块分配到其他对应的order链表中，最后返回该页块。</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * Go through the free lists for the given migratetype and remove</span></span><br><span class="line"><span class="comment"> * the smallest available page from the freelists</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="type">static</span> __always_inline</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">page</span> *__<span class="title">rmqueue_smallest</span>(<span class="keyword">struct</span> <span class="title">zone</span> *<span class="title">zone</span>, <span class="title">unsigned</span> <span class="title">int</span> <span class="title">order</span>,</span></span><br><span class="line"><span class="class">                        <span class="title">int</span> <span class="title">migratetype</span>)</span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    <span class="type">unsigned</span> <span class="type">int</span> current_order;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">free_area</span> *<span class="title">area</span>;</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">page</span> *<span class="title">page</span>;</span></span><br><span class="line">    <span class="comment">/* Find a page of the appropriate size in the preferred list */</span></span><br><span class="line">    <span class="keyword">for</span> (current_order = order; current_order &lt; MAX_ORDER; ++current_order) &#123;</span><br><span class="line">        area = &amp;(zone-&gt;free_area[current_order]);</span><br><span class="line">        page = list_first_entry_or_null(&amp;area-&gt;free_list[migratetype],</span><br><span class="line">                            <span class="keyword">struct</span> page, lru);</span><br><span class="line">        <span class="keyword">if</span> (!page)</span><br><span class="line">            <span class="keyword">continue</span>;</span><br><span class="line">        list_del(&amp;page-&gt;lru);</span><br><span class="line">        rmv_page_order(page);</span><br><span class="line">        area-&gt;nr_free--;</span><br><span class="line">        expand(zone, page, order, current_order, area, migratetype);</span><br><span class="line">        set_pcppage_migratetype(page, migratetype);</span><br><span class="line">        <span class="keyword">return</span> page;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">&#125;</span><br><span class="line">  expand()函数中将页块区域前移，size右移即除<span class="number">2</span>，然后使用list_add加入链表之中</span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * The order of subdivision here is critical for the IO subsystem.</span></span><br><span class="line"><span class="comment"> * Please do not alter this order without good reasons and regression</span></span><br><span class="line"><span class="comment"> * testing. Specifically, as large blocks of memory are subdivided,</span></span><br><span class="line"><span class="comment"> * the order in which smaller blocks are delivered depends on the order</span></span><br><span class="line"><span class="comment"> * they&#x27;re subdivided in this function. This is the primary factor</span></span><br><span class="line"><span class="comment"> * influencing the order in which pages are delivered to the IO</span></span><br><span class="line"><span class="comment"> * subsystem according to empirical testing, and this is also justified</span></span><br><span class="line"><span class="comment"> * by considering the behavior of a buddy system containing a single</span></span><br><span class="line"><span class="comment"> * large block of memory acted on by a series of small allocations.</span></span><br><span class="line"><span class="comment"> * This behavior is a critical factor in sglist merging&#x27;s success.</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * -- nyc</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="type">static</span> <span class="keyword">inline</span> <span class="type">void</span> <span class="title function_">expand</span><span class="params">(<span class="keyword">struct</span> zone *zone, <span class="keyword">struct</span> page *page,</span></span><br><span class="line"><span class="params">    <span class="type">int</span> low, <span class="type">int</span> high, <span class="keyword">struct</span> free_area *area,</span></span><br><span class="line"><span class="params">    <span class="type">int</span> migratetype)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">unsigned</span> <span class="type">long</span> size = <span class="number">1</span> &lt;&lt; high;</span><br><span class="line">    <span class="keyword">while</span> (high &gt; low) &#123;</span><br><span class="line">        area--;</span><br><span class="line">        high--;</span><br><span class="line">        size &gt;&gt;= <span class="number">1</span>;</span><br><span class="line">        VM_BUG_ON_PAGE(bad_range(zone, &amp;page[size]), &amp;page[size]);</span><br><span class="line">        <span class="comment">/*</span></span><br><span class="line"><span class="comment">         * Mark as guard pages (or page), that will allow to</span></span><br><span class="line"><span class="comment">         * merge back to allocator when buddy will be freed.</span></span><br><span class="line"><span class="comment">         * Corresponding page table entries will not be touched,</span></span><br><span class="line"><span class="comment">         * pages will stay not present in virtual address space</span></span><br><span class="line"><span class="comment">         */</span></span><br><span class="line">        <span class="keyword">if</span> (set_page_guard(zone, &amp;page[size], high, migratetype))</span><br><span class="line">            <span class="keyword">continue</span>;</span><br><span class="line">        list_add(&amp;page[size].lru, &amp;area-&gt;free_list[migratetype]);</span><br><span class="line">        area-&gt;nr_free++;</span><br><span class="line">        set_page_order(&amp;page[size], high);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>最后以一张结构图作为总结</p>
<p><img src="https://user-images.githubusercontent.com/87457873/128138199-9b16c394-17e9-40b7-a048-c1e68dfb5af0.png" alt="image"></p>
<h3 id="4-2-slub-allocator"><a href="#4-2-slub-allocator" class="headerlink" title="4.2 slub allocator"></a>4.2 slub allocator</h3><p>  任务task_struct在派生时，会调用alloc_task_struct_node()分配task_struct对象，其底层调用kmem_cache_alloc_node()函数在task_struct的缓存区域kmem_cache *task_struct_cachep分配内存。在系统初始化的时候，task_struct_cachep 会被 kmem_cache_create() 函数创建。这个函数专门用于分配 task_struct 对象的缓存。这个缓存区的名字就叫 task_struct。</p>
<p>  缓存区中每一块的大小正好等于 task_struct 的大小，也即 arch_task_struct_size。有了这个缓存区，每次创建 task_struct 的时候，先调用 kmem_cache_alloc_node()函数在缓存里面看看有没有直接可用的。当一个进程结束，task_struct 也不用直接被销毁，而是调用kmem_cache_free()放回到缓存中。这样，新进程创建的时候，我们就可以直接用现成的缓存中的 task_struct 了，从而加快了申请、释放速度。</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">static</span> <span class="class"><span class="keyword">struct</span> <span class="title">kmem_cache</span> *<span class="title">task_struct_cachep</span>;</span></span><br><span class="line"></span><br><span class="line">task_struct_cachep = kmem_cache_create(<span class="string">&quot;task_struct&quot;</span>,</span><br><span class="line">      arch_task_struct_size, align,</span><br><span class="line">      SLAB_PANIC|SLAB_NOTRACK|SLAB_ACCOUNT, <span class="literal">NULL</span>);</span><br><span class="line"></span><br><span class="line"><span class="type">static</span> <span class="keyword">inline</span> <span class="keyword">struct</span> task_struct *<span class="title function_">alloc_task_struct_node</span><span class="params">(<span class="type">int</span> node)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">return</span> kmem_cache_alloc_node(task_struct_cachep, GFP_KERNEL, node);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">static</span> <span class="keyword">inline</span> <span class="type">void</span> <span class="title function_">free_task_struct</span><span class="params">(<span class="keyword">struct</span> task_struct *tsk)</span></span><br><span class="line">&#123;</span><br><span class="line">    kmem_cache_free(task_struct_cachep, tsk);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>  下面分析一下缓冲区kmem_cache结构体。</p>
<ul>
<li><p>kmem_cached_cpu和kmem_cached_node：每个NUMA节点都对应一个，分别是缓存分配的fast path和slow path。每次分配的时候，要先从 kmem_cache_cpu 进行分配。如果 kmem_cache_cpu 里面没有空闲的块，那就到 kmem_cache_node 中进行分配；如果还是没有空闲的块，才去伙伴系统分配新的页。</p>
</li>
<li><p>size，object_size和offset：通过链表list_head，所有的小内存块会联系起来存放在缓冲区，用于task_struct、mm_struct、fs_struct等申请小内存块，object_size表示某内存块的大小，size表示该内存块加上指针的总大小，offset表示下一个空闲内存块的指针的偏移量。</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * Slab cache management.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">kmem_cache</span> &#123;</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">kmem_cache_cpu</span> __<span class="title">percpu</span> *<span class="title">cpu_slab</span>;</span></span><br><span class="line">    <span class="comment">/* Used for retrieving partial slabs, etc. */</span></span><br><span class="line">    <span class="type">slab_flags_t</span> flags;</span><br><span class="line">    <span class="type">unsigned</span> <span class="type">long</span> min_partial;</span><br><span class="line">    <span class="type">unsigned</span> <span class="type">int</span> size;	<span class="comment">/* The size of an object including metadata */</span></span><br><span class="line">    <span class="type">unsigned</span> <span class="type">int</span> object_size;<span class="comment">/* The size of an object without metadata */</span></span><br><span class="line">    <span class="type">unsigned</span> <span class="type">int</span> offset;	<span class="comment">/* Free pointer offset */</span></span><br><span class="line"><span class="meta">#<span class="keyword">ifdef</span> CONFIG_SLUB_CPU_PARTIAL</span></span><br><span class="line">    <span class="comment">/* Number of per cpu partial objects to keep around */</span></span><br><span class="line">    <span class="type">unsigned</span> <span class="type">int</span> cpu_partial;</span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">kmem_cache_order_objects</span> <span class="title">oo</span>;</span></span><br><span class="line">    <span class="comment">/* Allocation and freeing of slabs */</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">kmem_cache_order_objects</span> <span class="title">max</span>;</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">kmem_cache_order_objects</span> <span class="title">min</span>;</span></span><br><span class="line">    <span class="type">gfp_t</span> allocflags;	<span class="comment">/* gfp flags to use on each alloc */</span></span><br><span class="line">    <span class="type">int</span> refcount;		<span class="comment">/* Refcount for slab cache destroy */</span></span><br><span class="line">    <span class="type">void</span> (*ctor)(<span class="type">void</span> *);</span><br><span class="line">    <span class="type">unsigned</span> <span class="type">int</span> inuse;		<span class="comment">/* Offset to metadata */</span></span><br><span class="line">    <span class="type">unsigned</span> <span class="type">int</span> align;		<span class="comment">/* Alignment */</span></span><br><span class="line">    <span class="type">unsigned</span> <span class="type">int</span> red_left_pad;	<span class="comment">/* Left redzone padding size */</span></span><br><span class="line">    <span class="type">const</span> <span class="type">char</span> *name;	<span class="comment">/* Name (only for display!) */</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">list_head</span> <span class="title">list</span>;</span>	<span class="comment">/* List of slab caches */</span></span><br><span class="line">......</span><br><span class="line">    <span class="type">unsigned</span> <span class="type">int</span> useroffset;	<span class="comment">/* Usercopy region offset */</span></span><br><span class="line">    <span class="type">unsigned</span> <span class="type">int</span> usersize;		<span class="comment">/* Usercopy region size */</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">kmem_cache_node</span> *<span class="title">node</span>[<span class="title">MAX_NUMNODES</span>];</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>  首先来看看快分配方式kmem_cached_cpu，该结构体中page指向内存页块的第一页，freelist指向下一个可用的内存页块，partial表示部分被分配部分为空的页，该项为备用项，仅当page满了才会在partial中寻找，而partial本身指向的是kmem_cached_node中的partial链表。</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">kmem_cache_cpu</span> &#123;</span></span><br><span class="line">    <span class="type">void</span> **freelist;	<span class="comment">/* Pointer to next available object */</span></span><br><span class="line">    <span class="type">unsigned</span> <span class="type">long</span> tid;	<span class="comment">/* Globally unique transaction id */</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">page</span> *<span class="title">page</span>;</span>	<span class="comment">/* The slab from which we are allocating */</span></span><br><span class="line"><span class="meta">#<span class="keyword">ifdef</span> CONFIG_SLUB_CPU_PARTIAL</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">page</span> *<span class="title">partial</span>;</span>	<span class="comment">/* Partially allocated frozen slabs */</span></span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">ifdef</span> CONFIG_SLUB_STATS</span></span><br><span class="line">    <span class="type">unsigned</span> stat[NR_SLUB_STAT_ITEMS];</span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>  kmem_cached_node结构体中也有类似的成员变量，但是相较之下会有更多详细信息，如slab链表总长度、空闲内存块的数量等等。</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * The slab lists for all objects.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">kmem_cache_node</span> &#123;</span></span><br><span class="line">    <span class="type">spinlock_t</span> list_lock;</span><br><span class="line"><span class="meta">#<span class="keyword">ifdef</span> CONFIG_SLAB</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">list_head</span> <span class="title">slabs_partial</span>;</span>	<span class="comment">/* partial list first, better asm code */</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">list_head</span> <span class="title">slabs_full</span>;</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">list_head</span> <span class="title">slabs_free</span>;</span></span><br><span class="line">    <span class="type">unsigned</span> <span class="type">long</span> total_slabs;	<span class="comment">/* length of all slab lists */</span></span><br><span class="line">    <span class="type">unsigned</span> <span class="type">long</span> free_slabs;	<span class="comment">/* length of free slab list only */</span></span><br><span class="line">    <span class="type">unsigned</span> <span class="type">long</span> free_objects;</span><br><span class="line">    <span class="type">unsigned</span> <span class="type">int</span> free_limit;</span><br><span class="line">    <span class="type">unsigned</span> <span class="type">int</span> colour_next;	<span class="comment">/* Per-node cache coloring */</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">array_cache</span> *<span class="title">shared</span>;</span>	<span class="comment">/* shared per node */</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">alien_cache</span> **<span class="title">alien</span>;</span>	<span class="comment">/* on other nodes */</span></span><br><span class="line">    <span class="type">unsigned</span> <span class="type">long</span> next_reap;	<span class="comment">/* updated without locking */</span></span><br><span class="line">    <span class="type">int</span> free_touched;		<span class="comment">/* updated without locking */</span></span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">ifdef</span> CONFIG_SLUB</span></span><br><span class="line">    <span class="type">unsigned</span> <span class="type">long</span> nr_partial;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">list_head</span> <span class="title">partial</span>;</span></span><br><span class="line">......</span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>  下面回到缓冲区的分配函数kmem_cache_alloc_node()和释放函数kmem_cache_free。分配函数kmem_cache_alloc_node()实际调用slab_alloc_node()。从这里可以看出快通道和慢通道的处理逻辑。</p>
</li>
<li><p>快通道：尝试取出kmem_cache_cpu cpu_slab的freelist，如果有空闲则返回，否则进入慢通道</p>
</li>
<li><p>慢通道：调用__slab_alloc()分配新的内存块</p>
</li>
</ul>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * Inlined fastpath so that allocation functions (kmalloc, kmem_cache_alloc)</span></span><br><span class="line"><span class="comment"> * have the fastpath folded into their functions. So no function call</span></span><br><span class="line"><span class="comment"> * overhead for requests that can be satisfied on the fastpath.</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * The fastpath works by first checking if the lockless freelist can be used.</span></span><br><span class="line"><span class="comment"> * If not then __slab_alloc is called for slow processing.</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * Otherwise we can simply pick the next object from the lockless free list.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="type">static</span> __always_inline <span class="type">void</span> *<span class="title function_">slab_alloc_node</span><span class="params">(<span class="keyword">struct</span> kmem_cache *s,</span></span><br><span class="line"><span class="params">        <span class="type">gfp_t</span> gfpflags, <span class="type">int</span> node, <span class="type">unsigned</span> <span class="type">long</span> addr)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">void</span> *object;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">kmem_cache_cpu</span> *<span class="title">c</span>;</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">page</span> *<span class="title">page</span>;</span></span><br><span class="line">    <span class="type">unsigned</span> <span class="type">long</span> tid;</span><br><span class="line">    s = slab_pre_alloc_hook(s, gfpflags);</span><br><span class="line">    <span class="keyword">if</span> (!s)</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">redo:</span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">     * Must read kmem_cache cpu data via this cpu ptr. Preemption is</span></span><br><span class="line"><span class="comment">     * enabled. We may switch back and forth between cpus while</span></span><br><span class="line"><span class="comment">     * reading from one cpu area. That does not matter as long</span></span><br><span class="line"><span class="comment">     * as we end up on the original cpu again when doing the cmpxchg.</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * We should guarantee that tid and kmem_cache are retrieved on</span></span><br><span class="line"><span class="comment">     * the same cpu. It could be different if CONFIG_PREEMPT so we need</span></span><br><span class="line"><span class="comment">     * to check if it is matched or not.</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">do</span> &#123;</span><br><span class="line">        tid = this_cpu_read(s-&gt;cpu_slab-&gt;tid);</span><br><span class="line">        c = raw_cpu_ptr(s-&gt;cpu_slab);</span><br><span class="line">    &#125; <span class="keyword">while</span> (IS_ENABLED(CONFIG_PREEMPT) &amp;&amp;</span><br><span class="line">         unlikely(tid != READ_ONCE(c-&gt;tid)));</span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">     * Irqless object alloc/free algorithm used here depends on sequence</span></span><br><span class="line"><span class="comment">     * of fetching cpu_slab&#x27;s data. tid should be fetched before anything</span></span><br><span class="line"><span class="comment">     * on c to guarantee that object and page associated with previous tid</span></span><br><span class="line"><span class="comment">     * won&#x27;t be used with current tid. If we fetch tid first, object and</span></span><br><span class="line"><span class="comment">     * page could be one associated with next tid and our alloc/free</span></span><br><span class="line"><span class="comment">     * request will be failed. In this case, we will retry. So, no problem.</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    barrier();</span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">     * The transaction ids are globally unique per cpu and per operation on</span></span><br><span class="line"><span class="comment">     * a per cpu queue. Thus they can be guarantee that the cmpxchg_double</span></span><br><span class="line"><span class="comment">     * occurs on the right processor and that there was no operation on the</span></span><br><span class="line"><span class="comment">     * linked list in between.</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    object = c-&gt;freelist;</span><br><span class="line">    page = c-&gt;page;</span><br><span class="line">    <span class="keyword">if</span> (unlikely(!object || !node_match(page, node))) &#123;</span><br><span class="line">        object = __slab_alloc(s, gfpflags, node, addr, c);</span><br><span class="line">        stat(s, ALLOC_SLOWPATH);</span><br><span class="line">    &#125;</span><br><span class="line">......</span><br><span class="line">    <span class="keyword">return</span> object;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>  __slab_alloc()主要逻辑如下</p>
<ul>
<li>在此尝试kmem_cache_cpu中的freelist是否可用，因为当前进程可能被中断，等回到该进程继续执行时可能已经有了空闲内存块可以直接使用了，因此先检查一下</li>
<li>跳转到new_slab标签，检查kmem_cache_cpu中的paritial，如果partial不为空则将kmem_cache_cpu中的page替换为partial，跳转至redo标签再次尝试分配</li>
<li>依然失败，则调用new_slab_objects()分配新内存块</li>
</ul>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * Slow path. The lockless freelist is empty or we need to perform</span></span><br><span class="line"><span class="comment"> * debugging duties.</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * Processing is still very fast if new objects have been freed to the</span></span><br><span class="line"><span class="comment"> * regular freelist. In that case we simply take over the regular freelist</span></span><br><span class="line"><span class="comment"> * as the lockless freelist and zap the regular freelist.</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * If that is not working then we fall back to the partial lists. We take the</span></span><br><span class="line"><span class="comment"> * first element of the freelist as the object to allocate now and move the</span></span><br><span class="line"><span class="comment"> * rest of the freelist to the lockless freelist.</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * And if we were unable to get a new slab from the partial slab lists then</span></span><br><span class="line"><span class="comment"> * we need to allocate a new slab. This is the slowest path since it involves</span></span><br><span class="line"><span class="comment"> * a call to the page allocator and the setup of a new slab.</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * Version of __slab_alloc to use when we know that interrupts are</span></span><br><span class="line"><span class="comment"> * already disabled (which is the case for bulk allocation).</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="type">static</span> <span class="type">void</span> *___slab_alloc(<span class="keyword">struct</span> kmem_cache *s, <span class="type">gfp_t</span> gfpflags, <span class="type">int</span> node,</span><br><span class="line">              <span class="type">unsigned</span> <span class="type">long</span> addr, <span class="keyword">struct</span> kmem_cache_cpu *c)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">void</span> *freelist;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">page</span> *<span class="title">page</span>;</span></span><br><span class="line">    page = c-&gt;page;</span><br><span class="line">    <span class="keyword">if</span> (!page)</span><br><span class="line">        <span class="keyword">goto</span> new_slab;</span><br><span class="line">redo:</span><br><span class="line">    <span class="keyword">if</span> (unlikely(!node_match(page, node))) &#123;</span><br><span class="line">        <span class="type">int</span> searchnode = node;</span><br><span class="line">        <span class="keyword">if</span> (node != NUMA_NO_NODE &amp;&amp; !node_present_pages(node))</span><br><span class="line">            searchnode = node_to_mem_node(node);</span><br><span class="line">        <span class="keyword">if</span> (unlikely(!node_match(page, searchnode))) &#123;</span><br><span class="line">            stat(s, ALLOC_NODE_MISMATCH);</span><br><span class="line">            deactivate_slab(s, page, c-&gt;freelist, c);</span><br><span class="line">            <span class="keyword">goto</span> new_slab;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">     * By rights, we should be searching for a slab page that was</span></span><br><span class="line"><span class="comment">     * PFMEMALLOC but right now, we are losing the pfmemalloc</span></span><br><span class="line"><span class="comment">     * information when the page leaves the per-cpu allocator</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">if</span> (unlikely(!pfmemalloc_match(page, gfpflags))) &#123;</span><br><span class="line">        deactivate_slab(s, page, c-&gt;freelist, c);</span><br><span class="line">        <span class="keyword">goto</span> new_slab;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">/* must check again c-&gt;freelist in case of cpu migration or IRQ */</span></span><br><span class="line">    freelist = c-&gt;freelist;</span><br><span class="line">    <span class="keyword">if</span> (freelist)</span><br><span class="line">        <span class="keyword">goto</span> load_freelist;</span><br><span class="line">    freelist = get_freelist(s, page);</span><br><span class="line">    <span class="keyword">if</span> (!freelist) &#123;</span><br><span class="line">        c-&gt;page = <span class="literal">NULL</span>;</span><br><span class="line">        stat(s, DEACTIVATE_BYPASS);</span><br><span class="line">        <span class="keyword">goto</span> new_slab;</span><br><span class="line">    &#125;</span><br><span class="line">    stat(s, ALLOC_REFILL);</span><br><span class="line">load_freelist:</span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">     * freelist is pointing to the list of objects to be used.</span></span><br><span class="line"><span class="comment">     * page is pointing to the page from which the objects are obtained.</span></span><br><span class="line"><span class="comment">     * That page must be frozen for per cpu allocations to work.</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    VM_BUG_ON(!c-&gt;page-&gt;frozen);</span><br><span class="line">    c-&gt;freelist = get_freepointer(s, freelist);</span><br><span class="line">    c-&gt;tid = next_tid(c-&gt;tid);</span><br><span class="line">    <span class="keyword">return</span> freelist;</span><br><span class="line">new_slab:</span><br><span class="line">    <span class="keyword">if</span> (slub_percpu_partial(c)) &#123;</span><br><span class="line">        page = c-&gt;page = slub_percpu_partial(c);</span><br><span class="line">        slub_set_percpu_partial(c, page);</span><br><span class="line">        stat(s, CPU_PARTIAL_ALLOC);</span><br><span class="line">        <span class="keyword">goto</span> redo;</span><br><span class="line">    &#125;</span><br><span class="line">    freelist = new_slab_objects(s, gfpflags, node, &amp;c);</span><br><span class="line">    <span class="keyword">if</span> (unlikely(!freelist)) &#123;</span><br><span class="line">        slab_out_of_memory(s, gfpflags, node);</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    page = c-&gt;page;</span><br><span class="line">    <span class="keyword">if</span> (likely(!kmem_cache_debug(s) &amp;&amp; pfmemalloc_match(page, gfpflags)))</span><br><span class="line">        <span class="keyword">goto</span> load_freelist;</span><br><span class="line">    <span class="comment">/* Only entered in the debug case */</span></span><br><span class="line">    <span class="keyword">if</span> (kmem_cache_debug(s) &amp;&amp;</span><br><span class="line">            !alloc_debug_processing(s, page, freelist, addr))</span><br><span class="line">        <span class="keyword">goto</span> new_slab;	<span class="comment">/* Slab failed checks. Next slab needed */</span></span><br><span class="line">    deactivate_slab(s, page, get_freepointer(s, freelist), c);</span><br><span class="line">    <span class="keyword">return</span> freelist;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>  new_slab_objects()函数逻辑如下</p>
<ul>
<li>调用get_partial()函数，根据node找到对应的kmem_cache_node然后调用get_partial_node()分配内存块。实际分配通过acquire_slab()函数完成，该函数会分配完成返回内存块指针并保存在freelist中，从 kmem_cache_node 的 partial 链表中拿下一大块内存来，并且将 freelist，也就是第一块空闲的缓存块赋值给 t。并且当第一轮循环的时候，将 kmem_cache_cpu 的 page 指向取下来的这一大块内存，返回的 object 就是这块内存里面的第一个缓存块 t。如果 kmem_cache_cpu 也有一个 partial，就会进行第二轮，再次取下一大块内存来，这次调用 put_cpu_partial()，放到 kmem_cache_cpu 的 partial 里面。如果 kmem_cache_node 里面也没有空闲的内存，这就说明原来分配的页里面都放满了，执行下一步。</li>
<li>调用new_slab()函数，向伙伴系统请求2^order个page，将请求的page构建成一个slab。分配的时候，要按 kmem_cache_order_objects 里面的 order 来。如果第一次分配不成功，说明内存已经很紧张了，那就换成 min 版本的 kmem_cache_order_objects。其调用链为new_slab()-&gt;allocate_slab()-&gt;alloc_slab_page()-&gt;__alloc_pages_node()-&gt;__alloc_pages()-&gt;__alloc_pages_nodemask()，从这里回到了伙伴系统，可见上文对该函数的分析。</li>
</ul>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">static</span> <span class="keyword">inline</span> <span class="type">void</span> *<span class="title function_">new_slab_objects</span><span class="params">(<span class="keyword">struct</span> kmem_cache *s, <span class="type">gfp_t</span> flags,</span></span><br><span class="line"><span class="params">            <span class="type">int</span> node, <span class="keyword">struct</span> kmem_cache_cpu **pc)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">void</span> *freelist;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">kmem_cache_cpu</span> *<span class="title">c</span> =</span> *pc;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">page</span> *<span class="title">page</span>;</span></span><br><span class="line">    WARN_ON_ONCE(s-&gt;ctor &amp;&amp; (flags &amp; __GFP_ZERO));</span><br><span class="line">    freelist = get_partial(s, flags, node, c);</span><br><span class="line">    <span class="keyword">if</span> (freelist)</span><br><span class="line">        <span class="keyword">return</span> freelist;</span><br><span class="line">    page = new_slab(s, flags, node);</span><br><span class="line">    <span class="keyword">if</span> (page) &#123;</span><br><span class="line">        c = raw_cpu_ptr(s-&gt;cpu_slab);</span><br><span class="line">        <span class="keyword">if</span> (c-&gt;page)</span><br><span class="line">            flush_slab(s, c);</span><br><span class="line">        <span class="comment">/*</span></span><br><span class="line"><span class="comment">         * No other reference to the page yet so we can</span></span><br><span class="line"><span class="comment">         * muck around with it freely without cmpxchg</span></span><br><span class="line"><span class="comment">         */</span></span><br><span class="line">        freelist = page-&gt;freelist;</span><br><span class="line">        page-&gt;freelist = <span class="literal">NULL</span>;</span><br><span class="line">        stat(s, ALLOC_SLAB);</span><br><span class="line">        c-&gt;page = page;</span><br><span class="line">        *pc = c;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> freelist;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>  至此，页的分配就介绍完了。简单概括就是伙伴系统将多个连续页面整合为页块以供大规模使用，slub allocator将从伙伴系统申请的大块切成小块，放在缓存，并分配给其他系统。物理内存分页之后，通过page_address()-&gt;lowmem_page_address()-&gt;page_to_virt()调用链转化为虚拟地址以使用。</p>
<h2 id="五-内核页表"><a href="#五-内核页表" class="headerlink" title="五. 内核页表"></a>五. 内核页表</h2><p>  内核态的页表在系统初始化的时候就需要创建，而非可以等到用的时候再创建页并映射。在 arch&#x2F;x86&#x2F;include&#x2F;asm&#x2F;pgtable_64.h有如下定义</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="keyword">extern</span> <span class="type">p4d_t</span> level4_kernel_pgt[<span class="number">512</span>];</span><br><span class="line"><span class="keyword">extern</span> <span class="type">p4d_t</span> level4_ident_pgt[<span class="number">512</span>];</span><br><span class="line"><span class="keyword">extern</span> <span class="type">pud_t</span> level3_kernel_pgt[<span class="number">512</span>];</span><br><span class="line"><span class="keyword">extern</span> <span class="type">pud_t</span> level3_ident_pgt[<span class="number">512</span>];</span><br><span class="line"><span class="keyword">extern</span> <span class="type">pmd_t</span> level2_kernel_pgt[<span class="number">512</span>];</span><br><span class="line"><span class="keyword">extern</span> <span class="type">pmd_t</span> level2_fixmap_pgt[<span class="number">512</span>];</span><br><span class="line"><span class="keyword">extern</span> <span class="type">pmd_t</span> level2_ident_pgt[<span class="number">512</span>];</span><br><span class="line"><span class="keyword">extern</span> <span class="type">pte_t</span> level1_fixmap_pgt[<span class="number">512</span> * FIXMAP_PMD_NUM];</span><br><span class="line"><span class="keyword">extern</span> <span class="type">pgd_t</span> init_top_pgt[];</span><br><span class="line"><span class="meta">#<span class="keyword">define</span> swapper_pg_dir init_top_pgt</span></span><br></pre></td></tr></table></figure>
<p>  其中swapper_pg_dir 指向内核最顶级的目录 pgd，同时出现的还有几个页表目录，其中 XXX_ident_pgt 对应的是直接映射区，XXX_kernel_pgt 对应的是内核代码区，XXX_fixmap_pgt 对应的是固定映射区。</p>
<p>  初始化的位置位于arch\x86\kernel\head_64.S，以全局变量的方式保存。这里quad 表示声明了一项的内容，org表示跳到了某个位置。</p>
<p>  init_top_pgt是内核页的顶级目录，首先将其指向level3_ident_pgt，即直接映射区页表的三级目录。前文中有说过直接映射区物理内存和虚拟内存通过减去偏移量实现，即__START_KERNEL_map，虚拟地址空间的内核代码段的起始地址。通过这种方式，我们得到了其对应的物理地址。接着我们通过PGD_PAGE_OFFSET偏移量和PGD_START_KERNEL偏移量进行两次跳转，其中PGD_PAGE_OFFSET对应__PAGE_OFFSET_BASE，即虚拟地址空间里面内核的起始地址。第二项则指向__START_KERNEL_map，即虚拟地址空间里面内核代码段的起始地址。其他代码也是同理，最终形成如下表所示的整个页表项的初始化工作。</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">__INITDATA</span><br><span class="line"></span><br><span class="line"><span class="title function_">NEXT_PAGE</span><span class="params">(init_top_pgt)</span></span><br><span class="line">  .quad   level3_ident_pgt - __START_KERNEL_map + _KERNPG_TABLE</span><br><span class="line">  .org    init_top_pgt + PGD_PAGE_OFFSET*8, 0</span><br><span class="line">  .quad   level3_ident_pgt - __START_KERNEL_map + _KERNPG_TABLE</span><br><span class="line">  .org    init_top_pgt + PGD_START_KERNEL*8, 0</span><br><span class="line">  <span class="comment">/* (2^48-(2*1024*1024*1024))/(2^39) = 511 */</span></span><br><span class="line">  .quad   level3_kernel_pgt - __START_KERNEL_map + _PAGE_TABLE</span><br><span class="line"></span><br><span class="line"><span class="title function_">NEXT_PAGE</span><span class="params">(level3_ident_pgt)</span></span><br><span class="line">  .quad  level2_ident_pgt - __START_KERNEL_map + _KERNPG_TABLE</span><br><span class="line">  .fill  511, 8, 0</span><br><span class="line"><span class="title function_">NEXT_PAGE</span><span class="params">(level2_ident_pgt)</span></span><br><span class="line">  <span class="comment">/* Since I easily can, map the first 1G.</span></span><br><span class="line"><span class="comment">   * Don&#x27;t set NX because code runs from these pages.</span></span><br><span class="line"><span class="comment">   */</span></span><br><span class="line">  <span class="title function_">PMDS</span><span class="params">(<span class="number">0</span>, __PAGE_KERNEL_IDENT_LARGE_EXEC, PTRS_PER_PMD)</span></span><br><span class="line"></span><br><span class="line"><span class="title function_">NEXT_PAGE</span><span class="params">(level3_kernel_pgt)</span></span><br><span class="line">  .fill  L3_START_KERNEL,8,0</span><br><span class="line">  <span class="comment">/* (2^48-(2*1024*1024*1024)-((2^39)*511))/(2^30) = 510 */</span></span><br><span class="line">  .quad  level2_kernel_pgt - __START_KERNEL_map + _KERNPG_TABLE</span><br><span class="line">  .quad  level2_fixmap_pgt - __START_KERNEL_map + _PAGE_TABLE</span><br><span class="line"></span><br><span class="line"><span class="title function_">NEXT_PAGE</span><span class="params">(level2_kernel_pgt)</span></span><br><span class="line">  <span class="comment">/*</span></span><br><span class="line"><span class="comment">   * 512 MB kernel mapping. We spend a full page on this pagetable</span></span><br><span class="line"><span class="comment">   * anyway.</span></span><br><span class="line"><span class="comment">   *</span></span><br><span class="line"><span class="comment">   * The kernel code+data+bss must not be bigger than that.</span></span><br><span class="line"><span class="comment">   *</span></span><br><span class="line"><span class="comment">   * (<span class="doctag">NOTE:</span> at +512MB starts the module area, see MODULES_VADDR.</span></span><br><span class="line"><span class="comment">   *  If you want to increase this then increase MODULES_VADDR</span></span><br><span class="line"><span class="comment">   *  too.)</span></span><br><span class="line"><span class="comment">   */</span></span><br><span class="line">  <span class="title function_">PMDS</span><span class="params">(<span class="number">0</span>, __PAGE_KERNEL_LARGE_EXEC,</span></span><br><span class="line"><span class="params">    KERNEL_IMAGE_SIZE/PMD_SIZE)</span></span><br><span class="line"></span><br><span class="line"><span class="title function_">NEXT_PAGE</span><span class="params">(level2_fixmap_pgt)</span></span><br><span class="line">  .fill  506,8,0</span><br><span class="line">  .quad  level1_fixmap_pgt - __START_KERNEL_map + _PAGE_TABLE</span><br><span class="line">  <span class="comment">/* 8MB reserved for vsyscalls + a 2MB hole = 4 + 1 entries */</span></span><br><span class="line">  .fill  5,8,0</span><br><span class="line"></span><br><span class="line"><span class="title function_">NEXT_PAGE</span><span class="params">(level1_fixmap_pgt)</span></span><br><span class="line">  .fill  51</span><br><span class="line">  </span><br><span class="line">PGD_PAGE_OFFSET = pgd_index(__PAGE_OFFSET_BASE)</span><br><span class="line">PGD_START_KERNEL = pgd_index(__START_KERNEL_map)</span><br><span class="line">L3_START_KERNEL = pud_index(__START_KERNEL_map)</span><br></pre></td></tr></table></figure>

<p><img src="https://user-images.githubusercontent.com/87457873/128138240-53ab750c-c854-4dfa-9575-152c5f82e8a7.png" alt="image"></p>
<p>内核页表定义完了，一开始这里面的页表能够覆盖的内存范围比较小。例如内核代码区 512M，直接映射区 1G。这个时候，其实只要能够映射基本的内核代码和数据结构就可以了。可以看出里面还空着很多项，可以用于将来映射巨大的内核虚拟地址空间，等用到的时候再进行映射。如果是用户态进程页表，会有 mm_struct 指向进程顶级目录 pgd，对于内核来讲，也定义了一个 mm_struct，指向 swapper_pg_dir。</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">mm_struct</span> <span class="title">init_mm</span> =</span> &#123;</span><br><span class="line">    .mm_rb    = RB_ROOT,</span><br><span class="line">    .pgd    = swapper_pg_dir,</span><br><span class="line">    .mm_users  = ATOMIC_INIT(<span class="number">2</span>),</span><br><span class="line">    .mm_count  = ATOMIC_INIT(<span class="number">1</span>),</span><br><span class="line">    .mmap_sem  = __RWSEM_INITIALIZER(init_mm.mmap_sem),</span><br><span class="line">    .page_table_lock =  __SPIN_LOCK_UNLOCKED(init_mm.page_table_lock),</span><br><span class="line">    .mmlist    = LIST_HEAD_INIT(init_mm.mmlist),</span><br><span class="line">    .user_ns  = &amp;init_user_ns,</span><br><span class="line">    INIT_MM_CONTEXT(init_mm)</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>  内核页表的初始化工作会在系统启动时，start_kernel()通过调用setup_arch()完成。load_cr3(swapper_pg_dir) 说明内核页表要开始起作用了，并且刷新了 TLB，初始化 init_mm 的成员变量，最重要的就是 init_mem_mapping()，通过调用链init_mem_mapping()-&gt;init_memory_mapping()-&gt;kernel_physical_mapping_init()最终通过 __va 将物理地址转换为虚拟地址，然后再创建虚拟地址和物理地址的映射页表。__va和__pa本身可以直接完成物理地址和虚拟地址的转换，但是CPU在保护模式下访问虚拟地址需要通过CR3寄存器，因此必须完成该映射页表的创建工作。</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">void</span> __init <span class="title function_">setup_arch</span><span class="params">(<span class="type">char</span> **cmdline_p)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">     * copy kernel address range established so far and switch</span></span><br><span class="line"><span class="comment">     * to the proper swapper page table</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    clone_pgd_range(swapper_pg_dir     + KERNEL_PGD_BOUNDARY,</span><br><span class="line">        initial_page_table + KERNEL_PGD_BOUNDARY,</span><br><span class="line">        KERNEL_PGD_PTRS);</span><br><span class="line"></span><br><span class="line">    load_cr3(swapper_pg_dir);</span><br><span class="line">    __flush_tlb_all();</span><br><span class="line">......</span><br><span class="line">    init_mm.start_code = (<span class="type">unsigned</span> <span class="type">long</span>) _text;</span><br><span class="line">    init_mm.end_code = (<span class="type">unsigned</span> <span class="type">long</span>) _etext;</span><br><span class="line">    init_mm.end_data = (<span class="type">unsigned</span> <span class="type">long</span>) _edata;</span><br><span class="line">    init_mm.brk = _brk_end;</span><br><span class="line">......</span><br><span class="line">    init_mem_mapping();</span><br><span class="line">......</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="六-页面交换"><a href="#六-页面交换" class="headerlink" title="六. 页面交换"></a>六. 页面交换</h2><p>  由于虚拟内存是远大于物理内存的，在物理内存中加载所有的虚拟内存页显然是异想天开，因此我们必须要有页面的交换。和CPU调度相似，页的交换也包括主动的交换和被动的交换。</p>
<ul>
<li><p>被动页面回收：当分配内存的时候发现物理内存不够用了，则尝试回收。如申请页面会调用get_page_from_freelist()，该函数会通过调用链get_page_from_freelist()-&gt;node_reclaim()-&gt;__node_reclaim()-&gt;shrink_node()尝试是否可以对当前的内存节点执行换出操作，从而腾出空</p>
</li>
<li><p>主动页面管理：在内核中，内核线程kswapd0即负责该部分的功能。下面详细展开分析一下该部分功能。</p>
<p>为了衡量内存的使用情况，kswapd0 定义了三个内存阈值（watermark，也称为水位），分别是页最小阈值（pages_min）、页低阈值（pages_low）和页高阈值（pages_high）。剩余内存，则使用 pages_free 表示。</p>
</li>
</ul>
<p><img src="https://user-images.githubusercontent.com/87457873/128138262-402a29f4-5e94-459e-95b8-1af3d8dce0f6.png" alt="image"></p>
<p>kswapd0 定期扫描内存的使用情况，并根据剩余内存落在这三个阈值的空间位置，进行内存的回收操作。</p>
<ul>
<li><p>剩余内存小于页最小阈值，说明进程可用内存都耗尽了，只有内核才可以分配内存。</p>
</li>
<li><p>剩余内存落在页最小阈值和页低阈值中间，说明内存压力比较大，剩余内存不多了。这时 kswapd0 会执行内存回收，直到剩余内存大于高阈值为止。</p>
</li>
<li><p>剩余内存落在页低阈值和页高阈值中间，说明内存有一定压力，但还可以满足新内存请求。</p>
</li>
<li><p>剩余内存大于页高阈值，说明剩余内存比较多，没有内存压力。</p>
<p>一旦剩余内存小于页低阈值，就会触发内存的回收。这个页低阈值，其实可以通过内核选项 &#x2F;proc&#x2F;sys&#x2F;vm&#x2F;min_free_kbytes 来间接设置。min_free_kbytes 设置了页最小阈值，而其他两个阈值，都是根据页最小阈值计算生成的，计算方法如下 ：</p>
</li>
</ul>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">pages_low = pages_min*<span class="number">5</span>/<span class="number">4</span></span><br><span class="line">pages_high = pages_min*<span class="number">3</span>/<span class="number">2</span></span><br></pre></td></tr></table></figure>
<p>  如下所示为kswapd()源码，核心调用链为balance_pgdat()-&gt;kswapd_shrink_node()-&gt;shrink_node()，所以被动回收和主动管理最后殊途同归，回到了同样的函数shrink_node()。</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * The background pageout daemon, started as a kernel thread</span></span><br><span class="line"><span class="comment"> * from the init process.</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * This basically trickles out pages so that we have _some_</span></span><br><span class="line"><span class="comment"> * free memory available even if there is no other activity</span></span><br><span class="line"><span class="comment"> * that frees anything up. This is needed for things like routing</span></span><br><span class="line"><span class="comment"> * etc, where we otherwise might have all activity going on in</span></span><br><span class="line"><span class="comment"> * asynchronous contexts that cannot page things out.</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * If there are applications that are active memory-allocators</span></span><br><span class="line"><span class="comment"> * (most normal use), this basically shouldn&#x27;t matter.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="type">static</span> <span class="type">int</span> <span class="title function_">kswapd</span><span class="params">(<span class="type">void</span> *p)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">unsigned</span> <span class="type">int</span> alloc_order, reclaim_order;</span><br><span class="line">    <span class="type">unsigned</span> <span class="type">int</span> classzone_idx = MAX_NR_ZONES - <span class="number">1</span>;</span><br><span class="line">    <span class="type">pg_data_t</span> *pgdat = (<span class="type">pg_data_t</span>*)p;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">task_struct</span> *<span class="title">tsk</span> =</span> current;</span><br><span class="line">......</span><br><span class="line">    <span class="keyword">for</span> ( ; ; ) &#123;</span><br><span class="line">......</span><br><span class="line">kswapd_try_sleep:</span><br><span class="line">        kswapd_try_to_sleep(pgdat, alloc_order, reclaim_order,</span><br><span class="line">                    classzone_idx);</span><br><span class="line">......</span><br><span class="line">        <span class="comment">/*</span></span><br><span class="line"><span class="comment">         * Reclaim begins at the requested order but if a high-order</span></span><br><span class="line"><span class="comment">         * reclaim fails then kswapd falls back to reclaiming for</span></span><br><span class="line"><span class="comment">         * order-0. If that happens, kswapd will consider sleeping</span></span><br><span class="line"><span class="comment">         * for the order it finished reclaiming at (reclaim_order)</span></span><br><span class="line"><span class="comment">         * but kcompactd is woken to compact for the original</span></span><br><span class="line"><span class="comment">         * request (alloc_order).</span></span><br><span class="line"><span class="comment">         */</span></span><br><span class="line">        trace_mm_vmscan_kswapd_wake(pgdat-&gt;node_id, classzone_idx,</span><br><span class="line">                        alloc_order);</span><br><span class="line">        reclaim_order = balance_pgdat(pgdat, alloc_order, classzone_idx);</span><br><span class="line">......</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>  shrink_node()实际调用shrink_node_memcg()。这里面有个 LRU 列表，所有的页面都被挂在 LRU 列表中。LRU 也就是最近最少使用。这个列表里面会按照活跃程度进行排序，这样就容易把不怎么用的内存页拿出来做处理。内存页总共分两类，一类是匿名页，和虚拟地址空间进行关联；一类是内存映射，不但和虚拟地址空间关联，还和文件管理关联。它们每一类都有两个列表，一个是 active，一个是 inactive。顾名思义，active 就是比较活跃的，inactive 就是不怎么活跃的。这两个里面的页会变化，过一段时间，活跃的可能变为不活跃，不活跃的可能变为活跃。如果要换出内存，那就是从不活跃的列表中找出最不活跃的，换出到硬盘上。</p>
<p>  shrink_list() 会先缩减活跃页面列表，再压缩不活跃的页面列表。对于不活跃列表的缩减，shrink_inactive_list() 就需要对页面进行回收；对于匿名页来讲，需要分配 swap()，将内存页写入文件系统；对于内存映射关联了文件的，我们需要将在内存中对于文件的修改写回到文件中。</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * This is a basic per-node page freer.  Used by both kswapd and direct reclaim.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="type">static</span> <span class="type">void</span> <span class="title function_">shrink_node_memcg</span><span class="params">(<span class="keyword">struct</span> pglist_data *pgdat, <span class="keyword">struct</span> mem_cgroup *memcg,</span></span><br><span class="line"><span class="params">                  <span class="keyword">struct</span> scan_control *sc, <span class="type">unsigned</span> <span class="type">long</span> *lru_pages)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">lruvec</span> *<span class="title">lruvec</span> =</span> mem_cgroup_lruvec(pgdat, memcg);</span><br><span class="line">    <span class="type">unsigned</span> <span class="type">long</span> nr[NR_LRU_LISTS];</span><br><span class="line">    <span class="type">unsigned</span> <span class="type">long</span> targets[NR_LRU_LISTS];</span><br><span class="line">    <span class="type">unsigned</span> <span class="type">long</span> nr_to_scan;</span><br><span class="line">    <span class="class"><span class="keyword">enum</span> <span class="title">lru_list</span> <span class="title">lru</span>;</span></span><br><span class="line">......</span><br><span class="line">    <span class="keyword">while</span> (nr[LRU_INACTIVE_ANON] || nr[LRU_ACTIVE_FILE] ||</span><br><span class="line">                    nr[LRU_INACTIVE_FILE]) &#123;</span><br><span class="line">        <span class="type">unsigned</span> <span class="type">long</span> nr_anon, nr_file, percentage;</span><br><span class="line">        <span class="type">unsigned</span> <span class="type">long</span> nr_scanned;</span><br><span class="line">        for_each_evictable_lru(lru) &#123;</span><br><span class="line">            <span class="keyword">if</span> (nr[lru]) &#123;</span><br><span class="line">                nr_to_scan = min(nr[lru], SWAP_CLUSTER_MAX);</span><br><span class="line">                nr[lru] -= nr_to_scan;</span><br><span class="line">                nr_reclaimed += shrink_list(lru, nr_to_scan,</span><br><span class="line">                                lruvec, memcg, sc);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">......</span><br><span class="line">&#125;</span><br><span class="line">    </span><br><span class="line"><span class="class"><span class="keyword">enum</span> <span class="title">lru_list</span> &#123;</span></span><br><span class="line">  LRU_INACTIVE_ANON = LRU_BASE,</span><br><span class="line">  LRU_ACTIVE_ANON = LRU_BASE + LRU_ACTIVE,</span><br><span class="line">  LRU_INACTIVE_FILE = LRU_BASE + LRU_FILE,</span><br><span class="line">  LRU_ACTIVE_FILE = LRU_BASE + LRU_FILE + LRU_ACTIVE,</span><br><span class="line">  LRU_UNEVICTABLE,</span><br><span class="line">  NR_LRU_LISTS</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> for_each_evictable_lru(lru) for (lru = 0; lru &lt;= LRU_ACTIVE_FILE; lru++)</span></span><br><span class="line"></span><br><span class="line"><span class="type">static</span> <span class="type">unsigned</span> <span class="type">long</span> <span class="title function_">shrink_list</span><span class="params">(<span class="keyword">enum</span> lru_list lru, <span class="type">unsigned</span> <span class="type">long</span> nr_to_scan,</span></span><br><span class="line"><span class="params">                 <span class="keyword">struct</span> lruvec *lruvec, <span class="keyword">struct</span> mem_cgroup *memcg,</span></span><br><span class="line"><span class="params">                 <span class="keyword">struct</span> scan_control *sc)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">if</span> (is_active_lru(lru)) &#123;</span><br><span class="line">        <span class="keyword">if</span> (inactive_list_is_low(lruvec, is_file_lru(lru),</span><br><span class="line">                     memcg, sc, <span class="literal">true</span>))</span><br><span class="line">            shrink_active_list(nr_to_scan, lruvec, sc, lru);</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> shrink_inactive_list(nr_to_scan, lruvec, sc, lru);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="七-总结"><a href="#七-总结" class="headerlink" title="七. 总结"></a>七. 总结</h2><p>  内存管理可谓非常复杂，本文较为详尽的介绍了内存管理中分页和页的分配相关内容，下文将继续介绍物理内存和虚拟内存的映射。</p>
]]></content>
      <categories>
        <category>linux-doc 内存管理</category>
      </categories>
      <tags>
        <tag>Linux</tag>
      </tags>
  </entry>
  <entry>
    <title>多核心Linux内核路径优化的不二法门之-slab与伙伴系统</title>
    <url>/2023/01/15/linux-docs/%E5%86%85%E5%AD%98%E7%AE%A1%E7%90%86/%E5%A4%9A%E6%A0%B8%E5%BF%83Linux%E5%86%85%E6%A0%B8%E8%B7%AF%E5%BE%84%E4%BC%98%E5%8C%96%E7%9A%84%E4%B8%8D%E4%BA%8C%E6%B3%95%E9%97%A8%E4%B9%8B-slab%E4%B8%8E%E4%BC%99%E4%BC%B4%E7%B3%BB%E7%BB%9F/</url>
    <content><![CDATA[<p>Linux内核的slab来自一种很简单的思想，即事先准备好一些会频繁分配，释放的数据结构。然而标准的slab实现太复杂且维护开销巨大，因此便分化 出了更加小巧的slub，因此本文讨论的就是slub，后面所有提到slab的地方，指的都是slub。另外又由于本文主要描述内核优化方面的内容，并不 是基本原理介绍，因此想了解slab细节以及代码实现的请自行百度或者看源码。</p>
<h2 id="单CPU上单纯的slab"><a href="#单CPU上单纯的slab" class="headerlink" title="单CPU上单纯的slab"></a>单CPU上单纯的slab</h2><p>下图给出了单CPU上slab在分配和释放对象时的情景序列：</p>
<p><img src="https://user-images.githubusercontent.com/87457873/127661860-7794aa49-2c58-4a3b-b04e-6e4606a7bc53.png" alt="image"></p>
<p>可以看出，非常之简单，而且完全达到了slab设计之初的目标。</p>
<h2 id="扩展到多核心CPU"><a href="#扩展到多核心CPU" class="headerlink" title="扩展到多核心CPU"></a>扩展到多核心CPU</h2><p>现在我们简单的将上面的模型扩展到多核心CPU，同样差不多的分配序列如下图所示：</p>
<p><img src="https://user-images.githubusercontent.com/87457873/127661919-4dd9f2f0-77e6-476b-8ebf-915761f9580d.png" alt="image"></p>
<p>我们看到，在只有单一slab的时候，如果多个CPU同时分配对象，冲突是不可避免的，解决冲突的几乎是唯一的办法就是加锁排队，然而这将大大增加延迟，我们看到，申请单一对象的整个时延从T0开始，到T4结束，这太久了。</p>
<p>多CPU无锁化并行化操作的直接思路-复制给每个CPU一套相同的数据结构。</p>
<p>不二法门就是增加“每CPU变量”。对于slab而言，可以扩展成下面的样子：</p>
<p><img src="https://user-images.githubusercontent.com/87457873/127661976-071e27e8-9ffc-4a34-bd16-be02ba3a33fd.png" alt="image"></p>
<p>如果以为这么简单就结束了，那这就太没有意义了。</p>
<h2 id="问题"><a href="#问题" class="headerlink" title="问题"></a>问题</h2><p>首先，我们来看一个简单的问题，如果单独的某个CPU的slab缓存没有对象可分配了，但是其它CPU的slab缓存仍有大量空闲对象的情况，如下图所示：</p>
<p><img src="https://user-images.githubusercontent.com/87457873/127662044-3b803ad9-f37a-4a84-9538-76168bc440da.png" alt="image"></p>
<p>这 是可能的，因为对单独一种slab的需求是和该CPU上执行的进程&#x2F;线程紧密相关的，比如如果CPU0只处理网络，那么它就会对skb等数据结构有大量的 需求，对于上图最后引出的问题，如果我们选择从伙伴系统中分配一个新的page(或者pages，取决于对象大小以及slab cache的order)，那么久而久之就会造成slab在CPU间分布的不均衡，更可能会因此吃掉大量的物理内存，这都是不希望看到的。</p>
<p>在继续之前，首先要明确的是，我们需要在CPU间均衡slab，并且这些必须靠slab内部的机制自行完成，这个和进程在CPU间负载均衡是完全不同的， 对进程而言，拥有一个核心调度机制，比如基于时间片，或者虚拟时钟的步进速率等，但是对于slab，完全取决于使用者自身，只要对象仍然在使用，就不能剥 夺使用者继续使用的权利，除非使用者自己释放。因此slab的负载均衡必须设计成合作型的，而不是抢占式的。</p>
<p>好了。现在我们知道，从伙伴系统重新分配一个page(s)并不是一个好主意，它应该是最终的决定，在执行它之前，首先要试一下别的路线。</p>
<p>现在，我们引出第二个问题，如下图所示：</p>
<p><img src="https://user-images.githubusercontent.com/87457873/127662092-f5c14a2e-5124-4231-95db-841f74e7395f.png" alt="image"></p>
<p>谁也不能保证分配slab对象的CPU和释放slab对象的CPU是同一个CPU，谁也不能保证一个CPU在一个slab对象的生命周期内没有分配新的 page(s)，这期间的复杂操作谁也没有规定。这些问题该怎么解决呢？事实上，理解了这些问题是怎么解决的，一个slab框架就彻底理解了。</p>
<h2 id="问题的解决-分层slab-cache"><a href="#问题的解决-分层slab-cache" class="headerlink" title="问题的解决-分层slab cache"></a>问题的解决-分层slab cache</h2><p>无级变速总是让人向往。</p>
<p>如果一个CPU的slab缓存满了，直接去抢同级别的别的CPU的slab缓存被认为是一种鲁莽且不道义的做法。那么为何不设置另外一个slab缓存，获 取它里面的对象不像直接获取CPU的slab缓存那么简单且直接，但是难度却又不大，只是稍微增加一点消耗，这不是很好吗？事实上，CPU的 L1，L2，L3 cache不就是这个方案设计的吗？这事实上已经成为cache设计的不二法门。这个设计思想同样作用于slab，就是Linux内核的slub实现。<br>现在可以给出概念和解释了。</p>
<ul>
<li>Linux kernel slab cache：一个分为3层的对象cache模型。</li>
<li>Level 1 slab cache：一个空闲对象链表，每个CPU一个的独享cache，分配释放对象无需加锁。</li>
<li>Level 2 slab cache：一个空闲对象链表，每个CPU一个的共享page(s) cache，分配释放对象时仅需要锁住该page(s)，与Level 1 slab cache互斥，不互相包容。</li>
<li>Level 3 slab cache：一个page(s)链表，每个NUMA NODE的所有CPU共享的cache，单位为page(s)，获取后被提升到对应CPU的Level 1 slab cache，同时该page(s)作为Level 2的共享page(s)存在。</li>
<li>共享page(s)：该page(s)被一个或者多个CPU占 有，每一个CPU在该page(s)上都可以拥有互相不充图的空闲对象链表，该page(s)拥有一个唯一的Level 2 slab cache空闲链表，该链表与上述一个或多个Level 1 slab cache空闲链表亦不冲突，多个CPU获取该Level 2 slab cache时必须争抢，获取后可以将该链表提升成自己的Level 1 slab cache。</li>
</ul>
<p>该slab cache的图示如下：</p>
<p><img src="https://user-images.githubusercontent.com/87457873/127869263-b574e7ef-21ba-4633-a048-926e8489b11a.png" alt="127662257-9c2ec8e1-7989-40f7-8413-a8016b86394c"></p>
<p>其行为如下图所示：</p>
<p><img src="https://user-images.githubusercontent.com/87457873/127662299-8e03a0bb-2917-44ba-a219-51d12674ee5a.png" alt="image"></p>
<h2 id="2个场景"><a href="#2个场景" class="headerlink" title="2个场景"></a>2个场景</h2><p>对于常规的对象分配过程，下图展示了其细节：</p>
<p><img src="https://user-images.githubusercontent.com/87457873/127662336-7c93e32e-dfd5-4d6b-9696-866f1ead7d28.png" alt="image"></p>
<p>事实上，对于多个CPU共享一个page(s)的情况，还可以有另一种玩法，如下图所示：</p>
<p><img src="https://user-images.githubusercontent.com/87457873/127662366-177b02d9-895b-4717-8b13-17dbbb59e8ee.png" alt="image"></p>
<h2 id="伙伴系统"><a href="#伙伴系统" class="headerlink" title="伙伴系统"></a>伙伴系统</h2><p>前面我们简短的体会了Linux内核的slab设计,不宜过长,太长了不易理解.但是最后,如果Level 3也没有获取page(s)，那么最终会落到终极的伙伴系统。</p>
<p>伙伴系统是为了防内存分配碎片化的，所以它尽可能地做两件事：</p>
<p><strong>1).尽量分配尽可能大的内存</strong><br><br><strong>2).尽量合并连续的小块内存成一块大内存</strong><br></p>
<p>我们可以通过下面的图解来理解上面的原则：</p>
<p><img src="https://user-images.githubusercontent.com/87457873/127662869-feeea0d4-1e27-47bd-ab30-ff9c04dc00fb.jpg" alt="wKiom1X4ieTC39RgAAWN9sx0r2g463"></p>
<p>注意，本文是关于优化的，不是伙伴系统的科普，所以我假设大家已经理解了伙伴系统。</p>
<p>鉴于slab缓存对象大多数都是不超过1个页面的小结构(不仅仅slab系统，超过1个页面的内存需求相比1个页面的内存需求，很少)，因此会有大量的针 对1个页面的内存分配需求。从伙伴系统的分配原理可知，如果持续大量分配单一页面，会有大量的order大于0的页面分裂成单一页面，在单核心CPU上， 这不是问题，但是在多核心CPU上，由于每一个CPU都会进行此类分配，而伙伴系统的分裂，合并操作会涉及大量的链表操作，这个锁开销是巨大的，因此需要 优化！</p>
<p>Linux内核对伙伴系统针对单一页面的分配需求采取的批量分配“每CPU单一页面缓存”的方式！</p>
<p>每一个CPU拥有一个单一页面缓存池，需要单一页面的时候，可以无需加锁从当前CPU对应的页面池中获取页面。而当池中页面不足时，系统会批量从伙伴系统中拉取一堆页面到池中，反过来，在单一页面释放的时候，会择优将其释放到每CPU的单一页面缓存中。</p>
<p>为了维持“每CPU单一页面缓存”中页面的数量不会太多或太少(太多会影响伙伴系统，太少会影响CPU的需求)，系统保持了两个值，当缓存页面数量低于 low值的时候，便从伙伴系统中批量获取页面到池中，而当缓存页面数量大于high的时候，便会释放一些页面到伙伴系统中。</p>
<h2 id="小结"><a href="#小结" class="headerlink" title="小结"></a>小结</h2><p>多 CPU操作系统内核中，关键的开销就是锁的开销。我认为这是一开始的设计导致的，因为一开始，多核CPU并没有出现，单核CPU上的共享保护几乎都是可以 用“禁中断”，“禁抢占”来简单实现的，到了多核时代，操作系统同样简单平移到了新的平台，因此同步操作是在单核的基础上后来添加的。简单来讲，目前的主 流操作系统都是在单核年代创造出来的，因此它们都是顺应单核环境的，对于多核环境，可能它们一开始的设计就有问题。</p>
<p>不管怎么说，优化操作的不二法门就是禁止或者尽量减少锁的操作。随之而来的思路就是为共享的关键数据结构创建”每CPU的缓存“，而这类缓存分为两种类型：</p>
<p>1).数据通路缓存。<br><br>比如路由表之类的数据结构，你可以用RCU锁来保护，当然如果为每一个CPU都创建一个本地路由表缓存，也是不错的，现在的问题是何时更新它们，因为所有的缓存都是平级的，因此一种批量同步的机制是必须的。<br><br>2).管理机制缓存。<br><br>比 如slab对象缓存这类，其生命周期完全取决于使用者，因此不存在同步问题，然而却存在管理问题。采用分级cache的思想是好的，这个非常类似于CPU 的L1&#x2F;L2&#x2F;L3缓存，采用这种平滑的开销逐渐增大，容量逐渐增大的机制，并配合以设计良好的换入&#x2F;换出等算法，效果是非常明显的。</p>
]]></content>
      <categories>
        <category>linux-doc 内存管理</category>
      </categories>
      <tags>
        <tag>Linux</tag>
      </tags>
  </entry>
  <entry>
    <title>尽情阅读，技术进阶，详解mmap原理</title>
    <url>/2023/01/15/linux-docs/%E5%86%85%E5%AD%98%E7%AE%A1%E7%90%86/%E5%B0%BD%E6%83%85%E9%98%85%E8%AF%BB%EF%BC%8C%E6%8A%80%E6%9C%AF%E8%BF%9B%E9%98%B6%EF%BC%8C%E8%AF%A6%E8%A7%A3mmap%E5%8E%9F%E7%90%86/</url>
    <content><![CDATA[<h2 id="1-一句话概括mmap"><a href="#1-一句话概括mmap" class="headerlink" title="1. 一句话概括mmap"></a>1. 一句话概括mmap</h2><p>mmap的作用，在应用这一层，是让你把文件的某一段，当作内存一样来访问。将文件映射到物理内存，将进程虚拟空间映射到那块内存。</p>
<p>这样，进程不仅能像访问内存一样读写文件，多个进程映射同一文件，还能保证虚拟空间映射到同一块物理内存，达到内存共享的作用。</p>
<h2 id="2-虚拟内存？虚拟空间？"><a href="#2-虚拟内存？虚拟空间？" class="headerlink" title="2. 虚拟内存？虚拟空间？"></a>2. 虚拟内存？虚拟空间？</h2><p>其实是一个概念，前一篇对于这个词没有确切的定义，现在定义一下：</p>
<p>虚拟空间就是进程看到的所有地址组成的空间，虚拟空间是某个进程对分配给它的所有物理地址（已经分配的和将会分配的）的重新映射。</p>
<p>而虚拟内存，为啥叫虚拟内存，是因为它就不是真正的内存，是假的，因为它是由地址组成的空间，所以在这里，使用虚拟空间这个词更加确切和易懂。（不过虚拟内存这个词也不算错）</p>
<h3 id="2-1-虚拟空间原理"><a href="#2-1-虚拟空间原理" class="headerlink" title="2.1 虚拟空间原理"></a>2.1 虚拟空间原理</h3><h4 id="2-1-1物理内存"><a href="#2-1-1物理内存" class="headerlink" title="2.1.1物理内存"></a>2.1.1物理内存</h4><p>首先，物理地址实际上也不是连续的，通常是包含作为主存的DRAM和IO寄存器</p>
<p><img src="https://user-images.githubusercontent.com/87457873/127429281-171f23f8-7e9c-41da-92d5-1cc1ca388e75.png" alt="image"></p>
<p>以前的CPU（如X86）是为IO划分单独的地址空间，所以不能用直接访问内存的方式（如指针）IO，只能用专门的方法（in&#x2F;read&#x2F;out&#x2F;write）诸如此类。</p>
<p>现在的CPU利用PCI总线将IO寄存器映射到物理内存，所以出现了基于内存访问的IO。</p>
<p>还有一点补充的，就如同进程空间有一块内核空间一样，物理内存也会有极小一部分是不能访问的，为内核所用。</p>
<h3 id="2-1-2三个总线"><a href="#2-1-2三个总线" class="headerlink" title="2.1.2三个总线"></a>2.1.2三个总线</h3><p>这里再补充下三个总线的知识，即：地址总线、数据总线、控制总线<br></p>
<ul>
<li>地址总线，用来传输地址</li>
<li>数据总线，用来传输数据</li>
<li>控制总线，用来传输命令</li>
</ul>
<p>比如CPU通过控制总线发送读取命令，同时用地址总线发送要读取的数据虚地址，经过MMU后到内存</p>
<p>内存通过数据总线将数据传输给CPU。</p>
<p>虚拟地址的空间和指令集的地址长度有关，不一定和物理地址长度一致，比如现在的64位处理器，从VA角度看来，可以访问64位的地址，但地址总线长度只有48位，所以你可以访问一个位于2^52这个位置的地址。</p>
<h4 id="2-1-3虚拟内存地址转换（虚地址转实地址）"><a href="#2-1-3虚拟内存地址转换（虚地址转实地址）" class="headerlink" title="2.1.3虚拟内存地址转换（虚地址转实地址）"></a>2.1.3虚拟内存地址转换（虚地址转实地址）</h4><p>上面已经明确了虚拟内存是虚拟空间，即地址的集合这一概念。基于此，来说说原理。</p>
<p>如果还记得操作系统课程里面提到的虚地址，那么这个虚地址就是虚拟空间的地址了，虚地址通过转换得到实地址，转换方式课程内也讲得很清楚，虚地址头部包含了页号（段地址和段大小，看存储模式：页存储、段存储，段页式），剩下部分是偏移量，经过MMU转换成实地址。</p>
<p><img src="https://user-images.githubusercontent.com/87457873/127429372-deee3016-bbe6-45d6-a4f5-97c059ec50a7.png" alt="image"></p>
<p>存储方式</p>
<p><img src="https://user-images.githubusercontent.com/87457873/127429381-f718ed00-3600-4af3-b44b-4ec782ad5efa.png" alt="image"></p>
<p>如图则是页式存储动态地址变换的方式</p>
<p>虚拟地址头部为页号通过查询页表得到物理页号，假设一页时1K，那么页号*偏移量就得到物理地址</p>
<p><img src="https://user-images.githubusercontent.com/87457873/127429396-c3cde657-870e-4a9e-a945-58639ab59726.png" alt="image"></p>
<p>如图所示，段式存储</p>
<p>虚拟地址头部为段号，段表中找到段基地址加上偏移量得到实地址</p>
<p><img src="https://user-images.githubusercontent.com/87457873/127429412-b59eddf2-8c13-4f38-822a-445fbbc253b3.png" alt="image"></p>
<p>段页式结合两者，如图所示。</p>
<h2 id="3-mmap映射"><a href="#3-mmap映射" class="headerlink" title="3. mmap映射"></a>3. mmap映射</h2><p>至此，如果对虚拟空间已经了解了，那么接下来，作为coder，应该自动把虚拟空间无视掉，因为Linux的目的也是要让更多额进程能享用内存，又不让进程做麻烦的事情，是将虚拟空间和MMU都透明化，让进程（和coder）只需要管对内存怎样使用。</p>
<p>所以现在开始不再强调虚拟空间了。</p>
<p>mmap就是将文件映射到内存上，进程直接对内存进行读写，然后就会反映到磁盘上。</p>
<p><img src="https://user-images.githubusercontent.com/87457873/127429448-ab74f77b-9808-40b4-8a6e-e909a2dd251c.png" alt="image"></p>
<ul>
<li>虚拟空间获取到一段连续的地址</li>
<li>在没有读写的时候，这个地址指向不存在的地方（所以，上图中起始地址和终止地址是还没分配给进程的）</li>
<li>好了，根据偏移量，进程要读文件数据了，数据占在两个页当中（物理内存着色部分）</li>
<li>这时，进程开始使用内存了，所以OS给这两个页分配了内存（即缺页异常）（其余部分还是没有分配）</li>
<li>然后刚分配的页内是空的，所以再将相同偏移量的文件数据拷贝到物理内存对应页上。</li>
</ul>
]]></content>
      <categories>
        <category>linux-doc 内存管理</category>
      </categories>
      <tags>
        <tag>Linux</tag>
      </tags>
  </entry>
  <entry>
    <title>浅谈Linux内存管理机制</title>
    <url>/2023/01/15/linux-docs/%E5%86%85%E5%AD%98%E7%AE%A1%E7%90%86/%E6%B5%85%E8%B0%88Linux%E5%86%85%E5%AD%98%E7%AE%A1%E7%90%86%E6%9C%BA%E5%88%B6/</url>
    <content><![CDATA[<h2 id="活学活用"><a href="#活学活用" class="headerlink" title="活学活用"></a>活学活用</h2><p>OOM Killer 在 Linux 系统里如果内存不足时，会杀死一个正在运行的进程来释放一些内存。</p>
<p>Linux 里的程序都是调用 malloc() 来申请内存，如果内存不足，直接 malloc() 返回失败就可以，为什么还要去杀死正在运行的进程呢？Linux允许进程申请超过实际物理内存上限的内存。因为 malloc() 申请的是内存的虚拟地址，系统只是给了程序一个地址范围，由于没有写入数据，所以程序并没有得到真正的物理内存。物理内存只有程序真的往这个地址写入数据的时候，才会分配给程序。</p>
<p><img src="https://user-images.githubusercontent.com/87457873/127455549-4c2bec21-7aea-4f5f-af1a-99f0774047f5.png" alt="image"></p>
<h2 id="内存管理"><a href="#内存管理" class="headerlink" title="内存管理"></a>内存管理</h2><p>对于内存的访问，用户态的进程使用虚拟地址，内核的也基本都是使用虚拟地址</p>
<h2 id="物理内存空间布局"><a href="#物理内存空间布局" class="headerlink" title="物理内存空间布局"></a>物理内存空间布局</h2><p><img src="https://user-images.githubusercontent.com/87457873/127455595-9ab58b7a-2400-4322-85bf-70a9fd7ba837.png" alt="image"></p>
<h2 id="虚拟内存与物理内存的映射"><a href="#虚拟内存与物理内存的映射" class="headerlink" title="虚拟内存与物理内存的映射"></a>虚拟内存与物理内存的映射</h2><p><img src="https://user-images.githubusercontent.com/87457873/127455619-abb98623-fa06-4d21-849a-3fd066e9bf44.png" alt="image"></p>
<h2 id="进程“独占”虚拟内存及虚拟内存划分"><a href="#进程“独占”虚拟内存及虚拟内存划分" class="headerlink" title="进程“独占”虚拟内存及虚拟内存划分"></a>进程“独占”虚拟内存及虚拟内存划分</h2><p>为了保证操作系统的稳定性和安全性。用户程序不可以直接访问硬件资源，如果用户程序需要访问硬件资源，必须调用操作系统提供的接口，这个调用接口的过程也就是系统调用。每一次系统调用都会存在两个内存空间之间的相互切换，通常的网络传输也是一次系统调用，通过网络传输的数据先是从内核空间接收到远程主机的数据，然后再从内核空间复制到用户空间，供用户程序使用。这种从内核空间到用户空间的数据复制很费时，虽然保住了程序运行的安全性和稳定性，但是牺牲了一部分的效率。</p>
<p>如何分配用户空间和内核空间的比例也是一个问题，是更多地分配给用户空间供用户程序使用，还是首先保住内核有足够的空间来运行。在当前的Windows 32位操作系统中，默认用户空间：内核空间的比例是1:1，而在32位Linux系统中的默认比例是3:1（3GB用户空间、1GB内核空间）（这里只是地址空间，映射到物理地址，可没有某个物理地址的内存只能存储内核态数据或用户态数据的说法）。</p>
<p><img src="https://user-images.githubusercontent.com/87457873/127455684-ba618153-36ba-45bb-a140-0c61eccda417.png" alt="image"></p>
<p><img src="https://user-images.githubusercontent.com/87457873/127455693-b47c1227-0223-48f0-afdd-9057abac5753.png" alt="image"></p>
<p>左右两侧均表示虚拟地址空间，左侧以描述内核空间为主，右侧以描述用户空间为主。</p>
<p><img src="https://user-images.githubusercontent.com/87457873/127455885-e3183e52-b9a5-4b06-abaf-b5e583c330e6.png" alt="image"></p>
<p>在内核里面也会有内核的代码，同样有 Text Segment、Data Segment 和 BSS Segment，别忘了内核代码也是 ELF 格式的。</p>
<p><strong>在代码上的体现</strong></p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 持有task_struct 便可以访问进程在内存中的所有数据</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">task_struct</span> &#123;</span></span><br><span class="line">    ...</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">mm_struct</span>                *<span class="title">mm</span>;</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">mm_struct</span>                *<span class="title">active_mm</span>;</span></span><br><span class="line">    ...</span><br><span class="line">    <span class="type">void</span>  *<span class="built_in">stack</span>;   <span class="comment">// 指向内核栈的指针</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>内核使用内存描述符mm_struct来表示进程的地址空间，该描述符表示着进程所有地址空间的信息</p>
<p><img src="https://user-images.githubusercontent.com/87457873/127455987-7785f4e9-b33c-46be-bf3c-423f4bfe9a20.png" alt="image"></p>
<p>在用户态，进程觉着整个空间是它独占的，没有其他进程存在。但是到了内核里面，无论是从哪个进程进来的，看到的都是同一个内核空间，看到的都是同一个进程列表。虽然内核栈是各用个的，但是如果想知道的话，还是能够知道每个进程的内核栈在哪里的。所以，如果要访问一些公共的数据结构，需要进行锁保护。</p>
<p><img src="https://user-images.githubusercontent.com/87457873/127456009-3467796e-02ce-4a58-8006-44493dad7090.png" alt="image"></p>
<h2 id="地址空间内的栈"><a href="#地址空间内的栈" class="headerlink" title="地址空间内的栈"></a>地址空间内的栈</h2><p>栈是主要用途就是支持函数调用。</p>
<p>大多数的处理器架构，都有实现硬件栈。有专门的栈指针寄存器，以及特定的硬件指令来完成 入栈&#x2F;出栈 的操作。</p>
<h3 id="用户栈和内核栈的切换"><a href="#用户栈和内核栈的切换" class="headerlink" title="用户栈和内核栈的切换"></a>用户栈和内核栈的切换</h3><p>内核在创建进程的时候，在创建task_struct的同时，会为进程创建相应的堆栈。每个进程会有两个栈，一个用户栈，存在于用户空间，一个内核栈，存在于内核空间。当进程在用户空间运行时，cpu堆栈指针寄存器里面的内容是用户堆栈地址，使用用户栈；当进程在内核空间时，cpu堆栈指针寄存器里面的内容是内核栈空间地址，使用内核栈。</p>
<p>当进程因为中断或者系统调用而陷入内核态之行时，进程所使用的堆栈也要从用户栈转到内核栈。</p>
<p>如何相互切换呢？</p>
<p>进程陷入内核态后，先把用户态堆栈的地址保存在内核栈之中，然后设置堆栈指针寄存器的内容为内核栈的地址，这样就完成了用户栈向内核栈的转换；当进程从内核态恢复到用户态执行时，在内核态执行的最后，将保存在内核栈里面的用户栈的地址恢复到堆栈指针寄存器即可。这样就实现了内核栈和用户栈的互转。</p>
<p>那么，我们知道从内核转到用户态时用户栈的地址是在陷入内核的时候保存在内核栈里面的，但是在陷入内核的时候，我们是如何知道内核栈的地址的呢？</p>
<p>关键在进程从用户态转到内核态的时候，进程的内核栈总是空的。这是因为，一旦进程从内核态返回到用户态后，内核栈中保存的信息无效，会全部恢复。因此，每次进程从用户态陷入内核的时候得到的内核栈都是空的，直接把内核栈的栈顶地址给堆栈指针寄存器就可以了。</p>
<h3 id="为什么需要单独的进程内核栈？"><a href="#为什么需要单独的进程内核栈？" class="headerlink" title="为什么需要单独的进程内核栈？"></a>为什么需要单独的进程内核栈？</h3><p>内核地址空间所有进程空闲，但内核栈却不共享。为什么需要单独的进程内核栈？因为同时可能会有多个进程在内核运行。</p>
<p>所有进程运行的时候，都可能通过系统调用陷入内核态继续执行。假设第一个进程 A 陷入内核态执行的时候，需要等待读取网卡的数据，主动调用 schedule() 让出 CPU；此时调度器唤醒了另一个进程 B，碰巧进程 B 也需要系统调用进入内核态。那问题就来了，如果内核栈只有一个，那进程 B 进入内核态的时候产生的压栈操作，必然会破坏掉进程 A 已有的内核栈数据；一但进程 A 的内核栈数据被破坏，很可能导致进程 A 的内核态无法正确返回到对应的用户态了。</p>
<p>进程内核栈在进程创建的时候，通过 slab 分配器从 thread_info_cache 缓存池中分配出来，其大小为 THREAD_SIZE，一般来说是一个页大小 4K；</p>
<h3 id="进程切换带来的用户栈切换和内核栈切换"><a href="#进程切换带来的用户栈切换和内核栈切换" class="headerlink" title="进程切换带来的用户栈切换和内核栈切换"></a>进程切换带来的用户栈切换和内核栈切换</h3><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 持有task_struct 便可以访问进程在内存中的所有数据</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">task_struct</span> &#123;</span></span><br><span class="line">    ...</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">mm_struct</span>                *<span class="title">mm</span>;</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">mm_struct</span>                *<span class="title">active_mm</span>;</span></span><br><span class="line">    ...</span><br><span class="line">    <span class="type">void</span>  *<span class="built_in">stack</span>;   <span class="comment">// 指向内核栈的指针</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>从进程 A 切换到进程 B，用户栈要不要切换呢？当然要，在切换内存空间的时候就切换了，每个进程的用户栈都是独立的，都在内存空间里面。</p>
<p>那内核栈呢？已经在 __switch_to 里面切换了，也就是将 current_task 指向当前的 task_struct。里面的 void *stack 指针，指向的就是当前的内核栈。</p>
<p>内核栈的栈顶指针呢？在 __switch_to_asm 里面已经切换了栈顶指针，并且将栈顶指针在 __switch_to加载到了 TSS 里面。</p>
<p>用户栈的栈顶指针呢？如果当前在内核里面的话，它当然是在内核栈顶部的 pt_regs 结构里面呀。当从内核返回用户态运行的时候，pt_regs 里面有所有当时在用户态的时候运行的上下文信息，就可以开始运行了。</p>
<p>主线程的用户栈和一般现成的线程栈</p>
<p><img src="https://user-images.githubusercontent.com/87457873/127456263-0f0dcfb0-22d3-4daf-bc33-bc228de941a4.png" alt="image"></p>
<p>对应着jvm 一个线程一个栈</p>
<h3 id="中断栈"><a href="#中断栈" class="headerlink" title="中断栈"></a>中断栈</h3><p>中断有点类似于我们经常说的事件驱动编程，而这个事件通知机制是怎么实现的呢，硬件中断的实现通过一个导线和 CPU 相连来传输中断信号，软件上会有特定的指令，例如执行系统调用创建线程的指令，而 CPU 每执行完一个指令，就会检查中断寄存器中是否有中断，如果有就取出然后执行该中断对应的处理程序。</p>
<p>当系统收到中断事件后，进行中断处理的时候，也需要中断栈来支持函数调用。由于系统中断的时候，系统当然是处于内核态的，所以中断栈是可以和内核栈共享的。但是具体是否共享，这和具体处理架构密切相关。ARM 架构就没有独立的中断栈。</p>
<h2 id="内存管理的进程和硬件背景"><a href="#内存管理的进程和硬件背景" class="headerlink" title="内存管理的进程和硬件背景"></a>内存管理的进程和硬件背景</h2><h3 id="页表的位置"><a href="#页表的位置" class="headerlink" title="页表的位置"></a>页表的位置</h3><p>每个进程都有独立的地址空间，为了这个进程独立完成映射，每个进程都有独立的进程页表，这个页表的最顶级的 pgd 存放在 task_struct 中的 mm_struct 的 pgd 变量里面。</p>
<p>在一个进程新创建的时候，会调用 fork，对于内存的部分会调用 copy_mm，里面调用 dup_mm。</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">// Allocate a new mm structure and copy contents from the mm structure of the passed in task structure.</span></span><br><span class="line"><span class="type">static</span> <span class="keyword">struct</span> mm_struct *<span class="title function_">dup_mm</span><span class="params">(<span class="keyword">struct</span> task_struct *tsk)</span>&#123;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">mm_struct</span> *<span class="title">mm</span>, *<span class="title">oldmm</span> =</span> current-&gt;mm;</span><br><span class="line">    mm = allocate_mm();</span><br><span class="line">    <span class="built_in">memcpy</span>(mm, oldmm, <span class="keyword">sizeof</span>(*mm));</span><br><span class="line">    <span class="keyword">if</span> (!mm_init(mm, tsk, mm-&gt;user_ns))</span><br><span class="line">        <span class="keyword">goto</span> fail_nomem;</span><br><span class="line">    err = dup_mmap(mm, oldmm);</span><br><span class="line">    <span class="keyword">return</span> mm;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>除了创建一个新的 mm_struct，并且通过memcpy将它和父进程的弄成一模一样之外，我们还需要调用 mm_init 进行初始化。接下来，mm_init 调用 mm_alloc_pgd，分配全局页目录项，赋值给mm_struct 的 pdg 成员变量。</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">static</span> <span class="keyword">inline</span> <span class="type">int</span> <span class="title function_">mm_alloc_pgd</span><span class="params">(<span class="keyword">struct</span> mm_struct *mm)</span>&#123;</span><br><span class="line">    mm-&gt;pgd = pgd_alloc(mm);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>一个进程的虚拟地址空间包含用户态和内核态两部分。为了从虚拟地址空间映射到物理页面，页表也分为用户地址空间的页表和内核页表。在内核里面，映射靠内核页表，这里内核页表会拷贝一份到进程的页表</p>
<p>如果是用户态进程页表，会有 mm_struct 指向进程顶级目录 pgd，对于内核来讲，也定义了一个 mm_struct，指向 swapper_pg_dir（指向内核最顶级的目录 pgd）。</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">mm_struct</span> <span class="title">init_mm</span> =</span> &#123;</span><br><span class="line">    .mm_rb		= RB_ROOT,</span><br><span class="line">    <span class="comment">// pgd 页表最顶级目录</span></span><br><span class="line">    .pgd		= swapper_pg_dir,</span><br><span class="line">    .mm_users	= ATOMIC_INIT(<span class="number">2</span>),</span><br><span class="line">    .mm_count	= ATOMIC_INIT(<span class="number">1</span>),</span><br><span class="line">    .mmap_sem	= __RWSEM_INITIALIZER(init_mm.mmap_sem),</span><br><span class="line">    .page_table_lock =  __SPIN_LOCK_UNLOCKED(init_mm.page_table_lock),</span><br><span class="line">    .mmlist		= LIST_HEAD_INIT(init_mm.mmlist),</span><br><span class="line">    .user_ns	= &amp;init_user_ns,</span><br><span class="line">    INIT_MM_CONTEXT(init_mm)</span><br><span class="line">&#125;;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h3 id="页表的应用"><a href="#页表的应用" class="headerlink" title="页表的应用"></a>页表的应用</h3><p>一个进程 fork 完毕之后，有了内核页表（内核初始化时即弄好了内核页表， 所有进程共享），有了自己顶级的 pgd，但是对于用户地址空间来讲，还完全没有映射过（用户空间页表一开始是不完整的，只有最顶级目录pgd这个“光杆司令”）。这需要等到这个进程在某个 CPU 上运行，并且对内存访问的那一刻了</p>
<p>当这个进程被调度到某个 CPU 上运行的时候，要调用 context_switch 进行上下文切换。对于内存方面的切换会调用 switch_mm_irqs_off，这里面会调用 load_new_mm_cr3。</p>
<p>cr3 是 CPU 的一个寄存器，它会指向当前进程的顶级 pgd。如果 CPU 的指令要访问进程的虚拟内存，它就会自动从cr3 里面得到 pgd 在物理内存的地址，然后根据里面的页表解析虚拟内存的地址为物理内存，从而访问真正的物理内存上的数据。</p>
<p>这里需要注意两点。第一点，cr3 里面存放当前进程的顶级 pgd，这个是硬件的要求。cr3 里面需要存放 pgd 在物理内存的地址，不能是虚拟地址。第二点，用户进程在运行的过程中，访问虚拟内存中的数据，会被 cr3 里面指向的页表转换为物理地址后，才在物理内存中访问数据，这个过程都是在用户态运行的，地址转换的过程无需进入内核态。</p>
<p><img src="https://user-images.githubusercontent.com/87457873/127456588-09c55439-71a1-4726-9e8c-b1779dd61db8.png" alt="image"></p>
<p>这就可以解释，为什么页表数据在 task_struct 的mm_struct里却又 可以融入硬件地址翻译机制了。</p>
<h3 id="通过缺页中断来“填充”页表"><a href="#通过缺页中断来“填充”页表" class="headerlink" title="通过缺页中断来“填充”页表"></a>通过缺页中断来“填充”页表</h3><p>内存管理并不直接分配物理内存，只有等你真正用的那一刻才会开始分配。只有访问虚拟内存的时候，发现没有映射多物理内存，页表也没有创建过，才触发缺页异常。进入内核调用 do_page_fault，一直调用到 __handle_mm_fault，__handle_mm_fault 调用 pud_alloc 和 pmd_alloc，来创建相应的页目录项，最后调用 handle_pte_fault 来创建页表项。</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">static</span> noinline <span class="type">void</span></span><br><span class="line">__do_page_fault(<span class="keyword">struct</span> pt_regs *regs, <span class="type">unsigned</span> <span class="type">long</span> error_code,</span><br><span class="line">        <span class="type">unsigned</span> <span class="type">long</span> address)&#123;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">vm_area_struct</span> *<span class="title">vma</span>;</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">task_struct</span> *<span class="title">tsk</span>;</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">mm_struct</span> *<span class="title">mm</span>;</span></span><br><span class="line">    tsk = current;</span><br><span class="line">    mm = tsk-&gt;mm;</span><br><span class="line">    <span class="comment">// 判断缺页是否发生在内核</span></span><br><span class="line">    <span class="keyword">if</span> (unlikely(fault_in_kernel_space(address))) &#123;</span><br><span class="line">        <span class="keyword">if</span> (vmalloc_fault(address) &gt;= <span class="number">0</span>)</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    ......</span><br><span class="line">    <span class="comment">// 找到待访问地址所在的区域 vm_area_struct</span></span><br><span class="line">    vma = find_vma(mm, address);</span><br><span class="line">    ......</span><br><span class="line">    fault = handle_mm_fault(vma, address, flags);</span><br><span class="line">    ......</span><br><span class="line"></span><br><span class="line"><span class="type">static</span> <span class="type">int</span> __handle_mm_fault(<span class="keyword">struct</span> vm_area_struct *vma, <span class="type">unsigned</span> <span class="type">long</span> address,</span><br><span class="line">        <span class="type">unsigned</span> <span class="type">int</span> flags)&#123;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">vm_fault</span> <span class="title">vmf</span> =</span> &#123;</span><br><span class="line">        .vma = vma,</span><br><span class="line">        .address = address &amp; PAGE_MASK,</span><br><span class="line">        .flags = flags,</span><br><span class="line">        .pgoff = linear_page_index(vma, address),</span><br><span class="line">        .gfp_mask = __get_fault_gfp_mask(vma),</span><br><span class="line">    &#125;;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">mm_struct</span> *<span class="title">mm</span> =</span> vma-&gt;vm_mm;</span><br><span class="line">    <span class="type">pgd_t</span> *pgd;</span><br><span class="line">    <span class="type">p4d_t</span> *p4d;</span><br><span class="line">    <span class="type">int</span> ret;</span><br><span class="line">    pgd = pgd_offset(mm, address);</span><br><span class="line">    p4d = p4d_alloc(mm, pgd, address);</span><br><span class="line">    ......</span><br><span class="line">    vmf.pud = pud_alloc(mm, p4d, address);</span><br><span class="line">    ......</span><br><span class="line">    vmf.pmd = pmd_alloc(mm, vmf.pud, address);</span><br><span class="line">    ......</span><br><span class="line">    <span class="keyword">return</span> handle_pte_fault(&amp;vmf);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>以handle_pte_fault 的一种场景 do_anonymous_page为例：先通过 pte_alloc 分配一个页表项，然后通过 alloc_zeroed_user_highpage_movable 分配一个页，接下来要调用 mk_pte，将页表项指向新分配的物理页，set_pte_at 会将页表项塞到页表里面。</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">static</span> <span class="type">int</span> <span class="title function_">do_anonymous_page</span><span class="params">(<span class="keyword">struct</span> vm_fault *vmf)</span>&#123;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">vm_area_struct</span> *<span class="title">vma</span> =</span> vmf-&gt;vma;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">mem_cgroup</span> *<span class="title">memcg</span>;</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">page</span> *<span class="title">page</span>;</span></span><br><span class="line">    <span class="type">int</span> ret = <span class="number">0</span>;</span><br><span class="line">    <span class="type">pte_t</span> entry;</span><br><span class="line">    ......</span><br><span class="line">    <span class="keyword">if</span> (pte_alloc(vma-&gt;vm_mm, vmf-&gt;pmd, vmf-&gt;address))</span><br><span class="line">        <span class="keyword">return</span> VM_FAULT_OOM;</span><br><span class="line">    ......</span><br><span class="line">    page = alloc_zeroed_user_highpage_movable(vma, vmf-&gt;address);</span><br><span class="line">    ......</span><br><span class="line">    entry = mk_pte(page, vma-&gt;vm_page_prot);</span><br><span class="line">    <span class="keyword">if</span> (vma-&gt;vm_flags &amp; VM_WRITE)</span><br><span class="line">        entry = pte_mkwrite(pte_mkdirty(entry));</span><br><span class="line">    vmf-&gt;pte = pte_offset_map_lock(vma-&gt;vm_mm, vmf-&gt;pmd, vmf-&gt;address,</span><br><span class="line">            &amp;vmf-&gt;ptl);</span><br><span class="line">    ......</span><br><span class="line">    set_pte_at(vma-&gt;vm_mm, vmf-&gt;address, vmf-&gt;pte, entry);</span><br><span class="line">    ......</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>linux-doc 内存管理</category>
      </categories>
      <tags>
        <tag>Linux</tag>
      </tags>
  </entry>
  <entry>
    <title>熟读精思，熟读玩味，Linux虚拟内存管理，MMU机制，原来如此也</title>
    <url>/2023/01/15/linux-docs/%E5%86%85%E5%AD%98%E7%AE%A1%E7%90%86/%E7%86%9F%E8%AF%BB%E7%B2%BE%E6%80%9D%EF%BC%8C%E7%86%9F%E8%AF%BB%E7%8E%A9%E5%91%B3%EF%BC%8CLinux%E8%99%9A%E6%8B%9F%E5%86%85%E5%AD%98%E7%AE%A1%E7%90%86%EF%BC%8CMMU%E6%9C%BA%E5%88%B6%EF%BC%8C%E5%8E%9F%E6%9D%A5%E5%A6%82%E6%AD%A4%E4%B9%9F/</url>
    <content><![CDATA[<h2 id="MMU"><a href="#MMU" class="headerlink" title="MMU"></a>MMU</h2><p>现代操作系统普遍采用虚拟内存管理（Virtual Memory Management）机制，这需要处理器中的MMU（Memory Management Unit，内存管理单元）提供支持。</p>
<p>首先引入 PA 和 VA 两个概念。</p>
<h2 id="PA"><a href="#PA" class="headerlink" title="PA"></a>PA</h2><p>如果处理器没有MMU，或者有MMU但没有启用，CPU执行单元发出的内存地址将直接传到芯片引脚上，被内存芯片（以下称为物理内存，以便与虚拟内存区分）接收，这称为PA（Physical Address，以下简称PA），如下图所示。</p>
<p><img src="https://user-images.githubusercontent.com/87457873/127427861-3e570e26-bc38-4f7c-9bea-39838f710081.png" alt="image"></p>
<h2 id="VA"><a href="#VA" class="headerlink" title="VA"></a>VA</h2><p>如果处理器启用了MMU，CPU执行单元发出的内存地址将被MMU截获，从CPU到MMU的地址称为虚拟地址（Virtual Address，以下简称VA），而MMU将这个地址翻译成另一个地址发到CPU芯片的外部地址引脚上，也就是将VA映射成PA，如下图所示。</p>
<p><img src="https://user-images.githubusercontent.com/87457873/127427893-f5b2ed4b-d905-40c3-9898-ea9ff060d4bd.png" alt="image"></p>
<p>如果是32位处理器，则内地址总线是32位的，与CPU执行单元相连（图中只是示意性地画了4条地址线），而经过MMU转换之后的外地址总线则不一定是32位的。也就是说，虚拟地址空间和物理地址空间是独立的，32位处理器的虚拟地址空间是4GB，而物理地址空间既可以大于也可以小于4GB。</p>
<p>MMU将VA映射到PA是以页（Page）为单位的，32位处理器的页尺寸通常是4KB。例如，MMU可以通过一个映射项将VA的一页0xb7001000<del>0xb7001fff映射到PA的一页0x2000</del>0x2fff，如果CPU执行单元要访问虚拟地址0xb7001008，则实际访问到的物理地址是0x2008。物理内存中的页称为物理页面或者页帧（Page Frame）。虚拟内存的哪个页面映射到物理内存的哪个页帧是通过页表（Page Table）来描述的，页表保存在物理内存中，MMU会查找页表来确定一个VA应该映射到什么PA。</p>
<h2 id="进程地址空间"><a href="#进程地址空间" class="headerlink" title="进程地址空间"></a>进程地址空间</h2><p><img src="https://user-images.githubusercontent.com/87457873/127427923-59164b9b-fd56-4cca-9a77-d8adee1eb927.png" alt="image"></p>
<p>x86平台的虚拟地址空间是0x0000 0000<del>0xffff ffff，大致上前3GB（0x0000 0000</del>0xbfff ffff）是用户空间，后1GB（0xc000 0000~0xffff ffff）是内核空间。</p>
<p>Text Segmest 和 Data Segment</p>
<ul>
<li>Text Segment，包含.text段、.rodata段、.plt段等。是从&#x2F;bin&#x2F;bash加载到内存的，访问权限为r-x。</li>
<li>Data Segment，包含.data段、.bss段等。也是从&#x2F;bin&#x2F;bash加载到内存的，访问权限为rw-。</li>
</ul>
<h2 id="堆和栈"><a href="#堆和栈" class="headerlink" title="堆和栈"></a>堆和栈</h2><ul>
<li>堆（heap）：堆说白了就是电脑内存中的剩余空间，malloc函数动态分配内存是在这里分配的。在动态分配内存时堆空间是可以向高地址增长的。堆空间的地址上限称为Break，堆空间要向高地址增长就要抬高Break，映射新的虚拟内存页面到物理内存，这是通过系统调用brk实现的，malloc函数也是调用brk向内核请求分配内存的。</li>
<li>栈（stack）：栈是一个特定的内存区域，其中高地址的部分保存着进程的环境变量和命令行参数，低地址的部分保存函数栈帧，栈空间是向低地址增长的，但显然没有堆空间那么大的可供增长的余地，因为实际的应用程序动态分配大量内存的并不少见，但是有几十层深的函数调用并且每层调用都有很多局部变量的非常少见。</li>
</ul>
<p>如果写程序的时候没有注意好内存的分配问题，在堆和栈这两个地方可能产生以下几种问题：</p>
<p>1、内存泄露：如果你在一个函数里通过 malloc 在堆里申请了一块空间，并在栈里声明一个指针变量保存它，那么当该函数结束时，该函数的成员变量将会被释放，包括这个指针变量，那么这块空间也就找不回来了，也就无法得到释放。久而久之，可能造成下面的内存泄露问题。<br><br>2、栈溢出：如果你放太多数据到栈中（例如大型的结构体和数组），那么就可能会造成“栈溢出”（Stack Overflow）问题，程序也将会终止。为了避免这个问题，在声明这类变量时应使用 malloc 申请堆的空间。<br><br>3、野指针 和 段错误：如果一个指针所指向的空间已经被释放，此时再试图用该指针访问已经被释放了的空间将会造成“段错误”（Segment Fault）问题。此时指针已经变成野指针，应该及时手动将野指针置空。<br></p>
<h2 id="虚拟内存管理的作用"><a href="#虚拟内存管理的作用" class="headerlink" title="虚拟内存管理的作用"></a>虚拟内存管理的作用</h2><p>1、虚拟内存管理可以控制物理内存的访问权限。物理内存本身是不限制访问的，任何地址都可以读写，而操作系统要求不同的页面具有不同的访问权限，这是利用CPU模式和MMU的内存保护机制实现的。<br><br>2、虚拟内存管理最主要的作用是让每个进程有独立的地址空间。所谓独立的地址空间是指，不同进程中的同一个VA被MMU映射到不同的PA，并且在某一个进程中访问任何地址都不可能访问到另外一个进程的数据，这样使得任何一个进程由于执行错误指令或恶意代码导致的非法内存访问都不会意外改写其它进程的数据，不会影响其它进程的运行，从而保证整个系统的稳定性。另一方面，每个进程都认为自己独占整个虚拟地址空间，这样链接器和加载器的实现会比较容易，不必考虑各进程的地址范围是否冲突。<br></p>
<p><img src="https://user-images.githubusercontent.com/87457873/127428070-9b54fd66-034e-4b57-b5ba-948b5611d9b8.png" alt="image"></p>
<p>3、VA到PA的映射会给分配和释放内存带来方便，物理地址不连续的几块内存可以映射成虚拟地址连续的一块内存。比如要用malloc分配一块很大的内存空间，虽然有足够多的空闲物理内存，却没有足够大的连续空闲内存，这时就可以分配多个不连续的物理页面而映射到连续的虚拟地址范围。</p>
<p><img src="https://user-images.githubusercontent.com/87457873/127428084-23b8e2ca-a89e-4ea3-8ec7-c96a6d2848ea.png" alt="image"></p>
<p>4、一个系统如果同时运行着很多进程，为各进程分配的内存之和可能会大于实际可用的物理内存，虚拟内存管理使得这种情况下各进程仍然能够正常运行。因为各进程分配的只不过是虚拟内存的页面，这些页面的数据可以映射到物理页面，也可以临时保存到磁盘上而不占用物理页面，在磁盘上临时保存虚拟内存页面的可能是一个磁盘分区，也可能是一个磁盘文件，称为交换设备（Swap Device）。当物理内存不够用时，将一些不常用的物理页面中的数据临时保存到交换设备，然后这个物理页面就认为是空闲的了，可以重新分配给进程使用，这个过程称为换出（Page out）。如果进程要用到被换出的页面，就从交换设备再加载回物理内存，这称为换入（Page in）。换出和换入操作统称为换页（Paging），因此：[\mbox{系统中可分配的内存总量} &#x3D; \mbox{物理内存的大小} + \mbox{交换设备的大小}]</p>
<p>如下图所示。第一张图是换出，将物理页面中的数据保存到磁盘，并解除地址映射，释放物理页面。第二张图是换入，从空闲的物理页面中分配一个，将磁盘暂存的页面加载回内存，并建立地址映射。</p>
<p><img src="https://user-images.githubusercontent.com/87457873/127428113-d8d630b3-cbce-4740-bbf5-06e330a9c57e.png" alt="image"></p>
<h2 id="malloc-和-free"><a href="#malloc-和-free" class="headerlink" title="malloc 和 free"></a>malloc 和 free</h2><p>C标准库函数malloc可以在堆空间动态分配内存，它的底层通过brk系统调用向操作系统申请内存。动态分配的内存用完之后可以用free释放，更准确地说是归还给malloc，这样下次调用malloc时这块内存可以再次被分配。</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">void</span> *<span class="title function_">malloc</span><span class="params">(<span class="type">size_t</span> size)</span>;</span><br><span class="line">返回值：成功返回所分配内存空间的首地址，出错返回<span class="literal">NULL</span></span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">free</span><span class="params">(<span class="type">void</span> *ptr)</span>;</span><br></pre></td></tr></table></figure>

<p>malloc的参数size表示要分配的字节数，如果分配失败（可能是由于系统内存耗尽）则返回NULL。由于malloc函数不知道用户拿到这块内存要存放什么类型的数据，所以返回通用指针void *，用户程序可以转换成其它类型的指针再访问这块内存。malloc函数保证它返回的指针所指向的地址满足系统的对齐要求，例如在32位平台上返回的指针一定对齐到4字节边界，以保证用户程序把它转换成任何类型的指针都能用。<br>动态分配的内存用完之后可以用free释放掉，传给free的参数正是先前malloc返回的内存块首地址。</p>
<p><strong>示例</strong></p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> &#123;</span></span><br><span class="line">    <span class="type">int</span> number;</span><br><span class="line">    <span class="type">char</span> *msg;</span><br><span class="line">&#125; <span class="type">unit_t</span>;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">(<span class="type">void</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">unit_t</span> *p = <span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(<span class="type">unit_t</span>));</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (p == <span class="literal">NULL</span>) &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;out of memory\n&quot;</span>);</span><br><span class="line">        <span class="built_in">exit</span>(<span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    p-&gt;number = <span class="number">3</span>;</span><br><span class="line">    p-&gt;msg = <span class="built_in">malloc</span>(<span class="number">20</span>);</span><br><span class="line">    <span class="built_in">strcpy</span>(p-&gt;msg, <span class="string">&quot;Hello world!&quot;</span>);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;number: %d\nmsg: %s\n&quot;</span>, p-&gt;number, p-&gt;msg);</span><br><span class="line">    <span class="built_in">free</span>(p-&gt;msg);</span><br><span class="line">    <span class="built_in">free</span>(p);</span><br><span class="line">    p = <span class="literal">NULL</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>说明</strong></p>
<ul>
<li><code>unit_t *p = malloc(sizeof(unit_t))</code>;这一句，等号右边是<code>void *</code>类型，等号左边是<code>unit_t *</code>类型，编译器会做隐式类型转换，我们讲过<code>void *</code>类型和任何指针类型之间可以相互隐式转换。</li>
<li>虽然内存耗尽是很不常见的错误，但写程序要规范，malloc之后应该判断是否成功。以后要学习的大部分系统函数都有成功的返回值和失败的返回值，每次调用系统函数都应该判断是否成功。</li>
<li><code>free(p)</code>;之后，p所指的内存空间是归还了，但是p的值并没有变，因为从free的函数接口来看根本就没法改变p的值，p现在指向的内存空间已经不属于用户，换句话说，p成了野指针，为避免出现野指针，我们应该在<code>free(p)</code>;之后手动置<code>p = NULL</code>;。</li>
<li>应该先<code>free(p-&gt;msg)</code>，再<code>free(p)</code>。如果先<code>free(p)</code>，p成了野指针，就不能再通过<code>p-&gt;msg</code>访问内存了。</li>
</ul>
<h2 id="内存泄漏"><a href="#内存泄漏" class="headerlink" title="内存泄漏"></a>内存泄漏</h2><p>如果一个程序长年累月运行（例如网络服务器程序），并且在循环或递归中调用malloc分配内存，则必须有free与之配对，分配一次就要释放一次，否则每次循环都分配内存，分配完了又不释放，就会慢慢耗尽系统内存，这种错误称为内存泄漏（Memory Leak）。另外，malloc返回的指针一定要保存好，只有把它传给free才能释放这块内存，如果这个指针丢失了，就没有办法free这块内存了，也会造成内存泄漏。例如：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">foo</span><span class="params">(<span class="type">void</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">char</span> *p = <span class="built_in">malloc</span>(<span class="number">10</span>);</span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>foo函数返回时要释放局部变量p的内存空间，它所指向的内存地址就丢失了，这10个字节也就没法释放了。内存泄漏的Bug很难找到，因为它不会像访问越界一样导致程序运行错误，少量内存泄漏并不影响程序的正确运行，大量的内存泄漏会使系统内存紧缺，导致频繁换页，不仅影响当前进程，而且把整个系统都拖得很慢。</p>
<p>关于malloc和free还有一些特殊情况。malloc(0)这种调用也是合法的，也会返回一个非NULL的指针，这个指针也可以传给free释放，但是不能通过这个指针访问内存。free(NULL)也是合法的，不做任何事情，但是free一个野指针是不合法的，例如先调用malloc返回一个指针p，然后连着调用两次free§;，则后一次调用会产生运行时错误。</p>
]]></content>
      <categories>
        <category>linux-doc 内存管理</category>
      </categories>
      <tags>
        <tag>Linux</tag>
      </tags>
  </entry>
  <entry>
    <title>硬件原理 和 分页管理</title>
    <url>/2023/01/15/linux-docs/%E5%86%85%E5%AD%98%E7%AE%A1%E7%90%86/%E7%A1%AC%E4%BB%B6%E5%8E%9F%E7%90%86%20%E5%92%8C%20%E5%88%86%E9%A1%B5%E7%AE%A1%E7%90%86/</url>
    <content><![CDATA[<h3 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h3><p>内存管理相对复杂，涉及到硬件和软件，从微机原理到应用程序到内核。比如，硬件上的cache，CPU如何去寻址内存，页表， DMA，IOMMU。 软件上，要知道底层怎么分配内存，怎么管理内存，应用程序怎么申请内存。</p>
<p>常见的误解包括：</p>
<p>对free命令 cache和buffer的理解。<br><br>1、应用程序申请10M内存，申请成功其实并没有分配。内存其实是边写边拿。代码段有10M，并不是真的内存里占了10M。<br><br>2、内存管理学习难，一是网上的资料不准确，二是学习时执行代码，具有欺骗性。看到的东西不一定真实，要想理解必须陷入Linux本身。</p>
<p>学习时，不要过快陷入太多细节，而要先对整个流程整个框架理解。</p>
<p>先理清楚脉络和主干，从硬件到最底层内存的分配算法，–&gt;到内核的内存分配算法，–&gt;应用程序与内核的交互，–&gt;到内存如何做磁盘的缓存， –&gt; 内存如何和磁盘替换。</p>
<p>再动手实践demo。</p>
<h3 id="硬件原理-和-分页管理"><a href="#硬件原理-和-分页管理" class="headerlink" title="硬件原理 和 分页管理"></a>硬件原理 和 分页管理</h3><p>本文主要让大家理解内存管理最底层的buddy算法，内存为什么要分成多个Zone?</p>
<ul>
<li>CPU寻址内存，虚拟地址、物理地址</li>
<li>MMU 以及RWX权限、kernel和user模式权限</li>
<li>内存的zone: DMA、Normal和HIGHMEM</li>
<li>Linux内存管理Buddy算法</li>
<li>连续内存分配器（CMA）</li>
</ul>
<p>内存分页</p>
<p><img src="https://user-images.githubusercontent.com/87457873/127086457-a68a78f3-b6c5-45e8-833e-fd1dbdd51dc8.png" alt="image"></p>
<p>CPU 一旦开启MMU，MMU是个硬件。CPU就只知道虚拟地址了。如果地址是32位，0x12345670 。</p>
<p>假设MMU的管理是把每一页的内存分成4K，那么其中的670是页内偏移，作为d；0x12345 是页号，作为p。通过虚拟地址去查对应的物理地址，用0x12345去查一张页表，页表（Page table）本身在内存。</p>
<p>硬件里有寄存器，记录页表的基地址，每次进程切换时，寄存器就会更新一次，因为每个进程的页表不同。</p>
<p>CPU一旦访问虚拟地址，通过页表查到页表项，页表项记录对应的物理地址。</p>
<p>总结：一旦开启MMU，CPU只能看到虚拟地址，MMU才能看到物理地址。<br><br>虚拟地址是指针，物理地址是个整数。内存中的一切均通过虚拟地址来访问。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">typedef u64 phys_addr_t;</span><br></pre></td></tr></table></figure>
<p>去内存里读取页表会比较慢，CPU里有个高速单元tlb，它是页表的高速缓存。CPU就不需要在内存里读页表，直接在tlb中读取，从虚拟地址到物理地址的映射。如果tlb中读取不到，才回到内存里读取页表映射，并且在tlb中命中。</p>
<p>虚拟地址：0x12345 670 –&gt; 1M</p>
<p>物理地址：1M+670 MMU去访问这个物理地址。</p>
<p>内存的映射以页为单位。</p>
<h3 id="页表（Page-table）记录的页权限"><a href="#页表（Page-table）记录的页权限" class="headerlink" title="页表（Page table）记录的页权限"></a>页表（Page table）记录的页权限</h3><p>cpu虚拟地址，mmu根据cpu请求的虚拟地址，访问页表，查得物理地址。</p>
<p>每个MMU中的页表项，除了有虚拟地址到物理地址的映射之外，还可以标注这个页的 RWX权限和 kernel和user模式权限（用户空间,内核空间读取地址的权限），它们是内存管理两个的非常重要的权限。</p>
<p>一是，这一页地址的RWX权限 ，标记这4k地址的权限。一般用来做保护。</p>
<p>Pagefault，是CPU提供的功能。两种情况会出现Pagefault，一是，CPU通过虚拟地址没有查到对应的物理地址。二是，MMU没有访问物理地址的权限。</p>
<p>MPU，memory protection unit.</p>
<p>二是，MMU的页表项中，还可以标注这一页的地址：可以在内核态访问，还是只能在用户态访问。用户一般映射到0～3G，只有当CPU陷入到内核模式，才可以访问3G以上地址。</p>
<p>程序在用户态运行，处于CPU非特权模式，不能访问特权模式才能访问的内存。内核运行在CPU的特权模式，从用户态陷入到内核态，发送 软中断指令，CPU进行切环，x86从3环切到0环，到一个固定的地址去执行。软件就从非特权模式，跳到特权模式去执行。</p>
<p>MMU，能把某一段地址指定为只有特权模式才能够访问，会把内核空间3G以上的页表项里的每一行，指定为只有CPU 0环才能访问。应用程序没有陷入到内核态，是无法访问内核态的东西。</p>
<p>intel的漏洞meltdown，就是让用户可以在用户态读到内核态的东西。</p>
<p>meltdown 攻击原理： 基于时间的 旁路攻击 side-channel</p>
<p>李小璐买汉堡的故事 –&gt; 安全的基于时间的旁路攻击技巧。</p>
<p>比如试探用户名，密码。比如一个软件比较傻，每次第一个字母就不对，就不对比第2个字母了。那我每次26个字母实验换一次，看哪个字母反弹地最慢，就证明是这个字母的密码。</p>
<p>密码是abc, 我敲了d，那么第一个字母就不对，软件这个时候如果快速的返回出错，我知道首字母不是d，我可以实验出来首字母是a，然后接着一个个字母实，就可以把密码试探出来了。类似地原理。。</p>
<p>下面的这个例子，演示 page table记录的RWX权限的作用</p>
<p><img src="https://user-images.githubusercontent.com/87457873/127086646-3cecc3c9-d82b-4098-86a1-bbe1d6b1b753.png" alt="image"></p>
<p>页表的权限，RWX权限，和 用户空间,内核空间读取的权限。</p>
<h3 id="内存分Zone"><a href="#内存分Zone" class="headerlink" title="内存分Zone"></a>内存分Zone</h3><p>下面解释内存为什么分Zone? DMA zone.</p>
<p><img src="https://user-images.githubusercontent.com/87457873/127086714-76ef3e8a-da19-4267-86e4-1ec96ad1d73f.png" alt="image"></p>
<p>内存的分Zone，全都是物理地址的概念。内存条，被分为三个Zone。</p>
<p>分DMA Zone的原因，是DMA引擎的缺陷。DMA引擎 可以直接访问内存空间的地址，但不一定能够访问到所有的内存，访问内存时会存在一定的限制。</p>
<p>当CPU 和DMA同时访问内存时，硬件上会有仲裁器，选择优先级高的去访问内存。</p>
<p>为什么要切DMA zone?<br>DMA Zone的大小，是由硬件决定的。访问不到更高的内存。</p>
<p>什么叫做 normal zone? highmem zone?</p>
<p>highmem和lowmem 都是指的内存条，在虚拟地址空间，只能称为highmem，lowmem映射区。</p>
<p>如上图，内存虚拟地址空间0～4G，3～4G是内核空间的虚拟地址，0-3G 是用户空间的虚拟地址。</p>
<p>内核空间，访问任何一片内存都要虚拟地址。Linux为了简化内存访问，开机就把lowmem的物理地址一一映射到虚拟地址。highmem 地址包括了 normal + DMA。</p>
<p><img src="https://user-images.githubusercontent.com/87457873/127086768-f2c49b98-f924-48e2-abd2-b83d9f241ca4.png" alt="image"></p>
<p>lowmem是开机就直接映射好的内存，CPU访问这片内存，也是通过3G以上的虚拟地址。这段地址的虚拟地址和物理地址是直接线性映射，通过linux的两个api （phys_to_virt &#x2F; virt_to_phys）在虚拟和物理之间进行映射, highmem 不能直接用。</p>
<p>内核空间一般不使用highmem，内核一般使用kmalloc在lowmem申请内存，使用 kmmap在highmem 申请内存。lowmem 映射了，并不代表被内核使用掉了，只是不需要重建页表。内核使用lowmem内存，同样是要申请。 应用程序一样可以申请 lowmem 和highmem。</p>
<p>总结：<br><br>内存分highmem zone的原因，地址空间整体不够。<br><br>DMA zone产生的原因，硬件DMA引擎的访问缺陷。<br></p>
<p><img src="https://user-images.githubusercontent.com/87457873/127086819-efefb274-c386-4770-9a9d-8bf9ac6e66da.png" alt="image"></p>
<h3 id="硬件层的内存管理-buddy算法"><a href="#硬件层的内存管理-buddy算法" class="headerlink" title="硬件层的内存管理- buddy算法"></a>硬件层的内存管理- buddy算法</h3><p>每个zone都会使用buddy算法，把所有的空闲页面变成2的n次方进行管理。</p>
<p>&#x2F;proc&#x2F;buddyinfo</p>
<p>通过&#x2F;proc&#x2F;buddyinfo，可以看出空闲内存的情况</p>
<p><img src="https://user-images.githubusercontent.com/87457873/127086858-573709de-8b45-4a3a-bb03-ef85a275cd5f.png" alt="image"></p>
<p>CPU寻址内存的方法：通过MMU提供的虚拟地址到物理地址的映射访问。</p>
<p>如何处理内存碎片</p>
<p><img src="https://user-images.githubusercontent.com/87457873/127086883-72c6ad94-d41b-4b0b-aaa4-638667eb36ac.png" alt="image"></p>
<p>X86 linux 内核有一个线程 compaction, 会进行内存碎片整理，会尽量移出大内存。</p>
<p>CMA：continuous memory allocation</p>
<p>内核把虚拟地址 指向新的物理地址，让应用程序毫无知觉情况，把64M内存腾出来给DMA。当用DMA的api申请内存，会走到CMA。在dts中指定哪块区域做CMA。</p>
<p>Documentation&#x2F;devicetree&#x2F;bindings</p>
<p>reserved-memory&#x2F;reserved-memory.txt</p>
<p>dma_alloc_coherent</p>
<p><strong>CMA, iommu,</strong></p>
<p>CMA主要是给需要连续内存的DMA用的。但是为了避免DMA不用的时候浪费，才在DMA不用的时候给可移动的页面用。不能移动的页面，不能从CMA里面拿。所以主要是APP和文件的page cache的内存，才可以在CMA区域拿。</p>
<p>这样当DMA想拿CMA区域的时候，要么移走，要么抛弃。总之，必须保证DMA需要这片CMA区域的时候，之前占着CMA的统统滚蛋。</p>
<p>不具备滚蛋能力的内存，不能从CMA区域申请。你申请也滚蛋不了，待会DMA上来用的时候，DMA就完蛋了。</p>
<p>要搞清楚CMA的真正房东是那些需要连续内存的DMA，其他的人都只是租客。DMA要住的时候，租客必须走。哪个房东会把房子租给一辈子都不准备走的人？内核绝大多数情况下的内存申请，都是无法走的。应用走起来很容易，改下页面就行了。</p>
<p>CMA和不可移动之间，没有任何交集。CMA唯一的好处是，房东不住的时候，免得房子空置。</p>
]]></content>
      <categories>
        <category>linux-doc 内存管理</category>
      </categories>
      <tags>
        <tag>Linux</tag>
      </tags>
  </entry>
  <entry>
    <title>进程的内存消耗和泄漏</title>
    <url>/2023/01/15/linux-docs/%E5%86%85%E5%AD%98%E7%AE%A1%E7%90%86/%E8%BF%9B%E7%A8%8B%E7%9A%84%E5%86%85%E5%AD%98%E6%B6%88%E8%80%97%E5%92%8C%E6%B3%84%E6%BC%8F/</url>
    <content><![CDATA[<h2 id="进程的内存消耗和泄漏"><a href="#进程的内存消耗和泄漏" class="headerlink" title="进程的内存消耗和泄漏"></a>进程的内存消耗和泄漏</h2><ul>
<li>进程的VMA</li>
<li>进程内存消耗的4个概念： vss、rss、pss和uss</li>
<li>page fault的几种可能性， major 和 minor</li>
<li>应用内存泄漏的界定方法</li>
<li>应用内存泄漏的检测方法：valgrind 和 addresssanitizer</li>
</ul>
<p>本节重点阐述 Linux的应用程序究竟消耗了多少内存？</p>
<p>一是，看到的内存消耗，并不是一定是真的消耗。</p>
<p>二是，Linux存在大量的内存共享的情况。<br><br>动态链接库的特点：代码段共享内存，数据段写时拷贝。<br><br>把一个应用程序跑两个进程，这两个进程的代码段也是共享的。<br></p>
<p>当我们评估进程消耗多少内存时，就是指在用户空间消耗的内存，即虚拟地址在0～3G的部分，对应的物理地址内存。内核空间的内存消耗属于内核，系统调用申请了很多内存，这些内存是不属于进程消耗的。</p>
<h3 id="进程的虚拟地址空间VMA"><a href="#进程的虚拟地址空间VMA" class="headerlink" title="进程的虚拟地址空间VMA"></a>进程的虚拟地址空间VMA</h3><p><img src="https://user-images.githubusercontent.com/87457873/127090169-f784d99c-da06-40cb-b500-ed48b1be83ac.png" alt="image"></p>
<p>task_struct里面有个mm_struct指针， 它代表进程的内存资源。pgd，代表 页表的地址； mmap 指向vm_area_struct 链表。 vm_area_struct 的每一段代表进程的一个虚拟地址空间。vma的每一段，都可能是可执行程序的某个数据段、某个代码段，堆、或栈。一个进程的虚拟地址，是在0～3G之间任意分布的。</p>
<p><img src="https://user-images.githubusercontent.com/87457873/127090189-b6bc651a-d82d-444d-bff6-cdf6a7141069.png" alt="image"></p>
<p>上图 提供三种方式，看到进程的VMA空间。</p>
<p>pmap 3474</p>
<p>基地址，size, 权限，</p>
<p>通过以上的方式，可以看到进程的虚拟地址空间，分布在0～3G，任意一小段一小段分布的。</p>
<p>应用程序运行起来，就是一堆各种各样的VMA。VMA对应着 堆、栈、代码段、数据段、等，不在任何段里的虚拟地址空间，被认为是非法的。</p>
<p><img src="https://user-images.githubusercontent.com/87457873/127090214-f0f9dfd2-7899-43ae-816e-34403c36ac1d.png" alt="image"></p>
<p>当指针访问地址时，落在一个非法的地址，即不在任何一个VMA区域。相当于访问一个非法的地址，这些虚拟地址没有对应的物理地址。应用程序收到page fault，查看原因，访问非法位置，返回segv。</p>
<p>在VMA的东西，不等于在内存。调malloc申请了100M内存，立马会多出一个100M的 VMA，代表这段vma区域有r+w权限。</p>
<p><strong>应用程序访问内存，必须落在一个VMA里。其次，落在一个VMA里也不一定对。把100M的堆申请出来，100M内存页全部映射为0页。页表里每一页写的只读，页表和硬件对应，MMU只查页表。而在页表项中指向物理地址的权限是只读，所以在任何时候，去写其中任何一页，硬件都会发生缺页中断。</strong></p>
<p><strong>Linux 内核在缺页中断的处理程序，通过MMU寄存器读出发生page fault的地址和原因。发现此时page fault的原因是写一个页表里记录只读的物理地址，而vma记录的虚拟地址又是r+w，此时，linux会申请一页内存。同时把页表中的权限改为r+w。</strong></p>
<p>总结：<br><br>Linux 内核通过VMA管理进程每一段虚拟地址空间和权限。一旦发生page fault，如果没有落在任何一个vma区域，会干掉。</p>
<p>VMA的起始地址+size，用来限定程序访问的地址是否合法。VMA中每一段的权限，是来界定访问这段地址是否使用正确的方式访问。</p>
<p>把所有的vma加起来，构成进程的虚拟地址空间，但这并不代表进程真实耗费的内存。拿到之后才是真实耗费的内存，RSS。耗费的虚拟内存，是VSS。</p>
<h3 id="page-fault的几种可能性"><a href="#page-fault的几种可能性" class="headerlink" title="page fault的几种可能性"></a>page fault的几种可能性</h3><p><img src="https://user-images.githubusercontent.com/87457873/127090458-dafe02a1-0fc1-4e2c-959e-746b169d2487.png" alt="image"></p>
<p>1、申请堆内存vma，第一次写，页表里的权限是R ，发生page fault，linux会去申请一页内存，此时把页表权限设置为 R+W。<br><br>2、内存访问落在空白非法区域，程序收到segv段错误。<br><br>3、代码段在VMA记录是R+X，此时如果对代码段执行写，程序会收到segv段错误。<br></p>
<h4 id="minor-和major-缺页"><a href="#minor-和major-缺页" class="headerlink" title="minor 和major 缺页"></a>minor 和major 缺页</h4><p>缺页，分为两种情况：主缺页 和次缺页。</p>
<p>主缺页 和次缺页，区别就是 申请内存时，是否需要读硬盘。前者需要。</p>
<p>如上图第4种情况，在代码段里执行时，出现缺页。linux申请一页内存，而且要从硬盘中读取代码段的内容，此时产生了IO，称为 major缺页。</p>
<p>无论是代码段还是堆，都是边执行边产生缺页中断，申请实际的内存给代码段，且从硬盘中读取代码段的内容到内存。这个过程时间比较长。</p>
<p>minor： malloc的内存，产生缺页中断。去申请一页内存，没有产生IO的行为。major缺页处理时间，远大于minor。</p>
<p><img src="https://user-images.githubusercontent.com/87457873/127090530-49373bbd-8d2e-4170-a46d-80b4b462548b.png" alt="image"></p>
<h3 id="vss、rss、pss和uss的区别"><a href="#vss、rss、pss和uss的区别" class="headerlink" title="vss、rss、pss和uss的区别"></a>vss、rss、pss和uss的区别</h3><p><img src="https://user-images.githubusercontent.com/87457873/127090546-05a8c508-77cb-4a43-a792-7109461eeed0.png" alt="image"></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">VSS - Virtual Set Size</span><br><span class="line">RSS - Resident Set Size</span><br><span class="line">PSS - Proportional Set Size</span><br><span class="line">USS - Unique Set Size</span><br><span class="line">ASAN - AddressSanitizer</span><br><span class="line">LSAN - LeakSanitizer</span><br></pre></td></tr></table></figure>

<p>如上图，中间是一根内存条。三个进程分别是1044，1045，1054, 每一个进程对应一个page table，页表项记录虚拟地址如何往物理地址转换。硬件里的寄存器，记录页表的物理地址。当linux做进程上下文切换时，页表也跟着一起切换。</p>
<p><img src="https://user-images.githubusercontent.com/87457873/127090569-cc475c78-4c51-4492-b228-80f25b5b6f02.png" alt="image"></p>
<p>三个进程都需要使用libc的代码段。<br><br>VSS ＝ 1 +2 +3<br><br>RSS &#x3D; 4 +5 +6<br><br>PSS&#x3D; 4&#x2F;3 + 5&#x2F;2 + 6 比例化的<br><br>USS＝ 6 独占且驻留的</p>
<p>工具：smem ，查看进程使用内存的情况。<br><br>一般来讲，进程使用的内存量，还是看PSS，强调公平性。看内存泄漏看USS 就好了。</p>
<h3 id="内存泄漏-界定和检测方法"><a href="#内存泄漏-界定和检测方法" class="headerlink" title="内存泄漏 界定和检测方法"></a>内存泄漏 界定和检测方法</h3><p>界定：连续多点采样法，随着时间越久，进程耗费内存越多。</p>
<p>主要由内存申请和释放不是成对引起。RSS&#x2F;USS曲线，</p>
<p>观察方法：使用smem工具查看多次进程使用内存，USS使用量。</p>
<p>检查工具：<br><br>1、valgrind ，会跑一个虚拟机，运行时检查进程的内存行为。会放慢程序的速度。不需要重新编译程序。<br><br>2、addressanitizer，需要重新编译程序。编译时加参数，-fsanitize<br><br>gcc 4.9才支持，只会放慢程序速度2～3倍。</p>
]]></content>
      <categories>
        <category>linux-doc 内存管理</category>
      </categories>
      <tags>
        <tag>Linux</tag>
      </tags>
  </entry>
  <entry>
    <title>Linux IO 之 块IO流程与IO调度器</title>
    <url>/2023/01/15/linux-docs/%E6%96%87%E4%BB%B6%E7%B3%BB%E7%BB%9F/Linux%20IO%20%E4%B9%8B%20%E5%9D%97IO%E6%B5%81%E7%A8%8B%E4%B8%8EIO%E8%B0%83%E5%BA%A6%E5%99%A8/</url>
    <content><![CDATA[<h2 id="块I-O流程与-I-O调度器"><a href="#块I-O流程与-I-O调度器" class="headerlink" title="块I&#x2F;O流程与 I&#x2F;O调度器"></a>块I&#x2F;O流程与 I&#x2F;O调度器</h2><ul>
<li>一个块IO的一生：从page cache到bio 到 request</li>
<li>块设备层的数据结构</li>
<li>page和bio的关系，request 和bio的关系</li>
<li>O_DIRECT 和O_SYNC</li>
<li>blktrace , ftrace</li>
<li>IO调度和CFQ调度算法</li>
<li>CFQ和ionice</li>
<li>cgroup与IO</li>
<li>io性能测试： iotop, iostat</li>
</ul>
<p>主要内容：从应用程序发起一次IO行为，最终怎么到磁盘，以及在这个路径上有什么trace的方法和 配置。</p>
<p>每次应用程序写磁盘，都是到pagecache 。三进三出 讲解 bio的一生，都是在pagecache以下。</p>
<p>首先，在一次普通的sys_write过程中，会触发以下的函数调用。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">sys_write -&gt; vfs_write -&gt;  generic_file_write_iter</span><br><span class="line"></span><br><span class="line">PageCache: Linux通过局部性原理，使用页面缓存提高性能。</span><br><span class="line">1) generic_perform_write -&gt; write_begin -&gt; copy_data -&gt;write_end </span><br><span class="line"></span><br><span class="line">generic_perform_write: 开始pagecache的写入过程</span><br><span class="line">write_begin: 在内存空间中准备对应index需要的page。</span><br><span class="line"></span><br><span class="line">例如： ext4_write_begin 中包含</span><br><span class="line"> grab_cache_page_write_begin ： 查获取一个缓存页或者创建一个缓存页。</span><br><span class="line">     -&gt; page_cache_get_page:  从mapping的radix tree中查找缓存页，假如不存在，则从伙伴系统中申请一个新页插入，并添加到LRU链表中。</span><br><span class="line"></span><br><span class="line">ext4_write_end 首先调用__block_commit_write提交写入的数据，</span><br><span class="line"></span><br><span class="line">通过set_buffer_uptodate ：</span><br><span class="line">-&gt; mark_buffer_dirty -&gt; set_buffer_dirty/ set_page_dirty/ set_inode_dirty 将该页设脏， </span><br><span class="line"></span><br><span class="line">通过wb_wakeup_delayed把writeback任务提交到bdi_writeback队列中。</span><br><span class="line"></span><br><span class="line">DirectIO: </span><br><span class="line">2) generic_file_direct_write -&gt; filemap_write_and_write_range -&gt; mapping-&gt; a_ops-&gt; direct_IO</span><br></pre></td></tr></table></figure>

<p>如果是buffer IO , 脏页回写是异步的，并且由块设备层负责。</p>
<p>对于新版本的内核，ext4注册的方法是new_sync_write.</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">sys_write -&gt; vfs_write -&gt; __vfs_write -&gt; new_sync_write </span><br><span class="line">                                        -&gt; filp-&gt;f_op-&gt;write_iter -&gt; ext4_file_write_iter</span><br></pre></td></tr></table></figure>

<h3 id="块设备层的数据结构"><a href="#块设备层的数据结构" class="headerlink" title="块设备层的数据结构"></a>块设备层的数据结构</h3><p>struct page -&gt; struct inode -&gt; struct bio -&gt; struct request</p>
<p>真正开始做IO之前，即操作block子系统之前，包括以下步骤：</p>
<p><img src="https://user-images.githubusercontent.com/87457873/127652799-f2a0c75f-7fd3-4435-9292-73601cde6a81.png" alt="image"></p>
<p>应用程序读一个文件，首先会去查page cache是否命中，下一次再读page cache是命中的。<br><br>应用程序去写硬盘时，首先会去写page cache，至于什么时候开始写硬盘，由linux flush线程通过（pdflush-&gt;每一个设备的flush -&gt;工作队列）实现。当然也可以是线程本身，通过direct IO去写硬盘。<br></p>
<p>如上图三个task_struct进程，同时打开一个文件，在内存中生成file数据结构，记录文件打开的实例。</p>
<p>inode是真实存在硬盘里，当inode结构体中的i_mapping，对应的地址空间address_space。一个4M的文件，被分成很多4K单元存在于内存，通过地址 去radix tree来查page cache是否命中。如果查到了，就从radix tree对应的page返回。 如果没有page cache对应，就会通过 address_space_operations（文件系统实现的数据结构） 去 readpage，从硬盘里的块读到pagecache。</p>
<p>free命令看到的buffers和cache有什么区别？<br><br>答：在内核层面，全部都是pagecache。前者对应的是裸分区产生的page cache，后者对应的是挂载文件系统之后，文件系统目录产生的page cache。如下图内核代码的截图：</p>
<p><img src="https://user-images.githubusercontent.com/87457873/127652882-e1c19be4-6b93-4e85-ad1c-516bde546cae.png" alt="image"></p>
<p>文件系统的管理单元是block，内存管理是以page为单位，扇区（section）是硬件读写的最小单元。</p>
<p>假设你把ext4文件系统格式化成1k&#x2F;block，那么一个page对应4个block，此时读一个内存的page，文件系统要操作4个block。<br><br>假设你把ext4文件系统格式化成4k&#x2F;block，那么page和block可以一一对应。</p>
<p>&#x2F;proc&#x2F;meminfo中的 buffer ram如何计算出？</p>
<p>调用 nr_blockdev_pages()，这个函数会遍历所有原始块设备（list_for_each_entry），把所有原始块设备的inode中的i_mapping , 指向 address_space_operation。包括radix tree管理的pagecache，和 pagecache读写硬盘的硬件操作的接口。<br><br>nr_pages: page cache中已经命中的page。</p>
<h3 id="page和-bio的关系"><a href="#page和-bio的关系" class="headerlink" title="page和 bio的关系"></a>page和 bio的关系</h3><p>所谓的bio，抽象的读写block device的请求，指文件系统的block与内存page的对应。bio要变成实际的block device access还要通过block device driver再排队，并受到ioscheduler的控制。</p>
<p>有时候文件系统格式化block为1k，一次读写page的请求，最终转换成操作多个block。bio为I&#x2F;O请求提供了一个轻量级的表示方法，内核用一个bio的结构体来描述一次块IO操作。</p>
<p>bio结构体如下：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">bio</span> &#123;</span>  </span><br><span class="line">   <span class="type">sector_t</span> bi_sector; <span class="comment">/*我们想在块设备的第几个扇区上进行io操作（起始扇区），此处扇区大小是按512计算的*/</span></span><br><span class="line">   <span class="class"><span class="keyword">struct</span> <span class="title">bio</span> *<span class="title">bi_next</span>;</span></span><br><span class="line">   <span class="class"><span class="keyword">struct</span> <span class="title">block_device</span> *<span class="title">bi_bdev</span>;</span> <span class="comment">/*指向块设备描述符的指针，该io操作是针对哪个块设备的*/</span></span><br><span class="line">   <span class="type">unsigned</span> <span class="type">long</span> bi_rw; <span class="comment">/*该io操作是读还是写*/</span></span><br><span class="line">   <span class="type">unsigned</span> <span class="type">short</span> bi_vcnt; <span class="comment">/* bio的bio_vec数组中段的数目 */</span></span><br><span class="line">   <span class="type">unsigned</span> <span class="type">short</span> bi_idx; <span class="comment">/* bio的bio_vec数组中段的当前索引值 */</span></span><br><span class="line">   <span class="type">unsigned</span> <span class="type">short</span> bi_phys_segments; <span class="comment">//合并之后bio中（内存）物理段的数目</span></span><br><span class="line">   <span class="type">unsigned</span> <span class="type">int</span> bi_size; <span class="comment">/* 需要传送的字节数 */</span></span><br><span class="line">   <span class="type">bio_end_io_t</span> *bi_end_io; <span class="comment">/* bio的I/O操作结束时调用的方法 */</span></span><br><span class="line">   <span class="type">void</span> *bi_private; <span class="comment">//通用块层和块设备驱动程序的I/O完成方法使用的指针</span></span><br><span class="line">   <span class="type">unsigned</span> <span class="type">int</span> bi_max_vecs; <span class="comment">/* bio的bio vec数组中允许的最大段数 */</span></span><br><span class="line">   <span class="type">atomic_t</span> bi_cnt; <span class="comment">/* bio的引用计数器 */</span></span><br><span class="line">   <span class="class"><span class="keyword">struct</span> <span class="title">bio_vec</span> *<span class="title">bi_io_vec</span>;</span> <span class="comment">/*指向bio的bio_vec数组中的段的指针 */</span></span><br><span class="line">   <span class="class"><span class="keyword">struct</span> <span class="title">bio_set</span> *<span class="title">bi_pool</span>;</span></span><br><span class="line">   <span class="class"><span class="keyword">struct</span> <span class="title">bio_vec</span> <span class="title">bi_inline_vecs</span>[0];</span><span class="comment">/*一般一个bio就一个段，bi_inline_vecs就可满足，省去了再为bi_io_vec分配空间*/</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">bio_vec</span> &#123;</span></span><br><span class="line">   <span class="class"><span class="keyword">struct</span> <span class="title">page</span> *<span class="title">bv_page</span>;</span> <span class="comment">//指向段的页框对应页描述符的指针 </span></span><br><span class="line">   <span class="type">unsigned</span> <span class="type">int</span> bv_len; <span class="comment">//段的字节长度，长度可以超过一个页</span></span><br><span class="line">   <span class="type">unsigned</span> <span class="type">int</span> bv_offset; <span class="comment">//页框中段数据的偏移量</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>一个bio可能有很多个bio段，这些bio段在内存是可能不连续，位于不同的页，但在磁盘上对应的位置是连续的。一般上层构建bio的时候都是只有一个bio段。(新的DMA支持多个不连续内存的数据传输)</p>
<p>可以看到bio的段可能指向多个page，而bio也可以在没有buffer_head的情况下构造。</p>
<h3 id="request-和bio的关系"><a href="#request-和bio的关系" class="headerlink" title="request 和bio的关系"></a>request 和bio的关系</h3><p>在IO调度器中，上层提交的bio被构造成request结构，每个物理设备会对应一个request_queue，里面顺序存放着相关的request。每个请求包含一个或多个bio结构，bio之间用有序链表连接起来，按bio起始扇区的位置从小到大，而且这些bio之间在磁盘扇区是相邻的，也就是说一个bio的结尾刚好是下一个bio的开头。</p>
<p>通常，通用块层创建一个仅包含一个bio结构的请求，可能存在新bio与请求中已存在的数据物理相邻的情况，就把bio加入该请求，否则用该bio初始化一个新的请求。</p>
<p>buffer 和cache，在linux内核实现上没有区别，在计数上有区别。最后都是 address_space -&gt;radix tree -&gt; read&#x2F;write pages。</p>
<p>buffer_head: 是内核封装的数据结构。它是内核page与磁盘上物理数据块之间的桥梁。一方面，每个page包含多个buffer_head（一般4个），另外一方面，buffer_head中又记录了底层设备块号信息。这样，通过page-&gt;buffer_head-&gt;block就能完成数据的读写。</p>
<h3 id="O-DIRECT-和-O-SYNC"><a href="#O-DIRECT-和-O-SYNC" class="headerlink" title="O_DIRECT 和 O_SYNC"></a>O_DIRECT 和 O_SYNC</h3><p><img src="https://user-images.githubusercontent.com/87457873/127653137-6e34b815-7bf7-40dc-a511-9ef4189ba99d.png" alt="image"></p>
<p>两者区别，O_DIRECT 把一片地址配置成不带cache的空间 , 直接导硬盘 , 而 O_SYNC 类似CPU cache的write through. 当应用程序使用O_SYNC写page cache时，直接写穿到硬盘。</p>
<p>当应用程序同时使用O_SYNC和 O_DIRECT，可能会出现page cache的不一致问题。</p>
<h3 id="writeback机制-与bdi"><a href="#writeback机制-与bdi" class="headerlink" title="writeback机制 与bdi"></a>writeback机制 与bdi</h3><p>write的过程，把要写的page提交到bdi_writeback 队列中，然后由writeback线程将其真正写到block device上。<br><br>writeback机制：一方面加快了write()的速度，另一方面便于合并和排序多个write请求。</p>
<h3 id="三进三出-讲解-bio"><a href="#三进三出-讲解-bio" class="headerlink" title="三进三出 讲解 bio"></a>三进三出 讲解 bio</h3><p><img src="https://user-images.githubusercontent.com/87457873/127653201-445ff608-1ac9-472d-bbbe-fc6386dbe448.png" alt="image"></p>
<p>page cache只有通过 address_space_operations里的 write_pages和 read_pages，才能产生对文件系统的block产生IO行为。而不管是directIO还是writeback机制最终都会通过submit_bio方法提交bio到block层。</p>
<p>block io( bio ) : 讲文件系统上哪些block 读到内存哪些 page, 文件系统的 block bitmap 和 inode table，bio是从文件系统解析出来，从block到page之间的关系。</p>
<p>generic_make_request实现中请求构建的关键为 make_request_fn, 该函数的调用链路为：<br><br>blk_init_queue() -&gt; blk_init_queue_node() -&gt; blk_init_allocated_queue -&gt; blk_queue_make_request(q, lk_queue_io), 最后被调用执行的回调函数blk_queue_bio实现如下：</p>
<p>page cache和 硬盘数据 通过linux readpages函数关联时，会把文件系统的四个block，转化成4个bio。bio里的指针指向数据在硬盘的位置，也会有把这些数据读出来之后放置到page cache的哪些page。</p>
<p>当一个page对应多个block的情况，一个page 对应几个bio：size(page) &gt; size(block)，</p>
<p><img src="https://user-images.githubusercontent.com/87457873/127653227-9a39fdda-b553-4cd9-801b-2032b7ccdfe2.png" alt="image"></p>
<p>bio –&gt; request</p>
<p>每个进程有自己的plug队列，先把bio先发送到plug队列。在plug队列里，把bio转化成request。第一个bio一定是一个request，之后的bio就会查看多个bio是否可以merge到一个request，如果不能合并就产生一个新的request。</p>
<p>bio边发plug队列，边转成request。而这些request 先放到 elevator电梯队列，IO调度电梯做的类似路由器中QoS的功能-&gt;限制端口的流量。</p>
<p>deadline调度算法：优先考虑读，认为写不重要。应用程序写到pagecache以后，就已经写完了。</p>
<h3 id="I-O写入流程图"><a href="#I-O写入流程图" class="headerlink" title="I&#x2F;O写入流程图"></a>I&#x2F;O写入流程图</h3><p><img src="https://user-images.githubusercontent.com/87457873/127653301-a5704e64-71ff-4a6d-9562-f6183c67da21.png" alt="image"></p>
<h3 id="ftrace"><a href="#ftrace" class="headerlink" title="ftrace"></a>ftrace</h3><p>vfs_read&#x2F;vfs_write 慢，到底层操作磁盘差十万八千里。要用ftrace分析，才能知道具体原因。</p>
<p><img src="https://user-images.githubusercontent.com/87457873/127653353-efa9e9bf-b1bd-4ad6-adf6-2023155693e2.png" alt="image"></p>
<p>对于文件读写这种非常复杂的流程，在工程里面可以使用的调试方式是 ftrace。</p>
<p>除了用ftrace工具进行函数级的分析之外，使用blktrace去跟踪整个block io 生命周期，比如什么时候进入plug队列，unplug，什么时候进入电梯调度，什么时候进到驱动队列。</p>
<h3 id="blktrace"><a href="#blktrace" class="headerlink" title="blktrace"></a>blktrace</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">apt-get install sleuthkit blktrace</span><br><span class="line"></span><br><span class="line">#1:</span><br><span class="line">blktrace -d /dev/sda -o - | blkparse -i - &gt; 1.trace</span><br><span class="line"></span><br><span class="line">#2:</span><br><span class="line">root@whale-indextest01-1001:/home/gzzhangyi2015/learningLinuxKernel/io-courses/bio-flow# dd if=read.c of=barry oflag=sync</span><br><span class="line">0+1 records in</span><br><span class="line">0+1 records out</span><br><span class="line">219 bytes (219 B) copied, 0.000854041 s, 256 kB/s</span><br></pre></td></tr></table></figure>

<p><img src="https://user-images.githubusercontent.com/87457873/127653417-36ddc28c-50eb-49e4-acb1-1e56d6063e5a.png" alt="image"></p>
<p>扇区号(294220992)&#x2F;8 ＝ block号(36777624)</p>
<p>再用debugfs -R ‘icheck 块号’ &#x2F;dev&#x2F;sda9</p>
<p><img src="https://user-images.githubusercontent.com/87457873/127653436-e8279b02-87c6-4a10-b44f-82865994304d.png" alt="image"></p>
<p>再用debugfs -R ‘ncheck inode’ &#x2F;dev&#x2F;sda9</p>
<p><img src="https://user-images.githubusercontent.com/87457873/127653456-52eb0402-6808-4efa-a32e-e570454bbe00.png" alt="image"></p>
<p>再用 blkcat &#x2F;dev&#x2F;sda9 块号</p>
<p><img src="https://user-images.githubusercontent.com/87457873/127653478-6d33eb81-399b-466f-bf34-217d7b68f007.png" alt="image"></p>
<p>总结：</p>
<p>blktrace 是在内核里关键函数点上加了一些记录，再把记录抓下来。主要是看操作的流程。<br><br>ftrace 看 函数的流程。</p>
<h2 id="IO调度-和-CFQ调度算法"><a href="#IO调度-和-CFQ调度算法" class="headerlink" title="IO调度 和 CFQ调度算法"></a>IO调度 和 CFQ调度算法</h2><p><img src="https://user-images.githubusercontent.com/87457873/127653540-493fd277-3d7e-4124-bf18-0d3897b3f384.png" alt="image"></p>
<p>主要从 进程优先级 ， 流量控制 方面考虑，在通用块层和 I&#x2F;O调度层 进行限速，限制带宽和 IOPS。</p>
<p>Noop：空操作调度算法，也就是没有任何调度操作，并不对io请求进行排序，仅仅做适当的io合并的一个fifo队列。合并的技术，不太适用于排序。适用于固态硬盘，因为固态硬盘基本上可以随机访问。</p>
<p>CFQ：完全公平队列调度类似进程调度里的CFS，指定进程的nice值。它试图给所有进程提供一个完全公平的IO操作环境。它为每个进程创建一个同步IO调度队列，并默认以时间片和请求数限定的方式分配IO资源，以此保证每个进程的IO资源占用是公平的，cfq还实现了针对进程级别的优先级调度。</p>
<p>CFQ对于IO密集型场景不适用，尤其是IO压力集中在某些进程上的场景。该场景下需要更多满足某个或某几个进程的IO响应速度，而不是让所有的进程公平的使用IO。</p>
<p>此时，deadline调度（最终期限调度）就更适应这样的场景。deadline实现了四个队列，其中两个分别处理正常read和write，按扇区号排序，进行正常io的合并处理以提高吞吐量.因为IO请求可能会集中在某些磁盘位置，这样会导致新来的请求一直被合并，于是可能会有其他磁盘位置的io请求被饿死。<br><br>于是，实现了另外两个处理超时read和write的队列，按请求创建时间排序，如果有超时的请求出现，就放进这两个队列，调度算法保证超时（达到最终期限时间）的队列中的请求会优先被处理，防止请求被饿死。由于deadline的特点，无疑在这里无法区分进程，也就不能实现针对进程的io资源控制。</p>
<p>从原理上看，<br><br>cfq是一种比较通用的调度算法，是一种以进程为出发点考虑的调度算法，保证大家尽量公平。</p>
<p>deadline是一种以提高机械硬盘吞吐量为思考出发点的调度算法，只有当有io请求达到最终期限的时候才进行调度，非常适合业务比较单一并且IO压力比较重的业务，比如数据库。</p>
<p>而noop呢？其实如果我们把我们的思考对象拓展到固态硬盘，那么你就会发现，无论cfq还是deadline，都是针对机械硬盘的结构进行的队列算法调整，而这种调整对于固态硬盘来说，完全没有意义。对于固态硬盘来说，IO调度算法越复杂，效率就越低，因为额外要处理的逻辑越多。</p>
<p>所以，固态硬盘这种场景下，使用noop是最好的，deadline次之，而cfq由于复杂度的原因，无疑效率最低。</p>
<h2 id="CFQ-和-ionice"><a href="#CFQ-和-ionice" class="headerlink" title="CFQ 和 ionice"></a>CFQ 和 ionice</h2><p><img src="https://user-images.githubusercontent.com/87457873/127653620-28c8864e-bff3-44fd-8c57-4c1c9c7478f3.png" alt="image"></p>
<h3 id="demo"><a href="#demo" class="headerlink" title="demo"></a>demo</h3><p>把linux的IO调度算法改成CFQ，并且运行两个不同IO nice值的进程。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">目前的调度算法是 deadline</span><br><span class="line"></span><br><span class="line">root@whale-indextest01-1001:/sys/block/sda/queue# cat scheduler</span><br><span class="line">noop [deadline] cfq</span><br><span class="line"></span><br><span class="line">root@whale-indextest01-1001:/sys/block/sda/queue# echo cfq &gt; scheduler</span><br><span class="line">root@whale-indextest01-1001:/sys/block/sda/queue# cat scheduler</span><br><span class="line">noop deadline [cfq]</span><br><span class="line"></span><br><span class="line">root@whale-indextest01-1001:/sys/block/sda/queue# ionice -c 2 -n 0 cat /dev/sda9 &gt; /dev/null&amp;</span><br><span class="line">[1] 6755</span><br><span class="line">root@whale-indextest01-1001:/sys/block/sda/queue# ionice -c 2 -n 7 cat /dev/sda9 &gt; /dev/null&amp;</span><br><span class="line">[2] 6757</span><br><span class="line"></span><br><span class="line">root@whale-indextest01-1001:/sys/block/sda/queue# iotop</span><br></pre></td></tr></table></figure>

<h3 id="cgroup与IO"><a href="#cgroup与IO" class="headerlink" title="cgroup与IO"></a>cgroup与IO</h3><p><img src="https://user-images.githubusercontent.com/87457873/127653946-11e97c24-7ca9-46ba-9a38-9400d3710af3.png" alt="image"></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">root@whale-indextest01-1001:/sys/fs/cgroup/blkio# cgexec -g blkio:A dd if=/dev/sda9 of=/dev/null iflag=direct &amp;</span><br><span class="line">[3] 7550</span><br><span class="line"></span><br><span class="line">root@whale-indextest01-1001:/sys/fs/cgroup/blkio# cgexec -g blkio:B dd if=/dev/sda9 of=/dev/null iflag=direct &amp;</span><br><span class="line">[4] 7552</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h3 id="IO性能测试"><a href="#IO性能测试" class="headerlink" title="IO性能测试"></a>IO性能测试</h3><p>iostat<br><br><a href="http://linuxperf.com/?p=156">http://linuxperf.com/?p=156</a><br></p>
<p>1、rrqm&#x2F;s &amp; wrqm&#x2F;s 看io合并: 和&#x2F;sys&#x2F;block&#x2F;sdb&#x2F;queue&#x2F;scheduler 设置的io调度算法有关。<br><br>2、%util与硬盘设备饱和度: iostat 无法看硬盘设备的饱和度。<br><br>3、即使%util高达100%，硬盘也仍然有可能还有余力处理更多的I&#x2F;O请求，即没有达到饱和状态。<br></p>
<p>await 是单个I&#x2F;O所消耗的时间，包括硬盘设备处理I&#x2F;O的时间和I&#x2F;O请求在kernel队列中等待的时间.<br><br>实际场景根据I&#x2F;O模式 随机&#x2F;顺序与否进行判断。如果磁盘阵列的写操作不在一两个毫秒以内就算慢的了；读操作则未必，不在缓存中的数据仍然需要读取物理硬盘，单个小数据块的读取速度跟单盘差不多。</p>
<p>iowait<br><br>%iowait 表示在一个采样周期内有百分之几的时间属于以下情况：CPU空闲、并且有仍未完成的I&#x2F;O请求。<br><br>%iowait 升高并不能证明等待I&#x2F;O的进程数量增多了，也不能证明等待I&#x2F;O的总时间增加了。<br><br>%iowait升高有可能仅仅是cpu空闲时间增加了。<br><br>%iowait 的高低与I&#x2F;O的多少没有必然关系，而是与I&#x2F;O的并发度相关。所以，仅凭 %iowait 的上升不能得出I&#x2F;O负载增加 的结论。</p>
<p>它是一个非常模糊的指标，如果看到 %iowait 升高，还需检查I&#x2F;O量有没有明显增加，avserv&#x2F;avwait&#x2F;avque等指标有没有明显增大，应用有没有感觉变慢。</p>
<p>FAQ:<br><br>什么是Bufferd IO&#x2F; Direct IO? 如何解释cgroup的blkio对buffered IO是没有限速支持的？<br><br>答：这里面的buffer的含义跟内存中buffer cache有概念上的不同。实际上这里Buffered IO的含义，相当于内存中的buffer cache+page cache，就是IO经过缓存的意思。<br></p>
<p>cgroup针对IO的资源限制实现在了通用块设备层，对哪些IO操作有影响呢？ 原则上说都有影响，因为绝大多数数据都是要经过通用块设备层写入存储的，但是对于应用程序来说感受可能不一样。在一般IO的情况下，应用程序很可能很快的就写完了数据（在数据量小于缓存空间的情况下），然后去做其他事情了。这时应用程序感受不到自己被限速了，而内核在处理write-back的阶段，由于没有相关page cache中的inode是属于那个cgroup的信息记录，所以所有的page cache的回写只能放到cgroup的root组中进行限制，而不能在其他cgroup中进行限制，因为root组的cgroup一般是不做限制的。</p>
<p>而在Sync IO和Direct IO的情况下，由于应用程序写的数据是不经过缓存层的，所以能直接感受到速度被限制，一定要等到整个数据按限制好的速度写完或者读完，才能返回。这就是当前cgroup的blkio限制所能起作用的环境限制。</p>
]]></content>
      <categories>
        <category>linux-doc 文件系统</category>
      </categories>
      <tags>
        <tag>Linux</tag>
      </tags>
  </entry>
  <entry>
    <title>Linux IO 之 文件系统的实现</title>
    <url>/2023/01/15/linux-docs/%E6%96%87%E4%BB%B6%E7%B3%BB%E7%BB%9F/Linux%20IO%20%E4%B9%8B%20%E6%96%87%E4%BB%B6%E7%B3%BB%E7%BB%9F%E7%9A%84%E5%AE%9E%E7%8E%B0/</url>
    <content><![CDATA[<ul>
<li>Ext2&#x2F;3&#x2F;4 的layout</li>
<li>文件系统的一致性： append一个文件的全流程</li>
<li>掉电与文件系统的一致性</li>
<li>fsck</li>
<li>文件系统的日志</li>
<li>ext4 mount选项</li>
<li>文件系统的debug和dump</li>
<li>Copy On Write 文件系统： btrfs</li>
</ul>
<p>预备知识：数据库里的transaction(事务)有什么特性？</p>
<ul>
<li>原子性（Atomicity）：事务作为一个整体被执行，包含在其中的对数据库的操作要么全部被执行，要么都不执行。</li>
<li>一致性（Consistency）：事务应确保数据库的状态从一个一致状态转变为另一个一致状态。</li>
<li>持久性（Durability）：一个事务一旦提交，他对数据库的修改应该永久保存在数据库中。</li>
</ul>
<h2 id="Ext2-3-4-的layout"><a href="#Ext2-3-4-的layout" class="headerlink" title="Ext2&#x2F;3&#x2F;4 的layout"></a>Ext2&#x2F;3&#x2F;4 的layout</h2><p><img src="https://user-images.githubusercontent.com/87457873/127652263-8b59563d-16e5-4582-9731-514a6533b537.png" alt="image"></p>
<p>如上图，任何一个文件，在硬盘上有inode、 datablocks，和一些元数据信息(- 描述数据的数据)。其中，inode的信息包括，inode bitmap 和 inode table。通过inode bitmap和block bitmap来描述具体的inode table 和data blocks是否被占用。inode table包括文件的 读写权限和 指针表。</p>
<p><img src="https://user-images.githubusercontent.com/87457873/127652286-380dd2af-a4d1-4883-aa94-8ad08b112a1e.png" alt="image"></p>
<p>Linux对硬盘上一个文件，是分不同角度描述。创建一个文件，包括修改inode bitmap 和 block bitmap的描述。包括修改datablock和 inode bitmap的信息等等。所以“修改文件”这个操作，并不是原子的。所以存在文件系统的执行一致性的问题。</p>
<p><img src="https://user-images.githubusercontent.com/87457873/127652319-055ab693-25f5-44a0-8d51-65affeade3e2.png" alt="image"></p>
<p>分Group的好处，在同一个目录下的东西，尽量放在同一个group，用来减少硬盘的来回寻道。</p>
<p>文件系统的一致性： append一个文件的全流程</p>
<p><img src="https://user-images.githubusercontent.com/87457873/127652347-245e71c8-7278-455e-b5dd-a6cfd4243510.png" alt="image"></p>
]]></content>
      <categories>
        <category>linux-doc 文件系统</category>
      </categories>
      <tags>
        <tag>Linux</tag>
      </tags>
  </entry>
  <entry>
    <title>Linux IO 之 文件系统的架构</title>
    <url>/2023/01/15/linux-docs/%E6%96%87%E4%BB%B6%E7%B3%BB%E7%BB%9F/Linux%20IO%20%E4%B9%8B%20%E6%96%87%E4%BB%B6%E7%B3%BB%E7%BB%9F%E7%9A%84%E6%9E%B6%E6%9E%84/</url>
    <content><![CDATA[<h2 id="本文概述："><a href="#本文概述：" class="headerlink" title="本文概述："></a>本文概述：</h2><p>应用程序 -&gt;read -&gt;文件系统的代码 如何实现？<br><br>当目录里面 A&#x2F;B&#x2F;C ，是如何找到C的全过程？<br><br>文件系统如何描述文件在磁盘的哪些位置？<br><br>硬链接和 符号链接的详细区别？<br><br>userspace的文件系统的实现？<br></p>
<h2 id="一切都是文件：-VFS"><a href="#一切都是文件：-VFS" class="headerlink" title="一切都是文件： VFS"></a>一切都是文件： VFS</h2><p><img src="https://user-images.githubusercontent.com/87457873/127651033-de62eda0-638e-4a5b-b384-6e82ad301a46.png" alt="image"></p>
<p>文件系统的设计，类似 抽象基类，面向对象的思想。</p>
<p>虚函数都必须由底层派生出的实例实现，使用成员函数 file_operations。在linux里面的文件操作，底层都要实现file_operations，抽象出owner，write，open，release。所以，无论是字符块，还是文件系统的文件，最终操作就必须是file_operations。</p>
<p>例如，实现一个字符设备驱动，就是去实现file_operations。VFS_read时就会调用字符设备的file_operations。</p>
<h2 id="字符设备文件、块设备文件"><a href="#字符设备文件、块设备文件" class="headerlink" title="字符设备文件、块设备文件"></a>字符设备文件、块设备文件</h2><p>块设备的两种访问方法，一是访问裸分区，二是访问文件系统。</p>
<p>当直接访问裸分区，是通过fs&#x2F;block_dev.c 中的 file_operations def_blk_fops，也有read,write,open，一切继承到file_operations。如果是访问文件系统，就会通过实现 {ext4}_file_operations 来对接VFS对文件的操作。</p>
<p>块设备驱动就不需要知道file_operations，无论是裸设备，还是文件系统的file。他们实现的file_operations是把linux中的各种设备，hook进 VFS的方法。</p>
<h3 id="文件最终如何转化成对磁盘的访问？"><a href="#文件最终如何转化成对磁盘的访问？" class="headerlink" title="文件最终如何转化成对磁盘的访问？"></a>文件最终如何转化成对磁盘的访问？</h3><p>file_operation 跟pagecache 以及硬盘的关系？</p>
<p><img src="https://user-images.githubusercontent.com/87457873/127651253-4b14bf4b-1f25-4c5a-9315-66ba3be77deb.png" alt="image"></p>
<p>整个文件系统里，除了放文件本身的数据，还包括文件的管理数据，包括</p>
<ul>
<li>super block，保存在全局的 superblock结构中。</li>
<li>inode，是文件的唯一特定标识，文件系统使用bitmap来标识，inode是否使用。</li>
<li>block bitmap，来表示这些block是否占用，它在改变文件大小，创建删除等操作时，都会改变。</li>
<li>inode table&#x2F;diagram ： bitmap 只是表示inode和block是否被占用。</li>
</ul>
<p><img src="https://user-images.githubusercontent.com/87457873/127651295-1cb0542f-0340-41a7-9a0e-b17cf5ea2865.png" alt="image"></p>
<h2 id="超级块、目录、inode"><a href="#超级块、目录、inode" class="headerlink" title="超级块、目录、inode"></a>超级块、目录、inode</h2><ul>
<li>file_system_type 数据结构： 指的是 文件系统的类型，mount&#x2F;umount 的时候会用。</li>
<li>superblock数据结构：包含super_operations，其中包含如何分配&#x2F;销毁一个inode。</li>
<li>inode 数据结构：包含 inode_operations 和 file_operations。</li>
</ul>
<blockquote>
<p>file_operations里面记录这种类型的文件，包含哪些操作。<br>inode_operations里面包含如何生成新的inode，根据文件名字找到inode，如何mkdir,unlink.</p>
</blockquote>
<ul>
<li>dentry 数据结构: 对应路径，目录在文件系统里面是一个特殊的文件，文件的内容是一个inode和文件的表格。</li>
<li>file 数据结构:</li>
</ul>
<p><img src="https://user-images.githubusercontent.com/87457873/127651380-4e127a96-d14d-420e-9cd5-f9721affee67.png" alt="image"></p>
<ul>
<li>inode表：包含文件的一些基本信息，大小，创建日期，属性。还有一些成员指向硬盘所在的位置。<br>申请slab区域，比如 ext4_inode_cache , ext3_inode_cache. 这些cache会创建单独的slab，这些slab和内存里的page一一对应。</li>
</ul>
<p>ext2&#x2F;ext4文件系统中存在间接映射表。</p>
<p><img src="https://user-images.githubusercontent.com/87457873/127651428-2fafcb0f-dc5b-4e63-860b-b5d49ade8dff.png" alt="image"></p>
<p><img src="https://user-images.githubusercontent.com/87457873/127651439-0b3d58bb-7bab-4a33-8b4d-cb0c8e420cac.png" alt="image"></p>
<p><img src="https://user-images.githubusercontent.com/87457873/127651448-17ab6ed1-5775-427d-a874-5683f627446d.png" alt="image"></p>
<p>硬盘里的inode diagram里的数据结构，在内存中会通过slab分配器，组织成 xxx_inode_cache，出现在meminfo的可回收的内存。 inode表也会记录每一个inode 在硬盘中摆放的位置。</p>
<h2 id="目录的组织"><a href="#目录的组织" class="headerlink" title="目录的组织"></a>目录的组织</h2><p><img src="https://user-images.githubusercontent.com/87457873/127651495-af5b103d-40c2-479b-8339-2565cf0d3800.png" alt="image"></p>
<p>目录在硬盘里是一个特殊的文件，和之前的file结构体不同。目录在硬盘中对应一个inode，记录文件的名字和inode号。查找一个文件时，文件系统的 根inode和目录，根据根目录和根inode，找到根目录所在硬盘的位置。再去做字符串匹配，能够找到 &#x2F;A&#x2F;B&#x2F; 。inode表也会记录每一个inode 在硬盘中摆放的位置。</p>
<h2 id="icache和dcache，slab-shrink"><a href="#icache和dcache，slab-shrink" class="headerlink" title="icache和dcache，slab shrink"></a>icache和dcache，slab shrink</h2><p><img src="https://user-images.githubusercontent.com/87457873/127651908-c221f27e-8b01-4093-8bb6-9a94400b6d36.png" alt="image"></p>
<p>文件系统在实现时，在vfs这一层的 inode cache 和 dentry cache，不管硬盘的系统，跨所有文件系统的通用信息。</p>
<p>针对这些cache，这些可以回收的slab，linux提供了专门的slab shrink- 收缩函数。<br><br>最后所有可回收的内存，都必须通过LRU算法去回收。<br><br>有些自己申请的 reclaim的内存，由于没有写 shrink函数，所以就无法进行内存的回收。<br></p>
<h2 id="文件读写如何通过file-operation-和pagecache的关系"><a href="#文件读写如何通过file-operation-和pagecache的关系" class="headerlink" title="文件读写如何通过file_operation 和pagecache的关系"></a>文件读写如何通过file_operation 和pagecache的关系</h2><p><img src="https://user-images.githubusercontent.com/87457873/127651982-66ba1471-b32d-4c79-b733-b91564995a96.png" alt="image"></p>
<p><img src="https://user-images.githubusercontent.com/87457873/127651993-487fe5a8-1bad-438b-ac01-317f18aacb31.png" alt="image"></p>
<p><img src="https://user-images.githubusercontent.com/87457873/127652007-b57e63eb-5ed9-4125-9626-baf79faa6659.png" alt="image"></p>
<h2 id="发现并读取-usr-bin-xxx的全流程"><a href="#发现并读取-usr-bin-xxx的全流程" class="headerlink" title="发现并读取&#x2F;usr&#x2F;bin&#x2F;xxx的全流程"></a>发现并读取&#x2F;usr&#x2F;bin&#x2F;xxx的全流程</h2><p><img src="https://user-images.githubusercontent.com/87457873/127651566-cd18bafe-5ebe-48d6-917b-6eccda09cce1.png" alt="image"></p>
<p>如上图，当你在硬盘查找 &#x2F;usr&#x2F;bin&#x2F;emacs文件时，从根的inode和dentry，根据&#x2F;的inode表，找到&#x2F; 目录文件所在的硬盘中的位置，读硬盘&#x2F;目录文件的内容，发现 usr 对应inode 2, bin 对应inode 3, share 对应inode4。再去查inode表，inode 2所在硬盘的位置，即&#x2F;usr 目录文件所在硬盘的位置。读出内容包括 var 对应 inode 10, bin 对应inode 11, opt对应inode 12，。</p>
<p>这个过程会查找很多inode和 dentry，这些都会通过 icache 和dcache缓存。</p>
<h2 id="符号链接-与-硬链接"><a href="#符号链接-与-硬链接" class="headerlink" title="符号链接 与 硬链接"></a>符号链接 与 硬链接</h2><p><img src="https://user-images.githubusercontent.com/87457873/127651769-c1b5d554-37b8-4f1a-91ee-5532ee65d2b5.png" alt="image"></p>
<p>文件名是特殊目录文件的内容，比如 A目录下有b\c\d，其实就是 A这个目录文件，里面对应目录b,c,d和对应inode的表。</p>
<p>硬链接：在硬盘中是同一个inode存在，在目录文件中多了一个目录和inode对应。</p>
<p>符号链接：是linux中是真实存在的实体文件，文件内容指向 其他文件。符号链接和文件是不同的inode。</p>
<p>1、硬链接不能跨本地文件系统<br><br>2、硬链接不能针对目录<br><br>3、针对目录的软链接，用rm -fr 删除不了目录里的内容<br><br>4、针对目录的软链接，”cd ..”进的是软链接所在目录的上级目录<br><br>5、可以对文件执行unlink或rm，但是不能对目录执行unlink<br></p>
<h2 id="用户空间的文件系统：-FUSE"><a href="#用户空间的文件系统：-FUSE" class="headerlink" title="用户空间的文件系统： FUSE"></a>用户空间的文件系统： FUSE</h2><p>用户空间文件系统 是操作系统中的概念，指完全在用户态实现的文件系统。</p>
<p>目前Linux通过内核模块对此进行支持。一些文件系统如ZFS，glusterfs使用FUSE实现。</p>
<p><img src="https://user-images.githubusercontent.com/87457873/127652044-b91f96f8-ea78-4d2b-aa37-4bcde036735d.png" alt="image"></p>
<p>FUSE的工作原理如上图所示。假设基于FUSE的用户态文件系统hello挂载在&#x2F;tmp&#x2F;fuse目录下。当应用层程序要访问&#x2F;tmp&#x2F;fuse下的文件时，通过glibc中的函数进行系统调用，处理这些系统调用的VFS中的函数会调用FUSE在内核中的文件系统；内核中的FUSE文件系统将用户的请求，发送给用户态文件系统hello；用户态文件系统收到请求后，进行处理，将结果返回给内核中的FUSE文件系统；最后，内核中的FUSE文件系统将数据返回给用户态程序。</p>
]]></content>
      <categories>
        <category>linux-doc 文件系统</category>
      </categories>
      <tags>
        <tag>Linux</tag>
      </tags>
  </entry>
  <entry>
    <title>Linux 操作系统原理-文件系统(1)</title>
    <url>/2023/01/15/linux-docs/%E6%96%87%E4%BB%B6%E7%B3%BB%E7%BB%9F/Linux%20%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E5%8E%9F%E7%90%86-%E6%96%87%E4%BB%B6%E7%B3%BB%E7%BB%9F(1)/</url>
    <content><![CDATA[<h2 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h2><p><img src="https://user-images.githubusercontent.com/87457873/127256331-9a2e8da5-0061-42ff-9788-9233e8a11120.png" alt="image"></p>
<p><strong>虚拟文件系统</strong>（Virtual File System，简称VFS）是Linux内核的子系统之一，它为用户程序提供文件和文件系统操作的统一接口，屏蔽不同文件系统的差异和操作细节。借助VFS可以直接使用open()、read()、write()这样的系统调用操作文件，而无须考虑具体的文件系统和实际的存储介质。</p>
<p>通过VFS系统，Linux提供了通用的系统调用，可以跨越不同文件系统和介质之间执行，极大简化了用户访问不同文件系统的过程。另一方面，新的文件系统、新类型的存储介质，可以无须编译的情况下，动态加载到Linux中。</p>
<p>“一切皆文件”是Linux的基本哲学之一，不仅是普通的文件，包括目录、字符设备、块设备、套接字等，都可以以文件的方式被对待。实现这一行为的基础，正是Linux的虚拟文件系统机制。</p>
<p>VFS之所以能够衔接各种各样的文件系统，是因为它抽象了一个通用的文件系统模型，定义了通用文件系统都支持的、概念上的接口。新的文件系统只要支持并实现这些接口，并注册到Linux内核中，即可安装和使用。</p>
<p>举个例子，比如Linux写一个文件：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">int</span> ret = write(fd, buf, len);</span><br></pre></td></tr></table></figure>
<p>调用了write()系统调用，它的过程简要如下：</p>
<p>首先，勾起VFS通用系统调用sys_write()处理。<br><br>接着，sys_write()根据fd找到所在的文件系统提供的写操作函数，比如op_write()。<br><br>最后，调用op_write()实际的把数据写入到文件中。<br><br>操作示意图如下：</p>
<p><img src="https://user-images.githubusercontent.com/87457873/127256431-b8dde885-d774-40d7-a556-5ae5ee1b7196.png" alt="image"></p>
<h2 id="文件系统"><a href="#文件系统" class="headerlink" title="文件系统"></a>文件系统</h2><h3 id="Linux下常用文件系统介绍"><a href="#Linux下常用文件系统介绍" class="headerlink" title="Linux下常用文件系统介绍"></a>Linux下常用文件系统介绍</h3><ul>
<li>swap 文件系统<br><br>swap文件系统用于Linux的交换分区。在Linux中，使用整个交换分区来提供虚拟内存，其分区大小一般应是系统物理内存的2倍，在安装Linux操作系统时，就应创建交换分区，它是Linux正常运行所必需的，其类型必须是swap,交换分区由操作系统自行管理</li>
<li>Btrfs 文件系统<br></li>
<li>Ext系列文件系统<br><br>ext是第一个专门为Linux设计的文件系统类型，称为扩展文件系统。目前已经到了第四版分别是ext2, ext3,ext4 其中 centOS6默认是ext4文件系统</li>
<li>xfs 文件系统</li>
<li>NFS文件系统</li>
<li>FAT系列文件系统</li>
</ul>
<h3 id="比较"><a href="#比较" class="headerlink" title="比较"></a>比较</h3><table>
<thead>
<tr>
<th align="center">文件系统</th>
<th align="center">最大文件名长度</th>
<th align="center">最大文件大小</th>
<th align="center">最大分区大小</th>
</tr>
</thead>
<tbody><tr>
<td align="center">ext2</td>
<td align="center">255 bytes</td>
<td align="center">2 TB</td>
<td align="center">16 TB</td>
</tr>
<tr>
<td align="center">ext3</td>
<td align="center">255 bytes</td>
<td align="center">2 TB</td>
<td align="center">16 TB</td>
</tr>
<tr>
<td align="center">ext4</td>
<td align="center">255 bytes</td>
<td align="center">16 TB</td>
<td align="center">1 EB</td>
</tr>
<tr>
<td align="center">XFS</td>
<td align="center">255 bytes</td>
<td align="center">8 EB</td>
<td align="center">8 EB</td>
</tr>
<tr>
<td align="center">Btrfs</td>
<td align="center">255 bytes</td>
<td align="center">16 EB</td>
<td align="center">16 EB</td>
</tr>
</tbody></table>
<h3 id="选择"><a href="#选择" class="headerlink" title="选择"></a>选择</h3><table>
<thead>
<tr>
<th align="center">文件系统</th>
<th align="center">适用场景</th>
<th align="center">原因</th>
</tr>
</thead>
<tbody><tr>
<td align="center">ext2</td>
<td align="center">U盘</td>
<td align="center">U盘一般不会存很多文件，且U盘的文件在电脑上有备份，安全性要求没那么高，由于ext2不写日志（journal），所以写U盘性能比较好。当然由于ext2的兼容性没有fat好，目前大多数U盘格式还是用fat</td>
</tr>
<tr>
<td align="center">ext3</td>
<td align="center">对稳定性要求高的地方</td>
<td align="center">有了ext4后，好像没什么原因还要用ext3，ext4现在的问题是出来时间不长，还需要一段时间变稳定</td>
</tr>
<tr>
<td align="center">ext4</td>
<td align="center">小文件较少</td>
<td align="center">ext系列的文件系统都不支持inode动态分配，所以如果有大量小文件需要存储的话，不建议用ext4</td>
</tr>
<tr>
<td align="center">xfs</td>
<td align="center">小文件多或者需要大的xttr空间，如openstack swift将数据文件的元数据放在了xttr里面</td>
<td align="center">xfs支持inode动态分配，所以不存在inode不够的情况，并且xttr的最大长度可以达到64K</td>
</tr>
<tr>
<td align="center">btrfs</td>
<td align="center">没有频繁的写操作，且需要btrfs的一些特性</td>
<td align="center">btrfs虽然还不稳定，但支持众多的功能，如果你需要这些功能，且不会频繁的写文件，那么选择btrfs</td>
</tr>
</tbody></table>
<h2 id="文件系统的结构"><a href="#文件系统的结构" class="headerlink" title="文件系统的结构"></a>文件系统的结构</h2><h3 id="磁盘的组成原理"><a href="#磁盘的组成原理" class="headerlink" title="磁盘的组成原理"></a>磁盘的组成原理</h3><p>除了固态硬盘之外，硬盘一般都由磁盘、主轴马达、磁头臂、磁头、永磁铁等部分组成。</p>
<h4 id="盘片"><a href="#盘片" class="headerlink" title="盘片"></a>盘片</h4><p>盘片的表面涂有磁性物质，这些磁性物质用来记录二进制数据。因为正反两面都可涂上磁性物质，故一个盘片可能会有两个盘面，硬盘的存储介质是磁性材料，磁头通过电流改变磁盘的磁性来存储数据。硬盘在逻辑上被划分为磁道、柱面以及扇区。</p>
<p><img src="https://user-images.githubusercontent.com/87457873/127256887-4ae2be65-af03-44b2-afb0-bc4155acb314.png" alt="image"></p>
<h4 id="扇区，磁道"><a href="#扇区，磁道" class="headerlink" title="扇区，磁道"></a>扇区，磁道</h4><p>每个盘片被划分为一个个磁道，每个磁道又划分为一个个扇区。如下图：</p>
<p><img src="https://user-images.githubusercontent.com/87457873/127256921-5ee591c7-caa4-4a81-98a7-6c46ec881afd.png" alt="image"></p>
<p>其中，最内侧磁道上的扇区面积最小，因此数据密度最大。</p>
<h4 id="柱面"><a href="#柱面" class="headerlink" title="柱面"></a>柱面</h4><p>硬盘通常由重叠的一组盘片构成,每个盘面都被划分为数目相等的磁道,并从外缘的“0”开始编号,具有相同编号的磁道形成一个圆柱,称之为磁盘的柱面。</p>
<p><img src="https://user-images.githubusercontent.com/87457873/127256973-448316b8-5835-4572-9203-1b8ddbf2a6a6.png" alt="image"></p>
<h4 id="分区"><a href="#分区" class="headerlink" title="分区"></a>分区</h4><blockquote>
<p>为什么要对硬盘进行分区呢？</p>
</blockquote>
<p>因为我们必须要告诉操作系统：这块硬盘可以访问的区域是从 A 柱面到 B 柱面。如此一来，操作系统才能控制硬盘磁头去 A-B 范围内的柱面上访问数据。如果没有告诉操作系统这些信息，它就无法在磁盘上存取数据。所以对磁盘分区的要点是：记录每一个分区的起始与结束柱面。<br>实际上，分区时指定的开始和结束位置是柱面上的扇区(sector)：</p>
<p>下面我们以CentOS7 为例来看一下分区情况：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">[root@CentOS7 ~]# fdisk -l</span><br><span class="line"></span><br><span class="line">磁盘 /dev/sda：21.5 GB, 21474836480 字节，41943040 个扇区</span><br><span class="line">Units = 扇区 of 1 * 512 = 512 bytes</span><br><span class="line">扇区大小(逻辑/物理)：512 字节 / 512 字节</span><br><span class="line">I/O 大小(最小/最佳)：512 字节 / 512 字节</span><br><span class="line">磁盘标签类型：dos # 使 用dos---MBR 分区方式</span><br><span class="line">磁盘标识符：0x000ce1c0</span><br><span class="line"></span><br><span class="line">   设备    Boot      Start         End      Blocks   Id  System</span><br><span class="line">/dev/sda1   *        2048     2099199     1048576   83  Linux</span><br><span class="line">/dev/sda2         2099200    41943039    19921920   8e  Linux LVM（逻辑卷）</span><br><span class="line"># sda 分区</span><br><span class="line">磁盘 /dev/mapper/centos-root：18.2 GB, 18249416704 字节，35643392 个扇区</span><br><span class="line">Units = 扇区 of 1 * 512 = 512 bytes</span><br><span class="line">扇区大小(逻辑/物理)：512 字节 / 512 字节</span><br><span class="line">I/O 大小(最小/最佳)：512 字节 / 512 字节</span><br><span class="line"></span><br><span class="line"># 交换分区</span><br><span class="line">磁盘 /dev/mapper/centos-swap：2147 MB, 2147483648 字节，4194304 个扇区</span><br><span class="line">Units = 扇区 of 1 * 512 = 512 bytes</span><br><span class="line">扇区大小(逻辑/物理)：512 字节 / 512 字节</span><br><span class="line">I/O 大小(最小/最佳)：512 字节 / 512 字节</span><br></pre></td></tr></table></figure>

<h3 id="分区的组成结构"><a href="#分区的组成结构" class="headerlink" title="分区的组成结构"></a>分区的组成结构</h3><p><img src="https://user-images.githubusercontent.com/87457873/127257092-4099b5ed-2da0-4909-b466-ac9e796ce312.png" alt="image"></p>
<h4 id="MBR"><a href="#MBR" class="headerlink" title="MBR"></a>MBR</h4><p>那么，这些分区的信息(起始柱面与结束柱面)被存放在磁盘的主引导区(Master Boot Recorder, MBR)。MBR 在一块硬盘的第 0 轨上，这也是计算机启动之后要去使用硬盘时必须读取的第一个区域。</p>
<p>这个区域内记录了硬盘里所有分区的信息即磁盘分区表，以及启动时可以写入引导程序的位置。因此 MBR 对于硬盘来说至关重要，如果它坏掉了，这块磁盘也就寿终正寝了。</p>
<p>主引导记录由三个部分组成：</p>
<ul>
<li>引导程序占用其中的前446字节（偏移0～1BDH）</li>
<li>随后的64字节（偏移1BEH～1FDH）为DPT（Disk Partition Table，硬盘分区表）</li>
<li>最后的两个字节“55 AA”（偏移1FEH～1FFH）是结束标志。</li>
</ul>
<p><img src="https://user-images.githubusercontent.com/87457873/127257132-023a9849-ef88-4630-b1fa-eda081ca1159.png" alt="image"></p>
<p>分区表:</p>
<p><img src="https://user-images.githubusercontent.com/87457873/127257148-db61a633-ae1a-4bfe-a8a1-a5635892d6c4.png" alt="image"></p>
<h4 id="GDT"><a href="#GDT" class="headerlink" title="GDT"></a>GDT</h4><p>Disk label type: gpt—GPT</p>
<p>在MBR硬盘中，分区信息直接存储于主引导记录（MBR）中（主引导记录中还存储着系统的引导程序）。但在GPT硬盘中，分区表的位置信息储存在GPT头中。但出于兼容性考虑，硬盘的第一个扇区仍然用作MBR，之后才是GPT头。</p>
<p>跟现代的MBR一样，GPT也使用逻辑区块地址（LBA）取代了早期的CHS寻址方式。传统MBR信息存储于LBA 0，GPT头存储于LBA 1，接下来才是分区表本身。</p>
<p><img src="https://user-images.githubusercontent.com/87457873/127257215-6bd904ec-2a83-4724-a720-610eee280ad2.png" alt="image"></p>
<p>为什么要提出新的方案呢？那就让我们看看MBR分区方案有什么问题。前面已经提到了</p>
<ul>
<li>主分区数目不能超过4个的限制</li>
<li>关键的是MBR分区方案无法支持超过2TB容量的磁盘。因为这一方案用4个字节存储分区的总扇区数，最大能表示2的32次方的扇区个数，按每扇区512字节计算，每个分区最大不能超过2TB。磁盘容量超过2TB以后，分区的起始位置也就无法表示了。</li>
</ul>
<blockquote>
<p>有了扇区（sector），有了柱面（cylinder），有了 磁头（head），显然可以定位数据了，这就是数据定位(寻址)方式之一，CHS（也称3D），对早期的磁盘（上图所示）非常有效，知道用哪个 磁头，读取哪个柱面上的第几扇区就OK了。CHS模式支持的硬盘容量有限，用8bit来存储 磁头地址，用10bit来存储柱面地址，用6bit来存储扇区地址，而一个扇区共有512Byte，这样使用CHS寻址一块硬盘最大容量为256 * 1024 * 63 * 512B &#x3D; 8064 MB(1MB &#x3D; 1048576B)（若按1MB&#x3D;1000000B来算就是8.4GB）</p>
</blockquote>
<blockquote>
<p>但现在很多硬盘采用同密度盘片，意味着内外磁道上的扇区数量不同，扇区数量增加，容量增加，3D很难定位寻址，新的寻址模式：LBA(Logical Block Addressing)。在LBA地址中，地址不再表示实际硬盘的实际 物理地址（柱面、 磁头和扇区）。LBA编址方式将CHS这种三维寻址方式转变为一维的线性寻址，它把硬盘所有的 物理扇区的C&#x2F;H&#x2F;S编号通过一定的规则转变为一线性的编号，系统效率得到大大提高，避免了烦琐的 磁头&#x2F;柱面&#x2F;扇区的寻址方式。在访问硬盘时，由硬盘控制器再将这种 逻辑地址转换为实际硬盘的 物理地址。</p>
</blockquote>
<blockquote>
<p>LBA下的编号，扇区编号是从0开始。逻辑扇区号LBA的公式：</p>
</blockquote>
<blockquote>
<p>LBA(逻辑扇区号)&#x3D;磁头数 × 每磁道扇区数 × 当前所在柱面号 + 每磁道扇区数 × 当前所在磁头号 + 当前所在扇区号 – 1<br><br>例如：CHS&#x3D;0&#x2F;0&#x2F;1，则根据公式LBA&#x3D;255 × 63 × 0 + 63 × 0 + 1 – 1&#x3D; 0</p>
</blockquote>
<blockquote>
<p>也就是说 物理0柱面0 磁头1扇区，是 逻辑0扇区。也就是说 LBA就是扇区的编号， 按照磁道 柱面 和 磁头 从小到大的顺序编号</p>
</blockquote>
<h2 id="计算机启动的过程"><a href="#计算机启动的过程" class="headerlink" title="计算机启动的过程"></a>计算机启动的过程</h2><h3 id="1-BIOS-程序启动"><a href="#1-BIOS-程序启动" class="headerlink" title="1. BIOS 程序启动"></a>1. BIOS 程序启动</h3><p>上个世纪70年代初，“只读内存”（read-only memory，缩写为ROM）发明，开机程序被刷入ROM芯片，计算机通电后，第一件事就是读取它。这块芯片里的程序叫做”基本輸出輸入系統”（Basic Input&#x2F;Output System），简称为BIOS。</p>
<h3 id="2-硬件自检"><a href="#2-硬件自检" class="headerlink" title="2. 硬件自检"></a>2. 硬件自检</h3><p>BIOS程序首先检查，计算机硬件能否满足运行的基本条件，这叫做”硬件自检”（Power-On Self-Test），缩写为POST。<br><br>如果硬件出现问题，主板会发出不同含义的蜂鸣，启动中止。如果没有问题，屏幕就会显示出CPU、内存、硬盘等信息。<br></p>
<p>硬件自检完成后，BIOS把控制权转交给下一阶段的启动程序。这时，BIOS需要知道，“下一阶段的启动程序”具体存放在哪一个设备。也就是说，BIOS需要有一个外部储存设备的排序，排在前面的设备就是优先转交控制权的设备。这种排序叫做”启动顺序”（Boot Sequence）。</p>
<p>打开BIOS的操作界面，里面有一项就是”<strong>设定启动顺序</strong>“。</p>
<p><img src="https://user-images.githubusercontent.com/87457873/127257427-722a5345-c1ef-406f-8fa7-17b26d597791.png" alt="image"></p>
<h3 id="3-主引导记录"><a href="#3-主引导记录" class="headerlink" title="3. 主引导记录"></a>3. 主引导记录</h3><p>BIOS按照”启动顺序”，把控制权转交给排在第一位的储存设备。</p>
<p>这时，计算机读取该设备的第一个扇区，也就是读取最前面的512个字节。如果这512个字节的最后两个字节是0x55和0xAA，表明这个设备可以用于启动；如果不是，表明设备不能用于启动，控制权于是被转交给”启动顺序”中的下一个设备。<br>这最前面的512个字节，就叫做”主引导记录”（Master boot record，缩写为MBR）。<br>主引导记录”只有512个字节，放不了太多东西。它的主要作用是，告诉计算机到硬盘的哪一个位置去找操作系统</p>
<h3 id="4-启动管理器"><a href="#4-启动管理器" class="headerlink" title="4. 启动管理器"></a>4. 启动管理器</h3><p>在这种情况下，计算机读取”主引导记录”前面446字节的机器码之后，不再把控制权转交给某一个分区，而是运行事先安装的”启动管理器”（boot loader），由用户选择启动哪一个操作系统。Linux环境中，目前最流行的启动管理器是Grub。</p>
<h3 id="5-操作系统"><a href="#5-操作系统" class="headerlink" title="5. 操作系统"></a>5. 操作系统</h3><p>控制权转交给操作系统后，操作系统的内核首先被载入内存。<br>以Linux系统为例，先载入&#x2F;boot目录下面的kernel。内核加载成功后，第一个运行的程序是&#x2F;sbin&#x2F;init。它根据配置文件（Debian系统是&#x2F;etc&#x2F;initab， CentOS 是systemd）产生init进程。这是Linux启动后的第一个进程，pid进程编号为1，其他进程都是它的后代。</p>
<p>然后，init线程加载系统的各个模块，比如窗口程序和网络程序，直至执行&#x2F;bin&#x2F;login程序，跳出登录界面，等待用户输入用户名和密码。</p>
<h2 id="文件存贮"><a href="#文件存贮" class="headerlink" title="文件存贮"></a>文件存贮</h2><p>文件系统到底是怎么管理磁盘的被？首先，操作系统会将磁盘分区后，同一个文件系统中，我们以ext系列为例来说明：<br>ext系统将空间（这里的空间是指的一段连续的磁盘空间）划分为不同的功能区，比如元数据区和数据区。元数据去主要存贮文件的一些属性，比如说大小，快信息，这些信息被存贮在inode当中，而数据去以datablock 为存贮单元，主要是存放了文件的数据。</p>
<p>因为磁盘上的数据要和内存交互，而内存通常是以4KB为单位的，所以从逻辑上，把磁盘按照4KB划分比较方便（称为一个block）。现在假设由一个文件系统管理64个blocks的一个磁盘区域：</p>
<h3 id="顺序文件结构"><a href="#顺序文件结构" class="headerlink" title="顺序文件结构"></a>顺序文件结构</h3><p>顾名思义，文件的存贮数据块是连续的空间。</p>
<p>优点是不需要额外的空间开销，只要在文件目录中指出文件的大小和首块的块号即可，对顺序的访问效率很高。适应于顺序存取且文件不经常修改的情况。<br>缺点是</p>
<ul>
<li>文件动态地增长和缩小时系统开销很大；</li>
<li>文件创建时要求用户提供文件的大小；</li>
<li>存储空间浪费较大。</li>
</ul>
<h3 id="链式文件系统"><a href="#链式文件系统" class="headerlink" title="链式文件系统"></a>链式文件系统</h3><p><img src="https://user-images.githubusercontent.com/87457873/127257604-6de55df1-3737-4f74-8ba6-a930a2b21d89.png" alt="image"></p>
<p>克服了连续文件的不足之处，但文件的随机访问系统开销较大。适应于顺序访问的文件。</p>
<h3 id="索引式文件系统"><a href="#索引式文件系统" class="headerlink" title="索引式文件系统"></a>索引式文件系统</h3><p>在UNIX时代，就已经实现了索引式的文件系统。它的原理是为一个文件的所有块建立一个索引表，索引表就是块地址数组，每个数组元素就是块的地址，第n个数组元素指向文件中的第n个块，这样访问任意一个块的时候，只需要从索引表中获得块地址就可以了。而且文件中的块依然可以分散到不连续的零散空间中。其结构如下图所示</p>
<p><img src="https://user-images.githubusercontent.com/87457873/127258133-1d1bcc70-2627-497e-a70d-ba1456d581f6.png" alt="image"></p>
<p>既适应于顺序存访问，也适应于随机访问，是一种比较好的文件物理结构，但要有用于索引表的空间开销和文件索引的时间开销</p>
<h2 id="Ext-文件分区布局"><a href="#Ext-文件分区布局" class="headerlink" title="Ext 文件分区布局"></a>Ext 文件分区布局</h2><p><img src="https://user-images.githubusercontent.com/87457873/127258158-9f691820-6534-43ae-b61b-5b40452788ca.png" alt="image"></p>
<p>每个分区，将若干个块儿组成一个块组，每个块组会有以下几个结构</p>
<h3 id="超级块"><a href="#超级块" class="headerlink" title="超级块"></a>超级块</h3><p>1）超级块(Super Block)描述整个分区的文件系统信息，如inode&#x2F;block的大小、总量、使用量、剩余量，以及文件系统的格式与相关信息。超级块在每个块组的开头都有一份拷贝（第一个块组必须有，后面的块组可以没有）。</p>
<p>为了保证文件系统在磁盘部分扇区出现物理问题的情况下还能正常工作，就必须保证文件系统的super block信息在这种情况下也能正常访问。所以一个文件系统的super block会在多个block group中进行备份，这些super block区域的数据保持一致。<br>超级块记录的信息有：</p>
<p>1、block 与 inode 的总量（分区内所有Block Group的block和inode总量）；<br><br>2、未使用与已使用的 inode &#x2F; block 数量；<br><br>3、block 与 inode 的大小 (block 为 1, 2, 4K，inode 为 128 bytes)；<br><br>4、filesystem 的挂载时间、最近一次写入数据的时间、最近一次检验磁盘 (fsck) 的时间等文件系统的相关信息；<br><br>5、一个 valid bit 数值，若此文件系统已被挂载，则 valid bit 为 0 ，若未被挂载，则 valid bit 为 1 。</p>
<p>它的结构如图所示</p>
<p><img src="https://user-images.githubusercontent.com/87457873/127258220-b1552054-6178-43ad-8c24-a811304be7e9.png" alt="image"></p>
<p>对于ext2&#x2F;3&#x2F;4文件系统，以上介绍的这些inode bitmap, data block bitmap和inode table，都可以通过一个名为”dumpe2fs”的工具来查看其在磁盘上的具体位置</p>
<h3 id="GDT-1"><a href="#GDT-1" class="headerlink" title="GDT"></a>GDT</h3><p>2）块组描述符表(GDT,Group Descriptor Table)由很多块组描述符组成，整个分区分成多个块组就对应有多少个块组描述符。<br><br>每个块组描述符存储一个块组的描述信息，如在这个块组中从哪里开始是inode Table，从哪里开始是Data Blocks，空闲的inode和数据块还有多少个等等。</p>
<h3 id="Inode-和-Block-位图"><a href="#Inode-和-Block-位图" class="headerlink" title="Inode 和 Block 位图"></a>Inode 和 Block 位图</h3><p>4）inode位图(inode Bitmap)和块位图类似，本身占一个块，其中每个bit表示一个inode是否空闲可用。 Inode bitmap的作用是记录block group中Inode区域的使用情况，Ext文件系统中一个block group中可以有16384个Inode，代表着这个Ext文件系统中一个block group最多可以描述16384个文件。</p>
<p><img src="https://user-images.githubusercontent.com/87457873/127258296-59565548-134a-431f-9ed8-4a410beb400f.png" alt="image"></p>
<h3 id="inode"><a href="#inode" class="headerlink" title="inode"></a>inode</h3><p>索引表的索引结构称为inode，是”index node”的简称，用来索引，跟踪一个文件的所有块。inode是文件索引结构组织形式的具体体现，一个文件就必须对应一个inode。</p>
<p>5）inode表(inode Table)由一个块组中的所有inode组成。一个文件除了数据需要存储之外，一些描述信息也需要存储，如文件类型，权限，文件大小，创建、修改、访问时间等，这些信息存在inode中而不是数据块中。</p>
<p>inode表占多少个块在格式化时就要写入块组描述符中。 在Ext2&#x2F;Ext3文件系统中，每个文件在磁盘上的位置都由文件系统block group中的一个Inode指针进行索引，Inode将会把具体的位置指向一些真正记录文件数据的block块，需要注意的是这些block可能和Inode同属于一个block group也可能分属于不同的block group。我们把文件系统上这些真实记录文件数据的block称为Data blocks。</p>
<p>索引表本身要占用存储空间，如果文件很大时，块就比较多，索引表就会很大。UNIX为了解决这个问题，采用间接索引表来处理。</p>
<p><img src="https://user-images.githubusercontent.com/87457873/127258340-8ae8a93b-198c-4a73-a7d8-e2adffcb5bea.png" alt="image"></p>
<p>ls -i 命令可以显示inode 号</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">➜  command ls -ilt</span><br><span class="line">total 24</span><br><span class="line">3003623(inode号) -rwxr-xr-x  1 root  root    78  8 10 16:43 jump</span><br><span class="line">3003622(inode号) -rwxr-xr-x  1 root  root   476  8 10 16:42 jumper.sh</span><br><span class="line">3003624(inode号) -rwxr-xr-x  1 root  root  3346  3 24  2019 imgcat</span><br></pre></td></tr></table></figure>
<h3 id="data-block"><a href="#data-block" class="headerlink" title="data block"></a>data block</h3><p>6）数据块(Data Block)是用来放置文件内容数据的地方。根据不同的文件类型有以下几种情况：<br><br>对于普通文件，文件的数据存储在数据块中。<br><br>对于目录，该目录下的所有文件名和目录名存储在所在目录的数据块中，除了文件名外，ls -l命令看到的其它信息保存在该文件的inode中。<br></p>
<h2 id="文件分区实践"><a href="#文件分区实践" class="headerlink" title="文件分区实践"></a>文件分区实践</h2><p>我们根据实践一下磁盘分区的步骤，实践一下ext4下的文件管理系统的步骤。我们的系统如下。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">Linux CentOS7 3.10.0-1127.el7.x86_64 #1 SMP Tue Mar 31 23:36:51 UTC 2020 x86_64 x86_64 x86_64 GNU/Linux</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>首先第一步，我们需要一块硬盘，用于我是CentOS7的系统，这里我在虚拟机上新建了一块硬盘,容量是1G，这块硬盘还没有格式，我可以在我的&#x2F;dev 目录下找到这块硬盘。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">[root@CentOS7 ~]# ls /dev/sd*</span><br><span class="line">/dev/sda  /dev/sda1  /dev/sda2  /dev/sdb</span><br></pre></td></tr></table></figure>

<p>查看分区,我一共有两块硬盘，一块是sda,一块是sdb。我们接下来需要格式化一下sdb.</p>
<h3 id="格式化硬盘"><a href="#格式化硬盘" class="headerlink" title="格式化硬盘"></a>格式化硬盘</h3><p>首先，我们需要用fdisk 将sdb</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">[root@CentOS7 ~]# fdisk /dev/sdb</span><br><span class="line">欢迎使用 fdisk (util-linux 2.23.2)。</span><br><span class="line"></span><br><span class="line">更改将停留在内存中，直到您决定将更改写入磁盘。</span><br><span class="line">使用写入命令前请三思。</span><br><span class="line"></span><br><span class="line">Device does not contain a recognized partition table</span><br><span class="line">使用磁盘标识符 0x30c1a40d 创建新的 DOS 磁盘标签。</span><br><span class="line"></span><br><span class="line">命令(输入 m 获取帮助)：m  #获取帮助命令</span><br><span class="line">命令操作</span><br><span class="line">   a   toggle a bootable flag</span><br><span class="line">   b   edit bsd disklabel</span><br><span class="line">   c   toggle the dos compatibility flag</span><br><span class="line">   d   delete a partition</span><br><span class="line">   g   create a new empty GPT partition table</span><br><span class="line">   G   create an IRIX (SGI) partition table</span><br><span class="line">   l   list known partition types</span><br><span class="line">   m   print this menu</span><br><span class="line">   n   add a new partition</span><br><span class="line">   o   create a new empty DOS partition table</span><br><span class="line">   p   print the partition table</span><br><span class="line">   q   quit without saving changes</span><br><span class="line">   s   create a new empty Sun disklabel</span><br><span class="line">   t   change a partition&#x27;s system id</span><br><span class="line">   u   change display/entry units</span><br><span class="line">   v   verify the partition table</span><br><span class="line">   w   write table to disk and exit</span><br><span class="line">   x   extra functionality (experts only)</span><br><span class="line"></span><br><span class="line">命令(输入 m 获取帮助)：n</span><br><span class="line">Partition type:</span><br><span class="line">   p   primary (0 primary, 0 extended, 4 free)   （这里表示，我们没有任何分许，允许你创建4个可用分区，0个主分区，和一个逻辑分区）</span><br><span class="line">   e   extended</span><br><span class="line">Select (default p): p   （我们来创建主分区）</span><br><span class="line">分区号 (1-4，默认 1)：    （选择分区号，默认即可）</span><br><span class="line">起始 扇区 (2048-2097151，默认为 2048)：      （0-2048） # 前2048是系统预留空间 </span><br><span class="line">将使用默认值 2048</span><br><span class="line">Last 扇区, +扇区 or +size&#123;K,M,G&#125; (2048-2097151，默认为 2097151)：  （我们直接全部将1g划分为这个分区）</span><br><span class="line">将使用默认值 2097151</span><br><span class="line">分区 1 已设置为 Linux 类型，大小设为 1023 MiB</span><br></pre></td></tr></table></figure>

<h3 id="创建文件系统"><a href="#创建文件系统" class="headerlink" title="创建文件系统"></a>创建文件系统</h3><p>使用CentOS7 自带的文件系统格式工具，将sdb整个硬盘格式化成ext4文件格式。<br><br>mke2fs：ext系列文件系统专用管理工具<br></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">[root@CentOS7 ~]# mkfs.ext4 /dev/sdb</span><br><span class="line">mke2fs 1.42.9 (28-Dec-2013)</span><br><span class="line">/dev/sdb is entire device, not just one partition!</span><br><span class="line">无论如何也要继续? (y,n) y</span><br><span class="line">文件系统标签=</span><br><span class="line">OS type: Linux</span><br><span class="line">块大小=4096 (log=2)  </span><br><span class="line">分块大小=4096 (log=2)</span><br><span class="line">Stride=0 blocks, Stripe width=0 blocks</span><br><span class="line">65536 inodes, 262144 blocks   # inodes数量和blicks 是数量</span><br><span class="line">13107 blocks (5.00%) reserved for the super user</span><br><span class="line">第一个数据块=0</span><br><span class="line">Maximum filesystem blocks=268435456</span><br><span class="line">8 block groups      # 8个块组</span><br><span class="line">32768 blocks per group, 32768 fragments per group</span><br><span class="line">8192 inodes per group                   # 每组 inode 的数量</span><br><span class="line">Superblock backups stored on blocks:    # 超级快的存贮位置</span><br><span class="line">	32768, 98304, 163840, 229376</span><br><span class="line"></span><br><span class="line">Allocating group tables: 完成</span><br><span class="line">正在写入inode表: 完成</span><br><span class="line">Creating journal (8192 blocks): 完成  # 创建日志区</span><br><span class="line">Writing superblocks and filesystem accounting information: 完成</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h3 id="查看分区"><a href="#查看分区" class="headerlink" title="查看分区"></a>查看分区</h3><p>经过生面的步骤，我们已经将分区创建完毕，我们使用blkid 命令来查看一下分区</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">[root@CentOS7 ~]# blkid</span><br><span class="line">/dev/sda1: UUID=&quot;79678d4f-9276-4d1e-8093-28623d77461e&quot; TYPE=&quot;xfs&quot;</span><br><span class="line">/dev/sda2: UUID=&quot;FtqgeH-yiRM-f1Wr-73LT-QkQf-2kgX-BkXYi1&quot; TYPE=&quot;LVM2_member&quot;</span><br><span class="line">/dev/sr0: UUID=&quot;2020-04-22-00-54-00-00&quot; LABEL=&quot;CentOS 7 x86_64&quot; TYPE=&quot;iso9660&quot; PTTYPE=&quot;dos&quot;</span><br><span class="line">/dev/mapper/centos-root: UUID=&quot;d0412c8e-07f5-4716-8be7-8ed2da9affca&quot; TYPE=&quot;xfs&quot;</span><br><span class="line">/dev/mapper/centos-swap: UUID=&quot;ac1ae2c7-d653-4496-97fa-d9315f56993f&quot; TYPE=&quot;swap&quot;</span><br><span class="line">/dev/sdb: UUID=&quot;6285b923-0ee4-444d-9c68-d6af94914bc3&quot; TYPE=&quot;ext4&quot;</span><br></pre></td></tr></table></figure>

<h3 id="查看-超级块和块组"><a href="#查看-超级块和块组" class="headerlink" title="查看 超级块和块组"></a>查看 超级块和块组</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">dumpe2fs 1.42.9 (28-Dec-2013)</span><br><span class="line">Filesystem volume name:   &lt;none&gt;</span><br><span class="line">Last mounted on:          &lt;not available&gt;</span><br><span class="line">Filesystem UUID:          6285b923-0ee4-444d-9c68-d6af94914bc3</span><br><span class="line">Filesystem magic number:  0xEF53</span><br><span class="line">Filesystem revision #:    1 (dynamic)</span><br><span class="line">Filesystem features:      has_journal ext_attr resize_inode dir_index filetype extent 64bit flex_bg sparse_super large_file huge_file uninit_bg dir_nlink extra_isize</span><br><span class="line">Filesystem flags:         signed_directory_hash</span><br><span class="line">Default mount options:    user_xattr acl</span><br><span class="line">Filesystem state:         clean</span><br><span class="line">Errors behavior:          Continue</span><br><span class="line">Filesystem OS type:       Linux</span><br><span class="line">Inode count:              65536</span><br><span class="line">Block count:              262144</span><br><span class="line">Reserved block count:     13107</span><br><span class="line">Free blocks:              249189</span><br><span class="line">Free inodes:              65525</span><br><span class="line">First block:              0</span><br><span class="line">Block size:               4096</span><br><span class="line">Fragment size:            4096</span><br><span class="line">Group descriptor size:    64</span><br><span class="line">Reserved GDT blocks:      127</span><br><span class="line">Blocks per group:         32768</span><br><span class="line">Fragments per group:      32768</span><br><span class="line">Inodes per group:         8192</span><br><span class="line">Inode blocks per group:   512</span><br><span class="line">Flex block group size:    16</span><br><span class="line">Filesystem created:       Wed Sep 30 12:22:05 2020</span><br><span class="line">Last mount time:          n/a</span><br><span class="line">Last write time:          Wed Sep 30 12:22:05 2020</span><br><span class="line">Mount count:              0</span><br><span class="line">Maximum mount count:      -1</span><br><span class="line">Last checked:             Wed Sep 30 12:22:05 2020</span><br><span class="line">Check interval:           0 (&lt;none&gt;)</span><br><span class="line">Lifetime writes:          33 MB</span><br><span class="line">Reserved blocks uid:      0 (user root)</span><br><span class="line">Reserved blocks gid:      0 (group root)</span><br><span class="line">First inode:              11</span><br><span class="line">Inode size:	          256</span><br><span class="line">Required extra isize:     28</span><br><span class="line">Desired extra isize:      28</span><br><span class="line">Journal inode:            8</span><br><span class="line">Default directory hash:   half_md4</span><br><span class="line">Directory Hash Seed:      61f49ab4-d494-4be8-95b7-404358b685aa</span><br><span class="line">Journal backup:           inode blocks</span><br><span class="line">Journal features:         (none)</span><br><span class="line">日志大小:             32M</span><br><span class="line">Journal length:           8192</span><br><span class="line">Journal sequence:         0x00000001</span><br><span class="line">Journal start:            0</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">Group 0: (Blocks 0-32767)</span><br><span class="line">  Checksum 0x4cc2, unused inodes 8181</span><br><span class="line">  主 superblock at 0, Group descriptors at 1-1</span><br><span class="line">  保留的GDT块位于 2-128</span><br><span class="line">  Block bitmap at 129 (+129), Inode bitmap at 145 (+145)</span><br><span class="line">  Inode表位于 161-672 (+161)</span><br><span class="line">  28521 free blocks, 8181 free inodes, 2 directories, 8181个未使用的inodes</span><br><span class="line">  可用块数: 142-144, 153-160, 4258-32767</span><br><span class="line">  可用inode数: 12-8192</span><br><span class="line">Group 1: (Blocks 32768-65535) [INODE_UNINIT]</span><br><span class="line">  Checksum 0xabae, unused inodes 8192</span><br><span class="line">  备份 superblock at 32768, Group descriptors at 32769-32769</span><br><span class="line">  保留的GDT块位于 32770-32896</span><br><span class="line">  Block bitmap at 130 (bg #0 + 130), Inode bitmap at 146 (bg #0 + 146)</span><br><span class="line">  Inode表位于 673-1184 (bg #0 + 673)</span><br><span class="line">  32639 free blocks, 8192 free inodes, 0 directories, 8192个未使用的inodes</span><br><span class="line">  可用块数: 32897-65535</span><br><span class="line">  可用inode数: 8193-16384</span><br><span class="line"></span><br><span class="line">...</span><br></pre></td></tr></table></figure>



]]></content>
      <categories>
        <category>linux-doc 文件系统</category>
      </categories>
      <tags>
        <tag>Linux</tag>
      </tags>
  </entry>
  <entry>
    <title>Linux 操作系统原理-文件系统(2)</title>
    <url>/2023/01/15/linux-docs/%E6%96%87%E4%BB%B6%E7%B3%BB%E7%BB%9F/Linux%20%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E5%8E%9F%E7%90%86-%E6%96%87%E4%BB%B6%E7%B3%BB%E7%BB%9F(2)/</url>
    <content><![CDATA[<h1 id="文件类型"><a href="#文件类型" class="headerlink" title="文件类型"></a>文件类型</h1><h2 id="普通文件类型"><a href="#普通文件类型" class="headerlink" title="普通文件类型"></a>普通文件类型</h2><p>理解了文件系统的结构之后，我们来看一下文件的类型。</p>
<p>Linux以文件的形式对计算机中的数据和硬件资源进行管理，也就是彻底的一切皆文件，反映在Linux的文件类型上就是：<strong>普通文件、目录文件（也就是文件夹）、设备文件、链接文件、管道文件、套接字文件（数据通信的接口）</strong>等等。而这些种类繁多的文件被Linux使用目录树进行管理， 所谓的目录树就是以根目录（&#x2F;）为主，向下呈现分支状的一种文件结构。</p>
<h2 id="普通文件"><a href="#普通文件" class="headerlink" title="普通文件"></a>普通文件</h2><p>从Linux的角度来说，类似mp4、pdf、html这样应用层面上的文件类型都属于普通文件，Linux用户可以根据访问权限对普通文件进行查看、更改和删除。我们知道，文件的属性，权限，大小，占用那些数据块是存在inode当中。所以，这里注意一旦，inode 当中并没有存放文件名，至于为什么，我们接下来看目录文件。</p>
<h2 id="目录文件"><a href="#目录文件" class="headerlink" title="目录文件"></a>目录文件</h2><p>本质上来书，目录页是文件，目录文件inode除了存放一些目录的权限，等属性之外，目录文件的内容则是该目录文件下文件名和其inode编号的一个映射关系。最简单的保存格式就是列表，就是一项一项地将目录下的文件信息（如文件名、文件 inode、文件类型等）列在表里。</p>
<p>文件目录块：</p>
<p><img src="https://user-images.githubusercontent.com/87457873/127259047-5adc0559-7bc4-40ae-adfd-47d3069e240b.png" alt="image"></p>
<p>通常，第一项是「.」，表示当前目录，第二项是「…」，表示上一级目录，接下来就是一项一项的文件名和 inode。<br><br>如果一个目录有超级多的文件，我们要想在这个目录下找文件，按照列表一项一项的找，效率就不高了。</p>
<p>于是，保存目录的格式改成哈希表，对文件名进行哈希计算，把哈希值保存起来，如果我们要查找一个目录下面的文件名，可以通过名称取哈希。如果哈希能够匹配上，就说明这个文件的信息在相应的块里面。</p>
<p>Linux 系统的 ext 文件系统就是采用了哈希表，来保存目录的内容，这种方法的优点是查找非常迅速，插入和删除也较简单，不过需要一些预备措施来避免哈希冲突。</p>
<p>目录查询是通过在磁盘上反复搜索完成，需要不断地进行 I&#x2F;O 操作，开销较大。所以，为了减少 I&#x2F;O 操作，把当前使用的文件目录缓存在内存，以后要使用该文件时只要在内存中操作，从而降低了磁盘操作次数，提高了文件系统的访问速度。</p>
<p>文件inode</p>
<p><img src="https://user-images.githubusercontent.com/87457873/127259071-0e35aac3-e667-4204-b77d-fb0a84b0e13c.png" alt="image"></p>
<h2 id="文件操作"><a href="#文件操作" class="headerlink" title="文件操作"></a>文件操作</h2><h3 id="文件链接"><a href="#文件链接" class="headerlink" title="文件链接"></a>文件链接</h3><ul>
<li>硬链接</li>
</ul>
<p>一般情况下，文件名和inode号码是”一一对应”关系，每个inode号码对应一个文件名。但是，Unix&#x2F;Linux系统允许，多个文件名指向同一个inode号码。<br><br>这意味着，可以用不同的文件名访问同样的内容；对文件内容进行修改，会影响到所有文件名；但是，删除一个文件名，不影响另一个文件名的访问。这种情况就被称为”硬链接”（hard link）。<br></p>
<p>其实原理很简单，我们会在某个目录下创建一个文件名，这个文件名和硬链接的文件inode 相同，并且会在这个inode的记录中增加链接数量。<br><br>我们看到的就是两个链接到同一个inode 的文件其实是一个文件和inode的映射。<br></p>
<p><img src="https://user-images.githubusercontent.com/87457873/127259141-450a7bff-0d2d-484e-bf24-c7b583979c2f.png" alt="image"></p>
<p>ln命令可以创建硬链接：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">root@CentOS7 lnDemo]# ln source source_ln</span><br><span class="line">[root@CentOS7 lnDemo]# ls -ali</span><br><span class="line">总用量 8</span><br><span class="line">33575032 drwxr-xr-x. 2 root root  37 9月  30 17:35 .</span><br><span class="line">33574977 dr-xr-x---. 4 root root 161 9月  30 17:34 ..</span><br><span class="line">33575033 -rw-r--r--. 2 root root   7 9月  30 17:31 source</span><br><span class="line">33575033 -rw-r--r--. 2 root root   7 9月  30 17:31 source_ln</span><br><span class="line">[root@CentOS7 lnDemo]# stat source</span><br><span class="line">  文件：&quot;source&quot;</span><br><span class="line">  大小：7         	块：8          IO 块：4096   普通文件</span><br><span class="line">设备：fd00h/64768d	Inode：33575033    硬链接：2</span><br><span class="line">权限：(0644/-rw-r--r--)  Uid：(    0/    root)   Gid：(    0/    root)</span><br><span class="line">环境：unconfined_u:object_r:admin_home_t:s0</span><br><span class="line">最近访问：2020-09-30 17:34:54.975711266 +0800</span><br><span class="line">最近更改：2020-09-30 17:31:49.124074625 +0800</span><br><span class="line">最近改动：2020-09-30 17:35:05.665345071 +0800</span><br><span class="line">创建时间：-</span><br><span class="line">[root@CentOS7 lnDemo]# stat source_ln</span><br><span class="line">  文件：&quot;source_ln&quot;</span><br><span class="line">  大小：7         	块：8          IO 块：4096   普通文件</span><br><span class="line">设备：fd00h/64768d	Inode：33575033    硬链接：2</span><br><span class="line">权限：(0644/-rw-r--r--)  Uid：(    0/    root)   Gid：(    0/    root)</span><br><span class="line">环境：unconfined_u:object_r:admin_home_t:s0</span><br><span class="line">最近访问：2020-09-30 17:34:54.975711266 +0800</span><br><span class="line">最近更改：2020-09-30 17:31:49.124074625 +0800</span><br><span class="line">最近改动：2020-09-30 17:35:05.665345071 +0800</span><br><span class="line">创建时间：-</span><br></pre></td></tr></table></figure>
<p>根据我们上面的研究，我们发现，硬链接有一下几个问题：</p>
<ul>
<li><p>目录不允许硬链接</p>
</li>
<li><p>如果目录允许硬链接，那么我们完全可以将两个目录链接起来，那么操作系统则在找文件的时候，就会在两个目录跳来跳去，形成死循环。</p>
<p>  [root@CentOS7 ~]# ln lnDemo&#x2F; .&#x2F;lnDemo2<br>  ln: “lnDemo&#x2F;“: 不允许将硬链接指向目录<br>  [root@CentOS7 ~]#</p>
</li>
<li><p>不同分区不允许硬链接</p>
</li>
</ul>
<p>由于硬链接是在本分区指向相同的inode，那么就意味着inode的命名空间需要一直，但是不同的分区，inode的编号将会重置，所有不能通过inode映射同一个文件。</p>
<p><img src="https://user-images.githubusercontent.com/87457873/127259234-3a1e665a-5c6c-4b52-994a-adae12042e7e.png" alt="image"></p>
<ul>
<li>软连接</li>
</ul>
<p>而软连接则不同，当创建软连接的时候，linux确实已经创建了一个inode 和起对应来的data block，只不过，在data block存放的是字符串，字符串的内容则是 链接文件的地址。</p>
<pre><code>[root@CentOS7 lnDemo]# ln -s source source_sln
[root@CentOS7 lnDemo]# ls
source  source_sln
[root@CentOS7 lnDemo]# ls -alt
总用量 4
drwxr-xr-x. 2 root root  38 9月  30 18:08 .
lrwxrwxrwx. 1 root root   6 9月  30 18:08 source_sln -&gt; source
dr-xr-x---. 5 root root 172 9月  30 17:55 ..
-rw-r--r--. 1 root root   7 9月  30 17:31 source
[root@CentOS7 lnDemo]# ls -ailt
总用量 4
33575032 drwxr-xr-x. 2 root root  38 9月  30 18:08 .
33575034 lrwxrwxrwx. 1 root root   6 9月  30 18:08 source_sln -&gt; source
33574977 dr-xr-x---. 5 root root 172 9月  30 17:55 ..
33575033 -rw-r--r--. 1 root root   7 9月  30 17:31 source
</code></pre>
<p>我们发现 source_sln 的文件类型为 l ，且inode和source 不同。大小很小，原因就是我们存放的是地址字符。</p>
<p><img src="https://user-images.githubusercontent.com/87457873/127259326-bead1541-3a1f-4ffe-af9a-1045e7ec77e2.png" alt="image"></p>
<h3 id="文件新建-复制"><a href="#文件新建-复制" class="headerlink" title="文件新建(复制)"></a>文件新建(复制)</h3><ul>
<li>(1).读取GDT，找到各个(或部分)块组imap中未使用的inode号，并为待存储文件分配inode号；</li>
<li>((2).在inode table中完善该inode号所在行的记录；</li>
<li>((3).在目录的data block中添加一条该文件的相关记录；</li>
<li>((4).将数据填充到data block中。</li>
</ul>
<blockquote>
<p>注意，填充到data block中的时候会调用block分配器：一次分配4KB大小的block数量，当填充完4KB的data block后会继续调用block分配器分配4KB的block，然后循环直到填充完所有数据。也就是说，如果存储一个100M的文件需要调用block分配器100*1024&#x2F;4&#x3D;25600次。<br>另一方面，在block分配器分配block时，block分配器并不知道真正有多少block要分配，只是每次需要分配时就分配，在每存储一个data block前，就去bmap中标记一次该block已使用，它无法实现一次标记多个bmap位。这一点在ext4中进行了优化。</p>
</blockquote>
<ul>
<li>(5)填充完之后，去inode table中更新该文件inode记录中指向data block的寻址指针。</li>
</ul>
<h3 id="文件删除"><a href="#文件删除" class="headerlink" title="文件删除"></a>文件删除</h3><p>删除文件分为普通文件和目录文件，知道了这两种类型的文件的删除原理，就知道了其他类型特殊文件的删除方法。</p>
<p>对于删除普通文件：</p>
<ul>
<li><p>(1)找到文件的inode和data block(根据前一个小节中的方法寻找)；</p>
</li>
<li><p>(1.5) 如果inode的硬链接是数量不是1 ，则将硬链接的数量-1， 否则执行真正的删除。</p>
</li>
<li><p>(2)将inode table中该inode记录中的data block指针删除；</p>
</li>
<li><p>(3)在imap中将该文件的inode号标记为未使用；</p>
</li>
<li><p>(4)在其所在目录的data block中将该文件名所在的记录行删除，删除了记录就丢失了指向inode的指针（实际上不是真的删除，直接删除的话会在目录data block的数据结构中产生空洞，所以实际的操作是将待删除文件的inode号设置为特殊的值0，这样下次新建文件时就可以重用该行记录）；</p>
</li>
<li><p>(5)将bmap中data block对应的block号标记为未使用。</p>
</li>
<li><p>对于删除目录文件：</p>
</li>
<li><p>找到目录和目录下所有文件、子目录、子文件的inode和data block；</p>
</li>
<li><p>在imap中将这些inode号标记为未使用；将bmap中将这些文件占用的 block号标记为未使用；</p>
</li>
<li><p>在该目录的父目录的data block中将该目录名所在的记录行删除。需要注意的是，删除父目录data block中的记录是最后一步，如果该步骤提前，将报目录非空的错误，因为在该目录中还有文件占用。</p>
</li>
</ul>
<h3 id="文件搜索"><a href="#文件搜索" class="headerlink" title="文件搜索"></a>文件搜索</h3><p>当执行”cat &#x2F;var&#x2F;log&#x2F;messages”命令在系统内部进行了什么样的步骤呢？</p>
<ul>
<li>找到根文件系统的块组描述符表所在的blocks，读取GDT(已在内存中)找到inode table的block号。</li>
</ul>
<blockquote>
<p>根文件系统是不需被引用的，因为在操作系统加载到内存当中的时候，跟文件系统已经存在，其中第inode编号也已经注册到了操作系统内核当中。根文件系统的GDT早已经在内存中了，在系统开机的时候会挂载根文件系统，挂载的时候就已经将所有的GDT放进内存中。</p>
</blockquote>
<ul>
<li>在inode table的block中定位到根”&#x2F;“的inode，找出”&#x2F;“指向的data block。</li>
<li>在”&#x2F;“的datablock中记录了var目录名和var的inode号，找到该inode记录，inode记录中存储了指向var的block指针，所以也就找到了var目录文件的data block。</li>
<li>通过var目录的inode号，可以寻找到var目录的inode记录，但是在寻找的过程中，还需要知道该inode记录所在的块组以及所在的inode table，所以需要读取GDT，同样，GDT已经缓存到了内存中。</li>
<li>在var的data block中记录了log目录名和其inode号，通过该inode号定位到该inode所在的块组及所在的inode table，并根据该inode记录找到log的data block。</li>
<li>在log目录文件的data block中记录了messages文件名和对应的inode号，通过该inode号定位到该inode所在的块组及所在的inode table，并根据该inode记录找到messages的data block。</li>
<li>最后读取messages对应的datablock。</li>
<li>当然，在每次定位到inode记录后，都会先将inode记录加载到内存中，然后查看权限，如果权限允许，将根据block指针找到对应的data block。</li>
</ul>
<h3 id="文件移动"><a href="#文件移动" class="headerlink" title="文件移动"></a>文件移动</h3><p>同文件系统下移动文件实际上是修改目标文件所在目录的data block，向其中添加一行指向inode table中待移动文件的inode指针，如果目标路径下有同名文件，则会提示是否覆盖，实际上是覆盖目录data block中冲突文件的记录，由于同名文件的inode记录指针被覆盖，所以无法再找到该文件的data block，也就是说该文件被标记为删除</p>
<p>所以在同文件系统内移动文件相当快，仅仅在所在目录data block中添加或覆盖了一条记录而已。也因此，移动文件时，文件的inode号是不会改变的。</p>
<p>对于不同文件系统内的移动，相当于先复制再删除的动作。</p>
<h3 id="文件挂载"><a href="#文件挂载" class="headerlink" title="文件挂载"></a>文件挂载</h3><p>Linux 系统下，文件是虚拟文件系统，当我们ls &#x2F; 的时候，linux 会吧所有磁盘，所有分区下的且挂载在根目录下的所有目录列出来。<br>挂载文件系统到某个目录下，例如”mount &#x2F;dev&#x2F;cdrom &#x2F;mnt”，挂载成功后&#x2F;mnt目录中的文件全都暂时不可见了，且挂载后权限和所有者(如果指定允许普通用户挂载)等的都改变了，知道为什么吗？</p>
<p>下面就以通过”mount &#x2F;dev&#x2F;cdrom &#x2F;mnt”为例，详细说明挂载过程中涉及的细节。</p>
<p>在将文件系统&#x2F;dev&#x2F;cdrom(此处暂且认为它是文件系统)挂载到挂载点&#x2F;mnt之前，挂载点&#x2F;mnt是根文件系统中的一个目录，”&#x2F;“的data block中记录了&#x2F;mnt的一些信息，其中包括inode号inode_n，而在inode table中，&#x2F;mnt对应的inode记录中又存储了block指针block_n，此时这两个指针还是普通的指针。</p>
<p><img src="https://user-images.githubusercontent.com/87457873/127259551-c9648157-bc90-4dd9-b91d-6eda8cb057a3.png" alt="image"></p>
<p>当文件系统&#x2F;dev&#x2F;cdrom挂载到&#x2F;mnt上后，&#x2F;mnt此时就已经成为另一个文件系统的入口了，因此它需要连接两边文件系统的inode和data block。</p>
<p><img src="https://user-images.githubusercontent.com/87457873/127259607-ccf610e6-bbc0-4154-a5b6-feffc6c6f204.png" alt="image"></p>
<ul>
<li>在根文件系统的inode table中，为&#x2F;mnt重新分配一个inode记录m，该记录的block指针block_m指向文件系统&#x2F;dev&#x2F;cdrom中的data block。</li>
<li>&#x2F;mnt分配了新的inode记录m，那么在”&#x2F;“目录的data block中，也需要修改其inode指针为inode_m以指向m记录。</li>
<li>同时，原来inode table中的inode记录n就被标记为暂时不可用。</li>
</ul>
<p>block_m指向的是文件系统&#x2F;dev&#x2F;cdrom的data block，所以严格说起来，除了&#x2F;mnt的元数据信息即inode记录m还在根文件系统上，&#x2F;mnt的data block已经是在&#x2F;dev&#x2F;cdrom中的了。这就是挂载新文件系统后实现的跨文件系统，它将挂载点的元数据信息和数据信息分别存储在不同的文件系统上。</p>
<blockquote>
<p>挂载完成后，将在&#x2F;proc&#x2F;self&#x2F;{mounts,mountstats,mountinfo}这三个文件中写入挂载记录和相关的挂载信息，并会将&#x2F;proc&#x2F;self&#x2F;mounts中的信息同步到&#x2F;etc&#x2F;mtab文件中，当然，如果挂载时加了-n参数，将不会同步到&#x2F;etc&#x2F;mtab。</p>
</blockquote>
<p>而卸载文件系统，其实质是移除临时新建的inode记录(当然，在移除前会检查是否正在使用)及其指针，并将指针指回原来的inode记录，这样inode记录中的block指针也就同时生效而找回对应的data block了。由于卸载只是移除inode记录，所以使用挂载点和文件系统都可以实现卸载，因为它们是联系在一起的。</p>
<p>下面是分析或结论。</p>
<p>(1).挂载点挂载时的inode记录是新分配的。</p>
<p>挂载前挂载点&#x2F;mnt的inode号</p>
<pre><code>[root@server2 tmp]# ll -id /mnt
100663447 drwxr-xr-x. 2 root root 6 Aug 12  2015 /mnt


[root@server2 tmp]# mount /dev/cdrom /mnt
# 挂载后挂载点的inode号
[root@server2 tmp]# ll -id /mnt 
1856 dr-xr-xr-x    8 root root  2048 Dec 10  2015 mnt
由此可以验证，inode号确实是重新分配的。
</code></pre>
<p>(2).挂载后，挂载点的内容将暂时不可见、不可用，卸载后文件又再次可见、可用。   </p>
<p>在挂载前，向挂载点中创建几个文件</p>
<pre><code>[root@server2 tmp]# touch /mnt/a.txt
[root@server2 tmp]# mkdir /mnt/abcdir
# 挂载
[root@server2 tmp]# mount /dev/cdrom /mnt
</code></pre>
<p>挂载后，挂载点中将找不到刚创建的文件</p>
<pre><code>[root@server2 tmp]# ll /mnt
total 636
-r--r--r-- 1 root root     14 Dec 10  2015 CentOS_BuildTag
dr-xr-xr-x 3 root root   2048 Dec 10  2015 EFI
-r--r--r-- 1 root root    215 Dec 10  2015 EULA
-r--r--r-- 1 root root  18009 Dec 10  2015 GPL
dr-xr-xr-x 3 root root   2048 Dec 10  2015 images
dr-xr-xr-x 2 root root   2048 Dec 10  2015 isolinux
dr-xr-xr-x 2 root root   2048 Dec 10  2015 LiveOS
dr-xr-xr-x 2 root root 612352 Dec 10  2015 Packages
dr-xr-xr-x 2 root root   4096 Dec 10  2015 repodata
-r--r--r-- 1 root root   1690 Dec 10  2015 RPM-GPG-KEY-CentOS-7
-r--r--r-- 1 root root   1690 Dec 10  2015 RPM-GPG-KEY-CentOS-Testing-7
-r--r--r-- 1 root root   2883 Dec 10  2015 TRANS.TBL
</code></pre>
<p>卸载后，挂载点&#x2F;mnt中的文件将再次可见 </p>
<pre><code>[root@server2 tmp]# umount /mnt
[root@server2 tmp]# ll /mnt
total 0
drwxr-xr-x 2 root root 6 Jun  9 08:18 abcdir
-rw-r--r-- 1 root root 0 Jun  9 08:18 a.txt
</code></pre>
<p>之所以会这样，是因为挂载文件系统后，挂载点原来的inode记录暂时被标记为不可用，关键是没有指向该inode记录的inode指针了。在卸载文件系统后，又重新启用挂载点原来的inode记录，”&#x2F;“目录下的mnt的inode指针又重新指向该inode记录。</p>
<p>(3).挂载后，挂载点的元数据和data block是分别存放在不同文件系统上的。<br><br>(4).挂载点即使在挂载后，也还是属于源文件系统的文件。</p>
<h3 id="文件描述符"><a href="#文件描述符" class="headerlink" title="文件描述符"></a>文件描述符</h3><p>先看一段最文件描述符的官方说明</p>
<blockquote>
<p>维基百科:文件描述符在形式上是一个非负整数。实际上，它是一个索引值，指向内核为每一个进程所维护的该进程打开文件的记录表。当程序打开一个现有文件或者创建一个新文件时，内核向进程返回一个文件描述符。在程序设计中，一些涉及底层的程序编写往往会围绕着文件描述符展开。</p>
</blockquote>
<ul>
<li>作用</li>
</ul>
<p>Linux 系统中，把一切都看做是文件，当进程打开现有文件或创建新文件时，内核向进程返回一个文件描述符，文件描述符就是内核为了高效管理已被打开的文件所创建的索引，用来指向被打开的文件，所有执行I&#x2F;O操作的系统调用都会通过文件描述符。</p>
<ul>
<li><p>概念定义</p>
<ul>
<li>文件描述符 是 用来访问资源(文件，输入输出设备等)的一种抽象指示符。</li>
<li>文件描述符 是POSIX(Portable Operating System Interface)规范的组成部分</li>
<li>文件描述符 通常是非负整数，C 语言中使用int类型。</li>
</ul>
</li>
<li><p>FD 具体可以指向什么</p>
<ul>
<li>文件&#x2F;目录 files&#x2F;directories</li>
<li>输入输出源 input&#x2F;output</li>
<li>管道 pipes</li>
<li>套接字 sockets</li>
<li>其他 Unix 文件类型 other Unix files</li>
</ul>
</li>
<li><p>默认的fds</p>
<ul>
<li>每一个 Unix 进程中，通常会有三个预制的 FD。它们分别是</li>
<li>标准输入 Standard input 标准输入 用于程序接受数据</li>
<li>标准输出 Standard output 标准输出 用于程序输出数据</li>
<li>标准错误(输出) Standard error 标准错误 用于程序输出错误或者诊断信息</li>
</ul>
</li>
<li><p>文件描述符的意义<br>一个 Linux 进程启动后，会在内核空间中创建一个 PCB 控制块，PCB 内部有一个文件描述符表（File descriptor table），记录着当前进程所有可用的文件描述符，也即当前进程所有打开的文件。</p>
</li>
</ul>
<p>除了文件描述符表，系统还需要维护另外两张表：<br><br>打开文件表（Open file table）<br><br>i-node 表（i-node table）<br></p>
<p>文件描述符表每个进程都有一个，打开文件表和 i-node 表整个系统只有一个，它们三者之间的关系如下图所示。</p>
<p><img src="https://user-images.githubusercontent.com/87457873/127260023-82df0e08-da4f-47dd-8718-0e5ec71cca4a.png" alt="image"></p>
<h4 id="文件描述符的意义"><a href="#文件描述符的意义" class="headerlink" title="文件描述符的意义"></a>文件描述符的意义</h4><blockquote>
<p>首先，为什么不把文件位置干脆存放在索引节点中，而要多此一举，设一个新的数据结构呢？我们知道，Linux中的文件是能够共享的，假如把文件位置存放在索引节点中，则如果有两个或更多个进程同时打开同一个文件时，它们将去访问同一个索引节点，于是一个进程的LSEEK操作将影响到另一个进程的读操作，这显然是不允许也是不可想象的。</p>
</blockquote>
<blockquote>
<p>另一个想法是既然进程是通过文件描述符访问文件的，为什么不用一个与文件描述符数组相平行的数组来保存每个打开文件的文件位置？这个想法也是不能实现的，原因就在于在生成一个新进程时，子进程要共享父进程的所有信息，包括文件描述符数组。</p>
</blockquote>
<blockquote>
<p>我们知道，一个文件不仅可以被不同的进程分别打开，而且也可以被同一个进程先后多次打开。一个进程如果先后多次打开同一个文件，则每一次打开都要分配一个新的文件描述符，并且指向一个新的file结构，尽管它们都指向同一个索引节点，但是，如果一个子进程不和父进程共享同一个file结构，而是也如上面一样，分配一个新的file结构，会出现什么情况了？让我们来看一个例子：</p>
</blockquote>
<blockquote>
<p>假设有一个输出重定位到某文件A的shell script（shell脚本），我们知道，shell是作为一个进程运行的，当它生成第一个子进程时，将以0作为A的文件位置开始输出，假设输出了2K的数据，则现在文件位置为2K。然后，shell继续读取脚本，生成另一个子进程，它要共享shell的file结构，也就是共享文件位置，所以第二个进程的文件位置是2K，将接着第一个进程输出内容的后面输出。如果shell不和子进程共享文件位置，则第二个进程就有可能重写第一个进程的输出了，这显然不是希望得到的结果。</p>
</blockquote>
<h4 id="查看文件描述符"><a href="#查看文件描述符" class="headerlink" title="查看文件描述符"></a>查看文件描述符</h4><p>lsof（list open files）是一个查看当前系统文件的工具。在linux环境下，任何事物都以文件的形式存在，通过文件不仅仅可以访问常规数据，还可以访问网络连接和硬件。如传输控制协议 (TCP) 和用户数据报协议 (UDP) 套接字等，系统在后台都为该应用程序分配了一个文件描述符，该文件描述符提供了大量关于这个应用程序本身的信息。</p>
<p>lsof打开的文件可以是：</p>
<ul>
<li>普通文件</li>
<li>目录</li>
<li>网络文件系统的文件</li>
<li>字符或设备文件</li>
<li>(函数)共享库</li>
<li>管道，命名管道</li>
<li>符号链接</li>
<li>网络文件（例如：NFS file、网络socket，unix域名socket）</li>
<li>还有其它类型的文件，等等</li>
</ul>
<p>我们用java 新写一段代码</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">    <span class="type">String</span> <span class="variable">s</span> <span class="operator">=</span><span class="string">&quot;/tmp/file.test&quot;</span>;</span><br><span class="line">    <span class="type">FileOutputStream</span> <span class="variable">fileOutputStream</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">FileOutputStream</span>(<span class="keyword">new</span> <span class="title class_">File</span>(s));</span><br><span class="line">    System.in.read();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>运行上述代码，并用jps找到其对应的pid</p>
<p>利用lsof -i 命令来查看</p>
<pre><code>...
java    36562 lizhipeng  mem    REG  253,0    142144    50547 /usr/lib64/libpthread-2.17.so
java    36562 lizhipeng  mem    REG  253,0    163312    42066 /usr/lib64/ld-2.17.so
java    36562 lizhipeng  mem    REG  253,0     32768 51151094 /tmp/hsperfdata_lizhipeng/36562
java    36562 lizhipeng    0u   CHR  136,4       0t0        7 /dev/pts/4
java    36562 lizhipeng    1u   CHR  136,4       0t0        7 /dev/pts/4
java    36562 lizhipeng    2u   CHR  136,4       0t0        7 /dev/pts/4
java    36562 lizhipeng    3r   REG  253,0  73861866 33613070 /usr/lib/jvm/java-1.8.0-openjdk-1.8.0.262.b10-0.el7_8.x86_64/jre/lib/rt.jar
java    36562 lizhipeng    4r   REG  253,0   1027597 33613060 /usr/lib/jvm/java-1.8.0-openjdk-1.8.0.262.b10-0.el7_8.x86_64/jre/lib/jfr.jar
java    36562 lizhipeng    5w   REG  253,0         0 33671497 /tmp/file.test
</code></pre>
<h3 id="PCB-进程控制块"><a href="#PCB-进程控制块" class="headerlink" title="PCB 进程控制块"></a>PCB 进程控制块</h3><p>为了描述控制进程的运行，系统中存放进程的管理和控制信息的数据结构称为进程控制块（PCB Process Control Block），它是进程实体的一部分，是操作系统中最重要的记录性数据结构。它是进程管理和控制的最重要的数据结构，每一个进程均有一个PCB，在创建进程时，建立PCB，伴随进程运行的全过程，直到进程撤消而撤消。 在linux中 PCB 用task_struct 数据结构来表示</p>
<h4 id="PCB"><a href="#PCB" class="headerlink" title="PCB"></a>PCB</h4><p><img src="https://user-images.githubusercontent.com/87457873/127260213-b63330b6-8cf3-410a-9c66-fffdd49fd339.png" alt="image"></p>
<h4 id="fs-struct"><a href="#fs-struct" class="headerlink" title="fs_struct"></a>fs_struct</h4><p>1、与进程相关的文件<br><br>首先，文件必须由进程打开，每个进程都有它自己当前的工作目录和它自己的根目录。task_struct的fs字段指向进程的fs_struct结构，files字段指向进程的files_struct结构。</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">fs_struct</span> &#123;</span></span><br><span class="line"> <span class="type">atomic_t</span> count;</span><br><span class="line"> <span class="type">rwlock_t</span> lock;</span><br><span class="line"> <span class="type">int</span> umask;</span><br><span class="line"> <span class="class"><span class="keyword">struct</span> <span class="title">dentry</span> * <span class="title">root</span>, * <span class="title">pwd</span>, * <span class="title">altroot</span>;</span></span><br><span class="line"> <span class="class"><span class="keyword">struct</span> <span class="title">vfsmount</span> * <span class="title">rootmnt</span>, * <span class="title">pwdmnt</span>, * <span class="title">altrootmnt</span>;</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<ul>
<li>count：共享这个表的进程个数</li>
<li>lock：用于表中字段的读&#x2F;写自旋锁</li>
<li>umask：当打开文件设置文件权限时所使用的位掩码</li>
<li>root：根目录的目录项</li>
<li>pwd：当前工作目录的目录项</li>
</ul>
<h4 id="files-struct"><a href="#files-struct" class="headerlink" title="files_struct"></a>files_struct</h4><p>每个进程用一个 files_struct 结构来记录文件描述符的使用情况， 这个 files_struct结构称为用户打开文件表， 它是进程的私有数据。 files_struct 结构在include&#x2F;linux&#x2F;sched.h 中定义如下：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">files_struct</span> &#123;</span></span><br><span class="line">    <span class="type">atomic_t</span> count;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">fdtable</span> *<span class="title">fdt</span>;</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">fdtable</span>  <span class="title">fdtab</span>;</span></span><br><span class="line">   </span><br><span class="line">    <span class="type">int</span> next_fd;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">embedded_fd_set</span> <span class="title">close_on_exec_init</span>;</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">embedded_fd_set</span> <span class="title">open_fds_init</span>;</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">file</span> * <span class="title">fd_array</span>[<span class="title">NR_OPEN_DEFAULT</span>];</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p><img src="https://user-images.githubusercontent.com/87457873/127260307-d1fb06e0-c458-4e13-b16f-270dac82429b.png" alt="image"></p>
<h4 id="ulimit"><a href="#ulimit" class="headerlink" title="ulimit"></a>ulimit</h4><p>ulimit命令可以查看当前shell下的文件描述符的数量。</p>
<p>ulimit 用于限制 shell 启动进程所占用的资源，支持以下各种类型的限制：所创建的内核文件的大小、进程数据块的大小、Shell 进程创建文件的大小、内存锁住的大小、常驻内存集的大小、打开文件描述符的数量、分配堆栈的最大大小、CPU 时间、单个用户的最大线程数、Shell 进程所能使用的最大虚拟内存。同时，它支持硬资源和软资源的限制。</p>
<p>作为临时限制，ulimit 可以作用于通过使用其命令登录的 shell 会话，在会话终止时便结束限制，并不影响于其他 shell 会话。而对于长期的固定限制，ulimit 命令语句又可以被添加到由登录 shell 读取的文件中，作用于特定的 shell 用户。</p>
<p>语法：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">ulimit (选项)</span><br><span class="line">选项：</span><br><span class="line"></span><br><span class="line">-a：显示目前资源限制的设定；</span><br><span class="line">-c ：设定core文件的最大值，单位为区块； </span><br><span class="line">-d &lt;数据节区大小&gt;：程序数据节区的最大值，单位为KB； </span><br><span class="line">-f &lt;文件大小&gt;：shell所能建立的最大文件，单位为区块； </span><br><span class="line">-H：设定资源的硬性限制，也就是管理员所设下的限制； </span><br><span class="line">-m &lt;内存大小&gt;：指定可使用内存的上限，单位为KB； </span><br><span class="line">-n &lt;文件数目&gt;：指定同一时间最多可开启的文件数； </span><br><span class="line">-p &lt;缓冲区大小&gt;：指定管道缓冲区的大小，单位512字节； </span><br><span class="line">-s &lt;堆叠大小&gt;：指定堆叠的上限，单位为KB； </span><br><span class="line">-S：设定资源的弹性限制； </span><br><span class="line">-t ：指定CPU使用时间的上限，单位为秒； </span><br><span class="line">-u &lt;程序数目&gt;：用户最多可开启的程序数目； </span><br><span class="line">-v &lt;虚拟内存大小&gt;：指定可使用的虚拟内存上限，单位为KB。</span><br><span class="line">实例：</span><br></pre></td></tr></table></figure>

<p>来看一下具体的用法</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">[root@Centos ~]# ulimit -a</span><br><span class="line">core file size          (blocks, -c) 0            #core文件的最大值为100 blocks。</span><br><span class="line">data seg size           (kbytes, -d) unlimited    #进程的数据段可以任意大。</span><br><span class="line">scheduling priority            (-e) 0</span><br><span class="line">file size              (blocks, -f) unlimited    #文件可以任意大。</span><br><span class="line">pending signals               (-i) 3794         #最多有98304个待处理的信号。</span><br><span class="line">max locked memory         (kbytes, -l) 64           #一个任务锁住的物理内存的最大值为32KB。</span><br><span class="line">max memory size          (kbytes, -m) unlimited    #一个任务的常驻物理内存的最大值。</span><br><span class="line">open files                  (-n) 1024         #一个任务最多可以同时打开1024的文件。</span><br><span class="line">pipe size            (512 bytes, -p) 8            #管道的最大空间为4096字节。</span><br><span class="line">POSIX message queues        (bytes, -q) 819200       #POSIX的消息队列的最大值为819200字节。</span><br><span class="line">real-time priority             (-r) 0</span><br><span class="line">stack size             (kbytes, -s) 10240        #进程的栈的最大值为10240字节。</span><br><span class="line">cpu time              (seconds, -t) unlimited    #进程使用的CPU时间。</span><br><span class="line">max user processes             (-u) 1024         #当前用户同时打开的进程（包括线程）的最大个数为98304。</span><br><span class="line">virtual memory          (kbytes, -v) unlimited    #没有限制进程的最大地址空间。</span><br><span class="line">file locks                  (-x) unlimited    #所能锁住的文件的最大个数没有限制。</span><br><span class="line">Linux默认的文件打开数是1024,现在设置打开数为2048.</span><br><span class="line"></span><br><span class="line">[root@Centos ~]# ulimit -n        --查看打开数为1024</span><br><span class="line">1024</span><br><span class="line">[root@Centos ~]# ulimit -n 2048   --设置打开数为2048</span><br><span class="line">[root@Centos ~]# ulimit -n        --再次查看</span><br><span class="line">2048</span><br></pre></td></tr></table></figure>
<h1 id="特殊文件类型"><a href="#特殊文件类型" class="headerlink" title="特殊文件类型"></a>特殊文件类型</h1><ul>
<li>Linux设备驱动程序工作原理</li>
<li>系统调用是操作系统内核和应用程序之间的接口，设备驱动程序是操作系统内核和机器硬件之间的接口。设备驱动程序为应用程序屏蔽了硬件的细节，这样在应用程序看来，硬件设备只是一个设备文件， 应用程序可以象操作普通文件一样对硬件设备进行操作。设备驱动程序是内核的一部分，运行在核心态，它完成以下的功能：</li>
</ul>
<p>1.对设备初始化和释放.<br><br>2.把数据从内核传送到硬件和从硬件读取数据.<br><br>3.读取应用程序传送给设备文件的数据和回送应用程序请求的数据.<br><br>4.检测和处理设备出现的错误.<br></p>
<p>在Linux操作系统下有三类主要的设备文件类型：字符设备、块设备和网络接口。<br>字符设备和块设备的主要区别是：在对字符设备发出读&#x2F;写请求时，实际的硬件I&#x2F;O一般就紧接着发生了块设备则不然，它利用一块系统内存作缓冲区，当用户进程对设备请求能满足用户的要求，就返回请求的数据，如果不能，就调用请求函数来进行实际的I&#x2F;O操作。这也就是进程管理的<strong>Page cache</strong>的作用，块设备是主要针对磁盘等慢速设备设计的，以免耗费过多的CPU时间来等待。</p>
<blockquote>
<p>换句话说， 当发生块设备的IO的时候， 操作系统实际是先写到Page cache上，而 pageCashe 会有一个映射规则，映射到某个块设备的具体地址，在发生操作以系统的IO的时候，比如说 写某个文件 当我们点击保存的时候，实际是写到了Page cache上， 此时操作系统将当前pageCash标记为脏页，之后如何将脏页刷新会磁盘就要看各个操作系统策略了。</p>
</blockquote>
<h2 id="字符设备、块设备"><a href="#字符设备、块设备" class="headerlink" title="字符设备、块设备"></a>字符设备、块设备</h2><p>每个设备文件都有其文件属性(c&#x2F;b)，表示是字符设备还是块设备, 另外每个文件都有两个设备号，第一个是主设备号，标识驱动程序，第二个是从设备号，标识使用同一个设备驱动程序的不同的硬件设备，比如有两个软盘，就可以用 从设备号来区分他们。设备文件的的主设备号必须与设备驱动程序在登记时申请的主设备号一致，否则用户进程将无法访问到驱动程序。</p>
<p>我可以通过 ls 来看一下</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">命令：ls -alti</span><br><span class="line">输出详解：</span><br><span class="line"># =================== </span><br><span class="line">10605  (inode 编号)</span><br><span class="line">brw-rw----.   b 块设备， c 字符设备   </span><br><span class="line">1 </span><br><span class="line">root （所属用户）</span><br><span class="line">cdrom （用户组）   </span><br><span class="line">11,（主设备号）   </span><br><span class="line">0（次设备号） </span><br><span class="line">10月 12 17:41 </span><br><span class="line">sr0 设备名称</span><br><span class="line"># =================== </span><br><span class="line">ex:</span><br><span class="line"></span><br><span class="line">10445 brw-rw----.  1 root disk      8,   1 10月 12 17:41 sda1</span><br><span class="line">10446 brw-rw----.  1 root disk      8,   2 10月 12 17:41 sda2</span><br><span class="line">10444 brw-rw----.  1 root disk      8,   0 10月 12 17:41 sda</span><br><span class="line">10449 brw-rw----.  1 root disk      8,  16 10月 12 17:41 sdb</span><br><span class="line"> 8535 crw-------.  1 root root    247,   1 10月 12 17:41 usbmon1</span><br><span class="line">10104 crw-------.  1 root root    246,   0 10月 12 17:41 hidraw0</span><br><span class="line"> 8550 crw-------.  1 root root    247,   2 10月 12 17:41 usbmon2</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<ul>
<li>文件操作的关键结构</li>
</ul>
<p>由于用户进程是通过设备文件同硬件打交道，对设备文件的操作方式不外乎就是一些系统调用，如 open，read，write，close…， 注意，不是fopen， fread，但是如何把系统调用和驱动程序关联起来呢?这需要了解一个非常关键的数据结构 file_operations:</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">file_operations</span> &#123;</span></span><br><span class="line">    <span class="type">int</span> (*seek) (<span class="keyword">struct</span> inode * ，<span class="keyword">struct</span> file *， <span class="type">off_t</span> ，<span class="type">int</span>);</span><br><span class="line">    <span class="type">int</span> (*read) (<span class="keyword">struct</span> inode * ，<span class="keyword">struct</span> file *， <span class="type">char</span> ，<span class="type">int</span>);</span><br><span class="line">    <span class="type">int</span> (*write) (<span class="keyword">struct</span> inode * ，<span class="keyword">struct</span> file *， <span class="type">off_t</span> ，<span class="type">int</span>);</span><br><span class="line">    <span class="type">int</span> (*readdir) (<span class="keyword">struct</span> inode * ，<span class="keyword">struct</span> file *， <span class="keyword">struct</span> dirent * ，<span class="type">int</span>);</span><br><span class="line">    <span class="type">int</span> (*select) (<span class="keyword">struct</span> inode * ，<span class="keyword">struct</span> file *， <span class="type">int</span> ，select_table *);</span><br><span class="line">    <span class="type">int</span> (*ioctl) (<span class="keyword">struct</span> inode * ，<span class="keyword">struct</span> file *， unsined <span class="type">int</span> ，<span class="type">unsigned</span> <span class="type">long</span>);</span><br><span class="line">    <span class="type">int</span> (*mmap) (<span class="keyword">struct</span> inode * ，<span class="keyword">struct</span> file *， <span class="keyword">struct</span> vm_area_struct *);</span><br><span class="line">    <span class="type">int</span> (*open) (<span class="keyword">struct</span> inode * ，<span class="keyword">struct</span> file *);</span><br><span class="line">    <span class="type">int</span> (*release) (<span class="keyword">struct</span> inode * ，<span class="keyword">struct</span> file *);</span><br><span class="line">    <span class="type">int</span> (*fsync) (<span class="keyword">struct</span> inode * ，<span class="keyword">struct</span> file *);</span><br><span class="line">    <span class="type">int</span> (*fasync) (<span class="keyword">struct</span> inode * ，<span class="keyword">struct</span> file *，<span class="type">int</span>);</span><br><span class="line">    <span class="type">int</span> (*check_media_change) (<span class="keyword">struct</span> inode * ，<span class="keyword">struct</span> file *);</span><br><span class="line">    <span class="type">int</span> (*revalidate) (<span class="type">dev_t</span> dev);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这个结构的每一个成员的名字都对应着一个系统调用。用户进程利用系统调用在对设备文件进行诸如read&#x2F;write操作时，系统调用通过设备文件的主设备号找到相应的设备驱动程序，然后读取这个数据结构相应的函数指针，接着把控制权交给该函数。这是linux的设备驱动程序工作的基本原理<br>这里不再详细阐述。</p>
<h2 id="链接文件"><a href="#链接文件" class="headerlink" title="链接文件"></a>链接文件</h2><p>软连接文件，详情请看上文 文件链接</p>
<h2 id="管道文件"><a href="#管道文件" class="headerlink" title="管道文件"></a>管道文件</h2><ul>
<li>什么是管道？</li>
</ul>
<p>管道，英文为pipe。这是一个我们在学习Linux命令行的时候就会引入的一个很重要的概念。它的发明人是道格拉斯.麦克罗伊，这位也是UNIX上早期shell的发明人。他在发明了shell之后，发现系统操作执行命令的时候，经常有需求要将一个程序的输出交给另一个程序进行处理，这种操作可以使用输入输出重定向加文件搞定，比如：</p>
<pre><code>[lizhipeng@CentOS7 ~]$ ls /etc/ &gt; etc.txt
[lizhipeng@CentOS7 ~]$ wc -l etc.txt
</code></pre>
<p>但是这样未免显得太麻烦了。所以，管道的概念应运而生。目前在任何一个shell中，都可以使用“|”连接两个命令，shell会将前后两个进程的输入输出用一个管道相连，以便达到进程间通信的目的：</p>
<pre><code>[lizhipeng@CentOS7 ~]$ ls -l /etc/ | wc -l
</code></pre>
<p>对比以上两种方法，我们也可以理解为，管道本质上就是一个文件，前面的进程以写方式打开文件，后面的进程以读方式打开。这样前面写完后面读，于是就实现了通信。实际上管道的设计也是遵循UNIX的“一切皆文件”设计原则的，它本质上就是一个文件。Linux系统直接把管道实现成了一种文件系统，借助VFS给应用程序提供操作接口。</p>
<p>虽然实现形态上是文件，但是管道本身并不占用磁盘或者其他外部存储的空间。在Linux的实现上，它占用的是内存空间。所以，Linux上的管道就是一个操作方式为文件的内存缓冲区。</p>
<p>Linux上的管道分两种类型：</p>
<ul>
<li>匿名管道</li>
<li>命名管道</li>
</ul>
<p>这两种管道也叫做有名或无名管道。匿名管道最常见的形态就是我们在shell操作中最常用的”|”。它的特点是只能在父子进程中使用，父进程在产生子进程前必须打开一个管道文件，然后fork产生子进程，这样子进程通过拷贝父进程的进程地址空间获得同一个管道文件的描述符，以达到使用同一个管道通信的目的。此时除了父子进程外，没人知道这个管道文件的描述符，所以通过这个管道中的信息无法传递给其他进程。这保证了传输数据的安全性，当然也降低了管道了通用性，于是系统还提供了命名管道。</p>
<p>我们可以使用mkfifo或mknod命令来创建一个命名管道，这跟创建一个文件没有什么区别：</p>
<pre><code>[lizhipeng@CentOS7 ~]$ mkfifo pip
[lizhipeng@CentOS7 ~]$ ls
prw-rw-r--. 1 lizhipeng lizhipeng      0 11月 17 13:24 pip
</code></pre>
<p>可以看到创建出来的文件类型比较特殊，是p类型。表示这是一个管道文件。有了这个管道文件，系统中就有了对一个管道的全局名称，于是任何两个不相关的进程都可以通过这个管道文件进行通信了。比如我们现在让一个进程写这个管道文件：</p>
<pre><code>[lizhipeng@CentOS7 ~]$ echo xxxxxxxxxxxxxx &gt; pip
</code></pre>
<p>此时这个写操作会阻塞，因为管道另一端没有人读。这是内核对管道文件定义的默认行为。此时如果有进程读这个管道，那么这个写操作的阻塞才会解除：</p>
<pre><code>[lizhipeng@CentOS7 ~]$  cat pip
xxxxxxxxxxxxxx
</code></pre>
<p>大家可以观察到，当我们cat完这个文件之后，另一端的echo命令也返回了。这就是命名管道</p>
<p>接下来我们来看一下匿名管道，我们需要用到 shell 的代码块 命令如下</p>
<pre><code>[lizhipeng@CentOS7 ~]$ &#123; echo $BASHPID; read x ; &#125; | &#123; cat ; echo $BASHPID;  read y; &#125;
37057
</code></pre>
<p>{} 花括号的代码会先执行，遇到管道后，会开启另外一个进程，两个进程实现通讯。此时父进程输出了父进程的pid<br><br>且阻塞在了read x 这个代码块中，此时我们可以通过结果拿到父进程的 pid 37057</p>
<p>我们通过pstree来验证一下我们的关系</p>
<pre><code>[lizhipeng@CentOS7 ~]$ pstree -p
...
           ─sshd(36387)───bash(36388)─┬─bash(37057+
           │            │             └─bash(37058+
           │            └─sshd(36713)───sshd(36717)───bash(36718)───pstree(370+

...
</code></pre>
<p>我们看到了 37057 进程生出了 37058的子进程。我们来看一下管道的文件描述符</p>
<pre><code>[lizhipeng@CentOS7 fd]$ ls -alt /proc/37057/fd
总用量 0
lrwx------. 1 lizhipeng lizhipeng 64 11月 17 13:33 0 -&gt; /dev/pts/4
l-wx------. 1 lizhipeng lizhipeng 64 11月 17 13:33 1 -&gt; pipe:[253711]
lrwx------. 1 lizhipeng lizhipeng 64 11月 17 13:33 2 -&gt; /dev/pts/4
lrwx------. 1 lizhipeng lizhipeng 64 11月 17 13:33 255 -&gt; /dev/pts/4
dr-x------. 2 lizhipeng lizhipeng  0 11月 17 13:33 .
dr-xr-xr-x. 9 lizhipeng lizhipeng  0 11月 17 13:30 ..

[lizhipeng@CentOS7 fd]$ ls -alt /proc/37058/fd
总用量 0
lr-x------. 1 lizhipeng lizhipeng 64 11月 17 13:34 0 -&gt; pipe:[253711]
lrwx------. 1 lizhipeng lizhipeng 64 11月 17 13:34 1 -&gt; /dev/pts/4
lrwx------. 1 lizhipeng lizhipeng 64 11月 17 13:34 2 -&gt; /dev/pts/4
lrwx------. 1 lizhipeng lizhipeng 64 11月 17 13:34 255 -&gt; /dev/pts/4
dr-x------. 2 lizhipeng lizhipeng  0 11月 17 13:34 .
dr-xr-xr-x. 9 lizhipeng lizhipeng  0 11月 17 13:30 ..
</code></pre>
<p>由此我们可以看到，37057 通过重定向 1 号文件描述符来讲管道 重定向到了 37058 的0号描述符。<br><br>这就是匿名管道。</p>
]]></content>
      <categories>
        <category>linux-doc 文件系统</category>
      </categories>
      <tags>
        <tag>Linux</tag>
      </tags>
  </entry>
  <entry>
    <title>Linux内核sysfs文件系统</title>
    <url>/2023/01/15/linux-docs/%E6%96%87%E4%BB%B6%E7%B3%BB%E7%BB%9F/Linux%E5%86%85%E6%A0%B8sysfs%E6%96%87%E4%BB%B6%E7%B3%BB%E7%BB%9F/</url>
    <content><![CDATA[<p>内核源码：linux-2.6.38.8.tar.bz2</p>
<p>目标平台：ARM体系结构</p>
<p>sysfs是基于内存的文件系统，用于向用户空间导出内核对象并且能对其进行读写。</p>
<p>1、sysfs文件系统不支持特殊文件，只支持目录、普通文件（文本或二进制文件）和符号链接文件等三种类型，在内核中都使用struct sysfs_dirent结构体来表示，相当于其他文件系统在硬盘或flash里的数据。源代码如下所示：</p>
<figure class="highlight text"><table><tr><td class="code"><pre><span class="line">/* fs/sysfs/sysfs.h */</span><br><span class="line">struct sysfs_dirent &#123;</span><br><span class="line">	atomic_t		s_count;	//struct sysfs_dirent结构体实例自身的引用计数</span><br><span class="line">	atomic_t		s_active;	//struct sysfs_elem_*所涉及的外部对象的引用计数</span><br><span class="line">#ifdef CONFIG_DEBUG_LOCK_ALLOC</span><br><span class="line">	struct lockdep_map	dep_map; //死锁检测模块，针对s_attr.attr中的key或skey</span><br><span class="line">#endif</span><br><span class="line">	struct sysfs_dirent	*s_parent;	//指向父节点</span><br><span class="line">	struct sysfs_dirent	*s_sibling; //同级节点链表，插入到父节点的s_dir.children链表中</span><br><span class="line">	const char		*s_name;	//文件名</span><br><span class="line"> </span><br><span class="line">	const void		*s_ns;		//命名空间</span><br><span class="line">	union &#123;</span><br><span class="line">		struct sysfs_elem_dir		s_dir;		//目录</span><br><span class="line">		struct sysfs_elem_symlink	s_symlink;	//符号链接文件</span><br><span class="line">		struct sysfs_elem_attr		s_attr;		//文本文件</span><br><span class="line">		struct sysfs_elem_bin_attr	s_bin_attr;	//二进制文件</span><br><span class="line">	&#125;;</span><br><span class="line"> </span><br><span class="line">	unsigned int		s_flags;	//标志，表示struct sysfs_dirent类型、命名空间类型等信息</span><br><span class="line">	unsigned short		s_mode;		//文件访问权限，包含文件类型信息</span><br><span class="line">	ino_t			s_ino;			//对应于i节点号</span><br><span class="line">	struct sysfs_inode_attrs *s_iattr;	//文件属性</span><br><span class="line">&#125;;</span><br><span class="line"> </span><br><span class="line">struct sysfs_inode_attrs &#123;</span><br><span class="line">	struct iattr	ia_iattr;	//文件属性</span><br><span class="line">	void		*ia_secdata;	//安全检测模块所用数据</span><br><span class="line">	u32		ia_secdata_len;		//ia_secdata所指数据的长度</span><br><span class="line">&#125;;</span><br><span class="line"> </span><br><span class="line">/* include/linux/fs.h */</span><br><span class="line">struct iattr &#123;</span><br><span class="line">	unsigned int	ia_valid;	//文件属性标志</span><br><span class="line">	umode_t		ia_mode;		//文件类型及其访问权限</span><br><span class="line">	uid_t		ia_uid;			//用户ID</span><br><span class="line">	gid_t		ia_gid;			//组ID</span><br><span class="line">	loff_t		ia_size;		//文件大小</span><br><span class="line">	struct timespec	ia_atime;	//访问时间</span><br><span class="line">	struct timespec	ia_mtime;	//数据修改时间</span><br><span class="line">	struct timespec	ia_ctime;	//元数据修改时间</span><br><span class="line"> </span><br><span class="line">	struct file	*ia_file;	//辅助信息，用于想实现ftruncate等方法的文件系统</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>



<p><a href="https://link.zhihu.com/?target=https://so.csdn.net/so/search?q=struct&spm=1001.2101.3001.7020">struct</a> sysfs_dirent分为四种类型，如下所示：</p>
<figure class="highlight text"><table><tr><td class="code"><pre><span class="line">/* fs/sysfs/sysfs.h */</span><br><span class="line">struct sysfs_elem_dir &#123;</span><br><span class="line">	struct kobject		*kobj;	//指向内核对象</span><br><span class="line">	//子节点链表，只有目录才有可能包含文件或子目录</span><br><span class="line">	//子节点通过s_sibling成员以s_ino成员升序的方式插入到该链表</span><br><span class="line">	struct sysfs_dirent	*children;</span><br><span class="line">&#125;;</span><br><span class="line"> </span><br><span class="line">struct sysfs_elem_symlink &#123;</span><br><span class="line">	struct sysfs_dirent	*target_sd;	//指向所链接的节点</span><br><span class="line">&#125;;</span><br><span class="line"> </span><br><span class="line">struct sysfs_elem_attr &#123;</span><br><span class="line">	struct attribute	*attr;	//对象属性</span><br><span class="line">	struct sysfs_open_dirent *open;	//文件open信息，其中buffers成员是struct sysfs_buffer的链表</span><br><span class="line">&#125;;</span><br><span class="line"> </span><br><span class="line">struct sysfs_elem_bin_attr &#123;</span><br><span class="line">	struct bin_attribute	*bin_attr;	//二进制的对象属性</span><br><span class="line">	struct hlist_head	buffers; //struct bin_buffer的链表</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>struct sysfs_open_dirent等结构体的详细信息后文说明。</p>
<p>2、sysfs文件系统的初始化是由sysfs_init函数来完成的（该函数由vfs_caches_init函数所调用的mnt_init函数调用），执行文件系统的注册和挂载，与rootfs根文件系统的相关操作类似。源代码如下所示：</p>
<figure class="highlight text"><table><tr><td class="code"><pre><span class="line">/* fs/sysfs/mount.c */</span><br><span class="line">static struct vfsmount *sysfs_mnt;</span><br><span class="line">struct kmem_cache *sysfs_dir_cachep;</span><br><span class="line"> </span><br><span class="line">int __init sysfs_init(void)</span><br><span class="line">&#123;</span><br><span class="line">	int err = -ENOMEM;</span><br><span class="line"> </span><br><span class="line">	sysfs_dir_cachep = kmem_cache_create(&quot;sysfs_dir_cache&quot;,</span><br><span class="line">					      sizeof(struct sysfs_dirent),</span><br><span class="line">					      0, 0, NULL);  //创建用于struct sysfs_dirent的高速缓存</span><br><span class="line">	if (!sysfs_dir_cachep)</span><br><span class="line">		goto out;</span><br><span class="line">	</span><br><span class="line">	//初始化后备存储介质相关结构体struct backing_dev_info（sysfs文件系统基于内存，无须数据同步）</span><br><span class="line">	err = sysfs_inode_init(); </span><br><span class="line">	if (err)</span><br><span class="line">		goto out_err;</span><br><span class="line"> </span><br><span class="line">	err = register_filesystem(&amp;sysfs_fs_type); //注册文件系统</span><br><span class="line">	if (!err) &#123; //成功返回零</span><br><span class="line">		sysfs_mnt = kern_mount(&amp;sysfs_fs_type); //挂载文件系统，不过没有将sysfs_mnt所指的结构体实例插入到挂载树中</span><br><span class="line">		if (IS_ERR(sysfs_mnt)) &#123;</span><br><span class="line">			printk(KERN_ERR &quot;sysfs: could not mount!\n&quot;);</span><br><span class="line">			err = PTR_ERR(sysfs_mnt);</span><br><span class="line">			sysfs_mnt = NULL;</span><br><span class="line">			unregister_filesystem(&amp;sysfs_fs_type);</span><br><span class="line">			goto out_err;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125; else</span><br><span class="line">		goto out_err;</span><br><span class="line">out:</span><br><span class="line">	return err;</span><br><span class="line">out_err:</span><br><span class="line">	kmem_cache_destroy(sysfs_dir_cachep);</span><br><span class="line">	sysfs_dir_cachep = NULL;</span><br><span class="line">	goto out;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>在用户空间一般都将sysfs文件系统挂载在&#x2F;sys目录，而这里也有一次通过kern_mount函数的挂载，这样的话 sysfs文件系统就会挂载两次？其实是没有的，后者的挂载并没有将当前的struct vfsmount结构体实例插入到挂载树中，而是保存在全局指针sysfs_mnt中，并且会与用户空间挂载sysfs文件系统时所创建的struct vfsmount结构体实例共享相同的超级块。因此，无论用户空间的挂载操作是否执行，sysfs文件系统都会存在于内核之中（编译内核有配置CONFIG_SYSFS选项）。sysfs文件系统的struct file_system_type结构体实例如下所示：</p>
<figure class="highlight text"><table><tr><td class="code"><pre><span class="line">/* fs/sysfs/mount.c */</span><br><span class="line">static struct file_system_type sysfs_fs_type = &#123;</span><br><span class="line">	.name		= &quot;sysfs&quot;,</span><br><span class="line">	.mount		= sysfs_mount,</span><br><span class="line">	.kill_sb	= sysfs_kill_sb,</span><br><span class="line">&#125;;</span><br><span class="line"> </span><br><span class="line">static struct dentry *sysfs_mount(struct file_system_type *fs_type,</span><br><span class="line">	int flags, const char *dev_name, void *data)</span><br><span class="line">&#123;</span><br><span class="line">	struct sysfs_super_info *info;</span><br><span class="line">	enum kobj_ns_type type;</span><br><span class="line">	struct super_block *sb;</span><br><span class="line">	int error;</span><br><span class="line"> </span><br><span class="line">	info = kzalloc(sizeof(*info), GFP_KERNEL); //分配私有数据所用内存</span><br><span class="line">	if (!info)</span><br><span class="line">		return ERR_PTR(-ENOMEM);</span><br><span class="line">	</span><br><span class="line">	//构建超级块私有数据，用于sysfs_test_super和sysfs_set_super函数</span><br><span class="line">	for (type = KOBJ_NS_TYPE_NONE; type &lt; KOBJ_NS_TYPES; type++) </span><br><span class="line">		info-&gt;ns[type] = kobj_ns_current(type);</span><br><span class="line"> </span><br><span class="line">	sb = sget(fs_type, sysfs_test_super, sysfs_set_super, info); //查找或创建超级块</span><br><span class="line">	if (IS_ERR(sb) || sb-&gt;s_fs_info != info)  </span><br><span class="line">		kfree(info);</span><br><span class="line">	if (IS_ERR(sb))</span><br><span class="line">		return ERR_CAST(sb);</span><br><span class="line">	if (!sb-&gt;s_root) &#123; //如果根目录项为空指针，则说明超级块sb是新创建的</span><br><span class="line">		sb-&gt;s_flags = flags;</span><br><span class="line">		error = sysfs_fill_super(sb, data, flags &amp; MS_SILENT ? 1 : 0); //填充超级块</span><br><span class="line">		if (error) &#123;</span><br><span class="line">			deactivate_locked_super(sb);</span><br><span class="line">			return ERR_PTR(error);</span><br><span class="line">		&#125;</span><br><span class="line">		sb-&gt;s_flags |= MS_ACTIVE;</span><br><span class="line">	&#125;</span><br><span class="line"> </span><br><span class="line">	return dget(sb-&gt;s_root);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<p>其中，sysfs_test_super函数用于判断struct sysfs_super_info结构体数据是否相同以便确认是否可以共享超级块，源代码如下所示：</p>
<figure class="highlight text"><table><tr><td class="code"><pre><span class="line">/* include/linux/kobject_ns.h */</span><br><span class="line">enum kobj_ns_type &#123;</span><br><span class="line">	KOBJ_NS_TYPE_NONE = 0,</span><br><span class="line">	KOBJ_NS_TYPE_NET,</span><br><span class="line">	KOBJ_NS_TYPES</span><br><span class="line">&#125;;</span><br><span class="line"> </span><br><span class="line">/* fs/sysfs/sysfs.h */</span><br><span class="line">struct sysfs_super_info &#123;</span><br><span class="line">	const void *ns[KOBJ_NS_TYPES];</span><br><span class="line">&#125;;</span><br><span class="line"> </span><br><span class="line">/* fs/sysfs/mount.c */</span><br><span class="line">static int sysfs_test_super(struct super_block *sb, void *data)</span><br><span class="line">&#123;</span><br><span class="line">	struct sysfs_super_info *sb_info = sysfs_info(sb); //sb-&gt;s_fs_info</span><br><span class="line">	struct sysfs_super_info *info = data;</span><br><span class="line">	enum kobj_ns_type type;</span><br><span class="line">	int found = 1;</span><br><span class="line"> </span><br><span class="line">	for (type = KOBJ_NS_TYPE_NONE; type &lt; KOBJ_NS_TYPES; type++) &#123;</span><br><span class="line">		if (sb_info-&gt;ns[type] != info-&gt;ns[type]) //只要有任何一项的值不相同则函数返回0</span><br><span class="line">			found = 0;</span><br><span class="line">	&#125;</span><br><span class="line">	return found;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>sysfs_fill_super函数主要用于创建sysfs文件系统根目录所对应的目录项及其i节点，并且将sysfs_root作为根目录项的私有数据。源代码如下所示：</p>
<figure class="highlight text"><table><tr><td class="code"><pre><span class="line">/* fs/sysfs/mount.c */</span><br><span class="line">static int sysfs_fill_super(struct super_block *sb, void *data, int silent)</span><br><span class="line">&#123;</span><br><span class="line">	struct inode *inode;</span><br><span class="line">	struct dentry *root;</span><br><span class="line"> </span><br><span class="line">	sb-&gt;s_blocksize = PAGE_CACHE_SIZE; //与内存页大小相同</span><br><span class="line">	sb-&gt;s_blocksize_bits = PAGE_CACHE_SHIFT;</span><br><span class="line">	sb-&gt;s_magic = SYSFS_MAGIC;</span><br><span class="line">	sb-&gt;s_op = &amp;sysfs_ops;</span><br><span class="line">	sb-&gt;s_time_gran = 1;</span><br><span class="line"></span><br><span class="line">	//创建并初始化根目录的i节点</span><br><span class="line">	mutex_lock(&amp;sysfs_mutex);</span><br><span class="line">	inode = sysfs_get_inode(sb, &amp;sysfs_root);</span><br><span class="line">	mutex_unlock(&amp;sysfs_mutex);</span><br><span class="line">	if (!inode) &#123;</span><br><span class="line">		pr_debug(&quot;sysfs: could not get root inode\n&quot;);</span><br><span class="line">		return -ENOMEM;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	//创建并初始化sysfs文件系统的根目录项并关联根目录的i节点</span><br><span class="line">	root = d_alloc_root(inode);</span><br><span class="line">	if (!root) &#123;</span><br><span class="line">		pr_debug(&quot;%s: could not get root dentry!\n&quot;,__func__);</span><br><span class="line">		iput(inode);</span><br><span class="line">		return -ENOMEM;</span><br><span class="line">	&#125;</span><br><span class="line">	root-&gt;d_fsdata = &amp;sysfs_root;  //根目录项的d_fsdata成员指向sysfs文件系统的根数据项sysfs_root</span><br><span class="line">	sb-&gt;s_root = root;</span><br><span class="line">	return 0;</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line">struct sysfs_dirent sysfs_root = &#123;</span><br><span class="line">	.s_name		= &quot;&quot;,</span><br><span class="line">	.s_count	= ATOMIC_INIT(1),</span><br><span class="line">	.s_flags	= SYSFS_DIR | (KOBJ_NS_TYPE_NONE &lt;&lt; SYSFS_NS_TYPE_SHIFT),</span><br><span class="line">	.s_mode		= S_IFDIR | S_IRWXU | S_IRUGO | S_IXUGO, //目录文件，访问权限0755</span><br><span class="line">	.s_ino		= 1,   //起始i节点号为1</span><br><span class="line">&#125;;</span><br><span class="line"> </span><br><span class="line">static const struct super_operations sysfs_ops = &#123; //超级块操作函数</span><br><span class="line">    .statfs        = simple_statfs,</span><br><span class="line">    .drop_inode    = generic_delete_inode,</span><br><span class="line">    .evict_inode    = sysfs_evict_inode,</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>3、文件系统最核心的内容是要看其i节点是如何构建的，sysfs文件系统使用sysfs_init_inode函数来创建。源代码如下所示：</p>
<figure class="highlight text"><table><tr><td class="code"><pre><span class="line">/* fs/sysfs/inode.c */</span><br><span class="line">static void sysfs_init_inode(struct sysfs_dirent *sd, struct inode *inode)</span><br><span class="line">&#123;</span><br><span class="line">	struct bin_attribute *bin_attr;</span><br><span class="line"> </span><br><span class="line">	inode-&gt;i_private = sysfs_get(sd); //指向引用计数递增之后的sd</span><br><span class="line">	inode-&gt;i_mapping-&gt;a_ops = &amp;sysfs_aops; //地址空间操作函数</span><br><span class="line">	inode-&gt;i_mapping-&gt;backing_dev_info = &amp;sysfs_backing_dev_info; //后备存储介质的相关信息</span><br><span class="line">	inode-&gt;i_op = &amp;sysfs_inode_operations;</span><br><span class="line"> </span><br><span class="line">	set_default_inode_attr(inode, sd-&gt;s_mode);</span><br><span class="line">	sysfs_refresh_inode(sd, inode);</span><br><span class="line"></span><br><span class="line">	switch (sysfs_type(sd)) &#123; //struct sysfs_dirent类型</span><br><span class="line">	case SYSFS_DIR: //目录</span><br><span class="line">		inode-&gt;i_op = &amp;sysfs_dir_inode_operations;</span><br><span class="line">		inode-&gt;i_fop = &amp;sysfs_dir_operations;</span><br><span class="line">		break;</span><br><span class="line">	case SYSFS_KOBJ_ATTR: //文本文件</span><br><span class="line">		inode-&gt;i_size = PAGE_SIZE; //文件大小固定为一页内存</span><br><span class="line">		inode-&gt;i_fop = &amp;sysfs_file_operations;</span><br><span class="line">		break;</span><br><span class="line">	case SYSFS_KOBJ_BIN_ATTR: //二进制文件</span><br><span class="line">		bin_attr = sd-&gt;s_bin_attr.bin_attr;</span><br><span class="line">		inode-&gt;i_size = bin_attr-&gt;size;</span><br><span class="line">		inode-&gt;i_fop = &amp;bin_fops;</span><br><span class="line">		break;</span><br><span class="line">	case SYSFS_KOBJ_LINK: //符号链接文件</span><br><span class="line">		inode-&gt;i_op = &amp;sysfs_symlink_inode_operations;</span><br><span class="line">		break;</span><br><span class="line">	default:</span><br><span class="line">		BUG();</span><br><span class="line">	&#125;</span><br><span class="line"> </span><br><span class="line">	unlock_new_inode(inode);</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line">static inline void set_default_inode_attr(struct inode * inode, mode_t mode)</span><br><span class="line">&#123;</span><br><span class="line">	inode-&gt;i_mode = mode;</span><br><span class="line">	inode-&gt;i_atime = inode-&gt;i_mtime = inode-&gt;i_ctime = CURRENT_TIME;</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line">static void sysfs_refresh_inode(struct sysfs_dirent *sd, struct inode *inode)</span><br><span class="line">&#123;</span><br><span class="line">	struct sysfs_inode_attrs *iattrs = sd-&gt;s_iattr;</span><br><span class="line"> </span><br><span class="line">	inode-&gt;i_mode = sd-&gt;s_mode;</span><br><span class="line">	if (iattrs) &#123; //sd-&gt;s_iattr为真</span><br><span class="line">		//从iattrs-&gt;ia_iattr拷贝ia_uid、ia_gid、ia_atime、ia_mtime和ia_ctime等成员的值给i节点相应的成员</span><br><span class="line">		set_inode_attr(inode, &amp;iattrs-&gt;ia_iattr); </span><br><span class="line">		security_inode_notifysecctx(inode,</span><br><span class="line">					    iattrs-&gt;ia_secdata,</span><br><span class="line">					    iattrs-&gt;ia_secdata_len); //安全检测模块</span><br><span class="line">	&#125;</span><br><span class="line"> </span><br><span class="line">	if (sysfs_type(sd) == SYSFS_DIR)</span><br><span class="line">		inode-&gt;i_nlink = sysfs_count_nlink(sd); //计算目录的硬链接数目（等于子目录数+2）</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>四种structsysfs_dirent类型对应三种文件类型，其中SYSFS_KOBJ_ATTR和SYSFS_KOBJ_BIN_ATTR都为普通文件。文件系统针对不同的文件类型，i节点操作函数（struct inode_operations）和文件内容操作函数（struct file_operations）都会有不同的实现，并且其中的函数也是根据文件类型来决定是否实现（大部分成员为空指针）。</p>
<p>3.1、目录的i节点操作函数和文件内容操作函数分别为sysfs_dir_inode_operations和sysfs_dir_operations，其中i节点操作函数的create、mkdir和rmdir等成员都为空指针，表示sysfs文件系统的目录或文件无法从用户空间通过系统调用来创建和删除。对于sysfs文件系统中的目录来说，i节点操作函数最重要的是查找函数sysfs_lookup，文件内容操作函数最重要的是遍历目录函数sysfs_readdir。源代码如下所示：</p>
<figure class="highlight text"><table><tr><td class="code"><pre><span class="line">/* fs/sysfs/dir.c */</span><br><span class="line">const struct inode_operations sysfs_dir_inode_operations = &#123;</span><br><span class="line">	.lookup		= sysfs_lookup,</span><br><span class="line">	.permission	= sysfs_permission,</span><br><span class="line">	.setattr	= sysfs_setattr,</span><br><span class="line">	.getattr	= sysfs_getattr,</span><br><span class="line">	.setxattr	= sysfs_setxattr,</span><br><span class="line">&#125;;</span><br><span class="line"> </span><br><span class="line">const struct file_operations sysfs_dir_operations = &#123;</span><br><span class="line">	.read		= generic_read_dir,</span><br><span class="line">	.readdir	= sysfs_readdir,</span><br><span class="line">	.release	= sysfs_dir_release,</span><br><span class="line">	.llseek		= generic_file_llseek,</span><br><span class="line">&#125;;</span><br><span class="line"> </span><br><span class="line">static struct dentry * sysfs_lookup(struct inode *dir, struct dentry *dentry,</span><br><span class="line">				struct nameidata *nd) //dir为父目录的i节点，dentry为被查找对象的目录项(这时为d_alloc函数操作之后的状态)</span><br><span class="line">&#123;</span><br><span class="line">	struct dentry *ret = NULL;</span><br><span class="line">	struct dentry *parent = dentry-&gt;d_parent; //父目录项</span><br><span class="line">	struct sysfs_dirent *parent_sd = parent-&gt;d_fsdata;</span><br><span class="line">	struct sysfs_dirent *sd;</span><br><span class="line">	struct inode *inode;</span><br><span class="line">	enum kobj_ns_type type;</span><br><span class="line">	const void *ns;</span><br><span class="line"> </span><br><span class="line">	mutex_lock(&amp;sysfs_mutex);</span><br><span class="line"></span><br><span class="line">	//获取命名空间</span><br><span class="line">	type = sysfs_ns_type(parent_sd);</span><br><span class="line">	ns = sysfs_info(dir-&gt;i_sb)-&gt;ns[type];</span><br><span class="line"></span><br><span class="line">	//从其parent_sd-&gt;s_dir.children链表中查找相同命名空间并且名字相同的子项</span><br><span class="line">	sd = sysfs_find_dirent(parent_sd, ns, dentry-&gt;d_name.name);</span><br><span class="line">	if (!sd) &#123; //该子项不存在</span><br><span class="line">		ret = ERR_PTR(-ENOENT);</span><br><span class="line">		goto out_unlock;</span><br><span class="line">	&#125;</span><br><span class="line"> </span><br><span class="line">	//从inode_hashtable哈希表中查找该子项对应的i节点，若不存在则构建一个新的i节点实例</span><br><span class="line">	inode = sysfs_get_inode(dir-&gt;i_sb, sd);</span><br><span class="line">	if (!inode) &#123; //构建失败</span><br><span class="line">		ret = ERR_PTR(-ENOMEM);</span><br><span class="line">		goto out_unlock;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	//对于目录来说，只能有一个目录项，并且只有在其为空目录或者为当前文件系统的根目录时才有可能被设置DCACHE_UNHASHED状态</span><br><span class="line">	//当i节点为IS_ROOT和DCACHE_DISCONNECTED时，d_find_alias函数返回真</span><br><span class="line">	ret = d_find_alias(inode);</span><br><span class="line">	if (!ret) &#123;</span><br><span class="line">		d_set_d_op(dentry, &amp;sysfs_dentry_ops); //sysfs_dentry_ops为sysfs文件系统目录项的操作函数</span><br><span class="line">		dentry-&gt;d_fsdata = sysfs_get(sd);</span><br><span class="line">		d_add(dentry, inode);	//调用d_instantiate函数将目录项dentry插入到inode-&gt;i_dentry链表并且dentry-&gt;d_inode指向i节点inode</span><br><span class="line">								//调用d_rehash函数将目录项dentry插入到dentry_hashtable哈希表中</span><br><span class="line">	&#125; else &#123;</span><br><span class="line">		d_move(ret, dentry); //重新使用所返回的目录项ret并与目录项dentry交换d_name等数据</span><br><span class="line">		iput(inode); //销毁i节点</span><br><span class="line">	&#125;</span><br><span class="line"> </span><br><span class="line"> out_unlock:</span><br><span class="line">	mutex_unlock(&amp;sysfs_mutex);</span><br><span class="line">	return ret;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>对于目录来说，只能有一个目录项别名。</p>
<figure class="highlight text"><table><tr><td class="code"><pre><span class="line">/* fs/sysfs/dir.c */</span><br><span class="line">static int sysfs_readdir(struct file * filp, void * dirent, filldir_t filldir)</span><br><span class="line">&#123;</span><br><span class="line">	struct dentry *dentry = filp-&gt;f_path.dentry; //当前目录所对应的目录项</span><br><span class="line">	struct sysfs_dirent * parent_sd = dentry-&gt;d_fsdata;</span><br><span class="line">	struct sysfs_dirent *pos = filp-&gt;private_data;</span><br><span class="line">	enum kobj_ns_type type;</span><br><span class="line">	const void *ns;</span><br><span class="line">	ino_t ino;</span><br><span class="line"></span><br><span class="line">	//获取命名空间</span><br><span class="line">	type = sysfs_ns_type(parent_sd);</span><br><span class="line">	ns = sysfs_info(dentry-&gt;d_sb)-&gt;ns[type];</span><br><span class="line"></span><br><span class="line">	//当前目录</span><br><span class="line">	if (filp-&gt;f_pos == 0) &#123;</span><br><span class="line">		ino = parent_sd-&gt;s_ino;</span><br><span class="line">		if (filldir(dirent, &quot;.&quot;, 1, filp-&gt;f_pos, ino, DT_DIR) == 0)</span><br><span class="line">			filp-&gt;f_pos++;</span><br><span class="line">	&#125;</span><br><span class="line">	//父目录</span><br><span class="line">	if (filp-&gt;f_pos == 1) &#123;</span><br><span class="line">		if (parent_sd-&gt;s_parent)</span><br><span class="line">			ino = parent_sd-&gt;s_parent-&gt;s_ino;</span><br><span class="line">		else</span><br><span class="line">			ino = parent_sd-&gt;s_ino; //文件系统根目录将自身当作父目录</span><br><span class="line">		if (filldir(dirent, &quot;..&quot;, 2, filp-&gt;f_pos, ino, DT_DIR) == 0)</span><br><span class="line">			filp-&gt;f_pos++;</span><br><span class="line">	&#125;</span><br><span class="line">	mutex_lock(&amp;sysfs_mutex);</span><br><span class="line">	for (pos = sysfs_dir_pos(ns, parent_sd, filp-&gt;f_pos, pos); //这时filp-&gt;f_pos等于2，pos为NULL</span><br><span class="line">	     pos;</span><br><span class="line">	     pos = sysfs_dir_next_pos(ns, parent_sd, filp-&gt;f_pos, pos)) &#123; //遍历当前目录</span><br><span class="line">		const char * name;</span><br><span class="line">		unsigned int type;</span><br><span class="line">		int len, ret;</span><br><span class="line"> </span><br><span class="line">		name = pos-&gt;s_name;</span><br><span class="line">		len = strlen(name);</span><br><span class="line">		ino = pos-&gt;s_ino;</span><br><span class="line">		type = dt_type(pos); //文件类型</span><br><span class="line">		filp-&gt;f_pos = ino; //将i节点号作为上一个struct linux_dirent实例中d_off成员的值</span><br><span class="line">		filp-&gt;private_data = sysfs_get(pos);</span><br><span class="line"> </span><br><span class="line">		mutex_unlock(&amp;sysfs_mutex);</span><br><span class="line">		ret = filldir(dirent, name, len, filp-&gt;f_pos, ino, type);</span><br><span class="line">		mutex_lock(&amp;sysfs_mutex);</span><br><span class="line">		if (ret &lt; 0)</span><br><span class="line">			break;</span><br><span class="line">	&#125;</span><br><span class="line">	mutex_unlock(&amp;sysfs_mutex);</span><br><span class="line">	if ((filp-&gt;f_pos &gt; 1) &amp;&amp; !pos) &#123; //遍历完全</span><br><span class="line">		filp-&gt;f_pos = INT_MAX;</span><br><span class="line">		filp-&gt;private_data = NULL;</span><br><span class="line">	&#125;</span><br><span class="line">	return 0;</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line">static struct sysfs_dirent *sysfs_dir_pos(const void *ns,</span><br><span class="line">	struct sysfs_dirent *parent_sd,	ino_t ino, struct sysfs_dirent *pos)</span><br><span class="line">&#123;</span><br><span class="line">	if (pos) &#123;</span><br><span class="line">		int valid = !(pos-&gt;s_flags &amp; SYSFS_FLAG_REMOVED) &amp;&amp; //非SYSFS_FLAG_REMOVED项</span><br><span class="line">			pos-&gt;s_parent == parent_sd &amp;&amp;  //属于目录parent_sd</span><br><span class="line">			ino == pos-&gt;s_ino;</span><br><span class="line">		sysfs_put(pos);</span><br><span class="line">		if (!valid)</span><br><span class="line">			pos = NULL; //重新遍历该目录</span><br><span class="line">	&#125;</span><br><span class="line">	if (!pos &amp;&amp; (ino &gt; 1) &amp;&amp; (ino &lt; INT_MAX)) &#123; //这时pos为空指针，且i节点号的大小在有效范围内</span><br><span class="line">		pos = parent_sd-&gt;s_dir.children;</span><br><span class="line">		while (pos &amp;&amp; (ino &gt; pos-&gt;s_ino)) //过滤掉i节点号比它小的</span><br><span class="line">			pos = pos-&gt;s_sibling;</span><br><span class="line">	&#125;</span><br><span class="line">	while (pos &amp;&amp; pos-&gt;s_ns &amp;&amp; pos-&gt;s_ns != ns) //过滤掉不是相同命名空间的</span><br><span class="line">		pos = pos-&gt;s_sibling;</span><br><span class="line">	return pos;</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line">static struct sysfs_dirent *sysfs_dir_next_pos(const void *ns,</span><br><span class="line">	struct sysfs_dirent *parent_sd,	ino_t ino, struct sysfs_dirent *pos)</span><br><span class="line">&#123;</span><br><span class="line">	pos = sysfs_dir_pos(ns, parent_sd, ino, pos);</span><br><span class="line">	if (pos)</span><br><span class="line">		pos = pos-&gt;s_sibling; //获取下一个项</span><br><span class="line">	while (pos &amp;&amp; pos-&gt;s_ns &amp;&amp; pos-&gt;s_ns != ns)</span><br><span class="line">		pos = pos-&gt;s_sibling;</span><br><span class="line">	return pos;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>当在用户空间通过ls等命令查看sysfs文件系统的目录时，会通过系统调用getdents调用vfs_readdir，然后再调用sysfs_readdir函数。其中参数filp表示该目录打开之后的文件指针，dirent实际为struct getdents_callback类型的数据，filldir为回调函数指针，指向同名的filldir函数。源代码如下所示：</p>
<figure class="highlight text"><table><tr><td class="code"><pre><span class="line">/* include/linux/kernel.h */</span><br><span class="line">#define __ALIGN_KERNEL(x, a)		__ALIGN_KERNEL_MASK(x, (typeof(x))(a) - 1)</span><br><span class="line">#define __ALIGN_KERNEL_MASK(x, mask)	(((x) + (mask)) &amp; ~(mask))</span><br><span class="line">#define ALIGN(x, a)		__ALIGN_KERNEL((x), (a))</span><br><span class="line"> </span><br><span class="line">/* include/linux/compiler-gcc4.h */</span><br><span class="line">#define __compiler_offsetof(a,b) __builtin_offsetof(a,b)  //GCC编译器内置函数，计算成员偏移量</span><br><span class="line"> </span><br><span class="line">/* include/linux/stddef.h */</span><br><span class="line">#undef offsetof</span><br><span class="line">#ifdef __compiler_offsetof</span><br><span class="line">#define offsetof(TYPE,MEMBER) __compiler_offsetof(TYPE,MEMBER)</span><br><span class="line">#else</span><br><span class="line">#define offsetof(TYPE, MEMBER) ((size_t) &amp;((TYPE *)0)-&gt;MEMBER)</span><br><span class="line">#endif</span><br><span class="line"> </span><br><span class="line">/* fs/readdir.c */</span><br><span class="line">struct linux_dirent &#123;</span><br><span class="line">	unsigned long	d_ino; //i节点号</span><br><span class="line">	unsigned long	d_off; //偏移量，无实际意义，在sysfs文件系统的实现中，它的值为上一个所遍历的文件或目录的i节点号（最后一个为INT_MAX）</span><br><span class="line">	unsigned short	d_reclen; //整个struct linux_dirent实例的长度（经过对齐修正）</span><br><span class="line">	char		d_name[1]; //文件名，大小由实际文件名的长度决定（空字符结尾）</span><br><span class="line">&#125;;</span><br><span class="line"> </span><br><span class="line">struct getdents_callback &#123;</span><br><span class="line">	struct linux_dirent __user * current_dir;	//初始化为系统调用传入的内存地址</span><br><span class="line">	struct linux_dirent __user * previous;		//指向上一个struct linux_dirent实例</span><br><span class="line">	int count;	//初始化为系统调用传入的内存的总大小（字节数）</span><br><span class="line">	int error;	//保存错误码</span><br><span class="line">&#125;;</span><br><span class="line"> </span><br><span class="line">static int filldir(void * __buf, const char * name, int namlen, loff_t offset,</span><br><span class="line">		   u64 ino, unsigned int d_type)</span><br><span class="line">&#123;</span><br><span class="line">	struct linux_dirent __user * dirent;</span><br><span class="line">	struct getdents_callback * buf = (struct getdents_callback *) __buf;</span><br><span class="line">	unsigned long d_ino;</span><br><span class="line">	//功能等效于(len / sizeof(long) + (len % sizeof(long) ? 1 : 0)) * sizeof(long)，其中len为ALIGN的第一个参数的值</span><br><span class="line">	int reclen = ALIGN(offsetof(struct linux_dirent, d_name) + namlen + 2,	//其中加2个字节的意义是：一个字节用来存储字符串的结束符，</span><br><span class="line">		sizeof(long)); 														//另一个字节用来存储文件类型。</span><br><span class="line"> </span><br><span class="line">	buf-&gt;error = -EINVAL;</span><br><span class="line">	if (reclen &gt; buf-&gt;count) //剩余的内存不够</span><br><span class="line">		return -EINVAL;</span><br><span class="line">	d_ino = ino;</span><br><span class="line">	if (sizeof(d_ino) &lt; sizeof(ino) &amp;&amp; d_ino != ino) &#123; //d_ino的数据类型较小且导致数据溢出</span><br><span class="line">		buf-&gt;error = -EOVERFLOW;</span><br><span class="line">		return -EOVERFLOW;</span><br><span class="line">	&#125;</span><br><span class="line">	dirent = buf-&gt;previous;</span><br><span class="line">	if (dirent) &#123;</span><br><span class="line">		if (__put_user(offset, &amp;dirent-&gt;d_off)) //以当前的offset值填充上一个struct linux_dirent实例的d_off成员</span><br><span class="line">			goto efault;</span><br><span class="line">	&#125;</span><br><span class="line">	dirent = buf-&gt;current_dir;</span><br><span class="line">	if (__put_user(d_ino, &amp;dirent-&gt;d_ino)) //i节点号</span><br><span class="line">		goto efault;</span><br><span class="line">	if (__put_user(reclen, &amp;dirent-&gt;d_reclen)) //当前struct linux_dirent实例的总大小（字节数）</span><br><span class="line">		goto efault;</span><br><span class="line">	if (copy_to_user(dirent-&gt;d_name, name, namlen)) //拷贝文件名</span><br><span class="line">		goto efault;</span><br><span class="line">	if (__put_user(0, dirent-&gt;d_name + namlen)) //在文件名后加字符串结束符&#x27;\0&#x27;</span><br><span class="line">		goto efault;</span><br><span class="line">	if (__put_user(d_type, (char __user *) dirent + reclen - 1)) //最后一个字节用来保存文件类型信息</span><br><span class="line">		goto efault;</span><br><span class="line">	buf-&gt;previous = dirent;</span><br><span class="line">	dirent = (void __user *)dirent + reclen;</span><br><span class="line">	buf-&gt;current_dir = dirent; //指向下一个尚未使用的struct linux_dirent实例</span><br><span class="line">	buf-&gt;count -= reclen; //计算剩余内存数量</span><br><span class="line">	return 0;</span><br><span class="line">efault:</span><br><span class="line">	buf-&gt;error = -EFAULT;</span><br><span class="line">	return -EFAULT;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>3.2、sysfs文件系统针对文本文件和二进制文件实现了不同的文件内容操作函数，而i节点操作函数则相同。源代码如下所示：</p>
<figure class="highlight text"><table><tr><td class="code"><pre><span class="line">/* fs/sysfs/inode.c */</span><br><span class="line">static const struct inode_operations sysfs_inode_operations =&#123;</span><br><span class="line">	.permission	= sysfs_permission,</span><br><span class="line">	.setattr	= sysfs_setattr,</span><br><span class="line">	.getattr	= sysfs_getattr,</span><br><span class="line">	.setxattr	= sysfs_setxattr,</span><br><span class="line">&#125;;</span><br><span class="line"> </span><br><span class="line">/* fs/sysfs/file.c */</span><br><span class="line">const struct file_operations sysfs_file_operations = &#123; //文本文件</span><br><span class="line">	.read		= sysfs_read_file,</span><br><span class="line">	.write		= sysfs_write_file,</span><br><span class="line">	.llseek		= generic_file_llseek,</span><br><span class="line">	.open		= sysfs_open_file,</span><br><span class="line">	.release	= sysfs_release,</span><br><span class="line">	.poll		= sysfs_poll,</span><br><span class="line">&#125;;</span><br><span class="line"> </span><br><span class="line">/* fs/sysfs/bin.c */</span><br><span class="line">const struct file_operations bin_fops = &#123; //二进制文件</span><br><span class="line">	.read		= read,</span><br><span class="line">	.write		= write,</span><br><span class="line">	.mmap		= mmap,</span><br><span class="line">	.llseek		= generic_file_llseek,</span><br><span class="line">	.open		= open,</span><br><span class="line">	.release	= release,</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>针对普通文件，最重要的是观察它的文件内容操作函数的实现，如open、read和write等函数。下面则以文本文件为例，看看sysfs文件系统是如何读写文件的。源代码如下所示：</p>
<figure class="highlight text"><table><tr><td class="code"><pre><span class="line">/* include/linux/limits.h */</span><br><span class="line">#define PATH_MAX        4096</span><br><span class="line"> </span><br><span class="line">/* fs/sysfs/file.c */</span><br><span class="line">static char last_sysfs_file[PATH_MAX];</span><br><span class="line"> </span><br><span class="line">static int sysfs_open_file(struct inode *inode, struct file *file)</span><br><span class="line">&#123;</span><br><span class="line">	struct sysfs_dirent *attr_sd = file-&gt;f_path.dentry-&gt;d_fsdata; //sysfs数据项，表示当前被打开的文件</span><br><span class="line">	struct kobject *kobj = attr_sd-&gt;s_parent-&gt;s_dir.kobj; //所属目录所对应的内核对象</span><br><span class="line">	struct sysfs_buffer *buffer;</span><br><span class="line">	const struct sysfs_ops *ops;</span><br><span class="line">	int error = -EACCES;</span><br><span class="line">	char *p;</span><br><span class="line"></span><br><span class="line">	//获得该文件的全路径并依次保存在last_sysfs_file数组的尾部</span><br><span class="line">	p = d_path(&amp;file-&gt;f_path, last_sysfs_file, sizeof(last_sysfs_file));</span><br><span class="line">	if (!IS_ERR(p))</span><br><span class="line">		memmove(last_sysfs_file, p, strlen(p) + 1); //将路径移动到数组的开头</span><br><span class="line">	</span><br><span class="line">	//获取活动引用计数</span><br><span class="line">	if (!sysfs_get_active(attr_sd))</span><br><span class="line">		return -ENODEV;</span><br><span class="line">	</span><br><span class="line">	if (kobj-&gt;ktype &amp;&amp; kobj-&gt;ktype-&gt;sysfs_ops) //内核对象针对所属属性的读写函数必须存在</span><br><span class="line">		ops = kobj-&gt;ktype-&gt;sysfs_ops;</span><br><span class="line">	else &#123;</span><br><span class="line">		WARN(1, KERN_ERR &quot;missing sysfs attribute operations for &quot;</span><br><span class="line">		       &quot;kobject: %s\n&quot;, kobject_name(kobj));</span><br><span class="line">		goto err_out;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	if (file-&gt;f_mode &amp; FMODE_WRITE) &#123; //写文件</span><br><span class="line">		if (!(inode-&gt;i_mode &amp; S_IWUGO) || !ops-&gt;store) //需S_IWUGO访问权限且store函数必须定义</span><br><span class="line">			goto err_out;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	if (file-&gt;f_mode &amp; FMODE_READ) &#123; //读文件</span><br><span class="line">		if (!(inode-&gt;i_mode &amp; S_IRUGO) || !ops-&gt;show) //需S_IRUGO访问权限且show函数必须定义</span><br><span class="line">			goto err_out;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	//每次打开的文本文件都对应一个struct sysfs_buffer实例</span><br><span class="line">	error = -ENOMEM;</span><br><span class="line">	buffer = kzalloc(sizeof(struct sysfs_buffer), GFP_KERNEL);</span><br><span class="line">	if (!buffer)</span><br><span class="line">		goto err_out;</span><br><span class="line"> </span><br><span class="line">	mutex_init(&amp;buffer-&gt;mutex);</span><br><span class="line">	buffer-&gt;needs_read_fill = 1;</span><br><span class="line">	buffer-&gt;ops = ops;</span><br><span class="line">	file-&gt;private_data = buffer; //保存在文件指针的私有数据中</span><br><span class="line"> </span><br><span class="line">	//分配struct sysfs_open_dirent结构体实例</span><br><span class="line">	error = sysfs_get_open_dirent(attr_sd, buffer);</span><br><span class="line">	if (error)</span><br><span class="line">		goto err_free;</span><br><span class="line">	</span><br><span class="line">	//打开成功，释放活动引用计数</span><br><span class="line">	sysfs_put_active(attr_sd);</span><br><span class="line">	return 0;</span><br><span class="line"> </span><br><span class="line"> err_free:</span><br><span class="line">	kfree(buffer);</span><br><span class="line"> err_out:</span><br><span class="line">	sysfs_put_active(attr_sd);</span><br><span class="line">	return error;</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line">static DEFINE_SPINLOCK(sysfs_open_dirent_lock);</span><br><span class="line"> </span><br><span class="line">static int sysfs_get_open_dirent(struct sysfs_dirent *sd,</span><br><span class="line">				 struct sysfs_buffer *buffer)</span><br><span class="line">&#123;</span><br><span class="line">	struct sysfs_open_dirent *od, *new_od = NULL;</span><br><span class="line"> </span><br><span class="line"> retry:</span><br><span class="line">	spin_lock_irq(&amp;sysfs_open_dirent_lock);</span><br><span class="line"> </span><br><span class="line">	if (!sd-&gt;s_attr.open &amp;&amp; new_od) &#123; //每个文本文件的struct sysfs_dirent都有一个open成员</span><br><span class="line">		sd-&gt;s_attr.open = new_od; //指向新分配并初始化的struct sysfs_open_dirent实例</span><br><span class="line">		new_od = NULL;</span><br><span class="line">	&#125;</span><br><span class="line"> </span><br><span class="line">	od = sd-&gt;s_attr.open;</span><br><span class="line">	if (od) &#123;</span><br><span class="line">		atomic_inc(&amp;od-&gt;refcnt); //递增引用计数</span><br><span class="line">		//将buffer作为链表元素插入到od-&gt;buffers链表（该链表中元素的数量就是该文本文件正被打开的次数）</span><br><span class="line">		list_add_tail(&amp;buffer-&gt;list, &amp;od-&gt;buffers); </span><br><span class="line">	&#125;</span><br><span class="line"> </span><br><span class="line">	spin_unlock_irq(&amp;sysfs_open_dirent_lock);</span><br><span class="line"> </span><br><span class="line">	if (od) &#123;</span><br><span class="line">		kfree(new_od);</span><br><span class="line">		return 0;</span><br><span class="line">	&#125;</span><br><span class="line"> </span><br><span class="line">	//为struct sysfs_open_dirent结构体实例分配内存</span><br><span class="line">	new_od = kmalloc(sizeof(*new_od), GFP_KERNEL);</span><br><span class="line">	if (!new_od)</span><br><span class="line">		return -ENOMEM;</span><br><span class="line">	</span><br><span class="line">	//初始化成员</span><br><span class="line">	atomic_set(&amp;new_od-&gt;refcnt, 0);</span><br><span class="line">	atomic_set(&amp;new_od-&gt;event, 1);</span><br><span class="line">	init_waitqueue_head(&amp;new_od-&gt;poll);</span><br><span class="line">	INIT_LIST_HEAD(&amp;new_od-&gt;buffers);</span><br><span class="line">	goto retry;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>在sysfs文件系统中，文本文件使用struct sysfs_elem_attr来表示，而该结构体有一个struct sysfs_open_dirent类型的open成员，主要用于管理每次打开并读&#x2F;写该文件时所使用的内存（struct sysfs_buffer）。源代码如下所示：</p>
<figure class="highlight text"><table><tr><td class="code"><pre><span class="line">/* fs/sysfs/file.c */</span><br><span class="line">struct sysfs_open_dirent &#123;</span><br><span class="line">	atomic_t		refcnt; //打开次数</span><br><span class="line">	atomic_t		event;</span><br><span class="line">	wait_queue_head_t	poll; //等待队列</span><br><span class="line">	struct list_head	buffers; //sysfs_buffer.list的链表</span><br><span class="line">&#125;;</span><br><span class="line"> </span><br><span class="line">struct sysfs_buffer &#123;</span><br><span class="line">	size_t			count;	//数据大小（字节数）</span><br><span class="line">	loff_t			pos;	//偏移量</span><br><span class="line">	char			* page;	//指向一页内存，用于存储数据</span><br><span class="line">	const struct sysfs_ops	* ops;	//操作函数</span><br><span class="line">	struct mutex		mutex;		//互斥锁</span><br><span class="line">	int			needs_read_fill;	//是否已填充数据</span><br><span class="line">	int			event;</span><br><span class="line">	struct list_head	list;	//插入所属的struct sysfs_open_dirent的buffers链表</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>sysfs_read_file为sysfs文件系统文本文件的读函数，源代码如下所示：</p>
<figure class="highlight text"><table><tr><td class="code"><pre><span class="line">/* fs/sysfs/file.c */</span><br><span class="line">static ssize_t</span><br><span class="line">sysfs_read_file(struct file *file, char __user *buf, size_t count, loff_t *ppos)</span><br><span class="line">&#123;</span><br><span class="line">	struct sysfs_buffer * buffer = file-&gt;private_data;  //调用sysfs_open_file时所生成的</span><br><span class="line">	ssize_t retval = 0;</span><br><span class="line"> </span><br><span class="line">	mutex_lock(&amp;buffer-&gt;mutex);</span><br><span class="line">	if (buffer-&gt;needs_read_fill || *ppos == 0) &#123; //尚未获取数据或者文件偏移量为零</span><br><span class="line">		retval = fill_read_buffer(file-&gt;f_path.dentry,buffer); //一次读取</span><br><span class="line">		if (retval) //获取数据失败（返回零表示成功）</span><br><span class="line">			goto out;</span><br><span class="line">	&#125;</span><br><span class="line">	pr_debug(&quot;%s: count = %zd, ppos = %lld, buf = %s\n&quot;,</span><br><span class="line">		 __func__, count, *ppos, buffer-&gt;page);</span><br><span class="line">		 </span><br><span class="line">	//将count个字节的数据拷贝到用户空间内存buf，buffer-&gt;count表示可拷贝数据的最大字节数（可能须要多次拷贝才能读取完整个内存）</span><br><span class="line">	retval = simple_read_from_buffer(buf, count, ppos, buffer-&gt;page,</span><br><span class="line">					 buffer-&gt;count); </span><br><span class="line">out:</span><br><span class="line">	mutex_unlock(&amp;buffer-&gt;mutex);</span><br><span class="line">	return retval;</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line">static int fill_read_buffer(struct dentry * dentry, struct sysfs_buffer * buffer)</span><br><span class="line">&#123;</span><br><span class="line">	struct sysfs_dirent *attr_sd = dentry-&gt;d_fsdata; //sysfs数据项</span><br><span class="line">	struct kobject *kobj = attr_sd-&gt;s_parent-&gt;s_dir.kobj; //所属内核对象</span><br><span class="line">	const struct sysfs_ops * ops = buffer-&gt;ops;</span><br><span class="line">	int ret = 0;</span><br><span class="line">	ssize_t count;</span><br><span class="line"> </span><br><span class="line">	if (!buffer-&gt;page) //分配存储数据的内存</span><br><span class="line">		buffer-&gt;page = (char *) get_zeroed_page(GFP_KERNEL);</span><br><span class="line">	if (!buffer-&gt;page) //内存分配失败</span><br><span class="line">		return -ENOMEM;</span><br><span class="line">	</span><br><span class="line">	if (!sysfs_get_active(attr_sd)) //获取活动引用计数</span><br><span class="line">		return -ENODEV;</span><br><span class="line"> </span><br><span class="line">	buffer-&gt;event = atomic_read(&amp;attr_sd-&gt;s_attr.open-&gt;event);</span><br><span class="line">	count = ops-&gt;show(kobj, attr_sd-&gt;s_attr.attr, buffer-&gt;page);  //从该内核对象相应的属性中获取数据并保存到刚才所分配的内存中</span><br><span class="line"> </span><br><span class="line">	sysfs_put_active(attr_sd); //释放活动引用计数</span><br><span class="line"></span><br><span class="line">	if (count &gt;= (ssize_t)PAGE_SIZE) &#123; //至多能读取PAGE_SIZE - 1个字节</span><br><span class="line">		print_symbol(&quot;fill_read_buffer: %s returned bad count\n&quot;,</span><br><span class="line">			(unsigned long)ops-&gt;show);</span><br><span class="line">		/* Try to struggle along */</span><br><span class="line">		count = PAGE_SIZE - 1;</span><br><span class="line">	&#125;</span><br><span class="line">	if (count &gt;= 0) &#123;</span><br><span class="line">		buffer-&gt;needs_read_fill = 0; //表示填充过数据</span><br><span class="line">		buffer-&gt;count = count;</span><br><span class="line">	&#125; else &#123;</span><br><span class="line">		ret = count; //获取失败</span><br><span class="line">	&#125;</span><br><span class="line">	return ret;</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line">/* fs/libfs.c */</span><br><span class="line">ssize_t simple_read_from_buffer(void __user *to, size_t count, loff_t *ppos,</span><br><span class="line">				const void *from, size_t available)</span><br><span class="line">&#123;</span><br><span class="line">	loff_t pos = *ppos;</span><br><span class="line">	size_t ret;</span><br><span class="line"> </span><br><span class="line">	if (pos &lt; 0) //文件偏移量不能为负数</span><br><span class="line">		return -EINVAL;</span><br><span class="line">	if (pos &gt;= available || !count) //已无数据可读或者是想读取零个字节</span><br><span class="line">		return 0;</span><br><span class="line">	if (count &gt; available - pos)  //只剩available - pos个字节</span><br><span class="line">		count = available - pos;</span><br><span class="line">	ret = copy_to_user(to, from + pos, count); //拷贝数据</span><br><span class="line">	if (ret == count) //返回值为没有拷贝成功的字节数</span><br><span class="line">		return -EFAULT;</span><br><span class="line">	count -= ret; //获得count个字节的数据</span><br><span class="line">	*ppos = pos + count; //更新文件偏移量</span><br><span class="line">	return count;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>sysfs_write_file为sysfs文件系统的写函数，源代码如下所示：</p>
<figure class="highlight text"><table><tr><td class="code"><pre><span class="line">/* fs/sysfs/file.c */</span><br><span class="line">static ssize_t</span><br><span class="line">sysfs_write_file(struct file *file, const char __user *buf, size_t count, loff_t *ppos) //ppos为文件偏移量</span><br><span class="line">&#123;</span><br><span class="line">	struct sysfs_buffer * buffer = file-&gt;private_data; //调用sysfs_open_file时所生成的</span><br><span class="line">	ssize_t len;</span><br><span class="line"> </span><br><span class="line">	mutex_lock(&amp;buffer-&gt;mutex);</span><br><span class="line">	len = fill_write_buffer(buffer, buf, count); //一次写入，从用户空间内存buf中拷贝count个字节到内核空间</span><br><span class="line">	if (len &gt; 0) //成功拷贝len个字节</span><br><span class="line">		len = flush_write_buffer(file-&gt;f_path.dentry, buffer, len); //根据获得的数据更新该内核对象相应的属性</span><br><span class="line">	if (len &gt; 0)</span><br><span class="line">		*ppos += len; //更改文件偏移量，对buffer-&gt;page中的数据无意义，后面写入的数据会覆盖前面写入的数据</span><br><span class="line">	mutex_unlock(&amp;buffer-&gt;mutex);</span><br><span class="line">	return len;</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line">static int </span><br><span class="line">fill_write_buffer(struct sysfs_buffer * buffer, const char __user * buf, size_t count)</span><br><span class="line">&#123;</span><br><span class="line">	int error;</span><br><span class="line"> </span><br><span class="line">	if (!buffer-&gt;page) //分配存储数据的内存</span><br><span class="line">		buffer-&gt;page = (char *)get_zeroed_page(GFP_KERNEL);</span><br><span class="line">	if (!buffer-&gt;page) //内存分配失败</span><br><span class="line">		return -ENOMEM;</span><br><span class="line"> </span><br><span class="line">	if (count &gt;= PAGE_SIZE) //写入的数据最多只能为PAGE_SIZE - 1个字节</span><br><span class="line">		count = PAGE_SIZE - 1;</span><br><span class="line">	error = copy_from_user(buffer-&gt;page,buf,count); //拷贝数据，成功函数返回零</span><br><span class="line">	buffer-&gt;needs_read_fill = 1;</span><br><span class="line">	buffer-&gt;page[count] = 0; //字符串结束符&#x27;\0&#x27;</span><br><span class="line">	return error ? -EFAULT : count;</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line">static int</span><br><span class="line">flush_write_buffer(struct dentry * dentry, struct sysfs_buffer * buffer, size_t count)</span><br><span class="line">&#123;</span><br><span class="line">	struct sysfs_dirent *attr_sd = dentry-&gt;d_fsdata; //sysfs数据项，这里表示一个文本文件</span><br><span class="line">	struct kobject *kobj = attr_sd-&gt;s_parent-&gt;s_dir.kobj; //所属内核对象</span><br><span class="line">	const struct sysfs_ops * ops = buffer-&gt;ops;</span><br><span class="line">	int rc;</span><br><span class="line"> </span><br><span class="line">	if (!sysfs_get_active(attr_sd)) //获取活动引用计数</span><br><span class="line">		return -ENODEV;</span><br><span class="line"> </span><br><span class="line">	rc = ops-&gt;store(kobj, attr_sd-&gt;s_attr.attr, buffer-&gt;page, count); //调用store函数</span><br><span class="line"> </span><br><span class="line">	sysfs_put_active(attr_sd); //释放活动引用计数</span><br><span class="line"> </span><br><span class="line">	return rc;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>关闭文件时，打开、读&#x2F;写文件时所分配的内存都会释放，并不会一直存在于内核中。</p>
<p>3.3、对于符号链接文件来说，它没有文件内容操作函数，只有i节点操作函数，其中最重要的函数为符号链接文件的解析函数sysfs_follow_link，源代码如下所示：</p>
<figure class="highlight text"><table><tr><td class="code"><pre><span class="line">/* fs/sysfs/symlink.c */</span><br><span class="line">const struct inode_operations sysfs_symlink_inode_operations = &#123;</span><br><span class="line">	.setxattr	= sysfs_setxattr,</span><br><span class="line">	.readlink	= generic_readlink,</span><br><span class="line">	.follow_link	= sysfs_follow_link,</span><br><span class="line">	.put_link	= sysfs_put_link,</span><br><span class="line">	.setattr	= sysfs_setattr,</span><br><span class="line">	.getattr	= sysfs_getattr,</span><br><span class="line">	.permission	= sysfs_permission,</span><br><span class="line">&#125;;</span><br><span class="line"> </span><br><span class="line">static void *sysfs_follow_link(struct dentry *dentry, struct nameidata *nd)</span><br><span class="line">&#123;</span><br><span class="line">	int error = -ENOMEM;</span><br><span class="line">	unsigned long page = get_zeroed_page(GFP_KERNEL); //分配内存</span><br><span class="line">	if (page) &#123;</span><br><span class="line">		error = sysfs_getlink(dentry, (char *) page); </span><br><span class="line">		if (error &lt; 0)  //成功时sysfs_getlink返回零</span><br><span class="line">			free_page((unsigned long)page);</span><br><span class="line">	&#125;</span><br><span class="line">	nd_set_link(nd, error ? ERR_PTR(error) : (char *)page); //保存获得的相对路径或错误码</span><br><span class="line">	return NULL;</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line">static int sysfs_getlink(struct dentry *dentry, char * path)</span><br><span class="line">&#123;</span><br><span class="line">	struct sysfs_dirent *sd = dentry-&gt;d_fsdata; //sysfs数据项</span><br><span class="line">	struct sysfs_dirent *parent_sd = sd-&gt;s_parent; //父sysfs数据项</span><br><span class="line">	struct sysfs_dirent *target_sd = sd-&gt;s_symlink.target_sd; //所链接到的sysfs数据项</span><br><span class="line">	int error;</span><br><span class="line"> </span><br><span class="line">	mutex_lock(&amp;sysfs_mutex);</span><br><span class="line">	error = sysfs_get_target_path(parent_sd, target_sd, path); //获取从链接文件到链接对象的相对路径</span><br><span class="line">	mutex_unlock(&amp;sysfs_mutex);</span><br><span class="line"> </span><br><span class="line">	return error;</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line">//sysfs链接文件是两个内核对象之间的链接，也就是目录之间的链接</span><br><span class="line">static int sysfs_get_target_path(struct sysfs_dirent *parent_sd,</span><br><span class="line">				 struct sysfs_dirent *target_sd, char *path)</span><br><span class="line">&#123;</span><br><span class="line">	struct sysfs_dirent *base, *sd;</span><br><span class="line">	char *s = path;</span><br><span class="line">	int len = 0;</span><br><span class="line"></span><br><span class="line">	base = parent_sd;</span><br><span class="line">	while (base-&gt;s_parent) &#123; //sysfs的根数据项为sysfs_root，该数据项的s_parent成员为空指针</span><br><span class="line">		sd = target_sd-&gt;s_parent;</span><br><span class="line">		while (sd-&gt;s_parent &amp;&amp; base != sd)  //如果base一直不等于sd，则循环直到根数据项才会停止</span><br><span class="line">			sd = sd-&gt;s_parent;</span><br><span class="line"> </span><br><span class="line">		if (base == sd) //两者相等，这时链接文件和被链接对象的直接或间接的父目录相同</span><br><span class="line">			break;</span><br><span class="line"> </span><br><span class="line">		strcpy(s, &quot;../&quot;);  //拷贝字符串“../”，意味着两者不是同在这一目录下</span><br><span class="line">		s += 3;</span><br><span class="line">		base = base-&gt;s_parent; //接下来将比较链接文件的上一级目录的数据项</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	//这时，base已指向链接文件和被链接对象首个共有的直接或间接的父目录的数据项</span><br><span class="line"></span><br><span class="line">	//计算整个路径的长度</span><br><span class="line">	sd = target_sd;</span><br><span class="line">	while (sd-&gt;s_parent &amp;&amp; sd != base) &#123;</span><br><span class="line">		len += strlen(sd-&gt;s_name) + 1; //其中的加1表示目录项分隔符“/”所占的字节</span><br><span class="line">		sd = sd-&gt;s_parent;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	if (len &lt; 2) //名称为空字符串</span><br><span class="line">		return -EINVAL;</span><br><span class="line">	len--; //减去一个多余的目录项分隔符所占的字节</span><br><span class="line">	if ((s - path) + len &gt; PATH_MAX) //总长度超过path数组的大小</span><br><span class="line">		return -ENAMETOOLONG;</span><br><span class="line"> </span><br><span class="line">	//从被链接对象开始以倒序的方式拷贝目录项名称，直到base数据项（但不包括它的）</span><br><span class="line">	sd = target_sd;</span><br><span class="line">	while (sd-&gt;s_parent &amp;&amp; sd != base) &#123;</span><br><span class="line">		int slen = strlen(sd-&gt;s_name);</span><br><span class="line"> </span><br><span class="line">		len -= slen;</span><br><span class="line">		strncpy(s + len, sd-&gt;s_name, slen); //拷贝名称</span><br><span class="line">		if (len) //等于0时表示最后一个名称的前面不需要再加分隔符</span><br><span class="line">			s[--len] = &#x27;/&#x27;; //在该名称前加目录项分隔符“/”</span><br><span class="line"> </span><br><span class="line">		sd = sd-&gt;s_parent; //接着处理上一级目录</span><br><span class="line">	&#125;</span><br><span class="line"> </span><br><span class="line">	return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>读取符号链接文件内容的函数generic_readlink主要就是靠解析函数来实现的，源代码如下所示：</p>
<figure class="highlight text"><table><tr><td class="code"><pre><span class="line">/* fs/namei.c */</span><br><span class="line">int generic_readlink(struct dentry *dentry, char __user *buffer, int buflen)</span><br><span class="line">&#123;</span><br><span class="line">	struct nameidata nd;</span><br><span class="line">	void *cookie;</span><br><span class="line">	int res;</span><br><span class="line"> </span><br><span class="line">	nd.depth = 0;</span><br><span class="line">	cookie = dentry-&gt;d_inode-&gt;i_op-&gt;follow_link(dentry, &amp;nd);</span><br><span class="line">	if (IS_ERR(cookie)) //返回错误码</span><br><span class="line">		return PTR_ERR(cookie);</span><br><span class="line"> </span><br><span class="line">	res = vfs_readlink(dentry, buffer, buflen, nd_get_link(&amp;nd)); //通过nd_get_link获取follow_link保存的路径或错误码</span><br><span class="line">	if (dentry-&gt;d_inode-&gt;i_op-&gt;put_link)</span><br><span class="line">		dentry-&gt;d_inode-&gt;i_op-&gt;put_link(dentry, &amp;nd, cookie); //这里put_link指向sysfs_put_link函数</span><br><span class="line">	return res;</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line">int vfs_readlink(struct dentry *dentry, char __user *buffer, int buflen, const char *link)</span><br><span class="line">&#123;</span><br><span class="line">	int len;</span><br><span class="line"> </span><br><span class="line">	len = PTR_ERR(link);</span><br><span class="line">	if (IS_ERR(link)) //这里的link也有可能是错误码</span><br><span class="line">		goto out;</span><br><span class="line"> </span><br><span class="line">	len = strlen(link);</span><br><span class="line">	if (len &gt; (unsigned) buflen) //路径长度比传入的内存大</span><br><span class="line">		len = buflen;</span><br><span class="line">	if (copy_to_user(buffer, link, len)) //拷贝到用户空间内存（但不包括字符串结束符）</span><br><span class="line">		len = -EFAULT;</span><br><span class="line">out:</span><br><span class="line">	return len;</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line">/* fs/sysfs/symlink.c */</span><br><span class="line">static void sysfs_put_link(struct dentry *dentry, struct nameidata *nd, void *cookie)</span><br><span class="line">&#123;</span><br><span class="line">	char *page = nd_get_link(nd);</span><br><span class="line">	if (!IS_ERR(page)) //非错误码</span><br><span class="line">		free_page((unsigned long)page); //释放内存</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>其中，sysfs_put_link函数执行与sysfs_follow_link函数相反的操作，这里只是释放由sysfs_follow_link函数分配的内存。</p>
<p>4、对于sysfs文件系统来说，在用户空间只能读写文件的内容，而无法创建或删除文件或目录，只能在内核中通过sysfs_create_dir、sysfs_create_file等等函数来实现。</p>
<p>4.1、内核对象（struct kobject）对应于sysfs文件系统中的目录，可使用sysfs_create_dir函数来创建，源代码如下所示：</p>
<figure class="highlight text"><table><tr><td class="code"><pre><span class="line">/* fs/sysfs/dir.c */</span><br><span class="line">int sysfs_create_dir(struct kobject * kobj)</span><br><span class="line">&#123;</span><br><span class="line">	enum kobj_ns_type type;</span><br><span class="line">	struct sysfs_dirent *parent_sd, *sd;</span><br><span class="line">	const void *ns = NULL;</span><br><span class="line">	int error = 0;</span><br><span class="line"> </span><br><span class="line">	BUG_ON(!kobj);</span><br><span class="line"> </span><br><span class="line">	if (kobj-&gt;parent) //父内核对象为空时，则在sysfs文件系统的根目录下创建目录</span><br><span class="line">		parent_sd = kobj-&gt;parent-&gt;sd;</span><br><span class="line">	else</span><br><span class="line">		parent_sd = &amp;sysfs_root;</span><br><span class="line">	</span><br><span class="line">	//获取命名空间及其类型</span><br><span class="line">	if (sysfs_ns_type(parent_sd))</span><br><span class="line">		ns = kobj-&gt;ktype-&gt;namespace(kobj);</span><br><span class="line">	type = sysfs_read_ns_type(kobj);</span><br><span class="line"> </span><br><span class="line">	error = create_dir(kobj, parent_sd, type, ns, kobject_name(kobj), &amp;sd);</span><br><span class="line">	if (!error) //成功则返回零</span><br><span class="line">		kobj-&gt;sd = sd;  //保存相应的sysfs数据项</span><br><span class="line">	return error;</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line">/* include/linux/kobject.h */</span><br><span class="line">static inline const char *kobject_name(const struct kobject *kobj)</span><br><span class="line">&#123;</span><br><span class="line">	return kobj-&gt;name;</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line">/* fs/sysfs/dir.c */</span><br><span class="line">static int create_dir(struct kobject *kobj, struct sysfs_dirent *parent_sd,</span><br><span class="line">	enum kobj_ns_type type, const void *ns, const char *name,</span><br><span class="line">	struct sysfs_dirent **p_sd)</span><br><span class="line">&#123;</span><br><span class="line">	umode_t mode = S_IFDIR| S_IRWXU | S_IRUGO | S_IXUGO; //文件类型为目录，访问权限为0755</span><br><span class="line">	struct sysfs_addrm_cxt acxt;</span><br><span class="line">	struct sysfs_dirent *sd;</span><br><span class="line">	int rc;</span><br><span class="line"> </span><br><span class="line">	//分配sysfs数据项并初始化</span><br><span class="line">	sd = sysfs_new_dirent(name, mode, SYSFS_DIR); //数据项类型为目录</span><br><span class="line">	if (!sd)</span><br><span class="line">		return -ENOMEM;</span><br><span class="line"> </span><br><span class="line">	sd-&gt;s_flags |= (type &lt;&lt; SYSFS_NS_TYPE_SHIFT); //命名空间类型，占用s_flags倒数第二个8位</span><br><span class="line">	sd-&gt;s_ns = ns; //命名空间</span><br><span class="line">	sd-&gt;s_dir.kobj = kobj; //关联内核对象</span><br><span class="line"></span><br><span class="line">	sysfs_addrm_start(&amp;acxt, parent_sd); //加锁并携带父数据项</span><br><span class="line">	rc = sysfs_add_one(&amp;acxt, sd); //关联父数据项</span><br><span class="line">	sysfs_addrm_finish(&amp;acxt); //解锁</span><br><span class="line"> </span><br><span class="line">	if (rc == 0)  //成功返回</span><br><span class="line">		*p_sd = sd;</span><br><span class="line">	else</span><br><span class="line">		sysfs_put(sd); //释放数据项</span><br><span class="line"> </span><br><span class="line">	return rc;</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line">struct sysfs_dirent *sysfs_new_dirent(const char *name, umode_t mode, int type)</span><br><span class="line">&#123;</span><br><span class="line">	char *dup_name = NULL;</span><br><span class="line">	struct sysfs_dirent *sd;</span><br><span class="line"> </span><br><span class="line">	if (type &amp; SYSFS_COPY_NAME) &#123; //目录或符号链接文件需要拷贝文件名，它们对应的都是内核对象</span><br><span class="line">		name = dup_name = kstrdup(name, GFP_KERNEL); //分配内存并拷贝文件名</span><br><span class="line">		if (!name) //当不为空指针时则表示name指向新分配的内存</span><br><span class="line">			return NULL;</span><br><span class="line">	&#125;</span><br><span class="line"> </span><br><span class="line">	sd = kmem_cache_zalloc(sysfs_dir_cachep, GFP_KERNEL); //从sysfs_dir_cachep缓存中分配sysfs数据项</span><br><span class="line">	if (!sd)</span><br><span class="line">		goto err_out1;</span><br><span class="line"> </span><br><span class="line">	if (sysfs_alloc_ino(&amp;sd-&gt;s_ino)) //分配i节点号</span><br><span class="line">		goto err_out2;</span><br><span class="line">	</span><br><span class="line">	//引用计数</span><br><span class="line">	atomic_set(&amp;sd-&gt;s_count, 1);</span><br><span class="line">	atomic_set(&amp;sd-&gt;s_active, 0);</span><br><span class="line"> </span><br><span class="line">	sd-&gt;s_name = name; //目录项名称</span><br><span class="line">	sd-&gt;s_mode = mode; //文件类型及访问权限</span><br><span class="line">	sd-&gt;s_flags = type; //sysfs数据项类型，占用s_flags低8位</span><br><span class="line"> </span><br><span class="line">	return sd;</span><br><span class="line"> </span><br><span class="line"> err_out2:</span><br><span class="line">	kmem_cache_free(sysfs_dir_cachep, sd);</span><br><span class="line"> err_out1:</span><br><span class="line">	kfree(dup_name);</span><br><span class="line">	return NULL;</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line">int sysfs_add_one(struct sysfs_addrm_cxt *acxt, struct sysfs_dirent *sd)</span><br><span class="line">&#123;</span><br><span class="line">	int ret;</span><br><span class="line"> </span><br><span class="line">	ret = __sysfs_add_one(acxt, sd);</span><br><span class="line">	if (ret == -EEXIST) &#123; //同名数据项已经存在则输出告警信息</span><br><span class="line">		char *path = kzalloc(PATH_MAX, GFP_KERNEL);</span><br><span class="line">		WARN(1, KERN_WARNING</span><br><span class="line">		     &quot;sysfs: cannot create duplicate filename &#x27;%s&#x27;\n&quot;,</span><br><span class="line">		     (path == NULL) ? sd-&gt;s_name :</span><br><span class="line">		     strcat(strcat(sysfs_pathname(acxt-&gt;parent_sd, path), &quot;/&quot;),</span><br><span class="line">		            sd-&gt;s_name)); //数据项的全路径</span><br><span class="line">		kfree(path);</span><br><span class="line">	&#125;</span><br><span class="line"> </span><br><span class="line">	return ret;</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line">int __sysfs_add_one(struct sysfs_addrm_cxt *acxt, struct sysfs_dirent *sd)</span><br><span class="line">&#123;</span><br><span class="line">	struct sysfs_inode_attrs *ps_iattr;</span><br><span class="line"> </span><br><span class="line">	if (sysfs_find_dirent(acxt-&gt;parent_sd, sd-&gt;s_ns, sd-&gt;s_name)) //查找该父目录下是否存在同名的数据项</span><br><span class="line">		return -EEXIST; //已存在则返回错误码</span><br><span class="line"> </span><br><span class="line">	sd-&gt;s_parent = sysfs_get(acxt-&gt;parent_sd); //递增父数据项的引用计数，然后指向该父数据项</span><br><span class="line"> </span><br><span class="line">	sysfs_link_sibling(sd); //加入到父数据项的子数据项链表</span><br><span class="line"> </span><br><span class="line">	//更新父数据项的时间戳</span><br><span class="line">	ps_iattr = acxt-&gt;parent_sd-&gt;s_iattr;</span><br><span class="line">	if (ps_iattr) &#123;</span><br><span class="line">		struct iattr *ps_iattrs = &amp;ps_iattr-&gt;ia_iattr;</span><br><span class="line">		ps_iattrs-&gt;ia_ctime = ps_iattrs-&gt;ia_mtime = CURRENT_TIME;</span><br><span class="line">	&#125;</span><br><span class="line"> </span><br><span class="line">	return 0;</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line">struct sysfs_dirent *sysfs_find_dirent(struct sysfs_dirent *parent_sd,</span><br><span class="line">				       const void *ns,</span><br><span class="line">				       const unsigned char *name)</span><br><span class="line">&#123;</span><br><span class="line">	struct sysfs_dirent *sd;</span><br><span class="line"> </span><br><span class="line">	for (sd = parent_sd-&gt;s_dir.children; sd; sd = sd-&gt;s_sibling) &#123; //遍历父目录</span><br><span class="line">		if (ns &amp;&amp; sd-&gt;s_ns &amp;&amp; (sd-&gt;s_ns != ns)) //查找同一命名空间</span><br><span class="line">			continue;</span><br><span class="line">		if (!strcmp(sd-&gt;s_name, name)) //同名sysfs数据项</span><br><span class="line">			return sd;</span><br><span class="line">	&#125;</span><br><span class="line">	return NULL;</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line">static void sysfs_link_sibling(struct sysfs_dirent *sd)</span><br><span class="line">&#123;</span><br><span class="line">	struct sysfs_dirent *parent_sd = sd-&gt;s_parent;</span><br><span class="line">	struct sysfs_dirent **pos;</span><br><span class="line"> </span><br><span class="line">	BUG_ON(sd-&gt;s_sibling);</span><br><span class="line"> </span><br><span class="line">	for (pos = &amp;parent_sd-&gt;s_dir.children; *pos; pos = &amp;(*pos)-&gt;s_sibling) &#123;</span><br><span class="line">		if (sd-&gt;s_ino &lt; (*pos)-&gt;s_ino) //升序排列</span><br><span class="line">			break;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	sd-&gt;s_sibling = *pos;</span><br><span class="line">	*pos = sd;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>4.2、内核对象的属性（struct attribute）对应于sysfs文件系统中的文本文件，可使用sysfs_create_file函数来创建，源代码如下所示：</p>
<figure class="highlight text"><table><tr><td class="code"><pre><span class="line">/* fs/sysfs/file.c */</span><br><span class="line">int sysfs_create_file(struct kobject * kobj, const struct attribute * attr)</span><br><span class="line">&#123;</span><br><span class="line">	BUG_ON(!kobj || !kobj-&gt;sd || !attr); //三者必须为真</span><br><span class="line"> </span><br><span class="line">	return sysfs_add_file(kobj-&gt;sd, attr, SYSFS_KOBJ_ATTR); //数据项类型为SYSFS_KOBJ_ATTR，对应sysfs文件系统中的文本文件</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line">int sysfs_add_file(struct sysfs_dirent *dir_sd, const struct attribute *attr,</span><br><span class="line">		   int type)</span><br><span class="line">&#123;</span><br><span class="line">	return sysfs_add_file_mode(dir_sd, attr, type, attr-&gt;mode); //访问权限由内核对象的属性自身配置</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line">int sysfs_add_file_mode(struct sysfs_dirent *dir_sd,</span><br><span class="line">			const struct attribute *attr, int type, mode_t amode)</span><br><span class="line">&#123;</span><br><span class="line">	umode_t mode = (amode &amp; S_IALLUGO) | S_IFREG; //文件类型为普通文件</span><br><span class="line">	struct sysfs_addrm_cxt acxt;</span><br><span class="line">	struct sysfs_dirent *sd;</span><br><span class="line">	int rc;</span><br><span class="line"></span><br><span class="line">	//分配sysfs数据项并初始化</span><br><span class="line">	sd = sysfs_new_dirent(attr-&gt;name, mode, type);</span><br><span class="line">	if (!sd)</span><br><span class="line">		return -ENOMEM;</span><br><span class="line">	sd-&gt;s_attr.attr = (void *)attr; //保存内核对象属性</span><br><span class="line">	sysfs_dirent_init_lockdep(sd); //初始化死锁检测模块</span><br><span class="line"> </span><br><span class="line">	sysfs_addrm_start(&amp;acxt, dir_sd); //dir_sd对应于属性文件所在的目录</span><br><span class="line">	rc = sysfs_add_one(&amp;acxt, sd);</span><br><span class="line">	sysfs_addrm_finish(&amp;acxt);</span><br><span class="line"> </span><br><span class="line">	if (rc) //失败则销毁sysfs数据项</span><br><span class="line">		sysfs_put(sd);</span><br><span class="line"> </span><br><span class="line">	return rc;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>sysfs文件系统中的二进制文件通过sysfs_create_bin_file函数来创建，符号链接文件通过sysfs_create_link函数来创建。</p>
<hr>
<p>版权声明：本文为知乎博主「Linux内核库」的原创文章，遵循CC 4.0 BY-SA版权协议，转载请附上原文 出处链接及本声明。</p>
<p>原文链接：<a href="https://zhuanlan.zhihu.com/p/558497992">https://zhuanlan.zhihu.com/p/558497992</a></p>
]]></content>
      <categories>
        <category>linux-doc 文件系统</category>
      </categories>
      <tags>
        <tag>Linux</tag>
      </tags>
  </entry>
  <entry>
    <title>Linux内核加密文件系统（eCryptfs）</title>
    <url>/2023/01/15/linux-docs/%E6%96%87%E4%BB%B6%E7%B3%BB%E7%BB%9F/Linux%E5%86%85%E6%A0%B8%E5%8A%A0%E5%AF%86%E6%96%87%E4%BB%B6%E7%B3%BB%E7%BB%9F%EF%BC%88eCryptfs%EF%BC%89/</url>
    <content><![CDATA[<p>eCryptfs是在Linux内核2.6.19版本中，由IBM公司的Halcrow，Thompson等人引入的一个功能强大的企业级加密文件系统，它支持文件名和文件内容的加密。</p>
<h2 id="1、eCryptfs架构设计"><a href="#1、eCryptfs架构设计" class="headerlink" title="1、eCryptfs架构设计"></a><strong>1、eCryptfs架构设计</strong></h2><p><img src="https://pic4.zhimg.com/80/v2-f3bf234fa7baed1a177bbd457323ee97_720w.webp" alt="img"></p>
<blockquote>
<p>图片摘自《eCryptfs: a Stacked Cryptographic Filesystem》</p>
</blockquote>
<p>eCryptfs的架构设计如图所示。eCryptfs堆叠在底层文件系统之上，用户空间的eCryptfs daemon和内核的keyring共同负责秘钥的管理，当用户空间发起对加密文件的写操作时，由VFS转发给eCryptfs ，eCryptfs通过kernel Crypto API（AES,DES）对其进行加密操作，再转发给底层文件系统。读则相反。</p>
<p>eCryptfs 的加密设计受到OpenPGP规范的影响，其核心思想有以下两点：</p>
<h3 id="1-1文件名与内容的加密"><a href="#1-1文件名与内容的加密" class="headerlink" title="1.1文件名与内容的加密"></a>1.1文件名与内容的加密</h3><p>eCryptfs 采用对称秘钥加密算法来加密文件名及文件内容（如AES，DES等），秘钥FEK（FileEncryption Key）是随机分配的。相对多个加密文件使用同一个FEK，其安全性更高。</p>
<h3 id="1-2FEK的加密"><a href="#1-2FEK的加密" class="headerlink" title="1.2FEK的加密"></a>1.2FEK的加密</h3><p>eCryptfs 使用用户提供的口令（Passphrase）、公开密钥算法（如 RSA 算法）或 TPM（Trusted Platform Module）的公钥来加密保护FEK。加密后的FEK称EFEK（Encrypted File Encryption Key），口令&#x2F;公钥称为 FEFEK（File Encryption Key Encryption Key）。</p>
<h2 id="2、eCryptfs的使用"><a href="#2、eCryptfs的使用" class="headerlink" title="2、eCryptfs的使用"></a><strong>2、eCryptfs的使用</strong></h2><p>这里在ubuntu下演示eCryptfs的建立流程。</p>
<p>1.安装用户空间应用程序ecryptfs-utils</p>
<p><img src="https://pic3.zhimg.com/80/v2-2b3613ff7bad248f5812719f59f3a426_720w.webp" alt="img"></p>
<p>2.发起mount指令，在ecryptfs-utils的辅助下输入用户口令，选择加密算法，完成挂载。挂载成功后，将对my_cryptfs目录下的所有文件进行加密处理。</p>
<p><img src="https://pic1.zhimg.com/80/v2-ca05aa2dd1c8a11ea1ca03bb598c5768_720w.webp" alt="img"></p>
<p>\3. 在加密目录下新增文件，当umount当前挂载目录后，再次查看该目录下文件时，可以看到文件已被加密处理过。</p>
<p><img src="https://pic1.zhimg.com/80/v2-15a13f9b28d9b346f1aefd28e796dd30_720w.webp" alt="img"></p>
<h2 id="3、eCryptfs的加解密流程"><a href="#3、eCryptfs的加解密流程" class="headerlink" title="3、eCryptfs的加解密流程"></a><strong>3、eCryptfs的加解密流程</strong></h2><p><img src="https://pic2.zhimg.com/80/v2-7cc3242ccb60476c8525998a1e3a901d_720w.webp" alt="img"></p>
<blockquote>
<p>图片摘自《eCryptfs: a Stacked Cryptographic Filesystem》</p>
</blockquote>
<p>eCryptfs对数据的加解密流程如图所示，对称密钥加密算法以块为单位进行加解密，如AES-128。eCryptfs 将加密文件分成多个逻辑块，称为 extent，extent 的大小默认等于物理页page的大小。加密文件的头部存放元数据Metadata，包括File Size，Flag，EFEK等等，目前元数据的最小长度是8192个字节。当eCryptfs发起读操作解密时，首先解密FEKEK拿到FEK,然后将加密文件对应的 extent读入到Page Cache，通过 Kernel Crypto API 解密；写操作加密则相反。</p>
<p>下面我们基于eCryptfs代码调用流程，简单跟踪下读写的加解密过程：</p>
<h3 id="3-1eCryptfs-open流程"><a href="#3-1eCryptfs-open流程" class="headerlink" title="3.1eCryptfs_open流程"></a>3.1eCryptfs_open流程</h3><p><img src="https://pic2.zhimg.com/80/v2-7cd329469e412451be6ee9b6f49b4115_720w.webp" alt="img"></p>
<p>ecryptfs_open的函数调用流程如图所示，open函数主要功能是解析底层文件Head的metadata，从metadata中取出EFEK，通过kernel crypto解密得到FEK，保存在ecryptfs_crypt_stat结构体的key成员中，并初始化ecryptfs_crypt_stat对象，以便后续的读写加解密操作。具体的可以跟踪下ecryptfs_read_metadata函数的逻辑。</p>
<p>\2. eCryptfs_read流程</p>
<p><img src="https://pic3.zhimg.com/80/v2-85d8e9d00c46c97ac4230874e1f3f37a_720w.webp" alt="img"></p>
<p>ecryptfs_decrypt_page()核心代码</p>
<p><img src="https://pic2.zhimg.com/80/v2-929af4d742e14597b1f9bd1a87e36d09_720w.webp" alt="img"></p>
<p>crypt_extent()核心代码</p>
<p><img src="https://pic3.zhimg.com/80/v2-1f78161f3aaa356150b062d7d03478c2_720w.webp" alt="img"></p>
<h2 id="4、eCryptfs的缺点"><a href="#4、eCryptfs的缺点" class="headerlink" title="4、eCryptfs的缺点"></a><strong>4、eCryptfs的缺点</strong></h2><h3 id="4-1性能问题。"><a href="#4-1性能问题。" class="headerlink" title="4.1性能问题。"></a>4.1性能问题。</h3><p>我们知道，堆叠式文件系统，对于性能的影响是无法忽略的，并且eCryptfs还涉及了加解密的操作，其性能问题应该更为突出。从公开资料显示，对于读操作影响较小，写操作性能影响很大。这是因为，eCryptfs的Page cache中存放的是明文，对于一段数据，只有首次读取需要解密，后续读操作将没有这些开销。但对于每次写入的数据，涉及的加密操作开销就会较大。</p>
<h3 id="4-2安全隐患"><a href="#4-2安全隐患" class="headerlink" title="4.2安全隐患"></a>4.2安全隐患</h3><p><img src="https://pic1.zhimg.com/80/v2-f7cc2141ab97eecb27bbd73279dcc8b0_720w.webp" alt="img"></p>
<p>上面讲到，eCryptfs的Page cache中存放的是明文，如果用户空间的权限设置不当或被攻破，那么这段数据将会暴露给所有应用程序。这部分是使用者需要考虑优化的方向。</p>
<h2 id="5、结语"><a href="#5、结语" class="headerlink" title="5、结语"></a><strong>5、结语</strong></h2><p>本文主要对eCryptfs的整体架构做了简单阐述，可能在一些细节上还不够详尽，有兴趣的同学可以一起学习。近些年，随着处理器和存储性能的不断增强，eCryptfs的性能问题也在一直得到改善，其易部署、易使用、安全高效的优点正在日益凸显。</p>
<hr>
<p>版权声明：本文为知乎博主「Linux内核库」的原创文章，遵循CC 4.0 BY-SA版权协议，转载请附上原文 出处链接及本声明。 </p>
<p>原文链接：<a href="https://zhuanlan.zhihu.com/p/539350620">https://zhuanlan.zhihu.com/p/539350620</a></p>
]]></content>
      <categories>
        <category>linux-doc 文件系统</category>
      </categories>
      <tags>
        <tag>Linux</tag>
      </tags>
  </entry>
  <entry>
    <title>Linux内核文件系统原理与实现</title>
    <url>/2023/01/15/linux-docs/%E6%96%87%E4%BB%B6%E7%B3%BB%E7%BB%9F/Linux%E5%86%85%E6%A0%B8%E6%96%87%E4%BB%B6%E7%B3%BB%E7%BB%9F%E5%8E%9F%E7%90%86%E4%B8%8E%E5%AE%9E%E7%8E%B0/</url>
    <content><![CDATA[<h2 id="1、定义"><a href="#1、定义" class="headerlink" title="1、定义"></a>1、定义</h2><ul>
<li>文件系统为我们直接操作文件和目录与存储设备之间充当桥梁和中介的角色</li>
</ul>
<h2 id="2、分类"><a href="#2、分类" class="headerlink" title="2、分类"></a>2、分类</h2><ul>
<li>基本文件文件（拓展文件系统）<ul>
<li>ext<ul>
<li>单文件大小最大2GB</li>
<li>数据块分散在存储设备（碎片化），读取速度慢</li>
</ul>
</li>
<li>ext2<ul>
<li>单文件最大支持32TB</li>
<li>数据块分组，读取速度提升</li>
<li>系统崩溃和断电时易损坏文件系统</li>
<li>存储文件依赖于索引节点表</li>
</ul>
</li>
</ul>
</li>
<li>日志文件系统<ul>
<li>定义<ul>
<li>先将数据写入到日志，直到文件成功写入存储设备和更新索引节点表后再删除日志项，系统崩溃或断电恢复后，继续将上次未写入存储设备的日志文件继续写入</li>
</ul>
</li>
<li>日志方法<ul>
<li>数据模式<ul>
<li>索引节点和文件都会被写入日志（安全性好但性能差）</li>
</ul>
</li>
<li>有序模式<ul>
<li>只有索引节点数据会被写入日志，但只有数据成功写入后才删除（安全性和性能居中）</li>
</ul>
</li>
<li>回写模式<ul>
<li>只有索引节点数据会被写入日志，但不控制文件数据何时写入（安全性差但性能好）</li>
</ul>
</li>
</ul>
</li>
<li>分类<ul>
<li>ext3<ul>
<li>日志方法为有序模式（可修改）</li>
<li>没有数据压缩和加密功能</li>
<li>无法恢复误删文件</li>
</ul>
</li>
<li>ext4<ul>
<li>支持数据压缩和加密功能</li>
<li>支持extent(区段)特性</li>
<li>预分配技术为大文件预留空间</li>
</ul>
</li>
<li>Reiser<ul>
<li>日志方法为回写模式</li>
<li>支持在线调整文件系统大小</li>
<li>可把一个文件数据写到另一个文件的数据块的空白位置（尾部压缩技术）</li>
</ul>
</li>
<li>JFS<ul>
<li>日志方法为有序模式</li>
<li>基于extent的文件分配，减少碎片化</li>
</ul>
</li>
<li>XFS<ul>
<li>日志方法为回写模式</li>
<li>在线调整文件系统仅支持扩大</li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
<li>写时复制文件系统(cow)<ul>
<li>定义<ul>
<li>修改数据时，先把源文件克隆或打快照的方式，避免直接修改源文件的内容，然后文件系统会再另外一个位置创建一块空间，以供存放新数据</li>
</ul>
</li>
<li>分类<ul>
<li>Btrf<ul>
<li>高稳定性和易用性，支持动态调整已挂载的文件系统大小</li>
</ul>
</li>
<li>ZFS<ul>
<li>无GPL许可，非Linux默认文件系统</li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
</ul>
<h2 id="3、命令"><a href="#3、命令" class="headerlink" title="3、命令"></a>3、命令</h2><ul>
<li>创建分区<ul>
<li>创建分区<br><code>fdisk /dev/sdx</code></li>
<li>打印存储设备&#x2F;dev&#x2F;sdx的详细信息<br><code>p</code></li>
<li>创建一个新分区<br><code>n</code></li>
<li>指定分区数量<br><code>num</code></li>
<li>指定起始扇区<br><code>输入2048或回车</code></li>
<li>指定终止扇区<br><code>+num G或回车(如果是单个分区)</code></li>
<li>保存更改信息<br><code>w</code></li>
</ul>
</li>
<li>创建文件系统<ul>
<li>格式化文件系统<br><code>mkfs.ext4 /dev/sdx</code></li>
<li>挂载到虚拟目录的挂载点<br><code>mount -t ext4 /dev/sdx /mnt/</code></li>
<li>实现开机自挂载<br><code>echo -e &quot;/dev/sdx\t/mnt\t ext4\t defaults\t 0 0&quot; &gt;&gt;/etc/fstab</code></li>
</ul>
</li>
<li>LVM<ul>
<li>1.定义物理卷<ul>
<li>在建立的分区基础上改变分区类型<br><code>t</code></li>
<li>声明该分区仅为LVM系统的一部分<br><code>8e</code></li>
<li>打印该分区信息<br><code>p</code></li>
<li>保存分区信息更改<br><code>w</code></li>
</ul>
</li>
<li>2.创建物理卷<ul>
<li>把分区定义为LVM系统的分区<br><code>pvcreate /dev/sdx(x=a-z)</code></li>
<li>查看已创建的物理卷列表<br><code>pvdisplay /dev/sdx</code></li>
</ul>
</li>
<li>3.创建卷组<ul>
<li>创建卷组<br><code>vgcreate vgname /dev/sdx</code></li>
<li>查看已创建卷组信息<br><code>vgdisplay vgname</code></li>
</ul>
</li>
<li>4.创建逻辑卷<ul>
<li>创建占用全部逻辑区段(卷组)的逻辑卷<br><code>lvcreate -l 100%FREE -n lvname vgname</code></li>
<li>查看已创建的逻辑卷信息<br><code>lvdisplay vgname</code></li>
</ul>
</li>
<li>5.创建文逻辑卷件系统<br><code>mkfs.ext4 /dev/vgname/lvname</code></li>
<li>6.挂载逻辑卷到虚拟目录<br><code>mount /dev/vgname/lvname /mnt</code></li>
</ul>
</li>
<li>LVM修改<ul>
<li>激活或禁用卷组<br><code>vgchange</code></li>
<li>删除卷组<br><code>vgremove</code></li>
<li>把物理卷加入到卷组中<br><code>vgextend</code></li>
<li>从卷组中删除物理卷<br><code>vgreduce</code></li>
<li>增加逻辑卷大小<br><code>lvextend</code></li>
<li>缩减逻辑卷大小<br><code>lvreduce</code></li>
<li>重新格式化逻辑卷的文件系统<br><code>resize2fs</code></li>
</ul>
</li>
</ul>
<h2 id="4、注意事项"><a href="#4、注意事项" class="headerlink" title="4、注意事项"></a>4、注意事项</h2><blockquote>
<ul>
<li>文件系统通过索引节点表来存放文件信息，并通过索引节点号来标识文件</li>
<li>IDE驱动器的存储设备名使用dev&#x2F;hdx，SCSI和SATA驱动器的存储设备名使用&#x2F;dev&#x2F;sdx(x&#x3D;a-z)</li>
<li>传统模式的拓展文件系统空间只能通过调整单块磁盘的分区大小或是购置更大磁盘，再把文件系统手动移动到新磁盘的方式</li>
<li>逻辑卷管理允许将一个或多个物理磁盘和物理分区加入到现有文件系统，动态拓展文件系统空间</li>
<li>一个或多个物理磁盘或物理分区组成一个卷组</li>
<li>逻辑分区建立在卷组基础上，逻辑分区包含文件系统</li>
<li>一个逻辑卷相当于一个物理分区，可以在逻辑卷建立文件系统，然后挂载到虚拟目录使用</li>
<li>逻辑卷管理架构：硬盘–物理分区–物理卷–卷组–逻辑分区–逻辑卷</li>
<li>LVM使用的三种技术为快照，条带化，镜像</li>
<li>卷组名用来标识创建逻辑卷时使用的卷组</li>
</ul>
</blockquote>
<hr>
<p>版权声明：本文为博主<a href="https://www.cnblogs.com/tjane">Tjane’Blogs</a>的原创文章，遵循CC 4.0 BY-SA版权协议，转载请附上原文出处链接及本声明。</p>
<p>原文链接： <a href="https://www.cnblogs.com/tjane/p/16795365.html">https://www.cnblogs.com/tjane/p/16795365.html</a></p>
]]></content>
      <categories>
        <category>linux-doc 文件系统</category>
      </categories>
      <tags>
        <tag>Linux</tag>
      </tags>
  </entry>
  <entry>
    <title>Linux内核文件系统挂载</title>
    <url>/2023/01/15/linux-docs/%E6%96%87%E4%BB%B6%E7%B3%BB%E7%BB%9F/Linux%E5%86%85%E6%A0%B8%E6%96%87%E4%BB%B6%E7%B3%BB%E7%BB%9F%E6%8C%82%E8%BD%BD/</url>
    <content><![CDATA[<h2 id="1、前言"><a href="#1、前言" class="headerlink" title="1、前言"></a><strong>1、前言</strong></h2><ul>
<li>环境：处理器架构：arm64内核源码：linux-5.11ubuntu版本：20.04.1代码阅读工具：vim+ctags+cscope</li>
</ul>
<blockquote>
<p>我们知道，Linux系统中我们经常将一个块设备上的文件系统挂载到某个目录下才能访问这个文件系统下的文件，但是你有没有思考过：为什么块设备挂载之后才能访问文件？挂载文件系统Linux内核到底为我们做了哪些事情？是否可以不将文件系统挂载到具体的目录下也能访问？下面，本文将详细讲解Linxu系统中，文件系统挂载的奥秘。<br>注：<strong>本文主要讲解文件系统挂载核心逻辑，暂不涉及挂载命名空间和绑定挂载等内容（后面的内容可能会涉及），且以ext2磁盘文件系统为例讲解挂载。本专题文章分为上下两篇，上篇主要介绍挂载全貌以及具体文件系统的挂载方法，下篇介绍如何通过挂载实例关联挂载点和超级块。</strong></p>
</blockquote>
<h2 id="2、vfs-几个重要对象"><a href="#2、vfs-几个重要对象" class="headerlink" title="2、vfs 几个重要对象"></a><strong>2、vfs 几个重要对象</strong></h2><blockquote>
<p>在这里我们不介绍整个IO栈，只说明和文件系统相关的vfs和具体文件系统层。我们知道在Linux中通过虚拟文件系统层VFS统一所有具体的文件系统，提取所有具体文件系统的共性，屏蔽具体文件系统的差异。VFS既是向下的接口（所有文件系统都必须实现该接口），同时也是向上的接口（用户进程通过系统调用最终能够访问文件系统功能）。<br>下面我们来看下，vfs中几个比较重要的结构体对象：</p>
</blockquote>
<h3 id="2-1file-system-type"><a href="#2-1file-system-type" class="headerlink" title="2.1file_system_type"></a><strong>2.1file_system_type</strong></h3><ul>
<li>这个结构来描述一种文件系统类型，一般具体文件系统会定义这个结构，然后注册到系统中；定义了具体文件系统的挂载和卸载方法，文件系统挂载时调用其挂载方法构建超级块、跟dentry等实例。</li>
<li>文件系统分为以下几种：</li>
</ul>
<p>1）磁盘文件系统</p>
<blockquote>
<p>文件在非易失性存储介质上(如硬盘，flash)，掉电文件不丢失。<br>如ext2,ext4,xfs</p>
</blockquote>
<p>2）内存文件系统</p>
<p>文件在内存上，掉电丢失。</p>
<p>如tmpfs</p>
<p>3）伪文件系统</p>
<p>是假的文件系统，是利用虚拟文件系统的接口（可以对用户可见如proc、sysfs,也可以对用户不可见内核可见如sockfs,bdev）。</p>
<p>如proc,sysfs,sockfs,bdev</p>
<p>4）网络文件系统</p>
<p>这种文件系统允许访问另一台计算机上的数据，该计算机通过网络连接到本地计算机。</p>
<p>如nfs文件系统</p>
<p>结构体定义源码路径：include&#x2F;linux&#x2F;fs.h +2226</p>
<h3 id="2-2super-block"><a href="#2-2super-block" class="headerlink" title="2.2super_block"></a><strong>2.2super_block</strong></h3><p>超级块，用于描述块设备上的一个文件系统总体信息（如文件块大小，最大文件大小，文件系统魔数等），一个块设备上的文件系统可以被挂载多次，但是内存中只能有个super_block来描述（至少对于磁盘文件系统来说）。</p>
<p>结构体定义源码路径：include&#x2F;linux&#x2F;fs.h +1414</p>
<h3 id="2-3mount"><a href="#2-3mount" class="headerlink" title="2.3mount"></a><strong>2.3mount</strong></h3><p>挂载描述符，用于建立超级块和挂载点等之间的联系，描述文件系统的一次挂载，一个块设备上的文件系统可以被挂载多次，每次挂载内存中有一个mount对象描述。</p>
<p>结构体定义源码路径：fs&#x2F;mount.h +39</p>
<h3 id="2-4inode"><a href="#2-4inode" class="headerlink" title="2.4inode"></a><strong>2.4inode</strong></h3><p>索引节点对象，<strong>描述磁盘上的一个文件元数据</strong>（文件属性、位置等），有些文件系统需要从块设备上读取磁盘上的索引节点,然后在内存中创建vfs的索引节点对象，一般在文件第一次打开时创建。</p>
<p>结构体定义源码路径：include&#x2F;linux&#x2F;fs.h +610</p>
<h3 id="2-5dentry"><a href="#2-5dentry" class="headerlink" title="2.5dentry"></a><strong>2.5dentry</strong></h3><p>目录项对象，用于<strong>描述文件的层次结构</strong>，从而构建文件系统的目录树，文件系统将目录当作文件，目录的数据由目录项组成，而每个目录项存储一个目录或文件的名称和索引节点号等内容。每当进程访问一个目录项就会在内存中创建目录项对象（如ext2路径名查找中，通过查找父目录数据块的目录项，找到对应文件&#x2F;目录的名称，获得inode号来找到对应inode）。</p>
<p>结构体定义源码路径：include&#x2F;linux&#x2F;dcache.h +90</p>
<h3 id="2-6file"><a href="#2-6file" class="headerlink" title="2.6file"></a><strong>2.6file</strong></h3><p>文件对象，描述进程打开的文件，当进程打开文件时会创建文件对象加入到进程的文件打开表，通过文件描述符来索引文件对象，后面读写等操作都通过文件描述符进行（一个文件可以被多个进程打开，会由多个文件对象加入到各个进程的文件打开表，但是inode只有一个）。</p>
<p>结构体定义源码路径：include&#x2F;linux&#x2F;fs.h +915</p>
<h2 id="3、挂载总体流程"><a href="#3、挂载总体流程" class="headerlink" title="3、挂载总体流程"></a><strong>3、挂载总体流程</strong></h2><h3 id="3-1系统调用处理"><a href="#3-1系统调用处理" class="headerlink" title="3.1系统调用处理"></a><strong>3.1系统调用处理</strong></h3><blockquote>
<p>用户执行挂载是通过系统调用路径进入内核处理，拷贝用户空间传递参数到内核，挂载委托do_mount。<br>&#x2F;&#x2F;fs&#x2F;namespace.c<br>SYSCALL_DEFINE5(mount</p>
</blockquote>
<p>参数：</p>
<figure class="highlight text"><table><tr><td class="code"><pre><span class="line">dev_name 要挂载的块设备</span><br><span class="line">dir_name 挂载点目录</span><br><span class="line">type 文件系统类型名</span><br><span class="line">flags 挂载标志</span><br><span class="line">data 挂载选项</span><br><span class="line">-&gt; kernel_type = copy_mount_string(type); //拷贝文件系统类型名到内核空间</span><br><span class="line">-&gt; kernel_dev = copy_mount_string(dev_name) //拷贝块设备路径名到内核空间</span><br><span class="line">-&gt; options = copy_mount_options(data) //拷贝挂载选项到内核空间</span><br><span class="line">-&gt; do_mount(kernel_dev, dir_name, kernel_type, flags, options) //挂载委托do_mount</span><br></pre></td></tr></table></figure>

<h3 id="3-2挂载点路径查找"><a href="#3-2挂载点路径查找" class="headerlink" title="3.2挂载点路径查找"></a><strong>3.2挂载点路径查找</strong></h3><figure class="highlight text"><table><tr><td class="code"><pre><span class="line">挂载点路径查找，挂载委托path_mount</span><br><span class="line">do_mount</span><br><span class="line">-&gt; user_path_at(AT_FDCWD, dir_name, LOOKUP_FOLLOW, &amp;path) //挂载点路径查找 查找挂载点目录的 vfsmount和dentry 存放在 path</span><br><span class="line">-&gt; path_mount(dev_name, &amp;path, type_page, flags, data_page) //挂载委托path_mount</span><br></pre></td></tr></table></figure>

<h3 id="3-3参数合法性检查"><a href="#3-3参数合法性检查" class="headerlink" title="3.3参数合法性检查"></a><strong>3.3参数合法性检查</strong></h3><blockquote>
<p>参数合法性检查， 新挂载委托do_new_mount<br>path_mount<br>-&gt; 参数合法性检查<br>-&gt; 根据挂载标志调用不同函数处理 这里讲解是默认 do_new_mount</p>
</blockquote>
<h3 id="3-4调用具体文件系统挂载方法"><a href="#3-4调用具体文件系统挂载方法" class="headerlink" title="3.4调用具体文件系统挂载方法"></a><strong>3.4调用具体文件系统挂载方法</strong></h3><figure class="highlight text"><table><tr><td class="code"><pre><span class="line">do_new_mount</span><br><span class="line">-&gt; type = get_fs_type(fstype)  //根据传递的文件系统名  查找已经注册的文件系统类型</span><br><span class="line">-&gt; fc = fs_context_for_mount(type, sb_flags) //为挂载分配文件系统上下文 struct fs_context</span><br><span class="line"> -&gt; alloc_fs_context</span><br><span class="line">   -&gt; 分配fs_context fc = kzalloc(sizeof(struct fs_context), GFP_KERNEL)</span><br><span class="line">   -&gt;  设置 ... </span><br><span class="line">   -&gt;  fc-&gt;fs_type     = get_filesystem(fs_type);  //赋值相应的文件系统类型</span><br><span class="line">   -&gt;  init_fs_context = **fc-&gt;fs_type-&gt;init_fs_context**;  //新内核使用fs_type-&gt;init_fs_context接口  来初始化文件系统上下文</span><br><span class="line">    if (!init_fs_context)   //init_fs_context回掉 主要用于初始化</span><br><span class="line">        init_fs_context = **legacy_init_fs_context**;    //没有 fs_type-&gt;init_fs_context接口 </span><br><span class="line">   -&gt; init_fs_context(fc)  //初始化文件系统上下文 (初始化一些回掉函数，供后续使用)</span><br></pre></td></tr></table></figure>

<p>来看下文件系统类型没有实现init_fs_context接口的情况：</p>
<figure class="highlight text"><table><tr><td class="code"><pre><span class="line">//fs/fs_context.c</span><br><span class="line">init_fs_context = legacy_init_fs_context</span><br><span class="line">-&gt;  fc-&gt;ops = &amp;legacy_fs_context_ops   //设置文件系统上下午操作</span><br><span class="line">                    -&gt;.get_tree               = legacy_get_tree  //操作方法的get_tree用于  读取磁盘超级块并在内存创建超级块，创建跟inode， 跟dentry</span><br><span class="line">                        -&gt; root = fc-&gt;fs_type-&gt;mount(fc-&gt;fs_type, fc-&gt;sb_flags,</span><br><span class="line">                                         ¦     fc-&gt;source, ctx-&gt;legacy_data)  //调用文件系统类型的mount方法来读取并创建超级块</span><br><span class="line">                        -&gt; fc-&gt;root = root  //赋值创建好的跟dentry</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">有一些文件系统使用原来的接口(fs_type.mount  = xxx_mount)：如ext2,ext4等</span><br><span class="line">有一些文件系统使用新的接口(fs_type.init_fs_context =  xxx_init_fs_context)：xfs， proc， sys</span><br><span class="line"></span><br><span class="line">无论使用哪一种，都会在xxx_init_fs_contex中实现 fc-&gt;ops =  &amp;xxx_context_ops 接口，后面会看的都会调用fc-&gt;ops.get_tree 来读取创建超级块实例</span><br></pre></td></tr></table></figure>

<ul>
<li>继续往下走：</li>
</ul>
<figure class="highlight text"><table><tr><td class="code"><pre><span class="line">do_new_mount</span><br><span class="line">    -&gt; ...</span><br><span class="line">    -&gt;  fc = fs_context_for_mount(type, sb_flags) //分配 赋值文件系统上下文</span><br><span class="line">    -&gt; parse_monolithic_mount_data(fc, data)  //调用fc-&gt;ops-&gt;parse_monolithic  解析挂载选项</span><br><span class="line">    -&gt; mount_capable(fc) //检查是否有挂载权限</span><br><span class="line">    -&gt; vfs_get_tree(fc)  //fs/super.c 挂载重点   调用fc-&gt;ops-&gt;get_tree(fc) 读取创建超级块实例</span><br><span class="line">    ...</span><br></pre></td></tr></table></figure>

<h3 id="3-5挂载实例添加到全局文件系统树"><a href="#3-5挂载实例添加到全局文件系统树" class="headerlink" title="3.5挂载实例添加到全局文件系统树"></a><strong>3.5挂载实例添加到全局文件系统树</strong></h3><figure class="highlight text"><table><tr><td class="code"><pre><span class="line">do_new_mount</span><br><span class="line">    ...</span><br><span class="line">    -&gt;  do_new_mount_fc(fc, path, mnt_flags)  //创建mount实例 关联挂载点和超级块  添加到命名空间的挂载树中</span><br></pre></td></tr></table></figure>

<p>下面主要看下vfs_get_tree和do_new_mount_fc：</p>
<h2 id="4、具体文件系统挂载方法"><a href="#4、具体文件系统挂载方法" class="headerlink" title="4、具体文件系统挂载方法"></a><strong>4、具体文件系统挂载方法</strong></h2><h3 id="4-1vfs-get-tree"><a href="#4-1vfs-get-tree" class="headerlink" title="4.1vfs_get_tree"></a><strong>4.1vfs_get_tree</strong></h3><figure class="highlight text"><table><tr><td class="code"><pre><span class="line">//以ext2文件系统为例</span><br><span class="line">vfs_get_tree  //fs/namespace.c</span><br><span class="line">-&gt; fc-&gt;ops-&gt;get_tree(fc)</span><br><span class="line"> -&gt; legacy_get_tree   //上面分析过 fs_type-&gt;init_fs_context == NULL使用旧的接口(ext2为NULL)</span><br><span class="line">  -&gt;fc-&gt;fs_type-&gt;mount</span><br><span class="line">   -&gt; ext2_mount  //fs/ext2/super.c  调用到具体文件系统的挂载方法</span><br></pre></td></tr></table></figure>

<p>来看下ext2对挂载的处理：</p>
<p>启动阶段初始化-&gt;</p>
<figure class="highlight text"><table><tr><td class="code"><pre><span class="line">//fs/ext2/super.c</span><br><span class="line">module_init(init_ext2_fs)</span><br><span class="line">init_ext2_fs</span><br><span class="line"> -&gt;init_inodecache  //创建ext2_inode_cache 对象缓存</span><br><span class="line"> -&gt;register_filesystem(&amp;ext2_fs_type) //注册ext2的文件系统类型</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">static struct file_system_type ext2_fs_type = &#123;</span><br><span class="line">        .owner          = THIS_MODULE,</span><br><span class="line">        .name           = &quot;ext2&quot;,</span><br><span class="line">        .mount          = ext2_mount,   //挂载时调用  用于读取创建超级块实例</span><br><span class="line">        .kill_sb        = kill_block_super,  //卸载时调用  用于释放超级块</span><br><span class="line">        .fs_flags       = FS_REQUIRES_DEV,  //文件系统标志为  请求块设备，文件系统在块设备上</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>挂载时调用-&gt;</p>
<figure class="highlight text"><table><tr><td class="code"><pre><span class="line">// fs/ext2/super.c</span><br><span class="line">static struct dentry *ext2_mount(struct file_system_type *fs_type,           </span><br><span class="line">        int flags, const char *dev_name, void *data)</span><br><span class="line">&#123;</span><br><span class="line">        return mount_bdev(fs_type, flags, dev_name, data, ext2_fill_super);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>ext2_mount通过调用mount_bdev来执行实际文件系统的挂载工作，<strong>ext2_fill_super</strong>的一个函数指针作为参数传递给<strong>get_sb_bdev</strong>。该函数用于填充一个超级块对象，如果内存中没有适当的超级块对象，数据就必须从硬盘读取。</p>
<p>mount_bdev是个公用的函数，一般磁盘文件系统会使用它来根据具体文件系统的fill_super方法来读取磁盘上的超级块并在创建内存超级块。</p>
<p>我们来看下mount_bdev的实现（**它执行完成之后会创建vfs的三大数据结构 super_block、根inode和根dentry **）：</p>
<h3 id="4-2mount-bdev源码分析"><a href="#4-2mount-bdev源码分析" class="headerlink" title="4.2mount_bdev源码分析"></a><strong>4.2mount_bdev源码分析</strong></h3><figure class="highlight text"><table><tr><td class="code"><pre><span class="line">//fs/super.c</span><br><span class="line">mount_bdev</span><br><span class="line">-&gt;bdev = blkdev_get_by_path(dev_name, mode, fs_type)  //通过要挂载的块设备路径名 获得它的块设备描述符block_device（会涉及到路径名查找和通过设备号在bdev文件系统查找block_device，block_device是添加块设备到系统时创建的）</span><br><span class="line">-&gt; s = sget(fs_type, test_bdev_super, set_bdev_super, flags | SB_NOSEC,   </span><br><span class="line">         ¦bdev);  //查找或创建vfs的超级块  （会首先在文件系统类型的fs_supers链表查找是否已经读取过指定的超级块，会对比每个超级块的s_bdev块设备描述符，没有创建一个）</span><br><span class="line">-&gt;  if (s-&gt;s_root) &#123;   //超级块的根dentry是否被赋值？</span><br><span class="line">  ...</span><br><span class="line"> &#125; else &#123;   //没有赋值说明时新创建的sb</span><br><span class="line">  ...</span><br><span class="line">  -&gt; sb_set_blocksize(s, block_size(bdev)) //根据块设备描述符设置文件系统块大小</span><br><span class="line">  -&gt;  fill_super(s, data, flags &amp; SB_SILENT ? 1 : 0)  //调用传递的具体文件系统的填充超级块方法读取填充超级块等 如ext2_fill_super</span><br><span class="line">  -&gt;  bdev-&gt;bd_super = s  //块设备bd_super指向sb</span><br><span class="line"> &#125;</span><br><span class="line">-&gt; return dget(s-&gt;s_root)  //返回文件系统的根dentry</span><br></pre></td></tr></table></figure>

<p>可以看到mount_bdev主要是：</p>
<p>1.<strong>根据要挂载的块设备文件名查找到对应的块设备描述符（内核后面操作块设备都是使用块设备描述符）；</strong></p>
<p><strong>2.首先在文件系统类型的fs_supers链表查找是否已经读取过指定的vfs超级块，会对比每个超级块的s_bdev块设备描述符，没有创建一个vfs超级块;</strong></p>
<p><strong>3.新创建的vfs超级块，需要调用具体文件系统的fill_super方法来读取填充超级块。</strong></p>
<p>那么下面主要集中在具体文件系统的fill_super方法，这里是ext2_fill_super：</p>
<p>分析重点代码如下：</p>
<h3 id="4-3ext2-fill-super源码分析"><a href="#4-3ext2-fill-super源码分析" class="headerlink" title="4.3ext2_fill_super源码分析"></a><strong>4.3ext2_fill_super源码分析</strong></h3><figure class="highlight text"><table><tr><td class="code"><pre><span class="line">//fs/ext2/super.c</span><br><span class="line">static int ext2_fill_super(struct super_block *sb, void *data, int silent)               </span><br><span class="line">&#123;                                                                                                          </span><br><span class="line">        struct buffer_head * bh;    //缓冲区头  记录读取的磁盘超级块                                                     </span><br><span class="line">        struct ext2_sb_info * sbi;   //内存的ext2 超级块信息                                                    </span><br><span class="line">        struct ext2_super_block * es;  //磁盘上的  超级块信息                                               </span><br><span class="line">           ...</span><br><span class="line">                                                        </span><br><span class="line">        sbi = kzalloc(sizeof(*sbi), GFP_KERNEL);     //分配 内存的ext2 超级块信息结构                                   </span><br><span class="line">        if (!sbi)                                                                        </span><br><span class="line">                goto failed;                                                             </span><br><span class="line">                                                                                         </span><br><span class="line">         ...                                                  </span><br><span class="line">        sb-&gt;s_fs_info = sbi;     //vfs的超级块 的s_fs_info指向内存的ext2 超级块信息结构                                                   </span><br><span class="line">        sbi-&gt;s_sb_block = sb_block;                                                      </span><br><span class="line">                                                       </span><br><span class="line">      if (!(bh = sb_bread(sb, logic_sb_block))) &#123;  // 读取磁盘上的超级块到内存的 使用buffer_head关联内存缓冲区和磁盘扇区                                   </span><br><span class="line">              ext2_msg(sb, KERN_ERR, &quot;error: unable to read superblock&quot;);                 </span><br><span class="line">              goto failed_sbi;                                                            </span><br><span class="line">      &#125;                                                                                   </span><br><span class="line">                   </span><br><span class="line">      es = (struct ext2_super_block *) (((char *)bh-&gt;b_data) + offset);  //转换为struct ext2_super_block 结构                 </span><br><span class="line">      sbi-&gt;s_es = es; //  内存的ext2 超级块信息结构的 s_es指向真正的ext2磁盘超级块信息结构                                                                 </span><br><span class="line">      sb-&gt;s_magic = le16_to_cpu(es-&gt;s_magic); //获得文件系统魔数   ext2为0xEF53                                        </span><br><span class="line">                                                                                          </span><br><span class="line">      if (sb-&gt;s_magic != EXT2_SUPER_MAGIC)    //验证 魔数是否正确                                           </span><br><span class="line">              goto cantfind_ext2;</span><br><span class="line"></span><br><span class="line">    blocksize = BLOCK_SIZE &lt;&lt; le32_to_cpu(sbi-&gt;s_es-&gt;s_log_block_size); //获得磁盘读取的块大小   </span><br><span class="line"></span><br><span class="line">                                                                                          </span><br><span class="line">        /* If the blocksize doesn&#x27;t match, re-read the thing.. */                         </span><br><span class="line">        if (sb-&gt;s_blocksize != blocksize) &#123;  //块大小不匹配 需要重新读取超级块                                              </span><br><span class="line">                brelse(bh);                                                               </span><br><span class="line">                                                                                          </span><br><span class="line">                if (!sb_set_blocksize(sb, blocksize)) &#123;                                   </span><br><span class="line">                        ext2_msg(sb, KERN_ERR,                                            </span><br><span class="line">                                &quot;error: bad blocksize %d&quot;, blocksize);                    </span><br><span class="line">                        goto failed_sbi;                                                  </span><br><span class="line">                &#125;                                                                         </span><br><span class="line">                                                                                          </span><br><span class="line">                logic_sb_block = (sb_block*BLOCK_SIZE) / blocksize;                       </span><br><span class="line">                offset = (sb_block*BLOCK_SIZE) % blocksize;                               </span><br><span class="line">                bh = sb_bread(sb, logic_sb_block); //重新 读取超级块                                       </span><br><span class="line">                if(!bh) &#123;                                                                 </span><br><span class="line">                        ext2_msg(sb, KERN_ERR, &quot;error: couldn&#x27;t read&quot;                     </span><br><span class="line">                                &quot;superblock on 2nd try&quot;);                                 </span><br><span class="line">                        goto failed_sbi;                                                  </span><br><span class="line">                &#125;                                                                         </span><br><span class="line">                es = (struct ext2_super_block *) (((char *)bh-&gt;b_data) + offset);         </span><br><span class="line">                sbi-&gt;s_es = es;                                                           </span><br><span class="line">                if (es-&gt;s_magic != cpu_to_le16(EXT2_SUPER_MAGIC)) &#123;                       </span><br><span class="line">                        ext2_msg(sb, KERN_ERR, &quot;error: magic mismatch&quot;);                  </span><br><span class="line">                        goto failed_mount;                                                </span><br><span class="line">                &#125;                                                                         </span><br><span class="line">        &#125;                                                                                 </span><br><span class="line">                                                                                          </span><br><span class="line">        sb-&gt;s_maxbytes = ext2_max_size(sb-&gt;s_blocksize_bits);  //设置最大文件大小                            </span><br><span class="line">        ...                                                           </span><br><span class="line">       </span><br><span class="line">       //读取或设置 inode大小和第一个inode号                                                                        </span><br><span class="line">       if (le32_to_cpu(es-&gt;s_rev_level) == EXT2_GOOD_OLD_REV) &#123;                   </span><br><span class="line">               sbi-&gt;s_inode_size = EXT2_GOOD_OLD_INODE_SIZE;                      </span><br><span class="line">               sbi-&gt;s_first_ino = EXT2_GOOD_OLD_FIRST_INO;                        </span><br><span class="line">       &#125; else &#123;                                                                   </span><br><span class="line">               sbi-&gt;s_inode_size = le16_to_cpu(es-&gt;s_inode_size);                 </span><br><span class="line">               sbi-&gt;s_first_ino = le32_to_cpu(es-&gt;s_first_ino);                   </span><br><span class="line">              ...                          </span><br><span class="line">       &#125;                                                                          </span><br><span class="line">                                                                                  </span><br><span class="line">      ...             </span><br><span class="line">                                                                                  </span><br><span class="line">       sbi-&gt;s_blocks_per_group = le32_to_cpu(es-&gt;s_blocks_per_group);    //赋值每个块组 块个数          </span><br><span class="line">       sbi-&gt;s_frags_per_group = le32_to_cpu(es-&gt;s_frags_per_group);               </span><br><span class="line">       sbi-&gt;s_inodes_per_group = le32_to_cpu(es-&gt;s_inodes_per_group);  //赋值每个块组 inode个数             </span><br><span class="line">                                                                                  </span><br><span class="line">       sbi-&gt;s_inodes_per_block = sb-&gt;s_blocksize / EXT2_INODE_SIZE(sb);    //赋值每个块 inode个数       </span><br><span class="line">       ...                     </span><br><span class="line">       sbi-&gt;s_desc_per_block = sb-&gt;s_blocksize /                                  </span><br><span class="line">                                       sizeof (struct ext2_group_desc);    //赋值每个块 块组描述符个数     </span><br><span class="line">       sbi-&gt;s_sbh = bh;  //赋值读取的超级块缓冲区                                                          </span><br><span class="line">       sbi-&gt;s_mount_state = le16_to_cpu(es-&gt;s_state);    //赋值挂载状态                           </span><br><span class="line">     ...                                   </span><br><span class="line">                                                                               </span><br><span class="line">    if (sb-&gt;s_magic != EXT2_SUPER_MAGIC)                                       </span><br><span class="line">            goto cantfind_ext2;                                                </span><br><span class="line">   </span><br><span class="line">   //一些合法性检查</span><br><span class="line">     ...    </span><br><span class="line">    </span><br><span class="line">  //计算块组描述符 个数</span><br><span class="line">  sbi-&gt;s_groups_count = ((le32_to_cpu(es-&gt;s_blocks_count) -               </span><br><span class="line">                          le32_to_cpu(es-&gt;s_first_data_block) - 1)        </span><br><span class="line">                                  / EXT2_BLOCKS_PER_GROUP(sb)) + 1;       </span><br><span class="line">  db_count = (sbi-&gt;s_groups_count + EXT2_DESC_PER_BLOCK(sb) - 1) /        </span><br><span class="line">          ¦  EXT2_DESC_PER_BLOCK(sb);                                     </span><br><span class="line">  sbi-&gt;s_group_desc = kmalloc_array(db_count,                             </span><br><span class="line">                                  ¦  sizeof(struct buffer_head *),        </span><br><span class="line">                                  ¦  GFP_KERNEL);  //分配块组描述符 bh数组                       </span><br><span class="line">   </span><br><span class="line">    </span><br><span class="line">    for (i = 0; i &lt; db_count; i++) &#123;      //读取块组描述符                                 </span><br><span class="line">          block = descriptor_loc(sb, logic_sb_block, i);                </span><br><span class="line">          sbi-&gt;s_group_desc[i] = sb_bread(sb, block);   //读取的 块组描述符缓冲区保存 到sbi-&gt;s_group_desc[i]              </span><br><span class="line">          if (!sbi-&gt;s_group_desc[i]) &#123;                                  </span><br><span class="line">                  for (j = 0; j &lt; i; j++)                               </span><br><span class="line">                          brelse (sbi-&gt;s_group_desc[j]);                </span><br><span class="line">                  ext2_msg(sb, KERN_ERR,                                </span><br><span class="line">                          &quot;error: unable to read group descriptors&quot;);   </span><br><span class="line">                  goto failed_mount_group_desc;                         </span><br><span class="line">          &#125;                                                             </span><br><span class="line">  &#125;                                                                     </span><br><span class="line"></span><br><span class="line">                                                                    </span><br><span class="line">  sb-&gt;s_op = &amp;ext2_sops;   //赋值超级块操作</span><br><span class="line">  ...</span><br><span class="line"> root = ext2_iget(sb, EXT2_ROOT_INO); //读取根inode  （ext2 根根inode号为2） </span><br><span class="line"></span><br><span class="line"> sb-&gt;s_root = d_make_root(root);  //创建根dentry  并建立根inode和根dentry关系</span><br><span class="line"> ext2_write_super(sb);  //同步超级块信息到磁盘 如挂载时间等</span><br></pre></td></tr></table></figure>

<p>可以看到ext2_fill_super主要工作为：</p>
<p><strong>1.读取磁盘上的超级块；</strong></p>
<p><strong>2.填充并关联vfs超级块；</strong></p>
<p><strong>3.读取块组描述符；</strong></p>
<p><strong>4.读取磁盘根inode并建立vfs 根inode;</strong></p>
<p><strong>5.创建根dentry关联到根inode</strong>。</p>
<p><strong>下面给出ext2_fill_super之后ext2相关图解：</strong></p>
<p><img src="https://pic2.zhimg.com/80/v2-464f0a179a76ef8ee3283bced520126d_720w.webp" alt="img"></p>
<p>有了这些信息，虽然能够获得块设备上的文件系统全貌，内核也能通过已经建立好的block_device等结构访问块设备，但是用户进程不能真正意义上访问到，用户一般会通过open打开一个文件路径来访问文件，但是现在并没有关联挂载目录的路径，需要将文件系统关联到挂载点，以至于路径名查找的时候查找到挂载点后，在转向文件系统的根目录，而这需要通过do_new_mount_fc来去关联并加入全局的文件系统树中,下一篇我们将做详细讲解。<strong>4、添加到全局文件系统树</strong></p>
<h3 id="4-1do-new-mount-fc"><a href="#4-1do-new-mount-fc" class="headerlink" title="4.1do_new_mount_fc"></a><strong>4.1do_new_mount_fc</strong></h3><figure class="highlight text"><table><tr><td class="code"><pre><span class="line">do_new_mount  //fs/namespace.c</span><br><span class="line">-&gt;do_new_mount_fc</span><br><span class="line"> -&gt;     struct vfsmount *mnt;                      </span><br><span class="line">    -&gt;   struct mountpoint *mp;                     </span><br><span class="line"> -&gt;  struct super_block *sb = fc-&gt;root-&gt;d_sb;  //获得vfs的超级块 （之前已经构建好）</span><br><span class="line"> &gt;  mnt = vfs_create_mount(fc);   //为一个已配置的超级块 分配mount实例</span><br><span class="line">    -&gt;    mp = lock_mount(mountpoint);  //寻找挂载点 如果挂载目录是挂载点（已经有文件系统挂载其上），则将最后一次挂载的文件系统根目录作为挂载点    </span><br><span class="line"> -&gt;  do_add_mount(real_mount(mnt), mp, mountpoint, mnt_flags);  //关联挂载点 加入全局文件系统树</span><br></pre></td></tr></table></figure>

<h3 id="4-2vfs-create-mount源码分析"><a href="#4-2vfs-create-mount源码分析" class="headerlink" title="4.2vfs_create_mount源码分析"></a><strong>4.2vfs_create_mount源码分析</strong></h3><figure class="highlight text"><table><tr><td class="code"><pre><span class="line">vfs_create_mount</span><br><span class="line">    -&gt;     mnt = alloc_vfsmnt(fc-&gt;source ?: &quot;none&quot;);  //分配mount实例 </span><br><span class="line">    -&gt;     mnt-&gt;mnt.mnt_sb         = fc-&gt;root-&gt;d_sb;  //mount关联超级块 (使用vfsmount关联)</span><br><span class="line">    -&gt;    mnt-&gt;mnt.mnt_root       = dget(fc-&gt;root);   //mount关联根dentry (使用vfsmount关联)</span><br><span class="line">    -&gt;    mnt-&gt;mnt_mountpoint     = mnt-&gt;mnt.mnt_root; // mount关联挂载点 （临时指向根dentry，后面会指向真正的挂载点，以至于对用户可见）</span><br><span class="line">    -&gt;  mnt-&gt;mnt_parent         = mnt;  //父挂载指向自己 (临时指向 后面会设置)              </span><br><span class="line">    -&gt;     return &amp;mnt-&gt;mnt;  //返回内嵌的vfsmount</span><br></pre></td></tr></table></figure>

<ul>
<li>注：老内核使用的是vfsmount来描述文件系统的一次挂载，现在内核都使用mount来描述，而vfsmount被内嵌到mount中，主要来描述文件系统的超级块和跟dentry。</li>
</ul>
<h4 id="4-2-1vfs-create-mount之后vfs对象数据结构之间关系图如下："><a href="#4-2-1vfs-create-mount之后vfs对象数据结构之间关系图如下：" class="headerlink" title="4.2.1vfs_create_mount之后vfs对象数据结构之间关系图如下："></a>4.2.1vfs_create_mount之后vfs对象数据结构之间关系图如下：</h4><p><img src="https://pic1.zhimg.com/80/v2-eb423661d85acf15649569f9c4e0d804_720w.webp" alt="img"></p>
<h3 id="4-3lock-mount源码分析"><a href="#4-3lock-mount源码分析" class="headerlink" title="4.3lock_mount源码分析"></a><strong>4.3lock_mount源码分析</strong></h3><p>lock_mount是最不好理解的函数，下面详细讲解：</p>
<p>-&gt; mp &#x3D; lock_mount(mountpoint);</p>
<p>&#x2F;&#x2F;不只是加锁， 通过传来的 挂载点的 path（vfsmout, dentry二元组)，来查找最后一次挂载的文件系统的根dentry作为即将挂载文件系统的挂载点</p>
<p>我们看下这个函数</p>
<p>-&gt; 这个函数主要从挂载点的path(即是挂载目录的path结构，如挂载到&#x2F;mnt下, path为mnt的path) 来找到真正的挂载点 两种情况：</p>
<p>1.如果挂载点的path 是正常的目录，原来不是挂载点，则直接返回这个目录的dentry作为挂载点（mountpoint的m_dentry会指向挂载点的dentry）</p>
<p>2.如果挂载点的path不是正常的目录，原来就是挂载点，说明这个目录已经有其他的文件系统挂载，那么它会查找最后一个挂载到这个目录的文件系统的根dentry,作为真正的挂载点。</p>
<p>我们打开这个黑匣子看一下：首先传递来的path 是一个表示要解析的挂载目录[vfsmount,dentry]二元组，如我们要挂载到 &#x2F;mnt （path即为&lt;mnt所在文件系统的vfsmount, mnt的dentry&gt;）</p>
<figure class="highlight text"><table><tr><td class="code"><pre><span class="line">//include/linux/path.h  描述一个路径</span><br><span class="line">struct path &#123; </span><br><span class="line">        struct vfsmount *mnt;</span><br><span class="line">        struct dentry *dentry;</span><br><span class="line">&#125; __randomize_layout;</span><br><span class="line"></span><br><span class="line"> //fs/mount.h       描述一个挂载点</span><br><span class="line">struct mountpoint &#123;       </span><br><span class="line">        struct hlist_node m_hash; </span><br><span class="line">        struct dentry *m_dentry;  </span><br><span class="line">        struct hlist_head m_list; </span><br><span class="line">        int m_count;              </span><br><span class="line">&#125;;                                </span><br><span class="line"></span><br><span class="line"></span><br><span class="line">static struct mountpoint *lock_mount(struct path *path)           </span><br><span class="line">&#123;                                                                 </span><br><span class="line">        struct vfsmount *mnt;                                     </span><br><span class="line">        struct dentry *dentry = path-&gt;dentry; //获得挂载目录的dentry                     </span><br><span class="line">retry:                                                            </span><br><span class="line">        inode_lock(dentry-&gt;d_inode);     //写方式申请 inode的读写信号量                        </span><br><span class="line">        if (unlikely(cant_mount(dentry))) &#123; //判断挂载目录能否被挂载</span><br><span class="line">                inode_unlock(dentry-&gt;d_inode);                    </span><br><span class="line">                return ERR_PTR(-ENOENT);                          </span><br><span class="line">        &#125;                                                         </span><br><span class="line">        namespace_lock();  //写方式申请 命名空间读写信号量                                      </span><br><span class="line">        mnt = lookup_mnt(path); //查找挂载在path上的第一个子mount    //！！！重点函数，后面分析 ！！！                               </span><br><span class="line">        if (likely(!mnt)) &#123; // mnt为空 说明没有文件系统挂载在这个path上  是我们要找的目标 </span><br><span class="line">    </span><br><span class="line">    //1.如果dentry之前是挂载点 则从mountpoint hash表 查找mountpoint （dentry计算hash）</span><br><span class="line">    // 2. 如果dentry之前不是挂载点 分配mountpoint 加入mountpoint hash表（dentry计算hash）,设置dentry为挂载点</span><br><span class="line">                struct mountpoint *mp = get_mountpoint(dentry); //！！！重点函数,后面会分析 ！！！</span><br><span class="line">      </span><br><span class="line">                if (IS_ERR(mp)) &#123;                                 </span><br><span class="line">                        namespace_unlock();                       </span><br><span class="line">                        inode_unlock(dentry-&gt;d_inode);            </span><br><span class="line">                        return mp;                                </span><br><span class="line">                &#125;                                                 </span><br><span class="line">                return mp; //返回找到的挂载点实例 （这个挂载点的dentry之前没有被挂载）                                      </span><br><span class="line">        &#125;</span><br><span class="line">        namespace_unlock(); //释放命名空间读写信号量</span><br><span class="line">        inode_unlock(path-&gt;dentry-&gt;d_inode); //释放 inode的读写信号量 </span><br><span class="line">        path_put(path);</span><br><span class="line">        path-&gt;mnt = mnt; // path-&gt;mnt指向找到的vfsmount                                          </span><br><span class="line">        dentry = path-&gt;dentry = dget(mnt-&gt;mnt_root); //path-&gt;dentry指向找到的vfsmount的根dentry！</span><br><span class="line">        goto retry; //继续查找下一个挂载</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="4-3-1get-mountpoint源码分析"><a href="#4-3-1get-mountpoint源码分析" class="headerlink" title="4.3.1get_mountpoint源码分析"></a><strong>4.3.1get_mountpoint源码分析</strong></h4><figure class="highlight text"><table><tr><td class="code"><pre><span class="line">static struct mountpoint *get_mountpoint(struct dentry *dentry)                      </span><br><span class="line">&#123;                                                                                    </span><br><span class="line">        struct mountpoint *mp, *new = NULL;                                          </span><br><span class="line">        int ret;                                                                     </span><br><span class="line">                                                                                     </span><br><span class="line">        if (d_mountpoint(dentry)) &#123;  //dentry为挂载点 （当dentry为挂载点时 会设置dentry-&gt;d_flags 的DCACHE_MOUNTED标志）                                                </span><br><span class="line">                /* might be worth a WARN_ON() */                                     </span><br><span class="line">                if (d_unlinked(dentry))                                              </span><br><span class="line">                        return ERR_PTR(-ENOENT);                                     </span><br><span class="line">mountpoint:                                                                          </span><br><span class="line">                read_seqlock_excl(&amp;mount_lock);                                      </span><br><span class="line">                mp = lookup_mountpoint(dentry); // 从mountpoint hash表 查找mountpoint （dentry计算hash）                                    </span><br><span class="line">                read_sequnlock_excl(&amp;mount_lock);                                    </span><br><span class="line">                if (mp)                                                              </span><br><span class="line">                        goto done;  //找到直接返回mountpoint实例                                               </span><br><span class="line">        &#125;                                                                            </span><br><span class="line">                                                                                     </span><br><span class="line">        if (!new)    //mountpoint哈希表中没有找到    则分配                                                             </span><br><span class="line">                new = kmalloc(sizeof(struct mountpoint), GFP_KERNEL);             </span><br><span class="line">        if (!new)                                                                    </span><br><span class="line">                return ERR_PTR(-ENOMEM);                                             </span><br><span class="line">                                                                                     </span><br><span class="line">                                                                                     </span><br><span class="line">        /* Exactly one processes may set d_mounted */                                </span><br><span class="line">        ret = d_set_mounted(dentry);   //设置dentry为挂载点</span><br><span class="line">   -&gt;dentry-&gt;d_flags |= DCACHE_MOUNTED;  //设置挂载点标志很重要  路径名查找时发现为挂载点则会步进到相关文件系统的跟dentry</span><br><span class="line">                                                                                     </span><br><span class="line">        /* Someone else set d_mounted? */                                            </span><br><span class="line">        if (ret == -EBUSY)                                                           </span><br><span class="line">                goto mountpoint;                                                     </span><br><span class="line">                                                                                     </span><br><span class="line">        /* The dentry is not available as a mountpoint? */                           </span><br><span class="line">        mp = ERR_PTR(ret);                                                           </span><br><span class="line">        if (ret)                                                                     </span><br><span class="line">                goto done;                                                           </span><br><span class="line">                                                              </span><br><span class="line">        /* Add the new mountpoint to the hash table */        </span><br><span class="line">        read_seqlock_excl(&amp;mount_lock);                       </span><br><span class="line">        new-&gt;m_dentry = dget(dentry);  //设置mountpoint实例  的m_dentry 指向dentry                       </span><br><span class="line">        new-&gt;m_count = 1;                                      </span><br><span class="line">        hlist_add_head(&amp;new-&gt;m_hash, mp_hash(dentry));   // mountpoint实例添加到 mountpoint_hashtable     </span><br><span class="line">        INIT_HLIST_HEAD(&amp;new-&gt;m_list);  //初始化 挂载链表   mount实例会加入到这个链表                      </span><br><span class="line">        read_sequnlock_excl(&amp;mount_lock);                     </span><br><span class="line">                                                              </span><br><span class="line">        mp = new;   //指向挂载点                                          </span><br><span class="line">        new = NULL;                                           </span><br><span class="line">done:                                                         </span><br><span class="line">        kfree(new);                                           </span><br><span class="line">        return mp;  //返回挂载点                                           </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="4-3-2lookup-mnt源码分析"><a href="#4-3-2lookup-mnt源码分析" class="headerlink" title="4.3.2lookup_mnt源码分析"></a><strong>4.3.2lookup_mnt源码分析</strong></h4><p>它在文件系统挂载和路径名查找都会使用到，作用为查找挂载在这个path下的第一个子vfsmount实例。</p>
<p>-&gt;文件系统挂载场景中，使用它查找合适的vfsmount实例作为父vfsmount。</p>
<p>-&gt;路径名查找场景中，使用它查找一个合适的vfsmount实例作为下一级路径名解析起点的vfsmount。</p>
<figure class="highlight text"><table><tr><td class="code"><pre><span class="line">//fs/namespace.c</span><br><span class="line">lookup_mnt(const struct path *path)</span><br><span class="line">-&gt;  struct mount *child_mnt;</span><br><span class="line"> struct vfsmount *m;     </span><br><span class="line"> child_mnt = __lookup_mnt(path-&gt;mnt, path-&gt;dentry);  //委托__lookup_mnt</span><br><span class="line"> m = child_mnt ? &amp;child_mnt-&gt;mnt : NULL; //返回mount实例的vfsmount实例 或NULL            </span><br><span class="line"> return m;</span><br><span class="line"></span><br><span class="line">-&gt;</span><br><span class="line">struct mount *__lookup_mnt(struct vfsmount *mnt, struct dentry *dentry)        </span><br><span class="line">&#123;               </span><br><span class="line">        struct hlist_head *head = m_hash(mnt, dentry);  // 根据 父vfsmount实例 和 挂载点的dentry查找  mount_hashtable的一个哈希表项</span><br><span class="line">        struct mount *p;</span><br><span class="line">        </span><br><span class="line">        hlist_for_each_entry_rcu(p, head, mnt_hash)  //从哈希表项对应的链表中查找   遍历链表的每个节点</span><br><span class="line">                if (&amp;p-&gt;mnt_parent-&gt;mnt == mnt &amp;&amp; p-&gt;mnt_mountpoint == dentry) //节点的mount实例的父mount为mnt 且mount实例的挂载点为 dentry</span><br><span class="line">                        return p; //找到返回mount实例</span><br><span class="line">        return NULL;  //没找到返回NULL</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="4-3-3lock-mount情景分析"><a href="#4-3-3lock-mount情景分析" class="headerlink" title="4.3.3lock_mount情景分析"></a><strong>4.3.3lock_mount情景分析</strong></h4><p>1)lock_mount传递的path 之前不是挂载点：</p>
<p>调用链为：</p>
<blockquote>
<p>lock_mount<br>-&gt;mnt &#x3D; lookup_mnt(path) &#x2F;&#x2F;没有子mount 返回NULL<br>-&gt;mp &#x3D; get_mountpoint(dentry) &#x2F;&#x2F;分配mountpoint 加入mountpoint hash表（dentry计算hash）,设置dentry为挂载点<br>-&gt;return mp &#x2F;&#x2F;返回找到的挂载点实例</p>
</blockquote>
<p>2)lock_mount传递的path 之前是挂载点：我们现在执行 mount -t ext2 &#x2F;dev&#x2F;sda4 &#x2F;mnt</p>
<p>之前 &#x2F;mnt的挂载情况</p>
<blockquote>
<p>mount &#x2F;dev&#x2F;sda1 &#x2F;mnt （1）<br>mount &#x2F;dev&#x2F;sda2 &#x2F;mnt （2）<br>mount &#x2F;dev&#x2F;sda3 &#x2F;mnt （3）</p>
</blockquote>
<p>调用链为：</p>
<blockquote>
<p>lock_mount<br>-&gt;mnt &#x3D; lookup_mnt(path) &#x2F;&#x2F;返回（1）的mount实例<br>-&gt;path-&gt;mnt &#x3D; mnt &#x2F;&#x2F;下一次查找的 path-&gt;mnt赋值（1）的mount实例<br>-&gt;dentry &#x3D; path-&gt;dentry &#x3D; dget(mnt-&gt;mnt_root) &#x2F;&#x2F; &#x2F;&#x2F;下一次查找path-&gt;dentry 赋值（1）的根dentry</p>
</blockquote>
<blockquote>
<p>-&gt;mnt &#x3D; lookup_mnt(path) &#x2F;&#x2F;返回（2）的mount实例<br>-&gt;path-&gt;mnt &#x3D; mnt &#x2F;&#x2F;下一次查找的 path-&gt;mnt赋值（2）的mount实例<br>-&gt;dentry &#x3D; path-&gt;dentry &#x3D; dget(mnt-&gt;mnt_root) &#x2F;&#x2F; &#x2F;&#x2F;下一次查找path-&gt;dentry 赋值（2）的根dentry</p>
<p>-&gt;mnt &#x3D; lookup_mnt(path) &#x2F;&#x2F;返回（3）的mount实例</p>
</blockquote>
<blockquote>
<p>-&gt;path-&gt;mnt &#x3D; mnt &#x2F;&#x2F;下一次查找的 path-&gt;mnt赋值（3）的mount实例<br>-&gt;dentry &#x3D; path-&gt;dentry &#x3D; dget(mnt-&gt;mnt_root) &#x2F;&#x2F; &#x2F;&#x2F;下一次查找path-&gt;dentry 赋值（3）的根dentry<br>-&gt; mnt &#x3D; lookup_mnt(path) &#x2F;&#x2F;没有子mount 返回NULL<br>-&gt;mp &#x3D; get_mountpoint(dentry) &#x2F;&#x2F;分配mountpoint 加入mountpoint hash表（dentry计算hash）,设置dentry为挂载点（（3）的根dentry作为挂载点）</p>
</blockquote>
<blockquote>
<p>-&gt;return mp &#x2F;&#x2F;返回找到的挂载点实例(也就是最后一次挂载（3） 文件系统的根dentry)</p>
</blockquote>
<h4 id="4-3-4do-add-mount源码分析"><a href="#4-3-4do-add-mount源码分析" class="headerlink" title="4.3.4do_add_mount源码分析"></a><strong>4.3.4do_add_mount源码分析</strong></h4><p>准备好了挂载点之后，接下来子mount实例关联挂载点以及添加子mount实例到全局的文件系统挂载树中。</p>
<figure class="highlight text"><table><tr><td class="code"><pre><span class="line">do_add_mount  //添加mount到全局的文件系统挂载树中</span><br><span class="line">-&gt;struct mount *parent = real_mount(path-&gt;mnt); //获得父挂载点的挂载实例</span><br><span class="line">-&gt;graft_tree(newmnt, parent, mp)</span><br><span class="line"> -&gt; mnt_set_mountpoint(dest_mnt, dest_mp, source_mnt)</span><br><span class="line">  -&gt;   child_mnt-&gt;mnt_mountpoint = mp-&gt;m_dentry;   //关联子mount到挂载点的dentry                 </span><br><span class="line">    child_mnt-&gt;mnt_parent = mnt; //子mount-&gt;mnt_parent指向父mount</span><br><span class="line">    child_mnt-&gt;mnt_mp = mp; //子mount-&gt;mnt_mp指向挂载点</span><br><span class="line">    hlist_add_head(&amp;child_mnt-&gt;mnt_mp_list, &amp;mp-&gt;m_list); //mount添加到挂载点链表</span><br><span class="line"></span><br><span class="line"> -&gt;commit_tree //提交挂载树</span><br><span class="line">  -&gt;__attach_mnt(mnt, parent)</span><br><span class="line">   -&gt;  hlist_add_head_rcu(&amp;mnt-&gt;mnt_hash,</span><br><span class="line">       ¦  m_hash(&amp;parent-&gt;mnt, mnt-&gt;mnt_mountpoint));  //添加到mount hash表 ，通过父挂载点的vfsmount和挂载点的dentry作为索引(如上面示例中的&lt;(3)的vfsmount , (3)的根dentry&gt;)</span><br><span class="line">    list_add_tail(&amp;mnt-&gt;mnt_child, &amp;parent-&gt;mnt_mounts);  //添加到父mount链表</span><br></pre></td></tr></table></figure>

<p>上面说了一大堆，主要为了实现：</p>
<p><strong>将mount实例与挂载点联系起来（会将mount实例加入到mount 哈希表，父文件系统的vfsmount和真正的挂载点的dentry组成的二元组为索引，路径名查找时便于查找），以及mount实例与文件系统的跟dentry联系起来（路径名查找的时候便于沿着跟dentry来访问这个文件系统的所有文件）。</strong></p>
<h4 id="4-3-5do-add-mount-之后vfs对象数据结构之间关系图（-mnt之前不是挂载点情况）如下："><a href="#4-3-5do-add-mount-之后vfs对象数据结构之间关系图（-mnt之前不是挂载点情况）如下：" class="headerlink" title="4.3.5do_add_mount 之后vfs对象数据结构之间关系图（&#x2F;mnt之前不是挂载点情况）如下："></a>4.3.5do_add_mount 之后vfs对象数据结构之间关系图（&#x2F;mnt之前不是挂载点情况）如下：</h4><p><img src="https://pic1.zhimg.com/80/v2-72f3ca5ef905b57826560d45046eab94_720w.webp" alt="img"></p>
<h2 id="5、mount的应用"><a href="#5、mount的应用" class="headerlink" title="5、mount的应用"></a><strong>5、mount的应用</strong></h2><ul>
<li>上面几章我们分析了文件系统挂载的主要流程，创建并关联了各个vfs的对象，为了打开文件等路径名查找时做准备。</li>
</ul>
<h3 id="5-1路径名查找到挂载点源码分析"><a href="#5-1路径名查找到挂载点源码分析" class="headerlink" title="5.1路径名查找到挂载点源码分析"></a><strong>5.1路径名查找到挂载点源码分析</strong></h3><figure class="highlight text"><table><tr><td class="code"><pre><span class="line">//fs/namei.c 查找一个路径分量</span><br><span class="line">walk_component  </span><br><span class="line">-&gt;step_into</span><br><span class="line"> -&gt;handle_mounts</span><br><span class="line">  -&gt;traverse_mounts</span><br><span class="line">   -&gt;flags = smp_load_acquire(&amp;path-&gt;dentry-&gt;d_flags); //获得dentry标志</span><br><span class="line">   -&gt;__traverse_mounts(path, flags, jumped, count, lookup_flags); //查找挂载点  返回不再是挂载点的path</span><br><span class="line">     -&gt; &#123;</span><br><span class="line">     </span><br><span class="line">       while (flags &amp; DCACHE_MANAGED_DENTRY) &#123;    //找到的dentry是挂载点 则继续查找 ，不是则退出循环</span><br><span class="line">        ...</span><br><span class="line">        if (flags &amp; DCACHE_MOUNTED) &#123;   // something&#x27;s mounted on it..  是挂载点 和上面lock_mount分析逻辑类似 </span><br><span class="line">         //不断的查找挂载点  直到最后查找到的dentry不是挂载点 退出循环</span><br><span class="line">         struct vfsmount *mounted = lookup_mnt(path);  //查找第一个子mount          </span><br><span class="line">         if (mounted) &#123;          // ... in our namespace         </span><br><span class="line">           dput(path-&gt;dentry);                            </span><br><span class="line">           if (need_mntput)</span><br><span class="line">             mntput(path-&gt;mnt);</span><br><span class="line">           path-&gt;mnt = mounted; //path-&gt;mnt赋值子mount</span><br><span class="line">           path-&gt;dentry = dget(mounted-&gt;mnt_root); //path-&gt;dentry 赋值子mount的根dentry （是挂载点就会步进到挂载点的跟dentry）</span><br><span class="line">           // here we know it&#x27;s positive</span><br><span class="line">           flags = path-&gt;dentry-&gt;d_flags; //获得dentry标志</span><br><span class="line">           need_mntput = true;</span><br><span class="line">           continue; //继续查找</span><br><span class="line">        &#125;</span><br><span class="line">        ...</span><br><span class="line"></span><br><span class="line">       &#125;</span><br><span class="line">       </span><br><span class="line">       //最终返回找到的path（它不再是挂载点），后面继续查找下一个路径</span><br><span class="line">      &#125;</span><br></pre></td></tr></table></figure>

<h3 id="5-2举例说明"><a href="#5-2举例说明" class="headerlink" title="5.2举例说明"></a><strong>5.2举例说明</strong></h3><blockquote>
<p>我们做以下的路径名查找：&#x2F;mnt&#x2F;test&#x2F;text.txt<br>&#x2F;mnt&#x2F; 目录挂载情况为<br>mount &#x2F;dev&#x2F;sda1 &#x2F;mnt （1）<br>mount &#x2F;dev&#x2F;sda2 &#x2F;mnt （2）</p>
</blockquote>
<blockquote>
<p>mount &#x2F;dev&#x2F;sda3 &#x2F;mnt （3）<br>test&#x2F;text.txt文件在 &#x2F;dev&#x2F;sda3 上</p>
</blockquote>
<p>则路径名查找时，查找到mnt的dentry发现它是挂载点，就会依次查找（1）的根目录-&gt;（2）的根目录 -&gt;（3）的根目录， 最终将（3）的vfsmount和 根目录的dentry 填写到path，进行下一步的查找, 最终查找到&#x2F;dev&#x2F;sda3 上的text.txt文件。</p>
<p>注：一个目录被文件系统挂载时，原来目录中包含的其他子目录或文件会被隐藏。</p>
<h2 id="6、挂载图解"><a href="#6、挂载图解" class="headerlink" title="6、挂载图解"></a><strong>6、挂载图解</strong></h2><p>为了便于讲解图示中各个实例表示如下：</p>
<blockquote>
<p>Xyn —&gt; X表示哪个实例对象 如：mount实例使用M表示（第一个大小字母） dentry使用D表示 inode使用I表示 super_block用S表示 vfsmount使用V表示<br>y表示是父文件系统中的实例对象还是子文件系统中 如：p（parent）表示父文件系统中实例对象 c（child）表示子文件系统中实例对象<br>n 区分同一种对象的不同实例<br>例如：Dc1 表示子文件系统中一个dentry对象</p>
</blockquote>
<h3 id="6-1mount、super-block、file-system-type三者关系图解"><a href="#6-1mount、super-block、file-system-type三者关系图解" class="headerlink" title="6.1mount、super_block、file_system_type三者关系图解"></a><strong>6.1mount、super_block、file_system_type三者关系图解</strong></h3><p><img src="https://pic1.zhimg.com/80/v2-095bb1781dfa095aae41172484c23e3c_720w.webp" alt="img"></p>
<p>解释：mount实例、super_block实例、file_system_type实例三种层级逐渐升高，即一个file_system_type实例会包含多个super_block实例，一个super_block实例会包含多个mount实例。一种file_system_type必须先被注册到系统中来宣誓这种文件系统存在，主要提供此类文件系统的挂载和卸载方法等，注册即是加入全局的file_systems链表，等到有块设备上的文件系统要挂载时就会根据挂载时传递的文件系统类型名查找file_system_type实例，如果查找到，就会调用它的挂载方法进行挂载。首先，在file_systems实例的super_block链表中查找有没有super_block实例已经被创建，如果有就不需要从磁盘读取（这就是一个块设备上的文件系统挂载到多个目录上只有一个super_block实例的原因），如果没有从磁盘读取并加入对应的file_systems实例的super_block链表。而每次挂载都会创建一个mount实例来联系挂载点和super_block实例，并以（父vfsmount,挂载点dentry）为索引加入到全局mount哈希表，便于后面访问这个挂载点的文件系统时的路径名查找。</p>
<h3 id="6-2父子文件系统挂载关系图解"><a href="#6-2父子文件系统挂载关系图解" class="headerlink" title="6.2父子文件系统挂载关系图解"></a><strong>6.2父子文件系统挂载关系图解</strong></h3><p><img src="https://pic4.zhimg.com/80/v2-c88da59ea00bb451ddceb1cbf060d59f_720w.webp" alt="img"></p>
<p>解释：图中&#x2F;dev&#x2F;sda1中的子文件系统挂载到父文件系统的&#x2F;mnt目录下。当挂载的时候会创建mount、super_block、跟inode、跟dentry四大数据结构并建立相互关系，将子文件系统的mount加入到(Vp, Dp3)二元组为索引的mount哈希表中，通过设置mnt的目录项（Dp3）的DCACHE_MOUNTED来将其标记为挂载点，并与父文件系统建立亲缘关系挂载就完成了。</p>
<p>当需要访问子文件系统中的某个文件时，就会通过路径名各个分量解析到mnt目录，发现其为挂载点，就会通过(Vp, Dp3)二元组在mount哈希表中找到子文件系统的mount实例(Mc),然后就会从子文件系统的跟dentry（Dc1）开始往下继续查找，最终访问到子文件系统上的文件。</p>
<h3 id="6-3单个文件系统多挂载点关系图解"><a href="#6-3单个文件系统多挂载点关系图解" class="headerlink" title="6.3单个文件系统多挂载点关系图解"></a><strong>6.3单个文件系统多挂载点关系图解</strong></h3><p><img src="https://pic1.zhimg.com/80/v2-8a4deddc3f1722a73f4d113b7d64ead8_720w.webp" alt="img"></p>
<p>解释：图中将&#x2F;dev&#x2F;sda1中的文件系统分别挂载到父文件系统的&#x2F;mnt&#x2F;a和&#x2F;mnt&#x2F;b目录下。当第一次挂载到&#x2F;mnt&#x2F;a时，会创建mount、super_block、跟inode、跟dentry四大数据结构(分别对应与Mc1、Sc、Dc1、Ic)并建立相互关系，将子文件系统的Mc1加入到(Vp, Dp3)二元组为索引的mount哈希表中，通过设置&#x2F;mnt&#x2F;a的目录项的DCACHE_MOUNTED来将其标记为挂载点，并与父文件系统建立亲缘关系挂载就完成了。然后挂载到&#x2F;mnt&#x2F;b时, Sc、Dc1、Ic已经创建好不需要再创建，内存中只会有一份，会创建Mc2来关联super_block和第二次的挂载点，建立这几个数据结构关系，将子文件系统的Mc2加入到(Vp, Dp4)二元组为索引的mount哈希表中，通过设置&#x2F;mnt&#x2F;b的目录项的DCACHE_MOUNTED来将其标记为挂载点，并与父文件系统建立亲缘关系挂载就完成了。</p>
<p>当需要访问子文件系统中的某个文件时，就会通过路径名各个分量解析到&#x2F;mnt&#x2F;a目录，发现其为挂载点，就会通过(Vp, Dp3)在mount哈希表中找到子文件系统的Mc1,然后就会从子文件系统的Dc1开始往下继续查找，最终访问到子文件系统上的文件。同样，如果解析到&#x2F;mnt&#x2F;b目录,发现其为挂载点，就会通过(Vp, Dp4)在mount哈希表中找到子文件系统的Mc2,然后就会从子文件系统的Dc1开始往下继续查找，最终访问到子文件系统上的文件。可以发现，同一个块设备上的文件系统挂载到不同的目录上，相关联的super_block和跟dentry是一样的，这保证了无论从哪个挂载点开始路径名查找都访问到的是同一个文件系统上的文件。</p>
<h3 id="6-4多文件系统单挂载点关系图解"><a href="#6-4多文件系统单挂载点关系图解" class="headerlink" title="6.4多文件系统单挂载点关系图解"></a><strong>6.4多文件系统单挂载点关系图解</strong></h3><p><img src="https://pic4.zhimg.com/80/v2-03e69e56d7942f240dad3df406131303_720w.webp" alt="img"></p>
<p>解释：最后我们来看多文件系统单挂载点的情况，图中先将块设备&#x2F;dev&#x2F;sda1中的子文件系统1挂载到&#x2F;mnt目录，然后再将块设备&#x2F;dev&#x2F;sdb1中的子文件系统2挂载到&#x2F;mnt目录上。</p>
<p>当子文件系统1挂载的时候，会创建mount、super_block、跟inode、跟dentry四大数据结构(分别对应与Mc1、Sc1、Dc1、Ic1)并建立相互关系，将子文件系统的Mc1加入到(Vp, Dp3)二元组为索引的mount哈希表中，通过设置&#x2F;mnt的目录项的DCACHE_MOUNTED来将其标记为挂载点，并与父文件系统建立亲缘关系挂载就完成了。</p>
<p>当子文件系统2挂载的时候，会创建mount、super_block、跟inode、跟dentry四大数据结构(分别对应与Mc2、Sc2、Dc4、Ic2)并建立相互关系，这个时候会发现&#x2F;mnt目录是挂载点，则会将子文件系统1的根目录（Dc1）作为文件系统2的挂载点，将子文件系统的Mc2加入到(Vc1, Dc1)二元组为索引的mount哈希表中，通过设置Dc1的DCACHE_MOUNTED来将其标记为挂载点，并与父文件系统建立亲缘关系挂载就完成了。</p>
<p>这个时候，子文件系统1已经被子文件系统2隐藏起来了，当路径名查找到&#x2F;mnt目录时，发现其为挂载点，则通过(Vp, Dp3)二元组为索引在mount哈希表中找到Mc1，会转向文件系统1的跟目录（Dc1）开始往下继续查找，发现Dc1也是挂载点，则(通过Vc1, Dc1)二元组为索引在mount哈希表中找到Mc2, 会转向文件系统1的跟目录（Dc4）开始往下继续查找，于是就访问到了文件系统2中的文件。除非，文件系统2被卸载，文件系统1的跟dentry（Dc1）不再是挂载点，这个时候文件系统1中的文件才能再次被访问到。</p>
<h2 id="7、总结"><a href="#7、总结" class="headerlink" title="7、总结"></a><strong>7、总结</strong></h2><p>Linux中，块设备上的文件系统只有挂载到内存的目录树中的一个目录下，用户进程才能访问，而挂载是创建数据结构关联块设备上的文件系统和挂载点，使得路径名查找的时候能够通过挂载点目录访问到挂载在其下的文件系统。</p>
<h3 id="7-1挂载主要步骤"><a href="#7-1挂载主要步骤" class="headerlink" title="7.1挂载主要步骤"></a><strong>7.1挂载主要步骤</strong></h3><p>1.vfs_get_tree 调用具体文件系统的获取填充超级块方法(fs_context_operations.get_tree或者file_system_type.mount)， 在内存构建super_block，然后构建根inode和根dentry(磁盘文件系统可能需要从磁盘读取磁盘超级块构建内存的super_block，从磁盘读取根inode构建内存的inode)。2.do_new_mount_fc 对于每次挂载都会分配mount实例，用于关联挂载点到文件系统。当一个要挂载的目录不是挂载点，会设置这个目录的dentry为挂载点，然后mount实例记录这个挂载点。当一个要挂载的目录是挂载点（之前已经有文件系统被挂载到这个目录），那么新挂载的文件系统将挂载到这个目录最后一次挂载的文件系统的根dentry,之前挂载的文件系统的文件都被隐藏（当子挂载被卸载，原来的文件系统的文件才可见）。</p>
<h3 id="7-2文件系统的用户可见性"><a href="#7-2文件系统的用户可见性" class="headerlink" title="7.2文件系统的用户可见性"></a><strong>7.2文件系统的用户可见性</strong></h3><p><strong>只对内核内部可见：</strong>不需要将文件系统关联到一个挂载点，内核通过文件系统的super_block等结构即可访问到文件系统的文件（如bdev，sockfs）。</p>
<p><strong>对于用户可见：</strong>需要将文件系统关联到一个挂载点，就需要通过给定的挂载点目录名找到真正的挂载点，然后进行挂载操作， 挂载的实质是：通过mount实例的mnt_mountpoint关联真正的挂载点dentry,然后建立父mount关系，mount实例加入到全局的mount hash table（通过父vfsmount和真正的挂载点dentry作为hash索引），然后用户打开文件的时候通过路径名查找解析各个目录分量，当发现一个目录是挂载点时，就会步进到最后一次挂载到这个目录的文件系统的根dentry中继续查找，知道根dentry就可以继续查找到这个文件系统的任何文件。</p>
<h3 id="7-3几条重要规律"><a href="#7-3几条重要规律" class="headerlink" title="7.3几条重要规律"></a><strong>7.3几条重要规律</strong></h3><p>1）文件系统被挂载后都会有以下几大vfs对象被创建：</p>
<p>super_block<br>mount</p>
<p>根inode</p>
<p>根dentry</p>
<p>注：其中mount为纯软件构造的对象（内嵌vfsmount对象），其他对象视文件系统类型，可能涉及到磁盘操作。</p>
<p>super_block 超级块实例，描述一个文件系统的信息，有的需要磁盘读取在内存中填充来构建（如磁盘文件系统），有的直接内存中填充来构建。</p>
<p>mount 挂载实例，描述一个文件系统的一次挂载，主要关联一个文件系统到挂载点，为路径名查找做重要准备工作。</p>
<p>根inode 每个文件系统都会有根inode，有的需要磁盘读取在内存中填充来构建（如磁盘文件系统，根inode号已知），有的直接内存中填充来构建。</p>
<p>根dentry 每个文件系统都会有根dentry，根据根inode来构建，路径名查找时会步进到文件系统的根dentry来访问这个文件系统的文件。</p>
<p>2）一个目录可以被多个文件系统挂载。第一次挂载是直接挂载这个目录上，新挂载的文件系统实际上是挂载在上一个文件系统的根dentry上。</p>
<p>3）一个目录被多个文件系统挂载时，新挂载导致之前的挂载被隐藏。</p>
<p>4）一个目录被文件系统挂载时，原来目录中包含的其他子目录或文件被隐藏。</p>
<p>5）每次挂载都会有一个mount实例描述本次挂载。</p>
<p>6）一个快设备上的文件系统可以被挂载到多个目录，有多个mount实例，但是只会有一个super_block、根dentry 和根inode。</p>
<p>7）mount实例用于关联挂载点dentry和文件系统，起到路径名查找时“路由”的作用。</p>
<p>8）挂载一个文件系统必须保证所要挂载的文件系统类型已经被注册。</p>
<p>9）挂载时会查询文件系统类型的fs_type-&gt;fs_supers链表，检查是否已经有super_block被加入链表，如果没有才会分配并读磁盘超级块填充。</p>
<p>10）对象层次：一个fs_type-&gt;fs_supers链表可以挂接属于同一个文件系统的被挂载的超级块，超级块链表可以挂接属于同一个超级块的mount实例 fs_type -&gt; super_block -&gt; mount 从高到低的包含层次。</p>
<hr>
<p>版权声明：本文为知乎博主「Linux内核库」的原创文章，遵循CC 4.0 BY-SA版权协议，转载请附上原文 出处链接及本声明。 </p>
<p>原文链接：<a href="https://zhuanlan.zhihu.com/p/515769749">https://zhuanlan.zhihu.com/p/515769749</a></p>
]]></content>
      <categories>
        <category>linux-doc 文件系统</category>
      </categories>
      <tags>
        <tag>Linux</tag>
      </tags>
  </entry>
  <entry>
    <title>Linux内核文件系统知识大总结</title>
    <url>/2023/01/15/linux-docs/%E6%96%87%E4%BB%B6%E7%B3%BB%E7%BB%9F/Linux%E5%86%85%E6%A0%B8%E6%96%87%E4%BB%B6%E7%B3%BB%E7%BB%9F%E7%9F%A5%E8%AF%86%E5%A4%A7%E6%80%BB%E7%BB%93/</url>
    <content><![CDATA[<h2 id="1、文件系统特点"><a href="#1、文件系统特点" class="headerlink" title="1、文件系统特点"></a>1、文件系统特点</h2><ul>
<li>文件系统要有严格的组织形式，使得文件能够以块为单位进行存储。</li>
<li>文件系统中也要有索引区，用来方便查找一个文件分成的多个块都存放在了什么位置。</li>
<li>如果文件系统中有的文件是热点文件，近期经常被读取和写入，文件系统应该有缓存层。</li>
<li>文件应该用文件夹的形式组织起来，方便管理和查询。</li>
<li>Linux内核要在自己的内存里面维护一套数据结构，来保存哪些文件被哪些进程打开和使用。</li>
</ul>
<p><strong>总体来说，文件系统的主要功能梳理如下：</strong></p>
<p><img src="https://pic1.zhimg.com/80/v2-ccf126ff97d88b7191916f24af531368_720w.webp" alt="img"></p>
<h2 id="2、EXT系列的文件系统的格式"><a href="#2、EXT系列的文件系统的格式" class="headerlink" title="2、EXT系列的文件系统的格式"></a>2、EXT系列的文件系统的格式</h2><h3 id="2-1-inode与块的存储"><a href="#2-1-inode与块的存储" class="headerlink" title="2.1,inode与块的存储"></a><strong>2.1,inode与块的存储</strong></h3><p>硬盘分成相同大小的单元，我们称为块（Block）。一块的大小是扇区大小的整数倍，默认是4K。在格式化的时候，这个值是可以设定的。</p>
<p>一大块硬盘被分成了一个个小的块，用来存放文件的数据部分。这样一来，如果我们像存放一个文件，就不用给他分配一块连续的空间了。我们可以分散成一个个小块进行存放。这样就灵活得多，也比较容易添加、删除和插入数据。</p>
<p>inode就是文件索引的意思，我们每个文件都会对应一个inode；一个文件夹就是一个文件，也对应一个inode。</p>
<p><strong>inode数据结构如下：</strong></p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">struct</span> <span class="title class_">ext4_inode</span> &#123;</span><br><span class="line">    __le16  i_mode;     <span class="comment">/* File mode */</span></span><br><span class="line">    __le16  i_uid;      <span class="comment">/* Low 16 bits of Owner Uid */</span></span><br><span class="line">    __le32  i_size_lo;  <span class="comment">/* Size in bytes */</span></span><br><span class="line">    __le32  i_atime;    <span class="comment">/* Access time */</span></span><br><span class="line">    __le32  i_ctime;    <span class="comment">/* Inode Change time */</span></span><br><span class="line">    __le32  i_mtime;    <span class="comment">/* Modification time */</span></span><br><span class="line">    __le32  i_dtime;    <span class="comment">/* Deletion Time */</span></span><br><span class="line">    __le16  i_gid;      <span class="comment">/* Low 16 bits of Group Id */</span></span><br><span class="line">    __le16  i_links_count;  <span class="comment">/* Links count */</span></span><br><span class="line">    __le32  i_blocks_lo;    <span class="comment">/* Blocks count */</span></span><br><span class="line">    __le32  i_flags;    <span class="comment">/* File flags */</span></span><br><span class="line">......</span><br><span class="line">    __le32  i_block[EXT4_N_BLOCKS];<span class="comment">/* Pointers to blocks */</span></span><br><span class="line">    __le32  i_generation;   <span class="comment">/* File version (for NFS) */</span></span><br><span class="line">    __le32  i_file_acl_lo;  <span class="comment">/* File ACL */</span></span><br><span class="line">    __le32  i_size_high;</span><br><span class="line">......</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>inode里面有文件的读写权限i_mode，属于哪个用户i_uid，哪个组i_gid，大小是多少i_size_io，占用多少个块i_blocks_io，i_atime是access time，是最近一次访问文件的时间；i_ctime是change time，是最近一次更改inode的时间；i_mtime是modify time，是最近一次更改文件的时间等。</p>
<p><strong>所有的文件都是保存在i_block里面。具体保存规则由EXT4_N_BLOCKS决定，EXT4_N_BLOCKS有如下的定义：</strong></p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">define</span>    EXT4_NDIR_BLOCKS        12</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span>    EXT4_IND_BLOCK          EXT4_NDIR_BLOCKS</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span>    EXT4_DIND_BLOCK         (EXT4_IND_BLOCK + 1)</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span>    EXT4_TIND_BLOCK         (EXT4_DIND_BLOCK + 1)</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span>    EXT4_N_BLOCKS           (EXT4_TIND_BLOCK + 1)</span></span><br></pre></td></tr></table></figure>

<p><strong>在ext2和ext3中，其中前12项直接保存了块的位置，也就是说，我们可以通过i_block[0-11]，直接得到保存文件内容的块。</strong></p>
<p><img src="https://pic1.zhimg.com/80/v2-ffeacc008d1094a93c783a3ea6a42274_720w.webp" alt="img"></p>
<p>但是，如果一个文件比较大，12块放不下。当我们用到i_block[12]的时候，就不能直接放数据块的位置了，要不然i_block很快就会用完了。</p>
<p>那么可以让i_block[12]指向一个块，这个块里面不放数据块，而是放数据块的位置，这个块我们称为间接块。如果文件再大一些，i_block[13]会指向一个块，我们可以用二次间接块。二次间接块里面存放了间接块的位置，间接块里面存放了数据块的位置，数据块里面存放的是真正的数据。如果文件再大点，那么i_block[14]同理。</p>
<p>这里面有一个非常显著的问题，对于大文件来讲，我们要多次读取硬盘才能找到相应的块，这样访问速度就会比较慢。</p>
<p>为了解决这个问题，ext4做了一定的改变。它引入了一个新的概念，叫作Extents。比方说，一个文件大小为128M，如果使用4k大小的块进行存储，需要32k个块。如果按照ext2或者ext3那样散着放，数量太大了。但是Extents可以用于存放连续的块，也就是说，我们可以把128M放在一个Extents里面。这样的话，对大文件的读写性能提高了，文件碎片也减少了。</p>
<h3 id="2-2-Exents是一个树状结构："><a href="#2-2-Exents是一个树状结构：" class="headerlink" title="2.2,Exents是一个树状结构："></a><strong>2.2,Exents是一个树状结构：</strong></h3><p><img src="https://pic4.zhimg.com/80/v2-c179f68c3533a3ea3ac91f07618a2953_720w.webp" alt="img"></p>
<p><strong>每个节点都有一个头，ext4_extent_header可以用来描述某个节点：</strong></p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">struct</span> <span class="title class_">ext4_extent_header</span> &#123;</span><br><span class="line">    __le16  eh_magic;   <span class="comment">/* probably will support different formats */</span></span><br><span class="line">    __le16  eh_entries; <span class="comment">/* number of valid entries */</span></span><br><span class="line">    __le16  eh_max;     <span class="comment">/* capacity of store in entries */</span></span><br><span class="line">    __le16  eh_depth;   <span class="comment">/* has tree real underlying blocks? */</span></span><br><span class="line">    __le32  eh_generation;  <span class="comment">/* generation of the tree */</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>eh_entries表示这个节点里面有多少项。这里的项分两种，如果是叶子节点，这一项会直接指向硬盘上的连续块的地址，我们称为数据节点ext4_extent；如果是分支节点，这一项会指向下一层的分支节点或者叶子节点，我们称为索引节点ext4_extent_idx。这两种类型的项的大小都是12个byte。</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * This is the extent on-disk structure.</span></span><br><span class="line"><span class="comment"> * It&#x27;s used at the bottom of the tree.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">ext4_extent</span> &#123;</span><br><span class="line">    __le32  ee_block;   <span class="comment">/* first logical block extent covers */</span></span><br><span class="line">    __le16  ee_len;     <span class="comment">/* number of blocks covered by extent */</span></span><br><span class="line">    __le16  ee_start_hi;    <span class="comment">/* high 16 bits of physical block */</span></span><br><span class="line">    __le32  ee_start_lo;    <span class="comment">/* low 32 bits of physical block */</span></span><br><span class="line">&#125;;</span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * This is index on-disk structure.</span></span><br><span class="line"><span class="comment"> * It&#x27;s used at all the levels except the bottom.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">ext4_extent_idx</span> &#123;</span><br><span class="line">    __le32  ei_block;   <span class="comment">/* index covers logical blocks from &#x27;block&#x27; */</span></span><br><span class="line">    __le32  ei_leaf_lo; <span class="comment">/* pointer to the physical block of the next *</span></span><br><span class="line"><span class="comment">                 * level. leaf or next index could be there */</span></span><br><span class="line">    __le16  ei_leaf_hi; <span class="comment">/* high 16 bits of physical block */</span></span><br><span class="line">    __u16   ei_unused;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>如果文件不大，inode里面的i_block中，可以放得下一个ext4_extent_header和4项ext4_extent。所以这个时候，eh_depth为0，也即inode里面的就是叶子节点，树高度为0。</p>
<p>如果文件比较大，4个extent放不下，就要分裂成为一棵树，eh_depth&gt;0的节点就是索引节点，其中根节点深度最大，在inode中。最底层eh_depth&#x3D;0的是叶子节点。</p>
<p>除了根节点，其他的节点都保存在一个块4k里面，4k扣除ext4_extent_header的12个byte，剩下的能够放340项，每个extent最大能表示128MB的数据，340个extent会使你的表示的文件达到42.5GB。</p>
<h3 id="2-3-inode位图和块位图"><a href="#2-3-inode位图和块位图" class="headerlink" title="2.3,inode位图和块位图"></a><strong>2.3,inode位图和块位图</strong></h3><p>inode的位图大小为4k，每一位对应一个inode。如果是1，表示这个inode已经被用了；如果是0，则表示没被用。block的位图同理。</p>
<p>在Linux操作系统里面，想要创建一个新文件，会调用open函数，并且参数会有O_CREAT。这表示当文件找不到的时候，我们就需要创建一个。那么open函数的调用过程大致是：要打开一个文件，先要根据路径找到文件夹。如果发现文件夹下面没有这个文件，同时又设置了O_CREAT，就说明我们要在这个文件夹下面创建一个文件。</p>
<p>创建一个文件，那么就需要创建一个inode，那么就会从文件系统里面读取inode位图，然后找到下一个为0的inode，就是空闲的inode。对于block位图，在写入文件的时候，也会有这个过程。</p>
<h3 id="2-4-文件系统的格式"><a href="#2-4-文件系统的格式" class="headerlink" title="2.4,文件系统的格式"></a><strong>2.4,文件系统的格式</strong></h3><p>数据块的位图是放在一个块里面的，共4k。每位表示一个数据块，共可以表示</p>
<p><img src="https://pic3.zhimg.com/80/v2-5a1904d718681cb27f589c747eaf3e86_720w.webp" alt="img"></p>
<p>个数据块。如果每个数据块也是按默认的4K，最大可以表示空间为</p>
<p><img src="https://pic2.zhimg.com/80/v2-4694bb05a5877c55e9591ac9f1d50841_720w.webp" alt="img"></p>
<p>个byte，也就是128M，那么显然是不够的。这个时候就需要用到块组，数据结构为ext4_group_desc，这里面对于一个块组里的inode位图bg_inode_bitmap_lo、块位图bg_block_bitmap_lo、inode列表bg_inode_table_lo，都有相应的成员变量。</p>
<p>这样一个个块组，就基本构成了我们整个文件系统的结构。因为块组有多个，块组描述符也同样组成一个列表，我们把这些称为块组描述符表。</p>
<p>我们还需要有一个数据结构，对整个文件系统的情况进行描述，这个就是超级块ext4_super_block。里面有整个文件系统一共有多少inode，s_inodes_count；一共有多少块，s_blocks_count_lo，每个块组有多少inode，s_inodes_per_group，每个块组有多少块，s_blocks_per_group等。这些都是这类的全局信息。</p>
<p>最终，整个文件系统格式就是下面这个样子</p>
<p><img src="https://pic1.zhimg.com/80/v2-f3ceebe140b650c37c1d20a2d3635e74_720w.webp" alt="img"></p>
<p>默认情况下，超级块和块组描述符表都有副本保存在每一个块组里面。防止这些数据丢失了，导致整个文件系统都打不开了。</p>
<p>由于如果每个块组里面都保存一份完整的块组描述符表，一方面很浪费空间；另一个方面，由于一个块组最大128M，而块组描述符表里面有多少项，这就限制了有多少个块组，128M * 块组的总数目是整个文件系统的大小，就被限制住了。</p>
<p>因此引入Meta Block Groups特性。</p>
<p>首先，块组描述符表不会保存所有块组的描述符了，而是将块组分成多个组，我们称为元块组（Meta Block Group）。每个元块组里面的块组描述符表仅仅包括自己的，一个元块组包含64个块组，这样一个元块组中的块组描述符表最多64项。</p>
<p>我们假设一共有256个块组，原来是一个整的块组描述符表，里面有256项，要备份就全备份，现在分成4个元块组，每个元块组里面的块组描述符表就只有64项了，这就小多了，而且四个元块组自己备份自己的。</p>
<p><img src="https://pic4.zhimg.com/80/v2-ffb2da1d589fdacaa1cad7842f32c187_720w.webp" alt="img"></p>
<p>根据图中，每一个元块组包含64个块组，块组描述符表也是64项，备份三份，在元块组的第一个，第二个和最后一个块组的开始处。</p>
<p>如果开启了sparse_super特性，超级块和块组描述符表的副本只会保存在块组索引为0、3、5、7的整数幂里。所以上图的超级块只在索引为0、3、5、7等的整数幂里。</p>
<h2 id="3、目录的存储格式"><a href="#3、目录的存储格式" class="headerlink" title="3、目录的存储格式"></a>3、目录的存储格式</h2><p>其实目录本身也是个文件，也有inode。inode里面也是指向一些块。和普通文件不同的是，普通文件的块里面保存的是文件数据，而目录文件的块里面保存的是目录里面一项一项的文件信息。这些信息我们称为ext4_dir_entry。</p>
<p>在目录文件的块中，最简单的保存格式是列表，每一项都会保存这个目录的下一级的文件的文件名和对应的inode，通过这个inode，就能找到真正的文件。第一项是“.”，表示当前目录，第二项是“…”，表示上一级目录，接下来就是一项一项的文件名和inode。</p>
<p>如果在inode中设置EXT4_INDEX_FL标志，那么就表示根据索引查找文件。索引项会维护一个文件名的哈希值和数据块的一个映射关系。</p>
<p>如果我们要查找一个目录下面的文件名，可以通过名称取哈希。如果哈希能够匹配上，就说明这个文件的信息在相应的块里面。然后打开这个块，如果里面不再是索引，而是索引树的叶子节点的话，那里面还是ext4_dir_entry的列表，我们只要一项一项找文件名就行。通过索引树，我们可以将一个目录下面的N多的文件分散到很多的块里面，可以很快地进行查找。</p>
<p><img src="https://pic1.zhimg.com/80/v2-e92a52ef576a73d2ec1f00f83cb5c938_720w.webp" alt="img"></p>
<h2 id="3、Linux中的文件缓存"><a href="#3、Linux中的文件缓存" class="headerlink" title="3、Linux中的文件缓存"></a>3、Linux中的文件缓存</h2><h3 id="4-1ext4文件系统层"><a href="#4-1ext4文件系统层" class="headerlink" title="4.1ext4文件系统层"></a><strong>4.1ext4文件系统层</strong></h3><p>对于ext4文件系统来讲，内核定义了一个ext4_file_operations</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="type">const</span> <span class="keyword">struct</span> <span class="title class_">file_operations</span> ext4_file_operations = &#123;</span><br><span class="line">......</span><br><span class="line">    .read_iter  = ext4_file_read_iter,</span><br><span class="line">    .write_iter = ext4_file_write_iter,</span><br><span class="line">......</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>ext4_file_read_iter会调用generic_file_read_iter，ext4_file_write_iter会调用__generic_file_write_iter</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">ssize_t</span></span></span><br><span class="line"><span class="function"><span class="title">generic_file_read_iter</span><span class="params">(<span class="keyword">struct</span> kiocb *iocb, <span class="keyword">struct</span> iov_iter *iter)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">......</span><br><span class="line">    <span class="keyword">if</span> (iocb-&gt;ki_flags &amp; IOCB_DIRECT) &#123;</span><br><span class="line">......</span><br><span class="line">        <span class="keyword">struct</span> <span class="title class_">address_space</span> *mapping = file-&gt;f_mapping;</span><br><span class="line">......</span><br><span class="line">        retval = mapping-&gt;a_ops-&gt;<span class="built_in">direct_IO</span>(iocb, iter);</span><br><span class="line">    &#125;</span><br><span class="line">......</span><br><span class="line">    retval = <span class="built_in">generic_file_buffered_read</span>(iocb, iter, retval);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="type">ssize_t</span> __generic_file_write_iter(<span class="keyword">struct</span> kiocb *iocb, <span class="keyword">struct</span> iov_iter *from)</span><br><span class="line">&#123;</span><br><span class="line">......</span><br><span class="line">    <span class="keyword">if</span> (iocb-&gt;ki_flags &amp; IOCB_DIRECT) &#123;</span><br><span class="line">......</span><br><span class="line">        written = <span class="built_in">generic_file_direct_write</span>(iocb, from);</span><br><span class="line">......</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">......</span><br><span class="line">        written = <span class="built_in">generic_perform_write</span>(file, from, iocb-&gt;ki_pos);</span><br><span class="line">......</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>generic_file_read_iter和__generic_file_write_iter有相似的逻辑，就是要区分是否用缓存。因此，根据是否使用内存做缓存，我们可以把文件的I&#x2F;O操作分为两种类型。</p>
<p>第一种类型是缓存I&#x2F;O。大多数文件系统的默认I&#x2F;O操作都是缓存I&#x2F;O。对于读操作来讲，操作系统会先检查，内核的缓冲区有没有需要的数据。如果已经缓存了，那就直接从缓存中返回；否则从磁盘中读取，然后缓存在操作系统的缓存中。对于写操作来讲，<strong>操作系统会先将数据从用户空间复制到内核空间的缓存中。这时对用户程序来说，写操作就已经完成。</strong>至于什么时候再写到磁盘中由操作系统决定，除非显式地调用了sync同步命令。</p>
<p>第二种类型是直接IO，就是应用程序直接访问磁盘数据，而不经过内核缓冲区，从而减少了在内核缓存和用户程序之间数据复制。</p>
<p>如果在写的逻辑__generic_file_write_iter里面，发现设置了IOCB_DIRECT，则调用generic_file_direct_write，里面同样会调用address_space的direct_IO的函数，将数据直接写入硬盘。</p>
<p><strong>带缓存的写入操作</strong></p>
<p>我们先来看带缓存写入的函数generic_perform_write。</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">ssize_t</span> <span class="title">generic_perform_write</span><span class="params">(<span class="keyword">struct</span> file *file,</span></span></span><br><span class="line"><span class="params"><span class="function">                <span class="keyword">struct</span> iov_iter *i, <span class="type">loff_t</span> pos)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">struct</span> <span class="title class_">address_space</span> *mapping = file-&gt;f_mapping;</span><br><span class="line">    <span class="type">const</span> <span class="keyword">struct</span> <span class="title class_">address_space_operations</span> *a_ops = mapping-&gt;a_ops;</span><br><span class="line">    <span class="keyword">do</span> &#123;</span><br><span class="line">        <span class="keyword">struct</span> <span class="title class_">page</span> *page;</span><br><span class="line">        <span class="type">unsigned</span> <span class="type">long</span> offset;   <span class="comment">/* Offset into pagecache page */</span></span><br><span class="line">        <span class="type">unsigned</span> <span class="type">long</span> bytes;    <span class="comment">/* Bytes to write to page */</span></span><br><span class="line">        status = a_ops-&gt;<span class="built_in">write_begin</span>(file, mapping, pos, bytes, flags,</span><br><span class="line">                        &amp;page, &amp;fsdata);</span><br><span class="line">        copied = <span class="built_in">iov_iter_copy_from_user_atomic</span>(page, i, offset, bytes);</span><br><span class="line">        <span class="built_in">flush_dcache_page</span>(page);</span><br><span class="line">        status = a_ops-&gt;<span class="built_in">write_end</span>(file, mapping, pos, bytes, copied,</span><br><span class="line">                        page, fsdata);</span><br><span class="line">        pos += copied;</span><br><span class="line">        written += copied;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">        <span class="built_in">balance_dirty_pages_ratelimited</span>(mapping);</span><br><span class="line">    &#125; <span class="keyword">while</span> (<span class="built_in">iov_iter_count</span>(i));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>循环中主要做了这几件事：</strong></p>
<ul>
<li>对于每一页，先调用address_space的write_begin做一些准备；</li>
<li>调用iov_iter_copy_from_user_atomic，将写入的内容从用户态拷贝到内核态的页中；</li>
<li>调用address_space的write_end完成写操作；</li>
<li>调用balance_dirty_pages_ratelimited，看脏页是否太多，需要写回硬盘。所谓脏页，就是写入到缓存，但是还没有写入到硬盘的页面。</li>
</ul>
<p><strong>对于第一步，调用的是ext4_write_begin来说，主要做两件事：</strong></p>
<p><strong>第一做日志相关的工作</strong></p>
<p>ext4是一种日志文件系统，是为了防止突然断电的时候的数据丢失，引入了日志（Journal）模式。日志文件系统比非日志文件系统多了一个Journal区域。文件在ext4中分两部分存储，一部分是文件的元数据，另一部分是数据。元数据和数据的操作日志Journal也是分开管理的。你可以在挂载ext4的时候，选择Journal模式。这种模式在将数据写入文件系统前，必须等待元数据和数据的日志已经落盘才能发挥作用。这样性能比较差，但是最安全。</p>
<p>另一种模式是order模式。这个模式不记录数据的日志，只记录元数据的日志，但是在写元数据的日志前，必须先确保数据已经落盘。这个折中，是默认模式。</p>
<p>还有一种模式是writeback，不记录数据的日志，仅记录元数据的日志，并且不保证数据比元数据先落盘。这个性能最好，但是最不安全。</p>
<p><strong>第二调用</strong><br>grab_cache_page_write_begin来，得到应该写入的缓存页。</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">struct</span> <span class="title class_">page</span> *<span class="built_in">grab_cache_page_write_begin</span>(<span class="keyword">struct</span> address_space *mapping,</span><br><span class="line">                    <span class="type">pgoff_t</span> index, <span class="type">unsigned</span> flags)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">struct</span> <span class="title class_">page</span> *page;</span><br><span class="line">    <span class="type">int</span> fgp_flags = FGP_LOCK|FGP_WRITE|FGP_CREAT;</span><br><span class="line">    page = <span class="built_in">pagecache_get_page</span>(mapping, index, fgp_flags,</span><br><span class="line">            <span class="built_in">mapping_gfp_mask</span>(mapping));</span><br><span class="line">    <span class="keyword">if</span> (page)</span><br><span class="line">        <span class="built_in">wait_for_stable_page</span>(page);</span><br><span class="line">    <span class="keyword">return</span> page;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>在内核中，缓存以页为单位放在内存里面，每一个打开的文件都有一个struct file结构，每个struct file结构都有一个struct address_space用于关联文件和内存，就是在这个结构里面，有一棵树，用于保存所有与这个文件相关的的缓存页。</p>
<p><strong>对于第二步，调用</strong></p>
<p>iov_iter_copy_from_user_atomic。先将分配好的页面调用kmap_atomic映射到内核里面的一个虚拟地址，然后将用户态的数据拷贝到内核态的页面的虚拟地址中，调用kunmap_atomic把内核里面的映射删除。</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">size_t</span> <span class="title">iov_iter_copy_from_user_atomic</span><span class="params">(<span class="keyword">struct</span> page *page,</span></span></span><br><span class="line"><span class="params"><span class="function">        <span class="keyword">struct</span> iov_iter *i, <span class="type">unsigned</span> <span class="type">long</span> offset, <span class="type">size_t</span> bytes)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">char</span> *kaddr = <span class="built_in">kmap_atomic</span>(page), *p = kaddr + offset;</span><br><span class="line">    <span class="built_in">iterate_all_kinds</span>(i, bytes, v,</span><br><span class="line">        <span class="built_in">copyin</span>((p += v.iov_len) - v.iov_len, v.iov_base, v.iov_len),</span><br><span class="line">        <span class="built_in">memcpy_from_page</span>((p += v.bv_len) - v.bv_len, v.bv_page,</span><br><span class="line">                 v.bv_offset, v.bv_len),</span><br><span class="line">        <span class="built_in">memcpy</span>((p += v.iov_len) - v.iov_len, v.iov_base, v.iov_len)</span><br><span class="line">    )</span><br><span class="line">    <span class="built_in">kunmap_atomic</span>(kaddr);</span><br><span class="line">    <span class="keyword">return</span> bytes;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>第三步中，调用ext4_write_end完成写入。</strong>这里面会调用ext4_journal_stop完成日志的写入，会调用block_write_end-&gt;__block_commit_write-&gt;mark_buffer_dirty，将修改过的缓存标记为脏页。可以看出，其实所谓的完成写入，并没有真正写入硬盘，仅仅是写入缓存后，标记为脏页。</p>
<p><strong>第四步，调用</strong></p>
<p>balance_dirty_pages_ratelimited，是回写脏页</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * balance_dirty_pages_ratelimited - balance dirty memory state</span></span><br><span class="line"><span class="comment"> * @mapping: address_space which was dirtied</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * Processes which are dirtying memory should call in here once for each page</span></span><br><span class="line"><span class="comment"> * which was newly dirtied.  The function will periodically check the system&#x27;s</span></span><br><span class="line"><span class="comment"> * dirty state and will initiate writeback if needed.</span></span><br><span class="line"><span class="comment">  */</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">balance_dirty_pages_ratelimited</span><span class="params">(<span class="keyword">struct</span> address_space *mapping)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">struct</span> <span class="title class_">inode</span> *inode = mapping-&gt;host;</span><br><span class="line">    <span class="keyword">struct</span> <span class="title class_">backing_dev_info</span> *bdi = <span class="built_in">inode_to_bdi</span>(inode);</span><br><span class="line">    <span class="keyword">struct</span> <span class="title class_">bdi_writeback</span> *wb = <span class="literal">NULL</span>;</span><br><span class="line">    <span class="type">int</span> ratelimit;</span><br><span class="line">......</span><br><span class="line">    <span class="keyword">if</span> (<span class="built_in">unlikely</span>(current-&gt;nr_dirtied &gt;= ratelimit))</span><br><span class="line">        <span class="built_in">balance_dirty_pages</span>(mapping, wb, current-&gt;nr_dirtied);</span><br><span class="line">......</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>在balance_dirty_pages_ratelimited里面，发现脏页的数目超过了规定的数目，就调用balance_dirty_pages-&gt;wb_start_background_writeback，启动一个背后线程开始回写。</p>
<p><strong>另外还有几种场景也会触发回写：</strong></p>
<ul>
<li>用户主动调用sync，将缓存刷到硬盘上去，最终会调用wakeup_flusher_threads，同步脏页；</li>
<li>当内存十分紧张，以至于无法分配页面的时候，会调用free_more_memory，最终会调用wakeup_flusher_threads，释放脏页；</li>
<li>脏页已经更新了较长时间，时间上超过了设定时间，需要及时回写，保持内存和磁盘上数据一致性。</li>
</ul>
<h3 id="4-2，带缓存的读操作"><a href="#4-2，带缓存的读操作" class="headerlink" title="4.2，带缓存的读操作"></a><strong>4.2，带缓存的读操作</strong></h3><p>看带缓存的读，对应的是函数generic_file_buffered_read。</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">static</span> <span class="type">ssize_t</span> <span class="title">generic_file_buffered_read</span><span class="params">(<span class="keyword">struct</span> kiocb *iocb,</span></span></span><br><span class="line"><span class="params"><span class="function">        <span class="keyword">struct</span> iov_iter *iter, <span class="type">ssize_t</span> written)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">struct</span> <span class="title class_">file</span> *filp = iocb-&gt;ki_filp;</span><br><span class="line">    <span class="keyword">struct</span> <span class="title class_">address_space</span> *mapping = filp-&gt;f_mapping;</span><br><span class="line">    <span class="keyword">struct</span> <span class="title class_">inode</span> *inode = mapping-&gt;host;</span><br><span class="line">    <span class="keyword">for</span> (;;) &#123;</span><br><span class="line">        <span class="keyword">struct</span> <span class="title class_">page</span> *page;</span><br><span class="line">        <span class="type">pgoff_t</span> end_index;</span><br><span class="line">        <span class="type">loff_t</span> isize;</span><br><span class="line">        page = <span class="built_in">find_get_page</span>(mapping, index);</span><br><span class="line">        <span class="keyword">if</span> (!page) &#123;</span><br><span class="line">            <span class="keyword">if</span> (iocb-&gt;ki_flags &amp; IOCB_NOWAIT)</span><br><span class="line">                <span class="keyword">goto</span> would_block;</span><br><span class="line">            <span class="built_in">page_cache_sync_readahead</span>(mapping,</span><br><span class="line">                    ra, filp,</span><br><span class="line">                    index, last_index - index);</span><br><span class="line">            page = <span class="built_in">find_get_page</span>(mapping, index);</span><br><span class="line">            <span class="keyword">if</span> (<span class="built_in">unlikely</span>(page == <span class="literal">NULL</span>))</span><br><span class="line">                <span class="keyword">goto</span> no_cached_page;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (<span class="built_in">PageReadahead</span>(page)) &#123;</span><br><span class="line">            <span class="built_in">page_cache_async_readahead</span>(mapping,</span><br><span class="line">                    ra, filp, page,</span><br><span class="line">                    index, last_index - index);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">/*</span></span><br><span class="line"><span class="comment">         * Ok, we have the page, and it&#x27;s up-to-date, so</span></span><br><span class="line"><span class="comment">         * now we can copy it to user space...</span></span><br><span class="line"><span class="comment">         */</span></span><br><span class="line">        ret = <span class="built_in">copy_page_to_iter</span>(page, offset, nr, iter);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>在generic_file_buffered_read函数中，我们需要先找到page cache里面是否有缓存页。如果没有找到，不但读取这一页，还要进行预读，这需要在page_cache_sync_readahead函数中实现。预读完了以后，再试一把查找缓存页。</p>
<p>如果第一次找缓存页就找到了，我们还是要判断，是不是应该继续预读；如果需要，就调用<br>page_cache_async_readahead发起一个异步预读。</p>
<p>最后，copy_page_to_iter会将内容从内核缓存页拷贝到用户内存空间。</p>
<hr>
<p>版权声明：本文为知乎博主「玩转Linux内核」的原创文章，遵循CC 4.0 BY-SA版权协议，转载请附上原文出处链接及本声明。</p>
<p>原文链接：<a href="https://zhuanlan.zhihu.com/p/460393575">https://zhuanlan.zhihu.com/p/460393575</a></p>
]]></content>
      <categories>
        <category>linux-doc 文件系统</category>
      </categories>
      <tags>
        <tag>Linux</tag>
      </tags>
  </entry>
  <entry>
    <title>Linux操作系统学习之文件系统</title>
    <url>/2023/01/15/linux-docs/%E6%96%87%E4%BB%B6%E7%B3%BB%E7%BB%9F/Linux%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E5%AD%A6%E4%B9%A0%E4%B9%8B%E6%96%87%E4%BB%B6%E7%B3%BB%E7%BB%9F/</url>
    <content><![CDATA[<h2 id="一-前言"><a href="#一-前言" class="headerlink" title="一. 前言"></a>一. 前言</h2><p>  本节开始将分析Linux的文件系统。Linux一切皆文件的思想可谓众所周知，而其文件系统又是字符设备、块设备、管道、进程间通信、网络等等的必备知识，因此其重要性可想而知。本文将先介绍文件系统基础知识，然后介绍最重要的结构体inode以及构建于其上的一层层的文件系统。</p>
<h2 id="二-文件系统基础知识"><a href="#二-文件系统基础知识" class="headerlink" title="二. 文件系统基础知识"></a>二. 文件系统基础知识</h2><p>  一切设计均是为了实现需求，因此我们从文件系统需要的基本功能来看看其该如何设计。首先，一个文件系统需要有以下基本要求</p>
<ul>
<li>文件需要让人易于读写，并避免名字冲突等</li>
<li>文件需要易于查找、整理归类</li>
<li>操作系统需要有文档记录功能以便管理</li>
</ul>
<p>  由此，文件系统设计了如下特性</p>
<ul>
<li>采取树形结构、文件夹设计</li>
<li>对热点文件进行缓存，便于读写</li>
<li>采用索引结构，便于查找分类</li>
<li>维护一套数据结构用于记录哪些文档正在被哪些任务使用</li>
</ul>
<p>  依此基本设计，我们可以开始慢慢展开看看Linux博大而精神的文件系统。</p>
<h2 id="三-inode结构体和文件系统"><a href="#三-inode结构体和文件系统" class="headerlink" title="三. inode结构体和文件系统"></a>三. inode结构体和文件系统</h2><h3 id="3-1-块存储的表示"><a href="#3-1-块存储的表示" class="headerlink" title="3.1 块存储的表示"></a>3.1 块存储的表示</h3><p>  硬盘中我们以块为存储单元，而在文件系统中，我们需要有一个存储块信息的基本结构体，这就是文件系统的基石inode，其源码如下。inode意为index node，即索引节点。从这个数据结构中我们可以看出，inode 里面有文件的读写权限 i_mode，属于哪个用户 i_uid，哪个组 i_gid，大小是多少 i_size_lo，占用多少个块 i_blocks_lo。另外，这里面还有几个与文件相关的时间。i_atime 即 access time，是最近一次访问文件的时间；i_ctime 即 change time，是最近一次更改 inode 的时间；i_mtime 即 modify time，是最近一次更改文件的时间。</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * Structure of an inode on the disk</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">ext4_inode</span> &#123;</span></span><br><span class="line">    __le16	i_mode;		<span class="comment">/* File mode */</span></span><br><span class="line">    __le16	i_uid;		<span class="comment">/* Low 16 bits of Owner Uid */</span></span><br><span class="line">    __le32	i_size_lo;	<span class="comment">/* Size in bytes */</span></span><br><span class="line">    __le32	i_atime;	<span class="comment">/* Access time */</span></span><br><span class="line">    __le32	i_ctime;	<span class="comment">/* Inode Change time */</span></span><br><span class="line">    __le32	i_mtime;	<span class="comment">/* Modification time */</span></span><br><span class="line">    __le32	i_dtime;	<span class="comment">/* Deletion Time */</span></span><br><span class="line">    __le16	i_gid;		<span class="comment">/* Low 16 bits of Group Id */</span></span><br><span class="line">    __le16	i_links_count;	<span class="comment">/* Links count */</span></span><br><span class="line">    __le32	i_blocks_lo;	<span class="comment">/* Blocks count */</span></span><br><span class="line">    __le32	i_flags;	<span class="comment">/* File flags */</span></span><br><span class="line">......</span><br><span class="line">    __le32	i_block[EXT4_N_BLOCKS];<span class="comment">/* Pointers to blocks */</span></span><br><span class="line">......</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> EXT4_NDIR_BLOCKS 12</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> EXT4_IND_BLOCK EXT4_NDIR_BLOCKS</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> EXT4_DIND_BLOCK (EXT4_IND_BLOCK + 1)</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> EXT4_TIND_BLOCK (EXT4_DIND_BLOCK + 1)</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> EXT4_N_BLOCKS (EXT4_TIND_BLOCK + 1)</span></span><br></pre></td></tr></table></figure>
<p>  这里我们需要重点关注以下i_block，该成员变量实际存储了文件内容的每一个块。在ext2和ext3格式的文件系统中，我们用前12个块存放对应的文件数据，每个块4KB，如果文件较大放不下，则需要使用后面几个间接存储块来保存数据，下图很形象的表示了其存储原理。</p>
<p><img src="https://user-images.githubusercontent.com/87457873/128176692-6949236a-8cc8-41f1-8e59-ed73e1bf6686.png" alt="image"></p>
<p> 该存储结构带来的问题是对于大型文件，我们需要多次调用才可以访问对应块的内容，因此访问速度较慢。为此，ext4提出了新的解决方案：Extents。简单的说，Extents以一个树形结构来连续存储文件块，从而提高访问速度，大致结构如下图所示。</p>
<p><img src="https://user-images.githubusercontent.com/87457873/128176736-7ea6b328-674d-420f-b402-24f9e0199366.png" alt="image"></p>
<p>主要结构体为节点ext4_extent_header，eh_entries 表示这个节点里面有多少项。这里的项分两种：</p>
<ul>
<li>如果是叶子节点，这一项会直接指向硬盘上的连续块的地址，我们称为数据节点 ext4_extent；</li>
<li>如果是分支节点，这一项会指向下一层的分支节点或者叶子节点，我们称为索引节点 ext4_extent_idx。这两种类型的项的大小都是 12 个 byte。</li>
</ul>
<p>  如果文件不大，inode 里面的 i_block 中，可以放得下一个 ext4_extent_header 和 4 项 ext4_extent。所以这个时候，eh_depth 为 0，也即 inode 里面的就是叶子节点，树高度为 0。如果文件比较大，4 个 extent 放不下，就要分裂成为一棵树，eh_depth&gt;0 的节点就是索引节点，其中根节点深度最大，在 inode 中。最底层 eh_depth&#x3D;0 的是叶子节点。除了根节点，其他的节点都保存在一个块 4k 里面，4k 扣除 ext4_extent_header 的 12 个 byte，剩下的能够放 340 项，每个 extent 最大能表示 128MB 的数据，340 个 extent 会使你表示的文件达到 42.5GB。这已经非常大了，如果再大，我们可以增加树的深度。</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * Each block (leaves and indexes), even inode-stored has header.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">ext4_extent_header</span> &#123;</span></span><br><span class="line">    __le16	eh_magic;	<span class="comment">/* probably will support different formats */</span></span><br><span class="line">    __le16	eh_entries;	<span class="comment">/* number of valid entries */</span></span><br><span class="line">    __le16	eh_max;		<span class="comment">/* capacity of store in entries */</span></span><br><span class="line">    __le16	eh_depth;	<span class="comment">/* has tree real underlying blocks? */</span></span><br><span class="line">    __le32	eh_generation;	<span class="comment">/* generation of the tree */</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * This is the extent on-disk structure.</span></span><br><span class="line"><span class="comment"> * It&#x27;s used at the bottom of the tree.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">ext4_extent</span> &#123;</span></span><br><span class="line">    __le32  ee_block;  <span class="comment">/* first logical block extent covers */</span></span><br><span class="line">    __le16  ee_len;    <span class="comment">/* number of blocks covered by extent */</span></span><br><span class="line">    __le16  ee_start_hi;  <span class="comment">/* high 16 bits of physical block */</span></span><br><span class="line">    __le32  ee_start_lo;  <span class="comment">/* low 32 bits of physical block */</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * This is index on-disk structure.</span></span><br><span class="line"><span class="comment"> * It&#x27;s used at all the levels except the bottom.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">ext4_extent_idx</span> &#123;</span></span><br><span class="line">    __le32  ei_block;  <span class="comment">/* index covers logical blocks from &#x27;block&#x27; */</span></span><br><span class="line">    __le32  ei_leaf_lo;  <span class="comment">/* pointer to the physical block of the next *</span></span><br><span class="line"><span class="comment">         * level. leaf or next index could be there */</span></span><br><span class="line">    __le16  ei_leaf_hi;  <span class="comment">/* high 16 bits of physical block */</span></span><br><span class="line">    __u16  ei_unused;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>  由此，我们可以通过inode来表示一系列的块，从而构成了一个文件。在硬盘上，通过一系列的inode，我们可以存储大量的文件。但是我们尚需要一种方式去存储和管理inode，这就是位图。同样的，我们会用块位图去管理块的信息。如下所示为创建inode的过程中对位图的访问，我们需要找出下一个0位所在，即空闲inode的位置。</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">inode</span> *__<span class="title">ext4_new_inode</span>(<span class="title">handle_t</span> *<span class="title">handle</span>, <span class="keyword">struct</span> <span class="title">inode</span> *<span class="title">dir</span>,</span></span><br><span class="line"><span class="class">             <span class="title">umode_t</span> <span class="title">mode</span>, <span class="title">const</span> <span class="keyword">struct</span> <span class="title">qstr</span> *<span class="title">qstr</span>,</span></span><br><span class="line"><span class="class">             __<span class="title">u32</span> <span class="title">goal</span>, <span class="title">uid_t</span> *<span class="title">owner</span>, __<span class="title">u32</span> <span class="title">i_flags</span>,</span></span><br><span class="line"><span class="class">             <span class="title">int</span> <span class="title">handle_type</span>, <span class="title">unsigned</span> <span class="title">int</span> <span class="title">line_no</span>,</span></span><br><span class="line"><span class="class">             <span class="title">int</span> <span class="title">nblocks</span>)</span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">......</span><br><span class="line">    inode_bitmap_bh = ext4_read_inode_bitmap(sb, group);</span><br><span class="line">......</span><br><span class="line">    ino = ext4_find_next_zero_bit((<span class="type">unsigned</span> <span class="type">long</span> *)</span><br><span class="line">                inode_bitmap_bh-&gt;b_data,</span><br><span class="line">                EXT4_INODES_PER_GROUP(sb), ino);</span><br><span class="line">......</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="3-2-文件系统的格式"><a href="#3-2-文件系统的格式" class="headerlink" title="3.2 文件系统的格式"></a>3.2 文件系统的格式</h3><p>  <br>  inode和块是文件系统的最小组成单元，在此之上还有多级系统，大致有如下这些：</p>
<ul>
<li>块组：存储一块数据的组成单元，数据结构为ext4_group_desc。这里面对于一个块组里的 inode 位图 bg_inode_bitmap_lo、块位图 bg_block_bitmap_lo、inode 列表 bg_inode_table_lo均有相应的定义。一个个块组，就基本构成了我们整个文件系统的结构。</li>
<li>块组描述符表：多个块组的描述符构成的表</li>
<li>超级块：对整个文件系统的情况进行描述，即ext4_super_block，存储全局信息，如整个文件系统一共有多少 inode：s_inodes_count；一共有多少块：s_blocks_count_lo，每个块组有多少 inode：s_inodes_per_group，每个块组有多少块：s_blocks_per_group 等。</li>
<li>引导块：对于整个文件系统，我们需要预留一块区域作为引导区用于操作系统的启动，所以第一个块组的前面要留 1K，用于启动引导区。</li>
</ul>
<p><img src="https://user-images.githubusercontent.com/87457873/128176778-85a9b208-b2a4-4da8-b410-fe9c02a45a3d.png" alt="image"></p>
<p>超级块和块组描述符表都是全局信息，而且这些数据很重要。如果这些数据丢失了，整个文件系统都打不开了，这比一个文件的一个块损坏更严重。所以，这两部分我们都需要备份，但是采取不同的策略。</p>
<ul>
<li>默认策略：在每个块中均保存一份超级块和块组描述表的备份</li>
<li>sparse_super策略：采取稀疏存储的方式，仅在块组索引为 0、3、5、7 的整数幂里存储。</li>
<li>Meta Block Groups策略：我们将块组分为多个元块组（Meta Block Groups)，每个元块组里面的块组描述符表仅仅包括自己的内容，一个元块组包含 64 个块组，这样一个元块组中的块组描述符表最多 64 项。这种做法类似于merkle tree，可以在很大程度上优化空间。</li>
</ul>
<p><img src="https://user-images.githubusercontent.com/87457873/128176801-a6849be4-829c-49da-b304-0139c87a290c.png" alt="image"></p>
<h3 id="3-3-目录的存储格式"><a href="#3-3-目录的存储格式" class="headerlink" title="3.3 目录的存储格式"></a>3.3 目录的存储格式</h3><p>  为了便于文件的查找，我们必须要有索引，即文件目录。其实目录本身也是个文件，也有 inode。inode 里面也是指向一些块。和普通文件不同的是，普通文件的块里面保存的是文件数据，而目录文件的块里面保存的是目录里面一项一项的文件信息。这些信息我们称为 ext4_dir_entry。这里有两个版本，第二个版本 ext4_dir_entry_2 是将一个 16 位的 name_len，变成了一个 8 位的 name_len 和 8 位的 file_type。</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">ext4_dir_entry</span> &#123;</span></span><br><span class="line">    __le32  inode;      <span class="comment">/* Inode number */</span></span><br><span class="line">    __le16  rec_len;    <span class="comment">/* Directory entry length */</span></span><br><span class="line">    __le16  name_len;    <span class="comment">/* Name length */</span></span><br><span class="line">    <span class="type">char</span>  name[EXT4_NAME_LEN];  <span class="comment">/* File name */</span></span><br><span class="line">&#125;;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">ext4_dir_entry_2</span> &#123;</span></span><br><span class="line">    __le32  inode;      <span class="comment">/* Inode number */</span></span><br><span class="line">    __le16  rec_len;    <span class="comment">/* Directory entry length */</span></span><br><span class="line">    __u8  name_len;    <span class="comment">/* Name length */</span></span><br><span class="line">    __u8  file_type;</span><br><span class="line">    <span class="type">char</span>  name[EXT4_NAME_LEN];  <span class="comment">/* File name */</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>  在目录文件的块中，最简单的保存格式是列表，就是一项一项地将 ext4_dir_entry_2 列在哪里。每一项都会保存这个目录的下一级的文件的文件名和对应的 inode，通过这个 inode，就能找到真正的文件。第一项是“.”，表示当前目录，第二项是“…”，表示上一级目录，接下来就是一项一项的文件名和 inode。有时候，如果一个目录下面的文件太多的时候，我们想在这个目录下找一个文件，按照列表一个个去找太慢了，于是我们就添加了索引的模式。如果在 inode 中设置 EXT4_INDEX_FL 标志，则目录文件的块的组织形式将发生变化，变成了下面定义的这个样子：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">dx_root</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">fake_dirent</span> <span class="title">dot</span>;</span></span><br><span class="line">    <span class="type">char</span> dot_name[<span class="number">4</span>];</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">fake_dirent</span> <span class="title">dotdot</span>;</span></span><br><span class="line">    <span class="type">char</span> dotdot_name[<span class="number">4</span>];</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">dx_root_info</span></span></span><br><span class="line"><span class="class">    &#123;</span></span><br><span class="line">      __le32 reserved_zero;</span><br><span class="line">      u8 hash_version;</span><br><span class="line">      u8 info_length; <span class="comment">/* 8 */</span></span><br><span class="line">      u8 indirect_levels;</span><br><span class="line">      u8 unused_flags;</span><br><span class="line">    &#125;</span><br><span class="line">    info;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">dx_entry</span>  <span class="title">entries</span>[0];</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>  当前目录和上级目录不变，文件列表改用dx_root_info结构体，其中最重要的成员变量是 indirect_levels，表示间接索引的层数。索引项由结构体 dx_entry表示，本质上是文件名的哈希值和数据块的一个映射关系。</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">dx_entry</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    __le32 hash;</span><br><span class="line">    __le32 block;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>  如果我们要查找一个目录下面的文件名，可以通过名称取哈希。如果哈希能够匹配上，就说明这个文件的信息在相应的块里面。然后打开这个块，如果里面不再是索引，而是索引树的叶子节点的话，那里面还是 ext4_dir_entry_2 的列表，我们只要一项一项找文件名就行。通过索引树，我们可以将一个目录下面的 N 多的文件分散到很多的块里面，可以很快地进行查找。</p>
<p><img src="https://user-images.githubusercontent.com/87457873/128176835-29dd1d86-94a8-4cc6-9582-31b4af06c082.png" alt="image"></p>
<h3 id="3-4-软链接和硬链接的存储格式"><a href="#3-4-软链接和硬链接的存储格式" class="headerlink" title="3.4 软链接和硬链接的存储格式"></a>3.4 软链接和硬链接的存储格式</h3><p>  软链接和硬链接也是文件的一种，可以通过如下命令创建。ln -s 创建的是软链接，不带 -s 创建的是硬链接。</p>
<pre><code>ln [参数][源文件或目录][目标文件或目录]
</code></pre>
<p> <br> 硬链接与原始文件共用一个 inode ，但是 inode 是不跨文件系统的，每个文件系统都有自己的 inode 列表，因而硬链接是没有办法跨文件系统的。而软链接不同，软链接相当于重新创建了一个文件。这个文件也有独立的 inode，只不过打开这个文件看里面内容的时候，内容指向另外的一个文件。这就很灵活了。我们可以跨文件系统，甚至目标文件被删除了链接文件也依然存在，只不过指向的文件找不到了而已。</p>
<p><img src="https://user-images.githubusercontent.com/87457873/128176914-3227696e-4205-4a01-9e24-71c66f24bb82.png" alt="image"></p>
<h2 id="四-总结"><a href="#四-总结" class="headerlink" title="四. 总结"></a>四. 总结</h2><p>  本文主要从文件系统的设计角度出发，逐步分析了inode和基于inode的ext4文件系统结构和主要组成部分，下面引用极客时间中的一张图作为总结。</p>
<p><img src="https://user-images.githubusercontent.com/87457873/128176936-eea79fb9-6e04-46e4-a4d0-829e083506e0.png" alt="image"></p>
]]></content>
      <categories>
        <category>linux-doc 文件系统</category>
      </categories>
      <tags>
        <tag>Linux</tag>
      </tags>
  </entry>
  <entry>
    <title>Linux文件系统详解</title>
    <url>/2023/01/15/linux-docs/%E6%96%87%E4%BB%B6%E7%B3%BB%E7%BB%9F/Linux%E6%96%87%E4%BB%B6%E7%B3%BB%E7%BB%9F%E8%AF%A6%E8%A7%A3/</url>
    <content><![CDATA[<h2 id="Linux的一切皆文件"><a href="#Linux的一切皆文件" class="headerlink" title="Linux的一切皆文件"></a>Linux的一切皆文件</h2><p>Linux 中的各种事物比如像文档、目录（Mac OS X 和 Windows 系统下称之为文件夹）、键盘、监视器、硬盘、可移动媒体设备、打印机、调制解调器、虚拟终端，还有进程间通信（IPC）和网络通信等输入&#x2F;输出资源都是定义在文件系统空间下的字节流。<br><br>一切都可看作是文件，其最显著的好处是对于上面所列出的输入&#x2F;输出资源，只需要相同的一套 Linux 工具、实用程序和 API。你可以使用同一套api(read, write)和工具(cat , 重定向, 管道)来处理unix中大多数的资源.<br><br>设计一个系统的终极目标往往就是要找到原子操作，一旦锁定了原子操作，设计工作就会变得简单而有序。“文件”作为一个抽象概念，其原子操作非常简单，只有读和写，这无疑是一个非常好的模型。通过这个模型，API的设计可以化繁为简，用户可以使用通用的方式去访问任何资源，自有相应的中间件做好对底层的适配。<br><br>现代操作系统为解决信息能独立于进程之外被长期存储引入了文件，文件作为进程创建信息的逻辑单元可被多个进程并发使用。在 UNIX 系统中，操作系统为磁盘上的文本与图像、鼠标与键盘等输入设备及网络交互等 I&#x2F;O 操作设计了一组通用 API，使他们被处理时均可统一使用字节流方式。换言之，UNIX 系统中除进程之外的一切皆是文件，而 Linux 保持了这一特性。为了便于文件的管理，Linux 还引入了目录（有时亦被称为文件夹）这一概念。目录使文件可被分类管理，且目录的引入使 Linux 的文件系统形成一个层级结构的目录树</p>
<blockquote>
<p>在Linux系统中，一切都是文件，理解文件系统，对于学习Linux来说，是一个非常有必要的前提</p>
</blockquote>
<p>Linux上的文件系统一般来说就是EXT2或EXT3，但这篇文章并不准备一上来就直接讲它们，而希望结合Linux操作系统并从文件系统建立的基础——硬盘开始，一步步认识Linux的文件系统。</p>
<h2 id="1-机械硬盘的物理存储机制"><a href="#1-机械硬盘的物理存储机制" class="headerlink" title="1. 机械硬盘的物理存储机制"></a>1. 机械硬盘的物理存储机制</h2><blockquote>
<ul>
<li>现代计算机大部分文件存储功能都是由机械硬盘这种设备提供的。（现在的SSD和闪存从概念和逻辑上都部分继承自机械硬盘，所以使用机械硬盘来进行理解也是没有问题的）</li>
<li>机械硬盘能实现信息存储的功能基于：磁性存储介质能够被磁化，且磁化后会长久保留被磁化的状态，这种被磁化状态能够被读取出来，同时这种磁化状态还能够不断被修改，磁化正好有两个方向，所以可以表示0和1。于是硬盘就是把这种磁性存储介质做成一个个盘片，每一个盘片上都分布着数量巨大的磁性存储单位，使用磁性读写头对盘片进行写入和读取（从原理上类似黑胶唱片的播放）。</li>
<li>一个硬盘中的磁性存储单位数以亿计（1T硬盘就有约80亿个），所以需要一套规则来规划信息如何存取（比如一本存储信息的书我们还会分为页，每一页从上到下从左到右读取，同时还有章节目录）于是就有了这些物理、逻辑概念：<br><br>1、一个硬盘有多张盘片叠成，不同盘片有编号<br><br>2、每张盘片上的存储颗粒成环形一圈圈地排布，每一圈称为磁道，有编号<br><br>3、每条磁道上都有一圈存储颗粒，每512*8（512字节，0.5KB）个存储颗粒作为一个扇区，扇区是硬盘上存储的最小物理单位<br><br>4、N个扇区可以组成簇，N取决于不同的文件系统或是文件系统的配置，簇是此文件系统中的最小存储单位<br><br>5、所有盘面上的同一磁道构成一个圆柱，称为柱面，柱面是系统分区的最小单位<br><br>磁头读写文件的时候，首先是分区读写的，由inode编号（区内唯一的编号后面介绍）找到对应的磁道和扇区，然后一个柱面一个柱面地进行读写。机械硬盘的读写控制系统是一个令人叹为观止的精密工程（一个盘面上有几亿个存储单位，每个磁道宽度不到几十纳米，磁盘每分钟上万转），同时关于读写的逻辑也是有诸多细节（比如扇区的编号并不是连续的），非常有意思，可以自行搜索文章拓展阅读。<br>有了硬盘并不意味着LInux可以立刻把它用来存储，还需要组合进Linux的文件体系才能被Linux使用。</li>
</ul>
</blockquote>
<p><img src="https://user-images.githubusercontent.com/87457873/127275223-4e6d656a-bf3b-440c-966d-c5d366a8c2ab.png" alt="image"></p>
<h2 id="2-Linux文件体系"><a href="#2-Linux文件体系" class="headerlink" title="2.Linux文件体系"></a>2.Linux文件体系</h2><p>Linux以文件的形式对计算机中的数据和硬件资源进行管理，也就是彻底的一切皆文件，反映在Linux的文件类型上就是：普通文件、目录文件（也就是文件夹）、设备文件、链接文件、管道文件、套接字文件（数据通信的接口）等等。而这些种类繁多的文件被Linux使用目录树进行管理， 所谓的目录树就是以根目录（&#x2F;）为主，向下呈现分支状的一种文件结构。不同于纯粹的ext2之类的文件系统，我把它称为文件体系，一切皆文件和文件目录树的资源管理方式一起构成了Linux的文件体系，让Linux操作系统可以方便使用系统资源。所以文件系统比文件体系涵盖的内容少很多，Linux文件体系主要在于把操作系统相关的东西用文件这个载体实现：文件系统挂载在操作系统上，操作系统整个系统又放在文件系统里。但本文中文件体系的相关内容不是很多，大部分地方都可以用文件系统代替文件体系。</p>
<h3 id="1-Linux中的文件类型"><a href="#1-Linux中的文件类型" class="headerlink" title="1. Linux中的文件类型:"></a>1. Linux中的文件类型:</h3><h4 id="1-1-普通文件（-）"><a href="#1-1-普通文件（-）" class="headerlink" title="1.1. 普通文件（-）"></a>1.1. 普通文件（-）</h4><p>从Linux的角度来说，类似mp4、pdf、html这样应用层面上的文件类型都属于普通文件Linux用户可以根据访问权限对普通文件进行查看、更改和删除</p>
<h4 id="1-2-目录文件（d，directory-file）"><a href="#1-2-目录文件（d，directory-file）" class="headerlink" title="1.2. 目录文件（d，directory file）"></a>1.2. 目录文件（d，directory file）</h4><p>目录文件对于用惯Windows的用户来说不太容易理解，目录也是文件的一种目录文件包含了各自目录下的文件名和指向这些文件的指针，打开目录事实上就是打开目录文件，只要有访问权限，你就可以随意访问这些目录下的文件（普通文件的执行权限就是目录文件的访问权限），但是只有内核的进程能够修改它们虽然不能修改，但是我们能够通过vim去查看目录文件的内容</p>
<h4 id="1-3-符号链接（l，symbolic-link）"><a href="#1-3-符号链接（l，symbolic-link）" class="headerlink" title="1.3. 符号链接（l，symbolic link）"></a>1.3. 符号链接（l，symbolic link）</h4><p>这种类型的文件类似Windows中的快捷方式，是指向另一个文件的间接指针，也就是我们常说的软链接</p>
<h4 id="1-4-块设备文件（b，block）和字符设备文件（c，char）"><a href="#1-4-块设备文件（b，block）和字符设备文件（c，char）" class="headerlink" title="1.4. 块设备文件（b，block）和字符设备文件（c，char）"></a>1.4. 块设备文件（b，block）和字符设备文件（c，char）</h4><p>这些文件一般隐藏在&#x2F;dev目录下，在进行设备读取和外设交互时会被使用到比如磁盘光驱就是块设备文件，串口设备则属于字符设备文件系统中的所有设备要么是块设备文件，要么是字符设备文件，无一例外</p>
<h4 id="1-5-FIFO（p，pipe）"><a href="#1-5-FIFO（p，pipe）" class="headerlink" title="1.5. FIFO（p，pipe）"></a>1.5. FIFO（p，pipe）</h4><p>管道文件主要用于进程间通讯。比如使用mkfifo命令可以创建一个FIFO文件，启用一个进程A从FIFO文件里读数据，启动进程B往FIFO里写数据，先进先出，随写随读。</p>
<h4 id="1-6-套接字（s，socket）"><a href="#1-6-套接字（s，socket）" class="headerlink" title="1.6. 套接字（s，socket）"></a>1.6. 套接字（s，socket）</h4><p>用于进程间的网络通信，也可以用于本机之间的非网络通信这些文件一般隐藏在&#x2F;var&#x2F;run目录下，证明着相关进程的存在<br><br>Linux 的文件是没有所谓的扩展名的，一个 Linux文件能不能被执行与它是否可执行的属性有关，只要你的权限中有 x ，比如[ -rwx-r-xr-x ] 就代表这个文件可以被执行，与文件名没有关系。跟在 Windows下能被执行的文件扩展名通常是 .com .exe .bat 等不同。不过，可以被执行跟可以执行成功不一样。比如在 root 主目彔下的 install.log 是一个文本文件，修改权限成为 -rwxrwxrwx 后这个文件能够真的执行成功吗？ 当然不行，因为它的内容根本就没有可以执行的数据。所以说，这个 x 代表这个文件具有可执行的能力， 但是能不能执行成功，当然就得要看该文件的内容了。<br><br>虽然如此，不过我们仍然希望能从扩展名来了解该文件是什么东西，所以一般我们还是会以适当的扩展名来表示该文件是什么种类的。所以Linux 系统上的文件名真的只是让你了解该文件可能的用途而已， 真正的执行与否仍然需要权限的规范才行。比如常见的&#x2F;bin&#x2F;ls 这个显示文件属性的指令要是权限被修改为无法执行，那么ls 就变成不能执行了。这种问题最常发生在文件传送的过程中。例如你在网络上下载一个可执行文件，但是偏偏在你的 Linux 系统中就是无法执行，那就可能是档案的属性被改变了。而且从网络上传送到你 的 Linux 系统中，文件的属性权限确实是会被改变的</p>
<h3 id="2-Linux目录树"><a href="#2-Linux目录树" class="headerlink" title="2. Linux目录树"></a>2. Linux目录树</h3><p>对Linux系统和用户来说，所有可操作的计算机资源都存在于目录树这个逻辑结构中，对计算机资源的访问都可以认为是目录树的访问。就硬盘来说，所有对硬盘的访问都变成了对目录树中某个节点也就是文件夹的访问，访问时不需要知道它是硬盘还是硬盘中的文件夹。目录树的逻辑结构也非常简单，就是从根目录（&#x2F;）开始，不断向下展开各级子目录。</p>
<h2 id="3-硬盘分区"><a href="#3-硬盘分区" class="headerlink" title="3.硬盘分区"></a>3.硬盘分区</h2><p>硬盘分区是硬盘结合到文件体系的第一步，本质是「硬盘」这个物理概念转换成「区」这个逻辑概念，为下一步格式化做准备。所以分本身并不是必须的，你完全可以把一整块硬盘作为一个区。但从数据的安全性以及系统性能角度来看，分区还是有很多用处的，所以一般都会对硬盘进行分区。</p>
<p>讲分区就不得不先提每块硬盘上最重要的第一扇区，这个扇区中有硬盘主引导记录(Master boot record, MBR) 及分区表(partition table)， 其中 MBR 占有 446 bytes，而分区表占有 64 bytes。硬盘主引导记录放有最基本的引导加载程序，是系统开机启动的关键环节，在附录中有更详细的说明。而分区表则跟分区有关，它记录了硬盘分区的相关信息，但因分区表仅有 64bytes ， 所以最多只能记彔四块分区（分区本身其实就是对分区表进行设置）。</p>
<p>只能分四个区实在太少了，于是就有了扩展分区的概念，既然第一个扇区所在的分区表只能记录四条数据， 那我可否利用额外的扇区来记录更多的分区信息。<br><br>把普通可以访问的分区称为主分区，扩展分区不同于主分区，它本身并没有内容，它是为进一步逻辑分区提供空间的。在某块分区指定为扩展分区后，就可以对这块扩展分区进一步分成多个逻辑分区。操作系统规定：</p>
<p>1、四块分区每块都可以是主分区或扩展分区<br><br>2、扩展分区最多只能有一个（也没必要有多个）<br><br>3、扩展分区可以进一步分割为多个逻辑分区<br><br>4、扩展分区只是逻辑概念，本身不能被访问，也就是不能被格式化后作为数据访问的分区，能够作为数据访问的分区只有主分区和逻辑分区<br><br>5、逻辑分区的数量依操作系统而不同，在 Linux 系统中，IDE 硬盘最多有 59 个逻辑分区(5 号到 63 号)， SATA 硬盘则有 11 个逻辑分区(5 号到 15 号)</p>
<p>一般给硬盘进行分区时，一个主分区一个扩展分区，然后把扩展分区划分为N个逻辑分区是最好的</p>
<p>是否可以不要主分区呢？不知道，但好像不用管，你创建分区的时候会自动给你配置类型特殊的，你最好单独分一个swap区（内存置换空间），它独为一类，功能是：当有数据被存放在物理内存里面，但是这些数据又不是常被 CPU 所取用时，那么这些不常被使用的程序将会被丢到硬盘的 swap 置换空间当中， 而将速度较快的物理内存空间释放出来给真正需要的程序使用</p>
<h2 id="4-格式化"><a href="#4-格式化" class="headerlink" title="4.格式化"></a>4.格式化</h2><p>我们知道Linux操作系统支持很多不同的文件系统，比如ext2、ext3、XFS、FAT等等，而Linux把对不同文件系统的访问交给了VFS（虚拟文件系统），VFS能访问和管理各种不同的文件系统。所以有了区之后就需要把它格式化成具体的文件系统以便VFS访问。</p>
<p>标准的Linux文件系统Ext2是使用「基于inode的文件系统」</p>
<p>1、我们知道一般操作系统的文件数据除了文件实际内容外， 还带有很多属性，例如 Linux 操作系统的文件权限(rwx)与文件属性(拥有者、群组、 时间参数等)，文件系统通常会将属性和实际内容这两部分数据分别存放在不同的区块<br><br>2、在基于inode的文件系统中，权限与属性放置到 inode 中，实际数据放到 data block 区块中，而且inode和data block都有编号</p>
<p>Ext2 文件系统在此基础上</p>
<p>1、文件系统最前面有一个启动扇区(boot sector)<br></p>
<ul>
<li>这个启动扇区可以安装开机管理程序， 这个设计让我们能将不同的引导装载程序安装到个别的文件系统前端，而不用覆盖整个硬盘唯一的MBR， 也就是这样才能实现多重引导的功能</li>
</ul>
<p>2、把每个区进一步分为多个块组 (block group)，每个块组有独立的inode&#x2F;block体系<br></p>
<ul>
<li>如果文件系统高达数百 GB 时，把所有的 inode 和block 通通放在一起会因为 inode 和 block的数量太庞大，不容易管理</li>
<li>这其实很好理解，因为分区是用户的分区，实际计算机管理时还有个最适合的大小，于是计算机会进一步的在分区中分块</li>
<li>（但这样岂不是可能出现大文件放不了的问题？有什么机制善后吗？）</li>
</ul>
<p>3、每个块组实际还会分为分为6个部分，除了inode table 和 data block外还有4个附属模块，起到优化和完善系统性能的作用<br></p>
<p>所以整个分区大概会这样划分：</p>
<p><img src="https://user-images.githubusercontent.com/87457873/127280770-5acec908-89d3-4fa1-94a0-79eab26eafb4.png" alt="image"></p>
<h3 id="inode-table"><a href="#inode-table" class="headerlink" title="inode table"></a>inode table</h3><p>1.主要记录文件的属性以及该文件实际数据是放置在哪些block中，它记录的信息至少有这些：<br></p>
<ul>
<li>大小、真正内容的block号码（一个或多个）<br></li>
<li>访问模式(read&#x2F;write&#x2F;excute)<br></li>
<li>拥有者与群组(owner&#x2F;group)<br></li>
<li>各种时间：建立或状态改变的时间、最近一次的读取时间、最近修改的时间<br></li>
<li>没有文件名！文件名在目录的block中！<br></li>
</ul>
<p>2、一个文件占用一个 inode，每个inode有编号<br><br>3、Linux 系统存在 inode 号被用完但磁盘空间还有剩余的情况<br><br>4、注意，这里的文件不单单是普通文件，目录文件也就是文件夹其实也是一个文件，还有其他的也是<br><br>5、inode 的数量与大小在格式化时就已经固定了，每个inode 大小均固定为128 bytes (新的ext4 与xfs 可设定到256 bytes)<br><br>6、文件系统能够建立的文件数量与inode 的数量有关，存在空间还够但inode不够的情况<br><br>7、系统读取文件时需要先找到inode，并分析inode 所记录的权限与使用者是否符合，若符合才能够开始实际读取 block 的内容<br><br>8、inode 要记录的资料非常多，但偏偏又只有128bytes ， 而inode 记录一个block 号码要花掉4byte ，假设我一个文件有400MB 且每个block 为4K 时， 那么至少也要十万条block 号码的记录！inode 哪有这么多空间来存储？为此我们的系统很聪明的将inode 记录block 号码的区域定义为12个直接，一个间接, 一个双间接与一个三间接记录区（详细见附录）</p>
<h3 id="data-block"><a href="#data-block" class="headerlink" title="data block"></a>data block</h3><p>1、放置文件内容数据的地方<br><br>2、在格式化时block的大小就固定了，且每个block都有编号，以方便inode的记录<br></p>
<ul>
<li>原则上，block 的大小与数量在格式化完就不能够再改变了(除非重新格式化)<br></li>
</ul>
<p>3、在Ext2文件系统中所支持的block大小有1K, 2K及4K三种，由于block大小的区别，会导致该文件系统能够支持的最大磁盘容量与最大单一文件容量各不相同：<br></p>
<ul>
<li>Block 大小 1KB 2KB 4KB</li>
<li>最大单一档案限制 16GB 256GB 2TB</li>
<li>最大档案系统总容量 2TB 8TB 16TB</li>
</ul>
<p>4、每个block 内最多只能够放置一个文件的资料，但一个文件可以放在多个block中（大的话）<br><br>5、若文件小于block ，则该block 的剩余容量就不能够再被使用了(磁盘空间会浪费)<br></p>
<ul>
<li>所以如果你的档案都非常小，但是你的block 在格式化时却选用最大的4K 时，可能会产生容量的浪费<br></li>
<li>既然大的block 可能会产生较严重的磁碟容量浪费，那么我们是否就将block 大小定为1K ？这也不妥，因为如果block 较小的话，那么大型档案将会占用数量更多的block ，而inode 也要记录更多的block 号码，此时将可能导致档案系统不良的读写效能<br></li>
<li>事实上现在的磁盘容量都太大了，所以一般都会选择4K 的block 大小</li>
</ul>
<h3 id="superblock"><a href="#superblock" class="headerlink" title="superblock"></a>superblock</h3><p>1、记录整个文件系统相关信息的地方，一般大小为1024bytes，记录的信息主要有：<br></p>
<ul>
<li>block 与inode 的总量</li>
<li>未使用与已使用的inode &#x2F; block 数量</li>
<li>一个valid bit 数值，若此文件系统已被挂载，则valid bit 为0 ，若未被挂载，则valid bit 为1</li>
<li>block 与inode 的大小 (block 为1, 2, 4K，inode 为128bytes 或256bytes)；</li>
<li>其他各种文件系统相关信息：filesystem 的挂载时间、最近一次写入资料的时间、最近一次检验磁碟(fsck) 的时间</li>
</ul>
<p>2、Superblock是非常重要的， 没有Superblock ，就没有这个文件系统了，因此如果superblock死掉了，你的文件系统可能就需要花费很多时间去挽救<br><br>3、每个块都可能含有superblock，但是我们也说一个文件系统应该仅有一个superblock 而已，那是怎么回事？事实上除了第一个块内会含有superblock 之外，后续的块不一定含有superblock，而若含有superblock则该superblock主要是做为第一个块内superblock的备份，这样可以进行superblock的救援</p>
<h3 id="Filesystem-Description"><a href="#Filesystem-Description" class="headerlink" title="Filesystem Description"></a>Filesystem Description</h3><p>1、文件系统描述<br><br>2、这个区段可以描述每个block group的开始与结束的block号码，以及说明每个区段(superblock, bitmap, inodemap, data block)分别介于哪一个block号码之间</p>
<h3 id="block-bitmap"><a href="#block-bitmap" class="headerlink" title="block bitmap"></a>block bitmap</h3><p>1、块对照表<br><br>2、如果你想要新增文件时要使用哪个block 来记录呢？当然是选择「空的block」来记录。那你怎么知道哪个block 是空的？这就得要通过block bitmap了，它会记录哪些block是空的，因此我们的系统就能够很快速的找到可使用的空间来记录<br><br>3、同样在你删除某些文件时，那些文件原本占用的block号码就得要释放出来， 此时在block bitmap 中对应该block号码的标志位就得要修改成为「未使用中」</p>
<h3 id="inode-bitmap"><a href="#inode-bitmap" class="headerlink" title="inode bitmap"></a>inode bitmap</h3><p>1、与block bitmap 是类似的功能，只是block bitmap 记录的是使用与未使用的block 号码， 至于inode bitmap 则是记录使用与未使用的inode 号码</p>
<h2 id="5-挂载"><a href="#5-挂载" class="headerlink" title="5.挂载"></a>5.挂载</h2><p>在一个区被格式化为一个文件系统之后，它就可以被Linux操作系统使用了，只是这个时候Linux操作系统还找不到它，所以我们还需要把这个文件系统「注册」进Linux操作系统的文件体系里，这个操作就叫「挂载」 (mount)。挂载是利用一个目录当成进入点（类似选一个现成的目录作为代理），将文件系统放置在该目录下，也就是说，进入该目录就可以读取该文件系统的内容，类似整个文件系统只是目录树的一个文件夹（目录）。这个进入点的目录我们称为「挂载点」。</p>
<p>由于整个 Linux 系统最重要的是根目录，因此根目录一定需要挂载到某个分区。 而其他的目录则可依用户自己的需求来给予挂载到不同的分去。</p>
<p>到这里Linux的文件体系的构建过程其实已经大体讲完了，总结一下就是：硬盘经过分区和格式化，每个区都成为了一个文件系统，挂载这个文件系统后就可以让Linux操作系统通过VFS访问硬盘时跟访问一个普通文件夹一样。这里通过一个在目录树中读取文件的实际例子来细讲一下目录文件和普通文件。</p>
<h2 id="6-目录树的读取过程"><a href="#6-目录树的读取过程" class="headerlink" title="6.目录树的读取过程"></a>6.目录树的读取过程</h2><p>首先我们要知道</p>
<p>1、每个文件（不管是一般文件还是目录文件）都会占用一个inode<br><br>2、依据文件内容的大小来分配一个或多个block给该文件使用<br><br>3、创建一个文件后，文件完整信息分布在3处地方，生成2个新文件：<br></p>
<ul>
<li>文件名记录在该文件所在目录的目录文件的block中，没有新文件生成<br></li>
<li>文件属性、权限信息、记录具体内容的block编号记录在inode中，inode是新生成文件<br></li>
<li>文件具体内存记录在block中，block是新生成文件<br></li>
</ul>
<p>4、因为文件名的记录是在目录的block当中，「新增&#x2F;删除&#x2F;更名文件名」与目录的w权限有关所以在Linux&#x2F;Unix中，文件名称只是文件的一个属性，叫别名也好，叫绰号也罢，仅为了方便用户记忆和使用，但系统内部并不需要用文件名来定为文件位置，这样处理最直观的好处就是，你可以对正在使用的文件改名，换目录，甚至放到废纸篓，都不会影响当前文件的使用，这在Windows里是无法想象的。比如你打开个Word文件，然后对其进行重命名操作，Windows会告诉你门儿都没有，关闭文件先！但在Mac里就毫无压力，因为Mac的操作系统同样采用了inode的设计。</p>
<h3 id="创建文件过程"><a href="#创建文件过程" class="headerlink" title="创建文件过程"></a>创建文件过程</h3><p>当在ext2下建立一个一般文件时， ext2 会分配一个inode 与相对于该文件大小的block 数量给该文件</p>
<ul>
<li>例如：假设我的一个block 为4 Kbytes ，而我要建立一个100 KBytes 的文件，那么linux 将分配一个inode 与25 个block 来储存该文件</li>
<li>但同时请注意，由于inode 仅有12 个直接指向，因此还要多一个block 来作为区块号码的记录</li>
</ul>
<h3 id="创建目录过程"><a href="#创建目录过程" class="headerlink" title="创建目录过程"></a>创建目录过程</h3><p>当在ext2文件系统建立一个目录时（就是新建了一个目录文件），文件系统会分配一个inode与至少一块block给该目录</p>
<ul>
<li>inode记录该目录的相关权限与属性，并记录分配到的那块block号码</li>
<li>而block则是记录在这个目录下的文件名与该文件对应的inode号</li>
<li>block中还会自动生成两条记录，一条是.文件夹记录，inode指向自身，另一条是..文件夹记录，inode指向父文件夹</li>
</ul>
<h3 id="从目录树中读取某个文件过程"><a href="#从目录树中读取某个文件过程" class="headerlink" title="从目录树中读取某个文件过程"></a>从目录树中读取某个文件过程</h3><ul>
<li>因为文件名是记录在目录的block当中，因此当我们要读取某个文件时，就一定会经过目录的inode与block ，然后才能够找到那个待读取文件的inode号码，最终才会读到正确的文件的block内的资料。</li>
<li>由于目录树是由根目录开始，因此操作系统先通过挂载信息找到挂载点的inode号，由此得到根目录的inode内容，并依据该inode读取根目录的block信息，再一层一层的往下读到正确的文件。举例来说，如果我想要读取&#x2F;etc&#x2F;passwd 这个文件时，系统是如何读取的呢？先看一下这个文件以及有关路径文件夹的信息：</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">1$ ll -di / /etc /etc/passwd</span><br><span class="line">2     128 dr-xr-x r-x . 17 root root 4096 May 4 17:56 /</span><br><span class="line">333595521 drwxr-x r-x . 131 root root 8192 Jun 17 00:20 /et</span><br><span class="line">c436628004 -rw-r-- r-- . 1 root root 2092 Jun 17 00:20 /etc/passwd</span><br></pre></td></tr></table></figure>

<p>于是该文件的读取流程为：</p>
<p>1、&#x2F;的inode：<br><br>通过挂载点的信息找到inode号码为128的根目录inode，且inode规定的权限让我们可以读取该block的内容(有r与x)<br><br>2、&#x2F;的block：<br><br>经过上个步骤取得block的号码，并找到该内容有etc&#x2F;目录的inode号码(33595521)<br><br>3、etc&#x2F;的inode：<br><br>读取33595521号inode得知具有r与x的权限，因此可以读取etc&#x2F;的block内容<br><br>4、etc&#x2F;的block：<br><br>经过上个步骤取得block号码，并找到该内容有passwd文件的inode号码(36628004)<br><br>5、passwd的inode：<br><br>读取36628004号inode得知具有r的权限，因此可以读取passwd的block内容<br><br>6、passwd的block：<br><br>最后将该block内容的资料读出来<br></p>
]]></content>
      <categories>
        <category>linux-doc 文件系统</category>
      </categories>
      <tags>
        <tag>Linux</tag>
      </tags>
  </entry>
  <entry>
    <title>磁盘IO那些事</title>
    <url>/2023/01/15/linux-docs/%E6%96%87%E4%BB%B6%E7%B3%BB%E7%BB%9F/%E7%A3%81%E7%9B%98IO%E9%82%A3%E4%BA%9B%E4%BA%8B/</url>
    <content><![CDATA[<h2 id="背景"><a href="#背景" class="headerlink" title="背景"></a>背景</h2><p>计算机硬件性能在过去十年间的发展普遍遵循摩尔定律，通用计算机的CPU主频早已超过3GHz，内存也进入了普及DDR4的时代。然而传统硬盘虽然在存储容量上增长迅速，但是在读写性能上并无明显提升，同时SSD硬盘价格高昂，不能在短时间内完全替代传统硬盘。传统磁盘的I&#x2F;O读写速度成为了计算机系统性能提高的瓶颈，制约了计算机整体性能的发展。</p>
<p>硬盘性能的制约因素是什么？如何根据磁盘I&#x2F;O特性来进行系统设计？针对这些问题，本文将介绍硬盘的物理结构和性能指标，以及操作系统针对磁盘性能所做的优化，最后讨论下基于磁盘I&#x2F;O特性设计的技巧。</p>
<h2 id="硬盘的物理结构"><a href="#硬盘的物理结构" class="headerlink" title="硬盘的物理结构"></a>硬盘的物理结构</h2><p>硬盘内部主要部件为磁盘盘片、传动手臂、读写磁头和主轴马达。实际数据都是写在盘片上，读写主要是通过传动手臂上的读写磁头来完成。实际运行时，主轴让磁盘盘片转动，然后传动手臂可伸展让读取头在盘片上进行读写操作。磁盘物理结构如下图所示：</p>
<p><img src="https://awps-assets.meituan.net/mit-x/blog-images-bundle-2017/343bddc0.jpg" alt="img"></p>
<p>由于单一盘片容量有限，一般硬盘都有两张以上的盘片，每个盘片有两面，都可记录信息，所以一张盘片对应着两个磁头。盘片被分为许多扇形的区域，每个区域叫一个扇区，硬盘中每个扇区的大小固定为512字节。盘片表面上以盘片中心为圆心，不同半径的同心圆称为磁道，不同盘片相同半径的磁道所组成的圆柱称为柱面。磁道与柱面都是表示不同半径的圆，在许多场合，磁道和柱面可以互换使用。磁盘盘片垂直视角如下图所示：</p>
<p><img src="https://user-images.githubusercontent.com/87457873/127287681-c4483eae-7685-4862-aeab-f8fcaee1f946.png" alt="image"></p>
<p>早期的硬盘每磁道扇区数相同，此时由磁盘基本参数可以计算出硬盘的容量：存储容量&#x3D;磁头数<em>磁道（柱面）数</em>每道扇区数*每扇区字节数。由于每磁道扇区数相同，外圈磁道半径大，里圈磁道半径小，外圈和里圈扇区面积自然会不一样。同时，为了更好的读取数据，即使外圈扇区面积再大也只能和内圈扇区一样存放相同的字节数（512字节）。这样一来，外圈的记录密度就要比内圈小，会浪费大量的存储空间。</p>
<p>如今的硬盘都使用ZBR（Zoned Bit Recording，区位记录）技术，盘片表面由里向外划分为数个区域，不同区域的磁道扇区数目不同，同一区域内各磁道扇区数相同，盘片外圈区域磁道长扇区数目较多，内圈区域磁道短扇区数目较少，大体实现了等密度，从而获得了更多的存储空间。此时，由于每磁道扇区数各不相同，所以传统的容量计算公式就不再适用。实际上如今的硬盘大多使用LBA（Logical Block Addressing）逻辑块寻址模式，知道LBA后即可计算出硬盘容量。</p>
<h2 id="影响硬盘性能的因素"><a href="#影响硬盘性能的因素" class="headerlink" title="影响硬盘性能的因素"></a>影响硬盘性能的因素</h2><p>影响磁盘的关键因素是磁盘服务时间，即磁盘完成一个I&#x2F;O请求所花费的时间，它由寻道时间、旋转延迟和数据传输时间三部分构成。</p>
<h3 id="1-寻道时间"><a href="#1-寻道时间" class="headerlink" title="1. 寻道时间"></a>1. 寻道时间</h3><p>Tseek是指将读写磁头移动至正确的磁道上所需要的时间。寻道时间越短，I&#x2F;O操作越快，目前磁盘的平均寻道时间一般在3-15ms。</p>
<h3 id="2-旋转延迟"><a href="#2-旋转延迟" class="headerlink" title="2. 旋转延迟"></a>2. 旋转延迟</h3><p>Trotation是指盘片旋转将请求数据所在的扇区移动到读写磁盘下方所需要的时间。旋转延迟取决于磁盘转速，通常用磁盘旋转一周所需时间的1&#x2F;2表示。比如：7200rpm的磁盘平均旋转延迟大约为60*1000&#x2F;7200&#x2F;2 &#x3D; 4.17ms，而转速为15000rpm的磁盘其平均旋转延迟为2ms。</p>
<h3 id="3-数据传输时间"><a href="#3-数据传输时间" class="headerlink" title="3. 数据传输时间"></a>3. 数据传输时间</h3><p>Ttransfer是指完成传输所请求的数据所需要的时间，它取决于数据传输率，其值等于数据大小除以数据传输率。目前IDE&#x2F;ATA能达到133MB&#x2F;s，SATA II可达到300MB&#x2F;s的接口数据传输率，数据传输时间通常远小于前两部分消耗时间。简单计算时可忽略。</p>
<h2 id="衡量性能的指标"><a href="#衡量性能的指标" class="headerlink" title="衡量性能的指标"></a>衡量性能的指标</h2><p>机械硬盘的连续读写性能很好，但随机读写性能很差，这主要是因为磁头移动到正确的磁道上需要时间，随机读写时，磁头需要不停的移动，时间都浪费在了磁头寻址上，所以性能不高。衡量磁盘的重要主要指标是IOPS和吞吐量。</p>
<h3 id="1-IOPS"><a href="#1-IOPS" class="headerlink" title="1. IOPS"></a>1. IOPS</h3><p>IOPS（Input&#x2F;Output Per Second）即每秒的输入输出量（或读写次数），即指每秒内系统能处理的I&#x2F;O请求数量。随机读写频繁的应用，如小文件存储等，关注随机读写性能，IOPS是关键衡量指标。可以推算出磁盘的IOPS &#x3D; 1000ms &#x2F; (Tseek + Trotation + Transfer)，如果忽略数据传输时间，理论上可以计算出随机读写最大的IOPS。常见磁盘的随机读写最大IOPS为：</p>
<ul>
<li>7200rpm的磁盘 IOPS &#x3D; 76 IOPS</li>
<li>10000rpm的磁盘IOPS &#x3D; 111 IOPS</li>
<li>15000rpm的磁盘IOPS &#x3D; 166 IOPS</li>
</ul>
<h3 id="2-吞吐量"><a href="#2-吞吐量" class="headerlink" title="2. 吞吐量"></a>2. 吞吐量</h3><p>吞吐量（Throughput），指单位时间内可以成功传输的数据数量。顺序读写频繁的应用，如视频点播，关注连续读写性能、数据吞吐量是关键衡量指标。它主要取决于磁盘阵列的架构，通道的大小以及磁盘的个数。不同的磁盘阵列存在不同的架构，但他们都有自己的内部带宽，一般情况下，内部带宽都设计足够充足，不会存在瓶颈。磁盘阵列与服务器之间的数据通道对吞吐量影响很大，比如一个2Gbps的光纤通道，其所能支撑的最大流量仅为250MB&#x2F;s。最后，当前面的瓶颈都不再存在时，硬盘越多的情况下吞吐量越大。</p>
<h2 id="操作系统层的优化"><a href="#操作系统层的优化" class="headerlink" title="操作系统层的优化"></a>操作系统层的优化</h2><p>虽然15000rpm的磁盘计算出的理论最大IOPS仅为166，但在实际运行环境中，实际磁盘的IOPS往往能够突破200甚至更高。这其实就是在系统调用过程中，操作系统进行了一系列的优化。</p>
<p>那么操作系统是如何操作硬盘的呢？类似于网络的分层结构，下图显示了Linux系统中对于磁盘的一次读请求在核心空间中所要经历的层次模型。从图中看出：对于磁盘的一次读请求，首先经过虚拟文件系统层（VFS Layer），其次是具体的文件系统层（例如Ext2），接下来是Cache层（Page Cache Layer）、通用块层（Generic Block Layer）、I&#x2F;O调度层（I&#x2F;O Scheduler Layer）、块设备驱动层（Block Device Driver Layer），最后是物理块设备层（Block Device Layer）。</p>
<p><img src="https://user-images.githubusercontent.com/87457873/127287921-960d72b9-3d70-498a-9509-9d300ff54efa.png" alt="image"></p>
<h2 id="虚拟文件系统层（VFS-Layer）"><a href="#虚拟文件系统层（VFS-Layer）" class="headerlink" title="虚拟文件系统层（VFS Layer）"></a>虚拟文件系统层（VFS Layer）</h2><p>VFS（Virtual File System）虚拟文件系统是一种软件机制，更确切的说扮演着文件系统管理者的角色，与它相关的数据结构只存在于物理内存当中。它的作用是：屏蔽下层具体文件系统操作的差异，为上层的操作提供一个统一的接口。正是因为有了这个层次，Linux中允许众多不同的文件系统共存并且对文件的操作可以跨文件系统而执行。</p>
<p>VFS中包含着向物理文件系统转换的一系列数据结构，如VFS超级块、VFS的Inode、各种操作函数的转换入口等。Linux中VFS依靠四个主要的数据结构来描述其结构信息，分别为超级块、索引结点、目录项和文件对象。</p>
<p>1、超级块（Super Block）：超级块对象表示一个文件系统。它存储一个已安装的文件系统的控制信息，包括文件系统名称（比如Ext2）、文件系统的大小和状态、块设备的引用和元数据信息（比如空闲列表等等）。VFS超级块存在于内存中，它在文件系统安装时建立，并且在文件系统卸载时自动删除。同时需要注意的是对于每个具体的文件系统来说，也有各自的超级块，它们存放于磁盘。</p>
<p>2、索引结点（Inode）：索引结点对象存储了文件的相关元数据信息，例如：文件大小、设备标识符、用户标识符、用户组标识符等等。Inode分为两种：一种是VFS的Inode，一种是具体文件系统的Inode。前者在内存中，后者在磁盘中。所以每次其实是将磁盘中的Inode调进填充内存中的Inode，这样才是算使用了磁盘文件Inode。当创建一个文件的时候，就给文件分配了一个Inode。一个Inode只对应一个实际文件，一个文件也会只有一个Inode。</p>
<p>3、目录项（Dentry）：引入目录项对象的概念主要是出于方便查找文件的目的。不同于前面的两个对象，目录项对象没有对应的磁盘数据结构，只存在于内存中。一个路径的各个组成部分，不管是目录还是普通的文件，都是一个目录项对象。如，在路径&#x2F;home&#x2F;source&#x2F;test.java中，目录 &#x2F;, home, source和文件 test.java都对应一个目录项对象。VFS在查找的时候，根据一层一层的目录项找到对应的每个目录项的Inode，那么沿着目录项进行操作就可以找到最终的文件。</p>
<p>4、文件对象（File）：文件对象描述的是进程已经打开的文件。因为一个文件可以被多个进程打开，所以一个文件可以存在多个文件对象。一个文件对应的文件对象可能不是惟一的，但是其对应的索引节点和目录项对象肯定是惟一的。</p>
<h2 id="Ext2文件系统"><a href="#Ext2文件系统" class="headerlink" title="Ext2文件系统"></a>Ext2文件系统</h2><p>VFS的下一层即是具体的文件系统，本节简要介绍下Linux的Ext2文件系统。</p>
<p>一个文件系统一般使用块设备上一个独立的逻辑分区。对于Ext2文件系统来说，硬盘分区首先被划分为一个个的Block，一个Ext2文件系统上的每个Block都是一样大小的。但是不同Ext2文件系统，Block大小可能不同，这是在创建Ext2系统决定的，一般为1k或者4k。由于Block数量很多，为了方便管理，Ext2将这些Block聚集在一起分为几个大的块组（Block Group），每个块组包含的等量的物理块，在块组的数据块中存储文件或目录。Ext2文件系统存储结构如下图所示：</p>
<p><img src="https://user-images.githubusercontent.com/87457873/127288096-cc1daa6d-09ed-4e90-91f9-72aba734c34e.png" alt="image"></p>
<p>Ext2中的Super Block和Inode Table分别对应VFS中的超级块和索引结点，存放在磁盘。每个块组都有一个块组描述符GDT（Group Descriptor Table），存储一个块组的描述信息，例如在这个块组中从哪里开始是Inode表，从哪里开始是数据块等等。Block Bitmap和Inode Bitmap分别表示Block和Inode是否空闲可用。Data Block数据块是用来真正存储文件内容数据的地方，下面我们看一下具体的存储规则。</p>
<p>在Ext2文件系统中所支持的Block大小有1K、2K、4K三种。在格式化时Block的大小就固定了，且每个Block都有编号，方便Inode的记录。每个Block内最多只能够放置一个文件的数据，如果文件大于Block的大小，则一个文件会占用多个Block；如果文件小于Block，则该Block的剩余容量就不能够再被使用了，即磁盘空间会浪费。下面看看Inode和Block的对应关系。</p>
<p>Inode要记录的数据非常多，但大小仅为固定的128字节，同时记录一个Block号码就需要4字节，假设一个文件有400MB且每个Block为4K时，那么至少也要十万笔Block号码的记录。Inode不可能有这么多的记录信息，因此Ext2将Inode记录Block号码的区域定义为12个直接、一个间接、一个双间接与一个三间接记录区。Inode存储结构如下图所示：</p>
<p><img src="https://user-images.githubusercontent.com/87457873/127288120-6acfcdd2-472f-4958-8bac-f16e190d2c1b.png" alt="image"></p>
<p>最左边为Inode本身（128 bytes），里面有12个直接指向Block号码的对照，这12笔记录能够直接取得Block号码。至于所谓的间接就是再拿一个Block来当作记录Block号码的记录区，如果文件太大时，就会使用间接的Block来记录编号。如上图当中间接只是拿一个Block来记录额外的号码而已。 同理，如果文件持续长大，那么就会利用所谓的双间接，第一个Block仅再指出下一个记录编号的Block在哪里，实际记录的在第二个Block当中。依此类推，三间接就是利用第三层Block来记录编号。</p>
<h2 id="Page-Cache层"><a href="#Page-Cache层" class="headerlink" title="Page Cache层"></a>Page Cache层</h2><p>引入Cache层的目的是为了提高Linux操作系统对磁盘访问的性能。Cache层在内存中缓存了磁盘上的部分数据。当数据的请求到达时，如果在Cache中存在该数据且是最新的，则直接将数据传递给用户程序，免除了对底层磁盘的操作，提高了性能。Cache层也正是磁盘IOPS为什么能突破200的主要原因之一。</p>
<p>在Linux的实现中，文件Cache分为两个层面，一是Page Cache，另一个Buffer Cache，每一个Page Cache包含若干Buffer Cache。Page Cache主要用来作为文件系统上的文件数据的缓存来用，尤其是针对当进程对文件有read&#x2F;write操作的时候。Buffer Cache则主要是设计用来在系统对块设备进行读写的时候，对块进行数据缓存的系统来使用。</p>
<p>磁盘Cache有两大功能：预读和回写。预读其实就是利用了局部性原理，具体过程是：对于每个文件的第一个读请求，系统读入所请求的页面并读入紧随其后的少数几个页面（通常是三个页面），这时的预读称为同步预读。对于第二次读请求，如果所读页面不在Cache中，即不在前次预读的页中，则表明文件访问不是顺序访问，系统继续采用同步预读；如果所读页面在Cache中，则表明前次预读命中，操作系统把预读页的大小扩大一倍，此时预读过程是异步的，应用程序可以不等预读完成即可返回，只要后台慢慢读页面即可，这时的预读称为异步预读。任何接下来的读请求都会处于两种情况之一：第一种情况是所请求的页面处于预读的页面中，这时继续进行异步预读；第二种情况是所请求的页面处于预读页面之外，这时系统就要进行同步预读。</p>
<p>回写是通过暂时将数据存在Cache里，然后统一异步写到磁盘中。通过这种异步的数据I&#x2F;O模式解决了程序中的计算速度和数据存储速度不匹配的鸿沟，减少了访问底层存储介质的次数，使存储系统的性能大大提高。Linux 2.6.32内核之前，采用pdflush机制来将脏页真正写到磁盘中，什么时候开始回写呢？下面两种情况下，脏页会被写回到磁盘：</p>
<p>1、在空闲内存低于一个特定的阈值时，内核必须将脏页写回磁盘，以便释放内存。<br><br>2、当脏页在内存中驻留超过一定的阈值时，内核必须将超时的脏页写会磁盘，以确保脏页不会无限期地驻留在内存中。<br></p>
<p>回写开始后，pdflush会持续写数据，直到满足以下两个条件：<br></p>
<p>1、已经有指定的最小数目的页被写回到磁盘。<br><br>2、空闲内存页已经回升，超过了阈值。<br></p>
<p>Linux 2.6.32内核之后，放弃了原有的pdflush机制，改成了bdi_writeback机制。bdi_writeback机制主要解决了原有fdflush机制存在的一个问题：在多磁盘的系统中，pdflush管理了所有磁盘的Cache，从而导致一定程度的I&#x2F;O瓶颈。bdi_writeback机制为每个磁盘都创建了一个线程，专门负责这个磁盘的Page Cache的刷新工作，从而实现了每个磁盘的数据刷新在线程级的分离，提高了I&#x2F;O性能。</p>
<p>回写机制存在的问题是回写不及时引发数据丢失（可由sync|fsync解决），回写期间读I&#x2F;O性能很差。</p>
<h2 id="通用块层"><a href="#通用块层" class="headerlink" title="通用块层"></a>通用块层</h2><p>通用块层的主要工作是：接收上层发出的磁盘请求，并最终发出I&#x2F;O请求。该层隐藏了底层硬件块设备的特性，为块设备提供了一个通用的抽象视图。</p>
<p>对于VFS和具体的文件系统来说，块（Block）是基本的数据传输单元，当内核访问文件的数据时，它首先从磁盘上读取一个块。但是对于磁盘来说，扇区是最小的可寻址单元，块设备无法对比它还小的单元进行寻址和操作。由于扇区是磁盘的最小可寻址单元，所以块不能比扇区还小，只能整数倍于扇区大小，即一个块对应磁盘上的一个或多个扇区。一般来说，块大小是2的整数倍，而且由于Page Cache层的最小单元是页（Page），所以块大小不能超过一页的长度。</p>
<p>大多情况下，数据的传输通过DMA方式。旧的磁盘控制器，仅仅支持简单的DMA操作：每次数据传输，只能传输磁盘上相邻的扇区，即数据在内存中也是连续的。这是因为如果传输非连续的扇区，会导致磁盘花费更多的时间在寻址操作上。而现在的磁盘控制器支持“分散&#x2F;聚合”DMA操作，这种模式下，数据传输可以在多个非连续的内存区域中进行。为了利用“分散&#x2F;聚合”DMA操作，块设备驱动必须能处理被称为段（segments）的数据单元。一个段就是一个内存页面或一个页面的部分，它包含磁盘上相邻扇区的数据。</p>
<p>通用块层是粘合所有上层和底层的部分，一个页的磁盘数据布局如下图所示：</p>
<p><img src="https://user-images.githubusercontent.com/87457873/127288313-9af82744-c198-478f-9c75-40ac03bf960c.png" alt="image"></p>
<h2 id="I-O调度层"><a href="#I-O调度层" class="headerlink" title="I&#x2F;O调度层"></a>I&#x2F;O调度层</h2><p>I&#x2F;O调度层的功能是管理块设备的请求队列。即接收通用块层发出的I&#x2F;O请求，缓存请求并试图合并相邻的请求。并根据设置好的调度算法，回调驱动层提供的请求处理函数，以处理具体的I&#x2F;O请求。</p>
<p>如果简单地以内核产生请求的次序直接将请求发给块设备的话，那么块设备性能肯定让人难以接受，因为磁盘寻址是整个计算机中最慢的操作之一。为了优化寻址操作，内核不会一旦接收到I&#x2F;O请求后，就按照请求的次序发起块I&#x2F;O请求。为此Linux实现了几种I&#x2F;O调度算法，算法基本思想就是通过合并和排序I&#x2F;O请求队列中的请求，以此大大降低所需的磁盘寻道时间，从而提高整体I&#x2F;O性能。</p>
<p>常见的I&#x2F;O调度算法包括Noop调度算法（No Operation）、CFQ（完全公正排队I&#x2F;O调度算法）、DeadLine（截止时间调度算法）、AS预测调度算法等。</p>
<ul>
<li><p>Noop算法：最简单的I&#x2F;O调度算法。该算法仅适当合并用户请求，并不排序请求。新的请求通常被插在调度队列的开头或末尾，下一个要处理的请求总是队列中的第一个请求。这种算法是为不需要寻道的块设备设计的，如SSD。因为其他三个算法的优化是基于缩短寻道时间的，而SSD硬盘没有所谓的寻道时间且I&#x2F;O响应时间非常短。</p>
</li>
<li><p>CFQ算法：算法的主要目标是在触发I&#x2F;O请求的所有进程中确保磁盘I&#x2F;O带宽的公平分配。算法使用许多个排序队列，存放了不同进程发出的请求。通过散列将同一个进程发出的请求插入同一个队列中。采用轮询方式扫描队列，从第一个非空队列开始，依次调度不同队列中特定个数（公平）的请求，然后将这些请求移动到调度队列的末尾。</p>
</li>
<li><p>Deadline算法：算法引入了两个排队队列分别包含读请求和写请求，两个最后期限队列包含相同的读和写请求。本质就是一个超时定时器，当请求被传给电梯算法时开始计时。一旦最后期限队列中的超时时间已到，就想请求移至调度队列末尾。Deadline算法避免了电梯调度策略（为了减少寻道时间，会优先处理与上一个请求相近的请求）带来的对某个请求忽略很长一段时间的可能。</p>
</li>
<li><p>AS算法：AS算法本质上依据局部性原理，预测进程发出的读请求与刚被调度的请求在磁盘上可能是“近邻”。算法统计每个进程I&#x2F;O操作信息，当刚刚调度了由某个进程的一个读请求之后，算法马上检查排序队列中的下一个请求是否来自同一个进程。如果是，立即调度下一个请求。否则，查看关于该进程的统计信息，如果确定进程p可能很快发出另一个读请求，那么就延迟一小段时间。</p>
</li>
</ul>
<p>前文中计算出的IOPS是理论上的随机读写的最大IOPS，在随机读写中，每次I&#x2F;O操作的寻址和旋转延时都不能忽略不计，有了这两个时间的存在也就限制了IOPS的大小。现在如果我们考虑在读取一个很大的存储连续分布在磁盘的文件，因为文件的存储的分布是连续的，磁头在完成一个读I&#x2F;O操作之后，不需要重新寻址，也不需要旋转延时，在这种情况下我们能到一个很大的IOPS值。这时由于不再考虑寻址和旋转延时，则性能瓶颈仅是数据传输时延，假设数据传输时延为0.4ms，那么IOPS&#x3D;1000 &#x2F; 0.4 &#x3D; 2500 IOPS。</p>
<p>在许多的开源框架如Kafka、HBase中，都通过追加写的方式来尽可能的将随机I&#x2F;O转换为顺序I&#x2F;O，以此来降低寻址时间和旋转延时，从而最大限度的提高IOPS。</p>
<h2 id="块设备驱动层"><a href="#块设备驱动层" class="headerlink" title="块设备驱动层"></a>块设备驱动层</h2><p>驱动层中的驱动程序对应具体的物理块设备。它从上层中取出I&#x2F;O请求，并根据该I&#x2F;O请求中指定的信息，通过向具体块设备的设备控制器发送命令的方式，来操纵设备传输数据。这里不再赘述。</p>
<h2 id="基于磁盘I-O特性设计的技巧"><a href="#基于磁盘I-O特性设计的技巧" class="headerlink" title="基于磁盘I&#x2F;O特性设计的技巧"></a>基于磁盘I&#x2F;O特性设计的技巧</h2><p>在上一节中我们了解了Linux系统中请求到达磁盘的一次完整过程，期间Linux通过Cache以及排序合并I&#x2F;O请求来提高系统的性能。其本质就是由于磁盘随机读写慢、顺序读写快。本节针对常见开源系统阐述一些基于磁盘I&#x2F;O特性的设计技巧。</p>
<h2 id="采用追加写"><a href="#采用追加写" class="headerlink" title="采用追加写"></a>采用追加写</h2><p>在进行系统设计时，良好的读性能和写性能往往不可兼得。在许多常见的开源系统中都是优先在保证写性能的前提下来优化读性能。那么如何设计能让一个系统拥有良好的写性能呢？一个好的办法就是采用追加写，每次将数据添加到文件。由于完全是顺序的，所以可以具有非常好的写操作性能。但是这种方式也存在一些缺点：从文件中读一些数据时将会需要更多的时间：需要倒序扫描，直到找到所需要的内容。当然在一些简单的场景下也能够保证读操作的性能：</p>
<ul>
<li>数据是被整体访问，比如HDFS<ul>
<li>HDFS建立在一次写多次读的模型之上。在HDFS中就是采用了追加写并且设计为高数据吞吐量；高吞吐量必然以高延迟为代价，所以HDFS并不适用于对数据访问要求低延迟的场景；由于采用是的追加写，也并不适用于任意修改文件的场景。HDFS设计为流式访问大文件，使用大数据块并且采用流式数据访问来保证数据被整体访问，同时最小化硬盘的寻址开销，只需要一次寻址即可，这时寻址时间相比于传输时延可忽略，从而也拥有良好的读性能。HDFS不适合存储小文件，原因之一是由于NameNode内存不足问题，还有就是因为访问大量小文件需要执行大量的寻址操作，并且需要不断的从一个datanode跳到另一个datanode，这样会大大降低数据访问性能。</li>
</ul>
</li>
<li>知道文件明确的偏移量，比如Kafka<ul>
<li>在Kafka中，采用消息追加的方式来写入每个消息，每个消息读写时都会利用Page Cache的预读和后写特性，同时partition中都使用顺序读写，以此来提高I&#x2F;O性能。虽然Kafka能够根据偏移量查找到具体的某个消息，但是查找过程是顺序查找，因此如果数据很大的话，查找效率就很低。所以Kafka中采用了分段和索引的方式来解决查找效率问题。Kafka把一个patition大文件又分成了多个小文件段，每个小文件段以偏移量命名，通过多个小文件段，不仅可以使用二分搜索法很快定位消息，同时也容易定期清除或删除已经消费完的文件，减少磁盘占用。为了进一步提高查找效率，Kafka为每个分段后的数据建立了索引文件，并通过索引文件稀疏存储来降低元数据占用大小。一个段中数据对应结构如下图所示：</li>
</ul>
</li>
</ul>
<p><img src="https://user-images.githubusercontent.com/87457873/127288535-0732cf58-eb2c-40f0-9f01-538d056d5bb4.png" alt="image"></p>
<p>在面对更复杂的读场景（比如按key）时，如何来保证读操作的性能呢？简单的方式是像Kafka那样，将文件数据有序保存，使用二分查找来优化效率；或者通过建索引的方式来进行优化；也可以采用hash的方式将数据分割为不同的桶。以上的方法都能增加读操作的性能，但是由于在数据上强加了数据结构，又会降低写操作的性能。比如如果采用索引的方式来优化读操作，那么在更新索引时就需要更新B-tree中的特定部分，这时候的写操作就是随机写。那么有没有一种办法在保证写性能不损失的同时也提供较好的读性能呢？一个好的选择就是使用LSM-tree。LSM-tree与B-tree相比，LSM-tree牺牲了部分读操作，以此大幅提高写性能。</p>
<ul>
<li>日志结构的合并树LSM（The Log-Structured Merge-Tree）是HBase，LevelDB等NoSQL数据库的存储引擎。Log-Structured的思想是将整个磁盘看做一个日志，在日志中存放永久性数据及其索引，每次都添加到日志的末尾。并且通过将很多小文件的存取转换为连续的大批量传输，使得对于文件系统的大多数存取都是顺序的，从而提高磁盘I&#x2F;O。LSM-tree就是这样一种采用追加写、数据有序以及将随机I&#x2F;O转换为顺序I&#x2F;O的延迟更新，批量写入硬盘的数据结构。LSM-tree将数据的修改增量先保存在内存中，达到指定的大小限制后再将这些修改操作批量写入磁盘。因此比较旧的文件不会被更新，重复的纪录只会通过创建新的纪录来覆盖，这也就产生了一些冗余的数据。所以系统会周期性的合并一些数据，移除重复的更新或者删除纪录，同时也会删除上述的冗余。在进行读操作时，如果内存中没有找到相应的key，那么就是倒序从一个个磁盘文件中查找。如果文件越来越多那么读性能就会越来越低，目前的解决方案是采用页缓存来减少查询次数，周期合并文件也有助于提高读性能。在文件越来越多时，可通过布隆过滤器来避免大量的读文件操作。LSM-tree牺牲了部分读性能，以此来换取写入的最大化性能，特别适用于读需求低，会产生大量插入操作的应用环境。</li>
</ul>
<h2 id="文件合并和元数据优化"><a href="#文件合并和元数据优化" class="headerlink" title="文件合并和元数据优化"></a>文件合并和元数据优化</h2><p>目前的大多数文件系统，如XFS&#x2F;Ext4、GFS、HDFS，在元数据管理、缓存管理等实现策略上都侧重大文件。上述基于磁盘I&#x2F;O特性设计的系统都有一个共性特点就是都运行在这些文件系统之上。这些文件系统在面临海量时在性能和存储效率方面都大幅降低，本节来探讨下海量小文件下的系统设计。</p>
<p>常见文件系统在海量小文件应用下性能表现不佳的根本原因是磁盘最适合顺序的大文件I&#x2F;O读写模式，而非常不适合随机的小文件I&#x2F;O读写模式。主要原因体现在元数据管理低效和数据布局低效：</p>
<ul>
<li><p>元数据管理低效：由于小文件数据内容较少，因此元数据的访问性能对小文件访问性能影响巨大。Ext2文件系统中Inode和Data Block分别保存在不同的物理位置上，一次读操作需要至少经过两次的独立访问。在海量小文件应用下，Inode的频繁访问，使得原本的并发访问转变为了海量的随机访问，大大降低了性能。另外，大量的小文件会快速耗尽Inode资源，导致磁盘尽管有大量Data Block剩余也无法存储文件，会浪费磁盘空间。</p>
</li>
<li><p>数据布局低效：Ext2在Inode中使用多级指针来索引数据块。对于大文件，数据块的分配会尽量连续，这样会具有比较好的空间局部性。但是对于小文件，数据块可能零散分布在磁盘上的不同位置，并且会造成大量的磁盘碎片，不仅造成访问性能下降，还大量浪费了磁盘空间。数据块一般为1KB、2KB或4KB，对于小于4KB的小文件，Inode与数据的分开存储破坏了空间局部性，同时也造成了大量的随机I&#x2F;O。</p>
</li>
</ul>
<p>对于海量小文件应用，常见的I&#x2F;O流程复杂也是造成磁盘性能不佳的原因。对于小文件，磁盘的读写所占用的时间较少，而用于文件的open()操作占用了绝大部分系统时间，导致磁盘有效服务时间非常低，磁盘性能低下。针对于问题的根源，优化的思路大体上分为：</p>
<p>1、针对数据布局低效，采用小文件合并策略，将小文件合并为大文件。<br><br>2、针对元数据管理低效，优化元数据的存储和管理。针对这两种优化方式，业内也出现了许多优秀的开源软件。<br></p>
<p><strong>小文件合并</strong></p>
<p>小文件合并为大文件后，首先减少了大量元数据，提高了元数据的检索和查询效率，降低了文件读写的I&#x2F;O操作延时。其次将可能连续访问的小文件一同合并存储，增加了文件之间的局部性，将原本小文件间的随机访问变为了顺序访问，大大提高了性能。同时，合并存储能够有效的减少小文件存储时所产生的磁盘碎片问题，提高了磁盘的利用率。最后，合并之后小文件的访问流程也有了很大的变化，由原来许多的open操作转变为了seek操作，定位到大文件具体的位置即可。如何寻址这个大文件中的小文件呢？其实就是利用一个旁路数据库来记录每个小文件在这个大文件中的偏移量和长度等信息。其实小文件合并的策略本质上就是通过分层的思想来存储元数据。中控节点存储一级元数据，也就是大文件与底层块的对应关系；数据节点存放二级元数据，也就是最终的用户文件在这些一级大块中的存储位置对应关系，经过两级寻址来读写数据。</p>
<ul>
<li>淘宝的TFS就采用了小文件合并存储的策略。TFS中默认Block大小为64M，每个块中会存储许多不同的小文件，但是这个块只占用一个Inode。假设一个Block为64M，数量级为1PB。那么NameServer上会有 1 * 1024 * 1024 * 1024 &#x2F; 64 &#x3D; 16.7M个Block。假设每个Block的元数据大小为0.1K，则占用内存不到2G。在TFS中，文件名中包含了Block ID和File ID，通过Block ID定位到具体的DataServer上，然后DataServer会根据本地记录的信息来得到File ID所在Block的偏移量，从而读取到正确的文件内容。TFS一次读过程如下图所示：</li>
</ul>
<p><img src="https://user-images.githubusercontent.com/87457873/127288744-4fdd4239-8c8c-48cb-a5d1-2c93ccf1ebd9.png" alt="image"></p>
<p><strong>元数据管理优化</strong></p>
<p>一般来说元数据信息包括名称、文件大小、设备标识符、用户标识符、用户组标识符等等，在小文件系统中可以对元数据信息进行精简，仅保存足够的信息即可。元数据精简可以减少元数据通信延时，同时相同容量的Cache能存储更多的元数据，从而提高元数据使用效率。另外可以在文件名中就包含元数据信息，从而减少一个元数据的查询操作。最后针对特别小的一些文件，可以采取元数据和数据并存的策略，将数据直接存储在元数据之中，通过减少一次寻址操作从而大大提高性能。</p>
<ul>
<li>TFS中文件命名就隐含了位置信息等部分元数据，从而减少了一个元数据的查询操作。在Rerserfs中，对于小于1KB的小文件，Rerserfs可以将数据直接存储在Inode中。</li>
</ul>
<h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>本文从磁盘性能指标出发，探究了操作系统与磁盘的交互以及对磁盘读写的优化，最后列举了一些常用开源系统中基于磁盘I&#x2F;O特性的设计特点。期望通过展现磁盘I&#x2F;O的特性，为存储系统设计和解决一些系统性能问题提供一种新思路。</p>
<h2 id="作者简介"><a href="#作者简介" class="headerlink" title="作者简介"></a>作者简介</h2><p>喻枭，2016年加入美团，就职于美团酒店旅游事业群境内度假研发组。</p>
]]></content>
      <categories>
        <category>linux-doc 文件系统</category>
      </categories>
      <tags>
        <tag>Linux</tag>
      </tags>
  </entry>
  <entry>
    <title>虚拟文件系统</title>
    <url>/2023/01/15/linux-docs/%E6%96%87%E4%BB%B6%E7%B3%BB%E7%BB%9F/%E8%99%9A%E6%8B%9F%E6%96%87%E4%BB%B6%E7%B3%BB%E7%BB%9F/</url>
    <content><![CDATA[<h2 id="一-前言"><a href="#一-前言" class="headerlink" title="一. 前言"></a>一. 前言</h2><p>  基于上文介绍的文件系统的基本结构，本文将继续深入Linux文件系统的精髓所在：虚拟文件系统。操作文件的本质是将磁盘文件数据映射到进程中，上文的文件系统是如何存储文件数据，而从进程如何映射到该文件系统，中间还有一系列的过程，主要包括</p>
<ul>
<li>进程发出文件操作命令，通过系统调用如sys_open、sys_read、sys_write调用相应内核函数</li>
<li>在内核中为进程打开的文件和系统文件创建数据结构进行维护</li>
<li>通过虚拟文件系统对各种不同的文件系统操作，如I&#x2F;O设备、管道、进程间通信、网络等进行抽象并统一接口</li>
<li>实现虚拟文件系统和实际文件系统如ext4的挂载</li>
<li>提供文件系统和I&#x2F;O设备层的设备驱动接口及加快读写效率的缓存</li>
</ul>
<p><img src="https://user-images.githubusercontent.com/87457873/128173667-76823c0c-962a-431a-9ef0-aa6641efa53d.png" alt="image"></p>
<p>整体层次如上图所示，其实可以概括为文件系统层、通用快层和设备层，如下图所示。</p>
<p><img src="https://user-images.githubusercontent.com/87457873/128173704-455c2358-1e0d-4954-9002-378c2fd23200.png" alt="image"></p>
<ul>
<li>文件系统层，包括虚拟文件系统和其他各种文件系统的具体实现。它为上层的应用程序，提供标准的文件访问接口；对下会通过通用块层，来存储和管理磁盘数据。</li>
<li>通用块层，包括块设备 I&#x2F;O 队列和 I&#x2F;O 调度器。它会对文件系统的 I&#x2F;O 请求进行排队，再通过重新排序和请求合并，然后才要发送给下一级的设备层。</li>
<li>设备层，包括存储设备和相应的驱动程序，负责最终物理设备的 I&#x2F;O 操作。</li>
</ul>
<p>  下面就此展开详细叙述虚拟文件系统打开文件的整个过程。</p>
<h2 id="二-dentry介绍"><a href="#二-dentry介绍" class="headerlink" title="二. dentry介绍"></a>二. dentry介绍</h2><p>  在介绍从用户态调用至打开文件执行操作的流程前，我们先分析一下虚拟文件系统中的重要结构体，然后再分析映射关系的建立，以便于后文的理解。通过上文我们知道磁盘中实际的文件系统有ext4, NTFS等类型，通过超级块、块描述符、块位图、块列表等结构构成，其中一系列的文件块由文件系统对应的结构体如ext4_inode构成。虚拟文件系统是对文件系统的抽象，保存在内存之中，由dentry结构体和inode构成。</p>
<ul>
<li><p>索引节点，即 inode，用来记录文件的元数据，比如 inode 编号、文件大小、访问权限、修改日期、数据的位置等。索引节点和文件一一对应，它跟文件内容一样，都会被持久化存储到磁盘中。所以记住，索引节点同样占用磁盘空间。</p>
</li>
<li><p>目录项，即 dentry，用来记录文件的名字、索引节点指针以及与其他目录项的关联关系。多个关联的目录项，就构成了文件系统的目录结构。不过，不同于索引节点，目录项是由内核维护的一个内存数据结构，所以通常也被叫做目录项缓存。</p>
<p>inode对应于实际的索引节点如ext4_inode，而dentry则表示了不同层级之间的关系，也是链接所使用的结构体。dentry通过d_parent来和上级目录构成链接关系，通过d_op来存储对应的实际文件系统的文件操作，如创建、删除、打开、读写等。d_sb指向实际文件系统的超级块，该结构在上文已详细介绍。d_inode指向对应的inode，d_name表示该文件的文件名。</p>
</li>
</ul>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">dentry</span> &#123;</span></span><br><span class="line">......</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">hlist_bl_node</span> <span class="title">d_hash</span>;</span>	<span class="comment">/* lookup hash list */</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">dentry</span> *<span class="title">d_parent</span>;</span>	<span class="comment">/* parent directory */</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">qstr</span> <span class="title">d_name</span>;</span>    </span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">inode</span> *<span class="title">d_inode</span>;</span>		<span class="comment">/* Where the name belongs to - NULL is negative */</span>    </span><br><span class="line">    <span class="type">const</span> <span class="class"><span class="keyword">struct</span> <span class="title">dentry_operations</span> *<span class="title">d_op</span>;</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">super_block</span> *<span class="title">d_sb</span>;</span>	<span class="comment">/* The root of the dentry tree */</span>    </span><br><span class="line">......</span><br><span class="line">    <span class="class"><span class="keyword">union</span> &#123;</span></span><br><span class="line">        <span class="class"><span class="keyword">struct</span> <span class="title">list_head</span> <span class="title">d_lru</span>;</span>		<span class="comment">/* LRU list */</span></span><br><span class="line">        <span class="type">wait_queue_head_t</span> *d_wait;	<span class="comment">/* in-lookup ones only */</span></span><br><span class="line">    &#125;;</span><br><span class="line">......</span><br><span class="line">&#125; __randomize_layout;</span><br></pre></td></tr></table></figure>
<p>  除此之外，dentry有两个特殊的成员变量d_lru和d_hash。这其实关联于两张dentry cache表，顾名思义，该表保存的是一系列已分配过的dentry的缓存池，用于文件操作中快速的查找和使用。</p>
<ul>
<li><p>哈希表 dentry_hashtable：dcache 中的所有 dentry 对象都通过 d_hash 指针链到相应的 dentry 哈希链表中；</p>
</li>
<li><p>未使用的 dentry 对象链表 s_dentry_lru：dentry 对象通过其 d_lru 指针链入 LRU 链表中。</p>
</li>
</ul>
<p>  这两个列表之间会产生复杂的关系：</p>
<ul>
<li><p>引用为 0：一个在散列表中的 dentry 变成没有人引用了，就会被加到 LRU 表中去；</p>
</li>
<li><p>再次被引用：一个在 LRU 表中的 dentry 再次被引用了，则从 LRU 表中移除；</p>
</li>
<li><p>分配：当 dentry 在散列表中没有找到，则从 Slub 分配器中分配一个；</p>
</li>
<li><p>过期归还：当 LRU 表中最长时间没有使用的 dentry 应该释放回 Slub 分配器；</p>
</li>
<li><p>文件删除：文件被删除了，相应的 dentry 应该释放回 Slub 分配器；</p>
</li>
<li><p>结构复用：当需要分配一个 dentry，但是无法分配新的，就从 LRU 表中取出一个来复用。</p>
</li>
</ul>
<p><img src="https://user-images.githubusercontent.com/87457873/128173750-bb87cdc6-ec1e-4b8b-98e4-b533acf80b55.png" alt="image"></p>
<h2 id="三-文件系统挂载"><a href="#三-文件系统挂载" class="headerlink" title="三. 文件系统挂载"></a>三. 文件系统挂载</h2><p>  我们通过虚拟文件系统映射到对应的实际文件系统，该操作称之为文件系统的挂载。以ext4文件系统为例，我们需要通过 register_filesystem() 进行注册，传入的参数是 ext4_fs_type，表示注册的是 ext4 类型的文件系统，这里面最重要的一个成员变量就是 ext4_mount。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">register_filesystem(&amp;ext4_fs_type);</span><br><span class="line"></span><br><span class="line">static struct file_system_type ext4_fs_type = &#123;</span><br><span class="line">    .owner    = THIS_MODULE,</span><br><span class="line">    .name    = &quot;ext4&quot;,</span><br><span class="line">    .mount    = ext4_mount,</span><br><span class="line">    .kill_sb  = kill_block_super,</span><br><span class="line">    .fs_flags  = FS_REQUIRES_DEV,</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>  mount() 系统调用的定义如下，主要调用链为do_mount()-&gt;do_new_mount()-&gt;do_new_mount_fc()。</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">SYSCALL_DEFINE5(mount, <span class="type">char</span> __user *, dev_name, <span class="type">char</span> __user *, dir_name, <span class="type">char</span> __user *, type, <span class="type">unsigned</span> <span class="type">long</span>, flags, <span class="type">void</span> __user *, data)</span><br><span class="line">&#123;</span><br><span class="line">......</span><br><span class="line">    ret = do_mount(kernel_dev, dir_name, kernel_type, flags, options);</span><br><span class="line">......</span><br><span class="line">&#125;</span><br><span class="line">  do_new_mount_fc()先是调用vfs_create_mount()创建 <span class="class"><span class="keyword">struct</span> <span class="title">mount</span> 结构，每个挂载的文件系统都对应于这样一个结构，接着调用 <span class="title">do_add_mount</span>()完成挂载操作。</span></span><br><span class="line"><span class="class"></span></span><br><span class="line"><span class="class">/*</span></span><br><span class="line"><span class="class"> * <span class="title">Create</span> <span class="title">a</span> <span class="title">new</span> <span class="title">mount</span> <span class="title">using</span> <span class="title">a</span> <span class="title">superblock</span> <span class="title">configuration</span> <span class="title">and</span> <span class="title">request</span> <span class="title">it</span></span></span><br><span class="line"><span class="class"> * <span class="title">be</span> <span class="title">added</span> <span class="title">to</span> <span class="title">the</span> <span class="title">namespace</span> <span class="title">tree</span>.</span></span><br><span class="line"><span class="class"> */</span></span><br><span class="line"><span class="class"><span class="title">static</span> <span class="title">int</span> <span class="title">do_new_mount_fc</span>(<span class="keyword">struct</span> <span class="title">fs_context</span> *<span class="title">fc</span>, <span class="keyword">struct</span> <span class="title">path</span> *<span class="title">mountpoint</span>,</span></span><br><span class="line"><span class="class">               <span class="title">unsigned</span> <span class="title">int</span> <span class="title">mnt_flags</span>)</span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">vfsmount</span> *<span class="title">mnt</span>;</span></span><br><span class="line">......</span><br><span class="line">    mnt = vfs_create_mount(fc);</span><br><span class="line">......</span><br><span class="line">    error = do_add_mount(real_mount(mnt), mountpoint, mnt_flags);</span><br><span class="line">......</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>  首先看看fs_context结构体，该结构体用于保存超级块的信息的root，而超级块本身包含了该实际文件系统的信息，因此通过该结构体，我们可以使该文件系统和mount结构体建立联系。在旧版的Linux源码中，我们需要使用mount_fs()函数去获取对应的root，而新版则可以通过fs_context直接获取。</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">fs_context</span> &#123;</span></span><br><span class="line">......</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">dentry</span>		*<span class="title">root</span>;</span>		<span class="comment">/* The root and superblock */</span></span><br><span class="line">......</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>  接着我们来看看mount结构体和vfsmount结构体。每个文件系统会创建一个mount结构体表示其挂载的信息，其中mnt_parent指向该文件系统挂载的父文件系统，mnt_mountpoint 是装载点在父文件系统中的 dentry。vfsmount结构体中mnt_root 是当前文件系统根目录的 dentry，mnt_sb 是指向超级块的指针。这里之所以会有mnt_mountpoint和mnt_root，是因为在挂载时该文件系统的根目录同时成为了其父文件系统的一个子目录（挂载点）。</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">vfsmount</span> &#123;</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">dentry</span> *<span class="title">mnt_root</span>;</span>	<span class="comment">/* root of the mounted tree */</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">super_block</span> *<span class="title">mnt_sb</span>;</span>	<span class="comment">/* pointer to superblock */</span></span><br><span class="line">    <span class="type">int</span> mnt_flags;</span><br><span class="line">&#125; __randomize_layout;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">mount</span> &#123;</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">hlist_node</span> <span class="title">mnt_hash</span>;</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">mount</span> *<span class="title">mnt_parent</span>;</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">dentry</span> *<span class="title">mnt_mountpoint</span>;</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">vfsmount</span> <span class="title">mnt</span>;</span></span><br><span class="line">    <span class="class"><span class="keyword">union</span> &#123;</span></span><br><span class="line">        <span class="class"><span class="keyword">struct</span> <span class="title">rcu_head</span> <span class="title">mnt_rcu</span>;</span></span><br><span class="line">        <span class="class"><span class="keyword">struct</span> <span class="title">llist_node</span> <span class="title">mnt_llist</span>;</span></span><br><span class="line">    &#125;;</span><br><span class="line">......</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">list_head</span> <span class="title">mnt_mounts</span>;</span>	<span class="comment">/* list of children, anchored here */</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">list_head</span> <span class="title">mnt_child</span>;</span>	<span class="comment">/* and going through their mnt_child */</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">list_head</span> <span class="title">mnt_instance</span>;</span>	<span class="comment">/* mount instance on sb-&gt;s_mounts */</span></span><br><span class="line">    <span class="type">const</span> <span class="type">char</span> *mnt_devname;	<span class="comment">/* Name of device e.g. /dev/dsk/hda1 */</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">list_head</span> <span class="title">mnt_list</span>;</span></span><br><span class="line">......</span><br><span class="line">&#125; __randomize_layout;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>  由此，我们完成了挂载，并和目录系统dentry构成了对应关系。下面举个简单的例子。在Linux内核启动时，首先会挂载根目录文件系统，因此创建了一个mount结构体和根目录dentry。假设我们挂载一个文件系统A，该文件系统A包含一个文件夹home(由dentry表示)，则会创建一个新的mount结构体指向根目录的mount，并创建一个dentry表示该处为此文件系统A的挂载点。假设还有新的文件系统B包括了一个目录hello&#x2F;world&#x2F;data，则会采用同样的方式进行挂载和映射关系的建立，如下图所示。</p>
<p><img src="https://user-images.githubusercontent.com/87457873/128173788-c6ad273c-c404-4235-a8f8-dad091964d6b.png" alt="image"></p>
<p>在图中，我们还标出了一个结构体file，该结构体保存了指针分别指向dentry和mount，由此可以方便的进行虚拟文件系统的管理。而实际上，我们在用户态调用GLIBC函数获取的文件描述符也是直接和file结构体映射，并由此对虚拟文件系统中的文件进行方便的操作。</p>
<h2 id="四-打开-创建文件操作"><a href="#四-打开-创建文件操作" class="headerlink" title="四. 打开&#x2F;创建文件操作"></a>四. 打开&#x2F;创建文件操作</h2><p>  从用户态发起的文件操作主要包括创建、删除、打开、读写、权限管理等，这里以open()为例来解读。在系统调用一文中，我们同样以open()为例说明了其从GLIBC调用到到DO_CALL()，通过80软中断陷入内核，并最终通过查找系统调用表sys_call_talbe调用对应的系统调用do_sys_open()。本文就从do_sys_open()开始深入介绍其实现。</p>
<p>  do_sys_open()函数首先调用build_open_flags()将传递进来的flags进行解析并存在op中，接着调用get_unused_fd_flags()获取一个可用的文件描述符fd，接着调用do_file_open()创建文件结构f，并通过fd_install()将f其和文件描述符fd关联起来。这里的文件结构f即上文所述的结构体file。</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">long</span> <span class="title function_">do_sys_open</span><span class="params">(<span class="type">int</span> dfd, <span class="type">const</span> <span class="type">char</span> __user *filename, <span class="type">int</span> flags, <span class="type">umode_t</span> mode)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">open_flags</span> <span class="title">op</span>;</span></span><br><span class="line">    <span class="type">int</span> fd = build_open_flags(flags, mode, &amp;op);</span><br><span class="line">......</span><br><span class="line">    fd = get_unused_fd_flags(flags);</span><br><span class="line">    <span class="keyword">if</span> (fd &gt;= <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="class"><span class="keyword">struct</span> <span class="title">file</span> *<span class="title">f</span> =</span> do_filp_open(dfd, tmp, &amp;op);</span><br><span class="line">        <span class="keyword">if</span> (IS_ERR(f)) &#123;</span><br><span class="line">            put_unused_fd(fd);</span><br><span class="line">            fd = PTR_ERR(f);</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            fsnotify_open(f);</span><br><span class="line">            fd_install(fd, f);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    putname(tmp);</span><br><span class="line">    <span class="keyword">return</span> fd;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>  get_unused_fd_flags()函数实际调用__alloc_fd()函数，源码如下所示。这里传参files_struct来源于当前运行的task_struct中的files指针，该结构体最关键的是携带了文件描述符表struct file __rcu * fd_array[NR_OPEN_DEFAULT]。对于任何一个任务，默认情况下文件描述符 0 表示 stdin 标准输入，文件描述符 1 表示 stdout 标准输出，文件描述符 2 表示 stderr 标准错误输出，除此之外打开的文件都会从这个列表中找一个空闲位置分配给它。文件描述符列表的每一项都是一个指向 struct file 的指针，也就是说每打开一个文件都会有一个 struct file 对应。</p>
<p>  传入文件描述符表后，首先将fd赋值为files-&gt;next_fd，然后通过find_next_fd()去检查是否可用，如果不可用则会继续自增直至找到可用的文件描述符。找到之后，会将files-&gt;next_fd赋值为fd + 1以备下次使用，最后调用__set_open_fd()将fd位表的修改赋给fdt并保存。</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * allocate a file descriptor, mark it busy.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="type">int</span> __alloc_fd(<span class="keyword">struct</span> files_struct *files,</span><br><span class="line">           <span class="type">unsigned</span> start, <span class="type">unsigned</span> end, <span class="type">unsigned</span> flags)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">unsigned</span> <span class="type">int</span> fd;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">fdtable</span> *<span class="title">fdt</span>;</span></span><br><span class="line">......</span><br><span class="line">    fdt = files_fdtable(files);</span><br><span class="line">    fd = start;</span><br><span class="line">    <span class="keyword">if</span> (fd &lt; files-&gt;next_fd)</span><br><span class="line">        fd = files-&gt;next_fd;</span><br><span class="line">    <span class="keyword">if</span> (fd &lt; fdt-&gt;max_fds)</span><br><span class="line">        fd = find_next_fd(fdt, fd);</span><br><span class="line">......</span><br><span class="line">    <span class="keyword">if</span> (start &lt;= files-&gt;next_fd)</span><br><span class="line">        files-&gt;next_fd = fd + <span class="number">1</span>;</span><br><span class="line">    __set_open_fd(fd, fdt);</span><br><span class="line">......</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>  do_file_open()首先初始化了 struct nameidata 结构，该结构用于解析和查找文件路径。接着调用path_openat()，该函数会创建文件结构file，对文件路径进行解析和处理，并最终获取文件对应的索引节点inode并初始化file文件对象。</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="keyword">struct</span> file *<span class="title function_">do_filp_open</span><span class="params">(<span class="type">int</span> dfd, <span class="keyword">struct</span> filename *pathname,</span></span><br><span class="line"><span class="params">        <span class="type">const</span> <span class="keyword">struct</span> open_flags *op)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">nameidata</span> <span class="title">nd</span>;</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">file</span> *<span class="title">filp</span>;</span></span><br><span class="line">    set_nameidata(&amp;nd, dfd, pathname);</span><br><span class="line">    filp = path_openat(&amp;nd, op, flags | LOOKUP_RCU);</span><br><span class="line">......</span><br><span class="line">    restore_nameidata();</span><br><span class="line">    <span class="keyword">return</span> filp;</span><br><span class="line">&#125;</span><br><span class="line">```c</span><br><span class="line">  首先展开看看nameidata结构体，这里主要包括了如路径相关的path，last和root，虚拟文件系统的索引节点inode，标记位flags，序列号seq, m_seq，类型last_type，文件层级深度depth，链接相关的total_link_count和结构体<span class="built_in">stack</span>，文件名filename *name等。</span><br><span class="line">```c</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">nameidata</span> &#123;</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">path</span>	<span class="title">path</span>;</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">qstr</span>	<span class="title">last</span>;</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">path</span>	<span class="title">root</span>;</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">inode</span>	*<span class="title">inode</span>;</span> <span class="comment">/* path.dentry.d_inode */</span></span><br><span class="line">......</span><br><span class="line">&#125; __randomize_layout;</span><br></pre></td></tr></table></figure>
<p>  这里展开看一下结构体path，其中struct vfsmount 即上节所述的挂载变量，而dentry则为对应的目录结构体。</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">path</span> &#123;</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">vfsmount</span> *<span class="title">mnt</span>;</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">dentry</span> *<span class="title">dentry</span>;</span></span><br><span class="line">&#125; __randomize_layout;</span><br></pre></td></tr></table></figure>
<p>  path_openat()函数主要逻辑如下</p>
<ul>
<li>调用alloc_empty_filp() 生成一个 struct file 结构体，实际最终调用kmem_cache_alloc()分配，即采用前文所述的slab分配器分配；</li>
<li>调用path_init() 初始化 nameidata，准备开始节点路径查找；</li>
<li>调用link_path_walk()对于路径名逐层进行节点路径查找，这里面有一个大的循环，用“&#x2F;”分隔逐层处理。例如，文件“&#x2F;root&#x2F;hello&#x2F;world&#x2F;data”，link_path_walk 会解析前面的路径部分“&#x2F;root&#x2F;hello&#x2F;world”，解析完毕的时候 nameidata 的 dentry 为路径名的最后一部分的父目录“&#x2F;root&#x2F;hello&#x2F;world”，而 nameidata 的 filename 为路径名的最后一部分“data”。</li>
<li>调用do_last() 获取文件对应的 inode 对象，并且初始化 file 对象。</li>
<li>调用terminate_walk()返回路径保存在nd中</li>
</ul>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">static</span> <span class="keyword">struct</span> file *<span class="title function_">path_openat</span><span class="params">(<span class="keyword">struct</span> nameidata *nd,</span></span><br><span class="line"><span class="params">            <span class="type">const</span> <span class="keyword">struct</span> open_flags *op, <span class="type">unsigned</span> flags)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">file</span> *<span class="title">file</span>;</span></span><br><span class="line">    <span class="type">int</span> error;</span><br><span class="line">    file = alloc_empty_file(op-&gt;open_flag, current_cred());</span><br><span class="line">......</span><br><span class="line">        <span class="type">const</span> <span class="type">char</span> *s = path_init(nd, flags);</span><br><span class="line">        <span class="keyword">while</span> (!(error = link_path_walk(s, nd)) &amp;&amp;</span><br><span class="line">            (error = do_last(nd, file, op)) &gt; <span class="number">0</span>) &#123;</span><br><span class="line">            nd-&gt;flags &amp;= ~(LOOKUP_OPEN|LOOKUP_CREATE|LOOKUP_EXCL);</span><br><span class="line">            s = trailing_symlink(nd);</span><br><span class="line">        &#125;</span><br><span class="line">        terminate_walk(nd);</span><br><span class="line">......</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>  do_last()函数如其名字一样，完成了最后一部分的解析和处理工作。首先调用lookup_fast()查找文件路径最后一部分对应的dentry，接着使用lookup_open()判断是否需要创建新的dentry，最终将dentry赋值给path。最后调用vfs_open()真正的打开文件。</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * Handle the last step of open()</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="type">static</span> <span class="type">int</span> <span class="title function_">do_last</span><span class="params">(<span class="keyword">struct</span> nameidata *nd,</span></span><br><span class="line"><span class="params">           <span class="keyword">struct</span> file *file, <span class="type">const</span> <span class="keyword">struct</span> open_flags *op)</span></span><br><span class="line">&#123;</span><br><span class="line">......</span><br><span class="line">    error = lookup_fast(nd, &amp;path, &amp;inode, &amp;seq);</span><br><span class="line">......</span><br><span class="line">    error = lookup_open(nd, &amp;path, file, op, got_write);</span><br><span class="line">......</span><br><span class="line">    error = vfs_open(&amp;nd-&gt;path, file);</span><br><span class="line">......</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>  首先来看看lookup_fast()部分，Linux 为了提高目录项对象的处理效率，设计与实现了目录项高速缓存 dentry cache，简称 dcache，在上节中已有详细描述。lookup_fast()会在dcache中去试图找到该对应的dentry，实际最终会调用hlist_bl_for_each_entry_rcu轮询列表进行查找。</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">static</span> <span class="type">int</span> <span class="title function_">lookup_fast</span><span class="params">(<span class="keyword">struct</span> nameidata *nd,</span></span><br><span class="line"><span class="params">               <span class="keyword">struct</span> path *path, <span class="keyword">struct</span> inode **inode,</span></span><br><span class="line"><span class="params">               <span class="type">unsigned</span> *seqp)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">vfsmount</span> *<span class="title">mnt</span> =</span> nd-&gt;path.mnt;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">dentry</span> *<span class="title">dentry</span>, *<span class="title">parent</span> =</span> nd-&gt;path.dentry;</span><br><span class="line">......</span><br><span class="line">        dentry = __d_lookup_rcu(parent, &amp;nd-&gt;last, &amp;seq);</span><br><span class="line">......</span><br><span class="line">        dentry = __d_lookup(parent, &amp;nd-&gt;last);</span><br><span class="line">......</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>  lookup_open()会针对没有找到的情况创建一个新的 dentry，并且调用上一级目录的 Inode 的 inode_operations 的 lookup 函数，对于 ext4 来讲，调用的是 ext4_lookup，会到文件系统里面去找对应的ext4_inode。最终找到后将新生成的 dentry 赋给 path 变量。</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">static</span> <span class="type">int</span> <span class="title function_">lookup_open</span><span class="params">(<span class="keyword">struct</span> nameidata *nd, <span class="keyword">struct</span> path *path,</span></span><br><span class="line"><span class="params">      <span class="keyword">struct</span> file *file,</span></span><br><span class="line"><span class="params">      <span class="type">const</span> <span class="keyword">struct</span> open_flags *op,</span></span><br><span class="line"><span class="params">      <span class="type">bool</span> got_write, <span class="type">int</span> *opened)</span></span><br><span class="line">&#123;</span><br><span class="line">......</span><br><span class="line">    dentry = d_alloc_parallel(dir, &amp;nd-&gt;last, &amp;wq);</span><br><span class="line">......</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">dentry</span> *<span class="title">res</span> =</span> dir_inode-&gt;i_op-&gt;lookup(dir_inode, dentry,</span><br><span class="line">                   nd-&gt;flags);</span><br><span class="line">......</span><br><span class="line">    path-&gt;dentry = dentry;</span><br><span class="line">    path-&gt;mnt = nd-&gt;path.mnt;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">const</span> <span class="class"><span class="keyword">struct</span> <span class="title">inode_operations</span> <span class="title">ext4_dir_inode_operations</span> =</span> &#123;</span><br><span class="line">  .create    = ext4_create,</span><br><span class="line">  .lookup    = ext4_lookup,</span><br><span class="line">...</span><br></pre></td></tr></table></figure>
<p>  do_last() 的最后一步是调用 vfs_open() 真正打开文件，实际调用 f_op-&gt;open，也就是调用 ext4_file_open()。另外一件重要的事情是将打开文件的所有信息填写到 struct file 这个结构里面，从而完成了整个打开的过程。</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">vfs_open</span><span class="params">(<span class="type">const</span> <span class="keyword">struct</span> path *path, <span class="keyword">struct</span> file *file,</span></span><br><span class="line"><span class="params">       <span class="type">const</span> <span class="keyword">struct</span> cred *cred)</span></span><br><span class="line">&#123;</span><br><span class="line">  <span class="class"><span class="keyword">struct</span> <span class="title">dentry</span> *<span class="title">dentry</span> =</span> d_real(path-&gt;dentry, <span class="literal">NULL</span>, file-&gt;f_flags, <span class="number">0</span>);</span><br><span class="line">......</span><br><span class="line">  file-&gt;f_path = *path;</span><br><span class="line">  <span class="keyword">return</span> do_dentry_open(file, d_backing_inode(dentry), <span class="literal">NULL</span>, cred);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">static</span> <span class="type">int</span> <span class="title function_">do_dentry_open</span><span class="params">(<span class="keyword">struct</span> file *f,</span></span><br><span class="line"><span class="params">        <span class="keyword">struct</span> inode *inode,</span></span><br><span class="line"><span class="params">        <span class="type">int</span> (*open)(<span class="keyword">struct</span> inode *, <span class="keyword">struct</span> file *),</span></span><br><span class="line"><span class="params">        <span class="type">const</span> <span class="keyword">struct</span> cred *cred)</span></span><br><span class="line">&#123;</span><br><span class="line">......</span><br><span class="line">    f-&gt;f_mode = OPEN_FMODE(f-&gt;f_flags) | FMODE_LSEEK |</span><br><span class="line">        FMODE_PREAD | FMODE_PWRITE;</span><br><span class="line">    path_get(&amp;f-&gt;f_path);</span><br><span class="line">    f-&gt;f_inode = inode;</span><br><span class="line">    f-&gt;f_mapping = inode-&gt;i_mapping;</span><br><span class="line">......</span><br><span class="line">    f-&gt;f_op = fops_get(inode-&gt;i_fop);</span><br><span class="line">......</span><br><span class="line">    open = f-&gt;f_op-&gt;open;</span><br><span class="line">......</span><br><span class="line">    error = open(inode, f);</span><br><span class="line">......</span><br><span class="line">    f-&gt;f_flags &amp;= ~(O_CREAT | O_EXCL | O_NOCTTY | O_TRUNC);</span><br><span class="line">    file_ra_state_init(&amp;f-&gt;f_ra, f-&gt;f_mapping-&gt;host-&gt;i_mapping);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">......</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">const</span> <span class="class"><span class="keyword">struct</span> <span class="title">file_operations</span> <span class="title">ext4_file_operations</span> =</span> &#123;</span><br><span class="line">......</span><br><span class="line">    .open    = ext4_file_open,</span><br><span class="line">......</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>  我们总结一下open()函数的执行流程：其核心在于创建文件描述符和分配对应的file结构体并将二者结合起来，最后返回文件描述符以供后续使用。从这里面我们能看出虚拟文件系统所起到的作用：</p>
<ul>
<li>对每个task_struct建立一个文件描述符表管理该任务对应的文件</li>
<li>使用mount, vfsmount和dentry建立虚拟文件系统和实际文件系统的关联</li>
<li>创建file结构体来表述dentry和mount，并建立和文件描述符的关系以便使用</li>
<li>通过dentry查找对应inode，分配file结构体并完成初始化工作</li>
<li>通过虚拟文件系统和实际文件系统的映射，调用实际文件系统如ext4对应的函数完成打开操作</li>
</ul>
<p>  由此可见，虚拟文件实际是一层中间的抽象层，将具体的文件系统以及磁盘文件抽象为dentry和对应的inode，对上层的用户态封装为统一的文件描述符（磁盘文件，网络文件等），通过文件描述符和文件的绑定关系进行操作、处理。下图是对上文的一个总结。</p>
<p><img src="https://user-images.githubusercontent.com/87457873/128173860-fdfc57a0-ad94-45fd-85df-a741e87bcd86.png" alt="image"></p>
<h2 id="五-读写文件操作"><a href="#五-读写文件操作" class="headerlink" title="五. 读写文件操作"></a>五. 读写文件操作</h2><p>  有了上文的基础，文件的读写就容易理解了。首先给出读写对应的系统调用。</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">SYSCALL_DEFINE3(read, <span class="type">unsigned</span> <span class="type">int</span>, fd, <span class="type">char</span> __user *, buf, <span class="type">size_t</span>, count)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">fd</span> <span class="title">f</span> =</span> fdget_pos(fd);</span><br><span class="line">......</span><br><span class="line">    <span class="type">loff_t</span> pos = file_pos_read(f.file);</span><br><span class="line">    ret = vfs_read(f.file, buf, count, &amp;pos);</span><br><span class="line">......</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">SYSCALL_DEFINE3(write, <span class="type">unsigned</span> <span class="type">int</span>, fd, <span class="type">const</span> <span class="type">char</span> __user *, buf,</span><br><span class="line">    <span class="type">size_t</span>, count)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">fd</span> <span class="title">f</span> =</span> fdget_pos(fd);</span><br><span class="line">......</span><br><span class="line">    <span class="type">loff_t</span> pos = file_pos_read(f.file);</span><br><span class="line">      ret = vfs_write(f.file, buf, count, &amp;pos);</span><br><span class="line">......</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>  对于 read() 来讲，里面调用 vfs_read()-&gt;__vfs_read()。对于 write() 来讲，里面调用 vfs_write()-&gt;__vfs_write()。每一个打开的文件都有一个 struct file 结构。这里面有一个 struct file_operations f_op，用于定义对这个文件做的操作。__vfs_read() 会调用相应文件系统的 file_operations 里面的 read() 操作，__vfs_write() 会调用相应文件系统 file_operations 里的 write() 操作。</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">ssize_t</span> __vfs_read(<span class="keyword">struct</span> file *file, <span class="type">char</span> __user *buf, <span class="type">size_t</span> count,</span><br><span class="line">           <span class="type">loff_t</span> *pos)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">if</span> (file-&gt;f_op-&gt;read)</span><br><span class="line">        <span class="keyword">return</span> file-&gt;f_op-&gt;read(file, buf, count, pos);</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span> (file-&gt;f_op-&gt;read_iter)</span><br><span class="line">        <span class="keyword">return</span> new_sync_read(file, buf, count, pos);</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">        <span class="keyword">return</span> -EINVAL;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">static</span> <span class="type">ssize_t</span> __vfs_write(<span class="keyword">struct</span> file *file, <span class="type">const</span> <span class="type">char</span> __user *p,</span><br><span class="line">               <span class="type">size_t</span> count, <span class="type">loff_t</span> *pos)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">if</span> (file-&gt;f_op-&gt;write)</span><br><span class="line">        <span class="keyword">return</span> file-&gt;f_op-&gt;write(file, p, count, pos);</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span> (file-&gt;f_op-&gt;write_iter)</span><br><span class="line">        <span class="keyword">return</span> new_sync_write(file, p, count, pos);</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">        <span class="keyword">return</span> -EINVAL;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>  对于 ext4 文件系统来讲，内核定义了一个 ext4_file_operations。由于 ext4 没有定义 read() 和 write() 函数，于是会调用 ext4_file_read_iter() 和 ext4_file_write_iter()。ext4_file_read_iter() 会调用 generic_file_read_iter()，ext4_file_write_iter() 会调用 __generic_file_write_iter()。</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">const</span> <span class="class"><span class="keyword">struct</span> <span class="title">file_operations</span> <span class="title">ext4_file_operations</span> =</span> &#123;</span><br><span class="line">......</span><br><span class="line">    .read_iter  = ext4_file_read_iter,</span><br><span class="line">    .write_iter  = ext4_file_write_iter,</span><br><span class="line">......</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">ssize_t</span></span><br><span class="line">generic_file_read_iter(<span class="keyword">struct</span> kiocb *iocb, <span class="keyword">struct</span> iov_iter *iter)</span><br><span class="line">&#123;</span><br><span class="line">......</span><br><span class="line">    <span class="keyword">if</span> (iocb-&gt;ki_flags &amp; IOCB_DIRECT) &#123;</span><br><span class="line">......</span><br><span class="line">        <span class="keyword">struct</span> address_space *mapping = file-&gt;f_mapping;</span><br><span class="line">......</span><br><span class="line">        retval = mapping-&gt;a_ops-&gt;direct_IO(iocb, iter);</span><br><span class="line">    &#125;</span><br><span class="line">......</span><br><span class="line">    retval = generic_file_buffered_read(iocb, iter, retval);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">ssize_t</span> __generic_file_write_iter(<span class="keyword">struct</span> kiocb *iocb, <span class="keyword">struct</span> iov_iter *from)</span><br><span class="line">&#123;</span><br><span class="line">......</span><br><span class="line">    <span class="keyword">if</span> (iocb-&gt;ki_flags &amp; IOCB_DIRECT) &#123;</span><br><span class="line">......</span><br><span class="line">        written = generic_file_direct_write(iocb, from);</span><br><span class="line">......</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">......</span><br><span class="line">        written = generic_perform_write(file, from, iocb-&gt;ki_pos);</span><br><span class="line">......</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>  generic_file_read_iter() 和 __generic_file_write_iter() 有相似的逻辑，就是要区分是否用缓存。缓存其实就是内存中的一块空间。因为内存比硬盘快得多，Linux 为了改进性能，有时候会选择不直接操作硬盘，而是读写都在内存中，然后批量读取或者写入硬盘。一旦能够命中内存，读写效率就会大幅度提高。因此，根据是否使用内存做缓存，我们可以把文件的 I&#x2F;O 操作分为两种类型。</p>
<ul>
<li><p>第一种类型是缓存 I&#x2F;O。大多数文件系统的默认 I&#x2F;O 操作都是缓存 I&#x2F;O，缓存需要文件和内存页进行关联，这就要用到 address_space。address_space 的相关操作定义在 struct address_space_operations 结构中。对于 ext4 文件系统来讲， address_space 的操作定义在 ext4_aops，direct_IO 对应的函数是 ext4_direct_IO。</p>
<ul>
<li>对于读操作来讲，操作系统会先检查内核的缓冲区有没有需要的数据。如果已经缓存了，那就直接从缓存中返回；否则从磁盘中读取，然后缓存在操作系统的缓存中。</li>
<li>对于写操作来讲，操作系统会先将数据从用户空间复制到内核空间的缓存中。这时对用户程序来说，写操作就已经完成。至于什么时候再写到磁盘中由操作系统决定，除非显式地调用了 sync 同步命令。</li>
</ul>
</li>
<li><p>第二种类型是直接 IO，就是应用程序直接访问磁盘数据，而不经过内核缓冲区，从而减少了在内核缓存和用户程序之间数据复制。在读写逻辑中如果设置了IOCB_DIRECT，则会调用address_space的direct_IO函数实现。</p>
<p>ext4_direct_IO 最终会调用到 __blockdev_direct_IO-&gt;do_blockdev_direct_IO，这就跨过了缓存层，到了通用块层，最终到了文件系统的设备驱动层。由于文件系统是块设备，所以这个调用的是 blockdev 相关的函数，有关块设备驱动程序的原理我们会在设备驱动一节详细分析，这一节我们就讲到文件系统到块设备的分界线部分。</p>
</li>
</ul>
<p>  下面看看带缓冲的读写generic_perform_write()和generic_file_buffered_read()。</p>
<h3 id="5-1-带缓冲的写操作"><a href="#5-1-带缓冲的写操作" class="headerlink" title="5.1 带缓冲的写操作"></a>5.1 带缓冲的写操作</h3><p>  generic_perform_write()需要找出这次写入影响的所有的页，然后依次写入。对于每一个循环，主要做四件事情：</p>
<ul>
<li>对于每一页先调用 address_space 的 write_begin() 做一些准备；</li>
<li>调用 iov_iter_copy_from_user_atomic()将写入的内容从用户态拷贝到内核态的页中；</li>
<li>调用 address_space 的 write_end() 完成写操作；</li>
<li>调用 balance_dirty_pages_ratelimited()看脏页是否太多需要写回硬盘。所谓脏页就是写入到缓存但是还没有写入到硬盘的页面。</li>
</ul>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">ssize_t</span> <span class="title function_">generic_perform_write</span><span class="params">(<span class="keyword">struct</span> file *file,</span></span><br><span class="line"><span class="params">                <span class="keyword">struct</span> iov_iter *i, <span class="type">loff_t</span> pos)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">address_space</span> *<span class="title">mapping</span> =</span> file-&gt;f_mapping;</span><br><span class="line">    <span class="type">const</span> <span class="class"><span class="keyword">struct</span> <span class="title">address_space_operations</span> *<span class="title">a_ops</span> =</span> mapping-&gt;a_ops;</span><br><span class="line">......</span><br><span class="line">    <span class="keyword">do</span> &#123;</span><br><span class="line">        <span class="class"><span class="keyword">struct</span> <span class="title">page</span> *<span class="title">page</span>;</span></span><br><span class="line">        <span class="type">unsigned</span> <span class="type">long</span> offset;	<span class="comment">/* Offset into pagecache page */</span></span><br><span class="line">        <span class="type">unsigned</span> <span class="type">long</span> bytes;	<span class="comment">/* Bytes to write to page */</span></span><br><span class="line">......</span><br><span class="line">        status = a_ops-&gt;write_begin(file, mapping, pos, bytes, flags,</span><br><span class="line">                        &amp;page, &amp;fsdata);</span><br><span class="line">......</span><br><span class="line">        copied = iov_iter_copy_from_user_atomic(page, i, offset, bytes);</span><br><span class="line">......</span><br><span class="line">        status = a_ops-&gt;write_end(file, mapping, pos, bytes, copied,</span><br><span class="line">                        page, fsdata);</span><br><span class="line">......</span><br><span class="line">        balance_dirty_pages_ratelimited(mapping);</span><br><span class="line">    &#125; <span class="keyword">while</span> (iov_iter_count(i));</span><br><span class="line">    <span class="keyword">return</span> written ? written : status;</span><br><span class="line">&#125;</span><br><span class="line">EXPORT_SYMBOL(generic_perform_write);</span><br></pre></td></tr></table></figure>
<p>  第一步，对于ext4 来讲调用的是 ext4_write_begin()函数。ext4有着以下几种模式</p>
<ul>
<li><p>日志（Journal）模式。日志文件系统比非日志文件系统多了一个 Journal 区域。文件在 ext4 中分两部分存储，一部分是文件的元数据，另一部分是数据。元数据和数据的操作日志 Journal 也是分开管理的。你可以在挂载 ext4 的时候，选择 Journal 模式。这种模式在将数据写入文件系统前，必须等待元数据和数据的日志已经落盘才能发挥作用。这样性能比较差，但是最安全。</p>
</li>
<li><p>order 模式。这个模式不记录数据的日志，只记录元数据的日志，但是在写元数据的日志前必须先确保数据已经落盘。这个折中是默认模式。</p>
</li>
<li><p>writeback，不记录数据的日志，仅记录元数据的日志，并且不保证数据比元数据先落盘。这个性能最好，但是最不安全。</p>
<p>在 ext4_write_begin()，我们能看到对于 ext4_journal_start() 的调用就是在做日志相关的工作。在 ext4_write_begin() 中，还做了另外一件重要的事情，就是调用 grab_cache_page_write_begin()来得到应该写入的缓存页。</p>
</li>
</ul>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">static</span> <span class="type">int</span> <span class="title function_">ext4_write_begin</span><span class="params">(<span class="keyword">struct</span> file *file, <span class="keyword">struct</span> address_space *mapping,</span></span><br><span class="line"><span class="params">                <span class="type">loff_t</span> pos, <span class="type">unsigned</span> len, <span class="type">unsigned</span> flags,</span></span><br><span class="line"><span class="params">                <span class="keyword">struct</span> page **pagep, <span class="type">void</span> **fsdata)</span></span><br><span class="line">&#123;</span><br><span class="line">......</span><br><span class="line">    page = grab_cache_page_write_begin(mapping, index, flags);</span><br><span class="line">......</span><br><span class="line">    handle = ext4_journal_start(inode, EXT4_HT_WRITE_PAGE, needed_blocks);</span><br><span class="line">......</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">struct</span> page *<span class="title function_">grab_cache_page_write_begin</span><span class="params">(<span class="keyword">struct</span> address_space *mapping,</span></span><br><span class="line"><span class="params">          <span class="type">pgoff_t</span> index, <span class="type">unsigned</span> flags)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">page</span> *<span class="title">page</span>;</span></span><br><span class="line">    <span class="type">int</span> fgp_flags = FGP_LOCK|FGP_WRITE|FGP_CREAT;</span><br><span class="line">    page = pagecache_get_page(mapping, index, fgp_flags,</span><br><span class="line">        mapping_gfp_mask(mapping));</span><br><span class="line">    <span class="keyword">if</span> (page)</span><br><span class="line">      wait_for_stable_page(page);</span><br><span class="line">    <span class="keyword">return</span> page;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>  在内核中，缓存以页为单位放在内存里面，为了知道文件的哪些数据已经存放在内存中，我们需要使用address space。每一个打开的文件都有一个 struct file 结构，每个 struct file 结构都有一个 struct address_space 用于关联文件和内存，就是在这个结构里面，有一棵树用于保存所有与这个文件相关的的缓存页，这就是radix tree。我们查找的时候，往往需要根据文件中的偏移量找出相应的页面，而基数树 radix tree 这种数据结构能够快速根据一个长整型查找到其相应的对象，因而这里缓存页就放在 radix 基数树里面。pagecache_get_page() 就是根据 pgoff_t index 这个长整型，在这棵树里面查找缓存页，如果找不到就会创建一个缓存页。</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">address_space</span> &#123;</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">inode</span>    *<span class="title">host</span>;</span>    <span class="comment">/* owner: inode, block_device */</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">radix_tree_root</span>  <span class="title">page_tree</span>;</span>  <span class="comment">/* radix tree of all pages */</span></span><br><span class="line">    <span class="type">spinlock_t</span>    tree_lock;  <span class="comment">/* and lock protecting it */</span></span><br><span class="line">......</span><br><span class="line">&#125;</span><br><span class="line">  第二步，调用 iov_iter_copy_from_user_atomic()。先将分配好的页面调用 kmap_atomic() 映射到内核里面的一个虚拟地址，然后将用户态的数据拷贝到内核态的页面的虚拟地址中，调用 kunmap_atomic() 把内核里面的映射删除。</span><br><span class="line"></span><br><span class="line"><span class="type">size_t</span> <span class="title function_">iov_iter_copy_from_user_atomic</span><span class="params">(<span class="keyword">struct</span> page *page,</span></span><br><span class="line"><span class="params">    <span class="keyword">struct</span> iov_iter *i, <span class="type">unsigned</span> <span class="type">long</span> offset, <span class="type">size_t</span> bytes)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">char</span> *kaddr = kmap_atomic(page), *p = kaddr + offset;</span><br><span class="line">    iterate_all_kinds(i, bytes, v,</span><br><span class="line">      copyin((p += v.iov_len) - v.iov_len, v.iov_base, v.iov_len),</span><br><span class="line">      memcpy_from_page((p += v.bv_len) - v.bv_len, v.bv_page,</span><br><span class="line">      v.bv_offset, v.bv_len),</span><br><span class="line">      <span class="built_in">memcpy</span>((p += v.iov_len) - v.iov_len, v.iov_base, v.iov_len)</span><br><span class="line">    )</span><br><span class="line">    kunmap_atomic(kaddr);</span><br><span class="line">    <span class="keyword">return</span> bytes;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>  第三步，调用 ext4_write_end() 完成写入。这里面会调用 ext4_journal_stop() 完成日志的写入，会调用 block_write_end-&gt;__block_commit_write-&gt;mark_buffer_dirty，将修改过的缓存标记为脏页。可以看出，其实所谓的完成写入，并没有真正写入硬盘，仅仅是写入缓存后，标记为脏页。</p>
<p>  第四步，调用 balance_dirty_pages_ratelimited()，回写脏页。</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * balance_dirty_pages_ratelimited - balance dirty memory state</span></span><br><span class="line"><span class="comment"> * @mapping: address_space which was dirtied</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * Processes which are dirtying memory should call in here once for each page</span></span><br><span class="line"><span class="comment"> * which was newly dirtied.  The function will periodically check the system&#x27;s</span></span><br><span class="line"><span class="comment"> * dirty state and will initiate writeback if needed.</span></span><br><span class="line"><span class="comment">  */</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">balance_dirty_pages_ratelimited</span><span class="params">(<span class="keyword">struct</span> address_space *mapping)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">inode</span> *<span class="title">inode</span> =</span> mapping-&gt;host;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">backing_dev_info</span> *<span class="title">bdi</span> =</span> inode_to_bdi(inode);</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">bdi_writeback</span> *<span class="title">wb</span> =</span> <span class="literal">NULL</span>;</span><br><span class="line">    <span class="type">int</span> ratelimit;</span><br><span class="line">......</span><br><span class="line">    <span class="keyword">if</span> (unlikely(current-&gt;nr_dirtied &gt;= ratelimit))</span><br><span class="line">        balance_dirty_pages(mapping, wb, current-&gt;nr_dirtied);</span><br><span class="line">......</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>  在 balance_dirty_pages_ratelimited() 里面，发现脏页的数目超过了规定的数目，就调用 balance_dirty_pages()-&gt;wb_start_background_writeback()，启动一个背后线程开始回写。</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">wb_start_background_writeback</span><span class="params">(<span class="keyword">struct</span> bdi_writeback *wb)</span></span><br><span class="line">&#123;</span><br><span class="line">      <span class="comment">/*</span></span><br><span class="line"><span class="comment">       * We just wake up the flusher thread. It will perform background</span></span><br><span class="line"><span class="comment">       * writeback as soon as there is no other work to do.</span></span><br><span class="line"><span class="comment">       */</span></span><br><span class="line">      wb_wakeup(wb);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">static</span> <span class="type">void</span> <span class="title function_">wb_wakeup</span><span class="params">(<span class="keyword">struct</span> bdi_writeback *wb)</span></span><br><span class="line">&#123;</span><br><span class="line">    spin_lock_bh(&amp;wb-&gt;work_lock);</span><br><span class="line">    <span class="keyword">if</span> (test_bit(WB_registered, &amp;wb-&gt;state))</span><br><span class="line">      mod_delayed_work(bdi_wq, &amp;wb-&gt;dwork, <span class="number">0</span>);</span><br><span class="line">    spin_unlock_bh(&amp;wb-&gt;work_lock);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* bdi_wq serves all asynchronous writeback tasks */</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">workqueue_struct</span> *<span class="title">bdi_wq</span>;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * mod_delayed_work - modify delay of or queue a delayed work</span></span><br><span class="line"><span class="comment"> * @wq: workqueue to use</span></span><br><span class="line"><span class="comment"> * @dwork: work to queue</span></span><br><span class="line"><span class="comment"> * @delay: number of jiffies to wait before queueing</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * mod_delayed_work_on() on local CPU.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="type">static</span> <span class="keyword">inline</span> <span class="type">bool</span> <span class="title function_">mod_delayed_work</span><span class="params">(<span class="keyword">struct</span> workqueue_struct *wq,</span></span><br><span class="line"><span class="params">            <span class="keyword">struct</span> delayed_work *dwork,</span></span><br><span class="line"><span class="params">            <span class="type">unsigned</span> <span class="type">long</span> delay)</span></span><br><span class="line">&#123;....</span><br></pre></td></tr></table></figure>
<p>  通过上面的代码我们可以看出，bdi_wq 是一个全局变量，所有回写的任务都挂在这个队列上。mod_delayed_work() 函数负责将一个回写任务 bdi_writeback 挂在这个队列上。bdi_writeback 有个成员变量 struct delayed_work dwork，bdi_writeback 就是以 delayed_work 的身份挂到队列上的，并且把 delay 设置为 0，意思就是一刻不等，马上执行。这里的 bdi 的意思是 backing device info，用于描述后端存储相关的信息。每个块设备都会有这样一个结构，并且在初始化块设备的时候，调用 bdi_init() 初始化这个结构，在初始化 bdi 的时候，也会调用 wb_init() 初始化 bdi_writeback。</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">static</span> <span class="type">int</span> <span class="title function_">wb_init</span><span class="params">(<span class="keyword">struct</span> bdi_writeback *wb, <span class="keyword">struct</span> backing_dev_info *bdi,</span></span><br><span class="line"><span class="params">       <span class="type">int</span> blkcg_id, <span class="type">gfp_t</span> gfp)</span></span><br><span class="line">&#123;</span><br><span class="line">    wb-&gt;bdi = bdi;</span><br><span class="line">    wb-&gt;last_old_flush = jiffies;</span><br><span class="line">    INIT_LIST_HEAD(&amp;wb-&gt;b_dirty);</span><br><span class="line">    INIT_LIST_HEAD(&amp;wb-&gt;b_io);</span><br><span class="line">    INIT_LIST_HEAD(&amp;wb-&gt;b_more_io);</span><br><span class="line">    INIT_LIST_HEAD(&amp;wb-&gt;b_dirty_time);</span><br><span class="line">    wb-&gt;bw_time_stamp = jiffies;</span><br><span class="line">    wb-&gt;balanced_dirty_ratelimit = INIT_BW;</span><br><span class="line">    wb-&gt;dirty_ratelimit = INIT_BW;</span><br><span class="line">    wb-&gt;write_bandwidth = INIT_BW;</span><br><span class="line">    wb-&gt;avg_write_bandwidth = INIT_BW;</span><br><span class="line">    spin_lock_init(&amp;wb-&gt;work_lock);</span><br><span class="line">    INIT_LIST_HEAD(&amp;wb-&gt;work_list);</span><br><span class="line">    INIT_DELAYED_WORK(&amp;wb-&gt;dwork, wb_workfn);</span><br><span class="line">    wb-&gt;dirty_sleep = jiffies;</span><br><span class="line">......</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> __INIT_DELAYED_WORK(_work, _func, _tflags)      \</span></span><br><span class="line"><span class="meta">  do &#123;                \</span></span><br><span class="line"><span class="meta">    INIT_WORK(&amp;(_work)-&gt;work, (_func));      \</span></span><br><span class="line"><span class="meta">    __setup_timer(&amp;(_work)-&gt;timer, delayed_work_timer_fn,  \</span></span><br><span class="line"><span class="meta">            (unsigned long)(_work),      \</span></span><br></pre></td></tr></table></figure>
<p>  这里面最重要的是 INIT_DELAYED_WORK。其实就是初始化一个 timer，也即定时器，到时候我们就执行 wb_workfn() 这个函数。接下来的调用链为：wb_workfn-&gt;wb_do_writeback-&gt;wb_writeback-&gt;writeback_sb_inodes-&gt;__writeback_single_inode-&gt;do_writepages，写入页面到硬盘。在调用 write 的最后，当发现缓存的数据太多的时候会触发回写，这仅仅是回写的一种场景。另外还有几种场景也会触发回写：</p>
<ul>
<li>用户主动调用 sync，将缓存刷到硬盘上去，最终会调用 wakeup_flusher_threads，同步脏页；</li>
<li>当内存十分紧张，以至于无法分配页面的时候，会调用 free_more_memory，最终会调用 wakeup_flusher_threads，释放脏页；</li>
<li>脏页已经更新了较长时间，时间上超过了 timer，需要及时回写，保持内存和磁盘上数据一致性。</li>
</ul>
<h3 id="5-2-带缓冲的读操作"><a href="#5-2-带缓冲的读操作" class="headerlink" title="5.2 带缓冲的读操作"></a>5.2 带缓冲的读操作</h3><p>  带缓存的写分析完了，接下来，我们看带缓存的读，对应的是函数 generic_file_buffered_read()。</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">static</span> <span class="type">ssize_t</span> <span class="title function_">generic_file_buffered_read</span><span class="params">(<span class="keyword">struct</span> kiocb *iocb,</span></span><br><span class="line"><span class="params">    <span class="keyword">struct</span> iov_iter *iter, <span class="type">ssize_t</span> written)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">file</span> *<span class="title">filp</span> =</span> iocb-&gt;ki_filp;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">address_space</span> *<span class="title">mapping</span> =</span> filp-&gt;f_mapping;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">inode</span> *<span class="title">inode</span> =</span> mapping-&gt;host;</span><br><span class="line">    <span class="keyword">for</span> (;;) &#123;</span><br><span class="line">        <span class="class"><span class="keyword">struct</span> <span class="title">page</span> *<span class="title">page</span>;</span></span><br><span class="line">        <span class="type">pgoff_t</span> end_index;</span><br><span class="line">        <span class="type">loff_t</span> isize;</span><br><span class="line">        page = find_get_page(mapping, index);</span><br><span class="line">        <span class="keyword">if</span> (!page) &#123;</span><br><span class="line">            <span class="keyword">if</span> (iocb-&gt;ki_flags &amp; IOCB_NOWAIT)</span><br><span class="line">                <span class="keyword">goto</span> would_block;</span><br><span class="line">            page_cache_sync_readahead(mapping,</span><br><span class="line">                ra, filp,</span><br><span class="line">                index, last_index - index);</span><br><span class="line">            page = find_get_page(mapping, index);</span><br><span class="line">            <span class="keyword">if</span> (unlikely(page == <span class="literal">NULL</span>))</span><br><span class="line">                <span class="keyword">goto</span> no_cached_page;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (PageReadahead(page)) &#123;</span><br><span class="line">            page_cache_async_readahead(mapping,</span><br><span class="line">                ra, filp, page,</span><br><span class="line">            index, last_index - index);</span><br><span class="line">        &#125;</span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">     * Ok, we have the page, and it&#x27;s up-to-date, so</span></span><br><span class="line"><span class="comment">     * now we can copy it to user space...</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    ret = copy_page_to_iter(page, offset, nr, iter);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>  读取比写入总体而言简单一些，主要涉及预读的问题。在 generic_file_buffered_read() 函数中，我们需要先找到 page cache 里面是否有缓存页。如果没有找到，不但读取这一页，还要进行预读，这需要在 page_cache_sync_readahead() 函数中实现。预读完了以后，再试一把查找缓存页，应该能找到了。如果第一次找缓存页就找到了，我们还是要判断，是不是应该继续预读；如果需要，就调用 page_cache_async_readahead() 发起一个异步预读。最后，copy_page_to_iter() 会将内容从内核缓存页拷贝到用户内存空间。</p>
<p><img src="https://user-images.githubusercontent.com/87457873/128173919-4d8637fc-185d-4346-99c3-d6cea3c231e0.png" alt="image"></p>
<h2 id="六-总结"><a href="#六-总结" class="headerlink" title="六. 总结"></a>六. 总结</h2><p>  <br>  本文详细的总结了虚拟文件系统，并分析了文件操作中的打开和读写操作，由此我们完成了文件系统的框架的全部解析工作。</p>
]]></content>
      <categories>
        <category>linux-doc 文件系统</category>
      </categories>
      <tags>
        <tag>Linux</tag>
      </tags>
  </entry>
  <entry>
    <title>Linux 中的五种IO模型</title>
    <url>/2023/01/15/linux-docs/%E7%BD%91%E7%BB%9C%E5%8D%8F%E8%AE%AE%E6%A0%88/Linux%20%E4%B8%AD%E7%9A%84%E4%BA%94%E7%A7%8DIO%E6%A8%A1%E5%9E%8B/</url>
    <content><![CDATA[<p>IO模型的选择在Linux网络编程中十分重要，在Unix&#x2F;Linux环境中主要提供了五种不同的IO模型，分别是阻塞式IO、非阻塞式IO、IO多路复用、信号驱动式IO和异步IO。</p>
<p>通常一个输入操作包含两个不同阶段：</p>
<ol>
<li>等待数据准备好<br></li>
<li>从内核向进程复制数据<br></li>
</ol>
<p><img src="https://user-images.githubusercontent.com/87457873/127826956-daff612a-711e-4f92-bcb3-89000b17d6a2.png" alt="image"></p>
<p>例如，对于一个网络套接字上的输入操作，第一步通常涉及到发生系统调用，用户态切换到内核态并等待数据从网络中到达，当所有等待分组到达时，数据被复制到内核中的某个缓冲区。第二步则是将数据从内核缓冲区复制到应用进程缓冲区。</p>
<blockquote>
<p>磁盘文件的IO比较特殊，内核采用缓冲区cache加速磁盘IO请求。因而一旦请求的数据到达内核缓冲区cache，对磁盘的write()操作立即返回，而不用等待将数据写入磁盘后再返回（除非在打开文件时指定了O_SYNC标志）。与之相对应的read()操作将数据从内核缓冲区cache移动到用户的缓冲区中，如果请求的数据不在内核缓冲区cache中，内核会让进程休眠，同时执行对磁盘的读操作。所以实际上在磁盘IO中，等待阶段是不存在的，因为磁盘文件并不像网络IO那样，需要等待远程传输数据。</p>
</blockquote>
<h2 id="阻塞式I-O模型"><a href="#阻塞式I-O模型" class="headerlink" title="阻塞式I&#x2F;O模型"></a>阻塞式I&#x2F;O模型</h2><p><img src="https://user-images.githubusercontent.com/87457873/127827045-ba456dab-4e96-4c38-a572-e6337824e476.png" alt="image"></p>
<p>Linux中，默认情况下所有的socket都是阻塞的。这里有必要辨析以下阻塞和非阻塞这两个概念，这两个概念描述的是用户线程调用内核I&#x2F;O操作的方式，其中阻塞是指I&#x2F;O操作需要彻底完成后才返回到用户空间；而非阻塞则是指I&#x2F;O操作被调用后立即返回给用户一个状态值，不需要等到I&#x2F;O操作彻底完成。</p>
<p>除非特别指定，几乎所有的I&#x2F;O接口都是阻塞型的，即系统调用时不返回调用结果，只有当该系统调用获得结果或者超时出错才返回。这样的机制给网络编程带来了较大的影响，当线程因处理数据而处于阻塞状态时，线程将无法执行任何运算或者相应任何网络请求。</p>
<ul>
<li>改进方案</li>
</ul>
<p>在服务器端使用阻塞I&#x2F;O模型时结合多进程&#x2F;多线程技术。让每一个连接都拥有独立的进程&#x2F;线程，任何一个连接的阻塞都不会影响到其他连接。（选择多进程还是多线程并无统一标准，因为进程的开销远大于线程，所以在连接数较大的情况下推荐使用多线程。而进程相较于线程具有更高的安全性，所以如果单个服务执行体需要消耗较多的CPU资源，如需要进行大规模或长时间的数据运算或文件访问推荐使用多进程）。</p>
<p>当连接数规模继续增大，无论使用多线程还是多进程都会严重占据系统资源，降低系统对外界的响应效率，线程或者进程本身也更容易陷入假死。此时可以采用“线程池”或“连接池”来降低创建和销毁进程&#x2F;线程的频率，减少系统开销。</p>
<h2 id="非阻塞式I-O模型"><a href="#非阻塞式I-O模型" class="headerlink" title="非阻塞式I&#x2F;O模型"></a>非阻塞式I&#x2F;O模型</h2><p><img src="https://user-images.githubusercontent.com/87457873/127827107-819785fd-e73d-4a88-a018-80179575931f.png" alt="image"></p>
<p>进程把一个套接字设置成非阻塞是在通知内核：当请求的I&#x2F;O操作非得把本进程投入睡眠才能完成时，不要把本进程投入睡眠，而是返回一个错误。 因此如果在打开文件时设定了O_NONBLOCK标志，则会以非阻塞方式打开文件。如果I&#x2F;O系统调用不能立即完成，则会返回错误而不是阻塞进程。非阻塞式I&#x2F;O可以实现周期性检查（轮询）某个文件描述符是否可执行I&#x2F;O操作。比如，设定一个输入文件描述符为非阻塞式的，然后周期性的执行非阻塞式读操作。如果需要同时检测多个文件描述符，则将其都设为非阻塞，然后一次轮询。但是这种轮询的效率不高，在轮询频率不高的情况下，程序响应I&#x2F;O事件的延迟将难以接受。换句话说，在一个紧凑的循环中做轮询就是在浪费CPU时间，因为多数时间调用会立即出错并返回。</p>
<blockquote>
<p>对于不能满足非阻塞式I&#x2F;O操作，System V会返回EAGAIN错误而源于Berkeley的4.3BSD返回EWOULDBLOCK。如今大多数系统都把这两个错误码定义为相同的值。（可查看&lt;sys&#x2F;errno.h&gt;）</p>
</blockquote>
<p>如果不希望进程在对文件描述符执行I&#x2F;O操作时被阻塞，则可以结合使用多进程&#x2F;多线程技术，创建一个新的进程来执行I&#x2F;O操作，而父进程则可以去做其他工作，子进程将阻塞到I&#x2F;O操作完成。当有多个文件描述符进行I&#x2F;O操作时，就需要创建多个子进程。当子进程收到文件结束符，那么该子进程将会终止，父进程收到SIGCHLD信号，但是当父进程终止，那么父进程应通知子进程停止，为此可以使用一个信号如SUGUSR1，这使得这种方法的开销将十分昂贵且复杂。使用多线程而不是多进程的方式将减少资源的占用，并有效简化程序设计。但线程之间仍然需要处理同步的问题，当面对大量并发客户线程时，但是这也使得程序编写十分复杂。</p>
<h2 id="I-O多路复用模型"><a href="#I-O多路复用模型" class="headerlink" title="I&#x2F;O多路复用模型"></a>I&#x2F;O多路复用模型</h2><p><img src="https://user-images.githubusercontent.com/87457873/127828345-ca062966-dfd9-4c80-86c0-539e723ddb7f.png" alt="image"></p>
<p>I&#x2F;O多路复用（也叫做事件驱动I&#x2F;O）通过系统调用select()、poll、或者epoll()实现进程同时检查多个文件描述符，以找出其中任何一个是否可执行I&#x2F;O操作。通过上图可以看出I&#x2F;O多路复用与阻塞I&#x2F;O模型差别并不大，事实上还要差一些，因为这里使用了两个系统调用而阻塞I&#x2F;O只是用了一个系统调用。但是I&#x2F;O多路复用的优势是其可以同时处理多个连接。因此如果处理的连接数不是特别多的情况下使用I&#x2F;O多路复用模型的web server不一定比使用多线程技术的阻塞I&#x2F;O模型好。</p>
<p>select()和poll()的原理基本相同：<br></p>
<ol>
<li>注册待侦听的fd(这里的fd创建时最好使用非阻塞)<br></li>
<li>每次调用都去检查这些fd的状态，当有一个或者多个fd就绪的时候返回<br></li>
<li>返回结果中包括已就绪和未就绪的fd<br></li>
</ol>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">select</span> <span class="params">(<span class="type">int</span> maxfdp, fd_set *readfds, fd_set *writefds, fd_set *errorfds, <span class="keyword">struct</span> timeval *timeout)</span>;</span><br></pre></td></tr></table></figure>
<h3 id="select"><a href="#select" class="headerlink" title="select"></a>select</h3><ul>
<li>maxfdp 指集合中所有文件描述符的范围，即所有文件描述符的最大值+1</li>
<li>readfds、writefds、errorfds 指向文件描述符集合的指针，分别检测输入、输出是否就绪和异常情况是否发生</li>
<li>timeout 时select()的超时时间，控制着select()的阻塞行为</li>
</ul>
<blockquote>
<p>readfds、writefds、errorfds所指结构体都是保存结果的地方，在调用select()之前，这些参数指向的结构体必须初始化以包含我们所感兴趣的文件描述符集合。之后select()会修改这些结构体，当其返回时他们包含的就是处于就绪态的文件描述符集合。</p>
</blockquote>
<p>当timeout设为NULL或者其指向的结构体字段非零时，select()将阻塞到有下列事件发生<br></p>
<ol>
<li>readfds、writefds、errorfds 中指定的文件描述符中至少有一个成为就绪态（NULL）<br></li>
<li>该调用被信号处理程序中断<br></li>
<li>timeout中指定的时间上限已超时<br></li>
</ol>
<p>select()的返回值<br><br>当select()函数返回-1表示出错，错误码包括EBADF表示存在非法文件描述符，EINTR表示该调用被信号处理程序中断了（select不会自动恢复）。返回0表示超时，此时每个文件描述符集合都会被清空。返回一个正整数表示准备就绪的文件描述符个数，如果同一个文件描述符在返回的描述符集中出现多次，select会将其统计多次。</p>
<blockquote>
<p>一个文件描述符是否阻塞并不影响select()是否阻塞，也就是说如果希望读一个非阻塞文件描述符，并且以5s为超时值调用select()，则select()最多阻塞5s。同理若是指定超时值为NULL，则在该描述符就绪或者捕捉到一个信号之前select()会一直阻塞。</p>
</blockquote>
<p>所有关于文件描述符集合的操作都是通过以下四个宏完成，除此之外，常量FD_SETSIZE规定了文件描述符的最大容量。</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/select.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">FD_ZERO</span><span class="params">(fd_set *fdset)</span>; <span class="comment">//将fdset所指集合初始化为空</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">FD_SET</span><span class="params">(<span class="type">int</span> fd, fd_set *fdset)</span>; <span class="comment">//将文件描述符fd添加到由fdset指向的集合中</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">FD_CLR</span><span class="params">(<span class="type">int</span> fd, fd_set *fdset)</span>; <span class="comment">//将文件描述符fd从fdset所指集合中移出</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">FD_ISSET</span><span class="params">(<span class="type">int</span> fd, fd_set *fdset)</span>; <span class="comment">//检测fd是否是fdset所指集合成员</span></span><br></pre></td></tr></table></figure>

<h3 id="poll"><a href="#poll" class="headerlink" title="poll"></a>poll</h3><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;poll.h&gt;</span></span></span><br><span class="line"><span class="type">int</span> <span class="title function_">poll</span> <span class="params">(<span class="keyword">struct</span> pollfd fds[], <span class="type">nfds_t</span> nfds, <span class="type">int</span> timeout)</span>;</span><br></pre></td></tr></table></figure>

<p>poll和select的任务很相似，主要区别在于我们如何指定待检查的文件描述符（程序接口不同）。poll不为每个条件构造一个描述符集合，而是构造了一个pollfd结构的数组，每个数组元素指定一个描述符编号以及我们对该描述符感兴趣的条件。</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">pollfd</span> &#123;</span></span><br><span class="line">  <span class="type">int</span> fd; <span class="comment">//文件描述符</span></span><br><span class="line">  <span class="type">short</span> events; <span class="comment">//等待的事件</span></span><br><span class="line">  <span class="type">short</span> revents; <span class="comment">//实际发生了的事件</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>每个pollfd结构体指定了一个被监视的文件描述符，可以传递多个结构体，指示poll()监视多个文件描述符。每个结构体的events域是监视该文件描述符的事件掩码，由用户来设置这个域的属性。revents域是文件描述符的操作结果事件掩码，内核在调用返回时设置这个域，并且events中请求的任何事件都可能在revents中返回。</p>
<p>参数timeout的设置与select()中有所不同（poll的timeout参数是一个整型而select是一个结构体）。</p>
<p>1、当timeout等于-1时，表示无限超时。poll会一直阻塞到fds数组中列出的文件描述符有一个达到就绪态（定义在对应的events字段中）或者捕捉到一个信号<br><br>2、当timeout等于0时，poll不会阻塞——只执行一次检查看看哪个文件描述符已经就绪<br><br>3、当timeout大于0时，poll至多阻塞timeout毫秒数，无论IO是否准备好，poll都会返回<br></p>
<p>poll的返回值<br><br>当poll()函数返回-1表示出错，错误码包括EBADF表示存在非法文件描述符，EINTR表示该调用被信号处理程序中断了（poll不会自动恢复）。返回0表示超时。返回一个正整数表示准备就绪的文件描述符个数，与select不同，poll返回的就是就绪文件描述符的个数每个文件描述符只统计一次。</p>
<h3 id="select-和poll-的区别"><a href="#select-和poll-的区别" class="headerlink" title="select()和poll()的区别"></a>select()和poll()的区别</h3><p>Linux实现层面</p>
<p>select()和poll()都使用了相同的内核轮询（poll）程序集合，与系统调用poll()本身不同，内核的每个poll例程都返回有关单个文件描述符就绪的信息，这个信息以位掩码的形式返回，其值同poll()系统调用返回的revent字段中的比特值相关。poll()系统调用的实现包括为每个文件描述符调用内核poll例程，并将结果信息填入到对应的revents字段中。对于系统调用select()则可以使用一组宏将内核poll例程返回的信息转化为由select()返回的与之对应的事件集合。</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">define</span> POLLIN_SET (POLLIN | POLLRDNORM | POLLRDBAND | POLLHUP | POLLERR) <span class="comment">/*读就绪*/</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> POLLOUT_SET (POLLOUT | POLLWRNORM | POLLWRBAND | POLLERR) <span class="comment">/*写就绪*/</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> POLLEX_SET (POLLPRI) <span class="comment">/*异常*/</span></span></span><br></pre></td></tr></table></figure>
<p>以上宏定义展现了select()和poll()返回信息间的语义关系，唯一一点不同是如果被检查的文件描述符中有一个关闭了，poll()在revent字段中返回POLLNVAL，而select()返回-1并把错误码置为EBADF。</p>
<p>API设计层面</p>
<p>1、select()使用的数据类型fd_set对于被检查的文件描述数量有一个上限（FD_SETSIZE）。相对也较小（1024&#x2F;2048），如果要修改这个默认值需要重新编译内核。与之相反，poll()没有对于被检查文件描述符的数量限制。<br><br>2、由于select()的参数fd_set同时也是保存结果的地方，在select()返回之后会发生变化，所以每当在下一次进入select()之前需要重新初始化fd_set。poll()通过两个独立的字段events和revents将监控的输入输出分开，允许被监控的文件数组被复用而不需要重新初始化。<br><br>3、select()提供的超时精度（微妙）比poll()提供的超时精度（毫秒）高。<br><br>4、select()的超时参数在返回时也是未定义的，考虑到可移植性，每次在超时之后在下一次进入到select()之前都需要重新设置超时参数。<br><br>5、poll()不要求开发者计算最大文件描述符时进行+1操作<br></p>
<p>性能层面</p>
<p>在待检查文件描述符范围较小（最大文件描述符较低），或者有大量文件描述符待检查，但是其分布比较密集时poll()和select()性能相似。<br><br>在被检查文件描述符集合很稀疏的情况，poll()要优于select()。</p>
<h3 id="select-和poll-的不足"><a href="#select-和poll-的不足" class="headerlink" title="select()和poll()的不足"></a>select()和poll()的不足</h3><p>1、IO效率随着文件描述符的数量增加而线性下降。每次调用select()或poll()内核都要检查所有的被指定的文件描述符的状态（但是实际上只有部分的文件描述符会是活跃的），当有文件描述符集合增大时，IO的效率也随之下降。<br><br>2、当检查大量文件描述符时，用户空间和内核空间消息传递速度较慢。每次调用select()或poll()时，程序都必须传递一个表示所有需要被检查的文件描述符的数据结构到内核，在内核完成检查之后，修个这个数据结构并返回给程序。（此外select()每次调用之前还需要初始化该数据结构）对于poll()调用需要将用户传入的pollfd数组拷贝到内核空间，这是一个O(n)的操作。当事件发生后，poll()将获得的数据传送到用户空间，并执行释放内存和剥离等待队列等工作同样是O(n)的操作。因此随着文件描述符的增加消息传递速度会逐步下降。对于select()来说，传递的数据结构大小固定为FD_SETSIZE，与待检查的文件描述符数量无关。<br><br>3、select()或poll()调用完成之后，程序必须检查返回的数据结构中每个元素，已确定那个文件描述符处于就绪态<br><br>4、select()对一个进程打开的文件描述符数目有上限值，而且较少（1024&#x2F;2048）。<br></p>
<h3 id="epoll"><a href="#epoll" class="headerlink" title="epoll"></a>epoll</h3><p>epoll API是Linux专有的特性，相较于select和poll，epoll更加灵活且没有描述符限制。epoll设计也与select和poll不同，主要包含以下三个接口：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/epoll.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">epoll_create</span><span class="params">(<span class="type">int</span> size)</span>; <span class="comment">//创建一个epoll句柄</span></span><br></pre></td></tr></table></figure>

<p>参数size指定内核需要监听的文件描述符个数，但该参数与select中的maxfdp不同，并非一个上限（Linux 2.6.8以后该参数被忽略不用）。此外函数返回代表新创建的epoll句柄的文件描述符（在Linux下查看&#x2F;proc&#x2F;进程的id&#x2F;fd&#x2F;可看到该fd的值），因此当不再使用该文件描述符时应该通过close()关闭，当所用与epoll句柄相关的文件描述符都关闭时，该句柄被销毁并被系统回收其资源。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">#include &lt;sys/epoll.h&gt;</span><br><span class="line"></span><br><span class="line">int epoll_ctl(int epfd, int op, int fd, struct epoll_event *ev); //修改兴趣列表（事件注册函数）</span><br></pre></td></tr></table></figure>

<p>与select()的在监听事件时告诉内核需要监听的事件类型不同，epoll()需要先注册要监听的事件类型。参数op表示要执行的动作通过三个宏表示：1.EPOLL_CTL_ADD注册新的fd到epfd中；1.EPOLL_CTL_MOD修改已经注册的fd的监听事件；3.EPOLL_CTL_DEL从epfd中删除一个fd。参数fd表示需要监听的fd。最后一个参数ev指向结构体epoll_event则是告诉内核需要监听的事件类型，定义如下：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">epoll_event</span> &#123;</span></span><br><span class="line">  <span class="type">uint32_t</span> events; <span class="comment">//epoll events (bit mask)</span></span><br><span class="line">  <span class="type">epoll_data_t</span> data; <span class="comment">//user data variable</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>其中data的类型为：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">union</span> <span class="title">epoll_data</span> &#123;</span></span><br><span class="line">  <span class="type">void</span>    *ptr; <span class="comment">//pointer to user defined data</span></span><br><span class="line">  <span class="type">int</span>     fd; <span class="comment">//file descriptor</span></span><br><span class="line">  uint_32 u32; <span class="comment">//32-bit integer</span></span><br><span class="line">  uint_64 u64; <span class="comment">//64-bit integer</span></span><br><span class="line">&#125; <span class="type">epoll_data_t</span>;</span><br></pre></td></tr></table></figure>
<p>其中字段event表示事件掩码指定待监听的文件描述符fd上所感兴趣的事件集合，除了增加了一个前缀E外，这些掩码的名称与poll中对应名称相同（两个例外EPOLLET表示设置为边缘触发、EPOLLONESHOT表示只监听一次）。data字段是一个联合体，当描述符fd就绪后，联合体成员可以用来指定传回给调用进程的信息。data字段是唯一可以获知同这个事件相关的文件描述符的途径，因此调用epoll_ctl()将文件描述符添加到兴趣列表中时，应该要么将ev.data.fd设为文件描述符，要么将ev.data.ptr设为指向包含该文件描述的结构体。</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/epoll.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">epoll_wait</span><span class="params">(<span class="type">int</span> epfd, <span class="keyword">struct</span> epoll_event *evlist, <span class="type">int</span> maxevents, <span class="type">int</span> timeout)</span>;</span><br></pre></td></tr></table></figure>

<p>等待事件的产生，参数evlist所指向的结构体数组中返回就需文件描述的信息，数组evlist的空间由调用者负责申请，所包含的元素个数由参数maxevents指定。</p>
<h3 id="epoll的实现原理（以网络socket监听为例）"><a href="#epoll的实现原理（以网络socket监听为例）" class="headerlink" title="epoll的实现原理（以网络socket监听为例）"></a>epoll的实现原理（以网络socket监听为例）</h3><p>在linux，一切皆文件．所以当调用epoll_create时，内核给这个epoll分配一个文件描述符，但是这个不是普通的文件，而是只服务于epoll．</p>
<p>所以当内核初始化epoll时，会开辟一块内核高速cache区，用于安置我们监听的socket，这些socket会以红黑树的形式保存在内核的cache里，以支持快速的查找，插入，删除．同时，建立了一个list链表，用于存储准备就绪的事件．所以调用epoll_wait时，在timeout时间内，只是简单的观察这个list链表是否有数据，如果没有，则睡眠至超时时间到返回；如果有数据，则在超时时间到，拷贝至用户态events数组中．</p>
<p>那么，这个准备就绪list链表是怎么维护的呢？<br><br>当我们执行epoll_ctl()时，除了把socket放到epoll文件系统里file对象对应的红黑树上之外，还会给内核中断处理程序注册一个回调函数，告诉内核，如果这个句柄的中断到了，就把它放到准备就绪list链表里。所以，当一个socket上有数据到了，内核在把网卡上的数据copy到内核中后就来把socket插入到准备就绪链表里了。</p>
<p>epoll支持两种模式LT(水平触发)和ET(边缘触发)，LT模式下，主要缓冲区数据一次没有处理完，那么下次epoll_wait返回时，还会返回这个句柄；而ET模式下，缓冲区数据一次没处理结束，那么下次是不会再通知了，只在第一次返回．所以在ET模式下，一般是通过while循环，一次性读完全部数据．epoll默认使用的是LT．</p>
<p>这件事怎么做到的呢？当一个socket句柄上有事件时，内核会把该句柄插入上面所说的准备就绪list链表，这时我们调用epoll_wait，会把准备就绪的socket拷贝到用户态内存，然后清空准备就绪list链表，最后，epoll_wait干了件事，就是检查这些socket，如果不是ET模式（就是LT模式的句柄了），并且这些socket上确实有未处理的事件时，又把该句柄放回到刚刚清空的准备就绪链表了。所以，非ET的句柄，只要它上面还有事件，epoll_wait每次都会返回。而ET模式的句柄，除非有新中断到，即使socket上的事件没有处理完，也是不会次次从epoll_wait返回的．</p>
<p>经常看到比较ET和LT模式到底哪个效率高的问题．有一个回答是说ET模式下减少epoll系统调用．这话没错，也可以理解，但是在ET模式下，为了避免数据饿死问题，用户态必须用一个循环，将所有的数据一次性处理结束．所以在ET模式下下，虽然epoll系统调用减少了，但是用户态的逻辑复杂了，write&#x2F;read调用增多了．所以这不好判断，要看用户的性能瓶颈在哪．</p>
<h3 id="epoll设计的特点"><a href="#epoll设计的特点" class="headerlink" title="epoll设计的特点"></a>epoll设计的特点</h3><p>1、功能分离<br><br>socket低效的原因之一便是将“维护等待队列”和“阻塞进程”两个功能不加分离，每次调用 select 都需要这两步操作，然而大多数应用场景中，需要监视的 socket 相对固定，并不需要每次都修改。epoll 将这两个操作分开，先用epoll_ctl()维护等待队列，再调用 epoll_wait 阻塞进程。显而易见地，效率就能得到提升。</p>
<p><img src="https://user-images.githubusercontent.com/87457873/127828408-034ea5dc-b86f-4014-8291-10cc05d025f3.png" alt="image"></p>
<p>而epoll则是实现了功能分离，通过epoll_create()创建一个 epoll 对象 epfd，再通过epoll_ctl()将需要监视的 socket 添加到 epfd 中，最后调用 epoll_wait() 等待数据使得epoll有了优化的可能。</p>
<p>2、就绪列表<br><br>select 低效的另一个原因在于程序不知道哪些 socket 收到数据，只能一个个遍历。如果内核维护一个“就绪列表”，引用收到数据的 socket，就能避免遍历。如下图所示，计算机共有三个 socket，收到数据的 sock2 和 sock3 被就绪列表 rdlist 所引用。当进程被唤醒后，只要获取 rdlist 的内容，就能够知道哪些 socket 收到数据。</p>
<p><img src="https://user-images.githubusercontent.com/87457873/127828469-df0914b1-dff1-4f43-907a-225ac483bb03.png" alt="image"></p>
<h3 id="epoll的实现细节"><a href="#epoll的实现细节" class="headerlink" title="epoll的实现细节"></a>epoll的实现细节</h3><p>epoll主要由两个结构体：eventpoll与epitem。epitem是每一个IO所对应的的事件。比如 epoll_ctl()的EPOLL_CTL_ADD操作的时候，就需要创建一个epitem。eventpoll是每一个epoll所对应的。比如epoll_create就是创建一个eventpoll。如下图所示，eventpoll 包含了 lock、mtx、wq（等待队列）与 rdlist 等成员，其中 rdlist 和 rbr 是我们所关心的。</p>
<p><img src="https://user-images.githubusercontent.com/87457873/127828664-517706d2-58b9-4a11-bea7-59b0a2d84234.png" alt="image"></p>
<ul>
<li>就绪列表的数据结构（rdlist）<br>就绪列表引用着就绪的 socket，所以它应能够快速的插入数据。</li>
</ul>
<p>程序可能随时调用 epoll_ctl() 添加监视 socket，也可能随时删除。当删除时，若该 socket 已经存放在就绪列表中，它也应该被移除。所以就绪列表应是一种能够快速插入和删除的数据结构。</p>
<p>双向链表就是这样一种数据结构，epoll 使用双向链表来实现就绪队列。</p>
<ul>
<li>索引结构（rbr)<br>既然 epoll 将“维护监视队列”和“进程阻塞”分离，也意味着需要有个数据结构来保存监视的 socket，至少要方便地添加和移除，还要便于搜索，以避免重复添加。红黑树是一种自平衡二叉查找树，搜索、插入和删除时间复杂度都是O(log(N))，效率较好，epoll 使用了红黑树作为索引结构（对应上图的 rbr）。</li>
</ul>
<p>注：因为操作系统要兼顾多种功能，以及由更多需要保存的数据，rdlist 并非直接引用 socket，而是通过 epitem 间接引用，红黑树的节点也是 epitem 对象。同样，文件系统也并非直接引用着 socket。为方便理解，本文中省略了一些间接结构。</p>
<h3 id="epoll的优点"><a href="#epoll的优点" class="headerlink" title="epoll的优点"></a>epoll的优点</h3><p>1、没有最大打开文件描述符限制<br><br>epoll支持的最大打开文件数与系统内存相关，可通<br>过cat &#x2F;proc&#x2F;sys&#x2F;fs&#x2F;file-max查看具体数目<br><br>2、IO效率不随文件描述符数目增加而线性下降<br><br>传统的select&#x2F;poll在拥有较大的一个socket集合时，不过由于网络延迟，任意时间只有部分socket是活跃的，但是select&#x2F;poll每次调用都会线性扫描全部的集合，导致效率呈线性下降。而epoll通过在内核中实现的根据每个文件描述符上的回调函数callback函数实现了每次只对“活跃的”的socket进行操作，从而使epoll实现了一个伪AIO，使其效率不会随文件描述符的增加而先行下降。<br><br>3、使用mmap加速内核与用户空间的消息传递<br><br>select、poll和epoll都需要内核把fd消息通知给用户空间，但是epoll采用了内核与用户空间mmap处于同一块内存来实现，具有较高的效率。<br></p>
<h2 id="信号驱动式I-O模型"><a href="#信号驱动式I-O模型" class="headerlink" title="信号驱动式I&#x2F;O模型"></a>信号驱动式I&#x2F;O模型</h2><p><img src="https://user-images.githubusercontent.com/87457873/127829018-be125f77-6a05-497b-ab7d-a7d3927a1e33.png" alt="image"></p>
<p>信号驱动I&#x2F;O中，当文件描述符上可执行I&#x2F;O操作时，进程请求内核为自己发送一个信号，之后进程可以执行其他任务直到I&#x2F;O就绪为止，此时内核会发送信号给进程。建立一个针对套接字的信号驱动式I&#x2F;O需要进程执行以下三个步骤：</p>
<ol>
<li>建立SIGIO信号处理函数 2. 设置该套接字的属主，通常使用fcntl的F_SETOWN命令设置 3. 开启该套接字的信号驱动式I&#x2F;O，通常通过使用fcnt的F_SETFL命令打开O_ASYNC标志完成</li>
</ol>
<p>使用信号驱动式I&#x2F;O模型的主要优点是在等待数据到达期间，进程不会被阻塞。</p>
<h3 id="信号驱动式I-O的应用"><a href="#信号驱动式I-O的应用" class="headerlink" title="信号驱动式I&#x2F;O的应用"></a>信号驱动式I&#x2F;O的应用</h3><ul>
<li>对于UDP上的使用比较简单，SIGIO信号只有在数据报到达套接字或者套接字发生异步错误时产生。因此当捕获对于某个UDP套接字的SIGIO信号时，我们调用recvfrom或者读入到达的数据报或者获取发生的异步错误。</li>
<li>信号驱动式I&#x2F;O对于TCP套接字几乎无用，主要原因是SIGIO信号产生会过于频繁，并且其出现并没有告知我们发生了什么事件。比如，当一个进程既读又写一个TCP套接字时，当有数据到达或者当前写出的数据得到确认时，SIGIO信号都会产生，而信号处理函数无法区分这两种情况。 &gt; 应该只考虑对监听TCP套接字使用SIGIO，因为对于监听TCP套接字产生SIGIO的唯一条件是某个新连接的完成。</li>
</ul>
<p>实际上I&#x2F;O多路复用、信号驱动I&#x2F;O以及epoll都是用来实现同一个目标的技术——同时检查多个文件描述符是否准备好执行I&#x2F;O操作（准确的说是看I&#x2F;O系统调用是否可以非阻塞地执行）。文件描述符就绪状态的转化是通过一些I&#x2F;O事件来触发的，如输入数据到达、套接字连接建立完成或者是之前满载的套接字发送缓冲区在TCP将队列中的数据传送到对端之后有了剩余空间。但是以上这三种技术都不会实际执行I&#x2F;O操作，只会告诉我们某个文件描述符已经处于就绪状态，此时我们还需要调用其他系统调用来实际完成I&#x2F;O操作。AIO技术是POSIX异步I&#x2F;O，其允许进程将I&#x2F;O操作排列到一个文件中，当操作完成后得到通知，其优点是最初的I&#x2F;O调用会立刻返回，进程不会一直等待数据传达到内核或者等待操作完成。这使得进程可以同I&#x2F;O操作一起并行处理其他任务。</p>
<h2 id="I-O模型的技术选择"><a href="#I-O模型的技术选择" class="headerlink" title="I&#x2F;O模型的技术选择"></a>I&#x2F;O模型的技术选择</h2><ul>
<li>select()和poll()可移植性高但是当同时检查大量的文件描述符时性能延展性不佳。</li>
<li>epoll()关键优势是可以高效的检查大量文件描述符，但是可移植性差属于只能用于Linux的API。</li>
<li>信号驱动I&#x2F;O和epoll一样可以高效的检查大量文件描述符，但是epool具有许多信号驱动i&#x2F;O不具备的优势。<ul>
<li>避免了处理信号的复杂性</li>
<li>可以指定想要检查的事件类型（读就绪或者写就绪）</li>
<li>可以选择水平触发或者边缘触发的形式来通知进程。</li>
<li>如要用到信号驱动I&#x2F;O的优点需要用到不可移植的Linux的专有特性，如此其可移植性也不会优于epoll。<blockquote>
<p>通过以上总结可知，select和poll具有良好的可移植性而epoll和信号驱动I&#x2F;O具有更好的性能，因此通过一个软件抽象层来检查文件描述符事件，从而可移植程序就能在提供epoll API系统上使用epoll而在其他系统使用select或poll了。如Libevent的底层机制能够使用以上四种机制中的任意一种。</p>
</blockquote>
</li>
</ul>
</li>
</ul>
<h2 id="文件描述符准备就绪的通知方式"><a href="#文件描述符准备就绪的通知方式" class="headerlink" title="文件描述符准备就绪的通知方式"></a>文件描述符准备就绪的通知方式</h2><ul>
<li>水平触发通知：如果文件描述符上可以非阻塞地执行I&#x2F;O系统调用，此时认为其已经就绪。</li>
<li>边缘触发通知：如果文件描述符自上次状态检查以来有了新的I&#x2F;O活动（如新的输入），此时需要触发通知。</li>
</ul>
<p><img src="https://user-images.githubusercontent.com/87457873/127829103-223bdb2c-b788-4ccb-841e-025f4ef73601.png" alt="image"></p>
<p>通过上表可知，epoll与其他模式的区别在于其同时支持水平触发（默认）与边缘触发。</p>
<h3 id="触发方式对程序设计的影响"><a href="#触发方式对程序设计的影响" class="headerlink" title="触发方式对程序设计的影响"></a>触发方式对程序设计的影响</h3><ul>
<li><p>水平触发 当采用水平触发时，我们可以在任意时刻检查文件描述符的就绪状态。当确定其就绪状态后就可以对其进行I&#x2F;O操作，然后重复检查文件描述符，已确定是否仍然处于就绪状态，此时就可以执行更多的I&#x2F;O。也就是说，因为水平触发允许我们在任意时刻重复检查I&#x2F;O状态，也就没有必要每次文件描述符就绪后就尽可能多地执行I&#x2F;O（尽可能多地读取字节，亦或是不去执行I&#x2F;O）。</p>
</li>
<li><p>边缘触发 当采用边缘触发时，只有当I&#x2F;O事件发生时才会得到通知。在另一个I&#x2F;O时间到来之前我们不会收到任何新的通知。此外当文件描述符收到I&#x2F;O事件通知时，我们并不知道要处理多少I&#x2F;O（有多少数据可读）。因此采用边缘触发通知的程序应该在接收到一个I&#x2F;O事件通知后，程序在某个时刻（在有些时候我们确定文件描述符是就绪态时，此时不适合大量的I&#x2F;O操作。因为如果我们仅对一个文件描述符执行大量I&#x2F;O操作，可能会让其他文件描述符处于饥饿状态）应该在相应的文件描述符上尽可能多地执行I&#x2F;O（尽可能多地读取字节，与水平触发相反）。但是若是程序如此设计，就可能失去执行I&#x2F;O的机会。因为知道产生另一个I&#x2F;O事件为止，在此之前程序都不会在接收到通知了，也就不知道何时执行I&#x2F;O了。这也将导致数据丢失或者程序中出现阻塞。</p>
</li>
</ul>
<p>如果程序采用循环来对文件描述符执行尽可能多的I&#x2F;O，而文件描述符又被置为可阻塞的，那么最终当没有更多文件可执行时，I&#x2F;O系统调用就会阻塞。因此，每个被检查的文件描述符通常都应该被设为非阻塞模式。在得到I&#x2F;O事件通知后会重复执行I&#x2F;O操作，直到相应的系统调用 (如read()、write()) 以错误码EAGAIN或EWOULDBLOCK的形式失败。</p>
<h2 id="异步I-O模型"><a href="#异步I-O模型" class="headerlink" title="异步I&#x2F;O模型"></a>异步I&#x2F;O模型</h2><p><img src="/" alt="Uploading image.png…"></p>
<p>对于I&#x2F;O操作主要有两种分别是异步I&#x2F;O和同步I&#x2F;O，对于同步I&#x2F;O会导致请求进程阻塞，直到I&#x2F;O操作完成，即必须等待I&#x2F;O操作完成以后控制权才返回给用户进程；而异步I&#x2F;O不会导致请求进程阻塞，即无需等待I&#x2F;O操作完成就将控制权返回给用户进程。</p>
<ul>
<li><p>异步I&#x2F;O模型的工作机制 告知内核启动某个操作，并让内核在整个操作（包括将数据从内核复制到进程缓冲区）完成后通知我们。主要方式是调用aio_read函数向内核传递描述符、缓冲区指针、缓冲区大小（与read相同的三个参数）和文件偏移，并告知内核当整个操作完成时如何通知用户进程。该系统调用立即返回，在等待I&#x2F;O完成期间进程不被阻塞。</p>
</li>
<li><p>与信号驱动式I&#x2F;O模型的区别<br><br>信号驱动式I&#x2F;O是由内核告诉我们何时可以启动一个I&#x2F;O操作，而异步I&#x2F;O模型则是由内核通知我们I&#x2F;O操作何时完成。</p>
</li>
</ul>
]]></content>
      <categories>
        <category>linux-doc 网络协议栈</category>
      </categories>
      <tags>
        <tag>Linux</tag>
      </tags>
  </entry>
  <entry>
    <title>Linux内核之epoll模型</title>
    <url>/2023/01/15/linux-docs/%E7%BD%91%E7%BB%9C%E5%8D%8F%E8%AE%AE%E6%A0%88/Linux%E5%86%85%E6%A0%B8%E4%B9%8Bepoll%E6%A8%A1%E5%9E%8B/</url>
    <content><![CDATA[<p>同步IO和异步IO，阻塞IO和非阻塞IO分别是什么，到底有什么区别？不同的人在不同的上下文下给出的答案是不同的。</p>
<p>这里主要讨论Linux环境下的network IO。</p>
<h2 id="一-概念说明"><a href="#一-概念说明" class="headerlink" title="一 概念说明"></a>一 概念说明</h2><p>在进行解释之前，首先要说明几个概念：</p>
<ul>
<li>用户空间和内核空间</li>
<li>进程切换</li>
<li>进程的阻塞</li>
<li>文件描述符</li>
<li>缓存 I&#x2F;O</li>
</ul>
<h3 id="用户空间与内核空间"><a href="#用户空间与内核空间" class="headerlink" title="用户空间与内核空间"></a>用户空间与内核空间</h3><p>现在操作系统都是采用虚拟存储器，那么对32位操作系统而言，它的寻址空间（虚拟存储空间）为4G（2的32次方）。操作系统的核心是内核，独立于普通的应用程序，可以访问受保护的内存空间，也有访问底层硬件设备的所有权限。为了保证用户进程不能直接操作内核（kernel），保证内核的安全，操心系统将虚拟空间划分为两部分，一部分为内核空间，一部分为用户空间。</p>
<p>针对linux操作系统而言，将最高的1G字节（从虚拟地址0xC0000000到0xFFFFFFFF），供内核使用，称为<strong>内核空间</strong>。</p>
<p>而将较低的3G字节（从虚拟地址0x00000000到0xBFFFFFFF），供各个进程使用，称为<strong>用户空间</strong>。</p>
<h3 id="进程切换"><a href="#进程切换" class="headerlink" title="进程切换"></a>进程切换</h3><p>为了控制进程的执行，内核必须有能力挂起正在CPU上运行的进程，并恢复以前挂起的某个进程的执行。这种行为被称为进程切换。因此可以说，任何进程都是在操作系统内核的支持下运行的，是与内核紧密相关的。</p>
<p>从一个进程的运行转到另一个进程上运行，这个过程中经过下面这些变化：</p>
<p>1、保存处理机上下文，包括程序计数器和其他寄存器。<br><br>2、更新PCB信息。<br><br>3、把进程的PCB移入相应的队列，如就绪、在某事件阻塞等队列。<br><br>4、选择另一个进程执行，并更新其PCB。<br><br>5、更新内存管理的数据结构。<br><br>6、恢复处理机上下文。<br><br>7、总而言之就是很耗资源<br></p>
<h3 id="进程的阻塞"><a href="#进程的阻塞" class="headerlink" title="进程的阻塞"></a>进程的阻塞</h3><p>正在执行的进程，由于期待的某些事件未发生，如请求系统资源失败、等待某种操作的完成、新数据尚未到达或无新工作做等，则由系统自动执行阻塞原语(Block)，使自己由运行状态变为阻塞状态。可见，进程的阻塞是进程自身的一种主动行为，也因此只有处于运行态的进程（获得CPU），才可能将其转为阻塞状态。当进程进入阻塞状态，是不占用CPU资源的。</p>
<h3 id="文件描述符fd"><a href="#文件描述符fd" class="headerlink" title="文件描述符fd"></a>文件描述符fd</h3><p>文件描述符（File descriptor）是计算机科学中的一个术语，是一个用于表述指向文件的引用的抽象化概念。</p>
<p>文件描述符在形式上是一个非负整数。实际上，它是一个索引值，指向内核为每一个进程所维护的该进程打开文件的记录表。当程序打开一个现有文件或者创建一个新文件时，内核向进程返回一个文件描述符。在程序设计中，一些涉及底层的程序编写往往会围绕着文件描述符展开。但是文件描述符这一概念往往只适用于UNIX、Linux这样的操作系统。</p>
<h3 id="缓存-I-O"><a href="#缓存-I-O" class="headerlink" title="缓存 I&#x2F;O"></a>缓存 I&#x2F;O</h3><p>缓存 I&#x2F;O 又被称作标准 I&#x2F;O，大多数文件系统的默认 I&#x2F;O 操作都是缓存 I&#x2F;O。在 Linux 的缓存 I&#x2F;O 机制中，操作系统会将 I&#x2F;O 的数据缓存在文件系统的页缓存（ page cache ）中，也就是说，数据会先被拷贝到操作系统内核的缓冲区中，然后才会从操作系统内核的缓冲区拷贝到应用程序的地址空间。</p>
<h3 id="缓存-I-O-的缺点："><a href="#缓存-I-O-的缺点：" class="headerlink" title="缓存 I&#x2F;O 的缺点："></a>缓存 I&#x2F;O 的缺点：</h3><p>数据在传输过程中需要在应用程序地址空间和内核进行多次数据拷贝操作，这些数据拷贝操作所带来的 CPU 以及内存开销是非常大的。</p>
<h2 id="二-IO模式"><a href="#二-IO模式" class="headerlink" title="二 IO模式"></a>二 IO模式</h2><p>刚才说了，对于一次IO访问（以read举例），数据会先被拷贝到操作系统内核的缓冲区中，然后才会从操作系统内核的缓冲区拷贝到应用程序的地址空间。所以说，当一个read操作发生时，它会经历两个阶段：</p>
<p>1、等待数据准备 (Waiting for the data to be ready)<br><br>2、将数据从内核拷贝到进程中 (Copying the data from the kernel to the process)<br></p>
<p>正是因为这两个阶段，linux系统产生了下面五种网络模式的方案。</p>
<ul>
<li>阻塞 I&#x2F;O（blocking IO）</li>
<li>非阻塞 I&#x2F;O（nonblocking IO）</li>
<li>I&#x2F;O 多路复用（ IO multiplexing）</li>
<li>信号驱动 I&#x2F;O（ signal driven IO）</li>
<li>异步 I&#x2F;O（asynchronous IO）</li>
</ul>
<p>注：由于signal driven IO在实际中并不常用，所以我这只提及剩下的四种IO Model。</p>
<h3 id="阻塞-I-O（blocking-IO）"><a href="#阻塞-I-O（blocking-IO）" class="headerlink" title="阻塞 I&#x2F;O（blocking IO）"></a>阻塞 I&#x2F;O（blocking IO）</h3><p>在linux中，默认情况下所有的socket都是blocking，一个典型的读操作流程大概是这样：</p>
<p><img src="https://user-images.githubusercontent.com/87457873/127821904-5722d97b-8c31-4b69-8863-a88396a75702.png" alt="image"></p>
<p>当用户进程调用了recvfrom这个系统调用，kernel就开始了IO的第一个阶段：准备数据（对于网络IO来说，很多时候数据在一开始还没有到达。比如，还没有收到一个完整的UDP包。这个时候kernel就要等待足够的数据到来）。这个过程需要等待，也就是说数据被拷贝到操作系统内核的缓冲区中是需要一个过程的。而在用户进程这边，整个进程会被阻塞（当然，是进程自己选择的阻塞）。当kernel一直等到数据准备好了，它就会将数据从kernel中拷贝到用户内存，然后kernel返回结果，用户进程才解除block的状态，重新运行起来。</p>
<blockquote>
<p>所以，blocking IO的特点就是在IO执行的两个阶段都被block了。</p>
</blockquote>
<h3 id="非阻塞-I-O（nonblocking-IO）"><a href="#非阻塞-I-O（nonblocking-IO）" class="headerlink" title="非阻塞 I&#x2F;O（nonblocking IO）"></a>非阻塞 I&#x2F;O（nonblocking IO）</h3><p>linux下，可以通过设置socket使其变为non-blocking。当对一个non-blocking socket执行读操作时，流程是这个样子：</p>
<p><img src="https://user-images.githubusercontent.com/87457873/127821969-d6a391e8-756f-47eb-8706-8c57e01dbde0.png" alt="image"></p>
<p>当用户进程发出read操作时，如果kernel中的数据还没有准备好，那么它并不会block用户进程，而是立刻返回一个error。从用户进程角度io讲 ，它发起一个read操作后，并不需要等待，而是马上就得到了一个结果。用户进程判断结果是一个error时，它就知道数据还没有准备好，于是它可以再次发送read操作。一旦kernel中的数据准备好了，并且又再次收到了用户进程的system call，那么它马上就将数据拷贝到了用户内存，然后返回。</p>
<blockquote>
<p>所以，nonblocking IO的特点是用户进程需要不断的主动询问kernel数据好了没有。</p>
</blockquote>
<h3 id="I-O-多路复用（-IO-multiplexing）"><a href="#I-O-多路复用（-IO-multiplexing）" class="headerlink" title="I&#x2F;O 多路复用（ IO multiplexing）"></a>I&#x2F;O 多路复用（ IO multiplexing）</h3><p>IO multiplexing就是我们说的select，poll，epoll，有些地方也称这种IO方式为event driven IO。select&#x2F;epoll的好处就在于单个process就可以同时处理多个网络连接的IO。它的基本原理就是select，poll，epoll这个function会不断的轮询所负责的所有socket，当某个socket有数据到达了，就通知用户进程。</p>
<p><img src="https://user-images.githubusercontent.com/87457873/127822020-24b1505b-27fe-4a3d-9e61-2c6cc712e238.png" alt="image"></p>
<p>当用户进程调用了select，那么整个进程会被block，而同时，kernel会“监视”所有select负责的socket，当任何一个socket中的数据准备好了，select就会返回。这个时候用户进程再调用read操作，将数据从kernel拷贝到用户进程。</p>
<p>所以，I&#x2F;O 多路复用的特点是通过一种机制一个进程能同时等待多个文件描述符，而这些文件描述符（套接字描述符）其中的任意一个进入读就绪状态，select()函数就可以返回。</p>
<p>这个图和blocking IO的图其实并没有太大的不同，事实上，还更差一些。因为这里需要使用两个system call (select 和 recvfrom)，而blocking IO只调用了一个system call (recvfrom)。但是，用select的优势在于它可以同时处理多个connection。</p>
<p>所以，如果处理的连接数不是很高的话，使用select&#x2F;epoll的web server不一定比使用multi-threading + blocking IO的web server性能更好，可能延迟还更大。select&#x2F;epoll的优势并不是对于单个连接能处理得更快，而是在于能处理更多的连接。）</p>
<p>在IO multiplexing Model中，实际中，对于每一个socket，一般都设置成为non-blocking，但是，如上图所示，整个用户的process其实是一直被block的。只不过process是被select这个函数block，而不是被socket IO给block。</p>
<h3 id="异步-I-O（asynchronous-IO）"><a href="#异步-I-O（asynchronous-IO）" class="headerlink" title="异步 I&#x2F;O（asynchronous IO）"></a>异步 I&#x2F;O（asynchronous IO）</h3><p>Linux下的asynchronous IO其实用得很少。先看一下它的流程：</p>
<p><img src="https://user-images.githubusercontent.com/87457873/127822064-307fe305-e912-4c89-84f7-34858f4644ac.png" alt="image"></p>
<p>I用户进程发起read操作之后，立刻就可以开始去做其它的事。而另一方面，从kernel的角度，当它受到一个asynchronous read之后，首先它会立刻返回，所以不会对用户进程产生任何block。然后，kernel会等待数据准备完成，然后将数据拷贝到用户内存，当这一切都完成之后，kernel会给用户进程发送一个signal，告诉它read操作完成了。</p>
<h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><h4 id="blocking和non-blocking的区别"><a href="#blocking和non-blocking的区别" class="headerlink" title="blocking和non-blocking的区别"></a>blocking和non-blocking的区别</h4><p>调用blocking IO会一直block住对应的进程直到操作完成，而non-blocking IO在kernel还准备数据的情况下会立刻返回。</p>
<h4 id="synchronous-IO和asynchronous-IO的区别"><a href="#synchronous-IO和asynchronous-IO的区别" class="headerlink" title="synchronous IO和asynchronous IO的区别"></a>synchronous IO和asynchronous IO的区别</h4><p>在说明synchronous IO和asynchronous IO的区别之前，需要先给出两者的定义。POSIX的定义是这样子的：</p>
<ul>
<li>A synchronous I&#x2F;O operation causes the requesting process to be blocked until that I&#x2F;O operation completes;</li>
<li>An asynchronous I&#x2F;O operation does not cause the requesting process to be blocked</li>
</ul>
<p>两者的区别就在于synchronous IO做”IO operation”的时候会将process阻塞。按照这个定义，之前所述的blocking IO，non-blocking IO，IO multiplexing都属于synchronous IO。</p>
<p>有人会说，non-blocking IO并没有被block啊。这里有个非常“狡猾”的地方，定义中所指的”IO operation”是指真实的IO操作，就是例子中的recvfrom这个system call。non-blocking IO在执行recvfrom这个system call的时候，如果kernel的数据没有准备好，这时候不会block进程。但是，当kernel中数据准备好的时候，recvfrom会将数据从kernel拷贝到用户内存中，这个时候进程是被block了，在这段时间内，进程是被block的。</p>
<p>而asynchronous IO则不一样，当进程发起IO 操作之后，就直接返回再也不理睬了，直到kernel发送一个信号，告诉进程说IO完成。在这整个过程中，进程完全没有被block。</p>
<h4 id="各个IO-Model的比较如图所示："><a href="#各个IO-Model的比较如图所示：" class="headerlink" title="各个IO Model的比较如图所示："></a>各个IO Model的比较如图所示：</h4><p><img src="https://user-images.githubusercontent.com/87457873/127822245-eabba2a8-0f24-4f77-89c8-7b471a31bd83.png" alt="image"></p>
<p>通过上面的图片，可以发现non-blocking IO和asynchronous IO的区别还是很明显的。在non-blocking IO中，虽然进程大部分时间都不会被block，但是它仍然要求进程去主动的check，并且当数据准备完成以后，也需要进程主动的再次调用recvfrom来将数据拷贝到用户内存。而asynchronous IO则完全不同。它就像是用户进程将整个IO操作交给了他人（kernel）完成，然后他人做完后发信号通知。在此期间，用户进程不需要去检查IO操作的状态，也不需要主动的去拷贝数据。</p>
<h2 id="三-I-O-多路复用之select、poll、epoll详解"><a href="#三-I-O-多路复用之select、poll、epoll详解" class="headerlink" title="三 I&#x2F;O 多路复用之select、poll、epoll详解"></a>三 I&#x2F;O 多路复用之select、poll、epoll详解</h2><p>select，poll，epoll都是IO多路复用的机制。I&#x2F;O多路复用就是通过一种机制，一个进程可以监视多个描述符，一旦某个描述符就绪（一般是读就绪或者写就绪），能够通知程序进行相应的读写操作。但select，poll，epoll本质上都是同步I&#x2F;O，因为他们都需要在读写事件就绪后自己负责进行读写，也就是说这个读写过程是阻塞的，而异步I&#x2F;O则无需自己负责进行读写，异步I&#x2F;O的实现会负责把数据从内核拷贝到用户空间。</p>
<h3 id="select"><a href="#select" class="headerlink" title="select"></a>select</h3><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">select</span> <span class="params">(<span class="type">int</span> n, fd_set *readfds, fd_set *writefds, fd_set *exceptfds, <span class="keyword">struct</span> timeval *timeout)</span>;</span><br></pre></td></tr></table></figure>

<p>select 函数监视的文件描述符分3类，分别是writefds、readfds、和exceptfds。调用后select函数会阻塞，直到有描述副就绪（有数据 可读、可写、或者有except），或者超时（timeout指定等待时间，如果立即返回设为null即可），函数返回。当select函数返回后，可以 通过遍历fdset，来找到就绪的描述符。</p>
<p>select目前几乎在所有的平台上支持，其良好跨平台支持也是它的一个优点。select的一 个缺点在于单个进程能够监视的文件描述符的数量存在最大限制，在Linux上一般为1024，可以通过修改宏定义甚至重新编译内核的方式提升这一限制，但 是这样也会造成效率的降低。</p>
<h3 id="poll"><a href="#poll" class="headerlink" title="poll"></a>poll</h3><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">poll</span> <span class="params">(<span class="keyword">struct</span> pollfd *fds, <span class="type">unsigned</span> <span class="type">int</span> nfds, <span class="type">int</span> timeout)</span>;</span><br></pre></td></tr></table></figure>

<p>不同与select使用三个位图来表示三个fdset的方式，poll使用一个 pollfd的指针实现。</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">pollfd</span> &#123;</span></span><br><span class="line">    <span class="type">int</span> fd; <span class="comment">/* file descriptor */</span></span><br><span class="line">    <span class="type">short</span> events; <span class="comment">/* requested events to watch */</span></span><br><span class="line">    <span class="type">short</span> revents; <span class="comment">/* returned events witnessed */</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>pollfd结构包含了要监视的event和发生的event，不再使用select“参数-值”传递的方式。同时，pollfd并没有最大数量限制（但是数量过大后性能也是会下降）。 和select函数一样，poll返回后，需要轮询pollfd来获取就绪的描述符。</p>
<p>从上面看，select和poll都需要在返回后，通过遍历文件描述符来获取已经就绪的socket。事实上，同时连接的大量客户端在一时刻可能只有很少的处于就绪状态，因此随着监视的描述符数量的增长，其效率也会线性下降。</p>
<h3 id="epoll"><a href="#epoll" class="headerlink" title="epoll"></a>epoll</h3><p>epoll是在2.6内核中提出的，是之前的select和poll的增强版本。相对于select和poll来说，epoll更加灵活，没有描述符限制。epoll使用一个文件描述符管理多个描述符，将用户关系的文件描述符的事件存放到内核的一个事件表中，这样在用户空间和内核空间的copy只需一次。</p>
<h3 id="epoll操作过程"><a href="#epoll操作过程" class="headerlink" title="epoll操作过程"></a>epoll操作过程</h3><p>epoll操作过程需要三个接口，分别如下：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">epoll_create</span><span class="params">(<span class="type">int</span> size)</span>；<span class="comment">//创建一个epoll的句柄，size用来告诉内核这个监听的数目一共有多大</span></span><br><span class="line"><span class="type">int</span> <span class="title function_">epoll_ctl</span><span class="params">(<span class="type">int</span> epfd, <span class="type">int</span> op, <span class="type">int</span> fd, <span class="keyword">struct</span> epoll_event *event)</span>；</span><br><span class="line"><span class="type">int</span> <span class="title function_">epoll_wait</span><span class="params">(<span class="type">int</span> epfd, <span class="keyword">struct</span> epoll_event * events, <span class="type">int</span> maxevents, <span class="type">int</span> timeout)</span>;</span><br></pre></td></tr></table></figure>

<h4 id="1-int-epoll-create-int-size"><a href="#1-int-epoll-create-int-size" class="headerlink" title="1. int epoll_create(int size);"></a>1. int epoll_create(int size);</h4><p>创建一个epoll的句柄，size用来告诉内核这个监听的数目一共有多大，这个参数不同于select()中的第一个参数，给出最大监听的fd+1的值，参数size并不是限制了epoll所能监听的描述符最大个数，只是对内核初始分配内部数据结构的一个建议。<br>当创建好epoll句柄后，它就会占用一个fd值，在linux下如果查看&#x2F;proc&#x2F;进程id&#x2F;fd&#x2F;，是能够看到这个fd的，所以在使用完epoll后，必须调用close()关闭，否则可能导致fd被耗尽。</p>
<h4 id="2-int-epoll-ctl-int-epfd-int-op-int-fd-struct-epoll-event-event-；"><a href="#2-int-epoll-ctl-int-epfd-int-op-int-fd-struct-epoll-event-event-；" class="headerlink" title="2. int epoll_ctl(int epfd, int op, int fd, struct epoll_event *event)；"></a>2. int epoll_ctl(int epfd, int op, int fd, struct epoll_event *event)；</h4><p>函数是对指定描述符fd执行op操作。</p>
<ul>
<li>epfd：是epoll_create()的返回值。</li>
<li>op：表示op操作，用三个宏来表示：添加EPOLL_CTL_ADD，删除EPOLL_CTL_DEL，修改EPOLL_CTL_MOD。分别添加、删除和修改对fd的监听事件。</li>
<li>fd：是需要监听的fd（文件描述符）</li>
<li>epoll_event：是告诉内核需要监听什么事，struct epoll_event结构如下：</li>
</ul>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">epoll_event</span> &#123;</span></span><br><span class="line">  <span class="type">__uint32_t</span> events;  <span class="comment">/* Epoll events */</span></span><br><span class="line">  <span class="type">epoll_data_t</span> data;  <span class="comment">/* User data variable */</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>events可以是以下几个宏的集合：<br><br>EPOLLIN ：表示对应的文件描述符可以读（包括对端SOCKET正常关闭）；<br><br>EPOLLOUT：表示对应的文件描述符可以写；<br><br>EPOLLPRI：表示对应的文件描述符有紧急的数据可读（这里应该表示有带外数据到来）；<br><br>EPOLLERR：表示对应的文件描述符发生错误；<br><br>EPOLLHUP：表示对应的文件描述符被挂断；<br><br>EPOLLET： 将EPOLL设为边缘触发(Edge Triggered)模式，这是相对于水平触发(Level Triggered)来说的。<br><br>EPOLLONESHOT：只监听一次事件，当监听完这次事件之后，如果还需要继续监听这个socket的话，需要再次把这个socket加入到EPOLL队列里<br></p>
<h4 id="3-int-epoll-wait-int-epfd-struct-epoll-event-events-int-maxevents-int-timeout"><a href="#3-int-epoll-wait-int-epfd-struct-epoll-event-events-int-maxevents-int-timeout" class="headerlink" title="3. int epoll_wait(int epfd, struct epoll_event * events, int maxevents, int timeout);"></a>3. int epoll_wait(int epfd, struct epoll_event * events, int maxevents, int timeout);</h4><p>等待epfd上的io事件，最多返回maxevents个事件。<br><br>参数events用来从内核得到事件的集合，maxevents告之内核这个events有多大，这个maxevents的值不能大于创建epoll_create()时的size，参数timeout是超时时间（毫秒，0会立即返回，-1将不确定，也有说法说是永久阻塞）。该函数返回需要处理的事件数目，如返回0表示已超时。</p>
<h3 id="工作模式"><a href="#工作模式" class="headerlink" title="工作模式"></a>工作模式</h3><p>epoll对文件描述符的操作有两种模式：LT（level trigger）和ET（edge trigger）。LT模式是默认模式，LT模式与ET模式的区别如下：</p>
<ul>
<li>LT模式：当epoll_wait检测到描述符事件发生并将此事件通知应用程序，应用程序可以不立即处理该事件。下次调用epoll_wait时，会再次响应应用程序并通知此事件。</li>
<li>ET模式：当epoll_wait检测到描述符事件发生并将此事件通知应用程序，应用程序必须立即处理该事件。如果不处理，下次调用epoll_wait时，不会再次响应应用程序并通知此事件。</li>
</ul>
<h4 id="1-LT模式"><a href="#1-LT模式" class="headerlink" title="1. LT模式"></a>1. LT模式<br></h4><p>LT(level triggered)是缺省的工作方式，并且同时支持block和no-block socket.在这种做法中，内核告诉你一个文件描述符是否就绪了，然后你可以对这个就绪的fd进行IO操作。如果你不作任何操作，内核还是会继续通知你的。</p>
<h4 id="2-ET模式"><a href="#2-ET模式" class="headerlink" title="2. ET模式"></a>2. ET模式<br></h4><p>ET(edge-triggered)是高速工作方式，只支持no-block socket。在这种模式下，当描述符从未就绪变为就绪时，内核通过epoll告诉你。然后它会假设你知道文件描述符已经就绪，并且不会再为那个文件描述符发送更多的就绪通知，直到你做了某些操作导致那个文件描述符不再为就绪状态了(比如，你在发送，接收或者接收请求，或者发送接收的数据少于一定量时导致了一个EWOULDBLOCK 错误）。但是请注意，如果一直不对这个fd作IO操作(从而导致它再次变成未就绪)，内核不会发送更多的通知(only once)</p>
<p>ET模式在很大程度上减少了epoll事件被重复触发的次数，因此效率要比LT模式高。epoll工作在ET模式的时候，必须使用非阻塞套接口，以避免由于一个文件句柄的阻塞读&#x2F;阻塞写操作把处理多个文件描述符的任务饿死。</p>
<h4 id="3-总结"><a href="#3-总结" class="headerlink" title="3. 总结"></a>3. 总结</h4><p>假如有这样一个例子：</p>
<p>我们已经把一个用来从管道中读取数据的文件句柄(RFD)添加到epoll描述符<br><br>这个时候从管道的另一端被写入了2KB的数据<br><br>调用epoll_wait(2)，并且它会返回RFD，说明它已经准备好读取操作<br><br>然后我们读取了1KB的数据<br><br>调用epoll_wait(2)……<br></p>
<p><strong>LT模式：</strong><br>如果是LT模式，那么在第5步调用epoll_wait(2)之后，仍然能受到通知。</p>
<p><strong>ET模式：</strong><br>如果我们在第1步将RFD添加到epoll描述符的时候使用了EPOLLET标志，那么在第5步调用epoll_wait(2)之后将有可能会挂起，因为剩余的数据还存在于文件的输入缓冲区内，而且数据发出端还在等待一个针对已经发出数据的反馈信息。只有在监视的文件句柄上发生了某个事件的时候 ET 工作模式才会汇报事件。因此在第5步的时候，调用者可能会放弃等待仍在存在于文件输入缓冲区内的剩余数据。</p>
<p>当使用epoll的ET模型来工作时，当产生了一个EPOLLIN事件后，<br><br>读数据的时候需要考虑的是当recv()返回的大小如果等于请求的大小，那么很有可能是缓冲区还有数据未读完，也意味着该次事件还没有处理完，所以还需要再次读取：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="keyword">while</span>(rs)&#123;</span><br><span class="line">  buflen = recv(activeevents[i].data.fd, buf, <span class="keyword">sizeof</span>(buf), <span class="number">0</span>);</span><br><span class="line">  <span class="keyword">if</span>(buflen &lt; <span class="number">0</span>)&#123;</span><br><span class="line">    <span class="comment">// 由于是非阻塞的模式,所以当errno为EAGAIN时,表示当前缓冲区已无数据可读</span></span><br><span class="line">    <span class="comment">// 在这里就当作是该次事件已处理处.</span></span><br><span class="line">    <span class="keyword">if</span>(errno == EAGAIN)&#123;</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span>&#123;</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">else</span> <span class="keyword">if</span>(buflen == <span class="number">0</span>)&#123;</span><br><span class="line">     <span class="comment">// 这里表示对端的socket已正常关闭.</span></span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line"> <span class="keyword">if</span>(buflen == <span class="keyword">sizeof</span>(buf)&#123;</span><br><span class="line">      rs = <span class="number">1</span>;   <span class="comment">// 需要再次读取</span></span><br><span class="line"> &#125;</span><br><span class="line"> <span class="keyword">else</span>&#123;</span><br><span class="line">      rs = <span class="number">0</span>;</span><br><span class="line"> &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>Linux中的EAGAIN含义</strong></p>
<p>Linux环境下开发经常会碰到很多错误(设置errno)，其中EAGAIN是其中比较常见的一个错误(比如用在非阻塞操作中)。<br><br>从字面上来看，是提示再试一次。这个错误经常出现在当应用程序进行一些非阻塞(non-blocking)操作(对文件或socket)的时候。<br></p>
<p>例如，以 O_NONBLOCK的标志打开文件&#x2F;socket&#x2F;FIFO，如果你连续做read操作而没有数据可读。此时程序不会阻塞起来等待数据准备就绪返回，read函数会返回一个错误EAGAIN，提示你的应用程序现在没有数据可读请稍后再试。<br><br>又例如，当一个系统调用(比如fork)因为没有足够的资源(比如虚拟内存)而执行失败，返回EAGAIN提示其再调用一次(也许下次就能成功)。</p>
<h3 id="代码演示"><a href="#代码演示" class="headerlink" title="代码演示"></a>代码演示</h3><p>下面是一段不完整的代码且格式不对，意在表述上面的过程，去掉了一些模板代码。</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">define</span> IPADDRESS   <span class="string">&quot;127.0.0.1&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> PORT        8787</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> MAXSIZE     1024</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> LISTENQ     5</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> FDSIZE      1000</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> EPOLLEVENTS 100</span></span><br><span class="line"></span><br><span class="line">listenfd = socket_bind(IPADDRESS,PORT);</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">epoll_event</span> <span class="title">events</span>[<span class="title">EPOLLEVENTS</span>];</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//创建一个描述符</span></span><br><span class="line">epollfd = epoll_create(FDSIZE);</span><br><span class="line"></span><br><span class="line"><span class="comment">//添加监听描述符事件</span></span><br><span class="line">add_event(epollfd,listenfd,EPOLLIN);</span><br><span class="line"></span><br><span class="line"><span class="comment">//循环等待</span></span><br><span class="line"><span class="keyword">for</span> ( ; ; )&#123;</span><br><span class="line">    <span class="comment">//该函数返回已经准备好的描述符事件数目</span></span><br><span class="line">    ret = epoll_wait(epollfd,events,EPOLLEVENTS,<span class="number">-1</span>);</span><br><span class="line">    <span class="comment">//处理接收到的连接</span></span><br><span class="line">    handle_events(epollfd,events,ret,listenfd,buf);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//事件处理函数</span></span><br><span class="line"><span class="type">static</span> <span class="type">void</span> <span class="title function_">handle_events</span><span class="params">(<span class="type">int</span> epollfd,<span class="keyword">struct</span> epoll_event *events,<span class="type">int</span> num,<span class="type">int</span> listenfd,<span class="type">char</span> *buf)</span></span><br><span class="line">&#123;</span><br><span class="line">     <span class="type">int</span> i;</span><br><span class="line">     <span class="type">int</span> fd;</span><br><span class="line">     <span class="comment">//进行遍历;这里只要遍历已经准备好的io事件。num并不是当初epoll_create时的FDSIZE。</span></span><br><span class="line">     <span class="keyword">for</span> (i = <span class="number">0</span>;i &lt; num;i++)</span><br><span class="line">     &#123;</span><br><span class="line">         fd = events[i].data.fd;</span><br><span class="line">        <span class="comment">//根据描述符的类型和事件类型进行处理</span></span><br><span class="line">         <span class="keyword">if</span> ((fd == listenfd) &amp;&amp;(events[i].events &amp; EPOLLIN))</span><br><span class="line">            handle_accpet(epollfd,listenfd);</span><br><span class="line">         <span class="keyword">else</span> <span class="keyword">if</span> (events[i].events &amp; EPOLLIN)</span><br><span class="line">            do_read(epollfd,fd,buf);</span><br><span class="line">         <span class="keyword">else</span> <span class="keyword">if</span> (events[i].events &amp; EPOLLOUT)</span><br><span class="line">            do_write(epollfd,fd,buf);</span><br><span class="line">     &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//添加事件</span></span><br><span class="line"><span class="type">static</span> <span class="type">void</span> <span class="title function_">add_event</span><span class="params">(<span class="type">int</span> epollfd,<span class="type">int</span> fd,<span class="type">int</span> state)</span>&#123;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">epoll_event</span> <span class="title">ev</span>;</span></span><br><span class="line">    ev.events = state;</span><br><span class="line">    ev.data.fd = fd;</span><br><span class="line">    epoll_ctl(epollfd,EPOLL_CTL_ADD,fd,&amp;ev);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//处理接收到的连接</span></span><br><span class="line"><span class="type">static</span> <span class="type">void</span> <span class="title function_">handle_accpet</span><span class="params">(<span class="type">int</span> epollfd,<span class="type">int</span> listenfd)</span>&#123;</span><br><span class="line">     <span class="type">int</span> clifd;     </span><br><span class="line">     <span class="class"><span class="keyword">struct</span> <span class="title">sockaddr_in</span> <span class="title">cliaddr</span>;</span>     </span><br><span class="line">     <span class="type">socklen_t</span>  cliaddrlen;     </span><br><span class="line">     clifd = accept(listenfd,(<span class="keyword">struct</span> sockaddr*)&amp;cliaddr,&amp;cliaddrlen);     </span><br><span class="line">     <span class="keyword">if</span> (clifd == <span class="number">-1</span>)         </span><br><span class="line">     perror(<span class="string">&quot;accpet error:&quot;</span>);     </span><br><span class="line">     <span class="keyword">else</span> &#123;         </span><br><span class="line">         <span class="built_in">printf</span>(<span class="string">&quot;accept a new client: %s:%d\n&quot;</span>,inet_ntoa(cliaddr.sin_addr),cliaddr.sin_port);                       <span class="comment">//添加一个客户描述符和事件         </span></span><br><span class="line">         add_event(epollfd,clifd,EPOLLIN);     </span><br><span class="line">     &#125; </span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//读处理</span></span><br><span class="line"><span class="type">static</span> <span class="type">void</span> <span class="title function_">do_read</span><span class="params">(<span class="type">int</span> epollfd,<span class="type">int</span> fd,<span class="type">char</span> *buf)</span>&#123;</span><br><span class="line">    <span class="type">int</span> nread;</span><br><span class="line">    nread = read(fd,buf,MAXSIZE);</span><br><span class="line">    <span class="keyword">if</span> (nread == <span class="number">-1</span>)     &#123;         </span><br><span class="line">        perror(<span class="string">&quot;read error:&quot;</span>);         </span><br><span class="line">        close(fd); <span class="comment">//记住close fd        </span></span><br><span class="line">        delete_event(epollfd,fd,EPOLLIN); <span class="comment">//删除监听 </span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span> (nread == <span class="number">0</span>)     &#123;         </span><br><span class="line">        <span class="built_in">fprintf</span>(<span class="built_in">stderr</span>,<span class="string">&quot;client close.\n&quot;</span>);</span><br><span class="line">        close(fd); <span class="comment">//记住close fd       </span></span><br><span class="line">        delete_event(epollfd,fd,EPOLLIN); <span class="comment">//删除监听 </span></span><br><span class="line">    &#125;     </span><br><span class="line">    <span class="keyword">else</span> &#123;         </span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;read message is : %s&quot;</span>,buf);        </span><br><span class="line">        <span class="comment">//修改描述符对应的事件，由读改为写         </span></span><br><span class="line">        modify_event(epollfd,fd,EPOLLOUT);     </span><br><span class="line">    &#125; </span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//写处理</span></span><br><span class="line"><span class="type">static</span> <span class="type">void</span> <span class="title function_">do_write</span><span class="params">(<span class="type">int</span> epollfd,<span class="type">int</span> fd,<span class="type">char</span> *buf)</span> &#123;     </span><br><span class="line">    <span class="type">int</span> nwrite;     </span><br><span class="line">    nwrite = write(fd,buf,<span class="built_in">strlen</span>(buf));     </span><br><span class="line">    <span class="keyword">if</span> (nwrite == <span class="number">-1</span>)&#123;         </span><br><span class="line">        perror(<span class="string">&quot;write error:&quot;</span>);        </span><br><span class="line">        close(fd);   <span class="comment">//记住close fd       </span></span><br><span class="line">        delete_event(epollfd,fd,EPOLLOUT);  <span class="comment">//删除监听    </span></span><br><span class="line">    &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">        modify_event(epollfd,fd,EPOLLIN); </span><br><span class="line">    &#125;    </span><br><span class="line">    <span class="built_in">memset</span>(buf,<span class="number">0</span>,MAXSIZE); </span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//删除事件</span></span><br><span class="line"><span class="type">static</span> <span class="type">void</span> <span class="title function_">delete_event</span><span class="params">(<span class="type">int</span> epollfd,<span class="type">int</span> fd,<span class="type">int</span> state)</span> &#123;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">epoll_event</span> <span class="title">ev</span>;</span></span><br><span class="line">    ev.events = state;</span><br><span class="line">    ev.data.fd = fd;</span><br><span class="line">    epoll_ctl(epollfd,EPOLL_CTL_DEL,fd,&amp;ev);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//修改事件</span></span><br><span class="line"><span class="type">static</span> <span class="type">void</span> <span class="title function_">modify_event</span><span class="params">(<span class="type">int</span> epollfd,<span class="type">int</span> fd,<span class="type">int</span> state)</span>&#123;     </span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">epoll_event</span> <span class="title">ev</span>;</span></span><br><span class="line">    ev.events = state;</span><br><span class="line">    ev.data.fd = fd;</span><br><span class="line">    epoll_ctl(epollfd,EPOLL_CTL_MOD,fd,&amp;ev);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//注：另外一端我就省了</span></span><br></pre></td></tr></table></figure>
<h3 id="epoll总结"><a href="#epoll总结" class="headerlink" title="epoll总结"></a>epoll总结</h3><p>在 select&#x2F;poll中，进程只有在调用一定的方法后，内核才对所有监视的文件描述符进行扫描，而epoll事先通过epoll_ctl()来注册一 个文件描述符，一旦基于某个文件描述符就绪时，内核会采用类似callback的回调机制，迅速激活这个文件描述符，当进程调用epoll_wait() 时便得到通知。(此处去掉了遍历文件描述符，而是通过监听回调的的机制。这正是epoll的魅力所在。)</p>
<p>epoll的优点主要是以下几个方面：</p>
<p>1、监视的描述符数量不受限制，它所支持的FD上限是最大可以打开文件的数目，这个数字一般远大于2048,举个例子,在1GB内存的机器上大约是10万左右，具体数目可以cat &#x2F;proc&#x2F;sys&#x2F;fs&#x2F;file-max查看,一般来说这个数目和系统内存关系很大。select的最大缺点就是进程打开的fd是有数量限制的。这对 于连接数量比较大的服务器来说根本不能满足。虽然也可以选择多进程的解决方案( Apache就是这样实现的)，不过虽然linux上面创建进程的代价比较小，但仍旧是不可忽视的，加上进程间数据同步远比不上线程间同步的高效，所以也不是一种完美的方案。</p>
<p>2、IO的效率不会随着监视fd的数量的增长而下降。epoll不同于select和poll轮询的方式，而是通过每个fd定义的回调函数来实现的。只有就绪的fd才会执行回调函数。</p>
<p>如果没有大量的idle-connection或者dead-connection，epoll的效率并不会比select&#x2F;poll高很多，但是当遇到大量的idle-connection，就会发现epoll的效率大大高于select&#x2F;poll。</p>
]]></content>
      <categories>
        <category>linux-doc 网络协议栈</category>
      </categories>
      <tags>
        <tag>Linux</tag>
      </tags>
  </entry>
  <entry>
    <title>Linux内核网络UDP数据包发送（三）—IP协议层分析</title>
    <url>/2023/01/15/linux-docs/%E7%BD%91%E7%BB%9C%E5%8D%8F%E8%AE%AE%E6%A0%88/Linux%E5%86%85%E6%A0%B8%E7%BD%91%E7%BB%9CUDP%E6%95%B0%E6%8D%AE%E5%8C%85%E5%8F%91%E9%80%81%EF%BC%88%E4%B8%89%EF%BC%89%E2%80%94IP%E5%8D%8F%E8%AE%AE%E5%B1%82%E5%88%86%E6%9E%90/</url>
    <content><![CDATA[<h2 id="1-前言"><a href="#1-前言" class="headerlink" title="1. 前言"></a>1. 前言</h2><p>Linux内核网络 UDP 协议层通过调用 ip_send_skb 将 skb 交给 IP 协议层，本文通过分析内核 IP 协议层的关键函数来分享内核数据包发送在 IP 协议层的处理，并分享了监控IP层的方法。</p>
<h2 id="2-ip-send-skb"><a href="#2-ip-send-skb" class="headerlink" title="2. ip_send_skb"></a>2. ip_send_skb</h2><p>ip_send_skb 函数定义在 net&#x2F;ipv4&#x2F;ip_output.c 中，非常简短。它只是调用ip_local_out，如果调用失败，就更新相应的错误计数：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">ip_send_skb</span><span class="params">(<span class="keyword">struct</span> net *net, <span class="keyword">struct</span> sk_buff *skb)</span></span><br><span class="line">&#123;</span><br><span class="line">        <span class="type">int</span> err;</span><br><span class="line"></span><br><span class="line">        err = ip_local_out(skb);</span><br><span class="line">        <span class="keyword">if</span> (err) &#123;</span><br><span class="line">                <span class="keyword">if</span> (err &gt; <span class="number">0</span>)</span><br><span class="line">                        err = net_xmit_errno(err);</span><br><span class="line">                <span class="keyword">if</span> (err)</span><br><span class="line">                        IP_INC_STATS(net, IPSTATS_MIB_OUTDISCARDS);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> err;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>net_xmit_errno 函数将低层错误转换为 IP 和 UDP 协议层所能理解的错误。如果发生错误， IP 协议计数器 OutDiscards 会递增。稍后我们将看到读取哪些文件可以获取此统计信息。接下来看 ip_local_out。</p>
<h2 id="3-ip-local-out-and-ip-local-out"><a href="#3-ip-local-out-and-ip-local-out" class="headerlink" title="3. ip_local_out and __ip_local_out"></a>3. ip_local_out and __ip_local_out</h2><p>ip_local_out 和__ip_local_out 都很简单。ip_local_out 只需调用__ip_local_out，如果返回值为 1，则调用路由层 dst_output 发送数据包：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">ip_local_out</span><span class="params">(<span class="keyword">struct</span> sk_buff *skb)</span></span><br><span class="line">&#123;</span><br><span class="line">        <span class="type">int</span> err;</span><br><span class="line"></span><br><span class="line">        err = __ip_local_out(skb);</span><br><span class="line">        <span class="keyword">if</span> (likely(err == <span class="number">1</span>))</span><br><span class="line">                err = dst_output(skb);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> err;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>接下来看__ip_local_out 的代码：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">int</span> __ip_local_out(<span class="keyword">struct</span> sk_buff *skb)</span><br><span class="line">&#123;</span><br><span class="line">        <span class="class"><span class="keyword">struct</span> <span class="title">iphdr</span> *<span class="title">iph</span> =</span> ip_hdr(skb);</span><br><span class="line"></span><br><span class="line">        iph-&gt;tot_len = htons(skb-&gt;len);</span><br><span class="line">        ip_send_check(iph);</span><br><span class="line">        <span class="keyword">return</span> nf_hook(NFPROTO_IPV4, NF_INET_LOCAL_OUT, skb, <span class="literal">NULL</span>,</span><br><span class="line">                       skb_dst(skb)-&gt;dev, dst_output);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>可以看到，该函数首先做了两件重要的事情：<br><br>设置 IP 数据包的长度<br><br>调用 ip_send_check 来计算要写入 IP 头的校验和。ip_send_check 函数将进一步调用名为 ip_fast_csum 的函数来计算校验和。在 x86 和 x86_64 体系结构上，此函数用汇编实 现。<br><br>接下来，IP 协议层将通过调用 nf_hook 进入 netfilter，其返回值将传递回 ip_local_out 。如果 nf_hook 返回 1，则表示允许数据包通过，并且调用者应该自己发送数据包。这正是我们在上面看到的情况：ip_local_out 检查返回值 1 时，自己通过调用 dst_output 发送数据包。</p>
<h3 id="3-1-netfilter-and-nf-hook"><a href="#3-1-netfilter-and-nf-hook" class="headerlink" title="3.1 netfilter and nf_hook"></a>3.1 netfilter and nf_hook</h3><p>nf_hook 只是一个 wrapper，它调用 nf_hook_thresh，首先检查是否有为这个协议族和hook 类型（这里分别为 NFPROTO_IPV4 和 NF_INET_LOCAL_OUT）安装的过滤器，然后将返回到 IP 协议层，避免深入到 netfilter 或更下面，比如 iptables 和 conntrack。</p>
<p>如果有非常多或者非常复杂的 netfilter 或 iptables 规则，那些规则将在触发 sendmsg 系统调的用户进程的上下文中执行。如果对这个用户进程设置了 CPU 亲和性，相应的 CPU 将花费系统时间（system time）处理出站（outbound）iptables 规则。如果做性能回归测试，那可能要考虑根据系统的负载，将相应的用户进程绑到到特定的 CPU，或者是减少 netfilter&#x2F;iptables 规则的复杂度，以减少对性能测试的影响。</p>
<p>出于讨论目的，我们假设 nf_hook 返回 1，表示调用者（在这种情况下是 IP 协议层）应该自己发送数据包。</p>
<h3 id="3-2-目的（路由）缓存"><a href="#3-2-目的（路由）缓存" class="headerlink" title="3.2 目的（路由）缓存"></a>3.2 目的（路由）缓存</h3><p>dst 代码在 Linux 内核中实现协议无关的目标缓存。为了继续学习发送 UDP 数据报的流程 ，我们需要了解 dst 条目是如何被设置的，首先来看 dst 条目和路由是如何生成的。目标缓存，路由和邻居子系统，任何一个都可以拿来单独详细的介绍。现在不深入细节，只是快速地看一下它们是如何组合到一起的。<br>上面看到的代码调用了 dst_output(skb)。此函数只是查找关联到这个 skb 的 dst 条目 ，然后调用 output 方法。代码如下：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">/* Output packet to network from transport.  */</span></span><br><span class="line"><span class="type">static</span> <span class="keyword">inline</span> <span class="type">int</span> <span class="title function_">dst_output</span><span class="params">(<span class="keyword">struct</span> sk_buff *skb)</span></span><br><span class="line">&#123;</span><br><span class="line">        <span class="keyword">return</span> skb_dst(skb)-&gt;output(skb);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>看起来很简单，但是 output 方法之前是如何关联到 dst 条目的？<br><br>首先很重要的一点，目标缓存条目是以多种不同方式添加的。到目前为止，我们已经在代码中看到的一种方法是从 udp_sendmsg 调用ip_route_output_flow。ip_route_output_flow 函数调用 __ip_route_output_key ，后者进而调用 __mkroute_output。 __mkroute_output 函数创建路由和目标缓存条目。当它执行创建操作时，它会判断哪个 output 方法适合此 dst。大多数时候，这个函数是 ip_output。</p>
<h2 id="4-ip-output"><a href="#4-ip-output" class="headerlink" title="4. ip_output"></a>4. ip_output</h2><p>在 UDP IPv4 情况下，上面的 output 方法指向的是 ip_output:</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">ip_output</span><span class="params">(<span class="keyword">struct</span> sk_buff *skb)</span></span><br><span class="line">&#123;</span><br><span class="line">        <span class="class"><span class="keyword">struct</span> <span class="title">net_device</span> *<span class="title">dev</span> =</span> skb_dst(skb)-&gt;dev;</span><br><span class="line"></span><br><span class="line">        IP_UPD_PO_STATS(dev_net(dev), IPSTATS_MIB_OUT, skb-&gt;len);</span><br><span class="line"></span><br><span class="line">        skb-&gt;dev = dev;</span><br><span class="line">        skb-&gt;protocol = htons(ETH_P_IP);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> NF_HOOK_COND(NFPROTO_IPV4, NF_INET_POST_ROUTING, skb, <span class="literal">NULL</span>, dev,</span><br><span class="line">                            ip_finish_output,</span><br><span class="line">                            !(IPCB(skb)-&gt;flags &amp; IPSKB_REROUTED));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>首先，更新 IPSTATS_MIB_OUT 统计计数。IP_UPD_PO_STATS 宏将更新字节数和包数统计。接下来，设置要发送此 skb 的设备，以及协议。<br><br>最后，通过调用 NF_HOOK_COND 将控制权交给 netfilter。查看 NF_HOOK_COND 的函数原型 有助于更清晰地解释它如何工作：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">static</span> <span class="keyword">inline</span> <span class="type">int</span></span><br><span class="line"><span class="title function_">NF_HOOK_COND</span><span class="params">(<span class="type">uint8_t</span> pf, <span class="type">unsigned</span> <span class="type">int</span> hook, <span class="keyword">struct</span> sk_buff *skb,</span></span><br><span class="line"><span class="params">             <span class="keyword">struct</span> net_device *in, <span class="keyword">struct</span> net_device *out,</span></span><br><span class="line"><span class="params">             <span class="type">int</span> (*okfn)(<span class="keyword">struct</span> sk_buff *), <span class="type">bool</span> cond)</span></span><br></pre></td></tr></table></figure>
<p>NF_HOOK_COND 通过检查传入的条件来工作。在这里条件是!(IPCB(skb)-&gt;flags &amp; IPSKB_REROUTED。如果此条件为真，则 skb 将发送给 netfilter。如果 netfilter 允许包通过 ，okfn 回调函数将被调用。在这里，okfn 是 ip_finish_output。</p>
<h2 id="5-ip-finish-output"><a href="#5-ip-finish-output" class="headerlink" title="5. ip_finish_output"></a>5. ip_finish_output</h2><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">static</span> <span class="type">int</span> <span class="title function_">ip_finish_output</span><span class="params">(<span class="keyword">struct</span> sk_buff *skb)</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="meta">#<span class="keyword">if</span> defined(CONFIG_NETFILTER) &amp;&amp; defined(CONFIG_XFRM)</span></span><br><span class="line">        <span class="comment">/* Policy lookup after SNAT yielded a new policy */</span></span><br><span class="line">        <span class="keyword">if</span> (skb_dst(skb)-&gt;xfrm != <span class="literal">NULL</span>) &#123;</span><br><span class="line">                IPCB(skb)-&gt;flags |= IPSKB_REROUTED;</span><br><span class="line">                <span class="keyword">return</span> dst_output(skb);</span><br><span class="line">        &#125;</span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line">        <span class="keyword">if</span> (skb-&gt;len &gt; ip_skb_dst_mtu(skb) &amp;&amp; !skb_is_gso(skb))</span><br><span class="line">                <span class="keyword">return</span> ip_fragment(skb, ip_finish_output2);</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">                <span class="keyword">return</span> ip_finish_output2(skb);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>如果内核启用了 netfilter 和数据包转换（XFRM），则更新 skb 的标志并通过 dst_output 将 其发回。<br></p>
<p>更常见的两种情况是：<br><br>1、如果数据包的长度大于 MTU 并且分片不会 offload 到设备，则会调用 ip_fragment 在发送之前对数据包进行分片<br><br>2、否则，数据包将直接发送到 ip_finish_output2<br></p>
<p><strong>Path MTU Discovery</strong><br></p>
<p>Linux 提供了一个功能：路径 MTU 发现 。此功能允许内核自动确定路由的最大传输单元（ MTU ）。发送小于或等于该路由的 MTU 的包意味着可以避免 IP 分片，这是推荐设置，因为数据包分片会消耗系统资源，而避免分片看起来很容易：只需发送足够小的不需要分片的数据包。</p>
<p>可以在应用程序中通过调用 setsockopt 带 SOL_IP 和 IP_MTU_DISCOVER 选项，在 packet 级别来调整路径 MTU 发现设置，相应的合法值参考 IP 协议的man page。例如，可能想设置的值是 ：IP_PMTUDISC_DO，表示“始终执行路径 MTU 发现”。更高级的网络应用程序或诊断工具可能选择自己实现RFC 4821，以在应用程序启动时针对特定的路由做 PMTU。在这种情况下，可以使用 IP_PMTUDISC_PROBE 选项告诉内核设置“Do not Fragment”位，这就会允许发送大于 PMTU 的数据。</p>
<p>应用程序可以通过调用 getsockopt 带 SOL_IP 和 IP_MTU 选项来查看当前 PMTU。可以使用它指导应用程序在发送之前，构造 UDP 数据报的大小。</p>
<p>如果已启用 PMTU 发现，则发送大于 PMTU 的 UDP 数据将导致应用程序收到 EMSGSIZE 错误。这种情况下，应用程序只能减小 packet 大小重试。</p>
<p>强烈建议启用 PTMU 发现，当查看 IP 协议层统计信息时，将解释所有统计信息，包括与分片相关的统计信息。其中许多计数都在 ip_fragment 中更新的。不管分片与否，代码最后都会调到 ip_finish_output2。</p>
<h2 id="6-ip-finish-output2"><a href="#6-ip-finish-output2" class="headerlink" title="6. ip_finish_output2"></a>6. ip_finish_output2</h2><p>IP 分片后调用 ip_finish_output2，另外 ip_finish_output 也会直接调用它。这个函数在将包发送到邻居缓存之前处理各种统计计数器：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">static</span> <span class="keyword">inline</span> <span class="type">int</span> <span class="title function_">ip_finish_output2</span><span class="params">(<span class="keyword">struct</span> sk_buff *skb)</span></span><br><span class="line">&#123;</span><br><span class="line"></span><br><span class="line">        <span class="comment">/* variable declarations */</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (rt-&gt;rt_type == RTN_MULTICAST) &#123;</span><br><span class="line">                IP_UPD_PO_STATS(dev_net(dev), IPSTATS_MIB_OUTMCAST, skb-&gt;len);</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (rt-&gt;rt_type == RTN_BROADCAST)</span><br><span class="line">                IP_UPD_PO_STATS(dev_net(dev), IPSTATS_MIB_OUTBCAST, skb-&gt;len);</span><br><span class="line"></span><br><span class="line">        <span class="comment">/* Be paranoid, rather than too clever. */</span></span><br><span class="line">        <span class="keyword">if</span> (unlikely(skb_headroom(skb) &lt; hh_len &amp;&amp; dev-&gt;header_ops)) &#123;</span><br><span class="line">                <span class="class"><span class="keyword">struct</span> <span class="title">sk_buff</span> *<span class="title">skb2</span>;</span></span><br><span class="line"></span><br><span class="line">                skb2 = skb_realloc_headroom(skb, LL_RESERVED_SPACE(dev));</span><br><span class="line">                <span class="keyword">if</span> (skb2 == <span class="literal">NULL</span>) &#123;</span><br><span class="line">                        kfree_skb(skb);</span><br><span class="line">                        <span class="keyword">return</span> -ENOMEM;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">if</span> (skb-&gt;sk)</span><br><span class="line">                        skb_set_owner_w(skb2, skb-&gt;sk);</span><br><span class="line">                consume_skb(skb);</span><br><span class="line">                skb = skb2;</span><br><span class="line">        &#125;</span><br></pre></td></tr></table></figure>
<p>如果与此数据包关联的路由是多播类型，则使用 IP_UPD_PO_STATS 宏来增加 OutMcastPkts 和 OutMcastOctets 计数。如果广播路由，则会增加 OutBcastPkts 和 OutBcastOctets 计数。<br><br>接下来，确保 skb 结构有足够的空间容纳需要添加的任何链路层头。如果空间不够，则调用 skb_realloc_headroom 分配额外的空间，并且新的 skb 的费用（charge）记在相关的 socket 上。</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">rcu_read_lock_bh();</span><br><span class="line">        nexthop = (__force u32) rt_nexthop(rt, ip_hdr(skb)-&gt;daddr);</span><br><span class="line">        neigh = __ipv4_neigh_lookup_noref(dev, nexthop);</span><br><span class="line">        <span class="keyword">if</span> (unlikely(!neigh))</span><br><span class="line">                neigh = __neigh_create(&amp;arp_tbl, &amp;nexthop, dev, <span class="literal">false</span>);</span><br></pre></td></tr></table></figure>
<p>继续，查询路由层找到下一跳，再根据下一跳信息查找邻居缓存。如果未找到，则调用__neigh_create 创建一个邻居。例如，第一次将数据发送到另一台主机的时候，就是这种情况。创建邻居缓存的时候带了 arp_tbl参数。其他系统（如 IPv6 或 DECnet）维护自己的 ARP 表，并将不同的变量传给__neigh_create。邻居缓存如果创建， 会导致缓存表增大。邻居缓存会导出一组统计信息，以便可以衡量这种增长。</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="keyword">if</span> (!IS_ERR(neigh)) &#123;</span><br><span class="line">                <span class="type">int</span> res = dst_neigh_output(dst, neigh, skb);</span><br><span class="line"></span><br><span class="line">                rcu_read_unlock_bh();</span><br><span class="line">                <span class="keyword">return</span> res;</span><br><span class="line">        &#125;</span><br><span class="line">        rcu_read_unlock_bh();</span><br><span class="line"></span><br><span class="line">        net_dbg_ratelimited(<span class="string">&quot;%s: No header cache and no neighbour!\n&quot;</span>,</span><br><span class="line">                            __func__);</span><br><span class="line">        kfree_skb(skb);</span><br><span class="line">        <span class="keyword">return</span> -EINVAL;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>最后，如果创建邻居缓存成功，则调用 <code>dst_neigh_output</code> 继续传递 skb；否则，释放 skb 并返回 EINVAL，这会向上传递，导致 OutDiscards 在 ip_send_skb 中递增。</p>
<h2 id="7-dst-neigh-output"><a href="#7-dst-neigh-output" class="headerlink" title="7. dst_neigh_output"></a>7. dst_neigh_output</h2><p><code>dst_neigh_output</code> 函数做了两件重要的事情。首先，如果用户调用 <code>sendmsg </code>并通过辅助消息指定 MSG_CONFIRM 参数，则会设置一个标志位以指示目标高速缓存条目仍然有效且不应进行垃圾回收。这个检查就是在这个函数里面做的，并且邻居上的 confirm 字段设置为当前的 jiffies 计数。</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">static</span> <span class="keyword">inline</span> <span class="type">int</span> <span class="title function_">dst_neigh_output</span><span class="params">(<span class="keyword">struct</span> dst_entry *dst, <span class="keyword">struct</span> neighbour *n,</span></span><br><span class="line"><span class="params">                                   <span class="keyword">struct</span> sk_buff *skb)</span></span><br><span class="line">&#123;</span><br><span class="line">        <span class="type">const</span> <span class="class"><span class="keyword">struct</span> <span class="title">hh_cache</span> *<span class="title">hh</span>;</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (dst-&gt;pending_confirm) &#123;</span><br><span class="line">                <span class="type">unsigned</span> <span class="type">long</span> now = jiffies;</span><br><span class="line"></span><br><span class="line">                dst-&gt;pending_confirm = <span class="number">0</span>;</span><br><span class="line">                <span class="comment">/* avoid dirtying neighbour */</span></span><br><span class="line">                <span class="keyword">if</span> (n-&gt;confirmed != now)</span><br><span class="line">                        n-&gt;confirmed = now;</span><br><span class="line">        &#125;</span><br></pre></td></tr></table></figure>
<p>其次，检查邻居的状态并调用适当的 output 函数。</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">hh = &amp;n-&gt;hh;</span><br><span class="line">        <span class="keyword">if</span> ((n-&gt;nud_state &amp; NUD_CONNECTED) &amp;&amp; hh-&gt;hh_len)</span><br><span class="line">                <span class="keyword">return</span> neigh_hh_output(hh, skb);</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">                <span class="keyword">return</span> n-&gt;output(n, skb);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>邻居被认为是 NUD_CONNECTED，如果它满足以下一个或多个条件：<br><br>1、NUD_PERMANENT：静态路由<br><br>2、NUD_NOARP：不需要 ARP 请求（例如，目标是多播或广播地址，或环回设备）<br><br>3、NUD_REACHABLE：邻居是“可达的。”只要成功处理了ARP 请求，目标就会被标记为可达<br></p>
<p>进一步，如果“硬件头”（hh）被缓存（之前已经发送过数据，并生成了缓存），将调用 neigh_hh_output。<br><br>否则，调用 output 函数。<br><br>以上两种情况，最后都会到 <code>dev_queue_xmit</code>，它将 skb 发送给 Linux 网络设备子系统，在它 进入设备驱动程序层之前将对其进行更多处理。让我们沿着 <code>neigh_hh_output</code> 和 <code>n-&gt;output</code> 代码继续向下，直到达到 <code>dev_queue_xmit</code>。</p>
<h3 id="7-1-neigh-hh-output"><a href="#7-1-neigh-hh-output" class="headerlink" title="7.1 neigh_hh_output"></a>7.1 neigh_hh_output</h3><p>如果目标是 NUD_CONNECTED 并且硬件头已被缓存，则将调用 <code>neigh_hh_output</code>，在将 skb 移交 给 <code>dev_queue_xmit</code> 之前执行一小部分处理 ：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">static</span> <span class="keyword">inline</span> <span class="type">int</span> <span class="title function_">neigh_hh_output</span><span class="params">(<span class="type">const</span> <span class="keyword">struct</span> hh_cache *hh, <span class="keyword">struct</span> sk_buff *skb)</span></span><br><span class="line">&#123;</span><br><span class="line">        <span class="type">unsigned</span> <span class="type">int</span> seq;</span><br><span class="line">        <span class="type">int</span> hh_len;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">do</span> &#123;</span><br><span class="line">                seq = read_seqbegin(&amp;hh-&gt;hh_lock);</span><br><span class="line">                hh_len = hh-&gt;hh_len;</span><br><span class="line">                <span class="keyword">if</span> (likely(hh_len &lt;= HH_DATA_MOD)) &#123;</span><br><span class="line">                        <span class="comment">/* this is inlined by gcc */</span></span><br><span class="line">                        <span class="built_in">memcpy</span>(skb-&gt;data - HH_DATA_MOD, hh-&gt;hh_data, HH_DATA_MOD);</span><br><span class="line">                 &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                         <span class="type">int</span> hh_alen = HH_DATA_ALIGN(hh_len);</span><br><span class="line"></span><br><span class="line">                         <span class="built_in">memcpy</span>(skb-&gt;data - hh_alen, hh-&gt;hh_data, hh_alen);</span><br><span class="line">                 &#125;</span><br><span class="line">         &#125; <span class="keyword">while</span> (read_seqretry(&amp;hh-&gt;hh_lock, seq));</span><br><span class="line"></span><br><span class="line">         skb_push(skb, hh_len);</span><br><span class="line">         <span class="keyword">return</span> dev_queue_xmit(skb);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这个函数理解有点难，部分原因是seqlock这个东西，它用于在缓存的硬件头上做读&#x2F;写锁。可以将上面的 do {} while ()循环想象成一个简单的重试机制，它将尝试在循环中执行，直到成功。<br><br>循环里处理硬件头的长度对齐。这是必需的，因为某些硬件头（如IEEE 802.11 头）大于 HH_DATA_MOD（16 字节）。<br><br>将头数据复制到 skb 后，<code>skb_push</code> 将更新 skb 内指向数据缓冲区的指针。最后调用 <code>dev_queue_xmit</code> 将 skb 传递给 Linux 网络设备子系统。<br></p>
<h3 id="7-2-n-output"><a href="#7-2-n-output" class="headerlink" title="7.2 n-&gt;output"></a>7.2 n-&gt;output</h3><p>如果目标不是 NUD_CONNECTED 或硬件头尚未缓存，则代码沿 n-&gt;output 路径向下。neigbour 结构上的 output 指针指向哪个函数？这得看情况。要了解这是如何设置的，我们需要更多地了解邻居缓存的工作原理。</p>
<p><code>struct neighbour</code> 包含几个重要字段：我们在上面看到的 <code>nud_state</code> 字段，output 函数和 ops 结构。回想一下，我们之前看到如果在缓存中找不到现有条目，会从 <code>ip_finish_output2</code> 调用<code>__neigh_create 创建一个。当调用__neigh_creaet</code> 时，将分配邻居，其 output 函数最初设置为<code> neigh_blackhole</code>。随着<code>__neigh_create</code> 代码的进行，它将根据邻居的状态修改 output 值以指向适当的发送方法。</p>
<p>例如，当代码确定是“已连接的”邻居时，<code>neigh_connect</code> 会将 <code>output</code> 设置为 <code>neigh-&gt;ops-&gt;connected_output</code>。或者，当代码怀疑邻居可能已关闭时，<code>neigh_suspect</code> 会将 <code>output</code> 设置为 <code>neigh-&gt;ops-&gt;output</code>（例如，如果已超过 <code>/proc/sys/net/ipv4/neigh/default/delay_first_probe_time</code> 自发送探测以来的 <code>delay_first_probe_time</code> 秒）。</p>
<p>换句话说：<code>neigh-&gt;output</code> 会被设置为 <code>neigh-&gt;ops_connected_output</code> 或 <code>neigh-&gt;ops-&gt;output</code>，具体取决于邻居的状态。<code>neigh-&gt;ops</code> 来自哪里？</p>
<p>分配邻居后，调用 <code>arp_constructor（net/ipv4/arp.c ）</code>来设置 <code>struct neighbor</code> 的某些字段。特别是，此函数会检查与此邻居关联的设备是否导出来一个 <code>struct header_ops</code> 实例， 该结构体有一个 <code>cache</code> 方法。</p>
<p><code>neigh-&gt;ops</code> 设置为 <code>net/ipv4/arp</code> 中定义的以下实例：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">static</span> <span class="type">const</span> <span class="class"><span class="keyword">struct</span> <span class="title">neigh_ops</span> <span class="title">arp_hh_ops</span> =</span> &#123;</span><br><span class="line">        .family =               AF_INET,</span><br><span class="line">        .solicit =              arp_solicit,</span><br><span class="line">        .error_report =         arp_error_report,</span><br><span class="line">        .output =               neigh_resolve_output,</span><br><span class="line">        .connected_output =     neigh_resolve_output,</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>所以，不管 neighbor 是不是“已连接的”，或者邻居缓存代码是否怀疑连接“已关闭”， <code>neigh_resolve_output</code> 最终都会被赋给 <code>neigh-&gt;output</code>。当执行到 <code>n-&gt;output</code> 时就会调用它。</p>
<h3 id="7-3-neigh-resolve-output"><a href="#7-3-neigh-resolve-output" class="headerlink" title="7.3 neigh_resolve_output"></a>7.3 neigh_resolve_output</h3><p>此函数的目的是解析未连接的邻居，或已连接但没有缓存硬件头的邻居。</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">/* Slow and careful. */</span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">neigh_resolve_output</span><span class="params">(<span class="keyword">struct</span> neighbour *neigh, <span class="keyword">struct</span> sk_buff *skb)</span></span><br><span class="line">&#123;</span><br><span class="line">        <span class="class"><span class="keyword">struct</span> <span class="title">dst_entry</span> *<span class="title">dst</span> =</span> skb_dst(skb);</span><br><span class="line">        <span class="type">int</span> rc = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (!dst)</span><br><span class="line">                <span class="keyword">goto</span> discard;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (!neigh_event_send(neigh, skb)) &#123;</span><br><span class="line">                <span class="type">int</span> err;</span><br><span class="line">                <span class="class"><span class="keyword">struct</span> <span class="title">net_device</span> *<span class="title">dev</span> =</span> neigh-&gt;dev;</span><br><span class="line">                <span class="type">unsigned</span> <span class="type">int</span> seq;</span><br><span class="line">       &#125;</span><br><span class="line">&#125; </span><br></pre></td></tr></table></figure>
<p>代码首先进行一些基本检查，然后调用 <code>neigh_event_send。 neigh_event_send</code> 函数是 <code>__neigh_event_send</code> 的简单封装，后者干大部分脏话累活。可以在 <code>net/core/neighbour.c</code> 中读<code>__neigh_event_send</code>的源代码，从大的层面看，三种情况：</p>
<ul>
<li>NUD_NONE 状态（默认状态）的邻居：假设 <code>/proc/sys/net/ipv4/neigh/default/app_solicit</code> 和 <code>/proc/sys/net/ipv4/neigh/default/mcast_solicit</code> 配置允许发送探测（如果不是， 则将状态标记为 NUD_FAILED），将导致立即发送 ARP 请求。邻居状态将更新为 <code>NUD_INCOMPLETE</code></li>
<li>NUD_STALE 状态的邻居：将更新为 <code>NUD_DELAYED</code> 并且将设置计时器以稍后探测它们（ 稍后是现在的时间+&#x2F;proc&#x2F;sys&#x2F;net&#x2F;ipv4&#x2F;neigh&#x2F;default&#x2F;delay_first_probe_time 秒 ）</li>
<li>检查 NUD_INCOMPLETE 状态的邻居（包括上面第一种情形），以确保未解析邻居的排 队 packet 的数量小于等于&#x2F;proc&#x2F;sys&#x2F;net&#x2F;ipv4&#x2F;neigh&#x2F;default&#x2F;unres_qlen。如果超过 ，则数据包会出列并丢弃，直到小于等于 proc 中的值。统计信息中有个计数器会因此 更新</li>
</ul>
<p>如果需要 ARP 探测，ARP 将立即被发送。<code>__neigh_event_send</code> 将返回 0，表示邻居被视为“已 连接”或“已延迟”，否则返回 1。返回值 0 允许 <code>eigh_resolve_output</code> 继续：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="keyword">if</span> (dev-&gt;header_ops-&gt;cache &amp;&amp; !neigh-&gt;hh.hh_len)</span><br><span class="line">                        neigh_hh_init(neigh, dst);</span><br></pre></td></tr></table></figure>
<p>如果邻居关联的设备的协议实现（在我们的例子中是以太网）支持缓存硬件头，并且当前没有缓存，<code>neigh_hh_init</code> 将缓存它。</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="keyword">do</span> &#123;</span><br><span class="line">                        __skb_pull(skb, skb_network_offset(skb));</span><br><span class="line">                        seq = read_seqbegin(&amp;neigh-&gt;ha_lock);</span><br><span class="line">                        err = dev_hard_header(skb, dev, ntohs(skb-&gt;protocol),</span><br><span class="line">                                              neigh-&gt;ha, <span class="literal">NULL</span>, skb-&gt;len);</span><br><span class="line">                &#125; <span class="keyword">while</span> (read_seqretry(&amp;neigh-&gt;ha_lock, seq));</span><br></pre></td></tr></table></figure>
<p>接下来，seqlock 锁控制对邻居的硬件地址字段（neigh-&gt;ha）的访问。<code>ev_hard_header</code> 为 skb 创建以太网头时将读取该字段。之后是错误检查：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="keyword">if</span> (err &gt;= <span class="number">0</span>)</span><br><span class="line">                        rc = dev_queue_xmit(skb);</span><br><span class="line">                <span class="keyword">else</span></span><br><span class="line">                        <span class="keyword">goto</span> out_kfree_skb;</span><br><span class="line">        &#125;</span><br></pre></td></tr></table></figure>
<p>如果以太网头写入成功，将调用 <code>dev_queue_xmit</code> 将 skb 传递给 Linux 网络设备子系统进行发 送。如果出现错误，goto 将删除 skb，设置并返回错误码：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">out:</span><br><span class="line">        return rc;</span><br><span class="line">discard:</span><br><span class="line">        neigh_dbg(1, &quot;%s: dst=%p neigh=%p\n&quot;, __func__, dst, neigh);</span><br><span class="line">out_kfree_skb:</span><br><span class="line">        rc = -EINVAL;</span><br><span class="line">        kfree_skb(skb);</span><br><span class="line">        goto out;</span><br><span class="line">&#125;</span><br><span class="line">EXPORT_SYMBOL(neigh_resolve_output);</span><br></pre></td></tr></table></figure>
<p>接下来看一些用于监控和转换 IP 协议层的文件。</p>
<h2 id="8-监控-IP-层"><a href="#8-监控-IP-层" class="headerlink" title="8. 监控: IP 层"></a>8. 监控: IP 层</h2><h3 id="8-1-proc-net-snmp"><a href="#8-1-proc-net-snmp" class="headerlink" title="8.1 &#x2F;proc&#x2F;net&#x2F;snmp"></a>8.1 &#x2F;proc&#x2F;net&#x2F;snmp</h3><p>这个文件包扩多种协议的统计，IP 层的在最前面，每一列代表什么有说明。<br><br>前面我们已经看到 IP 协议层有一些地方会更新计数器。这些计数器的类型是 C 枚举类型，定义在<code>include/uapi/linux/snmp.h</code>:</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">enum</span><br><span class="line">&#123;</span><br><span class="line">  IPSTATS_MIB_NUM = 0,</span><br><span class="line">/* frequently written fields in fast path, kept in same cache line */</span><br><span class="line">  IPSTATS_MIB_INPKTS,     /* InReceives */</span><br><span class="line">  IPSTATS_MIB_INOCTETS,     /* InOctets */</span><br><span class="line">  IPSTATS_MIB_INDELIVERS,     /* InDelivers */</span><br><span class="line">  IPSTATS_MIB_OUTFORWDATAGRAMS,   /* OutForwDatagrams */</span><br><span class="line">  IPSTATS_MIB_OUTPKTS,      /* OutRequests */</span><br><span class="line">  IPSTATS_MIB_OUTOCTETS,      /* OutOctets */</span><br><span class="line"></span><br><span class="line">  /* ... */</span><br></pre></td></tr></table></figure>
<p>一些有趣的统计：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">OutRequests: Incremented each time an IP packet is attempted to be sent. It appears that this is incremented for every send, successful or not.</span><br><span class="line">OutDiscards: Incremented each time an IP packet is discarded. This can happen if appending data to the skb (for corked sockets) fails, or if the layers below IP return an error.</span><br><span class="line">OutNoRoute: Incremented in several places, for example in the UDP protocol layer (udp_sendmsg) if no route can be generated for a given destination. Also incremented when an application calls “connect” on a UDP socket but no route can be found.</span><br><span class="line">FragOKs: Incremented once per packet that is fragmented. For example, a packet split into 3 fragments will cause this counter to be incremented once.</span><br><span class="line">FragCreates: Incremented once per fragment that is created. For example, a packet split into 3 fragments will cause this counter to be incremented thrice.</span><br><span class="line">FragFails: Incremented if fragmentation was attempted, but is not permitted (because the “Don’t Fragment” bit is set). Also incremented if outputting the fragment fails.</span><br></pre></td></tr></table></figure>
<h3 id="8-2-proc-net-netstat"><a href="#8-2-proc-net-netstat" class="headerlink" title="8.2 &#x2F;proc&#x2F;net&#x2F;netstat"></a>8.2 &#x2F;proc&#x2F;net&#x2F;netstat</h3><p>格式与前面的类似，除了每列的名称都有 IpExt 前缀之外。<br><br>一些有趣的统计：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">OutMcastPkts: Incremented each time a packet destined for a multicast address is sent.</span><br><span class="line">OutBcastPkts: Incremented each time a packet destined for a broadcast address is sent.</span><br><span class="line">OutOctects: The number of packet bytes output.</span><br><span class="line">OutMcastOctets: The number of multicast packet bytes output.</span><br><span class="line">OutBcastOctets: The number of broadcast packet bytes output.</span><br></pre></td></tr></table></figure>
<h2 id="9-总结"><a href="#9-总结" class="headerlink" title="9. 总结"></a>9. 总结</h2><p>Linux内核网络数据包发送时，主要用到<code> ip_send_skb</code>、 <code>ip_local_out</code>、<code>ip_output</code>、<code>ip_finish_output</code>、<code>ip_finish_output2</code>、 <code>st_neigh_output</code>等函数，本文通过分析这些函数来分享Linux内核数据包发送在 IP 层的处理，并对 IP 层进行了数据监控。</p>
]]></content>
      <categories>
        <category>linux-doc 网络协议栈</category>
      </categories>
      <tags>
        <tag>Linux</tag>
      </tags>
  </entry>
  <entry>
    <title>Linux内核网络udp数据包发送(一)</title>
    <url>/2023/01/15/linux-docs/%E7%BD%91%E7%BB%9C%E5%8D%8F%E8%AE%AE%E6%A0%88/Linux%E5%86%85%E6%A0%B8%E7%BD%91%E7%BB%9Cudp%E6%95%B0%E6%8D%AE%E5%8C%85%E5%8F%91%E9%80%81(%E4%B8%80)/</url>
    <content><![CDATA[<h2 id="1-前言"><a href="#1-前言" class="headerlink" title="1.前言"></a>1.前言</h2><p>本文首先从宏观上概述了数据包发送的流程，然后分析了协议层注册进内核以及被套接字的过程，最后介绍了通过套接字发送网络数据的过程。</p>
<h2 id="2-数据包发送宏观视角"><a href="#2-数据包发送宏观视角" class="headerlink" title="2.数据包发送宏观视角"></a>2.数据包发送宏观视角</h2><p>从宏观上看，一个数据包从用户程序到达硬件网卡的整个过程如下：<br></p>
<p>1、使用系统调用（如 sendto，sendmsg 等）写数据<br><br>2、数据分段socket顶部，进入socket协议族（protocol family）系统<br><br>3、协议族处理：数据跨越协议层，这一过程（在许多情况下）转变数据（数据）转换成数据包（packet）<br><br>4、数据传输路由层，这会涉及路由缓存和ARP缓存的更新；如果目的MAC不在ARP缓存表中，将触发一次ARP广播来查找MAC地址<br><br>5、穿过协议层，packet到达设备无关层（设备不可知层）<br><br>6、使用XPS（如果启用）或散列函数选择发送坐标<br><br>7、调用网卡驱动的发送函数<br><br>8、数据传送到网卡的 qdisc（queue纪律，排队规则）<br><br>9、qdisc会直接发送数据（如果可以），或者将其放到串行，然后触发NET_TX类型软中断（softirq）的时候再发送<br><br>10、数据从qdisc传送给驱动程序<br><br>11、驱动程序创建所需的DMA映射，刹车网卡从RAM读取数据<br><br>12、驱动向网卡发送信号，通知数据可以发送了<br><br>13、网卡从RAM中获取数据并发送<br><br>14、发送完成后，设备触发一个硬中断（IRQ），表示发送完成<br><br>15、中断硬处理函数被唤醒执行。对许多设备来说，会这触发NET_RX类型的软中断，然后NAPI投票循环开始收包<br><br>16、poll函数会调用驱动程序的相应函数，解除DMA映射，释放数据<br></p>
<h2 id="3-协议层注册"><a href="#3-协议层注册" class="headerlink" title="3.协议层注册"></a>3.协议层注册</h2><p>协议层分析我们将关注IP和UDP层，其他协议层可参考这个过程。<br><br>当用户程序像下面这样创建UDP套接字时会发生什么？<br></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">sock = socket(AF_INET, SOCK_DGRAM, IPPROTO_UDP)</span><br></pre></td></tr></table></figure>

<p>简单来说，内核会去查找由UDP协议栈创建的一个单独的函数（其中包括用于发送和接收网络数据的函数），并赋予给套接字相应的分区 AF_INET 。<br><br>内核初始化的很早阶段就执行了 inet_init 函数，这个函数会注册 AF_INET 协议族，以及该协议族内部的各协议栈（TCP，UDP，ICMP和RAW），并初始化函数使协议栈准备好处理网络数据。inet_init 定义在net &#x2F; ipv4 &#x2F; af_inet.c。<br><br>AF_INET 协议族源自一个包含 create 方法的 struct net_proto_family 类型实例。当从用户程序创建socket时，内核会调用此方法：<br></p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">static</span> <span class="type">const</span> <span class="class"><span class="keyword">struct</span> <span class="title">net_proto_family</span> <span class="title">inet_family_ops</span> =</span> &#123;</span><br><span class="line">    .family = PF_INET,</span><br><span class="line">    .create = inet_create,</span><br><span class="line">    .owner  = THIS_MODULE,</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>inet_create 根据传递的套接字参数，在已注册的协议中查找对应的协议：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">/* Look for the requested type/protocol pair. */</span></span><br><span class="line">lookup_protocol:</span><br><span class="line">        err = -ESOCKTNOSUPPORT;</span><br><span class="line">        rcu_read_lock();</span><br><span class="line">        list_for_each_entry_rcu(answer, &amp;inetsw[sock-&gt;type], <span class="built_in">list</span>) &#123;</span><br><span class="line"></span><br><span class="line">                err = <span class="number">0</span>;</span><br><span class="line">                <span class="comment">/* Check the non-wild match. */</span></span><br><span class="line">                <span class="keyword">if</span> (protocol == answer-&gt;protocol) &#123;</span><br><span class="line">                        <span class="keyword">if</span> (protocol != IPPROTO_IP)</span><br><span class="line">                                <span class="keyword">break</span>;</span><br><span class="line">                &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                        <span class="comment">/* Check for the two wild cases. */</span></span><br><span class="line">                        <span class="keyword">if</span> (IPPROTO_IP == protocol) &#123;</span><br><span class="line">                                protocol = answer-&gt;protocol;</span><br><span class="line">                                <span class="keyword">break</span>;</span><br><span class="line">                        &#125;</span><br><span class="line">                        <span class="keyword">if</span> (IPPROTO_IP == answer-&gt;protocol)</span><br><span class="line">                                <span class="keyword">break</span>;</span><br><span class="line">                &#125;</span><br><span class="line">                err = -EPROTONOSUPPORT;</span><br><span class="line">        &#125;</span><br></pre></td></tr></table></figure>

<p>然后，引入协议的某些方法（集合）赋给这个新创建的socket：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">sock-&gt;ops = answer-&gt;ops;</span><br></pre></td></tr></table></figure>

<p>可以在 af_inet.c 中看到所有协议的初始化参数。下面是TCP和UDP的初始化参数：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">/* Upon startup we insert all the elements in inetsw_array[] into</span></span><br><span class="line"><span class="comment"> * the linked list inetsw.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="type">static</span> <span class="class"><span class="keyword">struct</span> <span class="title">inet_protosw</span> <span class="title">inetsw_array</span>[] =</span></span><br><span class="line">&#123;</span><br><span class="line">        &#123;</span><br><span class="line">                .type =       SOCK_STREAM,</span><br><span class="line">                .protocol =   IPPROTO_TCP,</span><br><span class="line">                .prot =       &amp;tcp_prot,</span><br><span class="line">                .ops =        &amp;inet_stream_ops,</span><br><span class="line">                .no_check =   <span class="number">0</span>,</span><br><span class="line">                .flags =      INET_PROTOSW_PERMANENT |</span><br><span class="line">                              INET_PROTOSW_ICSK,</span><br><span class="line">        &#125;,</span><br><span class="line"></span><br><span class="line">        &#123;</span><br><span class="line">                .type =       SOCK_DGRAM,</span><br><span class="line">                .protocol =   IPPROTO_UDP,</span><br><span class="line">                .prot =       &amp;udp_prot,</span><br><span class="line">                .ops =        &amp;inet_dgram_ops,</span><br><span class="line">                .no_check =   UDP_CSUM_DEFAULT,</span><br><span class="line">                .flags =      INET_PROTOSW_PERMANENT,</span><br><span class="line">       &#125;,</span><br><span class="line"></span><br><span class="line">            <span class="comment">/* .... more protocols ... */</span></span><br></pre></td></tr></table></figure>

<p>IPPROTO_UDP 协议类型有一个 ops 变量，包含很多信息，包括用于发送和接收数据的替代函数：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">const</span> <span class="class"><span class="keyword">struct</span> <span class="title">proto_ops</span> <span class="title">inet_dgram_ops</span> =</span> &#123;</span><br><span class="line">	.family          = PF_INET,</span><br><span class="line">	.owner           = THIS_MODULE,</span><br><span class="line">	</span><br><span class="line">	<span class="comment">/* ... */</span></span><br><span class="line">	</span><br><span class="line">	.sendmsg     = inet_sendmsg,</span><br><span class="line">	.recvmsg     = inet_recvmsg,</span><br><span class="line">	</span><br><span class="line">	<span class="comment">/* ... */</span></span><br><span class="line">&#125;;</span><br><span class="line">EXPORT_SYMBOL(inet_dgram_ops);</span><br></pre></td></tr></table></figure>

<p>prot UDP协议对应的 prot 变量为 udp_prot，定义在net &#x2F; ipv4 &#x2F; udp.c：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">proto</span> <span class="title">udp_prot</span> =</span> &#123;</span><br><span class="line">	.name        = <span class="string">&quot;UDP&quot;</span>,</span><br><span class="line">	.owner           = THIS_MODULE,</span><br><span class="line">	</span><br><span class="line">	<span class="comment">/* ... */</span></span><br><span class="line">	</span><br><span class="line">	.sendmsg     = udp_sendmsg,</span><br><span class="line">	.recvmsg     = udp_recvmsg,</span><br><span class="line">	</span><br><span class="line">	<span class="comment">/* ... */</span></span><br><span class="line">&#125;;</span><br><span class="line">EXPORT_SYMBOL(udp_prot);</span><br></pre></td></tr></table></figure>

<p>现在，让我们转向发送UDP数据的用户程序，看看 udp_sendmsg 是如何在内核中被调用的。</p>
<h2 id="4-通过套接字发送网络数据"><a href="#4-通过套接字发送网络数据" class="headerlink" title="4.通过套接字发送网络数据"></a>4.通过套接字发送网络数据</h2><p>用户程序想发送UDP网络数据，因此它使用 sendto 系统调用：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">ret = sendto(socket, buffer, buflen, 0, &amp;dest, sizeof(dest));</span><br></pre></td></tr></table></figure>

<p>该系统调用串联Linux系统调用（系统调用）层，最后到达net &#x2F; socket.c中的这个函数：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> *      Send a datagram to a given address. We move the address into kernel</span></span><br><span class="line"><span class="comment"> *      space and check the user space data area is readable before invoking</span></span><br><span class="line"><span class="comment"> *      the protocol.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"></span><br><span class="line">SYSCALL_DEFINE6(sendto, <span class="type">int</span>, fd, <span class="type">void</span> __user *, buff, <span class="type">size_t</span>, len,</span><br><span class="line">                <span class="type">unsigned</span> <span class="type">int</span>, flags, <span class="keyword">struct</span> sockaddr __user *, addr,</span><br><span class="line">                <span class="type">int</span>, addr_len)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">/*  ... code ... */</span></span><br><span class="line"></span><br><span class="line">    err = sock_sendmsg(sock, &amp;msg, len);</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* ... code  ... */</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>SYSCALL_DEFINE6 宏会展开成一堆宏，并通过一波复杂操作创建出一个带。6个参数的系统调用（因此叫 DEFINE6）。作为结果之一，会看到内核中的所有系统调用都带 sys_相连。<br><br>sendto 代码会先将数据整理成一体的可能可以处理的格式，然后调用 sock_sendmsg。特别地，依次传递给 sendto 的地址放到另一个变量（msg）中：<br></p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">iov.iov_base = buff;</span><br><span class="line">iov.iov_len = len;</span><br><span class="line">msg.msg_name = <span class="literal">NULL</span>;</span><br><span class="line">msg.msg_iov = &amp;iov;</span><br><span class="line">msg.msg_iovlen = <span class="number">1</span>;</span><br><span class="line">msg.msg_control = <span class="literal">NULL</span>;</span><br><span class="line">msg.msg_controllen = <span class="number">0</span>;</span><br><span class="line">msg.msg_namelen = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">if</span> (addr) &#123;</span><br><span class="line">        err = move_addr_to_kernel(addr, addr_len, &amp;address);</span><br><span class="line">        <span class="keyword">if</span> (err &lt; <span class="number">0</span>)</span><br><span class="line">                <span class="keyword">goto</span> out_put;</span><br><span class="line">        msg.msg_name = (<span class="keyword">struct</span> sockaddr *)&amp;address;</span><br><span class="line">        msg.msg_namelen = addr_len;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这段代码将用户程序传入到内核的（存放待发送数据的）地址，作为 msg_name 字段嵌入到 struct msghdr 类型变量中。状语从句：这用户程序直接调用 sendmsg 而不是 sendto 发送数据差不多，这之所以可行，因为的英文 sendto 状语从句： sendmsg 底层都会调用 sock_sendmsg。</p>
<h3 id="4-1-sock-sendmsg，-sock-sendmsg，-sock-sendmsg-nosec"><a href="#4-1-sock-sendmsg，-sock-sendmsg，-sock-sendmsg-nosec" class="headerlink" title="4.1  sock_sendmsg，  __sock_sendmsg， __sock_sendmsg_nosec"></a>4.1  <code>sock_sendmsg</code>，  <code>__sock_sendmsg</code>， <code>__sock_sendmsg_nosec</code></h3><p><code>sock_sendmsg</code> 做一些错误检查，然后调用<code>__sock_sendmsg</code>;后者做一些自己的错误检查，然后调用<code>__sock_sendmsg_nosec</code>。</p>
<p><code>__sock_sendmsg_nosec </code>将数据传递到插座子系统的更深处：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">static</span> <span class="keyword">inline</span> <span class="type">int</span> __sock_sendmsg_nosec(<span class="keyword">struct</span> kiocb *iocb, <span class="keyword">struct</span> socket *sock,</span><br><span class="line">                                       <span class="keyword">struct</span> msghdr *msg, <span class="type">size_t</span> size)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">sock_iocb</span> *<span class="title">si</span> =</span>  ....</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* other code ... */</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> sock-&gt;ops-&gt;sendmsg(iocb, sock, msg, size);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>通过前面介绍的socket创建过程，可以知道注册到这里的 sendmsg 方法就是 inet_sendmsg。</p>
<h3 id="4-2-inet-sendmsg"><a href="#4-2-inet-sendmsg" class="headerlink" title="4.2 inet_sendmsg"></a>4.2 inet_sendmsg</h3><p>从名字可以猜到，的英文这 AF_INET 协议族提供的通用函数此函数首先调用。 sock_rps_record_flow 来记录最后一个处理该（数据所属的）流的CPU; 接下来，调用套接字的协议类型（本例是UDP）对应的 sendmsg 方法：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">inet_sendmsg</span><span class="params">(<span class="keyword">struct</span> kiocb *iocb, <span class="keyword">struct</span> socket *sock, <span class="keyword">struct</span> msghdr *msg,</span></span><br><span class="line"><span class="params">                 <span class="type">size_t</span> size)</span></span><br><span class="line">&#123;</span><br><span class="line">      <span class="class"><span class="keyword">struct</span> <span class="title">sock</span> *<span class="title">sk</span> =</span> sock-&gt;sk;</span><br><span class="line"></span><br><span class="line">      sock_rps_record_flow(sk);</span><br><span class="line"></span><br><span class="line">      <span class="comment">/* We may need to bind the socket. */</span></span><br><span class="line">      <span class="keyword">if</span> (!inet_sk(sk)-&gt;inet_num &amp;&amp; !sk-&gt;sk_prot-&gt;no_autobind &amp;&amp; inet_autobind(sk))</span><br><span class="line">              <span class="keyword">return</span> -EAGAIN;</span><br><span class="line"></span><br><span class="line">      <span class="keyword">return</span> sk-&gt;sk_prot-&gt;sendmsg(iocb, sk, msg, size);</span><br><span class="line">&#125;</span><br><span class="line">EXPORT_SYMBOL(inet_sendmsg);</span><br></pre></td></tr></table></figure>

<p>本例是UDP协议，因此上面的 sk-&gt;sk_prot-&gt;sendmsg 指向的是之前udp_prot 看到的（通过 导出的）udp_sendmsg 函数。<br><br>sendmsg（）函数作为分界点，处理逻辑从AF_INET协议族通用处理转移到特定的UDP协议的处理。<br></p>
]]></content>
      <categories>
        <category>linux-doc 网络协议栈</category>
      </categories>
      <tags>
        <tag>Linux</tag>
      </tags>
  </entry>
  <entry>
    <title>Linux内核网络udp数据包发送（二）-UDP协议层分析</title>
    <url>/2023/01/15/linux-docs/%E7%BD%91%E7%BB%9C%E5%8D%8F%E8%AE%AE%E6%A0%88/Linux%E5%86%85%E6%A0%B8%E7%BD%91%E7%BB%9Cudp%E6%95%B0%E6%8D%AE%E5%8C%85%E5%8F%91%E9%80%81%EF%BC%88%E4%BA%8C%EF%BC%89-UDP%E5%8D%8F%E8%AE%AE%E5%B1%82%E5%88%86%E6%9E%90/</url>
    <content><![CDATA[<h2 id="1-前言"><a href="#1-前言" class="headerlink" title="1.前言"></a>1.前言</h2><p>本文分享了Linux内核网络数据包发送在UDP协议层的处理，主要分析了udp_sendmsg和udp_send_skb函数，并分享了UDP层的数据统计和监控以及套接字发送大小的调优。</p>
<h2 id="2-udp-sendmsg"><a href="#2-udp-sendmsg" class="headerlink" title="2.udp_sendmsg"></a>2.udp_sendmsg</h2><p>这个函数定义在net &#x2F; ipv4 &#x2F; udp.c，函数很长，分段来看。</p>
<h3 id="2-1-UDP插入"><a href="#2-1-UDP插入" class="headerlink" title="2.1 UDP插入"></a>2.1 UDP插入</h3><p>UDP udp_sendmsg corking是一项优化技术，允许内核将多个数据累积成一体的数据报发送。在用户程序中有两种方法可以启用此选项：</p>
<ul>
<li>使用 setsockopt 系统调用设置socket的 UDP_CORK 选项</li>
<li>程序调用 send，sendto 或 sendmsg 时，带 MSG_MORE 参数</li>
</ul>
<p>udp_sendmsg 代码检查 up-&gt;pending 套接字socket当前是否已被塞住（corked），如果是，则直接跳到 do_append_data 进行数据追加（append）。</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">udp_sendmsg</span><span class="params">(<span class="keyword">struct</span> kiocb *iocb, <span class="keyword">struct</span> sock *sk, <span class="keyword">struct</span> msghdr *msg,</span></span><br><span class="line"><span class="params">                <span class="type">size_t</span> len)</span></span><br><span class="line">&#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* variables and error checking ... */</span></span><br><span class="line"></span><br><span class="line">  fl4 = &amp;inet-&gt;cork.fl.u.ip4;</span><br><span class="line">  <span class="keyword">if</span> (up-&gt;pending) &#123;</span><br><span class="line">          <span class="comment">/*</span></span><br><span class="line"><span class="comment">           * There are pending frames.</span></span><br><span class="line"><span class="comment">           * The socket lock must be held while it&#x27;s corked.</span></span><br><span class="line"><span class="comment">           */</span></span><br><span class="line">          lock_sock(sk);</span><br><span class="line">          <span class="keyword">if</span> (likely(up-&gt;pending)) &#123;</span><br><span class="line">                  <span class="keyword">if</span> (unlikely(up-&gt;pending != AF_INET)) &#123;</span><br><span class="line">                          release_sock(sk);</span><br><span class="line">                          <span class="keyword">return</span> -EINVAL;</span><br><span class="line">                  &#125;</span><br><span class="line">                  <span class="keyword">goto</span> do_append_data;</span><br><span class="line">          &#125;</span><br><span class="line">          release_sock(sk);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h2 id="2-2获取目的IP地址和端口"><a href="#2-2获取目的IP地址和端口" class="headerlink" title="2.2获取目的IP地址和端口"></a>2.2获取目的IP地址和端口</h2><p>接下来获取目的IP地址和端口，有两个可能的来源：</p>
<ul>
<li>如果之前socket已经建立连接，那socket本身就存储了目标地址</li>
<li>地址通过辅助结构（struct msghdr）预测，逐步我们在 sendto 的内核代码中看到的那样</li>
</ul>
<p>具体逻辑：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> *      Get and verify the address.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line">  <span class="keyword">if</span> (msg-&gt;msg_name) &#123;</span><br><span class="line">          <span class="class"><span class="keyword">struct</span> <span class="title">sockaddr_in</span> *<span class="title">usin</span> =</span> (<span class="keyword">struct</span> sockaddr_in *)msg-&gt;msg_name;</span><br><span class="line">          <span class="keyword">if</span> (msg-&gt;msg_namelen &lt; <span class="keyword">sizeof</span>(*usin))</span><br><span class="line">                  <span class="keyword">return</span> -EINVAL;</span><br><span class="line">          <span class="keyword">if</span> (usin-&gt;sin_family != AF_INET) &#123;</span><br><span class="line">                  <span class="keyword">if</span> (usin-&gt;sin_family != AF_UNSPEC)</span><br><span class="line">                          <span class="keyword">return</span> -EAFNOSUPPORT;</span><br><span class="line">          &#125;</span><br><span class="line"></span><br><span class="line">          daddr = usin-&gt;sin_addr.s_addr;</span><br><span class="line">          dport = usin-&gt;sin_port;</span><br><span class="line">          <span class="keyword">if</span> (dport == <span class="number">0</span>)</span><br><span class="line">                  <span class="keyword">return</span> -EINVAL;</span><br><span class="line">  &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">          <span class="keyword">if</span> (sk-&gt;sk_state != TCP_ESTABLISHED)</span><br><span class="line">                  <span class="keyword">return</span> -EDESTADDRREQ;</span><br><span class="line">          daddr = inet-&gt;inet_daddr;</span><br><span class="line">          dport = inet-&gt;inet_dport;</span><br><span class="line">          <span class="comment">/* Open fast path for connected socket.</span></span><br><span class="line"><span class="comment">             Route will not be used, if at least one option is set.</span></span><br><span class="line"><span class="comment">           */</span></span><br><span class="line">          connected = <span class="number">1</span>;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>UDP代码中出现了 TCP_ESTABLISHED！UDP套接字的状态使用了TCP状态来描述。的上面显示代码了内核如何解析该变量以便设置 daddr 状语从句：  dport。</p>
<p>如果没有 struct msghdr 变量，内核函数到达 udp_sendmsg 函数时，会从socket本身检索目的地址和端口，插入socket标记为“已连接”。</p>
<h3 id="2-3套接字发送：簿记和打合并"><a href="#2-3套接字发送：簿记和打合并" class="headerlink" title="2.3套接字发送：簿记和打合并"></a>2.3套接字发送：簿记和打合并</h3><p>接下来，获取存储在插座上的源地址，设备索引（设备索引）和时间戳选项（例如SOCK_TIMESTAMPING_TX_HARDWARE，  SOCK_TIMESTAMPING_TX_SOFTWARE，  SOCK_WIFI_STATUS）：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">ipc.addr = inet-&gt;inet_saddr;</span><br><span class="line"></span><br><span class="line">ipc.oif = sk-&gt;sk_bound_dev_if;</span><br><span class="line"></span><br><span class="line">sock_tx_timestamp(sk, &amp;ipc.tx_flags);</span><br></pre></td></tr></table></figure>

<h3 id="2-4辅助消息（辅助消息）"><a href="#2-4辅助消息（辅助消息）" class="headerlink" title="2.4辅助消息（辅助消息）"></a>2.4辅助消息（辅助消息）</h3><p>除了发送或接收数据包之外，sendmsg 状语从句： recvmsg 系统-调用还网求允许用户设置或请求辅助数据。程序用户可以通过将请求信息组织分类中翻译 struct msghdr 类型变量来利用此辅助数据。一些辅助数据类型记录在IP手册页中。</p>
<p>辅助数据的一个常见例子是 IP_PKTINFO，对于 sendmsg，IP_PKTINFO 网求允许程序在发送数据时设置一个 in_pktinfo 变量。可以程序通过填写回复时 struct in_pktinfo 变量中的字段来指定要在包上使用的源地址。如果程序是监听多个IP地址的服务端程序，那这是一个很有用的选项。在这种情况下，服务端可能想使用客户端连接服务端的那个IP地址来回复客户端，IP_PKTINFO 非常适合这种场景。</p>
<p>setsockopt 可以在套接字级别设置发送包的IP_TTL和IP_TOS。而辅助消息允许在每个数据包级别设置TTL和TOS值。时从qdisc中发送出去。</p>
<p>可以看到内核如何在UDP套接字上处理 sendmsg 的辅助消息：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="keyword">if</span> (msg-&gt;msg_controllen) &#123;</span><br><span class="line">        err = ip_cmsg_send(sock_net(sk), msg, &amp;ipc,</span><br><span class="line">                           sk-&gt;sk_family == AF_INET6);</span><br><span class="line">        <span class="keyword">if</span> (err)</span><br><span class="line">                <span class="keyword">return</span> err;</span><br><span class="line">        <span class="keyword">if</span> (ipc.opt)</span><br><span class="line">                <span class="built_in">free</span> = <span class="number">1</span>;</span><br><span class="line">        connected = <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>解析辅助消息的工作是由 ip_cmsg_send 完成的，定义在net &#x2F; ipv4 &#x2F; ip_sockglue.c。传递一个未初始化的辅助数据，将会把这个套接字标记为“未建立连接的”。</p>
<h3 id="2-5设置自定义IP选项"><a href="#2-5设置自定义IP选项" class="headerlink" title="2.5设置自定义IP选项"></a>2.5设置自定义IP选项</h3><p>接下来，sendmsg 将检查用户是否通过辅助消息设置了任何自定义IP选项。如果设置了，将使用这些自定义值；如果没有，那就使用socket中（已经在用）的参数：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="keyword">if</span> (!ipc.opt) &#123;</span><br><span class="line">        <span class="class"><span class="keyword">struct</span> <span class="title">ip_options_rcu</span> *<span class="title">inet_opt</span>;</span></span><br><span class="line"></span><br><span class="line">        rcu_read_lock();</span><br><span class="line">        inet_opt = rcu_dereference(inet-&gt;inet_opt);</span><br><span class="line">        <span class="keyword">if</span> (inet_opt) &#123;</span><br><span class="line">                <span class="built_in">memcpy</span>(&amp;opt_copy, inet_opt,</span><br><span class="line">                       <span class="keyword">sizeof</span>(*inet_opt) + inet_opt-&gt;opt.optlen);</span><br><span class="line">                ipc.opt = &amp;opt_copy.opt;</span><br><span class="line">        &#125;</span><br><span class="line">        rcu_read_unlock();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>接下来，该函数检查是否设置了源记录路由（源记录路由，SRR）IP选项。SRR有两种类型：宽松的源记录路由和严格的源记录路由。地址串联其保存到 faddr，插入套接字标记为“未连接”。这将在后面用到：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">ipc.addr = faddr = daddr;</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (ipc.opt &amp;&amp; ipc.opt-&gt;opt.srr) &#123;</span><br><span class="line">        <span class="keyword">if</span> (!daddr)</span><br><span class="line">                <span class="keyword">return</span> -EINVAL;</span><br><span class="line">        faddr = ipc.opt-&gt;opt.faddr;</span><br><span class="line">        connected = <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>处理完SRR选项后，将处理TOS选项，这可以从辅助消息中获取，或者从socket当前值中获取。然后检查：</p>
<p>1、是否（使用 setsockopt）在插座上设置了 SO_DONTROUTE，或<br><br>2、是否（调用 sendto 或 sendmsg 时）指定了 MSG_DONTROUTE 标志，或<br><br>3、是否已设置了 is_strictroute，表示需要严格的SRR任何一个为真，tos 扩展的 RTO_ONLINK 位将置1，并且socket被视为“未连接”：<br></p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">tos = get_rttos(&amp;ipc, inet);</span><br><span class="line"><span class="keyword">if</span> (sock_flag(sk, SOCK_LOCALROUTE) ||</span><br><span class="line">    (msg-&gt;msg_flags &amp; MSG_DONTROUTE) ||</span><br><span class="line">    (ipc.opt &amp;&amp; ipc.opt-&gt;opt.is_strictroute)) &#123;</span><br><span class="line">        tos |= RTO_ONLINK;</span><br><span class="line">        connected = <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="2-6多播或单播（多播或单播）"><a href="#2-6多播或单播（多播或单播）" class="headerlink" title="2.6多播或单播（多播或单播）"></a>2.6多播或单播（多播或单播）</h3><p>这有点复杂，因为用户可以通过 IP_PKTINFO 辅助消息来指定发送包的源地址或设备号，如前所述。</p>
<p>如果目标地址是多播地址：<br><br>1、将多播设备（设备）的索引（索引）设置为发送（写）这个数据包的设备索引，并且<br><br>2、数据包的源地址将设置为多播<br></p>
<p>如果目标地址不是一个收件人地址，则发送数据包的设备准备为 inet-&gt;uc_index（单播），除非用户使用 IP_PKTINFO 辅助消息覆盖了它。</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="keyword">if</span> (ipv4_is_multicast(daddr)) &#123;</span><br><span class="line">        <span class="keyword">if</span> (!ipc.oif)</span><br><span class="line">                ipc.oif = inet-&gt;mc_index;</span><br><span class="line">        <span class="keyword">if</span> (!saddr)</span><br><span class="line">                saddr = inet-&gt;mc_addr;</span><br><span class="line">        connected = <span class="number">0</span>;</span><br><span class="line">&#125; <span class="keyword">else</span> <span class="keyword">if</span> (!ipc.oif)</span><br><span class="line">        ipc.oif = inet-&gt;uc_index;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h3 id="2-7路由"><a href="#2-7路由" class="headerlink" title="2.7路由"></a>2.7路由</h3><p>现在开始路由，UDP层中处理路由的代码以快速路径（fast path）开始。如果套接字已连接，则直接尝试获取路由：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="keyword">if</span> (connected)</span><br><span class="line">        rt = (<span class="keyword">struct</span> rtable *)sk_dst_check(sk, <span class="number">0</span>);</span><br></pre></td></tr></table></figure>

<p>如果socket未连接，或者虽然已经连接，但sk_dst_check 路由辅助 功能已确定路由已过期，则代码将进入慢速路径（slow path）以生成一条路由记录。首先调用 flowi4_init_output 构造一个描述此UDP流的变量：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="keyword">if</span> (rt == <span class="literal">NULL</span>) &#123;</span><br><span class="line">        <span class="class"><span class="keyword">struct</span> <span class="title">net</span> *<span class="title">net</span> =</span> sock_net(sk);</span><br><span class="line"></span><br><span class="line">        fl4 = &amp;fl4_stack;</span><br><span class="line">        flowi4_init_output(fl4, ipc.oif, sk-&gt;sk_mark, tos,</span><br><span class="line">                           RT_SCOPE_UNIVERSE, sk-&gt;sk_protocol,</span><br><span class="line">                           inet_sk_flowi_flags(sk)|FLOWI_FLAG_CAN_SLEEP,</span><br><span class="line">                           faddr, saddr, dport, inet-&gt;inet_sport);</span><br><span class="line"></span><br><span class="line">````</span><br><span class="line"></span><br><span class="line">然后，socket为此流程实例实例传递给安全实例，这样SELinux或SMACK这样的系统就可以在流程实例上设置安全ID。接下来，ip_route_output_flow 将调用IP路由代码，创建一个路由实例：</span><br><span class="line"></span><br><span class="line">```c</span><br><span class="line"><span class="title function_">security_sk_classify_flow</span><span class="params">(sk, flowi4_to_flowi(fl4))</span>;</span><br><span class="line">rt = ip_route_output_flow(net, fl4, sk);</span><br></pre></td></tr></table></figure>

<p>如果创建路由实例失败，并且返回码是 ENETUNREACH，则 OUTNOROUTES 计数器将会加1。</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="keyword">if</span> (IS_ERR(rt)) &#123;</span><br><span class="line">  err = PTR_ERR(rt);</span><br><span class="line">  rt = <span class="literal">NULL</span>;</span><br><span class="line">  <span class="keyword">if</span> (err == -ENETUNREACH)</span><br><span class="line">    IP_INC_STATS(net, IPSTATS_MIB_OUTNOROUTES);</span><br><span class="line">  <span class="keyword">goto</span> out;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这些统计计数器所在的源文件，其他可用的计数器及其含义，将在下面的UDP监控部分共享。</p>
<p>接下来，如果是广播路由，但socket的 SOCK_BROADCAST 选项未设置，则处理过程终止。如果socket被视为“已连接”，则路由实例将缓存到socket上：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">err = -EACCES;</span><br><span class="line"><span class="keyword">if</span> ((rt-&gt;rt_flags &amp; RTCF_BROADCAST) &amp;&amp;</span><br><span class="line">    !sock_flag(sk, SOCK_BROADCAST))</span><br><span class="line">        <span class="keyword">goto</span> out;</span><br><span class="line"><span class="keyword">if</span> (connected)</span><br><span class="line">        sk_dst_set(sk, dst_clone(&amp;rt-&gt;dst));</span><br></pre></td></tr></table></figure>

<h3 id="2-8-MSG-CONFIRM：阻止ARP缓存过期"><a href="#2-8-MSG-CONFIRM：阻止ARP缓存过期" class="headerlink" title="2.8 MSG_CONFIRM：阻止ARP缓存过期"></a>2.8 MSG_CONFIRM：阻止ARP缓存过期</h3><p>如果调用 send， sendto 或 sendmsg 的时候指定了 MSG_CONFIRM 参数，UDP协议层将会如下处理：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="keyword">if</span> (msg-&gt;msg_flags&amp;MSG_CONFIRM)</span><br><span class="line">          <span class="keyword">goto</span> do_confirm;</span><br><span class="line">back_from_confirm:</span><br></pre></td></tr></table></figure>

<p>该标志提示系统去确认一下ARP缓存缓存是否仍然有效，防止其被垃圾回收。 do_confirm 标签位于此函数末尾处：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">do_confirm:</span><br><span class="line">        dst_confirm(&amp;rt-&gt;dst);</span><br><span class="line">        <span class="keyword">if</span> (!(msg-&gt;msg_flags&amp;MSG_PROBE) || len)</span><br><span class="line">                <span class="keyword">goto</span> back_from_confirm;</span><br><span class="line">        err = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">goto</span> out;</span><br></pre></td></tr></table></figure>

<p>dst_confirm 函数只是在相应的缓存缓存上设置一个标记位，稍后当查询邻居缓存并找到放置时将检查该标志，我们后面一些会看到。此功能通常用于UDP网络应用程序，以减少不必要的ARP流量。此代码确认缓存并然后跳回 back_from_confirm 标签。一旦 do_confirm 代码跳回到 back_from_confirm（或者之前就没有执行到 do_confirm ），代码接下来将处理UDP软木塞和未塞木塞的情况。</p>
<h3 id="2-9-uncorked-UDP套接字快速路径：准备待发送数据"><a href="#2-9-uncorked-UDP套接字快速路径：准备待发送数据" class="headerlink" title="2.9 uncorked UDP套接字快速路径：准备待发送数据"></a>2.9 uncorked UDP套接字快速路径：准备待发送数据</h3><p>如果不需要corking，数据就可以封装到一个 struct sk_buff 实例中并传递给 udp_send_skb，离IP协议层更进了一步。这是通过调用 ip_make_skb 来完成的。</p>
<p>先前通过调用ip_route_output_flow 生成的路由可能也会 一起传进来，并保存到skb里。</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">/* Lockless fast path for the non-corking case. */</span></span><br><span class="line"><span class="keyword">if</span> (!corkreq) &#123;</span><br><span class="line">        skb = ip_make_skb(sk, fl4, getfrag, msg-&gt;msg_iov, ulen,</span><br><span class="line">                          <span class="keyword">sizeof</span>(<span class="keyword">struct</span> udphdr), &amp;ipc, &amp;rt,</span><br><span class="line">                          msg-&gt;msg_flags);</span><br><span class="line">        err = PTR_ERR(skb);</span><br><span class="line">        <span class="keyword">if</span> (!IS_ERR_OR_NULL(skb))</span><br><span class="line">                err = udp_send_skb(skb, fl4);</span><br><span class="line">        <span class="keyword">goto</span> out;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>ip_make_skb 函数将创建一个skb，其中需要考虑到很多的事情，例如：</p>
<ul>
<li>MTU</li>
<li>UDP阻塞（如果启用）</li>
<li>UDP分片卸载（UFO）</li>
<li>Fragmentation（分片）：如果硬件不支持UFO，但是要传输的数据大于MTU，需要软件做分片</li>
</ul>
<p>大多数网络设备驱动程序不支持UFO，因为网络硬件本身不支持此功能。</p>
<h4 id="2-9-1-ip-make-skb"><a href="#2-9-1-ip-make-skb" class="headerlink" title="2.9.1 ip_make_skb"></a>2.9.1 ip_make_skb</h4><p>定义在net &#x2F; ipv4 &#x2F; ip_output.c，这个函数有点复杂。</p>
<p>构建SKB的时候，ip_make_skb 依赖的底层代码需要使用一个加塞变量和一个队列变量，SKB将通过队列变量传入。如果插座未被软木，则会传入一个假的加塞变量和一个空队列。</p>
<p>现在来看看假corking变量和空数值是如何初始化的：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="keyword">struct</span> sk_buff *<span class="title function_">ip_make_skb</span><span class="params">(<span class="keyword">struct</span> sock *sk, <span class="comment">/* more args */</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">        <span class="class"><span class="keyword">struct</span> <span class="title">inet_cork</span> <span class="title">cork</span>;</span></span><br><span class="line">        <span class="class"><span class="keyword">struct</span> <span class="title">sk_buff_head</span> <span class="title">queue</span>;</span></span><br><span class="line">        <span class="type">int</span> err;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (flags &amp; MSG_PROBE)</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line"></span><br><span class="line">        __skb_queue_head_init(&amp;<span class="built_in">queue</span>);</span><br><span class="line"></span><br><span class="line">        cork.flags = <span class="number">0</span>;</span><br><span class="line">        cork.addr = <span class="number">0</span>;</span><br><span class="line">        cork.opt = <span class="literal">NULL</span>;</span><br><span class="line">        err = ip_setup_cork(sk, &amp;cork, <span class="comment">/* more args */</span>);</span><br><span class="line">        <span class="keyword">if</span> (err)</span><br><span class="line">                <span class="keyword">return</span> ERR_PTR(err);</span><br></pre></td></tr></table></figure>

<p>如上所示，cork和queue都是在栈上分配的，ip_make_skb 根本不需要它。 ip_setup_cork 初始化cork变量。然后，调用__ip_append_data 并调用cork和queue变量：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">err = __ip_append_data(sk, fl4, &amp;<span class="built_in">queue</span>, &amp;cork,</span><br><span class="line">                       &amp;current-&gt;task_frag, getfrag,</span><br><span class="line">                       from, length, transhdrlen, flags);</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>我们将在后面看到这个函数是如何工作的，因为无论socket是否被软木塞，最后都会执行它。</p>
<p>现在，我们只需要知道__ip_append_data 将创建一个skb，向其追加数据，转化为该skb添加到队列的队列变量中。如果追加数据失败，则__ip_flush_pending_frame 调用数据并向上返回错误（指针类型）：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="keyword">if</span> (err) &#123;</span><br><span class="line">        __ip_flush_pending_frames(sk, &amp;<span class="built_in">queue</span>, &amp;cork);</span><br><span class="line">        <span class="keyword">return</span> ERR_PTR(err);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>最后，如果没有发生错误，__ip_make_skb 将skb出队，添加IP选项，并返回一个准备好传递给更连续发送的skb：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">return __ip_make_skb(sk, fl4, &amp;queue, &amp;cork);</span><br></pre></td></tr></table></figure>

<h4 id="2-9-2发送数据"><a href="#2-9-2发送数据" class="headerlink" title="2.9.2发送数据"></a>2.9.2发送数据</h4><p>如果没有错误，skb将会交给 udp_send_skb，附属会继续将其传给下一层协议，IP协议：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">err = PTR_ERR(skb);</span><br><span class="line"><span class="keyword">if</span> (!IS_ERR_OR_NULL(skb))</span><br><span class="line">        err = udp_send_skb(skb, fl4);</span><br><span class="line"><span class="keyword">goto</span> out;</span><br></pre></td></tr></table></figure>

<p>如果有错误，错误计数就会有相应增加。后面的“错误计数”部分会详细介绍。</p>
<h3 id="2-10没有被软木的数据时的慢路径"><a href="#2-10没有被软木的数据时的慢路径" class="headerlink" title="2.10没有被软木的数据时的慢路径"></a>2.10没有被软木的数据时的慢路径</h3><p>如果使用了UDP corking，但之前没有数据被cork，则慢路径开始：</p>
<p>对插座加锁</p>
<p>检查应用程序是否有bug：已经被cork的socket是否再次被cork</p>
<p>设置该UDP流的一些参数，为corking做准备</p>
<p>将要发送的数据追加到现有数据</p>
<p>udp_sendmsg 代码继续向下看，就是这一逻辑：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">lock_sock(sk);</span><br><span class="line">  <span class="keyword">if</span> (unlikely(up-&gt;pending)) &#123;</span><br><span class="line">          <span class="comment">/* The socket is already corked while preparing it. */</span></span><br><span class="line">          <span class="comment">/* ... which is an evident application bug. --ANK */</span></span><br><span class="line">          release_sock(sk);</span><br><span class="line"></span><br><span class="line">          LIMIT_NETDEBUG(KERN_DEBUG pr_fmt(<span class="string">&quot;cork app bug 2\n&quot;</span>));</span><br><span class="line">          err = -EINVAL;</span><br><span class="line">          <span class="keyword">goto</span> out;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">/*</span></span><br><span class="line"><span class="comment">   *      Now cork the socket to pend data.</span></span><br><span class="line"><span class="comment">   */</span></span><br><span class="line">  fl4 = &amp;inet-&gt;cork.fl.u.ip4;</span><br><span class="line">  fl4-&gt;daddr = daddr;</span><br><span class="line">  fl4-&gt;saddr = saddr;</span><br><span class="line">  fl4-&gt;fl4_dport = dport;</span><br><span class="line">  fl4-&gt;fl4_sport = inet-&gt;inet_sport;</span><br><span class="line">  up-&gt;pending = AF_INET;</span><br><span class="line"></span><br><span class="line">do_append_data:</span><br><span class="line">  up-&gt;len += ulen;</span><br><span class="line">  err = ip_append_data(sk, fl4, getfrag, msg-&gt;msg_iov, ulen,</span><br><span class="line">                       <span class="keyword">sizeof</span>(<span class="keyword">struct</span> udphdr), &amp;ipc, &amp;rt,</span><br><span class="line">                       corkreq ? msg-&gt;msg_flags|MSG_MORE : msg-&gt;msg_flags);</span><br><span class="line">                       </span><br></pre></td></tr></table></figure>

<h4 id="2-10-1-ip-append-data"><a href="#2-10-1-ip-append-data" class="headerlink" title="2.10.1 ip_append_data"></a>2.10.1 ip_append_data</h4><p>这个函数简单封装了__ip_append_data，在调用之前之前，做了两件重要的事情：</p>
<p>检查是否从用户指定了 MSG_PROBE 标志。该标志表示用户不想真正发送数据，只是做路径探测（例如，确定PMTU）</p>
<p>检查socket的发送物理是否为空。如果为空，则意味着没有cork数据等待处理，因此调用ip_setup_cork 来设置corking </p>
<p>一旦处理了上述条件，就调用__ip_append_data 函数，该函数包含用于将数据处理成数据包的大量逻辑。</p>
<h4 id="2-10-2-ip-append-data"><a href="#2-10-2-ip-append-data" class="headerlink" title="2.10.2 __ip_append_data"></a>2.10.2 __ip_append_data</h4><p>如果插座是塞住，则从 ip_append_data 调用此函数;如果插座未被软木，则从 ip_make_skb 。调用此函数在任何一种情况下，函数都将分配一个新缓冲区来存储传入的数据，或者将数据附加到现有数据中。这种工作的方式围绕socket的发送序列。等待发送的现有数据（例如，如果socket被软木塞）将在一部分中有一个对应的对应，可以被追加数据。</p>
<p>这个函数很复杂，它执行很多计算逐步如何构造传递给下面的网络层的skb。</p>
<p>该函数的重点包括：</p>
<p>如果硬件支持，则处理UDP分段卸载（UFO）。绝大多数网络硬件不支持UFO。如果你的网卡驱动程序支持它，设置它将 NETIF_F_UFO 标记位</p>
<p>处理支持分散&#x2F;收集（分散&#x2F;聚集）IO的网卡许多卡都支持此功能，并使用。 NETIF_F_SG 标志进行通告支持该特性的网卡可以处理数据被分散到多个缓冲器的数据包;内核不需要花时间将避免这种额外的复制会提升性能，大多数网卡都支持此功能</p>
<p>通过调用sock_wmalloc 跟踪发送帧 的大小。当分配新的skb时，skb的大小由创建它的socket计费（charge），并计入socket发送的已分配字节数。 （超过计费限制），则skb并分配失败并返回错误。我们将在下面的调优部分中看到如何设置socket发送大小（txqueuelen）</p>
<p>更新错误统计信息。此函数中的任何错误都会增加“丢弃”计数。</p>
<p>函数执行成功后返回0，以及一个适用于网络设备传输的skb。</p>
<p>在unorked情况下，持有skb的队列被作为参数传递给上面描述的__ip_make_skb，在那里它被出队并通过 udp_send_skb 发送到更轻松。</p>
<p>在软木的情况下，__ip_append_data 的返回值向上传递。数据位于发送队列中，直到 udp_sendmsg 确定的英文时候调用 udp_push_pending_frames 来完成SKB，后者会进一步调用 udp_send_skb。</p>
<h4 id="2-10-3冲洗软木塞"><a href="#2-10-3冲洗软木塞" class="headerlink" title="2.10.3冲洗软木塞"></a>2.10.3冲洗软木塞</h4><p>现在，udp_sendmsg 会继续，检查__ip_append_skb 的返回值（错误码）：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="keyword">if</span> (err)</span><br><span class="line">        udp_flush_pending_frames(sk);</span><br><span class="line"><span class="keyword">else</span> <span class="keyword">if</span> (!corkreq)</span><br><span class="line">        err = udp_push_pending_frames(sk);</span><br><span class="line"><span class="keyword">else</span> <span class="keyword">if</span> (unlikely(skb_queue_empty(&amp;sk-&gt;sk_write_queue)))</span><br><span class="line">        up-&gt;pending = <span class="number">0</span>;</span><br><span class="line">release_sock(sk);</span><br></pre></td></tr></table></figure>

<p>我们来看看每个情况：</p>
<p>如果出现错误（错误为非零），则调用 udp_flush_pending_frames，这将取消cork并从socket的发送数据中删除所有数据</p>
<p>如果在未指定 MSG_MORE 的情况下发送此数据，则调用 udp_push_pending_frames，则数据传递到更下面的网络层</p>
<p>如果发送轴向为空，替换套接字标记为不再软木</p>
<p>如果追加操作完成并且有更多数据要进入cork，则代码将做一些清理工作，并返回追加数据的长度：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">ip_rt_put(rt);</span><br><span class="line"><span class="keyword">if</span> (<span class="built_in">free</span>)</span><br><span class="line">        kfree(ipc.opt);</span><br><span class="line"><span class="keyword">if</span> (!err)</span><br><span class="line">        <span class="keyword">return</span> len;</span><br></pre></td></tr></table></figure>

<p>这就是内核如何处理</p>
<h3 id="2-11错误会计"><a href="#2-11错误会计" class="headerlink" title="2.11错误会计"></a>2.11错误会计</h3><p>如果：</p>
<p>non-corking快速路径创建skb失败，或 udp_send_skb 返回错误，或</p>
<p>ip_append_data 无法将数据附加到corked UDP套接字，或</p>
<p>当 udp_push_pending_frames 调用 udp_send_skb 发送corked skb时间返回错误</p>
<p>仅当返回的错误是 ENOBUFS（内核无可用内存）或套接字已设置 SOCK_NOSPACE（发送串行已满）时，SNDBUFERRORS 统计信息才会增加：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * ENOBUFS = no kernel mem, SOCK_NOSPACE = no sndbuf space.  Reporting</span></span><br><span class="line"><span class="comment"> * ENOBUFS might not be good (it&#x27;s not tunable per se), but otherwise</span></span><br><span class="line"><span class="comment"> * we don&#x27;t have a good statistic (IpOutDiscards but it can be too many</span></span><br><span class="line"><span class="comment"> * things).  We could add another new stat but at least for now that</span></span><br><span class="line"><span class="comment"> * seems like overkill.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">if</span> (err == -ENOBUFS || test_bit(SOCK_NOSPACE, &amp;sk-&gt;sk_socket-&gt;flags)) &#123;</span><br><span class="line">        UDP_INC_STATS_USER(sock_net(sk),</span><br><span class="line">                        UDP_MIB_SNDBUFERRORS, is_udplite);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> err;</span><br></pre></td></tr></table></figure>

<p>我们接下来会在后面的数据监控里看到如何读取这些计数。</p>
<h3 id="3-udp-send-skb"><a href="#3-udp-send-skb" class="headerlink" title="3. udp_send_skb"></a>3. udp_send_skb</h3><p>udp_sendmsg 通过调用 udp_send_skb 函数将skb转到下一网络层，在这里中是IP协议层。</p>
<p>向skb添加UDP头</p>
<p>处理校验和：软件校验和，硬件校验和或无校​​验和（如果替换）</p>
<p>调用 ip_send_skb 将skb发送到IP协议层</p>
<p>更新发送成功或失败的统计计数器</p>
<p>首先，创建UDP头：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">static</span> <span class="type">int</span> <span class="title function_">udp_send_skb</span><span class="params">(<span class="keyword">struct</span> sk_buff *skb, <span class="keyword">struct</span> flowi4 *fl4)</span></span><br><span class="line">&#123;</span><br><span class="line">                <span class="comment">/* useful variables ... */</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">/*</span></span><br><span class="line"><span class="comment">         * Create a UDP header</span></span><br><span class="line"><span class="comment">         */</span></span><br><span class="line">        uh = udp_hdr(skb);</span><br><span class="line">        uh-&gt;source = inet-&gt;inet_sport;</span><br><span class="line">        uh-&gt;dest = fl4-&gt;fl4_dport;</span><br><span class="line">        uh-&gt;len = htons(len);</span><br><span class="line">        uh-&gt;check = <span class="number">0</span>;</span><br></pre></td></tr></table></figure>

<p>接下来，处理校验和。有几种情况：</p>
<p>首先处理UDP-Lite验证和</p>
<p>接下来，如果socket校正和选项被关闭（setsockopt 带 SO_NO_CHECK 参数），则被标记为校验和关闭</p>
<p>接下来，如果硬件支持UDP校验和，则将调用 udp4_hwcsum 来设置它。请注意，如果数据包是分段的，内核将在软件中生成校正和，可以在udp4_hwcsum的源代码中看到这一点</p>
<p>最后，通过调用 udp_csum 生成软件校验和</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="keyword">if</span> (is_udplite)                                  <span class="comment">/*     UDP-Lite      */</span></span><br><span class="line">        csum = udplite_csum(skb);</span><br><span class="line"></span><br><span class="line"><span class="keyword">else</span> <span class="keyword">if</span> (sk-&gt;sk_no_check == UDP_CSUM_NOXMIT) &#123;   <span class="comment">/* UDP csum disabled */</span></span><br><span class="line"></span><br><span class="line">        skb-&gt;ip_summed = CHECKSUM_NONE;</span><br><span class="line">        <span class="keyword">goto</span> send;</span><br><span class="line"></span><br><span class="line">&#125; <span class="keyword">else</span> <span class="keyword">if</span> (skb-&gt;ip_summed == CHECKSUM_PARTIAL) &#123; <span class="comment">/* UDP hardware csum */</span></span><br><span class="line"></span><br><span class="line">        udp4_hwcsum(skb, fl4-&gt;saddr, fl4-&gt;daddr);</span><br><span class="line">        <span class="keyword">goto</span> send;</span><br><span class="line"></span><br><span class="line">&#125; <span class="keyword">else</span></span><br><span class="line">        csum = udp_csum(skb);</span><br></pre></td></tr></table></figure>

<p>接下来，添加了伪头：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">uh-&gt;check = csum_tcpudp_magic(fl4-&gt;saddr, fl4-&gt;daddr, len,</span><br><span class="line">                              sk-&gt;sk_protocol, csum);</span><br><span class="line"><span class="keyword">if</span> (uh-&gt;check == <span class="number">0</span>)</span><br><span class="line">        uh-&gt;check = CSUM_MANGLED_0;</span><br></pre></td></tr></table></figure>

<p>如果校验和为0，则根据RFC 768，校验为全1（全部传输（等效于补码算术））。最后，将skb传递给IP协议层并增加统计计数：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">send:</span><br><span class="line">  err = ip_send_skb(sock_net(sk), skb);</span><br><span class="line">  <span class="keyword">if</span> (err) &#123;</span><br><span class="line">          <span class="keyword">if</span> (err == -ENOBUFS &amp;&amp; !inet-&gt;recverr) &#123;</span><br><span class="line">                  UDP_INC_STATS_USER(sock_net(sk),</span><br><span class="line">                                     UDP_MIB_SNDBUFERRORS, is_udplite);</span><br><span class="line">                  err = <span class="number">0</span>;</span><br><span class="line">          &#125;</span><br><span class="line">  &#125; <span class="keyword">else</span></span><br><span class="line">          UDP_INC_STATS_USER(sock_net(sk),</span><br><span class="line">                             UDP_MIB_OUTDATAGRAMS, is_udplite);</span><br><span class="line">  <span class="keyword">return</span> err;</span><br></pre></td></tr></table></figure>

<p>如果 ip_send_skb 成功，将更新 OUTDATAGRAMS 统计。如果IP协议层报告错误，并且错误是 ENOBUFS（内核内核内存）而且错误queue（inet-&gt;recverr）没有启用，则更新 SNDBUFERRORS。</p>
<p>接下来看看如何在Linux内核中监视和调优UDP协议层。</p>
<h3 id="4-监控：UDP层统计"><a href="#4-监控：UDP层统计" class="headerlink" title="4.监控：UDP层统计"></a>4.监控：UDP层统计</h3><p>两个非常有用的获取UDP协议统计文件：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">/proc/net/snmp</span><br><span class="line">/proc/net/udp</span><br></pre></td></tr></table></figure>

<h4 id="4-1-proc-net-snmp"><a href="#4-1-proc-net-snmp" class="headerlink" title="4.1 &#x2F; proc &#x2F; net &#x2F; snmp"></a>4.1 &#x2F; proc &#x2F; net &#x2F; snmp</h4><p>监控UDP协议层统计：</p>
<pre><code>cat /proc/net/snmp | grep Udp\:
</code></pre>
<p>要准确地理解这些计数，需要仔细地阅读内核代码。一些类型的错误计数并不是只出现在一种计数中，而可能是出现在多个计数中。</p>
<ul>
<li>InDatagrams：当userland程序使用recvmsg读取数据报时增加。当UDP数据包被封装并发回进行处理时，该值也会增加。</li>
<li>NoPorts：当UDP数据包到达没有程序正在侦听的端口时增加。</li>
<li>InErrors：在以下几种情况下增加：在接收队列中没有内存，看到错误的校验和，以及sk_add_backlog无法添加数据报。</li>
<li>OutDatagrams：当将UDP数据包无误传递到要发送的IP协议层时增加。</li>
<li>RcvbufErrors：当sock_queue_rcv_skb报告没有可用的内存时增加；如果sk-&gt; sk_rmem_alloc大于或等于sk-&gt; sk_rcvbuf，则会发生这种情况。</li>
<li>SndbufErrors：如果IP协议层在尝试发送数据包时报告错误，并且未设置错误队列，则增加。如果没有发送队列空间或内核内存可用，也将增加。</li>
<li>InCsumErrors：当检测到UDP校验和失败时增加。请注意，在所有情况下，我都能发现InCsumErrors与InErrors同时增加。因此，InErrors-InCsumErros应该在接收端产生与内存相关的错误计数。</li>
</ul>
<p>UDP协议层发现的某些错误会出现在其他协议层的统计信息中。一个例子：路由错误。 udp_sendmsg 发现的路由错误将导致IP协议层的 OutNoRoutes 统计增加。</p>
<h4 id="4-2-proc-net-udp"><a href="#4-2-proc-net-udp" class="headerlink" title="4.2 &#x2F; proc &#x2F; net &#x2F; udp"></a>4.2 &#x2F; proc &#x2F; net &#x2F; udp</h4><p>监控UDP套接字统计：</p>
<pre><code>cat /proc/net/udp
</code></pre>
<p>每一列的意思：</p>
<ul>
<li>sl：套接字的内核哈希槽</li>
<li>local_address：套接字的十六进制本地地址和端口号，以：分隔。</li>
<li>rem_address：套接字的十六进制远程地址和端口号，以：分隔。</li>
<li>st：套接字的状态。奇怪的是，UDP协议层似乎使用了某些TCP套接字状态。在上面的示例中，7是TCP_CLOSE。</li>
<li>tx_queue：在内核中为传出UDP数据报分配的内存量。</li>
<li>rx_queue：在内核中为传入的UDP数据报分配的内存量。</li>
<li>tr，tm-&gt; when，retrnsmt：UDP协议层未使用这些字段。</li>
<li>uid：创建此套接字的用户的有效用户ID。</li>
<li>timeout：未由UDP协议层使用。</li>
<li>inode：与此套接字相对应的inode编号。您可以使用它来帮助您确定哪个用户进程打开了此套接字。检查&#x2F; proc &#x2F; [pid] &#x2F; fd，其中将包含指向socket [：inode]的符号链接。</li>
<li>ref：套接字的当前引用计数。</li>
<li>pointer：struct sock内核中的内存地址。</li>
<li>drops：与此套接字关联的数据报丢弃数。请注意，这不包括与发送数据报有关的任何丢弃（在已塞好的UDP套接字上或以其他方式）；从本博客文章所检查的内核版本开始，该值仅在接收路径中递增。</li>
</ul>
<p>打印这些计数的代码在net &#x2F; ipv4 &#x2F; udp.c。</p>
<h3 id="5-调优：socket发送收发内存大小"><a href="#5-调优：socket发送收发内存大小" class="headerlink" title="5.调优：socket发送收发内存大小"></a>5.调优：socket发送收发内存大小</h3><p>发送副本（也叫“写类别”）的副本可以通过设置 net.core.wmem_max sysctl 进行修改。</p>
<pre><code>$ sudo sysctl -w net.core.wmem_max=8388608
</code></pre>
<p>sk-&gt;sk_write_queue 用 net.core.wmem_default 初始化，这个值也可以调整。</p>
<p>调整初始发送缓冲区大小：</p>
<pre><code>$ sudo sysctl -w net.core.wmem_default=8388608
</code></pre>
<p>也可以通过从应用程序调用 setsockopt 并传递 SO_SNDBUF 来设置 sk-&gt;sk_write_queue 。通过 setsockopt 设置的可选是 net.core.wmem_max。</p>
<p>不过，可以通过 setsockopt 并传递传递 SO_SNDBUFFORCE 覆盖 net.core.wmem_max 限制，这需要 CAP_NET_ADMIN 权限。</p>
<p>每次调用__ip_append_data 分配skb时，sk-&gt;sk_wmem_alloc 都会增长。预先我们所看到的，UDP数据报传输速度很快，通常不会在发送当中花费了太多时间。</p>
<h3 id="6-总结"><a href="#6-总结" class="headerlink" title="6.总结"></a>6.总结</h3><p>本文重点分析了数据包在传输层（UDP协议）的发送过程，并进行了监控和调优，后面的数据包将到达IP协议层，下次再分享，感谢阅读。</p>
]]></content>
      <categories>
        <category>linux-doc 网络协议栈</category>
      </categories>
      <tags>
        <tag>Linux</tag>
      </tags>
  </entry>
  <entry>
    <title>Linux内核网络中断下半部处理</title>
    <url>/2023/01/15/linux-docs/%E7%BD%91%E7%BB%9C%E5%8D%8F%E8%AE%AE%E6%A0%88/Linux%E5%86%85%E6%A0%B8%E7%BD%91%E7%BB%9C%E4%B8%AD%E6%96%AD%E4%B8%8B%E5%8D%8A%E9%83%A8%E5%A4%84%E7%90%86/</url>
    <content><![CDATA[<p>网卡接收和发过数据在 Linux 内核中的处理过程，我们先来回顾一下网卡接收和发送数据的过程，如 图1 所示：</p>
<p><img src="https://pic1.zhimg.com/80/v2-fa1a3a8338e1d40aed2ef2a1ddcb016c_720w.webp" alt="img"></p>
<p>图1 网卡接收和发送数据过程</p>
<ul>
<li>如上图所示，当网卡接收到从网络中发送过来的数据后，网卡会向 CPU 发起一个硬件中断。当 CPU 接收到网卡的硬件中断后，便会调用网卡驱动向内核注册的中断处理服务，如 <code>NS8390网卡驱动</code> 会向内核注册 <code>ei_interrupt</code> 中断服务。</li>
<li>由于在处理硬件中断服务时会关闭硬件中断，所以在处理硬件中断服务的过程中，如果发生了其他的硬件中断，也不能得到有效的处理，从而导致硬件中断丢失的情况。</li>
<li>为了避免这种情况出现，Linux 内核把中断处理分为：<strong>中断上半部</strong> 和 <strong>中断下半部</strong>，上半部在关闭中断的情况下进行，而下半部在打开中断的情况下进行。</li>
<li>由于中断上半部在关闭中断的情况下进行，所以必须要快速完成，从而避免中断丢失的情况。而中断下半部处理是在打开中断的情况下进行的，所以可以慢慢进行。</li>
<li>一般来说，网卡驱动向内核注册的中断处理服务属于 <strong>中断上半部</strong>，如前面介绍的 <code>NS8390网卡驱动</code> 注册的 <code>ei_interrupt</code> 中断处理服务，而本文主要分析网卡 <strong>中断下半部</strong> 的处理。</li>
</ul>
<h2 id="1、数据包上送"><a href="#1、数据包上送" class="headerlink" title="1、数据包上送"></a>1、<strong>数据包上送</strong></h2><ul>
<li>在上一篇文章中，我们介绍过 <code>ei_interrupt</code> 中断处理服务首先会创建一个 <code>sk_buff</code> 数据包对象保存从网卡中接收到的数据，然后调用 <code>netif_rx</code> 函数将数据包上送给网络协议栈处理。</li>
<li>我们先来分析一下 <code>netif_rx</code> 函数的实现：</li>
</ul>
<figure class="highlight text"><table><tr><td class="code"><pre><span class="line">int netif_rx(struct sk_buff *skb)</span><br><span class="line">&#123;</span><br><span class="line">     int this_cpu = smp_processor_id(); // 获取当前运行的CPU</span><br><span class="line">     struct softnet_data *queue;</span><br><span class="line">     unsigned long flags;</span><br><span class="line">     ...</span><br><span class="line">     queue = &amp;softnet_data[this_cpu]; // 获取当前CPU的待处理的数据包队列</span><br><span class="line"> </span><br><span class="line">     local_irq_save(flags); // 关闭本地硬件中断</span><br><span class="line"> </span><br><span class="line">     // 如果待处理队列的数据包数量没超出限制</span><br><span class="line">     if (queue-&gt;input_pkt_queue.qlen &lt;= netdev_max_backlog) &#123;</span><br><span class="line">         if (queue-&gt;input_pkt_queue.qlen) &#123;</span><br><span class="line">             ...</span><br><span class="line"> enqueue:</span><br><span class="line">             dev_hold(skb-&gt;dev); // 增加网卡设备的引用计数器</span><br><span class="line">             __skb_queue_tail(&amp;queue-&gt;input_pkt_queue, skb); // 将数据包添加到待处理队列中</span><br><span class="line">             __cpu_raise_softirq(this_cpu, NET_RX_SOFTIRQ);  // 启动网络中断下半部处理</span><br><span class="line">             local_irq_restore(flags);</span><br><span class="line"> </span><br><span class="line">             return softnet_data[this_cpu].cng_level;</span><br><span class="line">         &#125;</span><br><span class="line">         ...</span><br><span class="line">         goto enqueue;</span><br><span class="line">     &#125;</span><br><span class="line">     ...</span><br><span class="line"> drop:</span><br><span class="line">     local_irq_restore(flags); // 打开本地硬件中断</span><br><span class="line">     kfree_skb(skb);           // 释放数据包对象</span><br><span class="line">     return NET_RX_DROP;</span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure>

<ul>
<li><code>netif_rx</code> 函数的参数就是要上送给网络协议栈的数据包，<code>netif_rx</code> 函数主要完成以下几个工作：</li>
</ul>
<ol>
<li>获取当前 CPU 的待处理的数据包队列，在 Linux 内核初始化时，会为每个 CPU 创建一个待处理数据包队列，用于存放从网卡中读取到网络数据包。</li>
<li>如果待处理队列的数据包数量没超出 <code>netdev_max_backlog</code> 设置的限制，那么调用 <code>__skb_queue_tail</code> 函数把数据包添加到待处理队列中，并且调用 <code>__cpu_raise_softirq</code> 函数启动网络中断下半部处理。</li>
<li>如果待处理队列的数据包数量超出 <code>netdev_max_backlog</code> 设置的限制，那么就把数据包释放。</li>
</ol>
<ul>
<li><code>netif_rx</code> 函数的处理过程如 图2 所示：</li>
</ul>
<p><img src="https://pic4.zhimg.com/80/v2-9f87cfe85f20c5650cf38a5b0dc78d0f_720w.webp" alt="img"></p>
<p>图2 netif_rx 函数的处理过程</p>
<ul>
<li>所以，<code>netif_rx</code> 函数的主要工作就是把接收到的数据包添加到待处理队列中，并且启动网络中断下半部处理。</li>
<li>对于 Linux 内核的中断处理机制可以参考我们之前的文章 <a href="https://link.zhihu.com/?target=https://mp.weixin.qq.com/s?__biz=MzA3NzYzODg1OA==&mid=2648464225&idx=1&sn=7cc26da1f9312e5abc00751c7d65805b&scene=21%23wechat_redirect">Linux中断处理</a>，这里就不详细介绍了。在本文中，我们只需要知道网络中断下半部处理例程为 <code>net_rx_action</code> 函数即可。</li>
</ul>
<h2 id="2、网络中断下半部处理"><a href="#2、网络中断下半部处理" class="headerlink" title="2、网络中断下半部处理"></a>2、<strong>网络中断下半部处理</strong></h2><ul>
<li>上面说了，网络中断下半部处理例程为 <code>net_rx_action</code> 函数，所以我们主要分析 <code>net_rx_action</code> 函数的实现：</li>
</ul>
<figure class="highlight text"><table><tr><td class="code"><pre><span class="line">static void net_rx_action(struct softirq_action *h)</span><br><span class="line">&#123;</span><br><span class="line">     int this_cpu = smp_processor_id();                    // 当前运行的CPU</span><br><span class="line">     struct softnet_data *queue = &amp;softnet_data[this_cpu]; // 当前CPU对于的待处理数据包队列</span><br><span class="line">     ...</span><br><span class="line">     for (;;) &#123;</span><br><span class="line">         struct sk_buff *skb;</span><br><span class="line"> </span><br><span class="line">         local_irq_disable();</span><br><span class="line">         skb = __skb_dequeue(&amp;queue-&gt;input_pkt_queue); // 从待处理数据包队列中获取一个数据包</span><br><span class="line">         local_irq_enable();</span><br><span class="line"> </span><br><span class="line">         if (skb == NULL)</span><br><span class="line">             break;</span><br><span class="line"> </span><br><span class="line">         ...</span><br><span class="line">         &#123;</span><br><span class="line">             struct packet_type *ptype, *pt_prev;</span><br><span class="line">             unsigned short type = skb-&gt;protocol; // 网络层协议类型</span><br><span class="line"> </span><br><span class="line">             pt_prev = NULL;</span><br><span class="line">             ...</span><br><span class="line">             // 使用网络层协议处理接口处理数据包</span><br><span class="line">             for (ptype = ptype_base[ntohs(type)&amp;15]; ptype; ptype = ptype-&gt;next) &#123;</span><br><span class="line">                 if (ptype-&gt;type == type</span><br><span class="line">                     &amp;&amp; (!ptype-&gt;dev || ptype-&gt;dev == skb-&gt;dev))</span><br><span class="line">                 &#123;</span><br><span class="line">                     if (pt_prev) &#123;</span><br><span class="line">                         atomic_inc(&amp;skb-&gt;users);</span><br><span class="line">                         // 如处理IP协议数据包的 ip_rcv() 函数</span><br><span class="line">                         pt_prev-&gt;func(skb, skb-&gt;dev, pt_prev);</span><br><span class="line">                     &#125;</span><br><span class="line">                     pt_prev = ptype;</span><br><span class="line">                 &#125;</span><br><span class="line">             &#125;</span><br><span class="line"> </span><br><span class="line">             if (pt_prev) &#123;</span><br><span class="line">                 // 如处理IP协议数据包的 ip_rcv() 函数</span><br><span class="line">                 pt_prev-&gt;func(skb, skb-&gt;dev, pt_prev);</span><br><span class="line">             &#125; else</span><br><span class="line">                 kfree_skb(skb);</span><br><span class="line">         &#125;</span><br><span class="line">         ...</span><br><span class="line">     &#125;</span><br><span class="line">     ...</span><br><span class="line">     return;</span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure>

<ul>
<li><code>net_rx_action</code> 函数主要完成以下几个工作：</li>
</ul>
<ol>
<li>从待处理数据包队列中获取一个数据包，如果数据包为空，那么就退出网络中断下半部。<br>如果获取的数据包不为空，那么就从数据包的以太网头部中获取到网络层协议的类型。然后根据网络层协议类型从 <code>ptype_base</code> 数组中获取数据处理接口，再通过此数据处理接口来处理数据包。<br>在内核初始化时，通过调用 <code>dev_add_pack</code> 函数向 <code>ptype_base</code> 数组中注册网络层协议处理接口，如 <code>ip_init</code> 函数：</li>
</ol>
<figure class="highlight text"><table><tr><td class="code"><pre><span class="line">static struct packet_type ip_packet_type = &#123;</span><br><span class="line">     __constant_htons(ETH_P_IP),</span><br><span class="line">     NULL,</span><br><span class="line">     ip_rcv,  // 处理IP协议数据包的接口</span><br><span class="line">     (void*)1,</span><br><span class="line">     NULL,</span><br><span class="line"> &#125;;</span><br><span class="line"> </span><br><span class="line"> void __init ip_init(void)</span><br><span class="line">&#123;</span><br><span class="line">     // 注册网络层协议处理接口</span><br><span class="line">     dev_add_pack(&amp;ip_packet_type);</span><br><span class="line">     ...</span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure>

<ul>
<li>所以，<code>net_rx_action</code> 函数主要从待处理队列中获取数据包，然后根据数据包的网络层协议类型，找到相应的处理接口处理数据包。其过程如 图3 所示：</li>
</ul>
<p><img src="https://pic2.zhimg.com/80/v2-412eb9041d2bcdf4e23f28fe7578b639_720w.webp" alt="img"></p>
<ul>
<li><p>从上图可知，<code>net_rx_action</code> 函数将数据包交由网络层协议处理接口后就不管了，而网络层协议处理接口接管数据包后，会对数据包进行进一步处理，如判断数据包的合法性（数据包是否损坏、数据包是否发送给本机）。如果数据包是合法的，就会交由传输层协议处理接口处理。</p>
</li>
<li><p>在深度剖析Linux 网络中断下半部处理一文中介绍过，当网卡接收到网络数据包后，会由网卡驱动通过调用 <code>netif_rx</code> 函数把数据包添加到待处理队列中，然后唤起网络中断下半部处理。</p>
</li>
<li><p>而网络中断下半部处理由 <code>net_rx_action</code> 函数完成的，其主要功能就是从待处理队列中获取一个数据包，然后根据数据包的网络层协议类型来找到相应的处理接口来处理数据包。我们通过 图1 来展示 <code>net_rx_action</code> 函数的处理过程：</p>
</li>
</ul>
<p><img src="https://pic3.zhimg.com/80/v2-25a34cbac94390750fa9c8adbf3baa9a_720w.webp" alt="img"></p>
<p>图1 net_rx_action 处理过程</p>
<ul>
<li>网络层的处理接口保存在 <code>ptype_base</code> 数组中，其元素的类型为 <code>packet_type</code> 结构，而索引为网络层协议的类型，所以通过网络层协议的类型就能找到对应的处理接口，我们先来看看 <code>packet_type</code> 结构的定义：</li>
</ul>
<figure class="highlight text"><table><tr><td class="code"><pre><span class="line">struct packet_type</span><br><span class="line">&#123;</span><br><span class="line">    unsigned short      type;   // 网络层协议类型</span><br><span class="line">    struct net_device   *dev;   // 绑定的设备对象, 一般设置为NULL</span><br><span class="line">    int                 (*func)(struct sk_buff *, struct net_device *, struct packet_type *); // 处理接口</span><br><span class="line">    void                *data;  // 私有数据域, 一般设置为NULL</span><br><span class="line">    struct packet_type  *next;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<ul>
<li><code>ptype_base</code> 数组的定义如下：</li>
</ul>
<figure class="highlight text"><table><tr><td class="code"><pre><span class="line">static struct packet_type *ptype_base[16];</span><br></pre></td></tr></table></figure>

<ul>
<li>从 <code>ptype_base</code> 数组的定义可知，其只有 16 个元素，那么如果内核超过 16 种网络层协议怎么办？我们可以从网络层处理接口的注册函数 <code>dev_add_pack</code> 中找到答案：</li>
</ul>
<figure class="highlight text"><table><tr><td class="code"><pre><span class="line">void dev_add_pack(struct packet_type *pt)</span><br><span class="line">&#123;</span><br><span class="line">    int hash;</span><br><span class="line"></span><br><span class="line">    br_write_lock_bh(BR_NETPROTO_LOCK);</span><br><span class="line"></span><br><span class="line">    // 如果类型为ETH_P_ALL, 表示需要处理所有协议的数据包</span><br><span class="line">    if (pt-&gt;type == htons(ETH_P_ALL)) &#123; </span><br><span class="line">        netdev_nit++;</span><br><span class="line">        pt-&gt;next = ptype_all;</span><br><span class="line">        ptype_all = pt;</span><br><span class="line">    &#125; else &#123;</span><br><span class="line">        // 对网络层协议类型与15进行与操作, 得到一个 0 到 15 的整数</span><br><span class="line">        hash = ntohs(pt-&gt;type) &amp; 15;</span><br><span class="line"></span><br><span class="line">        // 通过 next 指针把冲突的处理接口连接起来</span><br><span class="line">        pt-&gt;next = ptype_base[hash];</span><br><span class="line">        ptype_base[hash] = pt;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    br_write_unlock_bh(BR_NETPROTO_LOCK);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li>从 <code>dev_add_pack</code> 函数的实现可知，内核把 <code>ptype_base</code> 数组当成了哈希表，而键值就是网络层协议类型，哈希函数就是对协议类型与 15 进行与操作。如果有冲突，就通过 <code>next</code> 指针把冲突的处理接口连接起来。</li>
<li>我们再来看看 IP 协议是怎样注册处理接口的，如下代码：</li>
</ul>
<figure class="highlight text"><table><tr><td class="code"><pre><span class="line">/* /net/ipv4/ip_output.c */</span><br><span class="line"></span><br><span class="line">static struct packet_type ip_packet_type = &#123;</span><br><span class="line">     __constant_htons(ETH_P_IP),</span><br><span class="line">     NULL,</span><br><span class="line">     ip_rcv,  // 处理 IP 协议数据包的接口</span><br><span class="line">     (void*)1,</span><br><span class="line">     NULL,</span><br><span class="line"> &#125;;</span><br><span class="line"> </span><br><span class="line"> void __init ip_init(void)</span><br><span class="line">&#123;</span><br><span class="line">     // 注册 IP 协议处理接口</span><br><span class="line">     dev_add_pack(&amp;ip_packet_type);</span><br><span class="line">     ...</span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure>

<ul>
<li><p>从上面的代码可以看到，在 <code>ip_init</code> 函数中调用了 <code>dev_add_pack(&amp;ip_packet_type)</code> 函数来注册了 IP 协议的处理接口，而 IP 协议的处理接口为 <code>ip_rcv</code> 函数。</p>
</li>
<li><p>我们再看看 <code>net_rx_action</code> 函数的处理：</p>
</li>
</ul>
<figure class="highlight text"><table><tr><td class="code"><pre><span class="line">static void net_rx_action(struct softirq_action *h)</span><br><span class="line">&#123;</span><br><span class="line">    ...</span><br><span class="line">    for (;;) &#123;</span><br><span class="line">        ...</span><br><span class="line">        &#123;</span><br><span class="line">            struct packet_type *ptype, *pt_prev;</span><br><span class="line">            unsigned short type = skb-&gt;protocol; // 网络层协议类型</span><br><span class="line"> </span><br><span class="line">            pt_prev = NULL;</span><br><span class="line">            ...</span><br><span class="line">            // 从 ptype_base 数组中查找网络层处理接口</span><br><span class="line">            for (ptype = ptype_base[ntohs(type) &amp; 15]; </span><br><span class="line">                 ptype; </span><br><span class="line">                 ptype = ptype-&gt;next) </span><br><span class="line">            &#123;</span><br><span class="line">                if (ptype-&gt;type == type // 如果协议类型匹配</span><br><span class="line">                    &amp;&amp; (!ptype-&gt;dev || ptype-&gt;dev == skb-&gt;dev))</span><br><span class="line">                &#123;</span><br><span class="line">                    if (pt_prev) &#123;</span><br><span class="line">                        atomic_inc(&amp;skb-&gt;users);</span><br><span class="line">                        // 如处理IP协议数据包的 ip_rcv() 函数</span><br><span class="line">                        pt_prev-&gt;func(skb, skb-&gt;dev, pt_prev);</span><br><span class="line">                    &#125;</span><br><span class="line"></span><br><span class="line">                    pt_prev = ptype;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            ...</span><br><span class="line">        &#125;</span><br><span class="line">        ...</span><br><span class="line">    &#125;</span><br><span class="line">    ...</span><br><span class="line">    return;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li>现在就非常清晰了，就是根据数据包的网络层协议类型，然后从 <code>ptype_base</code> 数组中找到对应的处理接口处理数据包，如 IP 协议的数据包就调用 <code>ip_rcv</code> 函数处理。</li>
</ul>
<h2 id="3、处理IP数据包"><a href="#3、处理IP数据包" class="headerlink" title="3、处理IP数据包"></a>3、处理IP数据包</h2><ul>
<li>通过上面的分析，我们知道当内核接收到一个 IP 数据包后，会调用 <code>ip_rcv</code> 函数处理这个数据包，下面我们来分析一下 <code>ip_rcv</code> 函数的实现：</li>
</ul>
<figure class="highlight text"><table><tr><td class="code"><pre><span class="line">int ip_rcv(struct sk_buff *skb, struct net_device *dev, </span><br><span class="line">           struct packet_type *pt)</span><br><span class="line">&#123;</span><br><span class="line">    struct iphdr *iph = skb-&gt;nh.iph;</span><br><span class="line"></span><br><span class="line">    // 如果数据包不是发送给本机的, 丢弃数据包</span><br><span class="line">    if (skb-&gt;pkt_type == PACKET_OTHERHOST)</span><br><span class="line">        goto drop;</span><br><span class="line"></span><br><span class="line">    // 如果其他地方也在使用数据包, 复制一份新的数据包</span><br><span class="line">    if ((skb = skb_share_check(skb, GFP_ATOMIC)) == NULL)</span><br><span class="line">        goto out;</span><br><span class="line"></span><br><span class="line">    // 数据包的长度比IP头部的长度还小，不合法丢弃</span><br><span class="line">    if (skb-&gt;len &lt; sizeof(struct iphdr) || skb-&gt;len &lt; (iph-&gt;ihl&lt;&lt;2))</span><br><span class="line">        goto inhdr_error;</span><br><span class="line"></span><br><span class="line">    // 判断IP头部是否合法</span><br><span class="line">    if (iph-&gt;ihl &lt; 5                                 // IP头部长度是否合法</span><br><span class="line">        || iph-&gt;version != 4                         // IP协议版本是否合法</span><br><span class="line">        || ip_fast_csum((u8 *)iph, iph-&gt;ihl) != 0)   // IP校验和是否正确</span><br><span class="line">        goto inhdr_error;</span><br><span class="line"></span><br><span class="line">    &#123;</span><br><span class="line">        __u32 len = ntohs(iph-&gt;tot_len);</span><br><span class="line"></span><br><span class="line">        // 如果数据包的长度比IP头部的总长度小, 说明数据包不合法, 需要丢弃</span><br><span class="line">        if (skb-&gt;len &lt; len || len &lt; (iph-&gt;ihl&lt;&lt;2))</span><br><span class="line">            goto inhdr_error;</span><br><span class="line">        __skb_trim(skb, len);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    // 如果所有验证都通过, 那么调用 ip_rcv_finish 函数继续处理数据包</span><br><span class="line">    return NF_HOOK(PF_INET, NF_IP_PRE_ROUTING, skb, dev, NULL, ip_rcv_finish);</span><br><span class="line"></span><br><span class="line">    // 这里是丢弃数据包的处理</span><br><span class="line">inhdr_error:</span><br><span class="line">    IP_INC_STATS_BH(IpInHdrErrors);</span><br><span class="line">drop:</span><br><span class="line">    kfree_skb(skb);</span><br><span class="line">out:</span><br><span class="line">    return NET_RX_DROP;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li><p><code>ip_rcv</code> 函数主要对数据包的合法性进行验证，如果数据包是合法的，那么就调用 <code>ip_rcv_finish</code> 函数继续对数据包进行处理。</p>
</li>
<li><p>我们继续分析 <code>ip_rcv_finish</code> 函数的实现：</p>
</li>
</ul>
<figure class="highlight text"><table><tr><td class="code"><pre><span class="line">static inline int ip_rcv_finish(struct sk_buff *skb)</span><br><span class="line">&#123;</span><br><span class="line">    struct net_device *dev = skb-&gt;dev;</span><br><span class="line">    struct iphdr *iph = skb-&gt;nh.iph;</span><br><span class="line"></span><br><span class="line">    if (skb-&gt;dst == NULL) &#123; // 如果数据包的输入路由缓存还没设置</span><br><span class="line">        // 根据目标IP地址获取数据包的输入路由缓存</span><br><span class="line">        if (ip_route_input(skb, iph-&gt;daddr, iph-&gt;saddr, iph-&gt;tos, dev))</span><br><span class="line">            goto drop;</span><br><span class="line">    &#125;</span><br><span class="line">    ...</span><br><span class="line">    // 如果数据包是发送给本机的，那么就调用 ip_local_deliver 进行处理</span><br><span class="line">    return skb-&gt;dst-&gt;input(skb); </span><br><span class="line"></span><br><span class="line">drop:</span><br><span class="line">    kfree_skb(skb);</span><br><span class="line">    return NET_RX_DROP;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li><p>为了简单起见，我们去掉了对 IP 选项的处理。在上面的代码中，如果数据包的输入路由缓存还没设置，那么先调用 <code>ip_route_input</code> 函数获取数据包的输入路由缓存（<code>ip_route_input</code> 函数将会在 <code>路由子系统</code> 一章介绍，暂时可以忽略这个函数）。</p>
</li>
<li><p>设置好数据包的路由缓存后，就调用路由缓存的 <code>input</code> 方法处理数据包。如果数据包是发送给本机的，那么路由缓存的 <code>input</code> 方法将会被设置为 <code>ip_local_deliver</code>（由 <code>ip_route_input</code> 函数设置）。</p>
</li>
<li><p>所有，如果数据包是发送给本机，那么最终会调用 <code>ip_local_deliver</code> 函数处理数据包，我们继续来分析 <code>ip_local_deliver</code> 函数：</p>
</li>
</ul>
<figure class="highlight text"><table><tr><td class="code"><pre><span class="line">int ip_local_deliver(struct sk_buff *skb)</span><br><span class="line">&#123;</span><br><span class="line">    struct iphdr *iph = skb-&gt;nh.iph;</span><br><span class="line"></span><br><span class="line">    // 如果当前数据包是一个IP分片, 那么先对数据包进行分片处理</span><br><span class="line">    if (iph-&gt;frag_off &amp; htons(IP_MF|IP_OFFSET)) &#123;</span><br><span class="line">        skb = ip_defrag(skb);</span><br><span class="line">        if (!skb)</span><br><span class="line">            return 0;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    // 接着调用 ip_local_deliver_finish 函数处理数据包</span><br><span class="line">    return NF_HOOK(PF_INET, NF_IP_LOCAL_IN, skb, skb-&gt;dev, NULL,</span><br><span class="line">                   ip_local_deliver_finish);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li><p><code>ip_local_deliver</code> 函数首先判断数据包是否为一个 IP 分片（IP 分片将在下一篇文章介绍，暂时可以忽略），如果是就调用 <code>ip_defrag</code> 函数对数据包进行分片重组处理。如果数据包不是一个分片或者分片重组成功，那么最终调用 <code>ip_local_deliver_finish</code> 函数处理数据包。</p>
</li>
<li><p><code>ip_local_deliver_finish</code> 函数是 IP 层处理数据包的最后一步，我们接着分析 <code>ip_local_deliver_finish</code> 函数的实现：</p>
</li>
</ul>
<figure class="highlight text"><table><tr><td class="code"><pre><span class="line">static inline int ip_local_deliver_finish(struct sk_buff *skb)</span><br><span class="line">&#123;</span><br><span class="line">    struct iphdr *iph = skb-&gt;nh.iph;         // 获取数据包的IP头部</span><br><span class="line">    ...</span><br><span class="line">    skb-&gt;h.raw = skb-&gt;nh.raw + iph-&gt;ihl * 4; // 设置传输层协议头部指针</span><br><span class="line"></span><br><span class="line">    &#123;</span><br><span class="line">        int hash = iph-&gt;protocol &amp; (MAX_INET_PROTOS - 1); // 从IP头部获取传输层协议类型</span><br><span class="line">        struct sock *raw_sk = raw_v4_htable[hash];</span><br><span class="line">        struct inet_protocol *ipprot;</span><br><span class="line">        int flag;</span><br><span class="line">        ...</span><br><span class="line">        ipprot = (struct inet_protocol *)inet_protos[hash]; // 传输层协议处理函数</span><br><span class="line">        flag = 0;</span><br><span class="line"></span><br><span class="line">        if (ipprot != NULL) &#123; // 调用传输层协议处理函数处理数据包</span><br><span class="line">            if (raw_sk == NULL &amp;&amp; ipprot-&gt;next == NULL &amp;&amp; ipprot-&gt;protocol == iph-&gt;protocol) &#123;</span><br><span class="line">                return ipprot-&gt;handler(skb, (ntohs(iph-&gt;tot_len)-(iph-&gt;ihl*4)));</span><br><span class="line">            &#125; else &#123;</span><br><span class="line">                flag = ip_run_ipprot(skb, iph, ipprot, (raw_sk != NULL));</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        ...</span><br><span class="line">    &#125;</span><br><span class="line">    return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li>在上面代码中，我们省略对原始套接字的处理（原始套接字将会在 <code>原始套接字</code> 一章中介绍）。<code>ip_local_deliver_finish</code> 函数的主要工作如下：</li>
</ul>
<ol>
<li>通过数据包的 IP 头部获取到上层协议（传输层）类型。</li>
<li>根据传输层协议类型从 <code>inet_protos</code> 数组中查找对应的处理函数。</li>
<li>调用传输层协议的处理函数处理数据包。</li>
</ol>
<ul>
<li><code>inet_protos</code> 数组保存了传输层协议的处理函数，其的定义如下：</li>
</ul>
<figure class="highlight text"><table><tr><td class="code"><pre><span class="line">struct inet_protocol</span><br><span class="line">&#123;</span><br><span class="line">    int (*handler)(struct sk_buff *skb, unsigned short len); // 协议的处理函数</span><br><span class="line">    unsigned char protocol;                                  // 协议类型</span><br><span class="line">    struct inet_protocol *next;                              // 解决冲突</span><br><span class="line">    ...</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">#define MAX_INET_PROTOS32</span><br><span class="line"></span><br><span class="line">struct inet_protocol *inet_protos[MAX_INET_PROTOS];</span><br></pre></td></tr></table></figure>

<ul>
<li><p>不同的传输层协议处理函数，会根据其协议类型的值保存到 <code>inet_protos</code> 数组中。由于 <code>inet_protos</code> 数组只有32个元素，所以保存处理函数时，需要将协议值与32进行取模操作，得到一个 0 ~ 31 的值，然后把处理函数保存到 <code>inet_protos</code> 数组对应位置上。如果有多个协议发生冲突，那么就通过 <code>next</code> 字段连接起来。</p>
</li>
<li><p>通过调用 <code>inet_add_protocol</code> 函数，可以向 <code>inet_protos</code> 数组注册传输层协议的处理函数。例如 <code>TCP协议</code> 的处理函数定义如下：</p>
</li>
</ul>
<figure class="highlight text"><table><tr><td class="code"><pre><span class="line">static struct inet_protocol tcp_protocol = </span><br><span class="line">&#123;</span><br><span class="line">    tcp_v4_rcv,         /* TCP handler */</span><br><span class="line">    IPPROTO_TCP,        /* protocol ID */</span><br><span class="line">    ...</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<ul>
<li><p>所以，当接收到一个 TCP 协议数据包时，将会调用 <code>tcp_v4_rcv</code> 函数处理此数据包。</p>
</li>
<li><p>最后，我以一幅图来展示处理 IP 数据包的函数调用链：</p>
</li>
</ul>
<h2 id="3、总结"><a href="#3、总结" class="headerlink" title="3、总结"></a>3、<strong>总结</strong></h2><ul>
<li>本文主要介绍了网络中断下半部的处理，从分析可知，网络中断下半部主要工作是从待处理队列中获取数据包，并且根据数据包的网络层协议类型来找到相应的处理接口，然后把数据包交由网络层协议处理接口进行处理。</li>
</ul>
<hr>
<p>版权声明：本文为知乎博主「Linux内核库」的原创文章，遵循CC 4.0 BY-SA版权协议，转载请附上原文 出处链接及本声明。 </p>
<p>原文链接：<a href="https://zhuanlan.zhihu.com/p/478883502">https://zhuanlan.zhihu.com/p/478883502</a></p>
]]></content>
      <categories>
        <category>linux-doc 网络协议栈</category>
      </categories>
      <tags>
        <tag>Linux</tag>
      </tags>
  </entry>
  <entry>
    <title>Linux内核网络协议栈accept函数剖析</title>
    <url>/2023/01/15/linux-docs/%E7%BD%91%E7%BB%9C%E5%8D%8F%E8%AE%AE%E6%A0%88/Linux%E5%86%85%E6%A0%B8%E7%BD%91%E7%BB%9C%E5%8D%8F%E8%AE%AE%E6%A0%88accept%E5%87%BD%E6%95%B0%E5%89%96%E6%9E%90/</url>
    <content><![CDATA[<h2 id="1、应用层——accept-函数"><a href="#1、应用层——accept-函数" class="headerlink" title="1、应用层——accept 函数"></a>1、应用层——acce<strong>pt 函数</strong></h2><p>该函数返回一个已建立连接的可用于数据通信的套接字。</p>
<figure class="highlight text"><table><tr><td class="code"><pre><span class="line">#include &lt;sys/socket.h&gt; </span><br><span class="line">int accept(int sockfd, struct sockaddr *cliaddr, socklen_t *addrlen);  </span><br><span class="line">//返回：非负描述子——成功，-1——出错 </span><br><span class="line">/*参数sockfd是监听后的套接字，这个套接字用来监听一个端口，当有一个客户与服务器连接时，它使用一个与这个套接字关联的端口号， </span><br><span class="line">比较特别的是：参数cliaddr和addrlen是一个结果参数，用来返回已连接客户的协议地址。如果对客户的地址不感兴趣，那么可以把这个值设置为NULL*/ </span><br></pre></td></tr></table></figure>

<h2 id="2、BSD-Socket-层——sock-accept-函数"><a href="#2、BSD-Socket-层——sock-accept-函数" class="headerlink" title="2、BSD Socket 层——sock_accept 函数"></a>2、BSD Socket 层——sock_accept 函数</h2><figure class="highlight text"><table><tr><td class="code"><pre><span class="line">/* </span><br><span class="line"> *  For accept, we attempt to create a new socket, set up the link </span><br><span class="line"> *  with the client, wake up the client, then return the new </span><br><span class="line"> *  connected fd. We collect the address of the connector in kernel </span><br><span class="line"> *  space and move it to user at the very end. This is buggy because </span><br><span class="line"> *  we open the socket then return an error. </span><br><span class="line"> */  </span><br><span class="line">//用于服务器接收一个客户端的连接请求，这里是值-结果参数，之前有说到  </span><br><span class="line">//fd 为监听后套接字。最后返回一个记录了本地与目的端信息的套接字  </span><br><span class="line">//upeer_sockaddr用来返回已连接客户的协议地址，如果对协议地址不感兴趣就NULL  </span><br><span class="line">static int sock_accept(int fd, struct sockaddr *upeer_sockaddr, int *upeer_addrlen)  </span><br><span class="line">&#123;  </span><br><span class="line">    struct file *file;  </span><br><span class="line">    struct socket *sock, *newsock;  </span><br><span class="line">    int i;  </span><br><span class="line">    char address[MAX_SOCK_ADDR];  </span><br><span class="line">    int len;  </span><br><span class="line">  </span><br><span class="line">    if (fd &lt; 0 || fd &gt;= NR_OPEN || ((file = current-&gt;files-&gt;fd[fd]) == NULL))  </span><br><span class="line">        return(-EBADF);  </span><br><span class="line">    if (!(sock = sockfd_lookup(fd, &amp;file)))   </span><br><span class="line">        return(-ENOTSOCK);  </span><br><span class="line">    if (sock-&gt;state != SS_UNCONNECTED)//socket各个状态的演变是一步一步来的   </span><br><span class="line">    &#123;  </span><br><span class="line">        return(-EINVAL);  </span><br><span class="line">    &#125;  </span><br><span class="line">    //这是tcp连接，得按步骤来  </span><br><span class="line">    if (!(sock-&gt;flags &amp; SO_ACCEPTCON))//没有listen  </span><br><span class="line">    &#123;  </span><br><span class="line">        return(-EINVAL);  </span><br><span class="line">    &#125;  </span><br><span class="line">    //分配一个新的套接字，用于表示后面可进行通信的套接字  </span><br><span class="line">    if (!(newsock = sock_alloc()))   </span><br><span class="line">    &#123;  </span><br><span class="line">        printk(&quot;NET: sock_accept: no more sockets\n&quot;);  </span><br><span class="line">        return(-ENOSR); /* Was: EAGAIN, but we are out of system </span><br><span class="line">                   resources! */  </span><br><span class="line">    &#125;  </span><br><span class="line">    newsock-&gt;type = sock-&gt;type;  </span><br><span class="line">    newsock-&gt;ops = sock-&gt;ops;  </span><br><span class="line">    //套接字重定向，目的是初始化新的用于数据传送的套接字  </span><br><span class="line">    //继承了第一参数传来的服务器的IP和端口号信息  </span><br><span class="line">    if ((i = sock-&gt;ops-&gt;dup(newsock, sock)) &lt; 0)   </span><br><span class="line">    &#123;  </span><br><span class="line">        sock_release(newsock);  </span><br><span class="line">        return(i);  </span><br><span class="line">    &#125;  </span><br><span class="line">    //转调用inet_accept  </span><br><span class="line">    i = newsock-&gt;ops-&gt;accept(sock, newsock, file-&gt;f_flags);  </span><br><span class="line">    if ( i &lt; 0)   </span><br><span class="line">    &#123;  </span><br><span class="line">        sock_release(newsock);  </span><br><span class="line">        return(i);  </span><br><span class="line">    &#125;  </span><br><span class="line">    //分配一个文件描述符，用于以后的数据传送  </span><br><span class="line">    if ((fd = get_fd(SOCK_INODE(newsock))) &lt; 0)   </span><br><span class="line">    &#123;  </span><br><span class="line">        sock_release(newsock);  </span><br><span class="line">        return(-EINVAL);  </span><br><span class="line">    &#125;  </span><br><span class="line">    //返回通信远端的地址  </span><br><span class="line">    if (upeer_sockaddr)  </span><br><span class="line">    &#123;//得到客户端地址，并复制到用户空间  </span><br><span class="line">        newsock-&gt;ops-&gt;getname(newsock, (struct sockaddr *)address, &amp;len, 1);  </span><br><span class="line">        move_addr_to_user(address,len, upeer_sockaddr, upeer_addrlen);  </span><br><span class="line">    &#125;  </span><br><span class="line">    return(fd);  </span><br><span class="line">&#125;  </span><br></pre></td></tr></table></figure>

<h2 id="3、INET-Socket-层——inet-accept-函数"><a href="#3、INET-Socket-层——inet-accept-函数" class="headerlink" title="3、INET Socket 层——inet_accept 函数"></a>3、INET Socket 层——inet_accept 函数</h2><figure class="highlight text"><table><tr><td class="code"><pre><span class="line">/* </span><br><span class="line"> *  Accept a pending connection. The TCP layer now gives BSD semantics. </span><br><span class="line"> */  </span><br><span class="line">//先去看看sock_accept，看看各个参数的意思，newsock是dup sock后的新sock  </span><br><span class="line">//sock为监听套接字，newsock为连接成功后实际用于通信的sock  </span><br><span class="line">static int inet_accept(struct socket *sock, struct socket *newsock, int flags)  </span><br><span class="line">&#123;  </span><br><span class="line">    struct sock *sk1, *sk2;  </span><br><span class="line">    int err;  </span><br><span class="line">  </span><br><span class="line">    sk1 = (struct sock *) sock-&gt;data;  </span><br><span class="line">  </span><br><span class="line">    /* </span><br><span class="line">     * We&#x27;ve been passed an extra socket. </span><br><span class="line">     * We need to free it up because the tcp module creates </span><br><span class="line">     * its own when it accepts one. </span><br><span class="line">     */  </span><br><span class="line">     //如果sock-&gt;data 已经指向了对应的sock结构，则把它销毁  </span><br><span class="line">     //销毁旧的，后面指向新的accept后的  </span><br><span class="line">    if (newsock-&gt;data)  </span><br><span class="line">    &#123;  </span><br><span class="line">        struct sock *sk=(struct sock *)newsock-&gt;data;  </span><br><span class="line">        newsock-&gt;data=NULL;  </span><br><span class="line">        sk-&gt;dead = 1;  </span><br><span class="line">        destroy_sock(sk);//销毁旧的socket对应的sock结构  </span><br><span class="line">    &#125;  </span><br><span class="line">    </span><br><span class="line">    if (sk1-&gt;prot-&gt;accept == NULL) //没有对应的操作函数集，退出  </span><br><span class="line">        return(-EOPNOTSUPP);  </span><br><span class="line">  </span><br><span class="line">    /* Restore the state if we have been interrupted, and then returned. */  </span><br><span class="line">//如果套接字在等待连接的过程中被中断，则监听套接字与中断的套接字关联，下次优先处理该套接字  </span><br><span class="line">    if (sk1-&gt;pair != NULL )   </span><br><span class="line">    &#123;  </span><br><span class="line">        sk2 = sk1-&gt;pair;  </span><br><span class="line">        sk1-&gt;pair = NULL;  </span><br><span class="line">    &#125;   </span><br><span class="line">    else  </span><br><span class="line">    &#123;  </span><br><span class="line">//这里调用下层处理函数tcp_accept，首次调用inet_accept，sk1-&gt;pair 肯定是为NULL的，所以一开始就会执行下面的代码  </span><br><span class="line">        sk2 = sk1-&gt;prot-&gt;accept(sk1,flags);//交给下层处理函数  </span><br><span class="line">        if (sk2 == NULL)   </span><br><span class="line">        &#123;  </span><br><span class="line">            if (sk1-&gt;err &lt;= 0)  </span><br><span class="line">                printk(&quot;Warning sock.c:sk1-&gt;err &lt;= 0.  Returning non-error.\n&quot;);  </span><br><span class="line">            err=sk1-&gt;err;  </span><br><span class="line">            sk1-&gt;err=0;  </span><br><span class="line">            return(-err);  </span><br><span class="line">        &#125;  </span><br><span class="line">    &#125;  </span><br><span class="line">    //socket sock建立关联  </span><br><span class="line">    newsock-&gt;data = (void *)sk2;//指向新的，sk2为下层函数tcp_accept返回的套接字  </span><br><span class="line">    sk2-&gt;sleep = newsock-&gt;wait;//等待队列  </span><br><span class="line">    sk2-&gt;socket = newsock;//回绑，指向上层的socket结构  </span><br><span class="line">    newsock-&gt;conn = NULL;//还没有连接客户端  </span><br><span class="line">    if (flags &amp; O_NONBLOCK)   </span><br><span class="line">        return(0);  </span><br><span class="line">  </span><br><span class="line">    cli(); /* avoid the race. */  </span><br><span class="line">    //三次握手中间过程，tcp SYN序列号接收  </span><br><span class="line">    while(sk2-&gt;state == TCP_SYN_RECV)   </span><br><span class="line">    &#123;  </span><br><span class="line">    //被中断了  </span><br><span class="line">        interruptible_sleep_on(sk2-&gt;sleep);  </span><br><span class="line">        if (current-&gt;signal &amp; ~current-&gt;blocked)   </span><br><span class="line">        &#123;  </span><br><span class="line">            sti();  </span><br><span class="line">            sk1-&gt;pair = sk2;//存入pair，下次优先处理  </span><br><span class="line">            sk2-&gt;sleep = NULL;  </span><br><span class="line">            sk2-&gt;socket=NULL;  </span><br><span class="line">            newsock-&gt;data = NULL;  </span><br><span class="line">            return(-ERESTARTSYS);  </span><br><span class="line">        &#125;  </span><br><span class="line">    &#125;  </span><br><span class="line">    sti();  </span><br><span class="line">    //连接失败，三次握手失败  </span><br><span class="line">    if (sk2-&gt;state != TCP_ESTABLISHED &amp;&amp; sk2-&gt;err &gt; 0)   </span><br><span class="line">    &#123;  </span><br><span class="line">        err = -sk2-&gt;err;  </span><br><span class="line">        sk2-&gt;err=0;  </span><br><span class="line">        sk2-&gt;dead=1; /* ANK */  </span><br><span class="line">        destroy_sock(sk2);//销毁新建的sock结构  </span><br><span class="line">        newsock-&gt;data = NULL;  </span><br><span class="line">        return(err);  </span><br><span class="line">    &#125;  </span><br><span class="line">    newsock-&gt;state = SS_CONNECTED;//已经建立了连接  </span><br><span class="line">    return(0);  </span><br><span class="line">&#125;  </span><br></pre></td></tr></table></figure>

<h2 id="4、传输层——tcp-accept-函数"><a href="#4、传输层——tcp-accept-函数" class="headerlink" title="4、传输层——tcp_accept 函数"></a>4、传输层——tcp_accept 函数</h2><figure class="highlight text"><table><tr><td class="code"><pre><span class="line">/* </span><br><span class="line"> *  This will accept the next outstanding connection.  </span><br><span class="line"> */  </span><br><span class="line"> //accept-&gt;sock_accpet-&gt;inet_accpet-&gt;tcp_accept(tcp)  </span><br><span class="line"> //顶层accept传值进来的套接字sk是监听套接字，然后返回可以进行数据通信的套接字  </span><br><span class="line"> //tcp_accept就是从监听套接字缓存队列里面找到一个完成连接的套接字  </span><br><span class="line">static struct sock *tcp_accept(struct sock *sk, int flags)  </span><br><span class="line">&#123;  </span><br><span class="line">    struct sock *newsk;  </span><br><span class="line">    struct sk_buff *skb;  </span><br><span class="line">    </span><br><span class="line">  /* </span><br><span class="line">   * We need to make sure that this socket is listening, </span><br><span class="line">   * and that it has something pending. </span><br><span class="line">   */  </span><br><span class="line">  </span><br><span class="line">    if (sk-&gt;state != TCP_LISTEN) //如果当前不是出于监听状态就退出  </span><br><span class="line">    &#123;  </span><br><span class="line">        sk-&gt;err = EINVAL;  </span><br><span class="line">        return(NULL);   </span><br><span class="line">    &#125;  </span><br><span class="line">    //套接字处于监听状态  </span><br><span class="line">    /* Avoid the race. */  </span><br><span class="line">    cli();  </span><br><span class="line">    sk-&gt;inuse = 1;//表示当前进程正在使用该sock结构，其余进程不能使用，加锁  </span><br><span class="line">      </span><br><span class="line">  //从监听套接字缓存队列里找到已经建立连接的套接字,并返回  </span><br><span class="line">    while((skb = tcp_dequeue_established(sk)) == NULL)  </span><br><span class="line">    &#123;  </span><br><span class="line">    //如果没有完成连接的，就一直陷入循环，然后重发back_log中的数据包  </span><br><span class="line">        if (flags &amp; O_NONBLOCK) //不阻塞  </span><br><span class="line">        &#123;  </span><br><span class="line">            sti();  </span><br><span class="line">//如果当前套接字正忙，数据包将插入到sock结构的back_log队列中，back_log只是暂居之所  </span><br><span class="line">//数据包必须插入到receive_queue中才算被接收  </span><br><span class="line">            release_sock(sk);//从back_log中取数据包重新调用tcp_rcv函数对数据包进行接收  </span><br><span class="line">            sk-&gt;err = EAGAIN;  </span><br><span class="line">            return(NULL);  </span><br><span class="line">        &#125;  </span><br><span class="line">       </span><br><span class="line">        release_sock(sk);//从back_log中取数据包重新调用tcp_rcv函数对数据包进行接收  </span><br><span class="line">        interruptible_sleep_on(sk-&gt;sleep);  </span><br><span class="line">        if (current-&gt;signal &amp; ~current-&gt;blocked)   </span><br><span class="line">        &#123;  </span><br><span class="line">            sti();  </span><br><span class="line">            sk-&gt;err = ERESTARTSYS;  </span><br><span class="line">            return(NULL);  </span><br><span class="line">        &#125;  </span><br><span class="line">        sk-&gt;inuse = 1;//加锁  </span><br><span class="line">    &#125;  </span><br><span class="line">    sti();  </span><br><span class="line">  </span><br><span class="line">    /* </span><br><span class="line">     *  Now all we need to do is return skb-&gt;sk.  </span><br><span class="line">     */  </span><br><span class="line">    newsk = skb-&gt;sk;//返回的套接字(已完成连接)  </span><br><span class="line">  </span><br><span class="line">    kfree_skb(skb, FREE_READ);//释放sk_buff  </span><br><span class="line">    sk-&gt;ack_backlog--;//未应答数据包个数-1  </span><br><span class="line">    release_sock(sk);//原套接字继续监听  </span><br><span class="line">    return(newsk);  </span><br><span class="line">&#125;  </span><br></pre></td></tr></table></figure>

<p>好，定位到 tcp_dqueue_established 函数：</p>
<figure class="highlight text"><table><tr><td class="code"><pre><span class="line">/* </span><br><span class="line"> *  Remove a completed connection and return it. This is used by </span><br><span class="line"> *  tcp_accept() to get connections from the queue. </span><br><span class="line"> */  </span><br><span class="line">//移除sock中一个已经建立连接的数据包，并返回该数据包  </span><br><span class="line">//结合前面可以看出，对于receive_queue，套接字连接的第1次握手时在该链表尾部增加一个链表节点，  </span><br><span class="line">//当第3次握手完成将此节点删除,所以对于监听套接字receive_queue中保存的是不完全建立连接的套接字的数据包  </span><br><span class="line">static struct sk_buff *tcp_dequeue_established(struct sock *s)  </span><br><span class="line">&#123;  </span><br><span class="line">    struct sk_buff *skb;  </span><br><span class="line">    unsigned long flags;  </span><br><span class="line">    save_flags(flags);//保存状态  </span><br><span class="line">    cli();   </span><br><span class="line">    skb=tcp_find_established(s);//找到已经建立连接的数据包  </span><br><span class="line">    if(skb!=NULL)  </span><br><span class="line">        skb_unlink(skb);    //从队列中移除，但该数据报实体还是存在的/* Take it off the queue */  </span><br><span class="line">    restore_flags(flags);  </span><br><span class="line">    return skb;  </span><br><span class="line">&#125;  </span><br></pre></td></tr></table></figure>

<p>好，再定位到 tcp_find_established 函数：</p>
<figure class="highlight text"><table><tr><td class="code"><pre><span class="line">/* </span><br><span class="line"> *  Find someone to &#x27;accept&#x27;. Must be called with </span><br><span class="line"> *  sk-&gt;inuse=1 or cli() </span><br><span class="line"> */   </span><br><span class="line"> //sk_buff 表示接收或发送数据报的包头信息  </span><br><span class="line">/*从监听套接字缓冲队列中检查是否存在已经完成连接的远端发送的数据包，该数据包的作用是完成连接。 </span><br><span class="line">本地监听套接字在处理完该连接，设置相关状态后将该数据包缓存在receive_queue中 </span><br><span class="line">*/  </span><br><span class="line">/*对于监听套接字而言，其接收队列中的数据包是建立连接数据包，即SYN数据包，不含数据数据包 </span><br><span class="line">*/  </span><br><span class="line">static struct sk_buff *tcp_find_established(struct sock *s)  </span><br><span class="line">&#123;  </span><br><span class="line">//获取receive_queue中的第一个链表元素，sk_buff 结构  </span><br><span class="line">    //该队列中的数据报表示已被正式接收  </span><br><span class="line">  </span><br><span class="line">    struct sk_buff *p=skb_peek(&amp;s-&gt;receive_queue);//返回指向链表第一个节点的指针  </span><br><span class="line">    if(p==NULL)  </span><br><span class="line">        return NULL;  </span><br><span class="line">    do  </span><br><span class="line">    &#123;  </span><br><span class="line">    //sk的状态state是枚举类  </span><br><span class="line">    //返回完成了三次握手连接的套接字  </span><br><span class="line">        if(p-&gt;sk-&gt;state == TCP_ESTABLISHED || p-&gt;sk-&gt;state &gt;= TCP_FIN_WAIT1)  </span><br><span class="line">            return p;  </span><br><span class="line">        p=p-&gt;next;  </span><br><span class="line">    &#125;  </span><br><span class="line">    while(p!=(struct sk_buff *)&amp;s-&gt;receive_queue);//双向链表，即遍历整个队列  </span><br><span class="line">    return NULL;  </span><br><span class="line">&#125;  </span><br></pre></td></tr></table></figure>

<p>看到没，这里accept 函数返回的通信套接字是从监听套接字的 receive_queue 队列中获得的，那么通信套接字与监听套接字的receive_queue队列之间的关系，其中的细节又是什么呢？</p>
<p>其内部实现在 tcp_conn_request 函数中啦：而这个函数在connect 函数下层函数被调用，服务器是被动打开的，即是客户端主动连接。</p>
<figure class="highlight text"><table><tr><td class="code"><pre><span class="line">/* </span><br><span class="line"> *  This routine handles a connection request. </span><br><span class="line"> *  It should make sure we haven&#x27;t already responded. </span><br><span class="line"> *  Because of the way BSD works, we have to send a syn/ack now. </span><br><span class="line"> *  This also means it will be harder to close a socket which is </span><br><span class="line"> *  listening. </span><br><span class="line"> */  </span><br><span class="line"> /* </span><br><span class="line"> 参数中daddr，saddr的理解应从远端角度出发。所以daddr表示本地地址；saddr表示远端地址 </span><br><span class="line"> seq是函数调用tcp_init_seq()的返回值，表示本地初始化序列号； </span><br><span class="line"> dev表示接收该数据包的接口设备 </span><br><span class="line"> */  </span><br><span class="line"> //tcp_rcv接收一个syn连接请求数据包后，将调用tcp_con_request函数进行具体处理  </span><br><span class="line"> //其内部逻辑很简单:创建一个新的套接字用于通信，其本身继续监听客户端的请求  </span><br><span class="line"> //创建一个新的套接字得设置其各个字段，这里是复制监听套接字的已有信息，然后根据需要修改部分  </span><br><span class="line"> //然后创建数据包，设置其TCP首部，创建MAC和IP首部，然后回送给客户端，  </span><br><span class="line"> //并把该数据包插入到监听套接字sk的recive_queue队列中，该数据包已经关联了新套接字，  </span><br><span class="line"> //在accept函数中，最后返回的通信套接字则是从这个队列中获得(参见tcp_accept函数)  </span><br><span class="line">static void tcp_conn_request(struct sock *sk, struct sk_buff *skb,  </span><br><span class="line">         unsigned long daddr, unsigned long saddr,  </span><br><span class="line">         struct options *opt, struct device *dev, unsigned long seq)  </span><br><span class="line">&#123;  </span><br><span class="line">    struct sk_buff *buff;  </span><br><span class="line">    struct tcphdr *t1;  </span><br><span class="line">    unsigned char *ptr;  </span><br><span class="line">    struct sock *newsk;  </span><br><span class="line">    struct tcphdr *th;  </span><br><span class="line">    struct device *ndev=NULL;  </span><br><span class="line">    int tmp;  </span><br><span class="line">    struct rtable *rt;  </span><br><span class="line">    </span><br><span class="line">    th = skb-&gt;h.th;//获取tcp首部  </span><br><span class="line">  </span><br><span class="line">    /* If the socket is dead, don&#x27;t accept the connection. */  </span><br><span class="line">    //判断套接字合法性  </span><br><span class="line">    if (!sk-&gt;dead)   </span><br><span class="line">    &#123;  </span><br><span class="line">        sk-&gt;data_ready(sk,0);//通知睡眠进程，有数据到达  </span><br><span class="line">    &#125;  </span><br><span class="line">    else //无效套接字，已经释放了的  </span><br><span class="line">    &#123;  </span><br><span class="line">        if(sk-&gt;debug)  </span><br><span class="line">            printk(&quot;Reset on %p: Connect on dead socket.\n&quot;,sk);  </span><br><span class="line">        tcp_reset(daddr, saddr, th, sk-&gt;prot, opt, dev, sk-&gt;ip_tos,sk-&gt;ip_ttl);  </span><br><span class="line">        tcp_statistics.TcpAttemptFails++;  </span><br><span class="line">        kfree_skb(skb, FREE_READ);  </span><br><span class="line">        return;  </span><br><span class="line">    &#125;  </span><br><span class="line">  </span><br><span class="line">    /* </span><br><span class="line">     * Make sure we can accept more.  This will prevent a </span><br><span class="line">     * flurry of syns from eating up all our memory. </span><br><span class="line">     */  </span><br><span class="line">   //缓存的未应答数据包个数 &gt;= 最大可缓存个数；表示满了，已经不能接收了  </span><br><span class="line">    if (sk-&gt;ack_backlog &gt;= sk-&gt;max_ack_backlog)   </span><br><span class="line">    &#123;  </span><br><span class="line">        tcp_statistics.TcpAttemptFails++;  </span><br><span class="line">        kfree_skb(skb, FREE_READ);  </span><br><span class="line">        return;  </span><br><span class="line">    &#125;  </span><br><span class="line">  </span><br><span class="line">    /* </span><br><span class="line">     * We need to build a new sock struct. </span><br><span class="line">     * It is sort of bad to have a socket without an inode attached </span><br><span class="line">     * to it, but the wake_up&#x27;s will just wake up the listening socket, </span><br><span class="line">     * and if the listening socket is destroyed before this is taken </span><br><span class="line">     * off of the queue, this will take care of it. </span><br><span class="line">     */  </span><br><span class="line">  //创建一个新的套接字  </span><br><span class="line">    newsk = (struct sock *) kmalloc(sizeof(struct sock), GFP_ATOMIC);  </span><br><span class="line">    if (newsk == NULL)   </span><br><span class="line">    &#123;  </span><br><span class="line">        /* just ignore the syn.  It will get retransmitted. */  </span><br><span class="line">        tcp_statistics.TcpAttemptFails++;  </span><br><span class="line">        kfree_skb(skb, FREE_READ);  </span><br><span class="line">        return;  </span><br><span class="line">    &#125;  </span><br><span class="line">   //复制一个套接字结构，即新的套接字中主要信息来源于监听套接字中的已有信息  </span><br><span class="line">    memcpy(newsk, sk, sizeof(*newsk));  </span><br><span class="line">   //下面两个就是把待发送和已接收队列初始化成数据包链表形式  </span><br><span class="line">    skb_queue_head_init(&amp;newsk-&gt;write_queue);  </span><br><span class="line">    skb_queue_head_init(&amp;newsk-&gt;receive_queue);  </span><br><span class="line">    //下面是重发队列  </span><br><span class="line">    newsk-&gt;send_head = NULL;  </span><br><span class="line">    newsk-&gt;send_tail = NULL;  </span><br><span class="line">    skb_queue_head_init(&amp;newsk-&gt;back_log);//数据包暂存队列(中转站)  </span><br><span class="line">    //新套接字的字段设置  </span><br><span class="line">    newsk-&gt;rtt = 0;      /*TCP_CONNECT_TIME&lt;&lt;3*/  </span><br><span class="line">    newsk-&gt;rto = TCP_TIMEOUT_INIT;  </span><br><span class="line">    newsk-&gt;mdev = 0;  </span><br><span class="line">    newsk-&gt;max_window = 0;  </span><br><span class="line">    newsk-&gt;cong_window = 1;  </span><br><span class="line">    newsk-&gt;cong_count = 0;  </span><br><span class="line">    newsk-&gt;ssthresh = 0;  </span><br><span class="line">    newsk-&gt;backoff = 0;  </span><br><span class="line">    newsk-&gt;blog = 0;  </span><br><span class="line">    newsk-&gt;intr = 0;  </span><br><span class="line">    newsk-&gt;proc = 0;  </span><br><span class="line">    newsk-&gt;done = 0;  </span><br><span class="line">    newsk-&gt;partial = NULL;  </span><br><span class="line">    newsk-&gt;pair = NULL;  </span><br><span class="line">    newsk-&gt;wmem_alloc = 0;  </span><br><span class="line">    newsk-&gt;rmem_alloc = 0;  </span><br><span class="line">    newsk-&gt;localroute = sk-&gt;localroute;  </span><br><span class="line">  </span><br><span class="line">    newsk-&gt;max_unacked = MAX_WINDOW - TCP_WINDOW_DIFF;  </span><br><span class="line">  </span><br><span class="line">    newsk-&gt;err = 0;  </span><br><span class="line">    newsk-&gt;shutdown = 0;  </span><br><span class="line">    newsk-&gt;ack_backlog = 0;  </span><br><span class="line">    newsk-&gt;acked_seq = skb-&gt;h.th-&gt;seq+1;  </span><br><span class="line">    newsk-&gt;copied_seq = skb-&gt;h.th-&gt;seq+1;  </span><br><span class="line">    newsk-&gt;fin_seq = skb-&gt;h.th-&gt;seq;  </span><br><span class="line">    newsk-&gt;state = TCP_SYN_RECV;  </span><br><span class="line">    newsk-&gt;timeout = 0;  </span><br><span class="line">    newsk-&gt;ip_xmit_timeout = 0;  </span><br><span class="line">    newsk-&gt;write_seq = seq;   </span><br><span class="line">    newsk-&gt;window_seq = newsk-&gt;write_seq;  </span><br><span class="line">    newsk-&gt;rcv_ack_seq = newsk-&gt;write_seq;  </span><br><span class="line">    newsk-&gt;urg_data = 0;  </span><br><span class="line">    newsk-&gt;retransmits = 0;  </span><br><span class="line">    newsk-&gt;linger=0;  </span><br><span class="line">    newsk-&gt;destroy = 0;  </span><br><span class="line">    init_timer(&amp;newsk-&gt;timer);  </span><br><span class="line">    newsk-&gt;timer.data = (unsigned long)newsk;  </span><br><span class="line">    newsk-&gt;timer.function = &amp;net_timer;  </span><br><span class="line">    init_timer(&amp;newsk-&gt;retransmit_timer);  </span><br><span class="line">    newsk-&gt;retransmit_timer.data = (unsigned long)newsk;  </span><br><span class="line">    newsk-&gt;retransmit_timer.function=&amp;retransmit_timer;  </span><br><span class="line">    newsk-&gt;dummy_th.source = skb-&gt;h.th-&gt;dest;  </span><br><span class="line">    newsk-&gt;dummy_th.dest = skb-&gt;h.th-&gt;source;  </span><br><span class="line">      </span><br><span class="line">    /* </span><br><span class="line">     *  Swap these two, they are from our point of view.  </span><br><span class="line">     */  </span><br><span class="line">       </span><br><span class="line">    newsk-&gt;daddr = saddr;  </span><br><span class="line">    newsk-&gt;saddr = daddr;  </span><br><span class="line">  </span><br><span class="line">    put_sock(newsk-&gt;num,newsk);//插入 array_sock 哈希表中  </span><br><span class="line">    newsk-&gt;dummy_th.res1 = 0;  </span><br><span class="line">    newsk-&gt;dummy_th.doff = 6;  </span><br><span class="line">    newsk-&gt;dummy_th.fin = 0;  </span><br><span class="line">    newsk-&gt;dummy_th.syn = 0;  </span><br><span class="line">    newsk-&gt;dummy_th.rst = 0;   </span><br><span class="line">    newsk-&gt;dummy_th.psh = 0;  </span><br><span class="line">    newsk-&gt;dummy_th.ack = 0;  </span><br><span class="line">    newsk-&gt;dummy_th.urg = 0;  </span><br><span class="line">    newsk-&gt;dummy_th.res2 = 0;  </span><br><span class="line">    newsk-&gt;acked_seq = skb-&gt;h.th-&gt;seq + 1;//序列号设置  </span><br><span class="line">    newsk-&gt;copied_seq = skb-&gt;h.th-&gt;seq + 1;  </span><br><span class="line">    newsk-&gt;socket = NULL;  </span><br><span class="line">  </span><br><span class="line">    /* </span><br><span class="line">     *  Grab the ttl and tos values and use them  </span><br><span class="line">     */  </span><br><span class="line">  </span><br><span class="line">    newsk-&gt;ip_ttl=sk-&gt;ip_ttl;  </span><br><span class="line">    newsk-&gt;ip_tos=skb-&gt;ip_hdr-&gt;tos;  </span><br><span class="line">  </span><br><span class="line">    /* </span><br><span class="line">     *  Use 512 or whatever user asked for  </span><br><span class="line">     */  </span><br><span class="line">  </span><br><span class="line">    /* </span><br><span class="line">     *  Note use of sk-&gt;user_mss, since user has no direct access to newsk  </span><br><span class="line">     */  </span><br><span class="line">    //ip路由表查找表项  </span><br><span class="line">    rt=ip_rt_route(saddr, NULL,NULL);  </span><br><span class="line">      </span><br><span class="line">    if(rt!=NULL &amp;&amp; (rt-&gt;rt_flags&amp;RTF_WINDOW))  </span><br><span class="line">        newsk-&gt;window_clamp = rt-&gt;rt_window;  </span><br><span class="line">    else  </span><br><span class="line">        newsk-&gt;window_clamp = 0;  </span><br><span class="line">          </span><br><span class="line">    if (sk-&gt;user_mss)  </span><br><span class="line">        newsk-&gt;mtu = sk-&gt;user_mss;  </span><br><span class="line">    else if(rt!=NULL &amp;&amp; (rt-&gt;rt_flags&amp;RTF_MSS))  </span><br><span class="line">        newsk-&gt;mtu = rt-&gt;rt_mss - HEADER_SIZE;  </span><br><span class="line">    else   </span><br><span class="line">    &#123;  </span><br><span class="line">#ifdef CONFIG_INET_SNARL    /* Sub Nets Are Local */  </span><br><span class="line">        if ((saddr ^ daddr) &amp; default_mask(saddr))  </span><br><span class="line">#else  </span><br><span class="line">        if ((saddr ^ daddr) &amp; dev-&gt;pa_mask)  </span><br><span class="line">#endif  </span><br><span class="line">            newsk-&gt;mtu = 576 - HEADER_SIZE;  </span><br><span class="line">        else  </span><br><span class="line">            newsk-&gt;mtu = MAX_WINDOW;  </span><br><span class="line">    &#125;  </span><br><span class="line">  </span><br><span class="line">    /* </span><br><span class="line">     *  But not bigger than device MTU  </span><br><span class="line">     */  </span><br><span class="line">  </span><br><span class="line">    newsk-&gt;mtu = min(newsk-&gt;mtu, dev-&gt;mtu - HEADER_SIZE);  </span><br><span class="line">  </span><br><span class="line">    /* </span><br><span class="line">     *  This will min with what arrived in the packet  </span><br><span class="line">     */  </span><br><span class="line">  </span><br><span class="line">    tcp_options(newsk,skb-&gt;h.th);  </span><br><span class="line"> //服务器端创建新的套接字后，接下来就是创建一个数据包(syn+ack)回送过去  </span><br><span class="line">    buff = newsk-&gt;prot-&gt;wmalloc(newsk, MAX_SYN_SIZE, 1, GFP_ATOMIC);  </span><br><span class="line">    if (buff == NULL)   </span><br><span class="line">    &#123;  </span><br><span class="line">        sk-&gt;err = ENOMEM;  </span><br><span class="line">        newsk-&gt;dead = 1;  </span><br><span class="line">        newsk-&gt;state = TCP_CLOSE;  </span><br><span class="line">        /* And this will destroy it */  </span><br><span class="line">        release_sock(newsk);  </span><br><span class="line">        kfree_skb(skb, FREE_READ);  </span><br><span class="line">        tcp_statistics.TcpAttemptFails++;  </span><br><span class="line">        return;  </span><br><span class="line">    &#125;  </span><br><span class="line">  //字段设置  </span><br><span class="line">    buff-&gt;len = sizeof(struct tcphdr)+4;  </span><br><span class="line">    buff-&gt;sk = newsk;//与新套接字关联  </span><br><span class="line">    buff-&gt;localroute = newsk-&gt;localroute;  </span><br><span class="line">  </span><br><span class="line">    t1 =(struct tcphdr *) buff-&gt;data;  </span><br><span class="line">  </span><br><span class="line">    /* </span><br><span class="line">     *  Put in the IP header and routing stuff.  </span><br><span class="line">     */  </span><br><span class="line">  //MAC 头+ ip 头创建  </span><br><span class="line">    tmp = sk-&gt;prot-&gt;build_header(buff, newsk-&gt;saddr, newsk-&gt;daddr, &amp;ndev,  </span><br><span class="line">                   IPPROTO_TCP, NULL, MAX_SYN_SIZE,sk-&gt;ip_tos,sk-&gt;ip_ttl);  </span><br><span class="line">  </span><br><span class="line">    /* </span><br><span class="line">     *  Something went wrong.  </span><br><span class="line">     */  </span><br><span class="line">  </span><br><span class="line">    if (tmp &lt; 0)   </span><br><span class="line">    &#123;  </span><br><span class="line">        sk-&gt;err = tmp;  </span><br><span class="line">        buff-&gt;free = 1;  </span><br><span class="line">        kfree_skb(buff,FREE_WRITE);  </span><br><span class="line">        newsk-&gt;dead = 1;  </span><br><span class="line">        newsk-&gt;state = TCP_CLOSE;  </span><br><span class="line">        release_sock(newsk);  </span><br><span class="line">        skb-&gt;sk = sk;  </span><br><span class="line">        kfree_skb(skb, FREE_READ);  </span><br><span class="line">        tcp_statistics.TcpAttemptFails++;  </span><br><span class="line">        return;  </span><br><span class="line">    &#125;  </span><br><span class="line">  </span><br><span class="line">    buff-&gt;len += tmp;  </span><br><span class="line">    t1 =(struct tcphdr *)((char *)t1 +tmp);  </span><br><span class="line">  //tcp首部字段设置  </span><br><span class="line">    memcpy(t1, skb-&gt;h.th, sizeof(*t1));  </span><br><span class="line">    buff-&gt;h.seq = newsk-&gt;write_seq;  </span><br><span class="line">    /* </span><br><span class="line">     *  Swap the send and the receive.  </span><br><span class="line">     */  </span><br><span class="line">    t1-&gt;dest = skb-&gt;h.th-&gt;source;  </span><br><span class="line">    t1-&gt;source = newsk-&gt;dummy_th.source;  </span><br><span class="line">    t1-&gt;seq = ntohl(newsk-&gt;write_seq++);  </span><br><span class="line">    t1-&gt;ack = 1;//确认控制位，表示这是一个确认数据包  </span><br><span class="line">    newsk-&gt;window = tcp_select_window(newsk);  </span><br><span class="line">    newsk-&gt;sent_seq = newsk-&gt;write_seq;  </span><br><span class="line">    t1-&gt;window = ntohs(newsk-&gt;window);  </span><br><span class="line">    t1-&gt;res1 = 0;  </span><br><span class="line">    t1-&gt;res2 = 0;  </span><br><span class="line">    t1-&gt;rst = 0;  </span><br><span class="line">    t1-&gt;urg = 0;  </span><br><span class="line">    t1-&gt;psh = 0;  </span><br><span class="line">    t1-&gt;syn = 1;//同步控制位置位，和ack位一起作用  </span><br><span class="line">    t1-&gt;ack_seq = ntohl(skb-&gt;h.th-&gt;seq+1);//确认序列号=发过来的数据包的序列号+1  </span><br><span class="line">    t1-&gt;doff = sizeof(*t1)/4+1;  </span><br><span class="line">    ptr =(unsigned char *)(t1+1);  </span><br><span class="line">    ptr[0] = 2;  </span><br><span class="line">    ptr[1] = 4;  </span><br><span class="line">    ptr[2] = ((newsk-&gt;mtu) &gt;&gt; 8) &amp; 0xff;  </span><br><span class="line">    ptr[3] =(newsk-&gt;mtu) &amp; 0xff;  </span><br><span class="line">  </span><br><span class="line">    //下面是tcp校验和检查  </span><br><span class="line">    tcp_send_check(t1, daddr, saddr, sizeof(*t1)+4, newsk);  </span><br><span class="line">    //调用_queue_xmit函数发送(前面介绍过)  </span><br><span class="line">    newsk-&gt;prot-&gt;queue_xmit(newsk, ndev, buff, 0);  </span><br><span class="line">    reset_xmit_timer(newsk, TIME_WRITE , TCP_TIMEOUT_INIT);  </span><br><span class="line">    skb-&gt;sk = newsk;//这里数据包捆绑的就是新的套接字了  </span><br><span class="line">  </span><br><span class="line">    /* </span><br><span class="line">     *  Charge the sock_buff to newsk.  </span><br><span class="line">     */  </span><br><span class="line">    //原监听套接字接收队列中存放的字节数减去该数据包大小  </span><br><span class="line">    //新创建的通信套接字则加上该数据包大小  </span><br><span class="line">    sk-&gt;rmem_alloc -= skb-&gt;mem_len;  </span><br><span class="line">    newsk-&gt;rmem_alloc += skb-&gt;mem_len;  </span><br><span class="line">      </span><br><span class="line">    //把这个数据包插入到reveive_queue中，这个数据包的宿主是新套接字  </span><br><span class="line">    //在accept函数中，通信套接字则是从这个队列中获取  </span><br><span class="line">    skb_queue_tail(&amp;sk-&gt;receive_queue,skb);  </span><br><span class="line">    sk-&gt;ack_backlog++;//缓存的数据包个数+1  </span><br><span class="line">    release_sock(newsk);  </span><br><span class="line">    tcp_statistics.TcpOutSegs++;  </span><br><span class="line">&#125;  </span><br></pre></td></tr></table></figure>

<p>经过上面这个函数，我们得到了一个重要信息，就是客户端向服务器发出连接请求后，服务器端新建了通信套接字和确认数据包，二者建立关联，并把确认数据包插入到监听套接字的receive_queue 队列中，该数据包的宿主就是新建的通信套接字，而accept函数返回的通信套接字则在监听套接字的 receive_queue 队列中获得。好了，至此整个tcp连接建立过程算是剖析完毕了。</p>
<hr>
<p>版权声明：本文为知乎博主「<a href="https://www.zhihu.com/people/linuxwang-xian-sheng">极致Linux内核</a>」的原创文章，遵循CC 4.0 BY-SA版权协议，转载请附上原文出处链接及本声明。</p>
<p>原文链接：<a href="https://zhuanlan.zhihu.com/p/549428366">https://zhuanlan.zhihu.com/p/549428366</a></p>
]]></content>
      <categories>
        <category>linux-doc 网络协议栈</category>
      </categories>
      <tags>
        <tag>Linux</tag>
      </tags>
  </entry>
  <entry>
    <title>Linux内核网络协议栈bind函数使用</title>
    <url>/2023/01/15/linux-docs/%E7%BD%91%E7%BB%9C%E5%8D%8F%E8%AE%AE%E6%A0%88/Linux%E5%86%85%E6%A0%B8%E7%BD%91%E7%BB%9C%E5%8D%8F%E8%AE%AE%E6%A0%88bind%E5%87%BD%E6%95%B0%E4%BD%BF%E7%94%A8/</url>
    <content><![CDATA[<p>socket 函数并没有为套接字绑定本地地址和端口号，对于服务器端则必须显性绑定地址和端口号。bind 函数主要是服务器端使用，把一个本地协议地址赋予套接字。</p>
<h2 id="1、应用层——bind-函数"><a href="#1、应用层——bind-函数" class="headerlink" title="1、应用层——bind 函数"></a>1、应用层——bind 函数</h2><figure class="highlight text"><table><tr><td class="code"><pre><span class="line">#include &lt;sys/socket.h&gt;</span><br><span class="line">int bind(int sockfd, const struct sockaddr *myaddr, socklen_t addrlen);</span><br><span class="line">/*sockfd是由socket函数返回的套接口描述字，第二个参数是一个指向特定于协议的地址结构的指针，第三个参数是该地址结构的长度*/</span><br></pre></td></tr></table></figure>

<p>bind 函数的功能则是将socket 套接字绑定指定的地址。</p>
<h2 id="2、BSD-Socket-层——sock-bind-函数"><a href="#2、BSD-Socket-层——sock-bind-函数" class="headerlink" title="2、BSD Socket 层——sock_bind 函数"></a>2、BSD Socket 层——sock_bind 函数</h2><p>同样是通过一个共同的入口函数 sys_socket</p>
<figure class="highlight text"><table><tr><td class="code"><pre><span class="line">/*</span><br><span class="line"> *	Bind a name to a socket. Nothing much to do here since it&#x27;s</span><br><span class="line"> *	the protocol&#x27;s responsibility to handle the local address.</span><br><span class="line"> *</span><br><span class="line"> *	We move the socket address to kernel space before we call</span><br><span class="line"> *	the protocol layer (having also checked the address is ok).</span><br><span class="line"> */</span><br><span class="line"> //bind函数对应的BSD层函数，用于绑定一个本地地址，服务器端</span><br><span class="line"> //umyaddr表示需要绑定的地址结构，addrlen表示改地址结构的长度</span><br><span class="line"> //这里的fd，即为套接字描述符</span><br><span class="line">static int sock_bind(int fd, struct sockaddr *umyaddr, int addrlen)</span><br><span class="line">&#123;</span><br><span class="line">	struct socket *sock;</span><br><span class="line">	int i;</span><br><span class="line">	char address[MAX_SOCK_ADDR];</span><br><span class="line">	int err;</span><br><span class="line">    //套接字参数有效性检查</span><br><span class="line">	if (fd &lt; 0 || fd &gt;= NR_OPEN || current-&gt;files-&gt;fd[fd] == NULL)</span><br><span class="line">		return(-EBADF);</span><br><span class="line">	//获取fd对应的socket结构</span><br><span class="line">	if (!(sock = sockfd_lookup(fd, NULL))) </span><br><span class="line">		return(-ENOTSOCK);</span><br><span class="line">    //将地址从用户缓冲区复制到内核缓冲区，umyaddr-&gt;address</span><br><span class="line">	if((err=move_addr_to_kernel(umyaddr,addrlen,address))&lt;0)</span><br><span class="line">	  	return err;</span><br><span class="line">    //转调用bind指向的函数，下层函数(inet_bind)</span><br><span class="line">	if ((i = sock-&gt;ops-&gt;bind(sock, (struct sockaddr *)address, addrlen)) &lt; 0) </span><br><span class="line">	&#123;</span><br><span class="line">		return(i);</span><br><span class="line">	&#125;</span><br><span class="line">	return(0);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>sock_bind 函数主要就是将用户缓冲区的地址结构复制到内核缓冲区，然后转调用下一层的bind函数。</p>
<p>该函数内部的一个用户空间与内核数据空间数据拷贝的函数</p>
<figure class="highlight text"><table><tr><td class="code"><pre><span class="line">//从uaddr拷贝ulen大小的数据到kaddr，实现地址用户空间到内核地址空间的数据拷贝</span><br><span class="line">static int move_addr_to_kernel(void *uaddr, int ulen, void *kaddr)</span><br><span class="line">&#123;</span><br><span class="line">	int err;</span><br><span class="line">	if(ulen&lt;0||ulen&gt;MAX_SOCK_ADDR)</span><br><span class="line">		return -EINVAL;</span><br><span class="line">	if(ulen==0)</span><br><span class="line">		return 0;</span><br><span class="line">	//检查用户空间的指针所指的指定大小存储块是否可读</span><br><span class="line">	if((err=verify_area(VERIFY_READ,uaddr,ulen))&lt;0)</span><br><span class="line">		return err;</span><br><span class="line">	memcpy_fromfs(kaddr,uaddr,ulen);//实质是memcpy函数</span><br><span class="line">	return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="3、INET-Socket-层——inet-bind-函数"><a href="#3、INET-Socket-层——inet-bind-函数" class="headerlink" title="3、INET Socket 层——inet_bind 函数"></a>3、INET Socket 层——inet_bind 函数</h2><figure class="highlight text"><table><tr><td class="code"><pre><span class="line">/* this needs to be changed to disallow</span><br><span class="line">   the rebinding of sockets.   What error</span><br><span class="line">   should it return? */</span><br><span class="line">//完成本地地址绑定，本地地址绑定包括IP地址和端口号两个部分</span><br><span class="line">static int inet_bind(struct socket *sock, struct sockaddr *uaddr,int addr_len)</span><br><span class="line">&#123;</span><br><span class="line">	struct sockaddr_in *addr=(struct sockaddr_in *)uaddr;</span><br><span class="line">	struct sock *sk=(struct sock *)sock-&gt;data, *sk2;</span><br><span class="line">	unsigned short snum = 0 /* Stoopid compiler.. this IS ok */;</span><br><span class="line">	int chk_addr_ret;</span><br><span class="line"> </span><br><span class="line">	/* check this error. */</span><br><span class="line">	//在进行地址绑定时，该套接字应该处于关闭状态</span><br><span class="line">	if (sk-&gt;state != TCP_CLOSE)</span><br><span class="line">		return(-EIO);</span><br><span class="line">	//地址长度字段校验</span><br><span class="line">	if(addr_len&lt;sizeof(struct sockaddr_in))</span><br><span class="line">		return -EINVAL;</span><br><span class="line"> </span><br><span class="line">    //非原始套接字类型，绑定前，没有端口号，则绑定端口号</span><br><span class="line">	if(sock-&gt;type != SOCK_RAW)</span><br><span class="line">	&#123;</span><br><span class="line">		if (sk-&gt;num != 0)//从inet_create函数可以看出，非原始套接字类型，端口号是初始化为0的 </span><br><span class="line">			return(-EINVAL);</span><br><span class="line"> </span><br><span class="line">		snum = ntohs(addr-&gt;sin_port);//将地址结构中的端口号转为主机字节顺序</span><br><span class="line"> </span><br><span class="line">		/*</span><br><span class="line">		 * We can&#x27;t just leave the socket bound wherever it is, it might</span><br><span class="line">		 * be bound to a privileged port. However, since there seems to</span><br><span class="line">		 * be a bug here, we will leave it if the port is not privileged.</span><br><span class="line">		 */</span><br><span class="line">		 //如果端口号为0，则自动分配一个</span><br><span class="line">		if (snum == 0) </span><br><span class="line">		&#123;</span><br><span class="line">			snum = get_new_socknum(sk-&gt;prot, 0);//得到一个新的端口号</span><br><span class="line">		&#125;</span><br><span class="line">		//端口号有效性检验，1024以上，超级用户权限</span><br><span class="line">		if (snum &lt; PROT_SOCK &amp;&amp; !suser()) </span><br><span class="line">			return(-EACCES);</span><br><span class="line">	&#125;</span><br><span class="line">	//下面则进行ip地址绑定</span><br><span class="line">	//检查地址是否是一个本地接口地址</span><br><span class="line">	chk_addr_ret = ip_chk_addr(addr-&gt;sin_addr.s_addr);</span><br><span class="line">	//如果指定的地址不是本地地址，并且也不是一个多播地址，则错误返回</span><br><span class="line">	if (addr-&gt;sin_addr.s_addr != 0 &amp;&amp; chk_addr_ret != IS_MYADDR &amp;&amp; chk_addr_ret != IS_MULTICAST)</span><br><span class="line">		return(-EADDRNOTAVAIL);	/* Source address MUST be ours! */</span><br><span class="line">	//如果没有指定地址，则系统自动分配一个本地地址  	</span><br><span class="line">	if (chk_addr_ret || addr-&gt;sin_addr.s_addr == 0)</span><br><span class="line">		sk-&gt;saddr = addr-&gt;sin_addr.s_addr;//本地地址绑定</span><br><span class="line">	</span><br><span class="line">	if(sock-&gt;type != SOCK_RAW)</span><br><span class="line">	&#123;</span><br><span class="line">		/* Make sure we are allowed to bind here. */</span><br><span class="line">		cli();</span><br><span class="line">	</span><br><span class="line">		//for循环主要是检查检查有无冲突的端口号以及本地地址，有冲突，但不允许地址复用，肯定错误退出</span><br><span class="line">		//成功跳出for循环时，已经定位到了哈希表sock_array指定索引的链表的末端</span><br><span class="line">		for(sk2 = sk-&gt;prot-&gt;sock_array[snum &amp; (SOCK_ARRAY_SIZE -1)];</span><br><span class="line">					sk2 != NULL; sk2 = sk2-&gt;next) </span><br><span class="line">		&#123;</span><br><span class="line">		/* should be below! */</span><br><span class="line">			if (sk2-&gt;num != snum) //没有重复，继续搜索下一个</span><br><span class="line">				continue;//除非有重复，否则后面的代码将不会被执行</span><br><span class="line">			if (!sk-&gt;reuse)//端口号重复，如果没有设置地址复用标志，退出</span><br><span class="line">			&#123;</span><br><span class="line">				sti();</span><br><span class="line">				return(-EADDRINUSE);</span><br><span class="line">			&#125;</span><br><span class="line">			</span><br><span class="line">			if (sk2-&gt;num != snum) </span><br><span class="line">				continue;		/* more than one */</span><br><span class="line">			if (sk2-&gt;saddr != sk-&gt;saddr) //地址和端口一个意思</span><br><span class="line">				continue;	/* socket per slot ! -FB */</span><br><span class="line">			//如果状态是LISTEN表明该套接字是一个服务端，服务端不可使用地址复用选项</span><br><span class="line">			if (!sk2-&gt;reuse || sk2-&gt;state==TCP_LISTEN) </span><br><span class="line">			&#123;</span><br><span class="line">				sti();</span><br><span class="line">				return(-EADDRINUSE);</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">		sti();</span><br><span class="line"> </span><br><span class="line">		remove_sock(sk);//将sk sock结构从其之前的表中删除，inet_create中 put_sock，这里remove_sock</span><br><span class="line">		put_sock(snum, sk);//然后根据新分配的端口号插入到新的表中。可以得知系统在维护许多这样的表</span><br><span class="line">		sk-&gt;dummy_th.source = ntohs(sk-&gt;num);//tcp首部，源端口号绑定</span><br><span class="line">		sk-&gt;daddr = 0;//sock结构所代表套接字的远端地址</span><br><span class="line">		sk-&gt;dummy_th.dest = 0;//tcp首部，目的端口号</span><br><span class="line">	&#125;</span><br><span class="line">	return(0);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>inet_bind 函数即为bind函数的最底层实现，该函数实现了本地地址和端口号的绑定，其中还针对上层传过来的地址结构进行校验，检查是否冲突可用。需要清楚的是 sock_array数组，这其实是一个链式哈希表，里面保存的就是各个端口号的sock结构，数组大小小于端口号，所以采用链式哈希表存储。</p>
<p>bind 函数的各层分工很明显，主要就是inet_bind函数了，在注释里说的很明确了，bind 是绑定本地地址，它不负责对端地址，一般用于服务器端，客户端是系统指定的。</p>
<p>一般是服务器端调用这个函数，到了这一步，服务器端套接字绑定了本地地址信息（ip地址和端口号），但是不知道对端（客户端）的地址信息。</p>
<hr>
<p>版权声明：本文为知乎博主「<a href="https://www.zhihu.com/people/linuxwang-xian-sheng">极致Linux内核</a>」的原创文章，遵循CC 4.0 BY-SA版权协议，转载请附上原文出处链接及本声明。</p>
<p>原文链接：<a href="https://zhuanlan.zhihu.com/p/549864166">https://zhuanlan.zhihu.com/p/549864166</a></p>
]]></content>
      <categories>
        <category>linux-doc 网络协议栈</category>
      </categories>
      <tags>
        <tag>Linux</tag>
      </tags>
  </entry>
  <entry>
    <title>Linux内核网络协议栈套接字的绑定、监听、连接和断开</title>
    <url>/2023/01/15/linux-docs/%E7%BD%91%E7%BB%9C%E5%8D%8F%E8%AE%AE%E6%A0%88/Linux%E5%86%85%E6%A0%B8%E7%BD%91%E7%BB%9C%E5%8D%8F%E8%AE%AE%E6%A0%88%E5%A5%97%E6%8E%A5%E5%AD%97%E7%9A%84%E7%BB%91%E5%AE%9A%E3%80%81%E7%9B%91%E5%90%AC%E3%80%81%E8%BF%9E%E6%8E%A5%E5%92%8C%E6%96%AD%E5%BC%80/</url>
    <content><![CDATA[<h2 id="1、套接字的绑定"><a href="#1、套接字的绑定" class="headerlink" title="1、套接字的绑定"></a><strong>1、套接字的绑定</strong></h2><p>创建完套接字服务器端会在应用层使用bind函数进行套接字的绑定，这时会产生系统调用，sys_bind内核函数进行套接字。</p>
<p>系统调用函数的具体实现</p>
<figure class="highlight text"><table><tr><td class="code"><pre><span class="line">SYSCALL_DEFINE3(bind, int, fd, struct sockaddr __user *, umyaddr, int, addrlen)</span><br><span class="line">&#123;</span><br><span class="line">	struct socket *sock;</span><br><span class="line">	struct sockaddr_storage address;</span><br><span class="line">	int err, fput_needed;</span><br><span class="line"></span><br><span class="line">	sock = sockfd_lookup_light(fd, &amp;err, &amp;fput_needed);</span><br><span class="line">	if (sock) &#123;</span><br><span class="line">		err = move_addr_to_kernel(umyaddr, addrlen, (struct sockaddr *)&amp;address);</span><br><span class="line">		if (err &gt;= 0) &#123;</span><br><span class="line">			err = security_socket_bind(sock,</span><br><span class="line">						   (struct sockaddr *)&amp;address,</span><br><span class="line">						   addrlen);</span><br><span class="line">			if (!err)</span><br><span class="line">				err = sock-&gt;ops-&gt;bind(sock,</span><br><span class="line">						      (struct sockaddr *)</span><br><span class="line">						      &amp;address, addrlen);</span><br><span class="line">		&#125;</span><br><span class="line">		fput_light(sock-&gt;file, fput_needed);</span><br><span class="line">	&#125;</span><br><span class="line">	return err;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>首先调用函数sockfd_lookup_light()函数通过文件描述符来查找对应的套接字sock。</p>
<figure class="highlight text"><table><tr><td class="code"><pre><span class="line">static struct socket *sockfd_lookup_light(int fd, int *err, int *fput_needed)</span><br><span class="line">&#123;</span><br><span class="line">	struct file *file;</span><br><span class="line">	struct socket *sock;</span><br><span class="line"></span><br><span class="line">	*err = -EBADF;</span><br><span class="line">	file = fget_light(fd, fput_needed);</span><br><span class="line">	if (file) &#123;</span><br><span class="line">		sock = sock_from_file(file, err);</span><br><span class="line">		if (sock)</span><br><span class="line">			return sock;</span><br><span class="line">		fput_light(file, *fput_needed);</span><br><span class="line">	&#125;</span><br><span class="line">	return NULL;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>上面函数中先调用fget_light函数通过文件描述符返回对应的文件结构，然后调用函数sock_from_file函数返回该文件对应的套接字结构体地址，它存储在file-&gt;private_data属性中。</p>
<p>再回到sys_bind函数，在返回了对应的套接字结构之后，调用move_addr_to_kernel将用户地址空间的socket拷贝到内核空间。</p>
<p>然后调用INET协议族的操作集中bind函数inet_bind函数将socket地址（内核空间）和socket绑定。</p>
<figure class="highlight text"><table><tr><td class="code"><pre><span class="line">int inet_bind(struct socket *sock, struct sockaddr *uaddr, int addr_len)</span><br><span class="line">&#123;</span><br><span class="line">	struct sockaddr_in *addr = (struct sockaddr_in *)uaddr;</span><br><span class="line">	struct sock *sk = sock-&gt;sk;</span><br><span class="line">	struct inet_sock *inet = inet_sk(sk);</span><br><span class="line">	unsigned short snum;</span><br><span class="line">	int chk_addr_ret;</span><br><span class="line">	int err;</span><br><span class="line"></span><br><span class="line">	//RAW类型套接字若有自己的bind函数，则使用之</span><br><span class="line">	if (sk-&gt;sk_prot-&gt;bind) &#123;</span><br><span class="line">		err = sk-&gt;sk_prot-&gt;bind(sk, uaddr, addr_len);</span><br><span class="line">		goto out;</span><br><span class="line">	&#125;</span><br><span class="line">	err = -EINVAL;</span><br><span class="line">	.....................</span><br><span class="line">        //地址合法性检查</span><br><span class="line">	chk_addr_ret = inet_addr_type(sock_net(sk), addr-&gt;sin_addr.s_addr);</span><br><span class="line"></span><br><span class="line">	/* Not specified by any standard per-se, however it breaks too</span><br><span class="line">	 * many applications when removed.  It is unfortunate since</span><br><span class="line">	 * allowing applications to make a non-local bind solves</span><br><span class="line">	 * several problems with systems using dynamic addressing.</span><br><span class="line">	 * (ie. your servers still start up even if your ISDN link</span><br><span class="line">	 *  is temporarily down)</span><br><span class="line">	 */</span><br><span class="line">	err = -EADDRNOTAVAIL;</span><br><span class="line">	if (!sysctl_ip_nonlocal_bind &amp;&amp;</span><br><span class="line">	    !(inet-&gt;freebind || inet-&gt;transparent) &amp;&amp;</span><br><span class="line">	    addr-&gt;sin_addr.s_addr != htonl(INADDR_ANY) &amp;&amp;</span><br><span class="line">	    chk_addr_ret != RTN_LOCAL &amp;&amp;</span><br><span class="line">	    chk_addr_ret != RTN_MULTICAST &amp;&amp;</span><br><span class="line">	    chk_addr_ret != RTN_BROADCAST)</span><br><span class="line">		goto out;</span><br><span class="line"></span><br><span class="line">	snum = ntohs(addr-&gt;sin_port);</span><br><span class="line">	err = -EACCES;</span><br><span class="line">	if (snum &amp;&amp; snum &lt; PROT_SOCK &amp;&amp; !capable(CAP_NET_BIND_SERVICE))</span><br><span class="line">		goto out;</span><br><span class="line"></span><br><span class="line">	/*      We keep a pair of addresses. rcv_saddr is the one</span><br><span class="line">	 *      used by hash lookups, and saddr is used for transmit.</span><br><span class="line">	 *</span><br><span class="line">	 *      In the BSD API these are the same except where it</span><br><span class="line">	 *      would be illegal to use them (multicast/broadcast) in</span><br><span class="line">	 *      which case the sending device address is used.</span><br><span class="line">	 */</span><br><span class="line">	lock_sock(sk);</span><br><span class="line"></span><br><span class="line">	/* Check these errors (active socket, double bind). */</span><br><span class="line">	err = -EINVAL;</span><br><span class="line">	if (sk-&gt;sk_state != TCP_CLOSE || inet-&gt;inet_num)//如果sk的状态是CLOSE或者本地端口已经被绑定</span><br><span class="line">		goto out_release_sock;</span><br><span class="line"></span><br><span class="line">	inet-&gt;inet_rcv_saddr = inet-&gt;inet_saddr = addr-&gt;sin_addr.s_addr;//设置源地址</span><br><span class="line">	if (chk_addr_ret == RTN_MULTICAST || chk_addr_ret == RTN_BROADCAST)</span><br><span class="line">		inet-&gt;inet_saddr = 0;  /* Use device */</span><br><span class="line"></span><br><span class="line">	/* Make sure we are allowed to bind here. */</span><br><span class="line">	if (sk-&gt;sk_prot-&gt;get_port(sk, snum)) &#123;</span><br><span class="line">		inet-&gt;inet_saddr = inet-&gt;inet_rcv_saddr = 0;</span><br><span class="line">		err = -EADDRINUSE;</span><br><span class="line">		goto out_release_sock;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	if (inet-&gt;inet_rcv_saddr)</span><br><span class="line">		sk-&gt;sk_userlocks |= SOCK_BINDADDR_LOCK;</span><br><span class="line">	if (snum)</span><br><span class="line">		sk-&gt;sk_userlocks |= SOCK_BINDPORT_LOCK;</span><br><span class="line">	inet-&gt;inet_sport = htons(inet-&gt;inet_num);//设置源端口号，标明该端口已经被占用</span><br><span class="line">	inet-&gt;inet_daddr = 0;</span><br><span class="line">	inet-&gt;inet_dport = 0;</span><br><span class="line">	sk_dst_reset(sk);</span><br><span class="line">	err = 0;</span><br><span class="line">out_release_sock:</span><br><span class="line">	release_sock(sk);</span><br><span class="line">out:</span><br><span class="line">	return err;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这样套接字绑定结束。</p>
<h2 id="2、套接字的监听"><a href="#2、套接字的监听" class="headerlink" title="2、套接字的监听"></a><strong>2、套接字的监听</strong></h2><figure class="highlight text"><table><tr><td class="code"><pre><span class="line">SYSCALL_DEFINE2(listen, int, fd, int, backlog)</span><br><span class="line">&#123;</span><br><span class="line">	struct socket *sock;</span><br><span class="line">	int err, fput_needed;</span><br><span class="line">	int somaxconn;</span><br><span class="line"></span><br><span class="line">	sock = sockfd_lookup_light(fd, &amp;err, &amp;fput_needed);</span><br><span class="line">	if (sock) &#123;</span><br><span class="line">		......................</span><br><span class="line"></span><br><span class="line">		err = security_socket_listen(sock, backlog);</span><br><span class="line">		if (!err)</span><br><span class="line">			err = sock-&gt;ops-&gt;listen(sock, backlog);</span><br><span class="line"></span><br><span class="line">		fput_light(sock-&gt;file, fput_needed);</span><br><span class="line">	&#125;</span><br><span class="line">	return err;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>该函数先通过文件描述符查找到对应的套接字结构，然后调用inet_listen函数对将套接字sk的状态设置为TCP_LISTEN。</p>
<figure class="highlight text"><table><tr><td class="code"><pre><span class="line">int inet_listen(struct socket *sock, int backlog)</span><br><span class="line">&#123;</span><br><span class="line">	struct sock *sk = sock-&gt;sk;</span><br><span class="line">	unsigned char old_state;</span><br><span class="line">	int err;</span><br><span class="line">	lock_sock(sk);</span><br><span class="line"></span><br><span class="line">	err = -EINVAL;</span><br><span class="line">	if (sock-&gt;state != SS_UNCONNECTED || sock-&gt;type != SOCK_STREAM)</span><br><span class="line">		goto out;</span><br><span class="line"></span><br><span class="line">	old_state = sk-&gt;sk_state;</span><br><span class="line">	if (!((1 &lt;&lt; old_state) &amp; (TCPF_CLOSE | TCPF_LISTEN)))</span><br><span class="line">		goto out;</span><br><span class="line"></span><br><span class="line">	if (old_state != TCP_LISTEN) &#123;</span><br><span class="line">		err = inet_csk_listen_start(sk, backlog);//该函数将sk的状态设置为TCP_LISTEN</span><br><span class="line">		if (err)</span><br><span class="line">			goto out;</span><br><span class="line">	&#125;</span><br><span class="line">	sk-&gt;sk_max_ack_backlog = backlog;</span><br><span class="line">	err = 0;</span><br><span class="line">out:</span><br><span class="line">	release_sock(sk);</span><br><span class="line">	return err;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="3、套接字的连接和接受连接"><a href="#3、套接字的连接和接受连接" class="headerlink" title="3、套接字的连接和接受连接"></a><strong>3、套接字的连接和接受连接</strong></h2><h3 id="3-1申请连接"><a href="#3-1申请连接" class="headerlink" title="3.1申请连接"></a><strong>3.1申请连接</strong></h3><figure class="highlight text"><table><tr><td class="code"><pre><span class="line">SYSCALL_DEFINE3(connect, int, fd, struct sockaddr __user *, uservaddr,</span><br><span class="line">		int, addrlen)</span><br><span class="line">&#123;</span><br><span class="line">	struct socket *sock;</span><br><span class="line">	struct sockaddr_storage address;</span><br><span class="line">	int err, fput_needed;</span><br><span class="line"></span><br><span class="line">	sock = sockfd_lookup_light(fd, &amp;err, &amp;fput_needed);</span><br><span class="line">	if (!sock)</span><br><span class="line">		goto out;</span><br><span class="line">	err = move_addr_to_kernel(uservaddr, addrlen, (struct sockaddr *)&amp;address);</span><br><span class="line">	if (err &lt; 0)</span><br><span class="line">		goto out_put;</span><br><span class="line"></span><br><span class="line">	err =</span><br><span class="line">	    security_socket_connect(sock, (struct sockaddr *)&amp;address, addrlen);</span><br><span class="line">	if (err)</span><br><span class="line">		goto out_put;</span><br><span class="line"></span><br><span class="line">	err = sock-&gt;ops-&gt;connect(sock, (struct sockaddr *)&amp;address, addrlen,</span><br><span class="line">				 sock-&gt;file-&gt;f_flags);</span><br><span class="line">out_put:</span><br><span class="line">	fput_light(sock-&gt;file, fput_needed);</span><br><span class="line">out:</span><br><span class="line">	return err;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>还是先调用sockfd_lookup_light函数获得socket指针，然后将用户空间地址移到内核空间，然后调用函数inet_stream_connect函数。</p>
<figure class="highlight text"><table><tr><td class="code"><pre><span class="line">int inet_stream_connect(struct socket *sock, struct sockaddr *uaddr,</span><br><span class="line">			int addr_len, int flags)</span><br><span class="line">&#123;</span><br><span class="line">	struct sock *sk = sock-&gt;sk;</span><br><span class="line">	int err;</span><br><span class="line">	long timeo;</span><br><span class="line"></span><br><span class="line">	if (addr_len &lt; sizeof(uaddr-&gt;sa_family))</span><br><span class="line">		return -EINVAL;</span><br><span class="line"></span><br><span class="line">	lock_sock(sk);</span><br><span class="line"></span><br><span class="line">	......................</span><br><span class="line"></span><br><span class="line">	switch (sock-&gt;state) &#123;</span><br><span class="line">	default:</span><br><span class="line">		err = -EINVAL;</span><br><span class="line">		goto out;</span><br><span class="line">	case SS_CONNECTED:</span><br><span class="line">		err = -EISCONN;</span><br><span class="line">		goto out;</span><br><span class="line">	case SS_CONNECTING:</span><br><span class="line">		err = -EALREADY;</span><br><span class="line">		/* Fall out of switch with err, set for this state */</span><br><span class="line">		break;</span><br><span class="line">	case SS_UNCONNECTED:</span><br><span class="line">		err = -EISCONN;</span><br><span class="line">		if (sk-&gt;sk_state != TCP_CLOSE)</span><br><span class="line">			goto out;</span><br><span class="line"></span><br><span class="line">		err = sk-&gt;sk_prot-&gt;connect(sk, uaddr, addr_len);</span><br><span class="line">		if (err &lt; 0)</span><br><span class="line">			goto out;</span><br><span class="line"></span><br><span class="line">		sock-&gt;state = SS_CONNECTING;</span><br><span class="line"></span><br><span class="line">		err = -EINPROGRESS;</span><br><span class="line">		break;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	timeo = sock_sndtimeo(sk, flags &amp; O_NONBLOCK);</span><br><span class="line"></span><br><span class="line">	if ((1 &lt;&lt; sk-&gt;sk_state) &amp; (TCPF_SYN_SENT | TCPF_SYN_RECV)) &#123;</span><br><span class="line">		/* Error code is set above */</span><br><span class="line">		if (!timeo || !inet_wait_for_connect(sk, timeo))</span><br><span class="line">			goto out;</span><br><span class="line"></span><br><span class="line">		err = sock_intr_errno(timeo);</span><br><span class="line">		if (signal_pending(current))</span><br><span class="line">			goto out;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	/* Connection was closed by RST, timeout, ICMP error</span><br><span class="line">	 * or another process disconnected us.</span><br><span class="line">	 */</span><br><span class="line">	if (sk-&gt;sk_state == TCP_CLOSE)</span><br><span class="line">		goto sock_error;</span><br><span class="line"></span><br><span class="line">	sock-&gt;state = SS_CONNECTED;</span><br><span class="line">	err = 0;</span><br><span class="line">out:</span><br><span class="line">	release_sock(sk);</span><br><span class="line">	return err;</span><br><span class="line"></span><br><span class="line">sock_error:</span><br><span class="line">	err = sock_error(sk) ? : -ECONNABORTED;</span><br><span class="line">	sock-&gt;state = SS_UNCONNECTED;</span><br><span class="line">	if (sk-&gt;sk_prot-&gt;disconnect(sk, flags))</span><br><span class="line">		sock-&gt;state = SS_DISCONNECTING;</span><br><span class="line">	goto out;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>调用函数tcp_v4_connect函数后然后将sock的状态置SS_CONNECTING。</p>
<figure class="highlight text"><table><tr><td class="code"><pre><span class="line">int tcp_v4_connect(struct sock *sk, struct sockaddr *uaddr, int addr_len)</span><br><span class="line">&#123;</span><br><span class="line">	struct sockaddr_in *usin = (struct sockaddr_in *)uaddr;</span><br><span class="line">	struct inet_sock *inet = inet_sk(sk);</span><br><span class="line">	struct tcp_sock *tp = tcp_sk(sk);</span><br><span class="line">	__be16 orig_sport, orig_dport;</span><br><span class="line">	__be32 daddr, nexthop;</span><br><span class="line">	struct flowi4 *fl4;</span><br><span class="line">	struct rtable *rt;</span><br><span class="line">	int err;</span><br><span class="line">	struct ip_options_rcu *inet_opt;</span><br><span class="line">        //合法性检查</span><br><span class="line">	if (addr_len &lt; sizeof(struct sockaddr_in))</span><br><span class="line">		return -EINVAL;</span><br><span class="line"></span><br><span class="line">	if (usin-&gt;sin_family != AF_INET)</span><br><span class="line">		return -EAFNOSUPPORT;</span><br><span class="line">        //记录吓一跳地址和目的地址</span><br><span class="line">	nexthop = daddr = usin-&gt;sin_addr.s_addr;</span><br><span class="line">	inet_opt = rcu_dereference_protected(inet-&gt;inet_opt,</span><br><span class="line">					     sock_owned_by_user(sk));</span><br><span class="line">	if (inet_opt &amp;&amp; inet_opt-&gt;opt.srr) &#123;</span><br><span class="line">		if (!daddr)</span><br><span class="line">			return -EINVAL;</span><br><span class="line">		nexthop = inet_opt-&gt;opt.faddr;</span><br><span class="line">	&#125;</span><br><span class="line">        //本地端口和目的端口</span><br><span class="line">	orig_sport = inet-&gt;inet_sport;</span><br><span class="line">	orig_dport = usin-&gt;sin_port;</span><br><span class="line">	fl4 = &amp;inet-&gt;cork.fl.u.ip4;</span><br><span class="line">	rt = ip_route_connect(fl4, nexthop, inet-&gt;inet_saddr,</span><br><span class="line">			      RT_CONN_FLAGS(sk), sk-&gt;sk_bound_dev_if,</span><br><span class="line">			      IPPROTO_TCP,</span><br><span class="line">			      orig_sport, orig_dport, sk, true);//维护路由表</span><br><span class="line">	if (IS_ERR(rt)) &#123;</span><br><span class="line">		err = PTR_ERR(rt);</span><br><span class="line">		if (err == -ENETUNREACH)</span><br><span class="line">			IP_INC_STATS_BH(sock_net(sk), IPSTATS_MIB_OUTNOROUTES);</span><br><span class="line">		return err;</span><br><span class="line">	&#125;</span><br><span class="line">        //处理多播或广播</span><br><span class="line">	if (rt-&gt;rt_flags &amp; (RTCF_MULTICAST | RTCF_BROADCAST)) &#123;</span><br><span class="line">		ip_rt_put(rt);</span><br><span class="line">		return -ENETUNREACH;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	if (!inet_opt || !inet_opt-&gt;opt.srr)</span><br><span class="line">		daddr = fl4-&gt;daddr;</span><br><span class="line"></span><br><span class="line">	if (!inet-&gt;inet_saddr)</span><br><span class="line">		inet-&gt;inet_saddr = fl4-&gt;saddr;</span><br><span class="line">	inet-&gt;inet_rcv_saddr = inet-&gt;inet_saddr;</span><br><span class="line"></span><br><span class="line">	if (tp-&gt;rx_opt.ts_recent_stamp &amp;&amp; inet-&gt;inet_daddr != daddr) &#123;</span><br><span class="line">		/* Reset inherited state */</span><br><span class="line">		tp-&gt;rx_opt.ts_recent	   = 0;</span><br><span class="line">		tp-&gt;rx_opt.ts_recent_stamp = 0;</span><br><span class="line">		tp-&gt;write_seq		   = 0;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	if (tcp_death_row.sysctl_tw_recycle &amp;&amp;</span><br><span class="line">	    !tp-&gt;rx_opt.ts_recent_stamp &amp;&amp; fl4-&gt;daddr == daddr) &#123;</span><br><span class="line">		struct inet_peer *peer = rt_get_peer(rt, fl4-&gt;daddr);</span><br><span class="line">		/*</span><br><span class="line">		 * VJ&#x27;s idea. We save last timestamp seen from</span><br><span class="line">		 * the destination in peer table, when entering state</span><br><span class="line">		 * TIME-WAIT * and initialize rx_opt.ts_recent from it,</span><br><span class="line">		 * when trying new connection.</span><br><span class="line">		 */</span><br><span class="line">		if (peer) &#123;</span><br><span class="line">			inet_peer_refcheck(peer);</span><br><span class="line">			if ((u32)get_seconds() - peer-&gt;tcp_ts_stamp &lt;= TCP_PAWS_MSL) &#123;</span><br><span class="line">				tp-&gt;rx_opt.ts_recent_stamp = peer-&gt;tcp_ts_stamp;</span><br><span class="line">				tp-&gt;rx_opt.ts_recent = peer-&gt;tcp_ts;</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">        //设置套接字中的目的端口和目的地址</span><br><span class="line">	inet-&gt;inet_dport = usin-&gt;sin_port;</span><br><span class="line">	inet-&gt;inet_daddr = daddr;</span><br><span class="line"></span><br><span class="line">	inet_csk(sk)-&gt;icsk_ext_hdr_len = 0;</span><br><span class="line">	if (inet_opt)</span><br><span class="line">		inet_csk(sk)-&gt;icsk_ext_hdr_len = inet_opt-&gt;opt.optlen;</span><br><span class="line"></span><br><span class="line">	tp-&gt;rx_opt.mss_clamp = TCP_MSS_DEFAULT;</span><br><span class="line"></span><br><span class="line">	//设置sk的状态为TCP_SYN_SENT</span><br><span class="line">	tcp_set_state(sk, TCP_SYN_SENT);</span><br><span class="line">	err = inet_hash_connect(&amp;tcp_death_row, sk);</span><br><span class="line">	if (err)</span><br><span class="line">		goto failure;</span><br><span class="line"></span><br><span class="line">	rt = ip_route_newports(fl4, rt, orig_sport, orig_dport,</span><br><span class="line">			       inet-&gt;inet_sport, inet-&gt;inet_dport, sk);</span><br><span class="line">	if (IS_ERR(rt)) &#123;</span><br><span class="line">		err = PTR_ERR(rt);</span><br><span class="line">		rt = NULL;</span><br><span class="line">		goto failure;</span><br><span class="line">	&#125;</span><br><span class="line">	/* OK, now commit destination to socket.  */</span><br><span class="line">	sk-&gt;sk_gso_type = SKB_GSO_TCPV4;</span><br><span class="line">	sk_setup_caps(sk, &amp;rt-&gt;dst);</span><br><span class="line"></span><br><span class="line">	if (!tp-&gt;write_seq)</span><br><span class="line">		tp-&gt;write_seq = secure_tcp_sequence_number(inet-&gt;inet_saddr,</span><br><span class="line">							   inet-&gt;inet_daddr,</span><br><span class="line">							   inet-&gt;inet_sport,</span><br><span class="line">							   usin-&gt;sin_port);</span><br><span class="line"></span><br><span class="line">	inet-&gt;inet_id = tp-&gt;write_seq ^ jiffies;</span><br><span class="line"></span><br><span class="line">	err = tcp_connect(sk);//创建SYN报文并发送，该函数实现过程挺复杂，需进行TCP连接初始化以及发送</span><br><span class="line">	rt = NULL;</span><br><span class="line">	if (err)</span><br><span class="line">		goto failure;</span><br><span class="line"></span><br><span class="line">	return 0;</span><br><span class="line"></span><br><span class="line">failure:</span><br><span class="line">	//失败处理</span><br><span class="line">	tcp_set_state(sk, TCP_CLOSE);</span><br><span class="line">	ip_rt_put(rt);</span><br><span class="line">	sk-&gt;sk_route_caps = 0;</span><br><span class="line">	inet-&gt;inet_dport = 0;</span><br><span class="line">	return err;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="3-2接受连接"><a href="#3-2接受连接" class="headerlink" title="3.2接受连接"></a><strong>3.2接受连接</strong></h3><p>系统调用函数sys_accept实现如下：</p>
<figure class="highlight text"><table><tr><td class="code"><pre><span class="line">SYSCALL_DEFINE3(accept, int, fd, struct sockaddr __user *, upeer_sockaddr,</span><br><span class="line">		int __user *, upeer_addrlen)</span><br><span class="line">&#123;</span><br><span class="line">	return sys_accept4(fd, upeer_sockaddr, upeer_addrlen, 0);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>调用系统调用sys_accept4</p>
<figure class="highlight text"><table><tr><td class="code"><pre><span class="line">SYSCALL_DEFINE4(accept4, int, fd, struct sockaddr __user *, upeer_sockaddr,</span><br><span class="line">		int __user *, upeer_addrlen, int, flags)</span><br><span class="line">&#123;</span><br><span class="line">	struct socket *sock, *newsock;</span><br><span class="line">	struct file *newfile;</span><br><span class="line">	int err, len, newfd, fput_needed;</span><br><span class="line">	struct sockaddr_storage address;</span><br><span class="line">	.......................</span><br><span class="line">	sock = sockfd_lookup_light(fd, &amp;err, &amp;fput_needed);//根据fd获得一个socket</span><br><span class="line">	if (!sock)</span><br><span class="line">		goto out;</span><br><span class="line"></span><br><span class="line">	err = -ENFILE;</span><br><span class="line">	newsock = sock_alloc();//重新创建一个新的socket</span><br><span class="line">	if (!newsock)</span><br><span class="line">		goto out_put;</span><br><span class="line">	//复制套接字部分属性</span><br><span class="line">	newsock-&gt;type = sock-&gt;type;</span><br><span class="line">	newsock-&gt;ops = sock-&gt;ops;</span><br><span class="line">	__module_get(newsock-&gt;ops-&gt;owner);</span><br><span class="line">	//给新建的socket分配文件结构，并返回新的文件描述符</span><br><span class="line">	newfd = sock_alloc_file(newsock, &amp;newfile, flags);</span><br><span class="line">	if (unlikely(newfd &lt; 0)) &#123;</span><br><span class="line">		err = newfd;</span><br><span class="line">		sock_release(newsock);</span><br><span class="line">		goto out_put;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	err = security_socket_accept(sock, newsock);</span><br><span class="line">	if (err)</span><br><span class="line">		goto out_fd;</span><br><span class="line">	//调用inet_accept接受连接</span><br><span class="line">	err = sock-&gt;ops-&gt;accept(sock, newsock, sock-&gt;file-&gt;f_flags);</span><br><span class="line">	if (err &lt; 0)</span><br><span class="line">		goto out_fd;</span><br><span class="line"></span><br><span class="line">	if (upeer_sockaddr) &#123;//将地址信息从内核移到用户空间</span><br><span class="line">		if (newsock-&gt;ops-&gt;getname(newsock, (struct sockaddr *)&amp;address,</span><br><span class="line">					  &amp;len, 2) &lt; 0) &#123;</span><br><span class="line">			err = -ECONNABORTED;</span><br><span class="line">			goto out_fd;</span><br><span class="line">		&#125;</span><br><span class="line">		err = move_addr_to_user((struct sockaddr *)&amp;address,</span><br><span class="line">					len, upeer_sockaddr, upeer_addrlen);</span><br><span class="line">		if (err &lt; 0)</span><br><span class="line">			goto out_fd;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	/* File flags are not inherited via accept() unlike another OSes. */</span><br><span class="line">	//安装文件描述符</span><br><span class="line">	fd_install(newfd, newfile);</span><br><span class="line">	err = newfd;</span><br><span class="line"></span><br><span class="line">out_put:</span><br><span class="line">	fput_light(sock-&gt;file, fput_needed);</span><br><span class="line">out:</span><br><span class="line">	return err;</span><br><span class="line">out_fd:</span><br><span class="line">	fput(newfile);</span><br><span class="line">	put_unused_fd(newfd);</span><br><span class="line">	goto out_put;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>该函数创建一个新的套接字，设置客户端连接并唤醒客户端并返回一个新的文件描述符fd。</p>
<p>下面是inet_accept函数的实现</p>
<figure class="highlight text"><table><tr><td class="code"><pre><span class="line">int inet_accept(struct socket *sock, struct socket *newsock, int flags)</span><br><span class="line">&#123;</span><br><span class="line">	struct sock *sk1 = sock-&gt;sk;</span><br><span class="line">	int err = -EINVAL;</span><br><span class="line">	struct sock *sk2 = sk1-&gt;sk_prot-&gt;accept(sk1, flags, &amp;err);//调用inet_csk_accept函数从队列icsk_accept_queue取出已经连接的套接字</span><br><span class="line"></span><br><span class="line">	if (!sk2)</span><br><span class="line">		goto do_err;</span><br><span class="line"></span><br><span class="line">	lock_sock(sk2);</span><br><span class="line"></span><br><span class="line">	sock_rps_record_flow(sk2);</span><br><span class="line">	WARN_ON(!((1 &lt;&lt; sk2-&gt;sk_state) &amp;</span><br><span class="line">		  (TCPF_ESTABLISHED | TCPF_CLOSE_WAIT | TCPF_CLOSE)));</span><br><span class="line"></span><br><span class="line">	sock_graft(sk2, newsock);</span><br><span class="line"></span><br><span class="line">	newsock-&gt;state = SS_CONNECTED;//设置套接字状态</span><br><span class="line">	err = 0;</span><br><span class="line">	release_sock(sk2);</span><br><span class="line">do_err:</span><br><span class="line">	return err;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="4、关闭连接"><a href="#4、关闭连接" class="headerlink" title="4、关闭连接"></a><strong>4、关闭连接</strong></h2><p>关闭一个socket连接，系统调用sys_shutdown</p>
<figure class="highlight text"><table><tr><td class="code"><pre><span class="line">SYSCALL_DEFINE2(shutdown, int, fd, int, how)</span><br><span class="line">&#123;</span><br><span class="line">	int err, fput_needed;</span><br><span class="line">	struct socket *sock;</span><br><span class="line"></span><br><span class="line">	sock = sockfd_lookup_light(fd, &amp;err, &amp;fput_needed);</span><br><span class="line">	if (sock != NULL) &#123;</span><br><span class="line">		err = security_socket_shutdown(sock, how);</span><br><span class="line">		if (!err)</span><br><span class="line">			err = sock-&gt;ops-&gt;shutdown(sock, how);</span><br><span class="line">		fput_light(sock-&gt;file, fput_needed);</span><br><span class="line">	&#125;</span><br><span class="line">	return err;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>函数最后调用inet_shutdown关闭套接字</p>
<figure class="highlight text"><table><tr><td class="code"><pre><span class="line">int inet_shutdown(struct socket *sock, int how)</span><br><span class="line">&#123;</span><br><span class="line">	struct sock *sk = sock-&gt;sk;</span><br><span class="line">	int err = 0;</span><br><span class="line">	.................</span><br><span class="line">	lock_sock(sk);</span><br><span class="line">	if (sock-&gt;state == SS_CONNECTING) &#123;</span><br><span class="line">		if ((1 &lt;&lt; sk-&gt;sk_state) &amp;</span><br><span class="line">		    (TCPF_SYN_SENT | TCPF_SYN_RECV | TCPF_CLOSE))</span><br><span class="line">			sock-&gt;state = SS_DISCONNECTING;</span><br><span class="line">		else</span><br><span class="line">			sock-&gt;state = SS_CONNECTED;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	switch (sk-&gt;sk_state) &#123;</span><br><span class="line">	case TCP_CLOSE:</span><br><span class="line">		err = -ENOTCONN;</span><br><span class="line">	default:</span><br><span class="line">		sk-&gt;sk_shutdown |= how;</span><br><span class="line">		if (sk-&gt;sk_prot-&gt;shutdown)</span><br><span class="line">			sk-&gt;sk_prot-&gt;shutdown(sk, how);//调用tcp_shutdown强制关闭连接</span><br><span class="line">		break;</span><br><span class="line"></span><br><span class="line">	/* Remaining two branches are temporary solution for missing</span><br><span class="line">	 * close() in multithreaded environment. It is _not_ a good idea,</span><br><span class="line">	 * but we have no choice until close() is repaired at VFS level.</span><br><span class="line">	 */</span><br><span class="line">	case TCP_LISTEN:</span><br><span class="line">		if (!(how &amp; RCV_SHUTDOWN))</span><br><span class="line">			break;</span><br><span class="line">		/* Fall through */</span><br><span class="line">	case TCP_SYN_SENT:</span><br><span class="line">		err = sk-&gt;sk_prot-&gt;disconnect(sk, O_NONBLOCK);//调用tcp_disconnect断开连接</span><br><span class="line">		sock-&gt;state = err ? SS_DISCONNECTING : SS_UNCONNECTED;//设置套接字状态</span><br><span class="line">		break;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	sk-&gt;sk_state_change(sk);</span><br><span class="line">	release_sock(sk);</span><br><span class="line">	return err;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>后面会详细分析TCP协议的发送和接收过程。</p>
<hr>
<p>版权声明：本文为知乎博主「<a href="https://www.zhihu.com/people/linuxwang-xian-sheng">极致Linux内核</a>」的原创文章，遵循CC 4.0 BY-SA版权协议，转载请附上原文出处链接及本声明。</p>
<p>原文链接：<a href="https://zhuanlan.zhihu.com/p/549563171">https://zhuanlan.zhihu.com/p/549563171</a></p>
]]></content>
      <categories>
        <category>linux-doc 网络协议栈</category>
      </categories>
      <tags>
        <tag>Linux</tag>
      </tags>
  </entry>
  <entry>
    <title>Linux内核网络协议栈数据包发送</title>
    <url>/2023/01/15/linux-docs/%E7%BD%91%E7%BB%9C%E5%8D%8F%E8%AE%AE%E6%A0%88/Linux%E5%86%85%E6%A0%B8%E7%BD%91%E7%BB%9C%E5%8D%8F%E8%AE%AE%E6%A0%88%E6%95%B0%E6%8D%AE%E5%8C%85%E5%8F%91%E9%80%81/</url>
    <content><![CDATA[<p>由于在connect函数中涉及数据包的发送与接收问题，事实上，发送与接收函数不限于connect函数，所以这里单独剖析。</p>
<p>承前文继续剖析 connect 函数，数据包的发送和接收在 ip_queue_xmit 函数和 release_sock 函数中实现。本文着重分析 ip_queue_xmit 函数，下篇将补充分析 connect 函数剩下的部分。</p>
<p>值得注意的是：这些函数是数据包发送函数，在数据传输阶段，基本上都会调用该函数，因为connect涉及该函数，就放在这里介绍了，不意味着这个函数只属于connect下层函数。</p>
<h2 id="1、网络层——ip-queue-xmit-函数"><a href="#1、网络层——ip-queue-xmit-函数" class="headerlink" title="1、网络层——ip_queue_xmit 函数"></a>1、网络层——ip_queue_xmit 函数</h2><figure class="highlight text"><table><tr><td class="code"><pre><span class="line">/*</span><br><span class="line"> * Queues a packet to be sent, and starts the transmitter</span><br><span class="line"> * if necessary.  if free = 1 then we free the block after</span><br><span class="line"> * transmit, otherwise we don&#x27;t. If free==2 we not only</span><br><span class="line"> * free the block but also don&#x27;t assign a new ip seq number.</span><br><span class="line"> * This routine also needs to put in the total length,</span><br><span class="line"> * and compute the checksum</span><br><span class="line"> */</span><br><span class="line"> //数据包发送函数</span><br><span class="line"> //sk:被发送数据包对应的套接字；dev:发送数据包的网络设备</span><br><span class="line"> //skb:被发送的数据包         ；flags:是否对数据包进行缓存以便于此后的超时重发</span><br><span class="line">void ip_queue_xmit(struct sock *sk, struct device *dev,</span><br><span class="line">	      struct sk_buff *skb, int free)</span><br><span class="line">&#123;</span><br><span class="line">	struct iphdr *iph;</span><br><span class="line">	unsigned char *ptr;</span><br><span class="line"> </span><br><span class="line">	/* Sanity check */</span><br><span class="line">	//发送设备检查</span><br><span class="line">	if (dev == NULL)</span><br><span class="line">	&#123;</span><br><span class="line">		printk(&quot;IP: ip_queue_xmit dev = NULL\n&quot;);</span><br><span class="line">		return;</span><br><span class="line">	&#125;</span><br><span class="line"> </span><br><span class="line">	IS_SKB(skb);//数据包合法性检查</span><br><span class="line"> </span><br><span class="line">	/*</span><br><span class="line">	 *	Do some book-keeping in the packet for later</span><br><span class="line">	 */</span><br><span class="line"> </span><br><span class="line"> </span><br><span class="line">	skb-&gt;dev = dev;</span><br><span class="line">	skb-&gt;when = jiffies;//重置数据包的发送时间，只有一个定时器，每次发数据包时，都要重新设置</span><br><span class="line"> </span><br><span class="line">	/*</span><br><span class="line">	 *	Find the IP header and set the length. This is bad</span><br><span class="line">	 *	but once we get the skb data handling code in the</span><br><span class="line">	 *	hardware will push its header sensibly and we will</span><br><span class="line">	 *	set skb-&gt;ip_hdr to avoid this mess and the fixed</span><br><span class="line">	 *	header length problem</span><br><span class="line">	 */</span><br><span class="line">    //skb-&gt;data指向的地址空间的布局: MAC首部 | IP首部 | TCP首部 | 有效负载</span><br><span class="line">	ptr = skb-&gt;data;//获取数据部分首地址</span><br><span class="line">	ptr += dev-&gt;hard_header_len;//后移硬件(MAC)首部长度个字节，定位到ip首部</span><br><span class="line">	iph = (struct iphdr *)ptr;//获取ip首部</span><br><span class="line">	skb-&gt;ip_hdr = iph;//skb对应字段建立关联</span><br><span class="line">	//ip数据报的总长度(ip首部+数据部分) = skb的总长度 - 硬件首部长度</span><br><span class="line">	iph-&gt;tot_len = ntohs(skb-&gt;len-dev-&gt;hard_header_len);</span><br><span class="line"> </span><br><span class="line">#ifdef CONFIG_IP_FIREWALL</span><br><span class="line">	//数据包过滤，用于防火墙安全性检查</span><br><span class="line">	if(ip_fw_chk(iph, dev, ip_fw_blk_chain, ip_fw_blk_policy, 0) != 1)</span><br><span class="line">		/* just don&#x27;t send this packet */</span><br><span class="line">		return;</span><br><span class="line">#endif	</span><br><span class="line"> </span><br><span class="line">	/*</span><br><span class="line">	 *	No reassigning numbers to fragments...</span><br><span class="line">	 */</span><br><span class="line">    //如果不是分片数据包，就需要递增id字段</span><br><span class="line">//free==2，表示这是个分片数据包，所有分片数据包必须具有相同的id字段，方便以后分片数据包重组</span><br><span class="line">	if(free!=2)</span><br><span class="line">		iph-&gt;id      = htons(ip_id_count++);//ip数据报标识符</span><br><span class="line">		//ip_id_count是全局变量，用于下一个数据包中ip首部id字段的赋值</span><br><span class="line">	else</span><br><span class="line">		free=1;</span><br><span class="line"> </span><br><span class="line">	/* All buffers without an owner socket get freed */</span><br><span class="line">	if (sk == NULL)//没有对应sock结构，则无法对数据包缓存</span><br><span class="line">		free = 1;</span><br><span class="line"> </span><br><span class="line">	skb-&gt;free = free;//用于标识数据包发送之后是缓存还是立即释放,=1表示无缓存</span><br><span class="line"> </span><br><span class="line">	/*</span><br><span class="line">	 *	Do we need to fragment. Again this is inefficient.</span><br><span class="line">	 *	We need to somehow lock the original buffer and use</span><br><span class="line">	 *	bits of it.</span><br><span class="line">	 */</span><br><span class="line">	//数据包拆分</span><br><span class="line">    //如果ip层数据包的数据部分(各层首部+有效负载)长度大于网络设备的最大传输单元，就需要拆分发送</span><br><span class="line">    //实际是skb-&gt;len - dev-&gt;hard_header_len &gt; dev-&gt;mtu</span><br><span class="line">    //因为MTU最大报文长度表示的仅仅是IP首部及其数据负载的长度，所以要考虑MAC首部长度</span><br><span class="line">	if(skb-&gt;len &gt; dev-&gt;mtu + dev-&gt;hard_header_len)</span><br><span class="line">	&#123;</span><br><span class="line">	//拆分成分片数据包传输</span><br><span class="line">		ip_fragment(sk,skb,dev,0);</span><br><span class="line">		IS_SKB(skb);//检查数据包skb相关字段</span><br><span class="line">		kfree_skb(skb,FREE_WRITE);</span><br><span class="line">		return;</span><br><span class="line">	&#125;</span><br><span class="line"> </span><br><span class="line">	/*</span><br><span class="line">	 *	Add an IP checksum</span><br><span class="line">	 */</span><br><span class="line">    //ip首部校验和计算</span><br><span class="line">	ip_send_check(iph);</span><br><span class="line"> </span><br><span class="line">	/*</span><br><span class="line">	 *	Print the frame when debugging</span><br><span class="line">	 */</span><br><span class="line"> </span><br><span class="line">	/*</span><br><span class="line">	 *	More debugging. You cannot queue a packet already on a list</span><br><span class="line">	 *	Spot this and moan loudly.</span><br><span class="line">	 */</span><br><span class="line">	if (skb-&gt;next != NULL)</span><br><span class="line">	&#123;</span><br><span class="line">		printk(&quot;ip_queue_xmit: next != NULL\n&quot;);</span><br><span class="line">		skb_unlink(skb);</span><br><span class="line">	&#125;</span><br><span class="line"> </span><br><span class="line">	/*</span><br><span class="line">	 *	If a sender wishes the packet to remain unfreed</span><br><span class="line">	 *	we add it to his send queue. This arguably belongs</span><br><span class="line">	 *	in the TCP level since nobody else uses it. BUT</span><br><span class="line">	 *	remember IPng might change all the rules.</span><br><span class="line">	 */</span><br><span class="line">    //free=0，表示对数据包进行缓存，一旦发生丢弃的情况，进行数据包重传(可靠性数据传输协议)</span><br><span class="line">	if (!free)</span><br><span class="line">	&#123;</span><br><span class="line">		unsigned long flags;</span><br><span class="line">		/* The socket now has more outstanding blocks */</span><br><span class="line"> </span><br><span class="line">		sk-&gt;packets_out++;//本地发送出去但未得到应答的数据包数目</span><br><span class="line"> </span><br><span class="line">		/* Protect the list for a moment */</span><br><span class="line">		save_flags(flags);</span><br><span class="line">		cli();</span><br><span class="line"> </span><br><span class="line">		//数据包重发队列</span><br><span class="line">		if (skb-&gt;link3 != NULL)</span><br><span class="line">		&#123;</span><br><span class="line">			printk(&quot;ip.c: link3 != NULL\n&quot;);</span><br><span class="line">			skb-&gt;link3 = NULL;</span><br><span class="line">		&#125;</span><br><span class="line">		if (sk-&gt;send_head == NULL)</span><br><span class="line">		&#123;</span><br><span class="line">		//数据包重传缓存队列则是由下列两个字段维护</span><br><span class="line">			sk-&gt;send_tail = skb;</span><br><span class="line">			sk-&gt;send_head = skb;</span><br><span class="line">		&#125;</span><br><span class="line">		else</span><br><span class="line">		&#123;</span><br><span class="line">			sk-&gt;send_tail-&gt;link3 = skb;</span><br><span class="line">			sk-&gt;send_tail = skb;</span><br><span class="line">		&#125;</span><br><span class="line">		/* skb-&gt;link3 is NULL */</span><br><span class="line"> </span><br><span class="line">		/* Interrupt restore */</span><br><span class="line">		restore_flags(flags);</span><br><span class="line">	&#125;</span><br><span class="line">	else</span><br><span class="line">		/* Remember who owns the buffer */</span><br><span class="line">		skb-&gt;sk = sk;</span><br><span class="line"> </span><br><span class="line">	/*</span><br><span class="line">	 *	If the indicated interface is up and running, send the packet.</span><br><span class="line">	 */</span><br><span class="line">	 </span><br><span class="line">	ip_statistics.IpOutRequests++;</span><br><span class="line">#ifdef CONFIG_IP_ACCT</span><br><span class="line">//下面函数内部调用ip_fw_chk，也是数据包过滤</span><br><span class="line">	ip_acct_cnt(iph,dev, ip_acct_chain);</span><br><span class="line">#endif	</span><br><span class="line">	</span><br><span class="line">#ifdef CONFIG_IP_MULTICAST	</span><br><span class="line">    //对于多播和广播数据包，其必须复制一份回送给本机</span><br><span class="line">	/*</span><br><span class="line">	 *	Multicasts are looped back for other local users</span><br><span class="line">	 */</span><br><span class="line">	 /*对多播和广播数据包进行处理*/</span><br><span class="line">	 //检查目的地址是否为一个多播地址</span><br><span class="line">	if (MULTICAST(iph-&gt;daddr) &amp;&amp; !(dev-&gt;flags&amp;IFF_LOOPBACK))</span><br><span class="line">	&#123;</span><br><span class="line">	//检查发送设备是否为一个回路设备</span><br><span class="line">		if(sk==NULL || sk-&gt;ip_mc_loop)</span><br><span class="line">		&#123;</span><br><span class="line">			if(iph-&gt;daddr==IGMP_ALL_HOSTS)//如果是224.0.0.1(默认多播地址)</span><br><span class="line">				ip_loopback(dev,skb);//数据包回送给发送端</span><br><span class="line">			else</span><br><span class="line">			&#123;  //检查多播地址列表，对数据包进行匹配</span><br><span class="line">				struct ip_mc_list *imc=dev-&gt;ip_mc_list;</span><br><span class="line">				while(imc!=NULL)</span><br><span class="line">				&#123;</span><br><span class="line">					if(imc-&gt;multiaddr==iph-&gt;daddr)//如果存在匹配项，则回送数据包</span><br><span class="line">					&#123;</span><br><span class="line">						ip_loopback(dev,skb);</span><br><span class="line">						break;</span><br><span class="line">					&#125;</span><br><span class="line">					imc=imc-&gt;next;</span><br><span class="line">				&#125;</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">		/* Multicasts with ttl 0 must not go beyond the host */</span><br><span class="line">		//检查ip首部ttl字段，如果为0，则不可进行数据包发送(转发)</span><br><span class="line">		if(skb-&gt;ip_hdr-&gt;ttl==0)</span><br><span class="line">		&#123;</span><br><span class="line">			kfree_skb(skb, FREE_READ);</span><br><span class="line">			return;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">#endif</span><br><span class="line">	//对广播数据包的判断</span><br><span class="line">	if((dev-&gt;flags&amp;IFF_BROADCAST) &amp;&amp; iph-&gt;daddr==dev-&gt;pa_brdaddr &amp;&amp; !(dev-&gt;flags&amp;IFF_LOOPBACK))</span><br><span class="line">		ip_loopback(dev,skb);</span><br><span class="line"> </span><br><span class="line">	//对发送设备当前状态的检查，如果处于非工作状态，则无法发送数据包，此时进入else执行</span><br><span class="line">	if (dev-&gt;flags &amp; IFF_UP)</span><br><span class="line">	&#123;</span><br><span class="line">		/*</span><br><span class="line">		 *	If we have an owner use its priority setting,</span><br><span class="line">		 *	otherwise use NORMAL</span><br><span class="line">		 */</span><br><span class="line">        //调用下层接口函数dev_queue_xmit，将数据包交由链路层处理</span><br><span class="line">		if (sk != NULL)</span><br><span class="line">		&#123;</span><br><span class="line">			dev_queue_xmit(skb, dev, sk-&gt;priority);</span><br><span class="line">		&#125;</span><br><span class="line">		else</span><br><span class="line">		&#123;</span><br><span class="line">			dev_queue_xmit(skb, dev, SOPRI_NORMAL);</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	else</span><br><span class="line">	&#123;</span><br><span class="line">		ip_statistics.IpOutDiscards++;</span><br><span class="line">		if (free)</span><br><span class="line">			kfree_skb(skb, FREE_WRITE);//丢弃数据包，对tcp可靠传输而言，将造成数据包超时重传</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>上面函数功能可以总结为：</p>
<p>\1. 相关合法性检查；</p>
<p>\2. 防火墙过滤；</p>
<p>\3. 对数据包是否需要分片发送进行检查；</p>
<p>\4. 进行可能的数据包缓存处理；</p>
<p>\5. 对多播和广播数据报是否需要回送本机进行检查；</p>
<p>\6. 调用下层接口函数 dev_queue_xmit 将数据包送往链路层进行处理。</p>
<p>上面函数内部涉及到一个函数，把数据包分片，当数据包大小大于最大传输单元时，需要将数据包分片传送，这里则是通过函数 ip_fragment 实现的。【Linux 内核网络协议栈源码剖析】数据包发送上面函数内部涉及到一个函数，把数据包分片，当数据包大小大于最大传输单元时，需要将数据包分片传送，这里则是通过函数 ip_fragment 实现的。</p>
<p>ip_fragment函数：将大数据包（大于最大传输单元(最大传输单元指的是ip报，不包含mac头部)）分片发送。这个函数条理很清楚</p>
<figure class="highlight text"><table><tr><td class="code"><pre><span class="line">/*</span><br><span class="line"> *	This IP datagram is too large to be sent in one piece.  Break it up into</span><br><span class="line"> *	smaller pieces (each of size equal to the MAC header plus IP header plus</span><br><span class="line"> *	a block of the data of the original IP data part) that will yet fit in a</span><br><span class="line"> *	single device frame, and queue such a frame for sending by calling the</span><br><span class="line"> *	ip_queue_xmit().  Note that this is recursion, and bad things will happen</span><br><span class="line"> *	if this function causes a loop...</span><br><span class="line"> *</span><br><span class="line"> *	Yes this is inefficient, feel free to submit a quicker one.</span><br><span class="line"> *</span><br><span class="line"> *	**Protocol Violation**</span><br><span class="line"> *	We copy all the options to each fragment. !FIXME!</span><br><span class="line"> */</span><br><span class="line">void ip_fragment(struct sock *sk, struct sk_buff *skb, struct device *dev, int is_frag)</span><br><span class="line">&#123;</span><br><span class="line">	struct iphdr *iph;</span><br><span class="line">	unsigned char *raw;</span><br><span class="line">	unsigned char *ptr;</span><br><span class="line">	struct sk_buff *skb2;</span><br><span class="line">	int left, mtu, hlen, len;</span><br><span class="line">	int offset;</span><br><span class="line">	unsigned long flags;</span><br><span class="line"> </span><br><span class="line">	/*</span><br><span class="line">	 *	Point into the IP datagram header.</span><br><span class="line">	 */</span><br><span class="line"> </span><br><span class="line">	raw = skb-&gt;data;//得到数据部分，如果你还没清楚skb与data表示什么的话，请自行面壁</span><br><span class="line">	iph = (struct iphdr *) (raw + dev-&gt;hard_header_len);//偏移mac首部就到了ip首部位置</span><br><span class="line"> </span><br><span class="line">	skb-&gt;ip_hdr = iph;//指定ip首部</span><br><span class="line"> </span><br><span class="line">	/*</span><br><span class="line">	 *	Setup starting values.</span><br><span class="line">	 */</span><br><span class="line">    //ip数据报由ip首部和数据负载部分组成，其中数据负载部分又有tcp首部和tcp有效负载组成</span><br><span class="line">	hlen = (iph-&gt;ihl * sizeof(unsigned long));//ip首部长度</span><br><span class="line">	left = ntohs(iph-&gt;tot_len) - hlen;//ip数据负载长度	/* Space per frame */</span><br><span class="line">	hlen += dev-&gt;hard_header_len;//加上mac首部长度，得到这两者的长度和		/* Total header size */</span><br><span class="line">	mtu = (dev-&gt;mtu - hlen);//mtu初始化为ip数据负载长度		/* Size of data space */</span><br><span class="line">	ptr = (raw + hlen);	//指向ip负载数据开始位置		/* Where to start from */</span><br><span class="line"> </span><br><span class="line">	/*</span><br><span class="line">	 *	Check for any &quot;DF&quot; flag. [DF means do not fragment]</span><br><span class="line">	 */</span><br><span class="line">    //检查发送端是否允许进行分片</span><br><span class="line">	if (ntohs(iph-&gt;frag_off) &amp; IP_DF)//如果不允许</span><br><span class="line">	&#123;</span><br><span class="line">		/*</span><br><span class="line">		 *	Reply giving the MTU of the failed hop.</span><br><span class="line">		 */</span><br><span class="line">		 //返回一个ICMP错误</span><br><span class="line">		ip_statistics.IpFragFails++;</span><br><span class="line">		icmp_send(skb,ICMP_DEST_UNREACH, ICMP_FRAG_NEEDED, dev-&gt;mtu, dev);</span><br><span class="line">		return;</span><br><span class="line">	&#125;</span><br><span class="line"> </span><br><span class="line">	/*</span><br><span class="line">	 *	The protocol doesn&#x27;t seem to say what to do in the case that the</span><br><span class="line">	 *	frame + options doesn&#x27;t fit the mtu. As it used to fall down dead</span><br><span class="line">	 *	in this case we were fortunate it didn&#x27;t happen</span><br><span class="line">	 */</span><br><span class="line">    //如果ip数据负载长度&lt;8，则无法为其创建分片</span><br><span class="line">    //规定，分片中数据长度必须是8的倍数</span><br><span class="line">	if(mtu&lt;8)</span><br><span class="line">	&#123;</span><br><span class="line">		/* It&#x27;s wrong but it&#x27;s better than nothing */</span><br><span class="line">		icmp_send(skb,ICMP_DEST_UNREACH,ICMP_FRAG_NEEDED,dev-&gt;mtu, dev);</span><br><span class="line">		ip_statistics.IpFragFails++;</span><br><span class="line">		return;</span><br><span class="line">	&#125;</span><br><span class="line"> </span><br><span class="line">	/*</span><br><span class="line">	 *	Fragment the datagram.</span><br><span class="line">	 */</span><br><span class="line"> </span><br><span class="line">	/*</span><br><span class="line">	 *	The initial offset is 0 for a complete frame. When</span><br><span class="line">	 *	fragmenting fragments it&#x27;s wherever this one starts.</span><br><span class="line">	 */</span><br><span class="line"> </span><br><span class="line">	if (is_frag &amp; 2)//表示被分片数据包本身是一个分片</span><br><span class="line">		offset = (ntohs(iph-&gt;frag_off) &amp; 0x1fff) &lt;&lt; 3;</span><br><span class="line">	else</span><br><span class="line">		offset = 0;</span><br><span class="line"> </span><br><span class="line"> </span><br><span class="line">	/*</span><br><span class="line">	 *	Keep copying data until we run out.</span><br><span class="line">	 */</span><br><span class="line">    //直到所有分片数据处理完</span><br><span class="line">	while(left &gt; 0)</span><br><span class="line">	&#123;</span><br><span class="line">		len = left;</span><br><span class="line">		/* IF: it doesn&#x27;t fit, use &#x27;mtu&#x27; - the data space left */</span><br><span class="line">		if (len &gt; mtu)//如果这个数据还是大于mtu，表示不是最后一个分片，还要继续分片处理</span><br><span class="line">			len = mtu;</span><br><span class="line">		/* IF: we are not sending upto and including the packet end</span><br><span class="line">		   then align the next start on an eight byte boundary */</span><br><span class="line">		if (len &lt; left)</span><br><span class="line">		&#123;</span><br><span class="line">//得到小于mtu的最大的一个为8的倍数的数值，这个运算很有意思，值得借鉴一下</span><br><span class="line">//可以看出分片的原则是每个分片在条件下尽量携带最多数据，这个条件就是不能大于mtu值，且必须是8的倍数</span><br><span class="line">			len/=8;</span><br><span class="line">			len*=8;</span><br><span class="line">		&#125;</span><br><span class="line">		/*</span><br><span class="line">		 *	Allocate buffer.</span><br><span class="line">		 */</span><br><span class="line">//分配一个skb_buff，注意这里分配的大小，hlen是ip首部大小，得加上ip首部</span><br><span class="line">//这里可以看出，每个分片数据包还得加上ip首部，典型的1+1&gt;2，相比不分片下降低了效率，</span><br><span class="line">//但是这是不可避免的，必须增加火车头，不然不知道往哪开</span><br><span class="line">		if ((skb2 = alloc_skb(len + hlen,GFP_ATOMIC)) == NULL)</span><br><span class="line">		&#123;</span><br><span class="line">			printk(&quot;IP: frag: no memory for new fragment!\n&quot;);</span><br><span class="line">			ip_statistics.IpFragFails++;</span><br><span class="line">			return;</span><br><span class="line">		&#125;</span><br><span class="line"> </span><br><span class="line">		/*</span><br><span class="line">		 *	Set up data on packet</span><br><span class="line">		 */</span><br><span class="line"> </span><br><span class="line">		skb2-&gt;arp = skb-&gt;arp;//表示mac首部是否创建成功，</span><br><span class="line">		//参见ip_build_header函数，其内部调用了ip_send函数(eth_header)</span><br><span class="line">		if(skb-&gt;free==0)</span><br><span class="line">			printk(&quot;IP fragmenter: BUG free!=1 in fragmenter\n&quot;);</span><br><span class="line">		skb2-&gt;free = 1;//数据包无须缓存</span><br><span class="line">		skb2-&gt;len = len + hlen;//数据部分长度(分片大小+ip首部)</span><br><span class="line">		skb2-&gt;h.raw=(char *) skb2-&gt;data;//让skb2对应层的raw指向分片数据包的数据部分</span><br><span class="line">		/*</span><br><span class="line">		 *	Charge the memory for the fragment to any owner</span><br><span class="line">		 *	it might possess</span><br><span class="line">		 */</span><br><span class="line"> </span><br><span class="line">		save_flags(flags);</span><br><span class="line">		if (sk)</span><br><span class="line">		&#123;</span><br><span class="line">			cli();</span><br><span class="line">			sk-&gt;wmem_alloc += skb2-&gt;mem_len;//设置sk当前写缓冲大小为分片数据包的大小</span><br><span class="line">			skb2-&gt;sk=sk;//关联</span><br><span class="line">		&#125;</span><br><span class="line">		restore_flags(flags);</span><br><span class="line">		skb2-&gt;raddr = skb-&gt;raddr;//数据包的下一站地址，所有分片数据包自然是原数据包是一个地址	/* For rebuild_header - must be here */</span><br><span class="line"> </span><br><span class="line">		/*</span><br><span class="line">		 *	Copy the packet header into the new buffer.</span><br><span class="line">		 */</span><br><span class="line">//把skb数据部分拷贝到raw指向的位置，这里拷贝的是首部(mac首部+ip首部)</span><br><span class="line">//实际上raw和skb2-&gt;data是指向同一个地址</span><br><span class="line">		memcpy(skb2-&gt;h.raw, raw, hlen);</span><br><span class="line">		//raw随着层次变化，链路层=eth，ip层=iph</span><br><span class="line"> </span><br><span class="line">		/*</span><br><span class="line">		 *	Copy a block of the IP datagram.</span><br><span class="line">		 */</span><br><span class="line">		//这里则是拷贝ip数据负载部分</span><br><span class="line">		memcpy(skb2-&gt;h.raw + hlen, ptr, len);</span><br><span class="line">		left -= len;//剩下未传送的数据大小</span><br><span class="line"> </span><br><span class="line">		skb2-&gt;h.raw+=dev-&gt;hard_header_len;//raw位置定位到了ip首部</span><br><span class="line">        //一定要清楚skb_buff-&gt;data到了某一层的数据布局</span><br><span class="line">		/*</span><br><span class="line">		 *	Fill in the new header fields.</span><br><span class="line">		 */</span><br><span class="line">		 //获取ip首部</span><br><span class="line">		iph = (struct iphdr *)(skb2-&gt;h.raw/*+dev-&gt;hard_header_len*/);</span><br><span class="line">		iph-&gt;frag_off = htons((offset &gt;&gt; 3));//片位移，offset在前面进行了设置</span><br><span class="line">		/*</span><br><span class="line">		 *	Added AC : If we are fragmenting a fragment thats not the</span><br><span class="line">		 *		   last fragment then keep MF on each bit</span><br><span class="line">		 */</span><br><span class="line">		if (left &gt; 0 || (is_frag &amp; 1))//left&gt;0，表示这不是最后一个分片，还有剩下数据包未发送</span><br><span class="line">			iph-&gt;frag_off |= htons(IP_MF);</span><br><span class="line"> </span><br><span class="line">	//ip数据负载已经发送了len各大小的分片数据包，那么就要更新下一个分片数据包的位置，以便发送</span><br><span class="line">		ptr += len;//ip数据负载位置更新</span><br><span class="line">		offset += len;//偏移量更新，</span><br><span class="line"> </span><br><span class="line">		/*</span><br><span class="line">		 *	Put this fragment into the sending queue.</span><br><span class="line">		 */</span><br><span class="line"> </span><br><span class="line">		ip_statistics.IpFragCreates++;</span><br><span class="line"> </span><br><span class="line">		ip_queue_xmit(sk, dev, skb2, 2);//发送数据包</span><br><span class="line">		//可以看出，发送一个数据包的过程就是，检查其大小是否小于mtu，否则需要进行分片，</span><br><span class="line">		//然后对分片进行发送，分片数据包自然是小于mtu，直到原来的大于mtu的数据包全部分片发送完</span><br><span class="line">	&#125;</span><br><span class="line">	ip_statistics.IpFragOKs++;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>ip_fragment 函数条理很清晰，就是将大的拆分为小的，其拆分过程为，新建指定大小（小于MTU的是8的倍数的最大值）的分片数据包，然后将原大数据包中的数据负载截取前分片大小，再加上ip首部，每个分片数据包都要加上ip首部，这样降低效率的措施不得不采用。然后就是发送这个分片数据包，直到大数据包分片发送完成。</p>
<p>ip_queue_xmit 最后通过调用 dev_queue_xmit 函数将数据包发往链路层进行处理。</p>
<h2 id="2、链路层——dev-queue-xmit-函数"><a href="#2、链路层——dev-queue-xmit-函数" class="headerlink" title="2、链路层——dev_queue_xmit 函数"></a>2、链路层——dev_queue_xmit 函数</h2><figure class="highlight text"><table><tr><td class="code"><pre><span class="line">/*</span><br><span class="line"> *	Send (or queue for sending) a packet. </span><br><span class="line"> *</span><br><span class="line"> *	IMPORTANT: When this is called to resend frames. The caller MUST</span><br><span class="line"> *	already have locked the sk_buff. Apart from that we do the</span><br><span class="line"> *	rest of the magic.</span><br><span class="line"> */</span><br><span class="line"> //该函数本身负责将数据包传递给驱动程序，由驱动程序最终将数据发送到物理介质上。</span><br><span class="line"> /*</span><br><span class="line"> skb:被发送的数据包；dev:数据包发送网络接口设备；pri:网络接口设备忙时，缓存该数据包时使用的优先级</span><br><span class="line"> */</span><br><span class="line">void dev_queue_xmit(struct sk_buff *skb, struct device *dev, int pri)</span><br><span class="line">&#123;</span><br><span class="line">	unsigned long flags;</span><br><span class="line">	int nitcount;</span><br><span class="line">	struct packet_type *ptype;//用于网络层协议</span><br><span class="line">	int where = 0;		/* used to say if the packet should go	*/</span><br><span class="line">				/* at the front or the back of the	*/</span><br><span class="line">				/* queue - front is a retransmit try	*/</span><br><span class="line"> </span><br><span class="line">	if (dev == NULL) </span><br><span class="line">	&#123;</span><br><span class="line">		printk(&quot;dev.c: dev_queue_xmit: dev = NULL\n&quot;);</span><br><span class="line">		return;</span><br><span class="line">	&#125;</span><br><span class="line"> </span><br><span class="line">	//加锁</span><br><span class="line">	if(pri&gt;=0 &amp;&amp; !skb_device_locked(skb))</span><br><span class="line">		skb_device_lock(skb);	/* Shove a lock on the frame */</span><br><span class="line">#ifdef CONFIG_SLAVE_BALANCING</span><br><span class="line">	save_flags(flags);//保存状态</span><br><span class="line">	cli();</span><br><span class="line">	//检查是否使用了主从设备的连接方式</span><br><span class="line">	//如果采用了这种方式，则发送数据包时，可在两个设备之间平均负载</span><br><span class="line">	if(dev-&gt;slave!=NULL &amp;&amp; dev-&gt;slave-&gt;pkt_queue &lt; dev-&gt;pkt_queue &amp;&amp;</span><br><span class="line">				(dev-&gt;slave-&gt;flags &amp; IFF_UP))</span><br><span class="line">		dev=dev-&gt;slave;</span><br><span class="line">	restore_flags(flags);</span><br><span class="line">#endif		</span><br><span class="line">#ifdef CONFIG_SKB_CHECK </span><br><span class="line">	IS_SKB(skb);//检查数据包的合法性</span><br><span class="line">#endif    </span><br><span class="line">	skb-&gt;dev = dev;//指向数据包发送设备对应结构</span><br><span class="line"> </span><br><span class="line">	/*</span><br><span class="line">	 *	This just eliminates some race conditions, but not all... </span><br><span class="line">	 */</span><br><span class="line">    //检查以免造成竞争条件，事实上skb-&gt;next == NULL的</span><br><span class="line">	if (skb-&gt;next != NULL) </span><br><span class="line">	&#123;</span><br><span class="line">		/*</span><br><span class="line">		 *	Make sure we haven&#x27;t missed an interrupt. </span><br><span class="line">		 */</span><br><span class="line">		printk(&quot;dev_queue_xmit: worked around a missed interrupt\n&quot;);</span><br><span class="line">		start_bh_atomic();//原子操作，宏定义</span><br><span class="line">		dev-&gt;hard_start_xmit(NULL, dev);</span><br><span class="line">		end_bh_atomic();</span><br><span class="line">		return;</span><br><span class="line">  	&#125;</span><br><span class="line"> </span><br><span class="line">	/*</span><br><span class="line">	 *	Negative priority is used to flag a frame that is being pulled from the</span><br><span class="line">	 *	queue front as a retransmit attempt. It therefore goes back on the queue</span><br><span class="line">	 *	start on a failure.</span><br><span class="line">	 */</span><br><span class="line">//优先级为负数，表示当前处理的数据包是从硬件队列中取下的，而非上层传递的新数据包</span><br><span class="line">  	if (pri &lt; 0) </span><br><span class="line">  	&#123;</span><br><span class="line">		pri = -pri-1;</span><br><span class="line">		where = 1;</span><br><span class="line">  	&#125;</span><br><span class="line"> </span><br><span class="line">	if (pri &gt;= DEV_NUMBUFFS) </span><br><span class="line">	&#123;</span><br><span class="line">		printk(&quot;bad priority in dev_queue_xmit.\n&quot;);</span><br><span class="line">		pri = 1;</span><br><span class="line">	&#125;</span><br><span class="line"> </span><br><span class="line">	/*</span><br><span class="line">	 *	If the address has not been resolved. Call the device header rebuilder.</span><br><span class="line">	 *	This can cover all protocols and technically not just ARP either.</span><br><span class="line">	 */</span><br><span class="line">//arp标识是否完成链路层的硬件地址解析，如果没完成，则需要调用rebuild_header(eth_rebuild_header函数)</span><br><span class="line">//完成链路层首部的创建工作</span><br><span class="line">	if (!skb-&gt;arp &amp;&amp; dev-&gt;rebuild_header(skb-&gt;data, dev, skb-&gt;raddr, skb)) &#123;</span><br><span class="line">		return;//这将启动arp地址解析过程，则数据包的发送则由arp协议模块负责，所以这里直接返回</span><br><span class="line">	&#125;</span><br><span class="line"> </span><br><span class="line">	save_flags(flags);</span><br><span class="line">	cli();	</span><br><span class="line">	if (!where) &#123;//where=1，表示这是从上层接受的新数据包</span><br><span class="line">#ifdef CONFIG_SLAVE_BALANCING	</span><br><span class="line">		skb-&gt;in_dev_queue=1;//标识该数据包缓存在设备队列中</span><br><span class="line">#endif		</span><br><span class="line">		skb_queue_tail(dev-&gt;buffs + pri,skb);//插入到设备缓存队列的尾部</span><br><span class="line">		skb_device_unlock(skb);		/* Buffer is on the device queue and can be freed safely */</span><br><span class="line">		skb = skb_dequeue(dev-&gt;buffs + pri);//从设备缓存队列的首部读取数据包，这样取得的数据包可能不是我们之前插入的数据包</span><br><span class="line">		skb_device_lock(skb);		/* New buffer needs locking down */</span><br><span class="line">#ifdef CONFIG_SLAVE_BALANCING		</span><br><span class="line">		skb-&gt;in_dev_queue=0;//该数据包当前不在缓存队列中</span><br><span class="line">#endif		</span><br><span class="line">	&#125;</span><br><span class="line">	restore_flags(flags);//恢复状态</span><br><span class="line"> </span><br><span class="line">	/* copy outgoing packets to any sniffer packet handlers */</span><br><span class="line">	//内核对混杂模式的支持。不明白...</span><br><span class="line">	if(!where)</span><br><span class="line">	&#123;</span><br><span class="line">		for (nitcount= dev_nit, ptype = ptype_base; nitcount &gt; 0 &amp;&amp; ptype != NULL; ptype = ptype-&gt;next) </span><br><span class="line">		&#123;</span><br><span class="line">			/* Never send packets back to the socket</span><br><span class="line">			 * they originated from - MvS (miquels@drinkel.ow.org)</span><br><span class="line">			 */</span><br><span class="line">			if (ptype-&gt;type == htons(ETH_P_ALL) &amp;&amp;</span><br><span class="line">			   (ptype-&gt;dev == dev || !ptype-&gt;dev) &amp;&amp;</span><br><span class="line">			   ((struct sock *)ptype-&gt;data != skb-&gt;sk))</span><br><span class="line">			&#123;</span><br><span class="line">				struct sk_buff *skb2;</span><br><span class="line">				if ((skb2 = skb_clone(skb, GFP_ATOMIC)) == NULL)//复制一份数据包</span><br><span class="line">					break;</span><br><span class="line">				/*</span><br><span class="line">				 *	The protocol knows this has (for other paths) been taken off</span><br><span class="line">				 *	and adds it back.</span><br><span class="line">				 */</span><br><span class="line">				skb2-&gt;len-=skb-&gt;dev-&gt;hard_header_len;//长度</span><br><span class="line">				ptype-&gt;func(skb2, skb-&gt;dev, ptype);//协议处理函数</span><br><span class="line">				nitcount--;</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	start_bh_atomic();</span><br><span class="line">//下面调用hard_start_xmit函数，前面skb-&gt;next不为NULL时，也调用这个函数，不过参数数据包skb是NULL</span><br><span class="line">//驱动层发送数据包，关联到了具体的网络设备处理函数，将进入真实的网卡驱动(物理层)</span><br><span class="line">//高版本的内核协议栈，还有虚拟设备，这个版本就是直接进入真实设备</span><br><span class="line">	if (dev-&gt;hard_start_xmit(skb, dev) == 0) &#123;</span><br><span class="line">		end_bh_atomic();</span><br><span class="line">		/*</span><br><span class="line">		 *	Packet is now solely the responsibility of the driver</span><br><span class="line">		 */</span><br><span class="line">		return;</span><br><span class="line">	&#125;</span><br><span class="line">	end_bh_atomic();</span><br><span class="line"> </span><br><span class="line">	/*</span><br><span class="line">	 *	Transmission failed, put skb back into a list. Once on the list it&#x27;s safe and</span><br><span class="line">	 *	no longer device locked (it can be freed safely from the device queue)</span><br><span class="line">	 */</span><br><span class="line">	cli();</span><br><span class="line">#ifdef CONFIG_SLAVE_BALANCING</span><br><span class="line">	skb-&gt;in_dev_queue=1;//如果使用主从设备，就缓存在队列中</span><br><span class="line">	dev-&gt;pkt_queue++;//该设备缓存的待发送数据包个数加1</span><br><span class="line">#endif		</span><br><span class="line">	skb_device_unlock(skb);</span><br><span class="line">	skb_queue_head(dev-&gt;buffs + pri,skb);//把数据包插入到数据包队列头中</span><br><span class="line">	restore_flags(flags);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="3、物理层"><a href="#3、物理层" class="headerlink" title="3、物理层"></a>3、物理层</h2><p>物理层则牵扯到具体的网络接口硬件设备了，实则是一个网络驱动程序。不同的网卡其驱动程序有所不同，这跟硬件的时序，延迟等有关。</p>
<p><img src="https://pic4.zhimg.com/80/v2-a8c44790925bc12839c9817d1cfb83ff_720w.webp" alt="img"></p>
<p>关于驱动，这里我们就不介绍了。</p>
<p>这部分介绍的就是数据包的发送过程，从网络层到最底层的网卡驱动。下篇将介绍数据包的接收过程。</p>
<p>connect 函数可真是渗透到网络栈的各个层啊，connect 函数是客户端向服务器端发出连接请求数据包，该数据包需要最终到达服务器端处理，自然要从客户端从上至下经过应用层、传输层、网络层、链路层、硬件接口到达对端（对端接收则是反过来从下往上）。所以通信双方进行数据传输的函数都要经过这些网络协议栈。</p>
<p>从侧面可看出，内核网络协议栈的设计体现了高内聚，低耦合的原则，各层之间只提供接口函数，协议栈某一层的改动，不需要取改动其余层，保持接口的一致性就可以了，面对日益复杂的网络栈，这种设计风格无疑很有利于维护和升级。</p>
<p>另外中间协议各层还有一些牵扯到的操作函数，会在后面一一介绍。</p>
<hr>
<p>版权声明：本文为知乎博主「<a href="https://www.zhihu.com/people/linuxwang-xian-sheng">极致Linux内核</a>」的原创文章，遵循CC 4.0 BY-SA版权协议，转载请附上原文出处链接及本声明。</p>
<p>原文链接：<a href="https://zhuanlan.zhihu.com/p/549023845">https://zhuanlan.zhihu.com/p/549023845</a></p>
]]></content>
      <categories>
        <category>linux-doc 网络协议栈</category>
      </categories>
      <tags>
        <tag>Linux</tag>
      </tags>
  </entry>
  <entry>
    <title>Linux内核网络协议栈计算机基础</title>
    <url>/2023/01/15/linux-docs/%E7%BD%91%E7%BB%9C%E5%8D%8F%E8%AE%AE%E6%A0%88/Linux%E5%86%85%E6%A0%B8%E7%BD%91%E7%BB%9C%E5%8D%8F%E8%AE%AE%E6%A0%88%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9F%BA%E7%A1%80/</url>
    <content><![CDATA[<h2 id="1、数据报文的封装与分用"><a href="#1、数据报文的封装与分用" class="headerlink" title="1、数据报文的封装与分用"></a><strong>1、数据报文的封装与分用</strong></h2><p><img src="https://pic3.zhimg.com/80/v2-7c40dfaa04dd75075c4ac7c28422b5ca_720w.webp" alt="img"></p>
<p><strong>封装</strong>：当应用程序用 TCP 协议传送数据时，数据首先进入内核网络协议栈中，然后逐一通过 TCP&#x2F;IP 协议族的每层直到被当作一串比特流送入网络。对于每一层而言，对收到的数据都会封装相应的协议首部信息（有时还会增加尾部信息）。TCP 协议传给 IP 协议的数据单元称作 TCP 报文段，或简称 TCP 段（TCP segment）。IP 传给数据链路层的数据单元称作 IP 数据报（IP datagram），最后通过以太网传输的比特流称作帧（Frame）。</p>
<p><img src="https://pic1.zhimg.com/80/v2-c3b8c1a3f2fa4f6fb8a2a4eeceec7488_720w.webp" alt="img"></p>
<p><strong>分用</strong>：当目的主机收到一个以太网数据帧时，数据就开始从内核网络协议栈中由底向上升，同时去掉各层协议加上的报文首部。每层协议都会检查报文首部中的协议标识，以确定接收数据的上层协议。这个过程称作分用。</p>
<p><img src="https://pic1.zhimg.com/80/v2-854a125ad23365ee22d7963bf32df8c0_720w.webp" alt="img"></p>
<h2 id="2、Linux-内核网络协议栈"><a href="#2、Linux-内核网络协议栈" class="headerlink" title="2、Linux 内核网络协议栈"></a>2、<strong>Linux 内核网络协议栈</strong></h2><h3 id="2-1协议栈的分层结构"><a href="#2-1协议栈的分层结构" class="headerlink" title="2.1协议栈的分层结构"></a>2.1<strong>协议栈的分层结构</strong></h3><p><img src="https://pic2.zhimg.com/80/v2-eb80114865e222e021776d34b24585a9_720w.webp" alt="img"></p>
<p><strong>逻辑抽象层级</strong>：</p>
<ul>
<li><strong>物理层</strong>：主要提供各种连接的物理设备，如各种网卡，串口卡等。</li>
<li><strong>链路层</strong>：主要提供对物理层进行访问的各种接口卡的驱动程序，如网卡驱动等。</li>
<li><strong>网路层</strong>：是负责将网络数据包传输到正确的位置，最重要的网络层协议是 IP 协议，此外还有如 ICMP，ARP，RARP 等协议。</li>
<li><strong>传输层</strong>：为应用程序之间提供端到端连接，主要为 TCP 和 UDP 协议。</li>
<li><strong>应用层</strong>：顾名思义，主要由应用程序提供，用来对传输数据进行语义解释的 “人机交互界面层”，比如 HTTP，SMTP，FTP 等协议。</li>
</ul>
<p><strong>协议栈实现层级</strong>：</p>
<ul>
<li><p><strong>硬件层（Physical device hardware）</strong>：又称驱动程序层，提供连接硬件设备的接口。</p>
</li>
<li><p><strong>设备无关层（Device agnostic interface）</strong>：又称设备接口层，提供与具体设备无关的驱动程序抽象接口。这一层的目的主要是为了统一不同的接口卡的驱动程序与网络协议层的接口，它将各种不同的驱动程序的功能统一抽象为几个特殊的动作，如 open，close，init 等，这一层可以屏蔽底层不同的驱动程序。</p>
</li>
<li><p><strong>网络协议层（Network protocols）</strong>：对应 IP layer 和 Transport layer。毫无疑问，这是整个内核网络协议栈的核心。这一层主要实现了各种网络协议，最主要的当然是 IP，ICMP，ARP，RARP，TCP，UDP 等。</p>
</li>
<li><p><strong>协议无关层（Protocol agnostic interface）</strong>，又称协议接口层，本质就是 SOCKET 层。这一层的目的是屏蔽网络协议层中诸多类型的网络协议（主要是 TCP 与 UDP 协议，当然也包括 RAW IP， SCTP 等等），以便提供简单而同一的接口给上面的系统调用层调用。简单的说，不管我们应用层使用什么协议，都要通过系统调用接口来建立一个 SOCKET，这个 SOCKET 其实是一个巨大的 sock 结构体，它和下面的网络协议层联系起来，屏蔽了不同的网络协议，通过系统调用接口只把数据部分呈献给应用层。</p>
</li>
<li><ul>
<li><strong>BSD（Berkeley Software Distribution）socket</strong>：BSD Socket 层，提供统一的 SOCKET 操作接口，与 socket 结构体关系紧密。</li>
<li><strong>INET（指一切支持 IP 协议的网络） socket</strong>：INET socket 层，调用 IP 层协议的统一接口，与 sock 结构体关系紧密。</li>
</ul>
</li>
<li><p><strong>系统调用接口层（System call interface）</strong>，实质是一个面向用户空间（User Space）应用程序的接口调用库，向用户空间应用程序提供使用网络服务的接口。</p>
</li>
</ul>
<p><img src="https://pic1.zhimg.com/80/v2-92fa4b5fb638d50d583baae78145d878_720w.webp" alt="img"></p>
<h3 id="2-2协议栈的数据结构"><a href="#2-2协议栈的数据结构" class="headerlink" title="2.2协议栈的数据结构"></a>2.2<strong>协议栈的数据结构</strong></h3><p><img src="https://pic4.zhimg.com/80/v2-983925d7c52084d19848ffaec8c3c1df_720w.webp" alt="img"></p>
<ul>
<li><strong>msghdr</strong>：描述了从应用层传递下来的消息格式，包含有用户空间地址，消息标记等重要信息。</li>
<li><strong>iovec</strong>：描述了用户空间地址的起始位置。</li>
<li><strong>file</strong>：描述文件属性的结构体，与文件描述符一一对应。</li>
<li><strong>file_operations</strong>：文件操作相关结构体，包括 <code>read()</code>、<code>write()</code>、<code>open()</code>、<code>ioctl()</code> 等。</li>
<li><strong>socket</strong>：向应用层提供的 BSD socket 操作结构体，协议无关，主要作用为应用层提供统一的 Socket 操作。</li>
<li><strong>sock</strong>：网络层 sock，定义与协议无关操作，是网络层的统一的结构，传输层在此基础上实现了 inet_sock。</li>
<li><strong>sock_common</strong>：最小网络层表示结构体。</li>
<li><strong>inet_sock</strong>：表示层结构体，在 sock 上做的扩展，用于在网络层之上表示 inet 协议族的的传输层公共结构体。</li>
<li><strong>udp_sock</strong>：传输层 UDP 协议专用 sock 结构，在传输层 inet_sock 上扩展。</li>
<li><strong>proto_ops</strong>：BSD socket 层到 inet_sock 层接口，主要用于操作 socket 结构。</li>
<li><strong>proto</strong>：inet_sock 层到传输层操作的统一接口，主要用于操作 sock 结构。</li>
<li><strong>net_proto_family</strong>：用于标识和注册协议族，常见的协议族有 IPv4、IPv6。</li>
<li><strong>softnet_data</strong>：内核为每个 CPU 都分配一个这样的 softnet_data 数据空间。每个 CPU 都有一个这样的队列，用于接收数据包。</li>
<li><strong>sk_buff</strong>：描述一个帧结构的属性，包含 socket、到达时间、到达设备、各层首部大小、下一站路由入口、帧长度、校验和等等。</li>
<li><strong>sk_buff_head</strong>：数据包队列结构。</li>
<li><strong>net_device</strong>：这个巨大的结构体描述一个网络设备的所有属性，数据等信息。</li>
<li><strong>inet_protosw</strong>：向 IP 层注册 socket 层的调用操作接口。</li>
<li><strong>inetsw_array</strong>：socket 层调用 IP 层操作接口都在这个数组中注册。</li>
<li><strong>sock_type</strong>：socket 类型。</li>
<li><strong>IPPROTO</strong>：传输层协议类型 ID。</li>
<li><strong>net_protocol</strong>：用于传输层协议向 IP 层注册收包的接口。</li>
<li><strong>packet_type</strong>：以太网数据帧的结构，包括了以太网帧类型、处理方法等。</li>
<li><strong>rtable</strong>：路由表结构，描述一个路由表的完整形态。</li>
<li><strong>rt_hash_bucket</strong>：路由表缓存。</li>
<li><strong>dst_entry</strong>：包的去向接口，描述了包的去留，下一跳等路由关键信息。</li>
<li><strong>napi_struct</strong>：NAPI 调度的结构。NAPI 是 Linux 上采用的一种提高网络处理效率的技术，它的核心概念就是不采用中断的方式读取数据，而代之以首先采用中断唤醒数据接收服务，然后采用 poll 的方法来轮询数据。NAPI 技术适用于高速率的短长度数据包的处理。</li>
</ul>
<h3 id="2-3网络协议栈初始化流程"><a href="#2-3网络协议栈初始化流程" class="headerlink" title="2.3网络协议栈初始化流程"></a>2.3<strong>网络协议栈初始化流程</strong></h3><p>这需要从内核启动流程说起。当内核完成自解压过程后进入内核启动流程，这一过程先在 arch&#x2F;mips&#x2F;kernel&#x2F;head.S 程序中，这个程序负责数据区（BBS）、中断描述表（IDT）、段描述表（GDT）、页表和寄存器的初始化，程序中定义了内核的入口函数 <code>kernel_entry()</code>、<code>kernel_entry()</code> 函数是体系结构相关的汇编代码，它首先初始化内核堆栈段为创建系统中的第一过程进行准备，接着用一段循环将内核映像的未初始化的数据段清零，最后跳到 <code>start_kernel()</code> 函数中初始化硬件相关的代码，完成 Linux Kernel 环境的建立。</p>
<p><code>start_kenrel()</code> 定义在 init&#x2F;main.c 中，真正的内核初始化过程就是从这里才开始。函数 <code>start_kerenl()</code> 将会调用一系列的初始化函数，如：平台初始化，内存初始化，陷阱初始化，中断初始化，进程调度初始化，缓冲区初始化，完成内核本身的各方面设置，目的是最终建立起基本完整的 Linux 内核环境。</p>
<p><code>start_kernel()</code> 中主要函数及调用关系如下：</p>
<p><img src="https://pic3.zhimg.com/80/v2-3e94921a373d33460fb7f564de7a7722_720w.webp" alt="img"></p>
<p><code>start_kernel()</code> 的过程中会执行 <code>socket_init()</code> 来完成协议栈的初始化，实现如下：</p>
<figure class="highlight text"><table><tr><td class="code"><pre><span class="line">void sock_init(void)//网络栈初始化</span><br><span class="line">&#123;</span><br><span class="line">	int i;</span><br><span class="line"> </span><br><span class="line">	printk(&quot;Swansea University Computer Society NET3.019\n&quot;);</span><br><span class="line"> </span><br><span class="line">	/*</span><br><span class="line">	 *	Initialize all address (protocol) families. </span><br><span class="line">	 */</span><br><span class="line">	 </span><br><span class="line">	for (i = 0; i &lt; NPROTO; ++i) pops[i] = NULL;</span><br><span class="line"> </span><br><span class="line">	/*</span><br><span class="line">	 *	Initialize the protocols module. </span><br><span class="line">	 */</span><br><span class="line"> </span><br><span class="line">	proto_init();</span><br><span class="line"> </span><br><span class="line">#ifdef CONFIG_NET</span><br><span class="line">	/* </span><br><span class="line">	 *	Initialize the DEV module. </span><br><span class="line">	 */</span><br><span class="line"> </span><br><span class="line">	dev_init();</span><br><span class="line">  </span><br><span class="line">	/*</span><br><span class="line">	 *	And the bottom half handler </span><br><span class="line">	 */</span><br><span class="line"> </span><br><span class="line">	bh_base[NET_BH].routine= net_bh;</span><br><span class="line">	enable_bh(NET_BH);</span><br><span class="line">#endif  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<p><img src="https://pic3.zhimg.com/80/v2-7e3f575b545ce0642bd60314346a14ee_720w.webp" alt="img"></p>
<p><code>sock_init()</code> 包含了内核协议栈的初始化工作：</p>
<ul>
<li><p><strong>sock_init</strong>：Initialize sk_buff SLAB cache，注册 SOCKET 文件系统。</p>
</li>
<li><p><strong>net_inuse_init</strong>：为每个 CPU 分配缓存。</p>
</li>
<li><p><strong>proto_init</strong>：在 &#x2F;proc&#x2F;net 域下建立 protocols 文件，注册相关文件操作函数。</p>
</li>
<li><p><strong>net_dev_init</strong>：建立 netdevice 在 &#x2F;proc&#x2F;sys 相关的数据结构，并且开启网卡收发中断；为每个 CPU 初始化一个数据包接收队列（softnet_data），包接收的回调；注册本地回环操作，注册默认网络设备操作。</p>
</li>
<li><p><strong>inet_init</strong>：注册 INET 协议族的 SOCKET 创建方法，注册 TCP、UDP、ICMP、IGMP 接口基本的收包方法。为 IPv4 协议族创建 proc 文件。此函数为协议栈主要的注册函数：</p>
</li>
<li><ul>
<li><p><code>rc = proto_register(&amp;udp_prot, 1);</code>：注册 INET 层 UDP 协议，为其分配快速缓存。</p>
</li>
<li><p><code>(void)sock_register(&amp;inet_family_ops);</code>：向 <code>static const struct net_proto_family *net_families[NPROTO]</code> 结构体注册 INET 协议族的操作集合（主要是 INET socket 的创建操作）。</p>
</li>
<li><p><code>inet_add_protocol(&amp;udp_protocol, IPPROTO_UDP) &lt; 0;</code>：向 <code>externconst struct net_protocol *inet_protos[MAX_INET_PROTOS]</code> 结构体注册传输层 UDP 的操作集合。</p>
</li>
<li><p><code>static struct list_head inetsw[SOCK_MAX]; for (r = &amp;inetsw[0]; r &lt; &amp;inetsw[SOCK_MAX];++r) INIT_LIST_HEAD(r);</code>：初始化 SOCKET 类型数组，其中保存了这是个链表数组，每个元素是一个链表，连接使用同种 SOCKET 类型的协议和操作集合。</p>
</li>
<li><p><code>for (q = inetsw_array; q &lt; &amp;inetsw_array[INETSW_ARRAY_LEN]; ++q)</code>：</p>
</li>
<li><ul>
<li><code>inet_register_protosw(q);</code>：向 sock 注册协议的的调用操作集合。</li>
</ul>
</li>
</ul>
</li>
<li><ul>
<li><code>arp_init();</code>：启动 ARP 协议支持。</li>
<li><code>ip_init();</code>：启动 IP 协议支持。</li>
<li><code>udp_init();</code>：启动 UDP 协议支持。</li>
<li><code>dev_add_pack(&amp;ip_packet_type);</code>：向 <code>ptype_base[PTYPE_HASH_SIZE];</code> 注册 IP 协议的操作集合。</li>
<li><code>socket.c</code> 提供的系统调用接口。</li>
</ul>
</li>
</ul>
<p><img src="https://pic2.zhimg.com/80/v2-614208987340e56ba7418f32d5346e1d_720w.webp" alt="img"></p>
<p><img src="https://pic1.zhimg.com/80/v2-322e847416d72b9c1775b00f44dd867c_720w.webp" alt="img"></p>
<p>协议栈初始化完成后再执行 <code>dev_init()</code>，继续设备的初始化。</p>
<h3 id="2-4Socket-创建流程"><a href="#2-4Socket-创建流程" class="headerlink" title="2.4Socket 创建流程"></a>2.4<strong>Socket 创建流程</strong></h3><p><img src="https://pic1.zhimg.com/80/v2-f82295bd27bd9efb16a79ed262649dec_720w.webp" alt="img"></p>
<h3 id="2-5协议栈收包流程概述"><a href="#2-5协议栈收包流程概述" class="headerlink" title="2.5协议栈收包流程概述"></a>2.5<strong>协议栈收包流程概述</strong></h3><p><strong>硬件层与设备无关层</strong>：硬件监听物理介质，进行数据的接收，当接收的数据填满了缓冲区，硬件就会产生中断，中断产生后，系统会转向中断服务子程序。在中断服务子程序中，数据会从硬件的缓冲区复制到内核的空间缓冲区，并包装成一个数据结构（sk_buff），然后调用对驱动层的接口函数 <code>netif_rx()</code> 将数据包发送给设备无关层。该函数的实现在 net&#x2F;inet&#x2F;dev.c 中，采用了 bootom half 技术，该技术的原理是将中断处理程序人为的分为两部分，上半部分是实时性要求较高的任务，后半部分可以稍后完成，这样就可以节省中断程序的处理时间，整体提高了系统的性能。</p>
<p><strong>NOTE</strong>：在整个协议栈实现中 dev.c 文件的作用重大，它衔接了其下的硬件层和其上的网络协议层，可以称它为链路层模块，或者设备无关层的实现。</p>
<p><strong>网络协议层</strong>：就以 IP 数据报为例，从设备无关层向网络协议层传递时会调用 <code>ip_rcv()</code>。该函数会根据 IP 首部中使用的传输层协议来调用相应协议的处理函数。UDP 对应 <code>udp_rcv()</code>、TCP 对应 <code>tcp_rcv()</code>、ICMP 对应 <code>icmp_rcv()</code>、IGMP 对应 <code>igmp_rcv()</code>。以 <code>tcp_rcv()</code> 为例，所有使用 TCP 协议的套接字对应的 sock 结构体都被挂入 tcp_prot 全局变量表示的 proto 结构之 sock_array 数组中，采用以本地端口号为索引的插入方式。所以，当 <code>tcp_rcv()</code> 接收到一个数据包，在完成必要的检查和处理后，其将以 TCP 协议首部中目的端口号为索引，在 tcp_prot 对应的 sock 结构体之 sock_array 数组中得到正确的 sock 结构体队列，再辅之以其他条件遍历该队列进行对应 sock 结构体的查询，在得到匹配的 sock 结构体后，将数据包挂入该 sock 结构体中的缓存队列中（由 sock 结构体中的 receive_queue 字段指向），从而完成数据包的最终接收。</p>
<p><strong>NOTE</strong>：虽然这里的 ICMP、IGMP 通常被划分为网络层协议，但是实际上他们都封装在 IP 协议里面，作为传输层对待。</p>
<p><strong>协议无关层和系统调用接口层</strong>：当用户需要接收数据时，首先根据文件描述符 inode 得到 socket 结构体和 sock 结构体，然后从 sock 结构体中指向的队列 recieve_queue 中读取数据包，将数据包 copy 到用户空间缓冲区。数据就完整的从硬件中传输到用户空间。这样也完成了一次完整的从下到上的传输。</p>
<h3 id="2-6协议栈发包流程概述"><a href="#2-6协议栈发包流程概述" class="headerlink" title="2.6协议栈发包流程概述"></a>2.6<strong>协议栈发包流程概述</strong></h3><ol>
<li><strong>应用层</strong>可以通过系统调用接口层或文件操作来调用内核函数，BSD socket 层的 <code>sock_write()</code> 会调用 INET socket 层的 <code>inet_wirte()</code>。INET socket 层会调用具体传输层协议的 write 函数，该函数是通过调用本层的 <code>inet_send()</code> 来实现的，<code>inet_send()</code> 的 UDP 协议对应的函数为 <code>udp_write()</code>。</li>
<li>在<strong>传输层</strong><code>udp_write()</code> 调用本层的 <code>udp_sendto()</code> 完成功能。<code>udp_sendto()</code> 完成 sk_buff 结构体相应的设置和报头的填写后会调用 <code>udp_send()</code> 来发送数据。而在 <code>udp_send()</code> 中，最后会调用 <code>ip_queue_xmit()</code> 将数据包下放的网络层。</li>
<li>在<strong>网络层</strong>，函数 <code>ip_queue_xmit()</code> 的功能是将数据包进行一系列复杂的操作，比如是检查数据包是否需要分片，是否是多播等一系列检查，最后调用 <code>dev_queue_xmit()</code> 发送数据。</li>
<li>在<strong>链路层</strong>中，函数调用会调用具体设备提供的发送函数来发送数据包，e.g. <code>dev-&gt;hard_start_xmit(skb, dev);</code>。具体设备的发送函数在协议栈初始化的时候已经设置了。这里以 8390 网卡为例来说明驱动层的工作原理，在 net&#x2F;drivers&#x2F;8390.c 中函数 <code>ethdev_init()</code> 的设置如下：</li>
</ol>
<figure class="highlight text"><table><tr><td class="code"><pre><span class="line">/* Initialize the rest of the 8390 device structure. */  </span><br><span class="line">int ethdev_init(struct device *dev)  </span><br><span class="line">&#123;  </span><br><span class="line">    if (ei_debug &gt; 1)  </span><br><span class="line">        printk(version);  </span><br><span class="line">      </span><br><span class="line">    if (dev-&gt;priv == NULL) &#123; //申请私有空间  </span><br><span class="line">        struct ei_device *ei_local; //8390 网卡设备的结构体  </span><br><span class="line">          </span><br><span class="line">        dev-&gt;priv = kmalloc(sizeof(struct ei_device), GFP_KERNEL); //申请内核内存空间  </span><br><span class="line">        memset(dev-&gt;priv, 0, sizeof(struct ei_device));  </span><br><span class="line">        ei_local = (struct ei_device *)dev-&gt;priv;  </span><br><span class="line">#ifndef NO_PINGPONG  </span><br><span class="line">        ei_local-&gt;pingpong = 1;  </span><br><span class="line">#endif  </span><br><span class="line">    &#125;  </span><br><span class="line">      </span><br><span class="line">    /* The open call may be overridden by the card-specific code. */  </span><br><span class="line">    if (dev-&gt;open == NULL)  </span><br><span class="line">        dev-&gt;open = &amp;ei_open; // 设备的打开函数  </span><br><span class="line">    /* We should have a dev-&gt;stop entry also. */  </span><br><span class="line">    dev-&gt;hard_start_xmit = &amp;ei_start_xmit; // 设备的发送函数，定义在 8390.c 中  </span><br><span class="line">    dev-&gt;get_stats   = get_stats;  </span><br><span class="line">#ifdef HAVE_MULTICAST  </span><br><span class="line">    dev-&gt;set_multicast_list = &amp;set_multicast_list;  </span><br><span class="line">#endif  </span><br><span class="line">  </span><br><span class="line">    ether_setup(dev);  </span><br><span class="line">          </span><br><span class="line">    return 0;  </span><br><span class="line">&#125;  </span><br></pre></td></tr></table></figure>

<h2 id="3、UDP-的收发包流程总览"><a href="#3、UDP-的收发包流程总览" class="headerlink" title="3、UDP 的收发包流程总览"></a>3、<strong>UDP 的收发包流程总览</strong></h2><p><img src="https://pic1.zhimg.com/80/v2-0e3a50c88aa6da33b7115da331e1e7c0_720w.webp" alt="img"></p>
<h3 id="3-1内核中断收包流程"><a href="#3-1内核中断收包流程" class="headerlink" title="3.1内核中断收包流程"></a>3.1<strong>内核中断收包流程</strong></h3><p><img src="https://pic1.zhimg.com/80/v2-d7555d650b8c7a8e342099a81d9ec0a0_720w.webp" alt="img"></p>
<h3 id="3-2UDP-收包流程"><a href="#3-2UDP-收包流程" class="headerlink" title="3.2UDP 收包流程"></a>3.2<strong>UDP 收包流程</strong></h3><p><img src="https://pic1.zhimg.com/80/v2-d96407f45901fe7d0d055387b23b6040_720w.webp" alt="img"></p>
<h3 id="3-3UDP-发包流程"><a href="#3-3UDP-发包流程" class="headerlink" title="3.3UDP 发包流程"></a>3.3<strong>UDP 发包流程</strong></h3><p><img src="https://pic2.zhimg.com/80/v2-964c9f567ea56de9137e7d208e2f66a9_720w.webp" alt="img"></p>
<hr>
<p>版权声明：本文为知乎博主「<a href="https://www.zhihu.com/people/linuxwang-xian-sheng">极致Linux内核</a>」的原创文章，遵循CC 4.0 BY-SA版权协议，转载请附上原文出处链接及本声明。</p>
<p>原文链接：<a href="https://zhuanlan.zhihu.com/p/548979948">https://zhuanlan.zhihu.com/p/548979948</a></p>
]]></content>
      <categories>
        <category>linux-doc 网络协议栈</category>
      </categories>
      <tags>
        <tag>Linux</tag>
      </tags>
  </entry>
  <entry>
    <title>Linux内核网络栈主要结构介绍</title>
    <url>/2023/01/15/linux-docs/%E7%BD%91%E7%BB%9C%E5%8D%8F%E8%AE%AE%E6%A0%88/Linux%E5%86%85%E6%A0%B8%E7%BD%91%E7%BB%9C%E6%A0%88%E4%B8%BB%E8%A6%81%E7%BB%93%E6%9E%84%E4%BB%8B%E7%BB%8D/</url>
    <content><![CDATA[<h2 id="1、socket"><a href="#1、socket" class="headerlink" title="1、socket"></a>1、socket</h2><p>（include\linux\Socket.h）该结构体socket 主要使用在BSD socket 层，是最上层的结构，在INET socket 层也会有涉及，但很少。</p>
<figure class="highlight text"><table><tr><td class="code"><pre><span class="line">/* </span><br><span class="line"> * Internal representation of a socket. not all the fields are used by </span><br><span class="line"> * all configurations: </span><br><span class="line"> * </span><br><span class="line"> *            server                client </span><br><span class="line"> * conn     client connected to server connected to </span><br><span class="line"> * iconn        list of clients     -unused- </span><br><span class="line"> *       awaiting connections </span><br><span class="line"> * wait     sleep for clients,  sleep for connection, </span><br><span class="line"> *          sleep for i/o               sleep for i/o </span><br><span class="line"> */  </span><br><span class="line"> //该结构表示一个网络套接字  </span><br><span class="line">struct socket &#123;  </span><br><span class="line">  short         type;       /* 套接字所用的流类型*/  </span><br><span class="line">  socket_state      state;//套接字所处状态  </span><br><span class="line">  long          flags;//标识字段，目前尚无明确作用  </span><br><span class="line">  struct proto_ops  *ops;       /* 操作函数集指针  */  </span><br><span class="line">    /* data保存指向‘私有&#x27;数据结构指针，在不同的域指向不同的数据结构        */  </span><br><span class="line">  //在INET域，指向sock结构，UNIX域指向unix_proto_data结构  </span><br><span class="line">  void          *data;    </span><br><span class="line">  //下面两个字段只用于UNIX域  </span><br><span class="line">  struct socket     *conn;      /* 指向连接的对端套接字   */  </span><br><span class="line">  struct socket     *iconn;     /* 指向正等待连接的客户端(服务器端)    */  </span><br><span class="line">  struct socket     *next;//链表  </span><br><span class="line">  struct wait_queue **wait;     /* 等待队列 */  </span><br><span class="line">  struct inode      *inode;//inode结构指针  </span><br><span class="line">  struct fasync_struct  *fasync_list;   /* 异步唤醒链表结构 */  </span><br><span class="line">&#125;;  </span><br></pre></td></tr></table></figure>

<h2 id="2、sock"><a href="#2、sock" class="headerlink" title="2、sock"></a>2、sock</h2><p>(include\linux\Net.h) sock 的使用范围比socket 要大得多，sock结构的使用基本贯穿硬件层、设备接口层、ip层、INET socket 层，而且是作为各层之间的一个联系，主要是因为无论是发送还是接收的数据包都要被缓存到sock 结构中的缓冲队列中。</p>
<p>sock 结构与其对应的 socket 会相互绑定。</p>
<figure class="highlight text"><table><tr><td class="code"><pre><span class="line">/* </span><br><span class="line"> * This structure really needs to be cleaned up. </span><br><span class="line"> * Most of it is for TCP, and not used by any of </span><br><span class="line"> * the other protocols. </span><br><span class="line"> * 大部分功能是为TCP准备的 </span><br><span class="line"> */  </span><br><span class="line">struct sock &#123;  </span><br><span class="line">  struct options        *opt;//IP选项缓冲于此处  </span><br><span class="line">  volatile unsigned long    wmem_alloc;//发送缓冲队列中存放的数据的大小，这两个与后面的rcvbuf和sndbuf一起使用  </span><br><span class="line">  volatile unsigned long    rmem_alloc;//接收缓冲队列中存放的数据的大小  </span><br><span class="line">  /* 下面三个seq用于TCP协议中为保证可靠数据传输而使用的序列号 */  </span><br><span class="line">  unsigned long         write_seq;//  </span><br><span class="line">  unsigned long         sent_seq;//  </span><br><span class="line">  unsigned long         acked_seq;//  </span><br><span class="line">  unsigned long         copied_seq;//应用程序有待读取(但尚未读取)数据的第一个序列号  </span><br><span class="line">  unsigned long         rcv_ack_seq;//目前本地接收到的对本地发送数据的应答序列号  </span><br><span class="line">  unsigned long         window_seq;//窗口大小  </span><br><span class="line">  unsigned long         fin_seq;//应答序列号  </span><br><span class="line">  //下面两个字段用于紧急数据处理  </span><br><span class="line">  unsigned long         urg_seq;//紧急数据最大序列号  </span><br><span class="line">  unsigned long         urg_data;//标志位，1表示收到紧急数据  </span><br><span class="line">  </span><br><span class="line">  /* </span><br><span class="line">   * Not all are volatile, but some are, so we </span><br><span class="line">   * might as well say they all are. </span><br><span class="line">   */  </span><br><span class="line">  volatile char                 inuse,//表示其他进程正在使用该sock结构，本进程需等待  </span><br><span class="line">                dead,//表示该sock结构已处于释放状态  </span><br><span class="line">                urginline,//=1，表示紧急数据将被当做普通数据处理  </span><br><span class="line">                intr,//  </span><br><span class="line">                blog,  </span><br><span class="line">                done,  </span><br><span class="line">                reuse,  </span><br><span class="line">                keepopen,//=1，使用保活定时器  </span><br><span class="line">                linger,//=1，表示在关闭套接字时需要等待一段时间以确认其已关闭  </span><br><span class="line">                delay_acks,//=1，表示延迟应答  </span><br><span class="line">                destroy,//=1，表示该sock结构等待销毁  </span><br><span class="line">                ack_timed,  </span><br><span class="line">                no_check,  </span><br><span class="line">                zapped, /* In ax25 &amp; ipx means not linked */  </span><br><span class="line">                broadcast,  </span><br><span class="line">                nonagle;//=1，表示不使用NAGLE算法  </span><br><span class="line">                //NAGLE算法:在前一个发送的数据包被应答之前，不可再继续发送其它数据包  </span><br><span class="line">  unsigned long             lingertime;//等待关闭操作的时间  </span><br><span class="line">  int               proc;//该sock结构所属的进程的进程号  </span><br><span class="line">  struct sock           *next;  </span><br><span class="line">  struct sock           *prev; /* Doubly linked chain.. */  </span><br><span class="line">  struct sock           *pair;  </span><br><span class="line">  //下面两个字段用于TCP协议重发队列  </span><br><span class="line">  struct sk_buff        * volatile send_head;//这个队列中的数据均已经发送出去，但尚未接收到应答  </span><br><span class="line">  struct sk_buff        * volatile send_tail;  </span><br><span class="line">  struct sk_buff_head       back_log;//接收的数据包缓存队列，当套接字正忙时，数据包暂存在这里  </span><br><span class="line">  struct sk_buff        *partial;//用于创建最大长度的待发送数据包  </span><br><span class="line">  struct timer_list     partial_timer;//定时器，用于按时发送partial指针指向的数据包  </span><br><span class="line">  long              retransmits;//重发次数  </span><br><span class="line">  struct sk_buff_head       write_queue,//指向待发送数据包  </span><br><span class="line">                receive_queue;//读队列，表示数据报已被正式接收，该队列中的数据可被应用程序读取?  </span><br><span class="line">  struct proto          *prot;//传输层处理函数集  </span><br><span class="line">  struct wait_queue     **sleep;  </span><br><span class="line">  unsigned long         daddr;//sock结构所代表套接字的远端地址  </span><br><span class="line">  unsigned long         saddr;//本地地址  </span><br><span class="line">  unsigned short        max_unacked;//最大未处理请求连接数  </span><br><span class="line">  unsigned short        window;//远端窗口大小  </span><br><span class="line">  unsigned short        bytes_rcv;//已接收字节总数  </span><br><span class="line">/* mss is min(mtu, max_window) */  </span><br><span class="line">  unsigned short        mtu; //和链路层协议密切相关      /* 最大传输单元 */  </span><br><span class="line">  volatile unsigned short   mss; //最大报文长度 =mtu-ip首部长度-tcp首部长度，也就是tcp数据包每次能够传输的最大数据分段  </span><br><span class="line">  volatile unsigned short   user_mss;  /* mss requested by user in ioctl */  </span><br><span class="line">  volatile unsigned short   max_window;//最大窗口大小  </span><br><span class="line">  unsigned long         window_clamp;//窗口大小钳制值  </span><br><span class="line">  unsigned short        num;//本地端口号  </span><br><span class="line">  //下面三个字段用于拥塞算法  </span><br><span class="line">  volatile unsigned short   cong_window;  </span><br><span class="line">  volatile unsigned short   cong_count;  </span><br><span class="line">  volatile unsigned short   ssthresh;  </span><br><span class="line">  volatile unsigned short   packets_out;//本地已发送出去但尚未得到应答的数据包数目  </span><br><span class="line">  volatile unsigned short   shutdown;//本地关闭标志位，用于半关闭操作  </span><br><span class="line">  volatile unsigned long    rtt;//往返时间估计值  </span><br><span class="line">  volatile unsigned long    mdev;//绝对偏差  </span><br><span class="line">  volatile unsigned long    rto;//用rtt和mdev 用算法计算出的延迟时间值  </span><br><span class="line">/* currently backoff isn&#x27;t used, but I&#x27;m maintaining it in case </span><br><span class="line"> * we want to go back to a backoff formula that needs it </span><br><span class="line"> */  </span><br><span class="line">  volatile unsigned short   backoff;//退避算法度量值  </span><br><span class="line">  volatile short        err;//错误标志值  </span><br><span class="line">  unsigned char         protocol;//传输层协议值  </span><br><span class="line">  volatile unsigned char    state;//套接字状态值  </span><br><span class="line">  volatile unsigned char    ack_backlog;//缓存的未应答数据包个数  </span><br><span class="line">  unsigned char         max_ack_backlog;//最大缓存的未应答数据包个数  </span><br><span class="line">  unsigned char         priority;//该套接字优先级  </span><br><span class="line">  unsigned char         debug;  </span><br><span class="line">  unsigned short        rcvbuf;//最大接收缓冲区大小  </span><br><span class="line">  unsigned short        sndbuf;//最大发送缓冲区大小  </span><br><span class="line">  unsigned short        type;//类型值如 SOCK_STREAM  </span><br><span class="line">  unsigned char         localroute;//=1,表示只使用本地路由 /* Route locally only */  </span><br><span class="line">#ifdef CONFIG_IPX  </span><br><span class="line">  ipx_address           ipx_dest_addr;  </span><br><span class="line">  ipx_interface         *ipx_intrfc;  </span><br><span class="line">  unsigned short        ipx_port;  </span><br><span class="line">  unsigned short        ipx_type;  </span><br><span class="line">#endif  </span><br><span class="line">#ifdef CONFIG_AX25  </span><br><span class="line">/* Really we want to add a per protocol private area */  </span><br><span class="line">  ax25_address          ax25_source_addr,ax25_dest_addr;  </span><br><span class="line">  struct sk_buff *volatile  ax25_retxq[8];  </span><br><span class="line">  char              ax25_state,ax25_vs,ax25_vr,ax25_lastrxnr,ax25_lasttxnr;  </span><br><span class="line">  char              ax25_condition;  </span><br><span class="line">  char              ax25_retxcnt;  </span><br><span class="line">  char              ax25_xx;  </span><br><span class="line">  char              ax25_retxqi;  </span><br><span class="line">  char              ax25_rrtimer;  </span><br><span class="line">  char              ax25_timer;  </span><br><span class="line">  unsigned char         ax25_n2;  </span><br><span class="line">  unsigned short        ax25_t1,ax25_t2,ax25_t3;  </span><br><span class="line">  ax25_digi         *ax25_digipeat;  </span><br><span class="line">#endif    </span><br><span class="line">#ifdef CONFIG_ATALK  </span><br><span class="line">  struct atalk_sock     at;  </span><br><span class="line">#endif  </span><br><span class="line">  </span><br><span class="line">/* IP &#x27;private area&#x27; or will be eventually */  </span><br><span class="line">  int               ip_ttl;//ip首部ttl字段值，实际上表示路由器跳数      /* TTL setting */  </span><br><span class="line">  int               ip_tos;//ip首部tos字段值，服务类型值       /* TOS */  </span><br><span class="line">  struct tcphdr         dummy_th;//缓存的tcp首部，在tcp协议中创建一个发送数据包时可以利用此字段快速创建tcp首部  </span><br><span class="line">  struct timer_list     keepalive_timer;//保活定时器，用于探测对方窗口大小，防止对方通报窗口大小的数据包丢弃 /* TCP keepalive hack */  </span><br><span class="line">  struct timer_list     retransmit_timer;//重发定时器，用于数据包超时重发  /* TCP retransmit timer */  </span><br><span class="line">  struct timer_list     ack_timer;//延迟应答定时器     /* TCP delayed ack timer */  </span><br><span class="line">  int               ip_xmit_timeout;//表示定时器超时原因 /* Why the timeout is running */  </span><br><span class="line">  </span><br><span class="line">//用于ip多播  </span><br><span class="line">#ifdef CONFIG_IP_MULTICAST    </span><br><span class="line">  int               ip_mc_ttl;          /* Multicasting TTL */  </span><br><span class="line">  int               ip_mc_loop;         /* Loopback (not implemented yet) */  </span><br><span class="line">  char              ip_mc_name[MAX_ADDR_LEN];   /* Multicast device name */  </span><br><span class="line">  struct ip_mc_socklist     *ip_mc_list;            /* Group array */  </span><br><span class="line">#endif    </span><br><span class="line">  </span><br><span class="line">  /* This part is used for the timeout functions (timer.c). */  </span><br><span class="line">  int               timeout;    /* What are we waiting for? */  </span><br><span class="line">  struct timer_list     timer;      /* This is the TIME_WAIT/receive timer when we are doing IP */  </span><br><span class="line">  struct timeval        stamp;  </span><br><span class="line">  </span><br><span class="line">  /* identd */  </span><br><span class="line">  //一个套接在在不同的层次上分别由socket结构和sock结构表示  </span><br><span class="line">  struct socket         *socket;  </span><br><span class="line">    </span><br><span class="line">  /* Callbacks *///回调函数  </span><br><span class="line">  void              (*state_change)(struct sock *sk);  </span><br><span class="line">  void              (*data_ready)(struct sock *sk,int bytes);  </span><br><span class="line">  void              (*write_space)(struct sock *sk);  </span><br><span class="line">  void              (*error_report)(struct sock *sk);  </span><br><span class="line">    </span><br><span class="line">&#125;;  </span><br></pre></td></tr></table></figure>

<h2 id="3、sk-buff"><a href="#3、sk-buff" class="headerlink" title="3、sk_buff"></a>3、sk_buff</h2><p>(include\linux\Skbuff.h) sk_buff 是网络数据报在内核中的表现形式，通过源码可以看出，数据包在内核协议栈中是通过这个数据结构来变现的。</p>
<p>从其中的 union 字段可以看出，该结构是贯穿在各个层的，可以说这个结构是用来为网络数据包服务的。其中的字段表明了数据包隶属的套接字、当前所处的协议层、所搭载的数据负载长度（data指针指向）、源端，目的端地址以及相关字段等。</p>
<p>主要重要的一个字段是 data[0]，这是一个指针，它指向对应层的数据报（首部+数据负载）内容的首地址。怎么解释呢？</p>
<p>如果在传输层，那么data指向的数据部分的首地址，其数据部分为 TCP 首部 + 有效数据负载。</p>
<p>如果在网络层，data指向的数据部分的首地址，其数据部分为 IP 首部 + TCP 首部 + 有效数据负载。</p>
<p>如果在链路层，data指向的首地址，其数据布局为 MAC 首部 + IP 首部 + TCP 首部 + 有效数据负载。</p>
<p>所以在该skb_buff结构传递时，获取某一层的首部，都是通过拷贝 data 指向地址对应首部大小的数据。</p>
<figure class="highlight text"><table><tr><td class="code"><pre><span class="line">  //sk_buff 结构用来封装网络数据  </span><br><span class="line">  //网络栈代码对数据的处理都是以sk_buff 结构为单元进行的  </span><br><span class="line">struct sk_buff &#123;  </span><br><span class="line">  struct sk_buff        * volatile next;  </span><br><span class="line">  struct sk_buff        * volatile prev;//构成队列  </span><br><span class="line">#if CONFIG_SKB_CHECK  </span><br><span class="line">  int               magic_debug_cookie; //调试用  </span><br><span class="line">#endif  </span><br><span class="line">  struct sk_buff        * volatile link3; //构成数据包重发队列  </span><br><span class="line">  struct sock           *sk; //数据包所属的套接字  </span><br><span class="line">  volatile unsigned long    when;    //数据包的发送时间，用于计算往返时间RTT/* used to compute rtt&#x27;s */  </span><br><span class="line">  struct timeval        stamp; //记录时间  </span><br><span class="line">  struct device         *dev; //接收该数据包的接口设备  </span><br><span class="line">  struct sk_buff        *mem_addr; //该sk_buff在内存中的基地址，用于释放该sk_buff结构  </span><br><span class="line">  //联合类型，表示数据报在不同处理层次上所到达的处理位置  </span><br><span class="line">  union &#123;  </span><br><span class="line">    struct tcphdr   *th; //传输层tcp，指向首部第一个字节位置  </span><br><span class="line">    struct ethhdr   *eth; //链路层上，指向以太网首部第一个字节位置  </span><br><span class="line">    struct iphdr    *iph; //网络层上，指向ip首部第一个字节位置  </span><br><span class="line">    struct udphdr   *uh; //传输层udp协议，  </span><br><span class="line">    unsigned char   *raw; //随层次变化而变化，链路层=eth，网络层=iph  </span><br><span class="line">    unsigned long   seq; //针对tcp协议的待发送数据包而言，表示该数据包的ACK值  </span><br><span class="line">  &#125; h;  </span><br><span class="line">  struct iphdr      *ip_hdr; //指向ip首部的指针        /* For IPPROTO_RAW */  </span><br><span class="line">  unsigned long         mem_len; //表示sk_buff结构大小加上数据部分的总长度  </span><br><span class="line">  unsigned long         len; //只表示数据部分长度，len = mem_len - sizeof(sk_buff)  </span><br><span class="line">  unsigned long         fraglen; //分片数据包个数  </span><br><span class="line">  struct sk_buff        *fraglist;  /* Fragment list */  </span><br><span class="line">  unsigned long         truesize; //同men_len  </span><br><span class="line">  unsigned long         saddr; //源端ip地址  </span><br><span class="line">  unsigned long         daddr; //目的端ip地址  </span><br><span class="line">  unsigned long         raddr; //数据包下一站ip地址     /* next hop addr */  </span><br><span class="line">   //标识字段  </span><br><span class="line">  volatile char         acked, //=1，表示数据报已得到确认，可以从重发队列中删除  </span><br><span class="line">                used, //=1，表示该数据包的数据已被应用程序读完，可以进行释放  </span><br><span class="line">                free, //用于数据包发送，=1表示再进行发送操作后立即释放，无需缓存  </span><br><span class="line">                arp; //用于待发送数据包，=1表示已完成MAC首部的建立，=0表示还不知道目的端MAC地址  </span><br><span class="line">  //已进行tries试发送，该数据包正在被其余部分使用，路由类型，数据包类型  </span><br><span class="line">  unsigned char         tries,lock,localroute,pkt_type;  </span><br><span class="line">   //下面是数据包的类型，即pkt_type的取值  </span><br><span class="line">#define PACKET_HOST     0     //发往本机    /* To us */  </span><br><span class="line">#define PACKET_BROADCAST    1 //广播  </span><br><span class="line">#define PACKET_MULTICAST    2 //多播  </span><br><span class="line">#define PACKET_OTHERHOST    3 //其他机器        /* Unmatched promiscuous */  </span><br><span class="line">  unsigned short        users; //使用该数据包的模块数     /* User count - see datagram.c (and soon seqpacket.c/stream.c) */  </span><br><span class="line">  unsigned short        pkt_class;  /* For drivers that need to cache the packet type with the skbuff (new PPP) */  </span><br><span class="line">#ifdef CONFIG_SLAVE_BALANCING  </span><br><span class="line">  unsigned short        in_dev_queue; //该字段是否正在缓存于设备缓存队列中  </span><br><span class="line">#endif    </span><br><span class="line">  unsigned long         padding[0]; //填充字节  </span><br><span class="line">  unsigned char         data[0]; //指向该层数据部分  </span><br><span class="line">  //data指向的数据负载首地址，在各个层对应不同的数据部分  </span><br><span class="line">//从侧面看出sk_buff结构基本上是贯穿整个网络栈的非常重要的一个数据结构  </span><br><span class="line">&#125;;  </span><br></pre></td></tr></table></figure>

<h2 id="4、device"><a href="#4、device" class="headerlink" title="4、device"></a>4、device</h2><p>（include\linux\Netdevice.h）该结构表明了一个网络设备需要的字段信息。</p>
<figure class="highlight text"><table><tr><td class="code"><pre><span class="line">/* </span><br><span class="line"> * The DEVICE structure. </span><br><span class="line"> * Actually, this whole structure is a big mistake.  It mixes I/O </span><br><span class="line"> * data with strictly &quot;high-level&quot; data, and it has to know about </span><br><span class="line"> * almost every data structure used in the INET module.   </span><br><span class="line"> */  </span><br><span class="line">  //网络设备结构  </span><br><span class="line">struct device   </span><br><span class="line">&#123;  </span><br><span class="line">  </span><br><span class="line">  /* </span><br><span class="line">   * This is the first field of the &quot;visible&quot; part of this structure </span><br><span class="line">   * (i.e. as seen by users in the &quot;Space.c&quot; file).  It is the name </span><br><span class="line">   * the interface. </span><br><span class="line">   */  </span><br><span class="line">  char            *name;//设备名称  </span><br><span class="line">  </span><br><span class="line">  /* I/O specific fields - FIXME: Merge these and struct ifmap into one */  </span><br><span class="line">  unsigned long       rmem_end;//设备读缓冲区空间       /* shmem &quot;recv&quot; end */  </span><br><span class="line">  unsigned long       rmem_start;       /* shmem &quot;recv&quot; start   */  </span><br><span class="line">  unsigned long       mem_end;//设备总缓冲区首地址和尾地址       /* sahared mem end  */  </span><br><span class="line">  unsigned long       mem_start;        /* shared mem start */  </span><br><span class="line">  unsigned long       base_addr;//设备寄存器读写IO基地址      /* device I/O address   */  </span><br><span class="line">  unsigned char       irq;  //设备所使用中断号      /* device IRQ number    */  </span><br><span class="line">  </span><br><span class="line">  /* Low-level status flags. */  </span><br><span class="line">  volatile unsigned char  start,//=1，表示设备已处于工作状态        /* start an operation   */  </span><br><span class="line">                          tbusy,//=1，表示设备正忙于数据包发送       /* transmitter busy */  </span><br><span class="line">                          interrupt;//=1，软件正在进行设备中断处理       /* interrupt arrived    */  </span><br><span class="line">  </span><br><span class="line">  struct device       *next;//构成设备队列  </span><br><span class="line">  </span><br><span class="line">  /* The device initialization function. Called only once. */  </span><br><span class="line">  int             (*init)(struct device *dev);//设备初始化指针(函数指针)  </span><br><span class="line">  </span><br><span class="line">  /* Some hardware also needs these fields, but they are not part of the </span><br><span class="line">     usual set specified in Space.c. */  </span><br><span class="line">  unsigned char       if_port;//指定使用的设备端口号      /* Selectable AUI, TP,..*/  </span><br><span class="line">  unsigned char       dma;//设备所用的dma通道号         /* DMA channel      */  </span><br><span class="line">  </span><br><span class="line">  struct enet_statistics* (*get_stats)(struct device *dev);//设备信息获取函数指针  </span><br><span class="line">  </span><br><span class="line">  /* </span><br><span class="line">   * This marks the end of the &quot;visible&quot; part of the structure. All </span><br><span class="line">   * fields hereafter are internal to the system, and may change at </span><br><span class="line">   * will (read: may be cleaned up at will). </span><br><span class="line">   */  </span><br><span class="line">  </span><br><span class="line">  /* These may be needed for future network-power-down code. */  </span><br><span class="line">  unsigned long       trans_start;//用于传输超时计算    /* Time (in jiffies) of last Tx */  </span><br><span class="line">  unsigned long       last_rx;//上次接收一个数据包的时间    /* Time of last Rx      */  </span><br><span class="line">  </span><br><span class="line">  unsigned short      flags;//标志位   /* interface flags (a la BSD)   */  </span><br><span class="line">  unsigned short      family;//设备所属的域协议 /* address family ID (AF_INET)  */  </span><br><span class="line">  unsigned short      metric;   /* routing metric (not used)    */  </span><br><span class="line">  unsigned short      mtu;//该接口设备的最大传输单元，ip首部+tcp首部+有效数据负载，去掉了以太网帧的帧头 /* interface MTU value*/  </span><br><span class="line">  unsigned short      type;//该设备所属硬件类型      /* interface hardware type  */  </span><br><span class="line">  unsigned short      hard_header_len;//硬件首部长度  /* hardware hdr length  */  </span><br><span class="line">  void            *priv;//私有数据指针    /* pointer to private data  */  </span><br><span class="line">  </span><br><span class="line">  /* Interface address info. */  </span><br><span class="line">  unsigned char       broadcast[MAX_ADDR_LEN];//链路层硬件广播地址   /* hw bcast add */  </span><br><span class="line">  unsigned char       dev_addr[MAX_ADDR_LEN];//本设备硬件地址  /* hw address   */  </span><br><span class="line">  unsigned char       addr_len;//硬件地址长度 /* hardware address length  */  </span><br><span class="line">  unsigned long       pa_addr;//本地ip地址  /* protocol address     */  </span><br><span class="line">  unsigned long       pa_brdaddr;//网络层广播ip地址    /* protocol broadcast addr  */  </span><br><span class="line">  unsigned long       pa_dstaddr;//点对点网络中对点的ip地址    /* protocol P-P other side addr */  </span><br><span class="line">  unsigned long       pa_mask;//ip地址网络掩码    /* protocol netmask     */  </span><br><span class="line">  unsigned short      pa_alen;//ip地址长度  /* protocol address length  */  </span><br><span class="line">  </span><br><span class="line">  struct dev_mc_list     *mc_list;//多播地址链表  /* Multicast mac addresses  */  </span><br><span class="line">  int            mc_count;//多播地址数目  /* Number of installed mcasts   */  </span><br><span class="line">    </span><br><span class="line">  struct ip_mc_list  *ip_mc_list;//网络层ip多播地址链表  /* IP multicast filter chain    */  </span><br><span class="line">      </span><br><span class="line">  /* For load balancing driver pair support */  </span><br><span class="line">    </span><br><span class="line">  unsigned long        pkt_queue;//该设备缓存的待发送的数据包个数  /* Packets queued */  </span><br><span class="line">  struct device       *slave;//从设备  /* Slave device */  </span><br><span class="line">    </span><br><span class="line">  </span><br><span class="line">  /* Pointer to the interface buffers. */  </span><br><span class="line">  struct sk_buff_head     buffs[DEV_NUMBUFFS];//设备缓存的待发送的数据包  </span><br><span class="line">  </span><br><span class="line"> //函数指针  </span><br><span class="line">  /* Pointers to interface service routines. */  </span><br><span class="line">  int             (*open)(struct device *dev);  </span><br><span class="line">  int             (*stop)(struct device *dev);  </span><br><span class="line">  int             (*hard_start_xmit) (struct sk_buff *skb,  </span><br><span class="line">                          struct device *dev);  </span><br><span class="line">  int             (*hard_header) (unsigned char *buff,  </span><br><span class="line">                      struct device *dev,  </span><br><span class="line">                      unsigned short type,  </span><br><span class="line">                      void *daddr,  </span><br><span class="line">                      void *saddr,  </span><br><span class="line">                      unsigned len,  </span><br><span class="line">                      struct sk_buff *skb);  </span><br><span class="line">  int             (*rebuild_header)(void *eth, struct device *dev,  </span><br><span class="line">                unsigned long raddr, struct sk_buff *skb);  </span><br><span class="line">  </span><br><span class="line">  //用于从接收到的数据包提取MAC首部中类型字符值，从而将数据包传送给适当的协议处理函数进行处理  </span><br><span class="line">  unsigned short      (*type_trans) (struct sk_buff *skb,  </span><br><span class="line">                     struct device *dev);  </span><br><span class="line">#define HAVE_MULTICAST             </span><br><span class="line">  void            (*set_multicast_list)(struct device *dev,  </span><br><span class="line">                     int num_addrs, void *addrs);  </span><br><span class="line">#define HAVE_SET_MAC_ADDR          </span><br><span class="line">  int             (*set_mac_address)(struct device *dev, void *addr);  </span><br><span class="line">#define HAVE_PRIVATE_IOCTL  </span><br><span class="line">  int             (*do_ioctl)(struct device *dev, struct ifreq *ifr, int cmd);  </span><br><span class="line">#define HAVE_SET_CONFIG  </span><br><span class="line">  int             (*set_config)(struct device *dev, struct ifmap *map);  </span><br><span class="line">    </span><br><span class="line">&#125;;  </span><br></pre></td></tr></table></figure>

<h2 id="5、tcp-首部格式"><a href="#5、tcp-首部格式" class="headerlink" title="5、tcp 首部格式"></a>5、tcp 首部格式</h2><figure class="highlight text"><table><tr><td class="code"><pre><span class="line"> //tcp首部格式  </span><br><span class="line"> //http://blog.csdn.net/wenqian1991/article/details/44598537  </span><br><span class="line">struct tcphdr &#123;  </span><br><span class="line">    __u16   source;//源端口号  </span><br><span class="line">    __u16   dest;//目的端口号  </span><br><span class="line">    __u32   seq;//32位序列号  </span><br><span class="line">    __u32   ack_seq;//32位确认号  </span><br><span class="line">#if defined(LITTLE_ENDIAN_BITFIELD)  </span><br><span class="line">    __u16   res1:4,//4位首部长度  </span><br><span class="line">        doff:4,//保留  </span><br><span class="line">        //下面为各个控制位  </span><br><span class="line">        fin:1,//最后控制位，表示数据已全部传输完成  </span><br><span class="line">        syn:1,//同步控制位  </span><br><span class="line">        rst:1,//重置控制位  </span><br><span class="line">        psh:1,//推控制位  </span><br><span class="line">        ack:1,//确认控制位  </span><br><span class="line">        urg:1,//紧急控制位  </span><br><span class="line">        res2:2;//  </span><br><span class="line">#elif defined(BIG_ENDIAN_BITFIELD)  </span><br><span class="line">    __u16   doff:4,  </span><br><span class="line">        res1:4,  </span><br><span class="line">        res2:2,  </span><br><span class="line">        urg:1,  </span><br><span class="line">        ack:1,  </span><br><span class="line">        psh:1,  </span><br><span class="line">        rst:1,  </span><br><span class="line">        syn:1,  </span><br><span class="line">        fin:1;  </span><br><span class="line">#else  </span><br><span class="line">#error  &quot;Adjust your &lt;asm/byteorder.h&gt; defines&quot;  </span><br><span class="line">#endif    </span><br><span class="line">    __u16   window;//16位窗口大小  </span><br><span class="line">    __u16   check;//16位校验和  </span><br><span class="line">    __u16   urg_ptr;//16位紧急指针  </span><br><span class="line">&#125;;  </span><br></pre></td></tr></table></figure>

<h2 id="6、ip-首部格式"><a href="#6、ip-首部格式" class="headerlink" title="6、ip 首部格式"></a>6、ip 首部格式</h2><figure class="highlight text"><table><tr><td class="code"><pre><span class="line"> //ip数据报，首部格式  </span><br><span class="line">struct iphdr &#123;  </span><br><span class="line">#if defined(LITTLE_ENDIAN_BITFIELD)//如果是小端模式  </span><br><span class="line">    __u8    ihl:4,//首部长度  </span><br><span class="line">        version:4;//版本  </span><br><span class="line">#elif defined (BIG_ENDIAN_BITFIELD)//大端  </span><br><span class="line">    __u8    version:4,  </span><br><span class="line">        ihl:4;  </span><br><span class="line">#else  </span><br><span class="line">#error  &quot;Please fix &lt;asm/byteorder.h&gt;&quot;  </span><br><span class="line">#endif  </span><br><span class="line">    __u8    tos;//区分服务，用语表示数据报的优先级和服务类型  </span><br><span class="line">    __u16   tot_len;//总长度，标识整个ip数据报的总长度 = 报头+数据部分  </span><br><span class="line">    __u16   id;//表示ip数据报的标识符  </span><br><span class="line">    __u16   frag_off;//片偏移  </span><br><span class="line">    __u8    ttl;//生存时间，即ip数据报在网络中传输的有效期  </span><br><span class="line">    __u8    protocol;//协议，标识此ip数据报在传输层所采用的协议类型  </span><br><span class="line">    __u16   check;//首部校验和  </span><br><span class="line">    __u32   saddr;//源地址  </span><br><span class="line">    __u32   daddr;//目的地址  </span><br><span class="line">    /*The options start here. */  </span><br><span class="line">&#125;;  </span><br></pre></td></tr></table></figure>

<h2 id="7、以太网帧帧头格式"><a href="#7、以太网帧帧头格式" class="headerlink" title="7、以太网帧帧头格式"></a>7、以太网帧帧头格式</h2><figure class="highlight text"><table><tr><td class="code"><pre><span class="line">/* This is an Ethernet frame header. */ </span><br><span class="line">struct ethhdr &#123;  </span><br><span class="line">  unsigned char     h_dest[ETH_ALEN];//目的地址 /* destination eth addr */ </span><br><span class="line">  unsigned char     h_source[ETH_ALEN];//源地址    /* source ether addr    */ </span><br><span class="line">  unsigned short    h_proto;//类型        /* packet type ID field */ </span><br><span class="line">&#125;;  </span><br></pre></td></tr></table></figure>

<h2 id="8、ARP报文报头"><a href="#8、ARP报文报头" class="headerlink" title="8、ARP报文报头"></a>8、ARP报文报头</h2><figure class="highlight text"><table><tr><td class="code"><pre><span class="line">/* </span><br><span class="line"> *  This structure defines an ethernet arp header. </span><br><span class="line"> */  </span><br><span class="line"> //ARP报文格式(arp报头)  </span><br><span class="line">struct arphdr  </span><br><span class="line">&#123;  </span><br><span class="line">    unsigned short  ar_hrd;//硬件类型       /* format of hardware address   */  </span><br><span class="line">    unsigned short  ar_pro;//上层协议类型     /* format of protocol address   */  </span><br><span class="line">    unsigned char   ar_hln;//MAC地址长度        /* length of hardware address   */  </span><br><span class="line">    unsigned char   ar_pln;//协议地址长度     /* length of protocol address   */  </span><br><span class="line">    unsigned short  ar_op;//操作类型        /* ARP opcode (command)     */  </span><br><span class="line">  </span><br><span class="line">#if 0  </span><br><span class="line">     /* </span><br><span class="line">      *  Ethernet looks like this : This bit is variable sized however... </span><br><span class="line">      */  </span><br><span class="line">    unsigned char       ar_sha[ETH_ALEN];//源MAC地址   /* sender hardware address  */  </span><br><span class="line">    unsigned char       ar_sip[4];//源IP地址       /* sender IP address        */  </span><br><span class="line">    unsigned char       ar_tha[ETH_ALEN];//目的MAC地址  /* target hardware address  */  </span><br><span class="line">    unsigned char       ar_tip[4];//目的IP地址      /* target IP address        */  </span><br><span class="line">#endif  </span><br><span class="line">  </span><br><span class="line">&#125;;  </span><br></pre></td></tr></table></figure>

<hr>
<p>版权声明：本文为知乎博主「<a href="https://www.zhihu.com/people/linuxwang-xian-sheng">极致Linux内核</a>」的原创文章，遵循CC 4.0 BY-SA版权协议，转载请附上原文出处链接及本声明。</p>
<p>原文链接：<a href="https://zhuanlan.zhihu.com/p/549140581">https://zhuanlan.zhihu.com/p/549140581</a></p>
]]></content>
      <categories>
        <category>linux-doc 网络协议栈</category>
      </categories>
      <tags>
        <tag>Linux</tag>
      </tags>
  </entry>
  <entry>
    <title>Linux操作系统原理—内核网络协议栈</title>
    <url>/2023/01/15/linux-docs/%E7%BD%91%E7%BB%9C%E5%8D%8F%E8%AE%AE%E6%A0%88/Linux%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E5%8E%9F%E7%90%86%E2%80%94%E5%86%85%E6%A0%B8%E7%BD%91%E7%BB%9C%E5%8D%8F%E8%AE%AE%E6%A0%88/</url>
    <content><![CDATA[<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>本文主要记录 Linux 内核网络协议栈的运行原理</p>
<h3 id="数据报文的封装与分用"><a href="#数据报文的封装与分用" class="headerlink" title="数据报文的封装与分用"></a>数据报文的封装与分用</h3><p><img src="https://img13.360buyimg.com/ddimg/jfs/t1/182975/33/16226/290860/610116feE9737eeb9/80bd9aa6acfae3ca.png" alt="img.png"></p>
<p>封装：当应用程序用 TCP 协议传送数据时，数据首先进入内核网络协议栈中，然后逐一通过 TCP&#x2F;IP 协议族的每层直到被当作一串比特流送入网络。对于每一层而言，对收到的数据都会封装相应的协议首部信息（有时还会增加尾部信息）。TCP 协议传给 IP 协议的数据单元称作 TCP 报文段，或简称 TCP 段（TCP segment）。IP 传给数据链路层的数据单元称作 IP 数据报（IP datagram），最后通过以太网传输的比特流称作帧（Frame）</p>
<p><img src="https://img10.360buyimg.com/ddimg/jfs/t1/187549/40/15407/142770/610116fdEaecb144d/42e0689805e556fc.png" alt="img.png"></p>
<p>分用：当目的主机收到一个以太网数据帧时，数据就开始从内核网络协议栈中由底向上升，同时去掉各层协议加上的报文首部。每层协议都会检查报文首部中的协议标识，以确定接收数据的上层协议。这个过程称作分用。</p>
<p><img src="https://img13.360buyimg.com/ddimg/jfs/t1/180869/34/16538/384674/610116fdE6ce6c950/d42c62b0d82c41e4.png" alt="img.png"></p>
<h2 id="Linux-内核网络协议栈"><a href="#Linux-内核网络协议栈" class="headerlink" title="Linux 内核网络协议栈"></a>Linux 内核网络协议栈</h2><h3 id="协议栈的全景图"><a href="#协议栈的全景图" class="headerlink" title="协议栈的全景图"></a>协议栈的全景图</h3><p><img src="https://img10.360buyimg.com/ddimg/jfs/t1/195665/6/15277/400984/610116fdE65683238/f59c2e167eaedd09.png" alt="img.png"></p>
<h3 id="协议栈的分层结构"><a href="#协议栈的分层结构" class="headerlink" title="协议栈的分层结构"></a>协议栈的分层结构</h3><p><img src="https://img13.360buyimg.com/ddimg/jfs/t1/190516/13/15338/42356/610116fcE4a405462/0bf912c37bbfe692.png" alt="img.png"></p>
<p><img src="https://img13.360buyimg.com/ddimg/jfs/t1/194294/8/15433/60844/610116fdEe1e5eab4/f014ca04c2ce0d56.png" alt="img.png"></p>
<p><strong>逻辑抽象层级：</strong></p>
<p>物理层：主要提供各种连接的物理设备，如各种网卡，串口卡等。</p>
<p>链路层：主要提供对物理层进行访问的各种接口卡的驱动程序，如网卡驱动等。</p>
<p>网路层：是负责将网络数据包传输到正确的位置，最重要的网络层协议是 IP 协议，此外还有如 ICMP，ARP，RARP 等协议。</p>
<p>传输层：为应用程序之间提供端到端连接，主要为 TCP 和 UDP 协议。</p>
<p>应用层：顾名思义，主要由应用程序提供，用来对传输数据进行语义解释的 “人机交互界面层”，比如 HTTP，SMTP，FTP 等协议。</p>
<p><strong>协议栈实现层级：</strong></p>
<p>硬件层（Physical device hardware）：又称驱动程序层，提供连接硬件设备的接口。</p>
<p>设备无关层（Device agnostic interface）：又称设备接口层，提供与具体设备无关的驱动程序抽象接口。这一层的目的主要是为了统一不同的接口卡的驱动程序与网络协议层的接口，它将各种不同的驱动程序的功能统一抽象为几个特殊的动作，如 open，close，init 等，这一层可以屏蔽底层不同的驱动程序。</p>
<p>网络协议层（Network protocols）：对应 IP layer 和 Transport layer。毫无疑问，这是整个内核网络协议栈的核心。这一层主要实现了各种网络协议，最主要的当然是 IP，ICMP，ARP，RARP，TCP，UDP 等。</p>
<p>协议无关层（Protocol agnostic interface），又称协议接口层，本质就是 SOCKET 层。这一层的目的是屏蔽网络协议层中诸多类型的网络协议（主要是 TCP 与 UDP 协议，当然也包括 RAW IP， SCTP 等等），以便提供简单而同一的接口给上面的系统调用层调用。简单的说，不管我们应用层使用什么协议，都要通过系统调用接口来建立一个 SOCKET，这个 SOCKET 其实是一个巨大的 sock 结构体，它和下面的网络协议层联系起来，屏蔽了不同的网络协议，通过系统调用接口只把数据部分呈献给应用层。</p>
<p>BSD（Berkeley Software Distribution）socket：BSD Socket 层，提供统一的 SOCKET 操作接口，与 socket 结构体关系紧密。</p>
<p>INET（指一切支持 IP 协议的网络） socket：INET socket 层，调用 IP 层协议的统一接口，与 sock 结构体关系紧密。</p>
<p>系统调用接口层（System call interface），实质是一个面向用户空间（User Space）应用程序的接口调用库，向用户空间应用程序提供使用网络服务的接口。</p>
<p><img src="https://img10.360buyimg.com/ddimg/jfs/t1/197372/39/266/109964/610116fdEcdc170ab/dd6436eded9c9c95.jpg" alt="img.jpeg"></p>
<h3 id="协议栈的数据结构"><a href="#协议栈的数据结构" class="headerlink" title="协议栈的数据结构"></a>协议栈的数据结构</h3><p><img src="https://img12.360buyimg.com/ddimg/jfs/t1/187491/17/15299/231260/610116fdE3c89d3d5/d5447bc620ef3a94.png" alt="img.png"></p>
<p>msghdr：描述了从应用层传递下来的消息格式，包含有用户空间地址，消息标记等重要信息。</p>
<p>iovec：描述了用户空间地址的起始位置。</p>
<p>file：描述文件属性的结构体，与文件描述符一一对应。</p>
<p>file_operations：文件操作相关结构体，包括 read()、write()、open()、ioctl() 等。</p>
<p>socket：向应用层提供的 BSD socket 操作结构体，协议无关，主要作用为应用层提供统一的 Socket 操作。</p>
<p>sock：网络层 sock，定义与协议无关操作，是网络层的统一的结构，传输层在此基础上实现了 inet_sock。</p>
<p>sock_common：最小网络层表示结构体。</p>
<p>inet_sock：表示层结构体，在 sock 上做的扩展，用于在网络层之上表示 inet 协议族的的传输层公共结构体。</p>
<p>udp_sock：传输层 UDP 协议专用 sock 结构，在传输层 inet_sock 上扩展。</p>
<p>proto_ops：BSD socket 层到 inet_sock 层接口，主要用于操作 socket 结构。</p>
<p>proto：inet_sock 层到传输层操作的统一接口，主要用于操作 sock 结构。</p>
<p>net_proto_family：用于标识和注册协议族，常见的协议族有 IPv4、IPv6。</p>
<p>softnet_data：内核为每个 CPU 都分配一个这样的 softnet_data 数据空间。每个 CPU 都有一个这样的队列，用于接收数据包。</p>
<p>sk_buff：描述一个帧结构的属性，包含 socket、到达时间、到达设备、各层首部大小、下一站路由入口、帧长度、校验和等等。</p>
<p>sk_buff_head：数据包队列结构。</p>
<p>net_device：这个巨大的结构体描述一个网络设备的所有属性，数据等信息。</p>
<p>inet_protosw：向 IP 层注册 socket 层的调用操作接口。</p>
<p>inetsw_array：socket 层调用 IP 层操作接口都在这个数组中注册。</p>
<p>sock_type：socket 类型。</p>
<p>IPPROTO：传输层协议类型 ID。</p>
<p>net_protocol：用于传输层协议向 IP 层注册收包的接口。</p>
<p>packet_type：以太网数据帧的结构，包括了以太网帧类型、处理方法等。</p>
<p>rtable：路由表结构，描述一个路由表的完整形态。</p>
<p>rt_hash_bucket：路由表缓存。</p>
<p>dst_entry：包的去向接口，描述了包的去留，下一跳等路由关键信息。</p>
<p>napi_struct：NAPI 调度的结构。NAPI 是 Linux 上采用的一种提高网络处理效率的技术，它的核心概念就是不采用中断的方式读取数据，而代之以首先采用中断唤醒数据接收服务，然后采用 poll 的方法来轮询数据。NAPI 技术适用于高速率的短长度数据包的处理。</p>
<h3 id="网络协议栈初始化流程"><a href="#网络协议栈初始化流程" class="headerlink" title="网络协议栈初始化流程"></a>网络协议栈初始化流程</h3><p>这需要从内核启动流程说起。当内核完成自解压过程后进入内核启动流程，这一过程先在 arch&#x2F;mips&#x2F;kernel&#x2F;head.S 程序中，这个程序负责数据区（BBS）、中断描述表（IDT）、段描述表（GDT）、页表和寄存器的初始化，程序中定义了内核的入口函数 kernel_entry()、kernel_entry() 函数是体系结构相关的汇编代码，它首先初始化内核堆栈段为创建系统中的第一过程进行准备，接着用一段循环将内核映像的未初始化的数据段清零，最后跳到 start_kernel() 函数中初始化硬件相关的代码，完成 Linux Kernel 环境的建立。</p>
<p>start_kenrel() 定义在 init&#x2F;main.c 中，真正的内核初始化过程就是从这里才开始。函数 start_kerenl() 将会调用一系列的初始化函数，如：平台初始化，内存初始化，陷阱初始化，中断初始化，进程调度初始化，缓冲区初始化，完成内核本身的各方面设置，目的是最终建立起基本完整的 Linux 内核环境。</p>
<p>start_kernel() 中主要函数及调用关系如下：</p>
<p><img src="https://img14.360buyimg.com/ddimg/jfs/t1/192345/20/15345/58625/610116fdE002185b0/4ebe05711c43481c.png" alt="img.png"></p>
<p>start_kernel() 的过程中会执行 socket_init() 来完成协议栈的初始化，实现如下：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">sock_init</span><span class="params">(<span class="type">void</span>)</span><span class="comment">//网络栈初始化</span></span><br><span class="line">&#123;</span><br><span class="line">	<span class="type">int</span> i;</span><br><span class="line"> </span><br><span class="line">	printk(<span class="string">&quot;Swansea University Computer Society NET3.019\n&quot;</span>);</span><br><span class="line"> </span><br><span class="line">	<span class="comment">/*</span></span><br><span class="line"><span class="comment">	 *	Initialize all address (protocol) families. </span></span><br><span class="line"><span class="comment">	 */</span></span><br><span class="line">	 </span><br><span class="line">	<span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; NPROTO; ++i) pops[i] = <span class="literal">NULL</span>;</span><br><span class="line"> </span><br><span class="line">	<span class="comment">/*</span></span><br><span class="line"><span class="comment">	 *	Initialize the protocols module. </span></span><br><span class="line"><span class="comment">	 */</span></span><br><span class="line"> </span><br><span class="line">	proto_init();</span><br><span class="line"> </span><br><span class="line"><span class="meta">#<span class="keyword">ifdef</span> CONFIG_NET</span></span><br><span class="line">	<span class="comment">/* </span></span><br><span class="line"><span class="comment">	 *	Initialize the DEV module. </span></span><br><span class="line"><span class="comment">	 */</span></span><br><span class="line"> </span><br><span class="line">	dev_init();</span><br><span class="line">  </span><br><span class="line">	<span class="comment">/*</span></span><br><span class="line"><span class="comment">	 *	And the bottom half handler </span></span><br><span class="line"><span class="comment">	 */</span></span><br><span class="line"> </span><br><span class="line">	bh_base[NET_BH].routine= net_bh;</span><br><span class="line">	enable_bh(NET_BH);</span><br><span class="line"><span class="meta">#<span class="keyword">endif</span>  </span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><img src="https://img10.360buyimg.com/ddimg/jfs/t1/195262/31/15211/90524/610116fdE38974f1d/7f22fc5985e9639b.jpg" alt="img.jpeg"></p>
<p>sock_init() 包含了内核协议栈的初始化工作：</p>
<p>sock_init：Initialize sk_buff SLAB cache，注册 SOCKET 文件系统。</p>
<p>net_inuse_init：为每个 CPU 分配缓存。</p>
<p>proto_init：在 &#x2F;proc&#x2F;net 域下建立 protocols 文件，注册相关文件操作函数。</p>
<p>net_dev_init：建立 netdevice 在 &#x2F;proc&#x2F;sys 相关的数据结构，并且开启网卡收发中断；为每个 CPU 初始化一个数据包接收队列（softnet_data），包接收的回调；注册本地回环操作，注册默认网络设备操作。</p>
<p>inet_init：注册 INET 协议族的 SOCKET 创建方法，注册 TCP、UDP、ICMP、IGMP 接口基本的收包方法。为 IPv4 协议族创建 proc 文件。此函数为协议栈主要的注册函数：</p>
<p>rc &#x3D; proto_register(&amp;udp_prot, 1);：注册 INET 层 UDP 协议，为其分配快速缓存。</p>
<p>(void)sock_register(&amp;inet_family_ops);：向 static const struct net_proto_family *net_families[NPROTO] 结构体注册 INET 协议族的操作集合（主要是 INET socket 的创建操作）。</p>
<p>inet_add_protocol(&amp;udp_protocol, IPPROTO_UDP) &lt; 0;：向 externconst struct net_protocol *inet_protos[MAX_INET_PROTOS] 结构体注册传输层 UDP 的操作集合。</p>
<p>static struct list_head inetsw[SOCK_MAX]; for (r &#x3D; &amp;inetsw[0]; r &lt; &amp;inetsw[SOCK_MAX];++r) INIT_LIST_HEAD(r);：初始化 SOCKET 类型数组，其中保存了这是个链表数组，每个元素是一个链表，连接使用同种 SOCKET 类型的协议和操作集合。</p>
<p>for (q &#x3D; inetsw_array; q &lt; &amp;inetsw_array[INETSW_ARRAY_LEN]; ++q)：</p>
<p>inet_register_protosw(q);：向 sock 注册协议的的调用操作集合。</p>
<p>arp_init();：启动 ARP 协议支持。</p>
<p>ip_init();：启动 IP 协议支持。</p>
<p>udp_init();：启动 UDP 协议支持。</p>
<p>dev_add_pack(&amp;ip_packet_type);：向 ptype_base[PTYPE_HASH_SIZE]; 注册 IP 协议的操作集合。</p>
<p>socket.c 提供的系统调用接口。</p>
<p><img src="https://img11.360buyimg.com/ddimg/jfs/t1/194186/27/15435/41198/610116fdE0d78136b/cd5b4a31b4b03c13.png" alt="img.png"></p>
<p><a href="https://imgtu.com/i/WTgxRx"><img src="https://z3.ax1x.com/2021/07/28/WTgxRx.md.png" alt="WTgxRx.md.png"></a></p>
<p>协议栈初始化完成后再执行 dev_init()，继续设备的初始化。</p>
<h2 id="Socket-创建流程"><a href="#Socket-创建流程" class="headerlink" title="Socket 创建流程"></a>Socket 创建流程</h2><p><img src="https://img13.360buyimg.com/ddimg/jfs/t1/184848/1/16195/218607/610116fdE9d6713c7/cb280d149a71b5f3.png" alt="img.png"></p>
<h2 id="协议栈收包流程概述"><a href="#协议栈收包流程概述" class="headerlink" title="协议栈收包流程概述"></a>协议栈收包流程概述</h2><p>硬件层与设备无关层：硬件监听物理介质，进行数据的接收，当接收的数据填满了缓冲区，硬件就会产生中断，中断产生后，系统会转向中断服务子程序。在中断服务子程序中，数据会从硬件的缓冲区复制到内核的空间缓冲区，并包装成一个数据结构（sk_buff），然后调用对驱动层的接口函数 netif_rx() 将数据包发送给设备无关层。该函数的实现在 net&#x2F;inet&#x2F;dev.c 中，采用了 bootom half 技术，该技术的原理是将中断处理程序人为的分为两部分，上半部分是实时性要求较高的任务，后半部分可以稍后完成，这样就可以节省中断程序的处理时间，整体提高了系统的性能。</p>
<p>NOTE：在整个协议栈实现中 dev.c 文件的作用重大，它衔接了其下的硬件层和其上的网络协议层，可以称它为链路层模块，或者设备无关层的实现。</p>
<p>网络协议层：就以 IP 数据报为例，从设备无关层向网络协议层传递时会调用 ip_rcv()。该函数会根据 IP 首部中使用的传输层协议来调用相应协议的处理函数。UDP 对应 udp_rcv()、TCP 对应 tcp_rcv()、ICMP 对应 icmp_rcv()、IGMP 对应 igmp_rcv()。以 tcp_rcv() 为例，所有使用 TCP 协议的套接字对应的 sock 结构体都被挂入 tcp_prot 全局变量表示的 proto 结构之 sock_array 数组中，采用以本地端口号为索引的插入方式。所以，当 tcp_rcv() 接收到一个数据包，在完成必要的检查和处理后，其将以 TCP 协议首部中目的端口号为索引，在 tcp_prot 对应的 sock 结构体之 sock_array 数组中得到正确的 sock 结构体队列，再辅之以其他条件遍历该队列进行对应 sock 结构体的查询，在得到匹配的 sock 结构体后，将数据包挂入该 sock 结构体中的缓存队列中（由 sock 结构体中的 receive_queue 字段指向），从而完成数据包的最终接收。</p>
<p>NOTE：虽然这里的 ICMP、IGMP 通常被划分为网络层协议，但是实际上他们都封装在 IP 协议里面，作为传输层对待。</p>
<p>协议无关层和系统调用接口层：当用户需要接收数据时，首先根据文件描述符 inode 得到 socket 结构体和 sock 结构体，然后从 sock 结构体中指向的队列 recieve_queue 中读取数据包，将数据包 copy 到用户空间缓冲区。数据就完整的从硬件中传输到用户空间。这样也完成了一次完整的从下到上的传输。</p>
<h2 id="协议栈发包流程概述"><a href="#协议栈发包流程概述" class="headerlink" title="协议栈发包流程概述"></a>协议栈发包流程概述</h2><p>1、应用层可以通过系统调用接口层或文件操作来调用内核函数，BSD socket 层的 sock_write() 会调用 INET socket 层的 inet_wirte()。INET socket 层会调用具体传输层协议的 write 函数，该函数是通过调用本层的 inet_send() 来实现的，inet_send() 的 UDP 协议对应的函数为 udp_write()。</p>
<p>2、在传输层 udp_write() 调用本层的 udp_sendto() 完成功能。udp_sendto() 完成 sk_buff 结构体相应的设置和报头的填写后会调用 udp_send() 来发送数据。而在 udp_send() 中，最后会调用 ip_queue_xmit() 将数据包下放的网络层。</p>
<p>3、在网络层，函数 ip_queue_xmit() 的功能是将数据包进行一系列复杂的操作，比如是检查数据包是否需要分片，是否是多播等一系列检查，最后调用 dev_queue_xmit() 发送数据。</p>
<p>4、在链路层中，函数调用会调用具体设备提供的发送函数来发送数据包，e.g. dev-&gt;hard_start_xmit(skb, dev);。具体设备的发送函数在协议栈初始化的时候已经设置了。这里以 8390 网卡为例来说明驱动层的工作原理，在 net&#x2F;drivers&#x2F;8390.c 中函数 ethdev_init() 的设置如下：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">/* Initialize the rest of the 8390 device structure. */</span>  </span><br><span class="line"><span class="type">int</span> <span class="title function_">ethdev_init</span><span class="params">(<span class="keyword">struct</span> device *dev)</span>  </span><br><span class="line">&#123;  </span><br><span class="line">    <span class="keyword">if</span> (ei_debug &gt; <span class="number">1</span>)  </span><br><span class="line">        printk(version);  </span><br><span class="line">      </span><br><span class="line">    <span class="keyword">if</span> (dev-&gt;priv == <span class="literal">NULL</span>) &#123; <span class="comment">//申请私有空间  </span></span><br><span class="line">        <span class="class"><span class="keyword">struct</span> <span class="title">ei_device</span> *<span class="title">ei_local</span>;</span> <span class="comment">//8390 网卡设备的结构体  </span></span><br><span class="line">          </span><br><span class="line">        dev-&gt;priv = kmalloc(<span class="keyword">sizeof</span>(<span class="keyword">struct</span> ei_device), GFP_KERNEL); <span class="comment">//申请内核内存空间  </span></span><br><span class="line">        <span class="built_in">memset</span>(dev-&gt;priv, <span class="number">0</span>, <span class="keyword">sizeof</span>(<span class="keyword">struct</span> ei_device));  </span><br><span class="line">        ei_local = (<span class="keyword">struct</span> ei_device *)dev-&gt;priv;  </span><br><span class="line"><span class="meta">#<span class="keyword">ifndef</span> NO_PINGPONG  </span></span><br><span class="line">        ei_local-&gt;pingpong = <span class="number">1</span>;  </span><br><span class="line"><span class="meta">#<span class="keyword">endif</span>  </span></span><br><span class="line">    &#125;  </span><br><span class="line">      </span><br><span class="line">    <span class="comment">/* The open call may be overridden by the card-specific code. */</span>  </span><br><span class="line">    <span class="keyword">if</span> (dev-&gt;open == <span class="literal">NULL</span>)  </span><br><span class="line">        dev-&gt;open = &amp;ei_open; <span class="comment">// 设备的打开函数  </span></span><br><span class="line">    <span class="comment">/* We should have a dev-&gt;stop entry also. */</span>  </span><br><span class="line">    dev-&gt;hard_start_xmit = &amp;ei_start_xmit; <span class="comment">// 设备的发送函数，定义在 8390.c 中  </span></span><br><span class="line">    dev-&gt;get_stats   = get_stats;  </span><br><span class="line"><span class="meta">#<span class="keyword">ifdef</span> HAVE_MULTICAST  </span></span><br><span class="line">    dev-&gt;set_multicast_list = &amp;set_multicast_list;  </span><br><span class="line"><span class="meta">#<span class="keyword">endif</span>  </span></span><br><span class="line">  </span><br><span class="line">    ether_setup(dev);  </span><br><span class="line">          </span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;  </span><br><span class="line">&#125;  </span><br></pre></td></tr></table></figure>
<h2 id="UDP-的收发包流程总览"><a href="#UDP-的收发包流程总览" class="headerlink" title="UDP 的收发包流程总览"></a>UDP 的收发包流程总览</h2><p><img src="https://img11.360buyimg.com/ddimg/jfs/t1/188115/9/15656/852324/61011704Ec8a86952/d68ee937ad7c4289.png" alt="img.png"></p>
<h2 id="内核中断收包流程"><a href="#内核中断收包流程" class="headerlink" title="内核中断收包流程"></a>内核中断收包流程</h2><p><img src="https://img12.360buyimg.com/ddimg/jfs/t1/197002/23/274/324391/610116fdE9835a62d/f242d794832ae1bb.png" alt="35.png"></p>
<h2 id="UDP-收包流程"><a href="#UDP-收包流程" class="headerlink" title="UDP 收包流程"></a>UDP 收包流程</h2><p><a href="https://imgtu.com/i/WTgrxf"><img src="https://z3.ax1x.com/2021/07/28/WTgrxf.png" alt="WTgrxf.png"></a></p>
<h2 id="UDP-发包流程"><a href="#UDP-发包流程" class="headerlink" title="UDP 发包流程"></a>UDP 发包流程</h2><p><a href="https://imgtu.com/i/WTgDRP"><img src="https://z3.ax1x.com/2021/07/28/WTgDRP.png" alt="WTgDRP.png"></a></p>
]]></content>
      <categories>
        <category>linux-doc 网络协议栈</category>
      </categories>
      <tags>
        <tag>Linux</tag>
      </tags>
  </entry>
  <entry>
    <title>Linux网络栈解剖</title>
    <url>/2023/01/15/linux-docs/%E7%BD%91%E7%BB%9C%E5%8D%8F%E8%AE%AE%E6%A0%88/Linux%E7%BD%91%E7%BB%9C%E6%A0%88%E8%A7%A3%E5%89%96/</url>
    <content><![CDATA[<p>Linux®操作系统的最大功能之一是其网络栈。它最初是BSD协议栈的衍生物，并且组织良好，具有一组干净的接口。其接口范围从协议无关接口（如通用socket层接口或设备层）到各个网络协议的特定接口。本文从网络栈各层的角度探讨了Linux网络栈的结构，并探讨了其一些主要结构体。</p>
<h2 id="协议介绍"><a href="#协议介绍" class="headerlink" title="协议介绍"></a>协议介绍</h2><p>虽然网络的正式介绍通常是指七层开放系统互连（OSI）模型，但是Linux中基本网络栈的介绍使用互联网模型的四层模型（参见图1）。</p>
<p><img src="https://img12.360buyimg.com/ddimg/jfs/t1/182952/10/16228/6387/61012015E56d726da/9b8c1e58a2635777.gif" alt="img.gif"></p>
<p>网络栈的底部是链路层。链路层是指提供访问物理层的设备驱动程序（物理层可以是各种各样的介质，诸如串行链路或以太网设备）。链路层上面是网络层，负责将数据包引导到目的地。再上一层是传输层，它负责点对点通信（例如，在主机内，像ssh 127.0.0.1）。网络层管理主机之间的通信，传输层管理这些主机之上的端点(Endpoint)之间的通信。最后是应用层，即可以理解所传输的数据的语义层。</p>
<p><img src="https://img12.360buyimg.com/ddimg/jfs/t1/196097/34/15194/8452/61012015E241a710d/4f4d9339d4d41d04.gif" alt="img.gif"></p>
<h2 id="核心网络架构"><a href="#核心网络架构" class="headerlink" title="核心网络架构"></a>核心网络架构</h2><p>现在讨论Linux网络栈的架构以及它如何实现Internet模型。图2提供了Linux网络栈的高级视图。顶部是定义网络栈用户的用户空间层或应用层。底部是提供与网络（串行或高速网络（如以太网））连接的物理设备。在中间的内核空间，是本文重点要讨论的网络子系统。通过网络栈的内部流量socket缓冲区（sk_buffs），它们在源和目的之间移动数据包数据。你很快会看到sk_buff结构。</p>
<p>首先简要介绍Linux网络子系统的核心元素，当然后面还会有更详细的介绍。在顶部（见图2）是系统调用接口。这只是为用户空间应用程序提供访问内核网络子系统的一种方式。接下来是一个协议无关的层，提供了一种常用的方法来处理底层的传输层协议。接下来是实际的协议，在Linux中包括TCP，UDP和IP的内置协议。接下来是另一个设备无关的层，它允许使用通用接口与单个设备驱动程序交互，之后是各个设备驱动程序本身。</p>
<h3 id="系统调用接口"><a href="#系统调用接口" class="headerlink" title="系统调用接口"></a>系统调用接口</h3><p>系统调用接口可以从两个角度进行描述。当用户进行网络调用时，通过系统调用接口多路复用到内核中。这最终作为 <code>sys_socketcall(./net/socket.c)</code>中的调用，然后进一步解复用到其预期目标的调用。</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">SYSCALL_DEFINE3(socket, <span class="type">int</span>, family, <span class="type">int</span>, type, <span class="type">int</span>, protocol)</span><br><span class="line">SYSCALL_DEFINE3(bind, <span class="type">int</span>, fd, <span class="keyword">struct</span> sockaddr __user *, umyaddr, <span class="type">int</span>, addrlen)</span><br><span class="line">SYSCALL_DEFINE2(listen, <span class="type">int</span>, fd, <span class="type">int</span>, backlog)</span><br><span class="line">SYSCALL_DEFINE3(accept, <span class="type">int</span>, fd, <span class="keyword">struct</span> sockaddr __user *, upeer_sockaddr,</span><br><span class="line">		<span class="type">int</span> __user *, upeer_addrlen)</span><br><span class="line">        SYSCALL_DEFINE3(connect, <span class="type">int</span>, fd, <span class="keyword">struct</span> sockaddr __user *, uservaddr,</span><br><span class="line">        		<span class="type">int</span>, addrlen)</span><br><span class="line">...</span><br></pre></td></tr></table></figure>

<p>系统调用接口的另一个角度是使用正常的文件操作进行网络I&#x2F;O。例如，典型的读写操作可以在网络socket（由文件描述符表示，就像普通文件）一样执行。因此，虽然存在一些特定于网络的操作（调用socket创建socket，调用connect将socket连接到目的地等等），但还是有一些适用于网络对象的标准文件操作，就像常规文件一样。</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">static</span> <span class="type">const</span> <span class="class"><span class="keyword">struct</span> <span class="title">file_operations</span> <span class="title">socket_file_ops</span> =</span> &#123;</span><br><span class="line">	.owner =	THIS_MODULE,</span><br><span class="line">	.llseek =	no_llseek,</span><br><span class="line">	.read_iter =	sock_read_iter,</span><br><span class="line">	.write_iter =	sock_write_iter,</span><br><span class="line"><span class="keyword">struct</span> file *sock_alloc_file(<span class="keyword">struct</span> socket *sock, <span class="type">int</span> flags, <span class="type">const</span> <span class="type">char</span> *dname)</span><br><span class="line">&#123;</span><br><span class="line">    file = alloc_file(&amp;path, FMODE_READ | FMODE_WRITE,</span><br><span class="line">		  &amp;socket_file_ops);</span><br></pre></td></tr></table></figure>

<p>最后，系统调用接口提供了在用户空间应用程序和内核之间传输控制的手段。</p>
<h3 id="协议无关接口"><a href="#协议无关接口" class="headerlink" title="协议无关接口"></a>协议无关接口</h3><p>socket层是协议无关接口，其提供一组通用功能，以支持各种不同的协议。socket层不仅支持典型的TCP和UDP协议，还支持IP，原始以太网和其他传输协议，如流控制传输协议（SCTP）。</p>
<p>网络栈使用socket通信。Linux中的socket结构struct sock是在linux&#x2F;include&#x2F;net&#x2F;sock.h中定义的。该大型结构包含特定socket的所有必需状态，包括socket使用的特定协议以及可能在其上执行的操作。</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">sock</span> &#123;</span></span><br><span class="line">	<span class="comment">/*</span></span><br><span class="line"><span class="comment">	 * Now struct inet_timewait_sock also uses sock_common, so please just</span></span><br><span class="line"><span class="comment">	 * don&#x27;t add nothing before this first member (__sk_common) --acme</span></span><br><span class="line"><span class="comment">	 */</span></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">sock_common</span>	__<span class="title">sk_common</span>;</span></span><br><span class="line">    <span class="meta">#<span class="keyword">define</span> sk_prot			__sk_common.skc_prot</span></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">proto</span>		*<span class="title">sk_prot_creator</span>;</span></span><br></pre></td></tr></table></figure>

<p>网络子系统通过定义了其功能的特殊结构（即proto）来了解各个可用协议。每个协议维护一个名为proto（在linux&#x2F;include&#x2F;net&#x2F;sock.h中找到）的结构。该结构定义了可以从socket层到传输层执行的特定socket操作（例如，如何创建socket，如何与socket建立连接，如何关闭socket等）。</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">proto</span> <span class="title">tcp_prot</span> =</span> &#123;</span><br><span class="line">	.name			= <span class="string">&quot;TCP&quot;</span>,</span><br><span class="line">	.owner			= THIS_MODULE,</span><br><span class="line">	.close			= tcp_close,</span><br><span class="line">	.connect		= tcp_v4_connect,</span><br><span class="line">	.disconnect		= tcp_disconnect,</span><br><span class="line">	.accept			= inet_csk_accept,</span><br><span class="line">...</span><br></pre></td></tr></table></figure>

<h3 id="网络协议"><a href="#网络协议" class="headerlink" title="网络协议"></a>网络协议</h3><p>网络协议部分定义了可用的特定网络协议（如TCP，UDP等）。这些是在linux&#x2F;net&#x2F;ipv4&#x2F;af_inet.c中的inet_init函数的开头进行初始化的（因为TCP和UDP是协议inet族的一部分）。inet_init函数调用proto_register注册每个内置协议。proto_register在linux&#x2F;net&#x2F;core&#x2F;sock.c中定义，除了将协议添加到活动协议列表之外，还可以根据需要分配一个或多个slab缓存。</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">proto_register</span><span class="params">(<span class="keyword">struct</span> proto *prot, <span class="type">int</span> alloc_slab)</span></span><br><span class="line">&#123;</span><br><span class="line">	<span class="keyword">if</span> (alloc_slab) &#123;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">	mutex_lock(&amp;proto_list_mutex);</span><br><span class="line">	list_add(&amp;prot-&gt;node, &amp;proto_list);</span><br><span class="line">	assign_proto_idx(prot);</span><br><span class="line">	mutex_unlock(&amp;proto_list_mutex);</span><br><span class="line"><span class="type">static</span> <span class="type">int</span> __init <span class="title function_">inet_init</span><span class="params">(<span class="type">void</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">inet_protosw</span> *<span class="title">q</span>;</span></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">list_head</span> *<span class="title">r</span>;</span></span><br><span class="line">	<span class="type">int</span> rc = -EINVAL;</span><br><span class="line"></span><br><span class="line">	sock_skb_cb_check_size(<span class="keyword">sizeof</span>(<span class="keyword">struct</span> inet_skb_parm));</span><br><span class="line"></span><br><span class="line">	rc = proto_register(&amp;tcp_prot, <span class="number">1</span>);</span><br><span class="line">	<span class="keyword">if</span> (rc)</span><br><span class="line">		<span class="keyword">goto</span> out;</span><br><span class="line"></span><br><span class="line">	rc = proto_register(&amp;udp_prot, <span class="number">1</span>);</span><br><span class="line">	<span class="keyword">if</span> (rc)</span><br><span class="line">		<span class="keyword">goto</span> out_unregister_tcp_proto;</span><br><span class="line">..</span><br><span class="line">	<span class="keyword">for</span> (q = inetsw_array; q &lt; &amp;inetsw_array[INETSW_ARRAY_LEN]; ++q)</span><br><span class="line">		inet_register_protosw(q);</span><br><span class="line"></span><br><span class="line">		arp_init();</span><br><span class="line">		ip_init();</span><br><span class="line">		tcp_init();</span><br><span class="line">		udp_init();</span><br><span class="line">...</span><br><span class="line"><span class="type">static</span> <span class="class"><span class="keyword">struct</span> <span class="title">inet_protosw</span> <span class="title">inetsw_array</span>[] =</span></span><br><span class="line">&#123;</span><br><span class="line">	&#123;</span><br><span class="line">		.type =       SOCK_STREAM,</span><br><span class="line">		.protocol =   IPPROTO_TCP,</span><br><span class="line">		.prot =       &amp;tcp_prot,</span><br><span class="line">		.ops =        &amp;inet_stream_ops,</span><br><span class="line">		.flags =      INET_PROTOSW_PERMANENT |</span><br><span class="line">			      INET_PROTOSW_ICSK,</span><br><span class="line">	&#125;,</span><br></pre></td></tr></table></figure>

<p>您可以通过linux&#x2F;net&#x2F;ipv4&#x2F;中的文件tcp_ipv4.c，udp.c和raw.c中的proto结构来了解各自的协议。这些协议的proto结构体都按照类型和协议映射到inetsw_array，将内部协议映射到对应的操作(which maps the built-in protocols to their operations.)。结构体inetsw_array及其关系如图3所示。该数组中的每个协议都在初始化inetsw时，通过在inet_init调用inet_register_protosw来初始化。函数inet_init还初始化各种inet模块，如ARP，ICMP，IP模块，TCP和UDP模块。</p>
<p><img src="https://img14.360buyimg.com/ddimg/jfs/t1/178936/35/16396/11729/61012017E897d2fcd/c873d2571911b87d.gif" alt="img.gif"></p>
<h4 id="Socket协议关联"><a href="#Socket协议关联" class="headerlink" title="Socket协议关联"></a>Socket协议关联</h4><p>回想下，当创建一个socket时，它定义了类型和协议，如 my_sock &#x3D; socket( AF_INET, SOCK_STREAM, 0 )。其中AF_INET表示基于Internet地址族，SOCK_STREAM表示其为流式socket（如上所示inetsw_array）。</p>
<p>从图3可以看出， proto结构定义了特定传输协议的方法，而proto_ops结构定义了一般的socket方法。其他额外的协议可以通过调用inet_register_protosw将自己加入到inetsw协议开关机(protocol switch) 。例如，SCTP通过在linux&#x2F;net&#x2F;sctp&#x2F;protocol.c中调用sctp_init来添加自己。</p>
<blockquote>
<p>补充：prot&#x2F;prot_ops二者有点相似，这里特意说明下：kernel的调用顺序是先inet(即prot_ops)，后protocal（即prot），inet层处于socket和具体protocol之间。下面以connect为例，ops即为prot_ops，它调用的bind是inet_listen，然后才是具体protocol的tcp_v4_connect。这一关系主要记录在inetsw_array中。</p>
</blockquote>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">SYSCALL_DEFINE3(connect, <span class="type">int</span>, fd, <span class="keyword">struct</span> sockaddr __user *, uservaddr,</span><br><span class="line">		<span class="type">int</span>, addrlen)</span><br><span class="line">&#123;</span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">socket</span> *<span class="title">sock</span>;</span></span><br><span class="line">...</span><br><span class="line">	err = sock-&gt;ops-&gt;connect(sock, (<span class="keyword">struct</span> sockaddr *)&amp;address, addrlen,</span><br><span class="line">				 sock-&gt;file-&gt;f_flags);</span><br><span class="line"> <span class="type">int</span> __inet_stream_connect(<span class="keyword">struct</span> socket *sock, <span class="keyword">struct</span> sockaddr *uaddr,</span><br><span class="line"> 			  <span class="type">int</span> addr_len, <span class="type">int</span> flags, <span class="type">int</span> is_sendmsg)</span><br><span class="line"> &#123;</span><br><span class="line"> 	<span class="class"><span class="keyword">struct</span> <span class="title">sock</span> *<span class="title">sk</span> =</span> sock-&gt;sk;</span><br><span class="line">	<span class="keyword">switch</span> (sock-&gt;state) &#123;</span><br><span class="line">	<span class="keyword">case</span> SS_UNCONNECTED:</span><br><span class="line">		err = -EISCONN;</span><br><span class="line">		<span class="keyword">if</span> (sk-&gt;sk_state != TCP_CLOSE)</span><br><span class="line">			<span class="keyword">goto</span> out;</span><br><span class="line"></span><br><span class="line">		err = sk-&gt;sk_prot-&gt;connect(sk, uaddr, addr_len);</span><br><span class="line">		<span class="keyword">if</span> (err &lt; <span class="number">0</span>)</span><br><span class="line">			<span class="keyword">goto</span> out;</span><br></pre></td></tr></table></figure>

<p>socket的数据移动使用核心结构socket缓冲区（sk_buff）来进行。一个sk_buff 包含包数据(package data)，和状态数据（state data, 覆盖协议栈的多个层）。每个发送或接收的数据包都用一个sk_buff来表示。该sk_buff 结构是在linux&#x2F;include&#x2F;linux&#x2F;skbuff.h中定义的，并在图4中示出。</p>
<p><img src="https://img13.360buyimg.com/ddimg/jfs/t1/189778/12/15488/9064/61012017E621f2a15/fc2656d15ac4256d.gif" alt="img.gif"></p>
<p>如图所示，一个给定连接的多个sk_buff可以串联在一起。每个sk_buff标识了要发送数据包或从其接收数据包的设备结构<code>（net_device *dev）</code>。由于每个包都表示为一个sk_buff，数据包报头可方便地通过一组指针来寻址（th，iph以及mac（MAC报头）），内核会保证这块内存是连续的。由于sk_buff 是socket数据管理的核心，因此kernel已经创建了许多支撑函数来管理它们，包括sk_buff的创建和销毁，克隆和队列管理等函数。</p>
<p>总的来说，内核socket缓冲器设计思路是，某一的socket的sk_buff串链接在一起，并且sk_buff包括许多信息，包括到协议头的指针，时间戳（发送或接收数据包的时间）以及与数据包相关的网络设备。</p>
<h3 id="设备无关接口"><a href="#设备无关接口" class="headerlink" title="设备无关接口"></a>设备无关接口</h3><p>协议层下面是另一个无关的接口层，将协议连接到具有不同功能的各种硬件设备的驱动程序。该层提供了一组通用的功能，由较低级别的网络设备驱动程序使用，以允许它们使用较高级协议栈进行操作。</p>
<p>首先，设备驱动程序可以通过调用register_netdevice&#x2F;unregister_netdevice将自己注册&#x2F;去注册到内核。调用者首先填写net_device结构，然后将其传入register_netdevice进行注册。内核调用其init功能（如果有定义），执行许多健全检查，创建一个 sysfs条目，然后将新设备添加到设备列表（在内核中Active设备的链表）。你可以 在linux&#x2F;include&#x2F;linux&#x2F;netdevice.h中找到net_device结构。各个函数在linux&#x2F;net&#x2F;core&#x2F;dev.c中实现。</p>
<p>使用dev_queue_xmit函数将sk_buff从协议层发送到网络设备。dev_queue_xmit函数会将sk_buff添加到底层网络设备驱动程序最终要传输的队列中（网络设备在net_device或者sk_buff-&gt;dev中定义）。dev结构包含函数hard_start_xmit，保存用于启动sk_buff传输的驱动程序功能的方法。</p>
<p>通常使用netif_rx接收报文数据。当下级设备驱动程序接收到一个包（包含在新分配的sk_buff）时，内核通过调用netif_rx将sk_buff传递给网络层。然后，netif_rx通过调用netif_rx_schedule将sk_buff排队到上层协议的队列以进行进一步处理。您可以在linux&#x2F;net&#x2F;core&#x2F;dev.c 中找到dev_queue_xmit和netif_rx函数。</p>
<p>最近，在内核中引入了一个新的应用程序接口（NAPI），以允许驱动程序与设备无关层（dev）进行交互。一些驱动程序使用NAPI，但绝大多数仍然使用较旧的帧接收接口（by a rough factor of six to one）。NAPI可以通过避免每个传入帧的中断，在高负载下得到更好的性能。</p>
<h3 id="设备驱动程序"><a href="#设备驱动程序" class="headerlink" title="设备驱动程序"></a>设备驱动程序</h3><p>网络栈的底部是管理物理网络设备的设备驱动程序。该层的设备示例包括串行接口上​​的SLIP驱动程序或以太网设备上的以太网驱动程序。</p>
<p>在初始化时，设备驱动程序分配一个net_device结构，然后用其必需的例程进行初始化。dev-&gt;hard_start_xmit就是其中一个例程，它定义了上层如何排队sk_buff用以传输。这个程序需要一个sk_buff。此功能的操作取决于底层硬件，但通常将sk_buff中的数据包移动到硬件环或队列。如设备无关层所述，帧接收使用该netif_rx接口或符合NAPI的网络驱动程序的netif_receive_skb。NAPI驱动程序对底层硬件的功能提出了约束。</p>
<p>在设备驱动程序配置其结构中的dev接口后，调用register_netdevice以后驱动就可以使用了。您可以在linux&#x2F;drivers&#x2F;net中找到网络设备专用的驱动程序。</p>
]]></content>
      <categories>
        <category>linux-doc 网络协议栈</category>
      </categories>
      <tags>
        <tag>Linux</tag>
      </tags>
  </entry>
  <entry>
    <title>Linux网络源代码学习——整体介绍</title>
    <url>/2023/01/15/linux-docs/%E7%BD%91%E7%BB%9C%E5%8D%8F%E8%AE%AE%E6%A0%88/Linux%E7%BD%91%E7%BB%9C%E6%BA%90%E4%BB%A3%E7%A0%81%E5%AD%A6%E4%B9%A0%E2%80%94%E2%80%94%E6%95%B4%E4%BD%93%E4%BB%8B%E7%BB%8D/</url>
    <content><![CDATA[<ul>
<li>简介</li>
<li>源码目录</li>
<li>网络分层</li>
<li>网络与文件操作</li>
<li>数据结构<ul>
<li>sk_buff结构</li>
<li>网络协议栈实现——数据struct 和 协议struct</li>
</ul>
</li>
<li>面向过程&#x2F;对象&#x2F;ioc</li>
<li>其它</li>
</ul>
<p>以下来自linux1.2.13源码。<br>linux的网络部分由网卡的驱动程序和kernel的网络协议栈部分组成，它们相互交互，完成数据的接收和发送。</p>
<h2 id="源码目录"><a href="#源码目录" class="headerlink" title="源码目录"></a>源码目录</h2><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">linux-1.2.13</span><br><span class="line">|</span><br><span class="line">|---net</span><br><span class="line">        |</span><br><span class="line">        |---protocols.c</span><br><span class="line">        |---socket.c</span><br><span class="line">        |---unix</span><br><span class="line">        |	     |</span><br><span class="line">        |	     |---proc.c</span><br><span class="line">        |	     |---sock.c</span><br><span class="line">        |	     |---unix.h</span><br><span class="line">        |---inet</span><br><span class="line">                |</span><br><span class="line">                |---af_inet.c</span><br><span class="line">                |---arp.h,arp.c</span><br><span class="line">                |---...</span><br><span class="line">                |---udp.c,utils.c</span><br></pre></td></tr></table></figure>

<p>其中 unix 子文件夹中三个文件是有关 UNIX 域代码， UNIX 域是模拟网络传输方式在本机范围内用于进程间数据传输的一种机制。</p>
<p>系统调用通过 INT $0x80 进入内核执行函数，该函数根据 AX 寄存器中的系统调用号，进一步调用内核网络栈相应的实现函数。</p>
<h2 id="网络分层"><a href="#网络分层" class="headerlink" title="网络分层"></a>网络分层</h2><p><img src="https://user-images.githubusercontent.com/87457873/127823943-b37924f6-27d0-4117-bf03-94c1feed898e.png" alt="image"></p>
<p>从这个图中，可以看到，到传输层时，横生枝节，代码不再针对任何数据包都通用。从下到上，收到的数据包由哪个传输层协议处理，根据从数据包传输层header中解析的数据确定。从上到下，数据包的发送使用什么传输层协议，由socket初始化时确定。</p>
<p>1、vfs层<br><br>2、socket 是用于负责对上给用户提供接口，并且和文件系统关联。<br><br>3、sock，负责向下对接内核网络协议栈<br><br>4、tcp层 和 ip 层， linux 1.2.13相关方法都在 tcp_prot中。在高版本linux 中，sock 负责tcp 层， ip层另由struct inet_connection_sock 和 icsk_af_ops 负责。分层之后，诸如拥塞控制和滑动窗口的 字段和方法就只体现在struct sock和tcp_prot中，代码实现与tcp规范设计是一致的<br><br>5、ip层 负责路由等逻辑，并执行nf_hook，也就是netfilter。netfilter是工作于内核空间当中的一系列网络（TCP&#x2F;IP）协议栈的钩子（hook），为内核模块在网络协议栈中的不同位置注册回调函数（callback）。也就是说，在数据包经过网络协议栈的不同位置时做相应的由iptables配置好的处理逻辑。<br><br>6、link 层，先寻找下一跳（ip &#x3D;&#x3D;&gt; mac），有了 MAC 地址，就可以调用 dev_queue_xmit发送二层网络包了，它会调用 <code>__dev_xmit_skb</code> 会将请求放入块设备的队列。同时还会处理一些vlan 的逻辑<br><br>7、设备层：网卡是发送和接收网络包的基本设备。在系统启动过程中，网卡通过内核中的网卡驱动程序注册到系统中。而在网络收发过程中，内核通过中断跟网卡进行交互。网络包的发送会触发一个软中断 NET_TX_SOFTIRQ 来处理队列中的数据。这个软中断的处理函数是 net_tx_action。在软中断处理函数中，会将网络包从队列上拿下来，调用网络设备的传输函数 ixgb_xmit_frame，将网络包发的设备的队列上去。<br></p>
<p><img src="https://user-images.githubusercontent.com/87457873/127824109-173a79ab-e425-4216-853f-7000452367a1.png" alt="image"></p>
<p>网卡中断处理程序为网络帧分配的，内核数据结构 sk_buff 缓冲区；是一个维护网络帧结构的双向链表，链表中的每一个元素都是一个网络帧（Packet）。<strong>虽然 TCP&#x2F;IP 协议栈分了好几层，但上下不同层之间的传递，实际上只需要操作这个数据结构中的指针，而无需进行数据复制。</strong></p>
<h2 id="网络与文件操作"><a href="#网络与文件操作" class="headerlink" title="网络与文件操作"></a>网络与文件操作</h2><p><img src="https://user-images.githubusercontent.com/87457873/127824190-536fcd2c-2f6e-46e3-83e3-37ef196eaf85.png" alt="image"></p>
<p>VFS为文件系统抽象了一套API，实现了该系列API就可以把对应的资源当作文件使用，当调用socket函数的时候，我们拿到的不是socket本身，而是一个文件描述符fd。</p>
<p><img src="https://user-images.githubusercontent.com/87457873/127825319-af472153-7bca-4b09-aaf2-b5e9510da847.jpeg" alt="vfs_socket"></p>
<p>从linux5.9看网络层的设计整个网络层的实际中，主要分为socket层、af_inet层和具体协议层（TCP、UDP等）。当使用网络编程的时候，首先会创建一个socket结构体（socket层），socket结构体是最上层的抽象，然后通过协议簇类型创建一个对应的sock结构体，sock是协议簇抽象（af_inet层），同一个协议簇下又分为不同的协议类型，比如TCP、UDP（具体协议层），然后根据socket的类型（流式、数据包）找到对应的操作函数集并赋值到socket和sock结构体中，后续的操作就调用对应的函数就行，调用某个网络函数的时候，会从socket层到af_inet层，af_inet做了一些封装，必要的时候调用底层协议（TCP、UDP）对应的函数。而不同的协议只需要实现自己的逻辑就能加入到网络协议中。</p>
<p>file_operations 结构定义了普通文件操作函数集。系统中每个文件对应一个 file 结构， file 结构中有一个 file_operations 变量，当使用 write，read 函数对某个文件描述符进行读写操作时，系统首先根据文件描述符索引到其对应的 file 结构，然后调用其成员变量 file_operations 中对应函数完成请求。</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 参见socket.c</span></span><br><span class="line"><span class="type">static</span> <span class="class"><span class="keyword">struct</span> <span class="title">file_operations</span> <span class="title">socket_file_ops</span> =</span> &#123;</span><br><span class="line">    sock_lseek,		<span class="comment">// Î´ÊµÏÖ</span></span><br><span class="line">    sock_read,</span><br><span class="line">    sock_write,</span><br><span class="line">    sock_readdir,	<span class="comment">// Î´ÊµÏÖ</span></span><br><span class="line">    sock_select,</span><br><span class="line">    sock_ioctl,</span><br><span class="line">    <span class="literal">NULL</span>,			<span class="comment">/* mmap */</span></span><br><span class="line">    <span class="literal">NULL</span>,			<span class="comment">/* no special open code... */</span></span><br><span class="line">    sock_close,</span><br><span class="line">    <span class="literal">NULL</span>,			<span class="comment">/* no fsync */</span></span><br><span class="line">    sock_fasync</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>以上 socket_file_ops 变量中声明的函数即是网络协议对应的普通文件操作函数集合。从而使得read， write， ioctl 等这些常见普通文件操作函数也可以被使用在网络接口的处理上。kernel维护一个struct file list，通过fd &#x3D;&#x3D;&gt; struct file &#x3D;&#x3D;&gt; file-&gt;ops &#x3D;&#x3D;&gt; socket_file_ops,便可以以文件接口的方式进行网络操作。同时，每个 file 结构都需要有一个 inode 结构对应。用于存储struct file的元信息</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">inode</span>&#123;</span></span><br><span class="line">    ...</span><br><span class="line">    <span class="class"><span class="keyword">union</span> &#123;</span></span><br><span class="line">        ...</span><br><span class="line">        <span class="class"><span class="keyword">struct</span> <span class="title">ext_inode_info</span> <span class="title">ext_i</span>;</span></span><br><span class="line">        <span class="class"><span class="keyword">struct</span> <span class="title">nfs_inode_info</span> <span class="title">nfs_i</span>;</span></span><br><span class="line">        <span class="class"><span class="keyword">struct</span> <span class="title">socket</span> <span class="title">socket_i</span>;</span></span><br><span class="line">    &#125;u</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>也就是说，对linux系统，一切皆文件，由struct file描述，通过file-&gt;ops指向具体操作，由file-&gt;inode 存储一些元信息。对于ext文件系统，是载入内存的超级块、磁盘块等数据。对于网络通信，则是待发送和接收的数据块、网络设备等信息。从这个角度看，struct socket和struct ext_inode_info 等是类似的。</p>
<h2 id="数据结构"><a href="#数据结构" class="headerlink" title="数据结构"></a>数据结构</h2><h3 id="sk-buff结构"><a href="#sk-buff结构" class="headerlink" title="sk_buff结构"></a>sk_buff结构</h3><p>sk_buff部分字段如下，</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">sk_buff</span> &#123;</span>  </span><br><span class="line">    <span class="comment">/* These two members must be first. */</span>  </span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">sk_buff</span>      *<span class="title">next</span>;</span>  </span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">sk_buff</span>      *<span class="title">prev</span>;</span>  </span><br><span class="line">    </span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">sk_buff_head</span> *<span class="title">list</span>;</span>  </span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">sock</span>     *<span class="title">sk</span>;</span>  </span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">timeval</span>      <span class="title">stamp</span>;</span>  </span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">net_device</span>   *<span class="title">dev</span>;</span>  </span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">net_device</span>   *<span class="title">real_dev</span>;</span>  </span><br><span class="line">    </span><br><span class="line">    <span class="class"><span class="keyword">union</span> &#123;</span>  </span><br><span class="line">        <span class="class"><span class="keyword">struct</span> <span class="title">tcphdr</span>   *<span class="title">th</span>;</span>  </span><br><span class="line">        <span class="class"><span class="keyword">struct</span> <span class="title">udphdr</span>   *<span class="title">uh</span>;</span>  </span><br><span class="line">        <span class="class"><span class="keyword">struct</span> <span class="title">icmphdr</span>  *<span class="title">icmph</span>;</span>  </span><br><span class="line">        <span class="class"><span class="keyword">struct</span> <span class="title">igmphdr</span>  *<span class="title">igmph</span>;</span>  </span><br><span class="line">        <span class="class"><span class="keyword">struct</span> <span class="title">iphdr</span>    *<span class="title">ipiph</span>;</span>  </span><br><span class="line">        <span class="type">unsigned</span> <span class="type">char</span>   *raw;  </span><br><span class="line">    &#125; h;  <span class="comment">// Transport layer header </span></span><br><span class="line">    </span><br><span class="line">    <span class="class"><span class="keyword">union</span> &#123;</span>  </span><br><span class="line">        <span class="class"><span class="keyword">struct</span> <span class="title">iphdr</span>    *<span class="title">iph</span>;</span>  </span><br><span class="line">        <span class="class"><span class="keyword">struct</span> <span class="title">ipv6hdr</span>  *<span class="title">ipv6h</span>;</span>  </span><br><span class="line">        <span class="class"><span class="keyword">struct</span> <span class="title">arphdr</span>   *<span class="title">arph</span>;</span>  </span><br><span class="line">        <span class="type">unsigned</span> <span class="type">char</span>   *raw;  </span><br><span class="line">    &#125; nh;  <span class="comment">// Network layer header </span></span><br><span class="line">    </span><br><span class="line">    <span class="class"><span class="keyword">union</span> &#123;</span>  </span><br><span class="line">        <span class="class"><span class="keyword">struct</span> <span class="title">ethhdr</span>   *<span class="title">ethernet</span>;</span>  </span><br><span class="line">        <span class="type">unsigned</span> <span class="type">char</span>   *raw;  </span><br><span class="line">    &#125; mac;  <span class="comment">// Link layer header </span></span><br><span class="line">    </span><br><span class="line">    <span class="class"><span class="keyword">struct</span>  <span class="title">dst_entry</span>   *<span class="title">dst</span>;</span>  </span><br><span class="line">    <span class="class"><span class="keyword">struct</span>  <span class="title">sec_path</span>    *<span class="title">sp</span>;</span>  </span><br><span class="line">    </span><br><span class="line">    <span class="type">void</span>            (*destructor)(<span class="keyword">struct</span> sk_buff *skb);  </span><br><span class="line"></span><br><span class="line">    <span class="comment">/* These elements must be at the end, see alloc_skb() for details.  */</span>  </span><br><span class="line">    <span class="type">unsigned</span> <span class="type">int</span>        truesize;  </span><br><span class="line">    <span class="type">atomic_t</span>        users;  </span><br><span class="line">    <span class="type">unsigned</span> <span class="type">char</span>       *head,  </span><br><span class="line">                *data,  </span><br><span class="line">                *tail,  </span><br><span class="line">                *end;  </span><br><span class="line">&#125;; </span><br></pre></td></tr></table></figure>

<p>head和end字段指向了buf的起始位置和终止位置。然后使用header指针指像各种协议填值。然后data就是实际数据。tail记录了数据的偏移值。</p>
<p>sk_buff 是各层通用的，在应用层数据包叫 data，在 TCP 层我们称为 segment，在 IP 层我们叫 packet，在数据链路层称为 frame。下层协议将上层协议数据作为data部分，并加上自己的header。这也是为什么代码注释中说，哪些字段必须在最前，哪些必须在最后， 这个其中的妙处可以自己体会。</p>
<p>sk_buff由sk_buff_head组织</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">sk_buff_head</span> &#123;</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">sk_buff</span>		* <span class="title">volatile</span> <span class="title">next</span>;</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">sk_buff</span>		* <span class="title">volatile</span> <span class="title">prev</span>;</span></span><br><span class="line">    <span class="meta">#<span class="keyword">if</span> CONFIG_SKB_CHECK</span></span><br><span class="line">    <span class="type">int</span>				magic_debug_cookie;</span><br><span class="line">    <span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p><img src="https://user-images.githubusercontent.com/87457873/127826103-2dc25fa6-18cb-4bd8-9403-350d58bdb276.png" alt="image"></p>
<h3 id="网络协议栈实现——数据struct-和-协议struct"><a href="#网络协议栈实现——数据struct-和-协议struct" class="headerlink" title="网络协议栈实现——数据struct 和 协议struct"></a>网络协议栈实现——数据struct 和 协议struct</h3><p>socket分为多种，除了inet还有unix。反应在代码结构上，就是net包下只有net&#x2F;unix,net&#x2F;inet两个文件夹。之所以叫unix域，可能跟描述其地址时，使用unix:&#x2F;&#x2F;xxx有关</p>
<p>The difference is that an INET socket is bound to an IP address-port tuple, while a UNIX socket is “bound” to a special file on your filesystem. Generally, only processes running on the same machine can communicate through the latter.</p>
<p>本文重点是inet,net&#x2F;inet下有以下几个比较重要的文件，这跟网络书上的知识就对上了。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">arp.c</span><br><span class="line">eth.c</span><br><span class="line">ip.c</span><br><span class="line">route.c</span><br><span class="line">tcp.c</span><br><span class="line">udp.c</span><br><span class="line">datalink.h		// 应该是数据链路层</span><br></pre></td></tr></table></figure>

<p><img src="https://user-images.githubusercontent.com/87457873/127825711-917c868a-8952-4e18-ba55-ad3875b16c2b.png" alt="image"></p>
<p>怎么理解整个表格呢？协议struct和数据struct有何异同？</p>
<p>1、struct一般由一个数组或链表组织，数组用index，链表用header(比如packet_type_base、inet_protocol_base)指针查找数据。<br><br>2、协议struct是怎么回事呢？通常是一个函数操作集，类似于controller-server-dao之间的interface定义，类似于本文开头的file_operations，有open、close、read等方法，但对ext是一回事，对socket操作是另一回事。<br><br>3、数据struct实例可以有很多，比如一个主机有多少个连接就有多少个struct sock，而协议struct个数由协议类型个数决定，具体的协议struct比如tcp_prot就只有一个。比较特别的是，通过tcp_prot就可以找到所有的struct sock实例。<br><br>4、socket、sock、device等数据struct经常被作为分析的重点，其实各种协议struct 才是流程的关键，并且契合了网络协议分层的理念。<br></p>
<p>以ip.c为例，在该文件中定义了ip_rcv（读数据）、ip_queue_xmit(用于写数据)，链路层收到数据后，通过ptype_base找到ip_packet_type,进而执行ip_rcv。tcp发送数据时，通过tcp_proto找到ip_queue_xmit并执行。</p>
<p>tcp_protocol是为了从下到上的数据接收，其函数集主要是handler、frag_handler和err_handler，对应数据接收后的处理。tcp_prot是为了从上到下的数据发送(所以struct proto没有icmp对应的结构)，其函数集connect、read等主要对应上层接口方法。</p>
<p>到bsd socket层，相关的结构在&#x2F;include&#x2F;linux下定义，而不是在net包下。这就对上了，bsd socket是一层接口规范，而net包下的相关struct则是linux自己的抽象了。</p>
<p>主要要搞清楚三个问题，具体可以参见相关的书籍，此处不详述。参见Linux1.0中的Linux1.2.13内核网络栈源码分析的第四章节。</p>
<p>1、这些结构如何初始化。有的结构直接就是定义好的，比如tcp_protocol等<br><br>2、如何接收数据。由中断程序触发。接收数据的时候，可以得到device，从数据中可以取得协议数据，进而从ptype_base及inet_protocol_base执行相应的rcv<br><br>3、如何发送数据。通常不直接发送，先发到queue里。可以从socket初始化时拿到protocol类型（比如tcp）、目的ip，通过route等决定device，于是一路向下执行xx_write方法<br></p>
<h2 id="面向过程-对象-ioc"><a href="#面向过程-对象-ioc" class="headerlink" title="面向过程&#x2F;对象&#x2F;ioc"></a>面向过程&#x2F;对象&#x2F;ioc</h2><p><img src="https://user-images.githubusercontent.com/87457873/127826202-cb5b77da-c922-47db-a468-f53917545859.png" alt="image"></p>
<p><img src="https://user-images.githubusercontent.com/87457873/127826240-9b0eef69-436f-4c1c-84bb-df0a53970449.png" alt="image"></p>
<p>重要的不是细节，这个过程让我想到了web编程中的controller,service,dao。都是分层，区别是web请求要立即返回，网络通信则不用。</p>
<p>mac &#x3D;&#x3D;&gt; device &#x3D;&#x3D;&gt; ip_rcv &#x3D;&#x3D;&gt; tcp_rcv &#x3D;&#x3D;&gt; 上层<br><br>url &#x3D;&#x3D;&gt; controller &#x3D;&#x3D;&gt; service &#x3D;&#x3D;&gt; dao &#x3D;&#x3D;&gt; 数据库<br><br>想一想，整个网络协议栈，其实就是一群loopbackController、eth0Controller、ipService、TcpDao组成，该是一件多么有意思的事。</p>
<p><img src="https://user-images.githubusercontent.com/87457873/127825930-b1b7ed90-9d6a-4a3b-aa0d-ed07f744ef55.png" alt="image"></p>
<h2 id="其它"><a href="#其它" class="headerlink" title="其它"></a>其它</h2><p>无论 TCP 还是 UDP，端口号都只占 16 位，也就说其最大值也只有 65535。那是不是说，如果使用 TCP 协议，在单台机器、单个 IP 地址时，并发连接数最大也只有 65535 呢？对于这个问题，首先你要知道，Linux 协议栈，通过五元组来标志一个连接（即协议，源 IP、源端口、目的 IP、目的端口)。对客户端来说，每次发起 TCP 连接请求时，都需要分配一个空闲的本地端口，去连接远端的服务器。由于这个本地端口是独占的，所以客户端最多只能发起 65535 个连接。对服务器端来说，其通常监听在固定端口上（比如 80 端口），等待客户端的连接。根据五元组结构，我们知道，客户端的 IP 和端口都是可变的。如果不考虑 IP 地址分类以及资源限制，服务器端的理论最大连接数，可以达到 2 的 48 次方（IP 为 32 位，端口号为 16 位），远大于 65535。服务器端可支持的连接数是海量的，当然，由于 Linux 协议栈本身的性能，以及各种物理和软件的资源限制等，这么大的连接数，还是远远达不到的（实际上，C10M 就已经很难了）。</p>
<p>软中断有专门的内核线程 ksoftirqd处理。每个 CPU 都会绑定一个 ksoftirqd 内核线程，比如， 2 个 CPU 时，就会有 ksoftirqd&#x2F;0 和 ksoftirqd&#x2F;1 这两个内核线程。</p>
]]></content>
      <categories>
        <category>linux-doc 网络协议栈</category>
      </categories>
      <tags>
        <tag>Linux</tag>
      </tags>
  </entry>
  <entry>
    <title>深入分析Linux操作系统对于TCP IP栈的实现原理与具体过程</title>
    <url>/2023/01/15/linux-docs/%E7%BD%91%E7%BB%9C%E5%8D%8F%E8%AE%AE%E6%A0%88/%E6%B7%B1%E5%85%A5%E5%88%86%E6%9E%90Linux%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E5%AF%B9%E4%BA%8ETCP%20IP%E6%A0%88%E7%9A%84%E5%AE%9E%E7%8E%B0%E5%8E%9F%E7%90%86%E4%B8%8E%E5%85%B7%E4%BD%93%E8%BF%87%E7%A8%8B/</url>
    <content><![CDATA[<h2 id="一、Linux内核与网络体系结构"><a href="#一、Linux内核与网络体系结构" class="headerlink" title="一、Linux内核与网络体系结构"></a>一、Linux内核与网络体系结构</h2><p>在我们了解整个linux系统的网络体系结构之前，我们需要对整个网络体系调用，初始化和交互的位置，同时也是Linux操作系统中最为关键的一部分代码——-内核，有一个初步的认知。</p>
<h3 id="1、Linux内核的结构"><a href="#1、Linux内核的结构" class="headerlink" title="1、Linux内核的结构"></a>1、Linux内核的结构</h3><p>首先，从功能上，我们将linux内核划分为五个不同的部分，分别是</p>
<p>（1）进程管理：主要负载CPU的访问控制，对CPU进行调度管理；<br><br>（2）内存管理：主要提供对内存资源的访问控制；<br><br>（3）文件系统：将硬盘的扇区组织成文件系统，实现文件读写等操作；<br><br>（4）设备管理：用于控制所有的外部设备及控制器；<br><br>（5）网洛：主要负责管理各种网络设备，并实现各种网络协议栈，最终实现通过网络连接其它系统的功能；<br></p>
<p>每个部分分别处理一项明确的功能，又向其它各个部分提供自己所完成的功能，相互协调，共同完成操作系统的任务。</p>
<p>Linux内核架构如下图所示：</p>
<p><img src="https://user-images.githubusercontent.com/87457873/127457010-628a0bb6-0541-4ea4-966e-9e0c6b2873ca.png" alt="image"></p>
<h3 id="2、Linux网络子系统"><a href="#2、Linux网络子系统" class="headerlink" title="2、Linux网络子系统"></a>2、Linux网络子系统</h3><p>内核的基本架构我们已经了解清楚了，接下来我们重点关注到内核中的网络模块，观察在linux内核中，我们是如何实现及运用TCP&#x2F;IP协议，并完成网络的初始化及各个模块调用调度。我们将内核中的网络部分抽出，通过对比TCP&#x2F;IP分层协议，与Linux网络实现体系相对比，深入的了解学习linux内核是怎样具体的实现TCP&#x2F;IP协议栈的。</p>
<p>Linux网络体系与TCP&#x2F;IP协议栈如下图所示。       </p>
<p><img src="https://user-images.githubusercontent.com/87457873/127457083-f9239de8-6358-4909-9fc4-605a81024009.png" alt="image"></p>
<p><img src="https://user-images.githubusercontent.com/87457873/127457095-b19e6c20-5843-47e4-938f-2a6785aa83ff.png" alt="image"></p>
<p>可以看到，在图中，linux为了抽象与实现相分离，将内核中的网络部分划分为五层：</p>
<ul>
<li>系统调用接口：系统调用接口是用户空间的应用程序正常访问内核的唯一途径，系统调用一般以sys开头。</li>
<li>协议无关接口：协议无关接口是由socket来实现的，它提供一组通用函数来支持各种不同的协议。Linux中socket结构是struct sock，这个结构定义了socket所需要的所  有状态信息，包括socke所使用的协议以及可以在socket上执行的操作。</li>
<li>网络协议：Linux支持多种协议，每一个协议都对应net_family[]数组中的一项，net_family[]的元素为一个结构体指针，指向一个包含注册协议信息的结构体                      net_proto_family;</li>
<li>设备无关接口：设备无关接口net_device实现的，任何设备与上层通信都是通过net_device设备无关接口。它将设备与具有很多功能的不同硬件连接在一起，这一层提供一组通用函数供底层网络设备驱动程序使用，让它们可以对高层协议栈进行操作。</li>
<li>设备驱动程序：网络体系结构的最底部是负责管理物理网络设备的设备驱动程序层。</li>
</ul>
<p>Linux网络子系统通过这五层结构的相互交互，共同完成TCP&#x2F;IP协议栈的运行。</p>
<h3 id="3、TCP-IP协议栈"><a href="#3、TCP-IP协议栈" class="headerlink" title="3、TCP&#x2F;IP协议栈"></a>3、TCP&#x2F;IP协议栈</h3><h4 id="3-1-网络架构"><a href="#3-1-网络架构" class="headerlink" title="3.1 网络架构"></a>3.1 网络架构</h4><p>Linux网络协议栈的架构如下图所示。该图展示了如何实现Internet模型,在最上面的是用户空间中实现的应用层，而中间为内核空间中实现的网络子系统，底部为物理设备，提供了对网络的连接能力。在网络协议栈内部流动的是套接口缓冲区(SKB)，用于在协议栈的底层、上层以及应用层之间传递报文数据。</p>
<p>网络协议栈顶部是系统调用接口，为用户空间中的应用程序提供一种访问内核网络子系统的接口。下面是一个协议无关层，它提供了一种通用方法来使用传输层协议。然后是传输层的具体协议，包括TCP、UDP。在传输层下面是网络层，之后是邻居子系统，再下面是网络设备接口，提供了与各个设备驱动通信的通用接口。最底层是设备驱动程序。                  </p>
<p><img src="https://user-images.githubusercontent.com/87457873/127457257-693815e3-3443-4d21-a79f-06d93234303f.png" alt="image"></p>
<h4 id="3-2-协议无关接口"><a href="#3-2-协议无关接口" class="headerlink" title="3.2 协议无关接口"></a>3.2 协议无关接口</h4><p>通过网络协议栈通信需要对套接口进行操作，套接口是一个与协议无关的接口，它提供了一组接口来支持各种协议，套接口层不但可以支持典型的TCP和UDP协议，还可以支持RAW套接口、RAW以太网以及其他传输协议。</p>
<p>Linux中使用socket结构描述套接口，代表一条通信链路的一端，用来存储与该链路有关的所有信息，这些信息中包括：</p>
<ul>
<li>所使用的协议</li>
<li>协议的状态信息(包括源地址和目标地址)</li>
<li>到达的连接队列</li>
<li>数据缓存和可选标志等等</li>
</ul>
<p>其示意图如下所示：</p>
<p><img src="https://user-images.githubusercontent.com/87457873/127457377-6d4fe3e9-139c-4b43-9e84-c8b9dd2e92e2.png" alt="image"></p>
<p>其中最关键的成员是sk和ops，sk指向与该套接口相关的传输控制块，ops指向特定的传输协议的操作集。</p>
<p>下图详细展示了socket结构体中的sk和ops字段，以TCP为例。</p>
<p><img src="https://user-images.githubusercontent.com/87457873/127457404-384b4a7b-6f26-4cef-a345-c5b6c673e400.png" alt="image"></p>
<p>sk字段指向与该套接口相关的传输控制块，传输层使用传输控制块来存放套接口所需的信息，在上图中即为TCP传输控制块，即tcp_sock结构。</p>
<p>ops字段指向特定传输协议的操作集接口，proto_pos结构中定义的接口函数是从套接口系统调用到传输层调用的入口，因此其成员与socket系统调用基本上是一一对应的。整个proto_ops结构就是一张套接口系统调用的跳转表，TCP、UDP、RAW套接口的传输层操作集分别为inet_stream_ops、inet_dgram_ops、inet_sockraw_ops。</p>
<h4 id="3-3-套接口缓存"><a href="#3-3-套接口缓存" class="headerlink" title="3.3 套接口缓存"></a>3.3 套接口缓存</h4><p>如下图所示，网络子系统中用来存储数据的缓冲区叫做套接口缓存，简称为SKB，该缓存区能够处理可变长数据，即能够很容易地在数据区头尾部添加和移除数据，且尽量避免数据的复制，通常每个报文使用一个SKB表示，各协议栈报文头通过一组指针进行定位，由于SKB是网络子系统中数据管理的核心，因此有很多管理函数是对它进行操作的。</p>
<p>SKB主要用于在网络驱动程序和应用程序之间传递、复制数据包。当应用程序要发送一个数据包时：</p>
<ul>
<li>数据通过系统调用提交到内核中</li>
<li>系统会分配一个SKB来存储数据</li>
<li>之后向下层传递</li>
<li>再传递给网络驱动后才将其释放</li>
</ul>
<p>当网络设备接收到数据包也要分配一个SKB来对数据进行存储，之后再向上传递，最终将数据复制到应用程序后进行释放。</p>
<p><img src="https://user-images.githubusercontent.com/87457873/127457515-485fa24f-613c-4c78-b661-2e02a47968d8.png" alt="image"></p>
<h4 id="3-4-重要的数据结构"><a href="#3-4-重要的数据结构" class="headerlink" title="3.4 重要的数据结构"></a>3.4 重要的数据结构</h4><h5 id="3-4-1-sk-buf"><a href="#3-4-1-sk-buf" class="headerlink" title="3.4.1 sk_buf"></a>3.4.1 sk_buf</h5><p>sk_buf是Linux网络协议栈最重要的数据结构之一，该数据结构贯穿于整个数据包处理的流程。由于协议采用分层结构，上层向下层传递数据时需要增加包头，下层向上层数据时又需要去掉包头。sk_buff中保存了L2，L3，L4层的头指针，这样在层传递时只需要对数据缓冲区改变头部信息，并调整sk_buff中的指针，而不需要拷贝数据，这样大大减少了内存拷贝的需要。</p>
<p>sk_buf的示意图如下：</p>
<p><img src="https://user-images.githubusercontent.com/87457873/127457634-36a897d5-c130-4581-bc9b-96ae226e4feb.png" alt="image"></p>
<p>各字段含义如下：</p>
<ul>
<li>head：指向分配给的线性数据内存首地址。</li>
<li>data：指向保存数据内容的首地址。</li>
<li>tail：指向数据的结尾。 </li>
<li>end：指向分配的内存块的结尾。</li>
<li>len：数据的长度。</li>
<li>head room: 位于head至data之间的空间，用于存储：protocol header，例如：TCP header, IP header, Ethernet header等。</li>
<li>user data: 位于data至tail之间的空间，用于存储：应用层数据，一般系统调用时会使用到。 </li>
<li>tail room: 位于tail至end之间的空间，用于填充用户数据未使用完的空间。</li>
<li>skb_shared_info: 位于end之后，用于存储特殊数据结构skb_shared_info，该结构用于描述分片信息。</li>
</ul>
<p>sk_buf的常用操作函数如下：</p>
<ul>
<li>alloc_skb：分配sk_buf。</li>
<li>skb_reserve：为sk_buff设置header空间。</li>
<li>skb_put：添加用户层数据。</li>
<li>skb_push：向header空间添加协议头。</li>
<li>skb_pull：复位data至数据区。</li>
</ul>
<p>操作sk_buf的简单示意图如下：</p>
<p><img src="https://user-images.githubusercontent.com/87457873/127457802-b2293277-90b3-4135-9f70-4f03675fba53.png" alt="image"></p>
<h5 id="3-4-2-net-device"><a href="#3-4-2-net-device" class="headerlink" title="3.4.2 net_device"></a>3.4.2 net_device</h5><p>在网络适配器硬件和软件协议栈之间需要一个接口，共同完成操作系统内核中协议栈数据处理与异步收发的功能。在Linux网络体系结构中，这个接口要满足以下要求:</p>
<p>（1）抽象出网络适配器的硬件特性。<br><br>（2）为协议栈提供统一的调用接口。<br></p>
<p>以上两个要求在Linux内核的网络体系结构中分别由两个软件（设备独立接口文件dev.c和网络设备驱动程序）和一个主要的数据结构net_device实现。</p>
<p>设备独立接口文件dev.c中实现了对上层协议的统一调用接口，dev.c文件中的函数实现了以下主要功能。</p>
<ul>
<li>协议调用与驱动程序函数对应：dev.c文件中的函数查看数据包由哪个网络设备(由sk_buff结构中*dev数据域指明该数据包由哪个网络设备net_device实例接收&#x2F;发送)传送，根据系统中注册的设备实例,调用网络设备驱动程序函数，实现硬件的收发。</li>
<li>对net_device数据结构的数据域统一初始化：dev.c提供了一些常规函数，来初始化net_device结构中的这样一些数据域:它们的值对所有类型的设备都一样，驱动程序可以调用这些函数来设置其设备实例的默认值，也可以重写由内核初始化的值。</li>
</ul>
<p>每一个网络设备都必须有一个驱动程序，并提供一个初始化函数供内核启动时调用，或在装载网络驱动程序模块时调用。不管网络设备内部有什么不同，有一件事是所有网络设备驱动程序必须首先完成的任务:初始化一个net_device数据结构的实例作为网络设备在内核中的实体，并将net_device数据结构实例的各数据域初始化为可工作的状态，然后将设备实例注册到内核中，为协议栈提供传送服务。</p>
<p>net_device数据结构从以下两个方面描述了网络设备的硬件特性在内核中的表示。</p>
<ul>
<li>描述设备属性</li>
</ul>
<p>net_device数据结构实例是网络设备在内核中的表示，它是每个网络设备在内核中的基础数据结构，它包含的信息不仅仅是网络设备的硬件属性（中断、端口地址、驱动程序函数等)，还包括网络中与设备有关的上层协议栈的配置信息（如IP地址、子网掩码等)。它跟踪连接到 TCP&#x2F;IP协议栈上的所有设备的状态信息。</p>
<ul>
<li>实现设备驱动程序接口</li>
</ul>
<p>net_device数据结构代表了上层的网络协议和硬件之间的一个通用接口，使我们可以将网络协议层的实现从具体的网络硬件部件中抽象出来，独立于硬件设备。为了有效地实现这种抽象，net_device中使用了大量函数指针，这样相对于上层的协议栈，它们在做数据收发操作时调用的函数的名字是相同的，但具体的函数实现细节可以根据不同的网络适配器而不同，由设备驱动程序提供，对网络协议栈透明。</p>
<p><img src="https://user-images.githubusercontent.com/87457873/127458062-fc93e822-b1d7-43c5-9f2e-213b66168293.png" alt="image"></p>
<h5 id="3-4-3-socket"><a href="#3-4-3-socket" class="headerlink" title="3.4.3 socket"></a>3.4.3 socket</h5><p>内核中的进程可以通过socket结构体来访问linux内核中的网络系统中的传输层、网络层以及数据链路层，也可以说socket是内核中的进程与内核中的网络系统的桥梁。</p>
<p>我们知道在TCP层中使用两个协议：tcp协议和udp协议。而在将TCP层中的数据往下传输时，要使用网络层的协议，而网络层的协议很多，不同的网络使用不同的网络层协议。我们常用的因特网中，网络层使用的是IPV4和IPV6协议。所以在内核中的进程在使用struct socket提取内核网络系统中的数据时，不光要指明struct socket的类型(用于说明是提取TCP层中tcp协议负载的数据，还是udp层负载的数据)，还要指明网络层的协议类型(网络层的协议用于负载TCP层中的数据)。</p>
<p>linux内核中的网络系统中的网络层的协议，在linux中被称为address family(地址簇，通常以AF_XXX表示）或protocol family(协议簇，通常以PF_XXX表示)。</p>
<h2 id="二、网络信息处理流程"><a href="#二、网络信息处理流程" class="headerlink" title="二、网络信息处理流程"></a>二、网络信息处理流程</h2><h3 id="1、硬中断处理"><a href="#1、硬中断处理" class="headerlink" title="1、硬中断处理"></a>1、硬中断处理</h3><p>首先当数据帧从网线到达网卡上的时候，第一站是网卡的接收队列。网卡在分配给自己的RingBuffer中寻找可用的内存位置，找到后DMA引擎会把数据DMA到网卡之前关联的内存里，这个时候CPU都是无感的。当DMA操作完成以后，网卡会像CPU发起一个硬中断，通知CPU有数据到达。</p>
<p><img src="https://user-images.githubusercontent.com/87457873/127458176-e1d436d9-5ddf-4e59-9ef8-f23ac16a725e.png" alt="image"></p>
<p>注意，当RingBuffer满的时候，新来的数据包将给丢弃。ifconfig查看网卡的时候，可以里面有个overruns，表示因为环形队列满被丢弃的包。如果发现有丢包，可能需要通过ethtool命令来加大环形队列的长度。</p>
<p>网卡的硬中断注册的处理函数是igb_msix_ring。</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">//file: drivers/net/ethernet/intel/igb/igb_main.c</span></span><br><span class="line"><span class="type">static</span> <span class="type">irqreturn_t</span> <span class="title function_">igb_msix_ring</span><span class="params">(<span class="type">int</span> irq, <span class="type">void</span> *data)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">igb_q_vector</span> *<span class="title">q_vector</span> =</span> data;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* Write the ITR value calculated from the previous interrupt. */</span></span><br><span class="line">    igb_write_itr(q_vector);</span><br><span class="line"></span><br><span class="line">    napi_schedule(&amp;q_vector-&gt;napi);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> IRQ_HANDLED;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>igb_write_itr只是记录一下硬件中断频率（据说目的是在减少对CPU的中断频率时用到）。顺着napi_schedule调用一路跟踪下去，__napi_schedule&#x3D;&gt;____napi_schedule。</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">/* Called with irq disabled */</span></span><br><span class="line"><span class="type">static</span> <span class="keyword">inline</span> <span class="type">void</span> ____napi_schedule(<span class="keyword">struct</span> softnet_data *sd,</span><br><span class="line">                     <span class="keyword">struct</span> napi_struct *napi)</span><br><span class="line">&#123;</span><br><span class="line">    list_add_tail(&amp;napi-&gt;poll_list, &amp;sd-&gt;poll_list);</span><br><span class="line">    __raise_softirq_irqoff(NET_RX_SOFTIRQ);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这里我们看到，list_add_tail修改了CPU变量softnet_data里的poll_list，将驱动napi_struct传过来的poll_list添加了进来。 其中softnet_data中的poll_list是一个双向列表，其中的设备都带有输入帧等着被处理。紧接着__raise_softirq_irqoff触发了一个软中断NET_RX_SOFTIRQ， 这个所谓的触发过程只是对一个变量进行了一次或运算而已。</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">void</span> __raise_softirq_irqoff(<span class="type">unsigned</span> <span class="type">int</span> nr)</span><br><span class="line">&#123;</span><br><span class="line">    trace_softirq_raise(nr);</span><br><span class="line">    or_softirq_pending(<span class="number">1UL</span> &lt;&lt; nr);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//file: include/linux/irq_cpustat.h</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> or_softirq_pending(x)  (local_softirq_pending() |= (x))</span></span><br></pre></td></tr></table></figure>

<p>Linux在硬中断里只完成简单必要的工作，剩下的大部分的处理都是转交给软中断的。通过上面代码可以看到，硬中断处理过程真的是非常短。只是记录了一个寄存器，修改了一下下CPU的poll_list，然后发出个软中断。就这么简单，硬中断工作就算是完成了。</p>
<h3 id="2、ksoftirqd内核线程处理软中断"><a href="#2、ksoftirqd内核线程处理软中断" class="headerlink" title="2、ksoftirqd内核线程处理软中断"></a>2、ksoftirqd内核线程处理软中断</h3><p><img src="https://user-images.githubusercontent.com/87457873/127458460-dede7009-1ba5-427e-98e2-345f798d6724.png" alt="image"></p>
<p>ksoftirqd_should_run代码如下：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">static</span> <span class="type">int</span> <span class="title function_">ksoftirqd_should_run</span><span class="params">(<span class="type">unsigned</span> <span class="type">int</span> cpu)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">return</span> local_softirq_pending();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> local_softirq_pending() \</span></span><br><span class="line"><span class="meta">    __IRQ_STAT(smp_processor_id(), __softirq_pending)</span></span><br><span class="line">这里看到和硬中断中调用了同一个函数local_softirq_pending。使用方式不同的是硬中断位置是为了写入标记，这里仅仅只是读取。如果硬中断中设置了NET_RX_SOFTIRQ,这里自然能读取的到。接下来会真正进入线程函数中run_ksoftirqd处理：</span><br><span class="line"><span class="type">static</span> <span class="type">void</span> <span class="title function_">run_ksoftirqd</span><span class="params">(<span class="type">unsigned</span> <span class="type">int</span> cpu)</span></span><br><span class="line">&#123;</span><br><span class="line">    local_irq_disable();</span><br><span class="line">    <span class="keyword">if</span> (local_softirq_pending()) &#123;</span><br><span class="line">        __do_softirq();</span><br><span class="line">        rcu_note_context_switch(cpu);</span><br><span class="line">        local_irq_enable();</span><br><span class="line">        cond_resched();</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    local_irq_enable();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>在__do_softirq中，判断根据当前CPU的软中断类型，调用其注册的action方法。</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">asmlinkage <span class="type">void</span> __do_softirq(<span class="type">void</span>)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">do</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (pending &amp; <span class="number">1</span>) &#123;</span><br><span class="line">            <span class="type">unsigned</span> <span class="type">int</span> vec_nr = h - softirq_vec;</span><br><span class="line">            <span class="type">int</span> prev_count = preempt_count();</span><br><span class="line"></span><br><span class="line">            ...</span><br><span class="line">            trace_softirq_entry(vec_nr);</span><br><span class="line">            h-&gt;action(h);</span><br><span class="line">            trace_softirq_exit(vec_nr);</span><br><span class="line">            ...</span><br><span class="line">        &#125;</span><br><span class="line">        h++;</span><br><span class="line">        pending &gt;&gt;= <span class="number">1</span>;</span><br><span class="line">    &#125; <span class="keyword">while</span> (pending);</span><br><span class="line">&#125;　　</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>在网络子系统初始化小节， 我们看到我们为NET_RX_SOFTIRQ注册了处理函数net_rx_action。所以net_rx_action函数就会被执行到了。</p>
<p>这里需要注意一个细节，硬中断中设置软中断标记，和ksoftirq的判断是否有软中断到达，都是基于smp_processor_id()的。这意味着只要硬中断在哪个CPU上被响应，那么软中断也是在这个CPU上处理的。所以说，如果你发现你的Linux软中断CPU消耗都集中在一个核上的话，做法是要把调整硬中断的CPU亲和性，来将硬中断打散到不通的CPU核上去。</p>
<p>我们再来把精力集中到这个核心函数net_rx_action上来。</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">static</span> <span class="type">void</span> <span class="title function_">net_rx_action</span><span class="params">(<span class="keyword">struct</span> softirq_action *h)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">softnet_data</span> *<span class="title">sd</span> =</span> &amp;__get_cpu_var(softnet_data);</span><br><span class="line">    <span class="type">unsigned</span> <span class="type">long</span> time_limit = jiffies + <span class="number">2</span>;</span><br><span class="line">    <span class="type">int</span> budget = netdev_budget;</span><br><span class="line">    <span class="type">void</span> *have;</span><br><span class="line"></span><br><span class="line">    local_irq_disable();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span> (!list_empty(&amp;sd-&gt;poll_list)) &#123;</span><br><span class="line">        ......</span><br><span class="line">        n = list_first_entry(&amp;sd-&gt;poll_list, <span class="keyword">struct</span> napi_struct, poll_list);</span><br><span class="line"></span><br><span class="line">        work = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">if</span> (test_bit(NAPI_STATE_SCHED, &amp;n-&gt;state)) &#123;</span><br><span class="line">            work = n-&gt;poll(n, weight);</span><br><span class="line">            trace_napi_poll(n);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        budget -= work;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>函数开头的time_limit和budget是用来控制net_rx_action函数主动退出的，目的是保证网络包的接收不霸占CPU不放。 等下次网卡再有硬中断过来的时候再处理剩下的接收数据包。其中budget可以通过内核参数调整。 这个函数中剩下的核心逻辑是获取到当前CPU变量softnet_data，对其poll_list进行遍历, 然后执行到网卡驱动注册到的poll函数。对于igb网卡来说，就是igb驱动力的igb_poll函数了。</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> *  igb_poll - NAPI Rx polling callback</span></span><br><span class="line"><span class="comment"> *  @napi: napi polling structure</span></span><br><span class="line"><span class="comment"> *  @budget: count of how many packets we should handle</span></span><br><span class="line"><span class="comment"> **/</span></span><br><span class="line"><span class="type">static</span> <span class="type">int</span> <span class="title function_">igb_poll</span><span class="params">(<span class="keyword">struct</span> napi_struct *napi, <span class="type">int</span> budget)</span></span><br><span class="line">&#123;</span><br><span class="line">    ...</span><br><span class="line">    <span class="keyword">if</span> (q_vector-&gt;tx.ring)</span><br><span class="line">        clean_complete = igb_clean_tx_irq(q_vector);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (q_vector-&gt;rx.ring)</span><br><span class="line">        clean_complete &amp;= igb_clean_rx_irq(q_vector, budget);</span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>在读取操作中，igb_poll的重点工作是对igb_clean_rx_irq的调用。</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">static</span> <span class="type">bool</span> <span class="title function_">igb_clean_rx_irq</span><span class="params">(<span class="keyword">struct</span> igb_q_vector *q_vector, <span class="type">const</span> <span class="type">int</span> budget)</span></span><br><span class="line">&#123;</span><br><span class="line">    ...</span><br><span class="line"></span><br><span class="line">    <span class="keyword">do</span> &#123;</span><br><span class="line"></span><br><span class="line">        <span class="comment">/* retrieve a buffer from the ring */</span></span><br><span class="line">        skb = igb_fetch_rx_buffer(rx_ring, rx_desc, skb);</span><br><span class="line"></span><br><span class="line">        <span class="comment">/* fetch next buffer in frame if non-eop */</span></span><br><span class="line">        <span class="keyword">if</span> (igb_is_non_eop(rx_ring, rx_desc))</span><br><span class="line">            <span class="keyword">continue</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">/* verify the packet layout is correct */</span></span><br><span class="line">        <span class="keyword">if</span> (igb_cleanup_headers(rx_ring, rx_desc, skb)) &#123;</span><br><span class="line">            skb = <span class="literal">NULL</span>;</span><br><span class="line">            <span class="keyword">continue</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">/* populate checksum, timestamp, VLAN, and protocol */</span></span><br><span class="line">        igb_process_skb_fields(rx_ring, rx_desc, skb);</span><br><span class="line"></span><br><span class="line">        napi_gro_receive(&amp;q_vector-&gt;napi, skb);</span><br><span class="line">&#125;</span><br><span class="line">igb_fetch_rx_buffer和igb_is_non_eop的作用就是把数据帧从RingBuffer上取下来。为什么需要两个函数呢？因为有可能帧要占多多个RingBuffer，所以是在一个循环中获取的，直到帧尾部。获取下来的一个数据帧用一个sk_buff来表示。收取完数据以后，对其进行一些校验，然后开始设置sbk变量的timestamp, VLAN id, protocol等字段。接下来进入到napi_gro_receive中:</span><br><span class="line"><span class="comment">//file: net/core/dev.c</span></span><br><span class="line"><span class="type">gro_result_t</span> <span class="title function_">napi_gro_receive</span><span class="params">(<span class="keyword">struct</span> napi_struct *napi, <span class="keyword">struct</span> sk_buff *skb)</span></span><br><span class="line">&#123;</span><br><span class="line">    skb_gro_reset_offset(skb);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> napi_skb_finish(dev_gro_receive(napi, skb), skb);</span><br><span class="line">&#125;</span><br><span class="line">dev_gro_receive这个函数代表的是网卡GRO特性，可以简单理解成把相关的小包合并成一个大包就行，目的是减少传送给网络栈的包数，这有助于减少 CPU 的使用量。我们暂且忽略，直接看napi_skb_finish, 这个函数主要就是调用了netif_receive_skb。</span><br><span class="line"><span class="comment">//file: net/core/dev.c</span></span><br><span class="line"><span class="type">static</span> <span class="type">gro_result_t</span> <span class="title function_">napi_skb_finish</span><span class="params">(<span class="type">gro_result_t</span> ret, <span class="keyword">struct</span> sk_buff *skb)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">switch</span> (ret) &#123;</span><br><span class="line">    <span class="keyword">case</span> GRO_NORMAL:</span><br><span class="line">        <span class="keyword">if</span> (netif_receive_skb(skb))</span><br><span class="line">            ret = GRO_DROP;</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">    ......</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>在netif_receive_skb中，数据包将被送到协议栈中。声明，以下的3.3, 3.4, 3.5也都属于软中断的处理过程，只不过由于篇幅太长，单独拿出来成小节。</p>
<h3 id="3、网络协议栈处理"><a href="#3、网络协议栈处理" class="headerlink" title="3、网络协议栈处理"></a>3、网络协议栈处理</h3><p>netif_receive_skb函数会根据包的协议，假如是udp包，会将包依次送到ip_rcv(),udp_rcv()协议处理函数中进行处理。</p>
<p><img src="https://user-images.githubusercontent.com/87457873/127458725-e83ce43a-9dc2-4794-b828-e9f7bac3b168.png" alt="image"></p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">//file: net/core/dev.c</span></span><br><span class="line"><span class="type">int</span> <span class="title function_">netif_receive_skb</span><span class="params">(<span class="keyword">struct</span> sk_buff *skb)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">//RPS处理逻辑，先忽略</span></span><br><span class="line">    ......</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> __netif_receive_skb(skb);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">static</span> <span class="type">int</span> __netif_receive_skb(<span class="keyword">struct</span> sk_buff *skb)</span><br><span class="line">&#123;</span><br><span class="line">    ......   </span><br><span class="line">    ret = __netif_receive_skb_core(skb, <span class="literal">false</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">static</span> <span class="type">int</span> __netif_receive_skb_core(<span class="keyword">struct</span> sk_buff *skb, <span class="type">bool</span> pfmemalloc)</span><br><span class="line">&#123;</span><br><span class="line">    ......</span><br><span class="line"></span><br><span class="line">    <span class="comment">//pcap逻辑，这里会将数据送入抓包点。tcpdump就是从这个入口获取包的</span></span><br><span class="line">    list_for_each_entry_rcu(ptype, &amp;ptype_all, <span class="built_in">list</span>) &#123;</span><br><span class="line">        <span class="keyword">if</span> (!ptype-&gt;dev || ptype-&gt;dev == skb-&gt;dev) &#123;</span><br><span class="line">            <span class="keyword">if</span> (pt_prev)</span><br><span class="line">                ret = deliver_skb(skb, pt_prev, orig_dev);</span><br><span class="line">            pt_prev = ptype;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    ......</span><br><span class="line"></span><br><span class="line">    list_for_each_entry_rcu(ptype,</span><br><span class="line">            &amp;ptype_base[ntohs(type) &amp; PTYPE_HASH_MASK], <span class="built_in">list</span>) &#123;</span><br><span class="line">        <span class="keyword">if</span> (ptype-&gt;type == type &amp;&amp;</span><br><span class="line">            (ptype-&gt;dev == null_or_dev || ptype-&gt;dev == skb-&gt;dev ||</span><br><span class="line">             ptype-&gt;dev == orig_dev)) &#123;</span><br><span class="line">            <span class="keyword">if</span> (pt_prev)</span><br><span class="line">                ret = deliver_skb(skb, pt_prev, orig_dev);</span><br><span class="line">            pt_prev = ptype;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>在__netif_receive_skb_core中，我看着原来经常使用的tcpdump的抓包点，很是激动，看来读一遍源代码时间真的没白浪费。接着__netif_receive_skb_core取出protocol，它会从数据包中取出协议信息，然后遍历注册在这个协议上的回调函数列表。ptype_base 是一个 hash table，在协议注册小节我们提到过。ip_rcv 函数地址就是存在这个 hash table中的。</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">//file: net/core/dev.c</span></span><br><span class="line"><span class="type">static</span> <span class="keyword">inline</span> <span class="type">int</span> <span class="title function_">deliver_skb</span><span class="params">(<span class="keyword">struct</span> sk_buff *skb,</span></span><br><span class="line"><span class="params">                  <span class="keyword">struct</span> packet_type *pt_prev,</span></span><br><span class="line"><span class="params">                  <span class="keyword">struct</span> net_device *orig_dev)</span></span><br><span class="line">&#123;</span><br><span class="line">    ......</span><br><span class="line">    <span class="keyword">return</span> pt_prev-&gt;func(skb, skb-&gt;dev, pt_prev, orig_dev);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>pt_prev-&gt;func这一行就调用到了协议层注册的处理函数了。对于ip包来讲，就会进入到ip_rcv（如果是arp包的话，会进入到arp_rcv）。</p>
<h3 id="4、IP协议层处理"><a href="#4、IP协议层处理" class="headerlink" title="4、IP协议层处理"></a>4、IP协议层处理</h3><p>我们再来大致看一下linux在ip协议层都做了什么，包又是怎么样进一步被送到udp或tcp协议处理函数中的。</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">//file: net/ipv4/ip_input.c</span></span><br><span class="line"><span class="type">int</span> <span class="title function_">ip_rcv</span><span class="params">(<span class="keyword">struct</span> sk_buff *skb, <span class="keyword">struct</span> net_device *dev, <span class="keyword">struct</span> packet_type *pt, <span class="keyword">struct</span> net_device *orig_dev)</span></span><br><span class="line">&#123;</span><br><span class="line">    ......</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> NF_HOOK(NFPROTO_IPV4, NF_INET_PRE_ROUTING, skb, dev, <span class="literal">NULL</span>,</span><br><span class="line">               ip_rcv_finish);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这里NF_HOOK是一个钩子函数，当执行完注册的钩子后就会执行到最后一个参数指向的函数ip_rcv_finish。</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">static</span> <span class="type">int</span> <span class="title function_">ip_rcv_finish</span><span class="params">(<span class="keyword">struct</span> sk_buff *skb)</span></span><br><span class="line">&#123;</span><br><span class="line">    ......</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (!skb_dst(skb)) &#123;</span><br><span class="line">        <span class="type">int</span> err = ip_route_input_noref(skb, iph-&gt;daddr, iph-&gt;saddr,</span><br><span class="line">                           iph-&gt;tos, skb-&gt;dev);</span><br><span class="line">        ...</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    ......</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> dst_input(skb);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>跟踪ip_route_input_noref 后看到它又调用了 ip_route_input_mc。 在ip_route_input_mc中，函数ip_local_deliver被赋值给了dst.input, 如下：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">//file: net/ipv4/route.c</span></span><br><span class="line"><span class="type">static</span> <span class="type">int</span> <span class="title function_">ip_route_input_mc</span><span class="params">(<span class="keyword">struct</span> sk_buff *skb, __be32 daddr, __be32 saddr,</span></span><br><span class="line"><span class="params">                u8 tos, <span class="keyword">struct</span> net_device *dev, <span class="type">int</span> our)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">if</span> (our) &#123;</span><br><span class="line">        rth-&gt;dst.input= ip_local_deliver;</span><br><span class="line">        rth-&gt;rt_flags |= RTCF_LOCAL;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>所以回到ip_rcv_finish中的return dst_input(skb)。</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">/* Input packet from network to transport.  */</span></span><br><span class="line"><span class="type">static</span> <span class="keyword">inline</span> <span class="type">int</span> <span class="title function_">dst_input</span><span class="params">(<span class="keyword">struct</span> sk_buff *skb)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">return</span> skb_dst(skb)-&gt;input(skb);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>skb_dst(skb)-&gt;input调用的input方法就是路由子系统赋的ip_local_deliver。</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">//file: net/ipv4/ip_input.c</span></span><br><span class="line"><span class="type">int</span> <span class="title function_">ip_local_deliver</span><span class="params">(<span class="keyword">struct</span> sk_buff *skb)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">     *  Reassemble IP fragments.</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (ip_is_fragment(ip_hdr(skb))) &#123;</span><br><span class="line">        <span class="keyword">if</span> (ip_defrag(skb, IP_DEFRAG_LOCAL_DELIVER))</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> NF_HOOK(NFPROTO_IPV4, NF_INET_LOCAL_IN, skb, skb-&gt;dev, <span class="literal">NULL</span>,</span><br><span class="line">               ip_local_deliver_finish);</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">static</span> <span class="type">int</span> <span class="title function_">ip_local_deliver_finish</span><span class="params">(<span class="keyword">struct</span> sk_buff *skb)</span></span><br><span class="line">&#123;</span><br><span class="line">    ......</span><br><span class="line"></span><br><span class="line">    <span class="type">int</span> protocol = ip_hdr(skb)-&gt;protocol;</span><br><span class="line">    <span class="type">const</span> <span class="class"><span class="keyword">struct</span> <span class="title">net_protocol</span> *<span class="title">ipprot</span>;</span></span><br><span class="line"></span><br><span class="line">    ipprot = rcu_dereference(inet_protos[protocol]);</span><br><span class="line">    <span class="keyword">if</span> (ipprot != <span class="literal">NULL</span>) &#123;</span><br><span class="line">        ret = ipprot-&gt;handler(skb);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>如协议注册小节看到inet_protos中保存着tcp_rcv()和udp_rcv()的函数地址。这里将会根据包中的协议类型选择进行分发,在这里skb包将会进一步被派送到更上层的协议中，udp和tcp。</p>
<h3 id="5、UDP协议层处理"><a href="#5、UDP协议层处理" class="headerlink" title="5、UDP协议层处理"></a>5、UDP协议层处理</h3><p>udp协议的处理函数是udp_rcv。</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">//file: net/ipv4/udp.c</span></span><br><span class="line"><span class="type">int</span> <span class="title function_">udp_rcv</span><span class="params">(<span class="keyword">struct</span> sk_buff *skb)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">return</span> __udp4_lib_rcv(skb, &amp;udp_table, IPPROTO_UDP);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> __udp4_lib_rcv(<span class="keyword">struct</span> sk_buff *skb, <span class="keyword">struct</span> udp_table *udptable,</span><br><span class="line">           <span class="type">int</span> proto)</span><br><span class="line">&#123;</span><br><span class="line">    sk = __udp4_lib_lookup_skb(skb, uh-&gt;source, uh-&gt;dest, udptable);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (sk != <span class="literal">NULL</span>) &#123;</span><br><span class="line">        <span class="type">int</span> ret = udp_queue_rcv_skb(sk, skb</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    icmp_send(skb, ICMP_DEST_UNREACH, ICMP_PORT_UNREACH, <span class="number">0</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>__udp4_lib_lookup_skb是根据skb来寻找对应的socket，当找到以后将数据包放到socket的缓存队列里。如果没有找到，则发送一个目标不可达的icmp包。</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">//file: net/ipv4/udp.c</span></span><br><span class="line"><span class="type">int</span> <span class="title function_">udp_queue_rcv_skb</span><span class="params">(<span class="keyword">struct</span> sock *sk, <span class="keyword">struct</span> sk_buff *skb)</span></span><br><span class="line">&#123;   </span><br><span class="line">    ......</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (sk_rcvqueues_full(sk, skb, sk-&gt;sk_rcvbuf))</span><br><span class="line">        <span class="keyword">goto</span> drop;</span><br><span class="line"></span><br><span class="line">        rc = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    ipv4_pktinfo_prepare(skb);</span><br><span class="line">    bh_lock_sock(sk);</span><br><span class="line">    <span class="keyword">if</span> (!sock_owned_by_user(sk))</span><br><span class="line">        rc = __udp_queue_rcv_skb(sk, skb);</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span> (sk_add_backlog(sk, skb, sk-&gt;sk_rcvbuf)) &#123;</span><br><span class="line">        bh_unlock_sock(sk);</span><br><span class="line">        <span class="keyword">goto</span> drop;</span><br><span class="line">    &#125;</span><br><span class="line">    bh_unlock_sock(sk);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> rc;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>sock_owned_by_user判断的是用户是不是正在这个socker上进行系统调用（socket被占用），如果没有，那就可以直接放到socket的接收队列中。如果有，那就通过sk_add_backlog把数据包添加到backlog队列。 当用户释放的socket的时候，内核会检查backlog队列，如果有数据再移动到接收队列中。</p>
<p>sk_rcvqueues_full接收队列如果满了的话，将直接把包丢弃。接收队列大小受内核参数net.core.rmem_max和net.core.rmem_default影响。</p>
<h2 id="三、send分析"><a href="#三、send分析" class="headerlink" title="三、send分析"></a>三、send分析</h2><h3 id="1、传输层分析"><a href="#1、传输层分析" class="headerlink" title="1、传输层分析"></a>1、传输层分析</h3><p>send的定义如下所示：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">ssize_t send(int sockfd, const void *buf, size_t len, int flags)</span><br></pre></td></tr></table></figure>

<p>当在调用send函数的时候，内核封装send()为sendto()，然后发起系统调用。其实也很好理解，send()就是sendto()的一种特殊情况，而sendto()在内核的系统调用服务程序为sys_sendto，sys_sendto的代码如下所示：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">int</span> __sys_sendto(<span class="type">int</span> fd, <span class="type">void</span> __user *buff, <span class="type">size_t</span> len, <span class="type">unsigned</span> <span class="type">int</span> flags,</span><br><span class="line">         <span class="keyword">struct</span> sockaddr __user *addr,  <span class="type">int</span> addr_len)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">socket</span> *<span class="title">sock</span>;</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">sockaddr_storage</span> <span class="title">address</span>;</span></span><br><span class="line">    <span class="type">int</span> err;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">msghdr</span> <span class="title">msg</span>;</span> <span class="comment">//用来表示要发送的数据的一些属性</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">iovec</span> <span class="title">iov</span>;</span></span><br><span class="line">    <span class="type">int</span> fput_needed;</span><br><span class="line">    err = import_single_range(WRITE, buff, len, &amp;iov, &amp;msg.msg_iter);</span><br><span class="line">    <span class="keyword">if</span> (unlikely(err))</span><br><span class="line">        <span class="keyword">return</span> err;</span><br><span class="line">    sock = sockfd_lookup_light(fd, &amp;err, &amp;fput_needed);</span><br><span class="line">    <span class="keyword">if</span> (!sock)</span><br><span class="line">        <span class="keyword">goto</span> out;</span><br><span class="line"></span><br><span class="line">    msg.msg_name = <span class="literal">NULL</span>;</span><br><span class="line">    msg.msg_control = <span class="literal">NULL</span>;</span><br><span class="line">    msg.msg_controllen = <span class="number">0</span>;</span><br><span class="line">    msg.msg_namelen = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">if</span> (addr) &#123;</span><br><span class="line">        err = move_addr_to_kernel(addr, addr_len, &amp;address);</span><br><span class="line">        <span class="keyword">if</span> (err &lt; <span class="number">0</span>)</span><br><span class="line">            <span class="keyword">goto</span> out_put;</span><br><span class="line">        msg.msg_name = (<span class="keyword">struct</span> sockaddr *)&amp;address;</span><br><span class="line">        msg.msg_namelen = addr_len;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (sock-&gt;file-&gt;f_flags &amp; O_NONBLOCK)</span><br><span class="line">        flags |= MSG_DONTWAIT;</span><br><span class="line">    msg.msg_flags = flags;</span><br><span class="line">    err = sock_sendmsg(sock, &amp;msg); <span class="comment">//实际的发送函数</span></span><br><span class="line"></span><br><span class="line">out_put:</span><br><span class="line">    fput_light(sock-&gt;file, fput_needed);</span><br><span class="line">out:</span><br><span class="line">    <span class="keyword">return</span> err;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>__sys_sendto函数其实做了3件事：</p>
<ul>
<li>通过fd获取了对应的struct socket</li>
<li>创建了用来描述要发送的数据的结构体struct msghdr</li>
<li>调用了sock_sendmsg来执行实际的发送</li>
</ul>
<p>继续追踪sock_sendmsg，发现其最终调用的是sock-&gt;ops-&gt;sendmsg(sock, msg, msg_data_left(msg))，即socet在初始化时赋值给结构体struct proto tcp_prot的函数tcp_sendmsg，如下所示：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">proto</span> <span class="title">tcp_prot</span> =</span> &#123;</span><br><span class="line">    .name            = <span class="string">&quot;TCP&quot;</span>,</span><br><span class="line">    .owner            = THIS_MODULE,</span><br><span class="line">    .close            = tcp_close,</span><br><span class="line">    .pre_connect        = tcp_v4_pre_connect,</span><br><span class="line">    .connect        = tcp_v4_connect,</span><br><span class="line">    .disconnect        = tcp_disconnect,</span><br><span class="line">    .accept            = inet_csk_accept,</span><br><span class="line">    .ioctl            = tcp_ioctl,</span><br><span class="line">    .init            = tcp_v4_init_sock,</span><br><span class="line">    .destroy        = tcp_v4_destroy_sock,</span><br><span class="line">    .shutdown        = tcp_shutdown,</span><br><span class="line">    .setsockopt        = tcp_setsockopt,</span><br><span class="line">    .getsockopt        = tcp_getsockopt,</span><br><span class="line">    .keepalive        = tcp_set_keepalive,</span><br><span class="line">    .recvmsg        = tcp_recvmsg,</span><br><span class="line">    .sendmsg        = tcp_sendmsg,</span><br><span class="line">  ...</span><br></pre></td></tr></table></figure>
<p>而tcp_send函数实际调用的是tcp_sendmsg_locked函数，该函数的定义如下所示：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">tcp_sendmsg_locked</span><span class="params">(<span class="keyword">struct</span> sock *sk, <span class="keyword">struct</span> msghdr *msg, <span class="type">size_t</span> size)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">tcp_sock</span> *<span class="title">tp</span> =</span> tcp_sk(sk);<span class="comment">/*进行了强制类型转换*/</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">sk_buff</span> *<span class="title">skb</span>;</span></span><br><span class="line">    flags = msg-&gt;msg_flags;</span><br><span class="line">    ......</span><br><span class="line">        <span class="keyword">if</span> (copied)</span><br><span class="line">            tcp_push(sk, flags &amp; ~MSG_MORE, mss_now,</span><br><span class="line">                 TCP_NAGLE_PUSH, size_goal);</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>在tcp_sendmsg_locked中，完成的是将所有的数据组织成发送队列，这个发送队列是struct sock结构中的一个域sk_write_queue，这个队列的每一个元素是一个skb，里面存放的就是待发送的数据。在该函数中通过调用tcp_push()函数将数据加入到发送队列中。</p>
<p>sock结构体的部分代码如下所示：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">sock</span>&#123;</span></span><br><span class="line">    ...</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">sk_buff_head</span>    <span class="title">sk_write_queue</span>;</span><span class="comment">/*指向skb队列的第一个元素*/</span></span><br><span class="line">    ...</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">sk_buff</span>    *<span class="title">sk_send_head</span>;</span><span class="comment">/*指向队列第一个还没有发送的元素*/</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>tcp_push的代码如下所示：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">static</span> <span class="type">void</span> <span class="title function_">tcp_push</span><span class="params">(<span class="keyword">struct</span> sock *sk, <span class="type">int</span> flags, <span class="type">int</span> mss_now,</span></span><br><span class="line"><span class="params">             <span class="type">int</span> nonagle, <span class="type">int</span> size_goal)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">tcp_sock</span> *<span class="title">tp</span> =</span> tcp_sk(sk);</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">sk_buff</span> *<span class="title">skb</span>;</span></span><br><span class="line"></span><br><span class="line">    skb = tcp_write_queue_tail(sk);</span><br><span class="line">    <span class="keyword">if</span> (!skb)</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    <span class="keyword">if</span> (!(flags &amp; MSG_MORE) || forced_push(tp))</span><br><span class="line">        tcp_mark_push(tp, skb);</span><br><span class="line"></span><br><span class="line">    tcp_mark_urg(tp, flags);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (tcp_should_autocork(sk, skb, size_goal)) &#123;</span><br><span class="line"></span><br><span class="line">        <span class="comment">/* avoid atomic op if TSQ_THROTTLED bit is already set */</span></span><br><span class="line">        <span class="keyword">if</span> (!test_bit(TSQ_THROTTLED, &amp;sk-&gt;sk_tsq_flags)) &#123;</span><br><span class="line">            NET_INC_STATS(sock_net(sk), LINUX_MIB_TCPAUTOCORKING);</span><br><span class="line">            set_bit(TSQ_THROTTLED, &amp;sk-&gt;sk_tsq_flags);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">/* It is possible TX completion already happened</span></span><br><span class="line"><span class="comment">         * before we set TSQ_THROTTLED.</span></span><br><span class="line"><span class="comment">         */</span></span><br><span class="line">        <span class="keyword">if</span> (refcount_read(&amp;sk-&gt;sk_wmem_alloc) &gt; skb-&gt;truesize)</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (flags &amp; MSG_MORE)</span><br><span class="line">        nonagle = TCP_NAGLE_CORK;</span><br><span class="line"></span><br><span class="line">    __tcp_push_pending_frames(sk, mss_now, nonagle); <span class="comment">//最终通过调用该函数发送数据</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>在之后tcp_push调用了__tcp_push_pending_frames(sk, mss_now, nonagle);来发送数据</p>
<p>__tcp_push_pending_frames的代码如下所示：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">void</span> __tcp_push_pending_frames(<span class="keyword">struct</span> sock *sk, <span class="type">unsigned</span> <span class="type">int</span> cur_mss,</span><br><span class="line">                   <span class="type">int</span> nonagle)</span><br><span class="line">&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (tcp_write_xmit(sk, cur_mss, nonagle, <span class="number">0</span>,</span><br><span class="line">               sk_gfp_mask(sk, GFP_ATOMIC))) <span class="comment">//调用该函数发送数据</span></span><br><span class="line">        tcp_check_probe_timer(sk);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>在__tcp_push_pending_frames又调用了tcp_write_xmit来发送数据，代码如下所示：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">static</span> <span class="type">bool</span> <span class="title function_">tcp_write_xmit</span><span class="params">(<span class="keyword">struct</span> sock *sk, <span class="type">unsigned</span> <span class="type">int</span> mss_now, <span class="type">int</span> nonagle,</span></span><br><span class="line"><span class="params">               <span class="type">int</span> push_one, <span class="type">gfp_t</span> gfp)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">tcp_sock</span> *<span class="title">tp</span> =</span> tcp_sk(sk);</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">sk_buff</span> *<span class="title">skb</span>;</span></span><br><span class="line">    <span class="type">unsigned</span> <span class="type">int</span> tso_segs, sent_pkts;</span><br><span class="line">    <span class="type">int</span> cwnd_quota;</span><br><span class="line">    <span class="type">int</span> result;</span><br><span class="line">    <span class="type">bool</span> is_cwnd_limited = <span class="literal">false</span>, is_rwnd_limited = <span class="literal">false</span>;</span><br><span class="line">    u32 max_segs;</span><br><span class="line">    <span class="comment">/*统计已发送的报文总数*/</span></span><br><span class="line">    sent_pkts = <span class="number">0</span>;</span><br><span class="line">    ......</span><br><span class="line"></span><br><span class="line">    <span class="comment">/*若发送队列未满，则准备发送报文*/</span></span><br><span class="line">    <span class="keyword">while</span> ((skb = tcp_send_head(sk))) &#123;</span><br><span class="line">        <span class="type">unsigned</span> <span class="type">int</span> limit;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (unlikely(tp-&gt;repair) &amp;&amp; tp-&gt;repair_queue == TCP_SEND_QUEUE) &#123;</span><br><span class="line">            <span class="comment">/* &quot;skb_mstamp_ns&quot; is used as a start point for the retransmit timer */</span></span><br><span class="line">            skb-&gt;skb_mstamp_ns = tp-&gt;tcp_wstamp_ns = tp-&gt;tcp_clock_cache;</span><br><span class="line">            list_move_tail(&amp;skb-&gt;tcp_tsorted_anchor, &amp;tp-&gt;tsorted_sent_queue);</span><br><span class="line">            tcp_init_tso_segs(skb, mss_now);</span><br><span class="line">            <span class="keyword">goto</span> repair; <span class="comment">/* Skip network transmission */</span></span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (tcp_pacing_check(sk))</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line"></span><br><span class="line">        tso_segs = tcp_init_tso_segs(skb, mss_now);</span><br><span class="line">        BUG_ON(!tso_segs);</span><br><span class="line">        <span class="comment">/*检查发送窗口的大小*/</span></span><br><span class="line">        cwnd_quota = tcp_cwnd_test(tp, skb);</span><br><span class="line">        <span class="keyword">if</span> (!cwnd_quota) &#123;</span><br><span class="line">            <span class="keyword">if</span> (push_one == <span class="number">2</span>)</span><br><span class="line">                <span class="comment">/* Force out a loss probe pkt. */</span></span><br><span class="line">                cwnd_quota = <span class="number">1</span>;</span><br><span class="line">            <span class="keyword">else</span></span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (unlikely(!tcp_snd_wnd_test(tp, skb, mss_now))) &#123;</span><br><span class="line">            is_rwnd_limited = <span class="literal">true</span>;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        ......</span><br><span class="line">        limit = mss_now;</span><br><span class="line">        <span class="keyword">if</span> (tso_segs &gt; <span class="number">1</span> &amp;&amp; !tcp_urg_mode(tp))</span><br><span class="line">            limit = tcp_mss_split_point(sk, skb, mss_now,</span><br><span class="line">                            <span class="type">min_t</span>(<span class="type">unsigned</span> <span class="type">int</span>,</span><br><span class="line">                              cwnd_quota,</span><br><span class="line">                              max_segs),</span><br><span class="line">                            nonagle);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (skb-&gt;len &gt; limit &amp;&amp;</span><br><span class="line">            unlikely(tso_fragment(sk, TCP_FRAG_IN_WRITE_QUEUE,</span><br><span class="line">                      skb, limit, mss_now, gfp)))</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (tcp_small_queue_check(sk, skb, <span class="number">0</span>))</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (unlikely(tcp_transmit_skb(sk, skb, <span class="number">1</span>, gfp))) <span class="comment">//调用该函数发送数据</span></span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">    ......</span><br><span class="line">    </span><br></pre></td></tr></table></figure>
<p>tcp_write_xmit位于tcpoutput.c中，它实现了tcp的拥塞控制，然后调用了tcp_transmit_skb(sk, skb, 1, gfp)传输数据，实际上调用的是__tcp_transmit_skb。</p>
<p>__tcp_transmit_skb的部分代码如下所示：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">static</span> <span class="type">int</span> __tcp_transmit_skb(<span class="keyword">struct</span> sock *sk, <span class="keyword">struct</span> sk_buff *skb,</span><br><span class="line">                  <span class="type">int</span> clone_it, <span class="type">gfp_t</span> gfp_mask, u32 rcv_nxt)</span><br><span class="line">&#123;</span><br><span class="line">    </span><br><span class="line">    skb_push(skb, tcp_header_size);</span><br><span class="line">    skb_reset_transport_header(skb);</span><br><span class="line">    ......</span><br><span class="line">    <span class="comment">/* 构建TCP头部和校验和 */</span></span><br><span class="line">    th = (<span class="keyword">struct</span> tcphdr *)skb-&gt;data;</span><br><span class="line">    th-&gt;source        = inet-&gt;inet_sport;</span><br><span class="line">    th-&gt;dest        = inet-&gt;inet_dport;</span><br><span class="line">    th-&gt;seq            = htonl(tcb-&gt;seq);</span><br><span class="line">    th-&gt;ack_seq        = htonl(rcv_nxt);</span><br><span class="line"></span><br><span class="line">    tcp_options_write((__be32 *)(th + <span class="number">1</span>), tp, &amp;opts);</span><br><span class="line">    skb_shinfo(skb)-&gt;gso_type = sk-&gt;sk_gso_type;</span><br><span class="line">    <span class="keyword">if</span> (likely(!(tcb-&gt;tcp_flags &amp; TCPHDR_SYN))) &#123;</span><br><span class="line">        th-&gt;window      = htons(tcp_select_window(sk));</span><br><span class="line">        tcp_ecn_send(sk, skb, th, tcp_header_size);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="comment">/* RFC1323: The window in SYN &amp; SYN/ACK segments</span></span><br><span class="line"><span class="comment">         * is never scaled.</span></span><br><span class="line"><span class="comment">         */</span></span><br><span class="line">        th-&gt;window    = htons(min(tp-&gt;rcv_wnd, <span class="number">65535U</span>));</span><br><span class="line">    &#125;</span><br><span class="line">    ......</span><br><span class="line">    icsk-&gt;icsk_af_ops-&gt;send_check(sk, skb);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (likely(tcb-&gt;tcp_flags &amp; TCPHDR_ACK))</span><br><span class="line">        tcp_event_ack_sent(sk, tcp_skb_pcount(skb), rcv_nxt);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (skb-&gt;len != tcp_header_size) &#123;</span><br><span class="line">        tcp_event_data_sent(tp, sk);</span><br><span class="line">        tp-&gt;data_segs_out += tcp_skb_pcount(skb);</span><br><span class="line">        tp-&gt;bytes_sent += skb-&gt;len - tcp_header_size;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (after(tcb-&gt;end_seq, tp-&gt;snd_nxt) || tcb-&gt;seq == tcb-&gt;end_seq)</span><br><span class="line">        TCP_ADD_STATS(sock_net(sk), TCP_MIB_OUTSEGS,</span><br><span class="line">                  tcp_skb_pcount(skb));</span><br><span class="line"></span><br><span class="line">    tp-&gt;segs_out += tcp_skb_pcount(skb);</span><br><span class="line">    <span class="comment">/* OK, its time to fill skb_shinfo(skb)-&gt;gso_&#123;segs|size&#125; */</span></span><br><span class="line">    skb_shinfo(skb)-&gt;gso_segs = tcp_skb_pcount(skb);</span><br><span class="line">    skb_shinfo(skb)-&gt;gso_size = tcp_skb_mss(skb);</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* Leave earliest departure time in skb-&gt;tstamp (skb-&gt;skb_mstamp_ns) */</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">/* Cleanup our debris for IP stacks */</span></span><br><span class="line">    <span class="built_in">memset</span>(skb-&gt;cb, <span class="number">0</span>, max(<span class="keyword">sizeof</span>(<span class="keyword">struct</span> inet_skb_parm),</span><br><span class="line">                   <span class="keyword">sizeof</span>(<span class="keyword">struct</span> inet6_skb_parm)));</span><br><span class="line"></span><br><span class="line">    err = icsk-&gt;icsk_af_ops-&gt;queue_xmit(sk, skb, &amp;inet-&gt;cork.fl); <span class="comment">//调用网络层的发送接口</span></span><br><span class="line">    ......</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>__tcp_transmit_skb是位于传输层发送tcp数据的最后一步，这里首先对TCP数据段的头部进行了处理，然后调用了网络层提供的发送接口：</p>
<p>icsk-&gt;icsk_af_ops-&gt;queue_xmit(sk, skb, &amp;inet-&gt;cork.fl);实现了数据的发送，自此，数据离开了传输层，传输层的任务也就结束了。</p>
<p>传输层时序图如下图所示：</p>
<p><img src="https://user-images.githubusercontent.com/87457873/127459705-58e89b43-bcfb-43a4-861e-9affcefed5c1.png" alt="image"></p>
<p>GDB调试如下所示。</p>
<p><img src="https://user-images.githubusercontent.com/87457873/127459738-790d6b13-ecc0-4ba2-91f0-21b06f51b56c.png" alt="image"></p>
<h3 id="2、网络层分析"><a href="#2、网络层分析" class="headerlink" title="2、网络层分析"></a>2、网络层分析</h3><p>将TCP传输过来的数据包打包成IP数据报，将数据打包成IP数据包之后，通过调用ip_local_out函数，在该函数内部调用了__ip_local_out，该函数返回了一个nf_hook函数，在该函数内部调用了dst_output</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">ip_queue_xmit</span><span class="params">(<span class="keyword">struct</span> sock *sk, <span class="keyword">struct</span> sk_buff *skb, <span class="keyword">struct</span> flowi *fl)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">inet_sock</span> *<span class="title">inet</span> =</span> inet_sk(sk);</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">net</span> *<span class="title">net</span> =</span> sock_net(sk);</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">ip_options_rcu</span> *<span class="title">inet_opt</span>;</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">flowi4</span> *<span class="title">fl4</span>;</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">rtable</span> *<span class="title">rt</span>;</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">iphdr</span> *<span class="title">iph</span>;</span></span><br><span class="line">    <span class="type">int</span> res;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* Skip all of this if the packet is already routed,</span></span><br><span class="line"><span class="comment">     * f.e. by something like SCTP.</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    rcu_read_lock();</span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">     * 如果待输出的数据包已准备好路由缓存，</span></span><br><span class="line"><span class="comment">     * 则无需再查找路由，直接跳转到packet_routed</span></span><br><span class="line"><span class="comment">     * 处作处理。</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    inet_opt = rcu_dereference(inet-&gt;inet_opt);</span><br><span class="line">    fl4 = &amp;fl-&gt;u.ip4;</span><br><span class="line">    rt = skb_rtable(skb);</span><br><span class="line">    <span class="keyword">if</span> (rt)</span><br><span class="line">        <span class="keyword">goto</span> packet_routed;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* Make sure we can route this packet. */</span></span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">     * 如果输出该数据包的传输控制块中</span></span><br><span class="line"><span class="comment">     * 缓存了输出路由缓存项，则需检测</span></span><br><span class="line"><span class="comment">     * 该路由缓存项是否过期。</span></span><br><span class="line"><span class="comment">     * 如果过期，重新通过输出网络设备、</span></span><br><span class="line"><span class="comment">     * 目的地址、源地址等信息查找输出</span></span><br><span class="line"><span class="comment">     * 路由缓存项。如果查找到对应的路</span></span><br><span class="line"><span class="comment">     * 由缓存项，则将其缓存到传输控制</span></span><br><span class="line"><span class="comment">     * 块中，否则丢弃该数据包。</span></span><br><span class="line"><span class="comment">     * 如果未过期，则直接使用缓存在</span></span><br><span class="line"><span class="comment">     * 传输控制块中的路由缓存项。</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    rt = (<span class="keyword">struct</span> rtable *)__sk_dst_check(sk, <span class="number">0</span>);</span><br><span class="line">    <span class="keyword">if</span> (!rt) &#123; <span class="comment">/* 缓存过期 */</span></span><br><span class="line">        __be32 daddr;</span><br><span class="line"></span><br><span class="line">        <span class="comment">/* Use correct destination address if we have options. */</span></span><br><span class="line">        daddr = inet-&gt;inet_daddr; <span class="comment">/* 目的地址 */</span></span><br><span class="line">        <span class="keyword">if</span> (inet_opt &amp;&amp; inet_opt-&gt;opt.srr)</span><br><span class="line">            daddr = inet_opt-&gt;opt.faddr; <span class="comment">/* 严格路由选项 */</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">/* If this fails, retransmit mechanism of transport layer will</span></span><br><span class="line"><span class="comment">         * keep trying until route appears or the connection times</span></span><br><span class="line"><span class="comment">         * itself out.</span></span><br><span class="line"><span class="comment">         */</span> <span class="comment">/* 查找路由缓存 */</span></span><br><span class="line">        rt = ip_route_output_ports(net, fl4, sk,</span><br><span class="line">                       daddr, inet-&gt;inet_saddr,</span><br><span class="line">                       inet-&gt;inet_dport,</span><br><span class="line">                       inet-&gt;inet_sport,</span><br><span class="line">                       sk-&gt;sk_protocol,</span><br><span class="line">                       RT_CONN_FLAGS(sk),</span><br><span class="line">                       sk-&gt;sk_bound_dev_if);</span><br><span class="line">        <span class="keyword">if</span> (IS_ERR(rt))</span><br><span class="line">            <span class="keyword">goto</span> no_route;</span><br><span class="line">        sk_setup_caps(sk, &amp;rt-&gt;dst);  <span class="comment">/* 设置控制块的路由缓存 */</span></span><br><span class="line">    &#125;</span><br><span class="line">    skb_dst_set_noref(skb, &amp;rt-&gt;dst);<span class="comment">/* 将路由设置到skb中 */</span></span><br><span class="line"></span><br><span class="line">packet_routed:</span><br><span class="line">    <span class="keyword">if</span> (inet_opt &amp;&amp; inet_opt-&gt;opt.is_strictroute &amp;&amp; rt-&gt;rt_uses_gateway)</span><br><span class="line">        <span class="keyword">goto</span> no_route;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* OK, we know where to send it, allocate and build IP header. */</span></span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">     * 设置IP首部中各字段的值。如果存在IP选项，</span></span><br><span class="line"><span class="comment">     * 则在IP数据包首部中构建IP选项。</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    skb_push(skb, <span class="keyword">sizeof</span>(<span class="keyword">struct</span> iphdr) + (inet_opt ? inet_opt-&gt;opt.optlen : <span class="number">0</span>));</span><br><span class="line">    skb_reset_network_header(skb);</span><br><span class="line">    iph = ip_hdr(skb);<span class="comment">/* 构造ip头 */</span></span><br><span class="line">    *((__be16 *)iph) = htons((<span class="number">4</span> &lt;&lt; <span class="number">12</span>) | (<span class="number">5</span> &lt;&lt; <span class="number">8</span>) | (inet-&gt;tos &amp; <span class="number">0xff</span>));</span><br><span class="line">    <span class="keyword">if</span> (ip_dont_fragment(sk, &amp;rt-&gt;dst) &amp;&amp; !skb-&gt;ignore_df)</span><br><span class="line">        iph-&gt;frag_off = htons(IP_DF);</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">        iph-&gt;frag_off = <span class="number">0</span>;</span><br><span class="line">    iph-&gt;ttl      = ip_select_ttl(inet, &amp;rt-&gt;dst);</span><br><span class="line">    iph-&gt;protocol = sk-&gt;sk_protocol;</span><br><span class="line">    ip_copy_addrs(iph, fl4);</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* Transport layer set skb-&gt;h.foo itself. */</span></span><br><span class="line">     <span class="comment">/* 构造ip选项 */</span></span><br><span class="line">    <span class="keyword">if</span> (inet_opt &amp;&amp; inet_opt-&gt;opt.optlen) &#123;</span><br><span class="line">        iph-&gt;ihl += inet_opt-&gt;opt.optlen &gt;&gt; <span class="number">2</span>;</span><br><span class="line">        ip_options_build(skb, &amp;inet_opt-&gt;opt, inet-&gt;inet_daddr, rt, <span class="number">0</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    ip_select_ident_segs(net, skb, sk,</span><br><span class="line">                 skb_shinfo(skb)-&gt;gso_segs ?: <span class="number">1</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* TODO : should we use skb-&gt;sk here instead of sk ? */</span></span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">     * 设置输出数据包的QoS类型。</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    skb-&gt;priority = sk-&gt;sk_priority;</span><br><span class="line">    skb-&gt;mark = sk-&gt;sk_mark;</span><br><span class="line"></span><br><span class="line">    res = ip_local_out(net, sk, skb);  <span class="comment">/* 输出 */</span></span><br><span class="line">    rcu_read_unlock();</span><br><span class="line">    <span class="keyword">return</span> res;</span><br><span class="line"></span><br><span class="line">no_route:</span><br><span class="line">    rcu_read_unlock();</span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">     * 如果查找不到对应的路由缓存项，</span></span><br><span class="line"><span class="comment">     * 在此处理，将该数据包丢弃。</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    IP_INC_STATS(net, IPSTATS_MIB_OUTNOROUTES);</span><br><span class="line">    kfree_skb(skb);</span><br><span class="line">    <span class="keyword">return</span> -EHOSTUNREACH;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>dst_output()实际调用skb_dst(skb)-&gt;output(skb)，skb_dst(skb)就是skb所对应的路由项。skb_dst(skb)指向的是路由项dst_entry，它的input在收到报文时赋值ip_local_deliver()，而output在发送报文时赋值ip_output()，该函数的作用是处理单播数据报，设置数据报的输出网络设备以及网络层协议类型参数。随后调用ip_finish_output，观察数据报长度是否大于MTU，若大于，则调用ip_fragment分片，否则调用ip_finish_output2输出。在ip_finish_output2函数中会检测skb的前部空间是否还能存储链路层首部。如果不够，就会申请更大的存储空间，最终会调用邻居子系统的输出函数neigh_output进行输出，输出分为有二层头缓存和没有两种情况，有缓存时调用neigh_hh_output进行快速输出，没有缓存时，则调用邻居子系统的输出回调函数进行慢速输出。</p>
<p>网络层时序图如下图所示。</p>
<p><img src="https://user-images.githubusercontent.com/87457873/127459859-c301360c-a540-497c-ac5d-26f4de0dbdb9.png" alt="image"></p>
<p>GDB调试结果如下。</p>
<p><img src="https://user-images.githubusercontent.com/87457873/127459945-d8dcffe1-39b2-42de-a877-8cbed25b7f1e.png" alt="image"></p>
<h3 id="3、数据链路层分析"><a href="#3、数据链路层分析" class="headerlink" title="3、数据链路层分析"></a>3、数据链路层分析</h3><p>网络层最终会通过调用dev_queue_xmit来发送报文，在该函数中调用的是__dev_queue_xmit(skb, NULL);，如下所示：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">dev_queue_xmit</span><span class="params">(<span class="keyword">struct</span> sk_buff *skb)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">return</span> __dev_queue_xmit(skb, <span class="literal">NULL</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>直接调用__dev_queue_xmit传入的参数是一个skb 数据包</p>
<p>__dev_queue_xmit函数会根据不同的情况会调用__dev_xmit_skb或者sch_direct_xmit函数，最终会调用dev_hard_start_xmit函数，该函数最终会调用xmit_one来发送一到多个数据包。</p>
<p>数据链路层时序图如下所示。</p>
<p><img src="https://user-images.githubusercontent.com/87457873/127460006-68b34ede-8413-4ab7-b8fc-8a260857151e.png" alt="image"></p>
<p>GDB调试结果。</p>
<p><img src="https://user-images.githubusercontent.com/87457873/127460024-8e3fa78f-5695-4da9-8194-20258a22b2cc.png" alt="image"></p>
<h2 id="四、recv分析"><a href="#四、recv分析" class="headerlink" title="四、recv分析"></a>四、recv分析</h2><h3 id="1、数据链路层分析"><a href="#1、数据链路层分析" class="headerlink" title="1、数据链路层分析"></a>1、数据链路层分析</h3><p>在数据链路层接受数据并传递给上层的步骤如下所示：</p>
<p>1、一个 package 到达机器的物理网络适配器，当它接收到数据帧时，就会触发一个中断，并将通过 DMA 传送到位于 linux kernel 内存中的 rx_ring。<br><br>2、网卡发出中断，通知 CPU 有个 package 需要它处理。中断处理程序主要进行以下一些操作，包括分配 skb_buff 数据结构，并将接收到的数据帧从网络适配器I&#x2F;O端口拷贝到skb_buff 缓冲区中；从数据帧中提取出一些信息，并设置 skb_buff相应的参数，这些参数将被上层的网络协议使用，例如skb-&gt;protocol；<br><br>3、终端处理程序经过简单处理后，发出一个软中断（NET_RX_SOFTIRQ），通知内核接收到新的数据帧。<br><br>4、内核 2.5 中引入一组新的 API 来处理接收的数据帧，即 NAPI。所以，驱动有两种方式通知内核：(1) 通过以前的函数netif_rx；(2)通过NAPI机制。该中断处理程序调用 Network device的 netif_rx_schedule函数，进入软中断处理流程，再调用net_rx_action函数。<br><br>5、该函数关闭中断，获取每个 Network device 的 rx_ring 中的所有 package，最终 pacakage 从 rx_ring 中被删除，进入netif _receive_skb处理流程。<br><br>6、netif_receive_skb是链路层接收数据报的最后一站。它根据注册在全局数组 ptype_all 和 ptype_base 里的网络层数据报类型，把数据报递交给不同的网络层协议的接收函数(INET域中主要是ip_rcv和arp_rcv)。该函数主要就是调用第三层协议的接收函数处理该skb包，进入第三层网络层处理。<br></p>
<p>数据链路层的时序图如下所示。</p>
<p><img src="https://user-images.githubusercontent.com/87457873/127460208-acaf449e-8a4e-4938-afa5-46fd3c7e31c3.png" alt="image"></p>
<p>GDB调试如下。</p>
<p><img src="https://user-images.githubusercontent.com/87457873/127460233-529bc635-9488-4fc1-8f3d-383185560a4b.png" alt="image"></p>
<h3 id="2、网络层分析-1"><a href="#2、网络层分析-1" class="headerlink" title="2、网络层分析"></a>2、网络层分析</h3><p>ip层的入口在ip_rcv函数，该函数首先会做包括 package checksum 在内的各种检查，如果需要的话会做 IP defragment（将多个分片合并），然后 packet 调用已经注册的 Pre-routing netfilter hook ，完成后最终到达ip_rcv_finish函数。</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">ip_rcv</span><span class="params">(<span class="keyword">struct</span> sk_buff *skb, <span class="keyword">struct</span> net_device *dev, <span class="keyword">struct</span> packet_type *pt,</span></span><br><span class="line"><span class="params">       <span class="keyword">struct</span> net_device *orig_dev)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">net</span> *<span class="title">net</span> =</span> dev_net(dev);</span><br><span class="line"></span><br><span class="line">    skb = ip_rcv_core(skb, net);</span><br><span class="line">    <span class="keyword">if</span> (skb == <span class="literal">NULL</span>)</span><br><span class="line">        <span class="keyword">return</span> NET_RX_DROP;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> NF_HOOK(NFPROTO_IPV4, NF_INET_PRE_ROUTING,</span><br><span class="line">               net, <span class="literal">NULL</span>, skb, dev, <span class="literal">NULL</span>,</span><br><span class="line">               ip_rcv_finish);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>ip_rcv_finish函数如下所示：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">static</span> <span class="type">int</span> <span class="title function_">ip_rcv_finish</span><span class="params">(<span class="keyword">struct</span> net *net, <span class="keyword">struct</span> sock *sk, <span class="keyword">struct</span> sk_buff *skb)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">net_device</span> *<span class="title">dev</span> =</span> skb-&gt;dev;</span><br><span class="line">    <span class="type">int</span> ret;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* if ingress device is enslaved to an L3 master device pass the</span></span><br><span class="line"><span class="comment">     * skb to its handler for processing</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    skb = l3mdev_ip_rcv(skb);</span><br><span class="line">    <span class="keyword">if</span> (!skb)</span><br><span class="line">        <span class="keyword">return</span> NET_RX_SUCCESS;</span><br><span class="line"></span><br><span class="line">    ret = ip_rcv_finish_core(net, sk, skb, dev, <span class="literal">NULL</span>);</span><br><span class="line">    <span class="keyword">if</span> (ret != NET_RX_DROP)</span><br><span class="line">        ret = dst_input(skb);</span><br><span class="line">    <span class="keyword">return</span> ret;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>ip_rcv_finish 函数最终会调用ip_route_input函数，进入路由处理环节。它首先会调用 ip_route_input 来更新路由，然后查找 route，决定该 package 将会被发到本机还是会被转发还是丢弃：</p>
<p>1、如果是发到本机的话，调用ip_local_deliver 函数，可能会做 de-fragment（合并多个 IP packet），然后调用ip_local_deliver函数。该函数根据 package 的下一个处理层的 protocal number，调用下一层接口，包括 tcp_v4_rcv （TCP）, udp_rcv （UDP），icmp_rcv (ICMP)，igmp_rcv(IGMP)。对于 TCP 来说，函数 tcp_v4_rcv 函数会被调用，从而处理流程进入 TCP 栈。<br><br>2、如果需要转发 （forward），则进入转发流程。该流程需要处理 TTL，再调用dst_input函数。该函数会 （1）处理 Netfilter Hook （2）执行 IP fragmentation （3）调用 dev_queue_xmit，进入链路层处理流程。</p>
<p>网络层时序图如下图所示。</p>
<p><img src="https://user-images.githubusercontent.com/87457873/127460441-3fe2e740-5f9e-44f1-b99b-872167a92176.png" alt="image"></p>
<p>GDB调试如下图所示。</p>
<p><img src="https://user-images.githubusercontent.com/87457873/127460461-f71b6ea5-0573-4d32-9087-cf9a1c8d88a5.png" alt="image"></p>
<h3 id="3、传输层分析"><a href="#3、传输层分析" class="headerlink" title="3、传输层分析"></a>3、传输层分析</h3><p>对于recv函数，与send函数类似，调用的系统调用是__sys_recvfrom，其代码如下所示：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">int</span> __sys_recvfrom(<span class="type">int</span> fd, <span class="type">void</span> __user *ubuf, <span class="type">size_t</span> size, <span class="type">unsigned</span> <span class="type">int</span> flags,</span><br><span class="line">           <span class="keyword">struct</span> sockaddr __user *addr, <span class="type">int</span> __user *addr_len)</span><br><span class="line">&#123;</span><br><span class="line">    ......</span><br><span class="line">    err = import_single_range(READ, ubuf, size, &amp;iov, &amp;msg.msg_iter);</span><br><span class="line">    <span class="keyword">if</span> (unlikely(err))</span><br><span class="line">        <span class="keyword">return</span> err;</span><br><span class="line">    sock = sockfd_lookup_light(fd, &amp;err, &amp;fput_needed);</span><br><span class="line">    .....</span><br><span class="line">    msg.msg_control = <span class="literal">NULL</span>;</span><br><span class="line">    msg.msg_controllen = <span class="number">0</span>;</span><br><span class="line">    <span class="comment">/* Save some cycles and don&#x27;t copy the address if not needed */</span></span><br><span class="line">    msg.msg_name = addr ? (<span class="keyword">struct</span> sockaddr *)&amp;address : <span class="literal">NULL</span>;</span><br><span class="line">    <span class="comment">/* We assume all kernel code knows the size of sockaddr_storage */</span></span><br><span class="line">    msg.msg_namelen = <span class="number">0</span>;</span><br><span class="line">    msg.msg_iocb = <span class="literal">NULL</span>;</span><br><span class="line">    msg.msg_flags = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">if</span> (sock-&gt;file-&gt;f_flags &amp; O_NONBLOCK)</span><br><span class="line">        flags |= MSG_DONTWAIT;</span><br><span class="line">    err = sock_recvmsg(sock, &amp;msg, flags); <span class="comment">//调用该函数接受数据</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (err &gt;= <span class="number">0</span> &amp;&amp; addr != <span class="literal">NULL</span>) &#123;</span><br><span class="line">        err2 = move_addr_to_user(&amp;address,</span><br><span class="line">                     msg.msg_namelen, addr, addr_len);</span><br><span class="line">    .....</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>__sys_recvfrom通过调用sock_recvmsg来对数据进行接收，该函数实际调用的是sock-&gt;ops-&gt;recvmsg(sock, msg, msg_data_left(msg), flags); ，同样类似send函数中，调用的实际上是socket在初始化时赋值给结构体struct proto tcp_prot的函数tcp_rcvmsg，如下所示：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">proto</span> <span class="title">tcp_prot</span> =</span> &#123;</span><br><span class="line">    .name            = <span class="string">&quot;TCP&quot;</span>,</span><br><span class="line">    .owner            = THIS_MODULE,</span><br><span class="line">    .close            = tcp_close,</span><br><span class="line">    .pre_connect        = tcp_v4_pre_connect,</span><br><span class="line">    .connect        = tcp_v4_connect,</span><br><span class="line">    .disconnect        = tcp_disconnect,</span><br><span class="line">    .accept            = inet_csk_accept,</span><br><span class="line">    .ioctl            = tcp_ioctl,</span><br><span class="line">    .init            = tcp_v4_init_sock,</span><br><span class="line">    .destroy        = tcp_v4_destroy_sock,</span><br><span class="line">    .shutdown        = tcp_shutdown,</span><br><span class="line">    .setsockopt        = tcp_setsockopt,</span><br><span class="line">    .getsockopt        = tcp_getsockopt,</span><br><span class="line">    .keepalive        = tcp_set_keepalive,</span><br><span class="line">    .recvmsg        = tcp_recvmsg,</span><br><span class="line">    .sendmsg        = tcp_sendmsg,</span><br><span class="line">  ...</span><br><span class="line">tcp_rcvmsg的代码如下所示：</span><br><span class="line"><span class="type">int</span> tcp_recvmsg(<span class="keyword">struct</span> sock *sk, <span class="keyword">struct</span> msghdr *msg, <span class="type">size_t</span> len, <span class="type">int</span> nonblock,</span><br><span class="line">        <span class="type">int</span> flags, <span class="type">int</span> *addr_len)</span><br><span class="line">&#123;</span><br><span class="line">    ......</span><br><span class="line">    <span class="keyword">if</span> (sk_can_busy_loop(sk) &amp;&amp; skb_queue_empty(&amp;sk-&gt;sk_receive_queue) &amp;&amp;</span><br><span class="line">        (sk-&gt;sk_state == TCP_ESTABLISHED))</span><br><span class="line">        sk_busy_loop(sk, nonblock); <span class="comment">//如果接收队列为空，则会在该函数内循环等待</span></span><br><span class="line"></span><br><span class="line">    lock_sock(sk);</span><br><span class="line">    .....</span><br><span class="line">        <span class="keyword">if</span> (unlikely(tp-&gt;repair)) &#123;</span><br><span class="line">        err = -EPERM;</span><br><span class="line">        <span class="keyword">if</span> (!(flags &amp; MSG_PEEK))</span><br><span class="line">            <span class="keyword">goto</span> out;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (tp-&gt;repair_queue == TCP_SEND_QUEUE) </span><br><span class="line">            <span class="keyword">goto</span> recv_sndq;</span><br><span class="line"></span><br><span class="line">        err = -EINVAL;</span><br><span class="line">        <span class="keyword">if</span> (tp-&gt;repair_queue == TCP_NO_QUEUE)</span><br><span class="line">            <span class="keyword">goto</span> out;</span><br><span class="line">    ......</span><br><span class="line">        last = skb_peek_tail(&amp;sk-&gt;sk_receive_queue); </span><br><span class="line">        skb_queue_walk(&amp;sk-&gt;sk_receive_queue, skb) &#123;</span><br><span class="line">            last = skb;</span><br><span class="line">    ......</span><br><span class="line">            <span class="keyword">if</span> (!(flags &amp; MSG_TRUNC)) &#123;</span><br><span class="line">            err = skb_copy_datagram_msg(skb, offset, msg, used); <span class="comment">//将接收到的数据拷贝到用户态</span></span><br><span class="line">            <span class="keyword">if</span> (err) &#123;</span><br><span class="line">                <span class="comment">/* Exception. Bailout! */</span></span><br><span class="line">                <span class="keyword">if</span> (!copied)</span><br><span class="line">                    copied = -EFAULT;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        *seq += used;</span><br><span class="line">        copied += used;</span><br><span class="line">        len -= used;</span><br><span class="line"></span><br><span class="line">        tcp_rcv_space_adjust(sk);</span><br></pre></td></tr></table></figure>
<p>在连接建立后，若没有数据到来，接收队列为空，进程会在sk_busy_loop函数内循环等待，知道接收队列不为空，并调用函数数skb_copy_datagram_msg将接收到的数据拷贝到用户态，该函数内部实际调用的是__skb_datagram_iter，其代码如下所示：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">int</span> __skb_datagram_iter(<span class="type">const</span> <span class="keyword">struct</span> sk_buff *skb, <span class="type">int</span> offset,</span><br><span class="line">            <span class="keyword">struct</span> iov_iter *to, <span class="type">int</span> len, <span class="type">bool</span> fault_short,</span><br><span class="line">            <span class="type">size_t</span> (*cb)(<span class="type">const</span> <span class="type">void</span> *, <span class="type">size_t</span>, <span class="type">void</span> *, <span class="keyword">struct</span> iov_iter *),</span><br><span class="line">            <span class="type">void</span> *data)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">int</span> start = skb_headlen(skb);</span><br><span class="line">    <span class="type">int</span> i, copy = start - offset, start_off = offset, n;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">sk_buff</span> *<span class="title">frag_iter</span>;</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">/* 拷贝tcp头部 */</span></span><br><span class="line">    <span class="keyword">if</span> (copy &gt; <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="keyword">if</span> (copy &gt; len)</span><br><span class="line">            copy = len;</span><br><span class="line">        n = cb(skb-&gt;data + offset, copy, data, to);</span><br><span class="line">        offset += n;</span><br><span class="line">        <span class="keyword">if</span> (n != copy)</span><br><span class="line">            <span class="keyword">goto</span> short_copy;</span><br><span class="line">        <span class="keyword">if</span> ((len -= copy) == <span class="number">0</span>)</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* 拷贝数据部分 */</span></span><br><span class="line">    <span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; skb_shinfo(skb)-&gt;nr_frags; i++) &#123;</span><br><span class="line">        <span class="type">int</span> end;</span><br><span class="line">        <span class="type">const</span> <span class="type">skb_frag_t</span> *frag = &amp;skb_shinfo(skb)-&gt;frags[i];</span><br><span class="line"></span><br><span class="line">        WARN_ON(start &gt; offset + len);</span><br><span class="line"></span><br><span class="line">        end = start + skb_frag_size(frag);</span><br><span class="line">        <span class="keyword">if</span> ((copy = end - offset) &gt; <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="class"><span class="keyword">struct</span> <span class="title">page</span> *<span class="title">page</span> =</span> skb_frag_page(frag);</span><br><span class="line">            u8 *vaddr = kmap(page);</span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span> (copy &gt; len)</span><br><span class="line">                copy = len;</span><br><span class="line">            n = cb(vaddr + frag-&gt;page_offset +</span><br><span class="line">                offset - start, copy, data, to);</span><br><span class="line">            kunmap(page);</span><br><span class="line">            offset += n;</span><br><span class="line">            <span class="keyword">if</span> (n != copy)</span><br><span class="line">                <span class="keyword">goto</span> short_copy;</span><br><span class="line">            <span class="keyword">if</span> (!(len -= copy))</span><br><span class="line">                <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        start = end;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>
<p>传输层时序图如下图所示。</p>
<p><img src="https://user-images.githubusercontent.com/87457873/127460642-9deb8274-b587-45bb-8e33-5eea8a69f247.png" alt="image"></p>
<p> GDB调试如下图所示。</p>
<p><img src="https://user-images.githubusercontent.com/87457873/127460687-9c34a4fe-db7b-4f61-a84c-d5aa894b96c2.png" alt="image"></p>
<h2 id="五、小结"><a href="#五、小结" class="headerlink" title="五、小结"></a>五、小结</h2><p>从Linux操作系统实现入手，深入的分析了Linux操作系统对于TCP&#x2F;IP栈的实现原理与具体过程，了解了Linux网络子系统的具体构成及流程，通过这次调研，使我对TCP&#x2F;IP协议的原理及具体实现有了极其深入的理解。</p>
]]></content>
      <categories>
        <category>linux-doc 网络协议栈</category>
      </categories>
      <tags>
        <tag>Linux</tag>
      </tags>
  </entry>
  <entry>
    <title>透过现象看本质，从linux源码角度看epoll</title>
    <url>/2023/01/15/linux-docs/%E7%BD%91%E7%BB%9C%E5%8D%8F%E8%AE%AE%E6%A0%88/%E9%80%8F%E8%BF%87%E7%8E%B0%E8%B1%A1%E7%9C%8B%E6%9C%AC%E8%B4%A8%EF%BC%8C%E4%BB%8Elinux%E6%BA%90%E7%A0%81%E8%A7%92%E5%BA%A6%E7%9C%8Bepoll/</url>
    <content><![CDATA[<p>对于较多数量的文件描述符的监听无论是select还是poll系统调用都显得捉襟见肘，poll每次都需要将所有的文件描述符复制到内核，内核本身不会对这些文件描述符加以保存，这样的设计就导致了poll的效率的低下。</p>
<p>而epoll则对此做了相应的改进，不是epoll_wait的时候才传入fd，而是通过epoll_ctl把所有fd传入内核，再一起”wait”，这就省掉了不必要的重复拷贝。</p>
<p>其次，在 epoll_wait时，也不是把current轮流的加入fd对应的设备等待队列，而是在设备等待队列醒来时调用一个回调函数（当然，这就需要“唤醒回调”机制），把产生事件的fd归入一个链表，然后返回这个链表上的fd。另外，epoll机制实现了自己特有的文件系统eventpoll filesystem。</p>
<p><img src="https://user-images.githubusercontent.com/87457873/127447306-89bb9b00-174d-4f38-9e9b-a39e3e152f89.png" alt="image"></p>
<h2 id="epoll初始化"><a href="#epoll初始化" class="headerlink" title="epoll初始化"></a>epoll初始化</h2><p>当系统启动时，epoll会进行初始化操作</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">static</span> <span class="type">int</span> __init <span class="title function_">eventpoll_init</span><span class="params">(<span class="type">void</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">    mutex_init(&amp;epmutex);</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* Initialize the structure used to perform safe poll wait head wake ups */</span></span><br><span class="line">    ep_poll_safewake_init(&amp;psw);</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* Allocates slab cache used to allocate &quot;struct epitem&quot; items */</span></span><br><span class="line">    epi_cache = kmem_cache_create(<span class="string">&quot;eventpoll_epi&quot;</span>, <span class="keyword">sizeof</span>(<span class="keyword">struct</span> epitem),</span><br><span class="line">            <span class="number">0</span>, SLAB_HWCACHE_ALIGN|EPI_SLAB_DEBUG|SLAB_PANIC,</span><br><span class="line">            <span class="literal">NULL</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* Allocates slab cache used to allocate &quot;struct eppoll_entry&quot; */</span></span><br><span class="line">    pwq_cache = kmem_cache_create(<span class="string">&quot;eventpoll_pwq&quot;</span>,</span><br><span class="line">            <span class="keyword">sizeof</span>(<span class="keyword">struct</span> eppoll_entry), <span class="number">0</span>,</span><br><span class="line">            EPI_SLAB_DEBUG|SLAB_PANIC, <span class="literal">NULL</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line">fs_initcall(eventpoll_init);</span><br></pre></td></tr></table></figure>

<p>上面的代码实现一些数据结构的初始化,通过fs&#x2F;eventpoll.c中的注释可以看出,有三种类型的锁机制使用场景:</p>
<p>1.epmutex(mutex):用户关闭文件描述符，但是没有调用EPOLL_CTL_DEL<br><br>2.ep-&gt;mtx(mutex):用户态与内核态的转换可能会睡眠<br><br>3.ep-&gt;lock(spinlock):内核态与具体设备中断过程中的转换,poll回调<br></p>
<p>接下来就是使用slab分配器动态分配内存，第一个结构为当系统中添加一个fd时，就创建一epitem结构体,内核管理的基本数据结构。</p>
<h2 id="内核数据结构"><a href="#内核数据结构" class="headerlink" title="内核数据结构"></a>内核数据结构</h2><p>epoll在内核主要维护了两个数据结构eventpoll与epitem，其中eventpoll表示每个epoll实例本身，epitem表示的是每一个IO所对应的的事件。</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">epitem</span> &#123;</span></span><br><span class="line">    <span class="comment">/* RB tree node used to link this structure to the eventpoll RB tree */</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">rb_node</span> <span class="title">rbn</span>;</span> <span class="comment">/*用于挂载到eventpoll管理的红黑树*/</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">/* List header used to link this structure to the eventpoll ready list */</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">list_head</span> <span class="title">rdllink</span>;</span> <span class="comment">/*挂载到eventpoll.rdlist的事件就绪队列*/</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">     * Works together &quot;struct eventpoll&quot;-&gt;ovflist in keeping the</span></span><br><span class="line"><span class="comment">     * single linked chain of items.</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">epitem</span> *<span class="title">next</span>;</span> <span class="comment">/*用于主结构体中的链表*/</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">/* The file descriptor information this item refers to */</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">epoll_filefd</span> <span class="title">ffd</span>;</span> <span class="comment">/*该结构体对应的被监听的文件描述符信息(fd+file， 作为红黑树的key)*/</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">/* Number of active wait queue attached to poll operations */</span></span><br><span class="line">    <span class="type">int</span> nwait;  <span class="comment">/*poll(轮询操作)的事件个数</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">    /* List containing poll wait queues */</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">list_head</span> <span class="title">pwqlist</span>;</span> <span class="comment">/*双向链表，保存被监视文件的等待队列，功能类似于select/poll中的poll_table；同一个文件上可能会监视多种事件，这些事件可能从属于不同的wait_queue中，所以需要使用链表</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">    /* The &quot;container&quot; of this item */</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">eventpoll</span> *<span class="title">ep</span>;</span> <span class="comment">/*当前epitem的所有者（多个epitem从属于一个eventpoll）*/</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">/* List header used to link this item to the &quot;struct file&quot; items list */</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">list_head</span> <span class="title">fllink</span>;</span> <span class="comment">/*双向链表，用来链接被监视的文件描述符对应的struct file。因为file里有f_ep_link用来保存所有监视这个文件的epoll节点</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">    /* The structure that describe the interested events and the source fd */</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">epoll_event</span> <span class="title">event</span>;</span> <span class="comment">/*注册感兴趣的事件，也就是用户空间的epoll_event</span></span><br><span class="line"><span class="comment">&#125;;</span></span><br></pre></td></tr></table></figure>

<p>而每个epoll fd对应的主要数据结构为：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">eventpoll</span> &#123;</span></span><br><span class="line">    <span class="comment">/* Protect the this structure access */</span></span><br><span class="line">    <span class="type">spinlock_t</span> lock; <span class="comment">/*自旋锁，在kernel内部用自旋锁加锁，就可以同时多线(进)程对此结构体进行操作，主要是保护ready_list*/</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">     * This mutex is used to ensure that files are not removed</span></span><br><span class="line"><span class="comment">     * while epoll is using them. This is held during the event</span></span><br><span class="line"><span class="comment">     * collection loop, the file cleanup path, the epoll file exit</span></span><br><span class="line"><span class="comment">     * code and the ctl operations.</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">mutex</span> <span class="title">mtx</span>;</span> <span class="comment">/*防止使用时被删除*/</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">/* Wait queue used by sys_epoll_wait() */</span></span><br><span class="line">    <span class="type">wait_queue_head_t</span> wq; <span class="comment">/*sys_epoll_wait()使用的等待队列*/</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">/* Wait queue used by file-&gt;poll() */</span></span><br><span class="line">    <span class="type">wait_queue_head_t</span> poll_wait; <span class="comment">/*file-&gt;epoll()使用的等待队列*/</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">/* List of ready file descriptors */</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">list_head</span> <span class="title">rdllist</span>;</span> <span class="comment">/*事件就绪链表*/</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">/* RB tree root used to store monitored fd structs */</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">rb_root</span> <span class="title">rbr</span>;</span> <span class="comment">/*用于管理当前epoll关注的文件描述符（树根）*/</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">     * This is a single linked list that chains all the &quot;struct epitem&quot; that</span></span><br><span class="line"><span class="comment">     * happened while transfering ready events to userspace w/out</span></span><br><span class="line"><span class="comment">     * holding -&gt;lock.</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">epitem</span> *<span class="title">ovflist</span>;</span> <span class="comment">/*在向用户空间传输就绪事件的时候，将同时发生事件的文件描述符链入到这个链表里面*/</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p><img src="https://user-images.githubusercontent.com/87457873/127447515-829c67df-666a-4f50-a8b0-46ab79696766.png" alt="image"></p>
<h2 id="函数调用关系"><a href="#函数调用关系" class="headerlink" title="函数调用关系"></a>函数调用关系</h2><h3 id="epoll-create"><a href="#epoll-create" class="headerlink" title="epoll_create"></a>epoll_create</h3><p>每个eventpoll通过epoll_create()创建：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">asmlinkage <span class="type">long</span> <span class="title function_">sys_epoll_create</span><span class="params">(<span class="type">int</span> size)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">int</span> error, fd = <span class="number">-1</span>;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">eventpoll</span> *<span class="title">ep</span>;</span></span><br><span class="line"></span><br><span class="line">    DNPRINTK(<span class="number">3</span>, (KERN_INFO <span class="string">&quot;[%p] eventpoll: sys_epoll_create(%d)\n&quot;</span>,</span><br><span class="line">             current, size));</span><br><span class="line"></span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">     * Sanity check on the size parameter, and create the internal data</span></span><br><span class="line"><span class="comment">     * structure ( &quot;struct eventpoll&quot; ).</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    error = -EINVAL;</span><br><span class="line">  <span class="comment">/*为ep分配内存并进行初始化*/</span></span><br><span class="line">    <span class="keyword">if</span> (size &lt;= <span class="number">0</span> || (error = ep_alloc(&amp;ep)) &lt; <span class="number">0</span>) &#123;</span><br><span class="line">        fd = error;</span><br><span class="line">        <span class="keyword">goto</span> error_return;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">     * Creates all the items needed to setup an eventpoll file. That is,</span></span><br><span class="line"><span class="comment">     * a file structure and a free file descriptor.</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">   <span class="comment">/*调用anon_inode_getfd新建一个struct file，也就是epoll可以看成一个文件（由* 于没有任何文件系统，为匿名文件）。并且将主结构体struct eventpoll *ep放入* file-&gt;private项中进行保存（sys_epoll_ctl会取用）*/</span></span><br><span class="line">    fd = anon_inode_getfd(<span class="string">&quot;[eventpoll]&quot;</span>, &amp;eventpoll_fops, ep);</span><br><span class="line">    <span class="keyword">if</span> (fd &lt; <span class="number">0</span>)</span><br><span class="line">        ep_free(ep);</span><br><span class="line"></span><br><span class="line">error_return:</span><br><span class="line">    DNPRINTK(<span class="number">3</span>, (KERN_INFO <span class="string">&quot;[%p] eventpoll: sys_epoll_create(%d) = %d\n&quot;</span>,</span><br><span class="line">             current, size, fd));</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> fd;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="epoll-ctl"><a href="#epoll-ctl" class="headerlink" title="epoll_ctl"></a>epoll_ctl</h3><figure class="highlight c"><table><tr><td class="code"><pre><span class="line">asmlinkage <span class="type">long</span> <span class="title function_">sys_epoll_ctl</span><span class="params">(<span class="type">int</span> epfd, <span class="type">int</span> op, <span class="type">int</span> fd,</span></span><br><span class="line"><span class="params">                  <span class="keyword">struct</span> epoll_event __user *event)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">int</span> error;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">file</span> *<span class="title">file</span>, *<span class="title">tfile</span>;</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">eventpoll</span> *<span class="title">ep</span>;</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">epitem</span> *<span class="title">epi</span>;</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">epoll_event</span> <span class="title">epds</span>;</span></span><br><span class="line"></span><br><span class="line">    DNPRINTK(<span class="number">3</span>, (KERN_INFO <span class="string">&quot;[%p] eventpoll: sys_epoll_ctl(%d, %d, %d, %p)\n&quot;</span>,</span><br><span class="line">             current, epfd, op, fd, event));</span><br><span class="line"></span><br><span class="line">    error = -EFAULT;</span><br><span class="line">  <span class="comment">/*判断参数合法性，将__user *event 复制给epds*/</span></span><br><span class="line">    <span class="keyword">if</span> (ep_op_has_event(op) &amp;&amp;</span><br><span class="line">        copy_from_user(&amp;epds, event, <span class="keyword">sizeof</span>(<span class="keyword">struct</span> epoll_event)))</span><br><span class="line">        <span class="keyword">goto</span> error_return;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* Get the &quot;struct file *&quot; for the eventpoll file */</span></span><br><span class="line">    error = -EBADF;</span><br><span class="line">    file = fget(epfd); <span class="comment">/*epoll fd对应的文件对象*/</span></span><br><span class="line">    <span class="keyword">if</span> (!file)</span><br><span class="line">        <span class="keyword">goto</span> error_return;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* Get the &quot;struct file *&quot; for the target file */</span></span><br><span class="line">    tfile = fget(fd); <span class="comment">/*fd对应的文件对象*/</span></span><br><span class="line">    <span class="keyword">if</span> (!tfile)</span><br><span class="line">        <span class="keyword">goto</span> error_fput;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* The target file descriptor must support poll */</span></span><br><span class="line">    error = -EPERM;</span><br><span class="line">    <span class="keyword">if</span> (!tfile-&gt;f_op || !tfile-&gt;f_op-&gt;poll)</span><br><span class="line">        <span class="keyword">goto</span> error_tgt_fput;</span><br><span class="line"></span><br><span class="line">  ...</span><br><span class="line"></span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">     * At this point it is safe to assume that the &quot;private_data&quot; contains</span></span><br><span class="line"><span class="comment">     * our own data structure.</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    ep = file-&gt;private_data; <span class="comment">/*在create时存入进去的（anon_inode_getfd），现在取用。*/</span></span><br><span class="line"></span><br><span class="line">    mutex_lock(&amp;ep-&gt;mtx);</span><br><span class="line"></span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">     * Try to lookup the file inside our RB tree, Since we grabbed &quot;mtx&quot;</span></span><br><span class="line"><span class="comment">     * above, we can be sure to be able to use the item looked up by</span></span><br><span class="line"><span class="comment">     * ep_find() till we release the mutex.</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    epi = ep_find(ep, tfile, fd); <span class="comment">/*防止重复添加（在ep的红黑树中查找是否已经存在这个fd）*/</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">switch</span> (op) &#123;</span><br><span class="line">    <span class="keyword">case</span> EPOLL_CTL_ADD: <span class="comment">/*新增一个监听fd*/</span></span><br><span class="line">        <span class="keyword">if</span> (!epi) &#123;</span><br><span class="line">            epds.events |= POLLERR | POLLHUP; <span class="comment">/*默认包含POLLERR和POLLHUP事件*/</span></span><br><span class="line"></span><br><span class="line">            error = ep_insert(ep, &amp;epds, tfile, fd); <span class="comment">/*在ep的红黑树中插入这个fd对应的epitm结构体。*/</span></span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="comment">/*重复添加（在ep的红黑树中查找已经存在这个fd）。*/</span></span><br><span class="line">            error = -EEXIST;</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line"></span><br><span class="line">  ...</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">  ...</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> error;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">其中ep_insert的实现如下：</span><br><span class="line"></span><br><span class="line">```c</span><br><span class="line"><span class="type">static</span> <span class="type">int</span> <span class="title function_">ep_insert</span><span class="params">(<span class="keyword">struct</span> eventpoll *ep, <span class="keyword">struct</span> epoll_event *event,</span></span><br><span class="line"><span class="params">             <span class="keyword">struct</span> file *tfile, <span class="type">int</span> fd)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">int</span> error, revents, pwake = <span class="number">0</span>;</span><br><span class="line">    <span class="type">unsigned</span> <span class="type">long</span> flags;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">epitem</span> *<span class="title">epi</span>;</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">ep_pqueue</span> <span class="title">epq</span>;</span></span><br><span class="line"></span><br><span class="line">    error = -ENOMEM;</span><br><span class="line">  <span class="comment">/*分配一个epitem结构体来保存每个存入的fd*/</span></span><br><span class="line">    <span class="keyword">if</span> (!(epi = kmem_cache_alloc(epi_cache, GFP_KERNEL)))</span><br><span class="line">        <span class="keyword">goto</span> error_return;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* Item initialization follow here ... */</span></span><br><span class="line">  <span class="comment">/*初始化该结构体*/</span></span><br><span class="line">    INIT_LIST_HEAD(&amp;epi-&gt;rdllink);</span><br><span class="line">    INIT_LIST_HEAD(&amp;epi-&gt;fllink);</span><br><span class="line">    INIT_LIST_HEAD(&amp;epi-&gt;pwqlist);</span><br><span class="line">    epi-&gt;ep = ep;</span><br><span class="line">    ep_set_ffd(&amp;epi-&gt;ffd, tfile, fd);</span><br><span class="line">    epi-&gt;event = *event;</span><br><span class="line">    epi-&gt;nwait = <span class="number">0</span>;</span><br><span class="line">    epi-&gt;next = EP_UNACTIVE_PTR;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* Initialize the poll table using the queue callback */</span></span><br><span class="line">    epq.epi = epi;</span><br><span class="line">  <span class="comment">/*安装poll回调函数*/</span></span><br><span class="line">    init_poll_funcptr(&amp;epq.pt, ep_ptable_queue_proc);</span><br><span class="line"></span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">     * Attach the item to the poll hooks and get current event bits.</span></span><br><span class="line"><span class="comment">     * We can safely use the file* here because its usage count has</span></span><br><span class="line"><span class="comment">     * been increased by the caller of this function. Note that after</span></span><br><span class="line"><span class="comment">     * this operation completes, the poll callback can start hitting</span></span><br><span class="line"><span class="comment">     * the new item.</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">   <span class="comment">/* </span></span><br><span class="line"><span class="comment">   * 调用poll函数来获取当前事件位，其实是利用它来调用注册函数ep_ptable_queue_proc（poll_wait中调用）。</span></span><br><span class="line"><span class="comment">   * 如果fd是套接字，f_op为socket_file_ops，poll函数是sock_poll()。</span></span><br><span class="line"><span class="comment">   * 如果是TCP套接字的话，进而会调用到tcp_poll()函数。此处调用poll函数查看当前文件描述符的状态，存储在revents中。</span></span><br><span class="line"><span class="comment">   * 在poll的处理函数(tcp_poll())中，会调用sock_poll_wait()，</span></span><br><span class="line"><span class="comment">   *  在sock_poll_wait()中会调用到epq.pt.qproc指向的函数，也就是ep_ptable_queue_proc()。  </span></span><br><span class="line"><span class="comment">   */</span> </span><br><span class="line">    revents = tfile-&gt;f_op-&gt;poll(tfile, &amp;epq.pt);</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* Add the current item to the list of active epoll hook for this file */</span></span><br><span class="line">    spin_lock(&amp;tfile-&gt;f_ep_lock);</span><br><span class="line">    list_add_tail(&amp;epi-&gt;fllink, &amp;tfile-&gt;f_ep_links);</span><br><span class="line">    spin_unlock(&amp;tfile-&gt;f_ep_lock);</span><br><span class="line"></span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">     * Add the current item to the RB tree. All RB tree operations are</span></span><br><span class="line"><span class="comment">     * protected by &quot;mtx&quot;, and ep_insert() is called with &quot;mtx&quot; held.</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    ep_rbtree_insert(ep, epi); <span class="comment">/*将该epi插入到ep的红黑树中*/</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">/* We have to drop the new item inside our item list to keep track of it */</span></span><br><span class="line">    spin_lock_irqsave(&amp;ep-&gt;lock, flags);</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* If the file is already &quot;ready&quot; we drop it inside the ready list */</span></span><br><span class="line">  <span class="comment">/* </span></span><br><span class="line"><span class="comment">  * revents &amp; event-&gt;events：刚才fop-&gt;poll的返回值中标识的事件有用户event关心的事件发生。</span></span><br><span class="line"><span class="comment">  * !ep_is_linked(&amp;epi-&gt;rdllink)：epi的ready队列中有数据。ep_is_linked用于判断队列是否为空。</span></span><br><span class="line"><span class="comment">  */</span></span><br><span class="line"></span><br><span class="line">  <span class="comment">/* 如果要监视的文件状态已经就绪并且还没有加入到就绪队列中,则将当前的epitem加入到就绪队列中.如果有进程正在等待该文件的状态就绪,则唤醒一个等待的进程。  */</span> </span><br><span class="line">    <span class="keyword">if</span> ((revents &amp; event-&gt;events) &amp;&amp; !ep_is_linked(&amp;epi-&gt;rdllink)) &#123;</span><br><span class="line">    <span class="comment">/*将当前epi插入到ep-&gt;ready队列中。*/</span></span><br><span class="line">        list_add_tail(&amp;epi-&gt;rdllink, &amp;ep-&gt;rdllist);</span><br><span class="line"></span><br><span class="line">        <span class="comment">/* Notify waiting tasks that events are available */</span></span><br><span class="line">    <span class="comment">/* 如果有进程正在等待文件的状态就绪，也就是调用epoll_wait睡眠的进程正在等待，则唤醒一个等待进程。waitqueue_active(q) 等待队列q中有等待的进程返回1，否则返回0。*/</span></span><br><span class="line">        <span class="keyword">if</span> (waitqueue_active(&amp;ep-&gt;wq))</span><br><span class="line">            wake_up_locked(&amp;ep-&gt;wq);</span><br><span class="line">    <span class="comment">/*  如果有进程等待eventpoll文件本身（???）的事件就绪，则增加临时变量pwake的值，pwake的值不为0时，在释放lock后，会唤醒等待进程。 */</span> </span><br><span class="line">        <span class="keyword">if</span> (waitqueue_active(&amp;ep-&gt;poll_wait))</span><br><span class="line">            pwake++;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    spin_unlock_irqrestore(&amp;ep-&gt;lock, flags);</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* We have to call this outside the lock */</span></span><br><span class="line">    <span class="keyword">if</span> (pwake)</span><br><span class="line">  <span class="comment">/*唤醒等待eventpoll文件状态就绪的进程*/</span></span><br><span class="line">        ep_poll_safewake(&amp;psw, &amp;ep-&gt;poll_wait);</span><br><span class="line"></span><br><span class="line">    DNPRINTK(<span class="number">3</span>, (KERN_INFO <span class="string">&quot;[%p] eventpoll: ep_insert(%p, %p, %d)\n&quot;</span>,</span><br><span class="line">             current, ep, tfile, fd));</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>init_poll_funcptr(&amp;epq.pt, ep_ptable_queue_proc);和revents &#x3D; tfile-&gt;f_op-&gt;poll(tfile, &amp;epq.pt);这两个函数将ep_ptable_queue_proc注册到epq.pt中的qproc。</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">poll_table_struct</span> &#123;</span></span><br><span class="line"></span><br><span class="line">poll_queue_proc qproc;</span><br><span class="line"></span><br><span class="line"><span class="type">unsigned</span> <span class="type">long</span> key;</span><br><span class="line"></span><br><span class="line">&#125;poll_table;</span><br></pre></td></tr></table></figure>

<p>执行f_op-&gt;poll(tfile, &amp;epq.pt)时，XXX_poll(tfile, &amp;epq.pt)函数会执行poll_wait()，poll_wait()会调用epq.pt.qproc函数，即ep_ptable_queue_proc。</p>
<p>ep_ptable_queue_proc函数如下：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">/*当poll醒来时就回调用该函数,在文件操作中的poll函数中调用，将epoll的回调函数加入到目标文件的唤醒队列中。如果监视的文件是套接字，参数whead则是sock结构的sk_sleep成员的地址*/</span></span><br><span class="line"><span class="type">static</span> <span class="type">void</span> <span class="title function_">ep_ptable_queue_proc</span><span class="params">(<span class="keyword">struct</span> file *file, <span class="type">wait_queue_head_t</span> *whead,</span></span><br><span class="line"><span class="params">                 poll_table *pt)</span></span><br><span class="line">&#123;</span><br><span class="line">  <span class="comment">/*pt获取struct ep_queue的epi字段。*/</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">epitem</span> *<span class="title">epi</span> =</span> ep_item_from_epqueue(pt);</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">eppoll_entry</span> *<span class="title">pwq</span>;</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (epi-&gt;nwait &gt;= <span class="number">0</span> &amp;&amp; (pwq = kmem_cache_alloc(pwq_cache, GFP_KERNEL))) &#123;</span><br><span class="line">        init_waitqueue_func_entry(&amp;pwq-&gt;wait, ep_poll_callback);</span><br><span class="line">        pwq-&gt;whead = whead;</span><br><span class="line">        pwq-&gt;base = epi;</span><br><span class="line">        add_wait_queue(whead, &amp;pwq-&gt;wait);</span><br><span class="line">        list_add_tail(&amp;pwq-&gt;llink, &amp;epi-&gt;pwqlist);</span><br><span class="line">        epi-&gt;nwait++;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="comment">/* We have to signal that an error occurred */</span></span><br><span class="line">    <span class="comment">/*如果分配内存失败，则将nwait置为-1，表示发生错误，即内存分配失败，或者已发生错误*/</span></span><br><span class="line">        epi-&gt;nwait = <span class="number">-1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>其中struct eppoll_entry定义如下：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">eppoll_entry</span> &#123;</span></span><br><span class="line"></span><br><span class="line">   <span class="class"><span class="keyword">struct</span> <span class="title">list_head</span> <span class="title">llink</span>;</span></span><br><span class="line"></span><br><span class="line">   <span class="class"><span class="keyword">struct</span> <span class="title">epitem</span> *<span class="title">base</span>;</span></span><br><span class="line"></span><br><span class="line">   <span class="type">wait_queue_t</span> wait;</span><br><span class="line"></span><br><span class="line">   <span class="type">wait_queue_head_t</span> *whead;</span><br><span class="line"></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>ep_ptable_queue_proc 函数完成 epitem 加入到特定文件的wait队列任务。<br><br>ep_ptable_queue_proc有三个参数：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">file</span> *<span class="title">file</span>;</span>              该fd对应的文件对象</span><br><span class="line"></span><br><span class="line"><span class="type">wait_queue_head_t</span> *whead;      该fd对应的设备等待队列（同select中的mydev-&gt;wait_address）</span><br><span class="line"></span><br><span class="line">poll_table *pt;                 f_op-&gt;poll(tfile, &amp;epq.pt)中的epq.pt</span><br></pre></td></tr></table></figure>

<p>在ep_ptable_queue_proc函数中，引入了另外一个非常重要的数据结构eppoll_entry。eppoll_entry主要完成epitem和epitem事件发生时的callback（ep_poll_callback）函数之间的关联。首先将eppoll_entry的whead指向fd的设备等待队列（同select中的wait_address），然后初始化eppoll_entry的base变量指向epitem，最后通过add_wait_queue将epoll_entry挂载到fd的设备等待队列上。完成这个动作后，epoll_entry已经被挂载到fd的设备等待队列。</p>
<p>由于ep_ptable_queue_proc函数设置了等待队列的ep_poll_callback回调函数。所以在设备硬件数据到来时，硬件中断处理函数中会唤醒该等待队列上等待的进程时，会调用唤醒函数ep_poll_callback</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">static</span> <span class="type">int</span> <span class="title function_">ep_poll_callback</span><span class="params">(<span class="type">wait_queue_t</span> *wait, <span class="type">unsigned</span> mode, <span class="type">int</span> sync, <span class="type">void</span> *key)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">int</span> pwake = <span class="number">0</span>;</span><br><span class="line">    <span class="type">unsigned</span> <span class="type">long</span> flags;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">epitem</span> *<span class="title">epi</span> =</span> ep_item_from_wait(wait);</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">eventpoll</span> *<span class="title">ep</span> =</span> epi-&gt;ep;</span><br><span class="line"></span><br><span class="line">    spin_lock_irqsave(&amp;ep-&gt;lock, flags);</span><br><span class="line"></span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">     * If the event mask does not contain any poll(2) event, we consider the</span></span><br><span class="line"><span class="comment">     * descriptor to be disabled. This condition is likely the effect of the</span></span><br><span class="line"><span class="comment">     * EPOLLONESHOT bit that disables the descriptor when an event is received,</span></span><br><span class="line"><span class="comment">     * until the next EPOLL_CTL_MOD will be issued.</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">if</span> (!(epi-&gt;event.events &amp; ~EP_PRIVATE_BITS))</span><br><span class="line">        <span class="keyword">goto</span> out_unlock;</span><br><span class="line"></span><br><span class="line">  ...</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* If this file is already in the ready list we exit soon */</span></span><br><span class="line">    <span class="keyword">if</span> (ep_is_linked(&amp;epi-&gt;rdllink))</span><br><span class="line">        <span class="keyword">goto</span> is_linked;</span><br><span class="line">  <span class="comment">/*将该fd加入到epoll监听的就绪链表中*/</span></span><br><span class="line">    list_add_tail(&amp;epi-&gt;rdllink, &amp;ep-&gt;rdllist);</span><br><span class="line"></span><br><span class="line">is_linked:</span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">     * Wake up ( if active ) both the eventpoll wait list and the -&gt;poll()</span></span><br><span class="line"><span class="comment">     * wait list.</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">   <span class="comment">/*唤醒调用epoll_wait()函数时睡眠的进程。用户层epoll_wait(...) 超时前返回。*/</span></span><br><span class="line">    <span class="keyword">if</span> (waitqueue_active(&amp;ep-&gt;wq))</span><br><span class="line">        wake_up_locked(&amp;ep-&gt;wq);</span><br><span class="line">    <span class="keyword">if</span> (waitqueue_active(&amp;ep-&gt;poll_wait))</span><br><span class="line">        pwake++;</span><br><span class="line"></span><br><span class="line">out_unlock:</span><br><span class="line">    spin_unlock_irqrestore(&amp;ep-&gt;lock, flags);</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* We have to call this outside the lock */</span></span><br><span class="line">    <span class="keyword">if</span> (pwake)</span><br><span class="line">        ep_poll_safewake(&amp;psw, &amp;ep-&gt;poll_wait);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">&#125; </span><br></pre></td></tr></table></figure>

<h3 id="epoll-wait"><a href="#epoll-wait" class="headerlink" title="epoll_wait"></a>epoll_wait</h3><p>epoll_wait实现如下：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">asmlinkage <span class="type">long</span> <span class="title function_">sys_epoll_wait</span><span class="params">(<span class="type">int</span> epfd, <span class="keyword">struct</span> epoll_event __user *events,</span></span><br><span class="line"><span class="params">                   <span class="type">int</span> maxevents, <span class="type">int</span> timeout)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">int</span> error;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">file</span> *<span class="title">file</span>;</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">eventpoll</span> *<span class="title">ep</span>;</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="comment">/* The maximum number of event must be greater than zero */</span></span><br><span class="line">    <span class="keyword">if</span> (maxevents &lt;= <span class="number">0</span> || maxevents &gt; EP_MAX_EVENTS)</span><br><span class="line">        <span class="keyword">return</span> -EINVAL;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* Verify that the area passed by the user is writeable */</span></span><br><span class="line">  <span class="comment">/* 检查用户空间传入的events指向的内存是否可写。参见__range_not_ok()。*/</span></span><br><span class="line">    <span class="keyword">if</span> (!access_ok(VERIFY_WRITE, events, maxevents * <span class="keyword">sizeof</span>(<span class="keyword">struct</span> epoll_event))) &#123;</span><br><span class="line">        error = -EFAULT;</span><br><span class="line">        <span class="keyword">goto</span> error_return;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* Get the &quot;struct file *&quot; for the eventpoll file */</span></span><br><span class="line">  <span class="comment">/* 获取epfd对应的eventpoll文件的file实例，file结构是在epoll_create中创建。 */</span></span><br><span class="line">    error = -EBADF;</span><br><span class="line">    file = fget(epfd);</span><br><span class="line">    <span class="keyword">if</span> (!file)</span><br><span class="line">        <span class="keyword">goto</span> error_return;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">     * We have to check that the file structure underneath the fd</span></span><br><span class="line"><span class="comment">     * the user passed to us _is_ an eventpoll file.</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="comment">/* 通过检查epfd对应的文件操作是不是eventpoll_fops 来判断epfd是否是一个eventpoll文件。如果不是则返回EINVAL错误。 */</span></span><br><span class="line">    error = -EINVAL;</span><br><span class="line">    <span class="keyword">if</span> (!is_file_epoll(file))</span><br><span class="line">        <span class="keyword">goto</span> error_fput;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">     * At this point it is safe to assume that the &quot;private_data&quot; contains</span></span><br><span class="line"><span class="comment">     * our own data structure.</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    ep = file-&gt;private_data;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* Time to fish for events ... */</span></span><br><span class="line">    error = ep_poll(ep, events, maxevents, timeout);</span><br><span class="line"></span><br><span class="line">error_fput:</span><br><span class="line">    fput(file);</span><br><span class="line">error_return:</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> error;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="ep-poll"><a href="#ep-poll" class="headerlink" title="ep_poll"></a>ep_poll</h3><p>epoll_wait调用ep_poll，ep_poll实现如下：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">static</span> <span class="type">int</span> <span class="title function_">ep_poll</span><span class="params">(<span class="keyword">struct</span> eventpoll *ep, <span class="keyword">struct</span> epoll_event __user *events,</span></span><br><span class="line"><span class="params">           <span class="type">int</span> maxevents, <span class="type">long</span> timeout)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">int</span> res, eavail;</span><br><span class="line">    <span class="type">unsigned</span> <span class="type">long</span> flags;</span><br><span class="line">    <span class="type">long</span> jtimeout;</span><br><span class="line">    <span class="type">wait_queue_t</span> wait;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">     * Calculate the timeout by checking for the &quot;infinite&quot; value ( -1 )</span></span><br><span class="line"><span class="comment">     * and the overflow condition. The passed timeout is in milliseconds,</span></span><br><span class="line"><span class="comment">     * that why (t * HZ) / 1000.</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">   <span class="comment">/* timeout是以毫秒为单位，这里是要转换为jiffies时间。这里加上999(即1000-1)，是为了向上取整。 */</span></span><br><span class="line">    jtimeout = (timeout &lt; <span class="number">0</span> || timeout &gt;= EP_MAX_MSTIMEO) ?</span><br><span class="line">        MAX_SCHEDULE_TIMEOUT : (timeout * HZ + <span class="number">999</span>) / <span class="number">1000</span>;</span><br><span class="line"></span><br><span class="line">retry:</span><br><span class="line">    spin_lock_irqsave(&amp;ep-&gt;lock, flags);</span><br><span class="line"></span><br><span class="line">    res = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">if</span> (list_empty(&amp;ep-&gt;rdllist)) &#123;</span><br><span class="line">        <span class="comment">/*</span></span><br><span class="line"><span class="comment">         * We don&#x27;t have any available event to return to the caller.</span></span><br><span class="line"><span class="comment">         * We need to sleep here, and we will be wake up by</span></span><br><span class="line"><span class="comment">         * ep_poll_callback() when events will become available.</span></span><br><span class="line"><span class="comment">         */</span></span><br><span class="line">   <span class="comment">/* 没有事件，所以需要睡眠。当有事件到来时，睡眠会被ep_poll_callback函数唤醒。*/</span></span><br><span class="line">        init_waitqueue_entry(&amp;wait, current); <span class="comment">/*将current进程放在wait这个等待队列中。*/</span></span><br><span class="line">        wait.flags |= WQ_FLAG_EXCLUSIVE;</span><br><span class="line">   <span class="comment">/* 将当前进程加入到eventpoll的等待队列中，等待文件状态就绪或直到超时，或被信号中断。 */</span></span><br><span class="line">        __add_wait_queue(&amp;ep-&gt;wq, &amp;wait);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (;;) &#123;</span><br><span class="line">            <span class="comment">/*</span></span><br><span class="line"><span class="comment">             * We don&#x27;t want to sleep if the ep_poll_callback() sends us</span></span><br><span class="line"><span class="comment">             * a wakeup in between. That&#x27;s why we set the task state</span></span><br><span class="line"><span class="comment">             * to TASK_INTERRUPTIBLE before doing the checks.</span></span><br><span class="line"><span class="comment">             */</span></span><br><span class="line">       <span class="comment">/* 执行ep_poll_callback()唤醒时应当需要将当前进程唤醒，所以当前进程状态应该为“可唤醒”TASK_INTERRUPTIBLE  */</span></span><br><span class="line">            set_current_state(TASK_INTERRUPTIBLE);</span><br><span class="line">       <span class="comment">/* 如果就绪队列不为空，也就是说已经有文件的状态就绪或者超时，则退出循环。*/</span></span><br><span class="line">            <span class="keyword">if</span> (!list_empty(&amp;ep-&gt;rdllist) || !jtimeout)</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">       <span class="comment">/* 如果当前进程接收到信号，则退出循环，返回EINTR错误 */</span></span><br><span class="line">            <span class="keyword">if</span> (signal_pending(current)) &#123;</span><br><span class="line">                res = -EINTR;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            spin_unlock_irqrestore(&amp;ep-&gt;lock, flags);</span><br><span class="line">       <span class="comment">/*</span></span><br><span class="line"><span class="comment">        * 主动让出处理器，等待ep_poll_callback()将当前进程唤醒或者超时,返回值是剩余的时间。</span></span><br><span class="line"><span class="comment">        * 从这里开始当前进程会进入睡眠状态，直到某些文件的状态就绪或者超时。</span></span><br><span class="line"><span class="comment">        * 当文件状态就绪时，eventpoll的回调函数ep_poll_callback()会唤醒在ep-&gt;wq指向的等待队列中的进程。</span></span><br><span class="line"><span class="comment">       */</span></span><br><span class="line">            jtimeout = schedule_timeout(jtimeout);</span><br><span class="line">            spin_lock_irqsave(&amp;ep-&gt;lock, flags);</span><br><span class="line">        &#125;</span><br><span class="line">        __remove_wait_queue(&amp;ep-&gt;wq, &amp;wait);</span><br><span class="line"></span><br><span class="line">        set_current_state(TASK_RUNNING);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* Is it worth to try to dig for events ? */</span></span><br><span class="line">  <span class="comment">/*</span></span><br><span class="line"><span class="comment">    * ep-&gt;ovflist链表存储的向用户传递事件时暂存就绪的文件。</span></span><br><span class="line"><span class="comment">    * 所以不管是就绪队列ep-&gt;rdllist不为空，或者ep-&gt;ovflist不等于</span></span><br><span class="line"><span class="comment">    * EP_UNACTIVE_PTR，都有可能现在已经有文件的状态就绪。</span></span><br><span class="line"><span class="comment">    * ep-&gt;ovflist不等于EP_UNACTIVE_PTR有两种情况，一种是NULL，此时</span></span><br><span class="line"><span class="comment">    * 可能正在向用户传递事件，不一定就有文件状态就绪，</span></span><br><span class="line"><span class="comment">    * 一种情况时不为NULL，此时可以肯定有文件状态就绪，</span></span><br><span class="line"><span class="comment">    * 参见ep_send_events()。</span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line">    eavail = !list_empty(&amp;ep-&gt;rdllist);</span><br><span class="line"></span><br><span class="line">    spin_unlock_irqrestore(&amp;ep-&gt;lock, flags);</span><br><span class="line"></span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">     * Try to transfer events to user space. In case we get 0 events and</span></span><br><span class="line"><span class="comment">     * there&#x27;s still timeout left over, we go trying again in search of</span></span><br><span class="line"><span class="comment">     * more luck.</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">   <span class="comment">/* 如果没有被信号中断，并且有事件就绪，但是没有获取到事件(有可能被其他进程获取到了)，并且没有超时，则跳转到retry标签处，重新等待文件状态就绪。 */</span></span><br><span class="line">    <span class="keyword">if</span> (!res &amp;&amp; eavail &amp;&amp;</span><br><span class="line">        !(res = ep_send_events(ep, events, maxevents)) &amp;&amp; jtimeout)</span><br><span class="line">        <span class="keyword">goto</span> retry;</span><br><span class="line">  </span><br><span class="line">  <span class="comment">/* 返回获取到的事件的个数或者错误码 */</span></span><br><span class="line">    <span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>ep_send_events()函数向用户空间发送就绪事件。</p>
<p>ep_send_events()函数将用户传入的内存简单封装到ep_send_events_data结构中，然后调用ep_scan_ready_list()将就绪队列中的事件传入用户空间的内存。 用户空间访问这个结果，进行处理。</p>
<p><img src="https://user-images.githubusercontent.com/87457873/127447425-3e1c4037-b5b3-49fa-b483-bda69bd33f7d.png" alt="image"></p>
]]></content>
      <categories>
        <category>linux-doc 网络协议栈</category>
      </categories>
      <tags>
        <tag>Linux</tag>
      </tags>
  </entry>
  <entry>
    <title>驾驭Linux内部网络实现——关键数据结构 sk_buff</title>
    <url>/2023/01/15/linux-docs/%E7%BD%91%E7%BB%9C%E5%8D%8F%E8%AE%AE%E6%A0%88/%E9%A9%BE%E9%A9%ADLinux%E5%86%85%E9%83%A8%E7%BD%91%E7%BB%9C%E5%AE%9E%E7%8E%B0%E2%80%94%E2%80%94%E5%85%B3%E9%94%AE%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%20sk_buff/</url>
    <content><![CDATA[<h2 id="背景"><a href="#背景" class="headerlink" title="背景"></a>背景</h2><p>在 Linux 的网络栈实现代码中，引用到了一些数据结构。要理解 Linux 内部的网络实现，需要先理清这些数据结构的作用。关键数据结构主要有两个: sk_buff 和 net_device。</p>
<p>struct sk_buff: 是整个网络数据包存储的地方。这个数据结构会被网络协议栈中的各层用来储存它们的协议头、用户数据和其他它们完成工作需要的数据。</p>
<p>struct net_device: 在 Linux 内核中，这个数据结构将用来代表网络设备。它会包含设备的硬件和软件配置信息。</p>
<p>在 Linux 的网络实现中，核心数据结构还有struct sock, 它被用来储存 socket 的信息。但是 Socket 其实是内核为用户态程序提供的一组 Api, 用来访问内核的网络栈实现，所以它不属于内核内部的网络实现，也就不再这里介绍了。</p>
<p>本文将先着重理解 sk_buff 数据结构。</p>
<h2 id="Socket-Buffer-sk-buff"><a href="#Socket-Buffer-sk-buff" class="headerlink" title="Socket Buffer: sk_buff"></a>Socket Buffer: sk_buff</h2><blockquote>
<p>sk_buff: 在本文中后面部分也会被称为缓冲区</p>
</blockquote>
<p>在 Linux 内核的网络代码中，这或许是最重要的数据结构，用来表示已接收或将要传输的数据。定义在 &lt;include&#x2F;linux&#x2F;skbuff.h&gt; 中，它由许多变量组成，目标就是满足所有网络协议的需要。</p>
<p>sk_buff 的结构随着内核的迭代已经被添加了许多新的选项，已经存在的字段也被重新整理了很多遍。可将内部的字段分为以下几类：</p>
<ul>
<li>Layout 负责内存布局的字段</li>
<li>General 通用的字段</li>
<li>Feature-specific 对应特别功能字段</li>
<li>Management functions 一些用来管理 sk_buff 的函数</li>
</ul>
<p>sk_buff 在不同的网络层被使用（MAC 或其他在 L2 的协议，在 L3 的 IP 协议，在 L4 的 TCP 或 UDP 等），当它从一层传递到另一层时，各个字段也会发生变化。在被传递到 L3 之前，L4 会追加头信息，然后在被传递到 L2 之前，L3 会追加头信息。从一层传递到另一层时，通过追加头信息的方式比将数据在层之间拷贝会更有效率。由于要在 buff 的开头增加空间（与平时常见的在尾部追加空间相比）是一项复杂的操作，内核便提供了 skb_reserve 函数执行这个操作。因此，随着 buffer 从上层到下层的传递，每层协议做的第一件事就是调用 skb_reserve 去为它们的协议头在 buffer 的头部分配空间。在后面，我们将通过一个例子去了解内核如何在当 buffer 在各个层间传递时，确保为每一层保留了足够的空间让它们添加它们自己的协议头。</p>
<p>在接收数据时，buffer 会被从下层到上层传递，在从下到上的过程中，前一层的协议头对于当前层来说已经没有用了。比如：L2 的协议头只会被处理 L2 协议的设备驱动程序使用，L3 并不关心 L2 的头。那么内核怎么做的呢? 内核的实现是：** sk_buff 中有一个指针会指向当前位于的层次的协议的协议头的内存开始地址，于是从 L2 到 L3 时，只需将指向 L2 头部的指针移动到 L3 的头部即可**（又是一步追求效率的操作）。</p>
<h2 id="网络选项和内核结构"><a href="#网络选项和内核结构" class="headerlink" title="网络选项和内核结构"></a>网络选项和内核结构</h2><p>内核的网络代码提供了大量有用但不是必须的选项，例如防火墙，多播等功能。这些选项都需要内核数据结构中的其他字段。因此，sk_buff 使用 C 语言的预处理命令 #ifdef 来做条件编译。例如在 sk_buff 定义的后面部分:</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">sk_buff</span> &#123;</span></span><br><span class="line"><span class="comment">//......</span></span><br><span class="line">    <span class="meta">#<span class="keyword">ifdef</span> CONFIG_NET_SCHED </span></span><br><span class="line">        __u32 tc_index;</span><br><span class="line">    <span class="meta">#<span class="keyword">ifdef</span> CONFIG_NET_CLS_ACT </span></span><br><span class="line">        __u32 tc_verd;</span><br><span class="line">        __u32 tc_classid;</span><br><span class="line">    <span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line">    <span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>通过在编译 Linux 时配置不同的编译选项，能够让编译出来的内核支持不同的功能。</p>
<h2 id="Layout-Fields"><a href="#Layout-Fields" class="headerlink" title="Layout Fields"></a>Layout Fields</h2><p>在 sk_buff 中存在一些字段，它们存在的意义只是为了搜索的方便和数据结构的组织。这类字段称为 Layout Fileds。Linux 内核把系统中所有的 sk_buff 实例维护在一个双向链表中。但是组织这个链表比传统的双向链表要复杂一点。</p>
<p>和任何双向链表类似，sk_buff 链表的每个节点也通过 next 和 prev 分别指向后继和前驱节点。但是 sk_buff 链表还要求：每个节点必须能够很快的找到整个链表的头节点。为了实现这个要求，一个额外的数据结构(sk_buff_head)被添加到链表的头部，作为一个空节点：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">sk_buff_head</span> &#123;</span></span><br><span class="line">	<span class="comment">/* These two members must be first. */</span></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">sk_buff</span>	*<span class="title">next</span>;</span></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">sk_buff</span>	*<span class="title">prev</span>;</span></span><br><span class="line"></span><br><span class="line">	__u32		qlen;</span><br><span class="line">	<span class="type">spinlock_t</span>	lock;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<ul>
<li>qlen: 表示链表中的节点数</li>
<li>lock: 用作多线程同步</li>
</ul>
<p>sk_buff 和 sk_buff_head 开始的两个节点(next prev)是相同的。即使 sk_buff_head 比 sk_buff 更轻量化，也允许这两种结构在链表中共存。另外，可以使用相同函数来操作 sk_buff 和 sk_buff_head。</p>
<p>为了实现通过每个节点都能快速找到链表头，每个节点都会包含一个指向链表中唯一的 sk_buff_head 的指针（list）。</p>
<p><img src="https://user-images.githubusercontent.com/87457873/127461275-2d349c99-38c1-44b6-a381-6a487add8c0f.png" alt="image"></p>
<h2 id="sk-buff-其他字段"><a href="#sk-buff-其他字段" class="headerlink" title="sk_buff 其他字段"></a>sk_buff 其他字段</h2><h3 id="struct-sock-sk"><a href="#struct-sock-sk" class="headerlink" title="struct sock sk"></a>struct sock sk</h3><p>一个指向 sock 数据结构的指针，表示 sock 对应 socket 拥有这个 sk_buff。当数据是由本地进程生成或接收时需要这个指针，因为数据和 socket相关的信息会被 L4（TCP或UDP）和用户态的程序使用。当一个 sk_buff 仅仅是被转发时（也就是说，源和目标地址不在本地计算机上），这个指针是不需要的，因此将会是 NULL。</p>
<h3 id="unsigned-int-len"><a href="#unsigned-int-len" class="headerlink" title="unsigned int len"></a>unsigned int len</h3><p>表示在 buffer 中数据区域的大小。该长度既包括主缓冲区的数据长度，也包括片段中的数据。因为协议头在向上传递中会被丢弃，在向下传递中会被添加，所以它的值会随着 buffer 在各层间传递而改变。</p>
<h3 id="unsiged-int-data-len"><a href="#unsiged-int-data-len" class="headerlink" title="unsiged int data_len"></a>unsiged int data_len</h3><p>和 len 不同的是，data_len 只记录分段中的数据大小。</p>
<h3 id="unsigned-int-mac-len"><a href="#unsigned-int-mac-len" class="headerlink" title="unsigned int mac_len"></a>unsigned int mac_len</h3><p>MAC 头部的长度</p>
<h3 id="atomic-t-users"><a href="#atomic-t-users" class="headerlink" title="atomic_t users"></a>atomic_t users</h3><p>sk_buff 的引用计数，或引用了此 sk_buff 缓冲区的对象数。 主要用途是避免在有人还在使用时就释放了 sk_buff。users的值可以通过 atomic_inc 和 atomic_dec直接增加和减少，但更多的时候是通过<code>skb_get和kfree_skb</code> 函数进行。</p>
<h3 id="unsigned-int-truesize"><a href="#unsigned-int-truesize" class="headerlink" title="unsigned int truesize"></a>unsigned int truesize</h3><p>这个字段表示 buffer 的总大小，包括了 sk_buff 自己的占用。在执行 alloc_skb 函数时该字段被初始化。</p>
<pre><code>#define SKB_TRUESIZE(X) ((X) +						\
   SKB_DATA_ALIGN(sizeof(struct sk_buff)) +	\
   SKB_DATA_ALIGN(sizeof(struct skb_shared_info)))
</code></pre>
<ul>
<li>unsigned char head</li>
<li>unsigned char end</li>
<li>unsigned char data</li>
<li>unsigned char tail</li>
</ul>
<p>上面4个指针用来表示 buffer 中数据域的边界。当每一层为了任务而准备 buffer 时，为了协议头或数据，可能会分配更多的空间。 head 和 end 指向了 buffer 被分配的内存区域的开始和结束， data 和 tail 指向其中实际数据域的开始和结束。</p>
<p><img src="https://user-images.githubusercontent.com/87457873/127461623-6ab77e77-099c-4a58-b2ca-bafadafe8116.png" alt="image"></p>
<p>每一层能够在 head 和 data 之间的区域填充协议头，或者在 tail 和 end 之间的区域填充新的数据。</p>
<h3 id="void-destructor-…"><a href="#void-destructor-…" class="headerlink" title="void (destructor)(…)"></a>void (destructor)(…)</h3><p>这个函数指针能够在运行时被赋值，从而在一个 buffer 被移除时，执行一些操作。当一个 buffer 不属于一个 socket 时，这个函数指针通常为空。当一个 buffer 属于一个 socket 时，这个函数指针通常被设置为 sock_rfree 或 sock_wfree。两个 sock_xxx 函数用于更新 socket 在它的队列中持有的大量内存。</p>
<h3 id="General-Fields"><a href="#General-Fields" class="headerlink" title="General Fields"></a>General Fields</h3><p>在 sk_buff 中存在一些通用目的的字段，这些字段没有与特定的内核功能绑定：</p>
<h3 id="struct-timeval-stamp"><a href="#struct-timeval-stamp" class="headerlink" title="struct timeval stamp"></a>struct timeval stamp</h3><p>这个字段通常仅对接收到的数据包有意义。这是一个时间戳，表示何时接收到一个数据包，或者何时计划发送一个数据包。它由接收 net_timestamp 参数的函数 netif_rx 设置，在接收每个数据包后由设备驱动程序调用。</p>
<h3 id="struct-net-device-dev"><a href="#struct-net-device-dev" class="headerlink" title="struct net_device dev"></a>struct net_device dev</h3><p>该字段描述了网络设备。 dev代表的设备的作用取决于缓冲区中存储的数据包是要发送还是刚刚被接收。<br><br>当收到数据包后，设备驱动程序会使用指向接收数据接口的指针来更新此字段。<br><br>当要发送数据包时，此参数表示将通过其发送出去的设备。<br></p>
<h3 id="struct-net-device-input-dev"><a href="#struct-net-device-input-dev" class="headerlink" title="struct net_device input_dev"></a>struct net_device input_dev</h3><p>表示数据包到来的设备。当数据包是在本地生成的，其值是 NULL。</p>
<h3 id="struct-net-device-real-dev"><a href="#struct-net-device-real-dev" class="headerlink" title="struct net_device real_dev"></a>struct net_device real_dev</h3><p>该字段仅对虚拟设备有意义，代表与虚拟设备关联的实际设备。 例如，Bonding（将两个或多个网络接口组合或合并为一个接口） 和 VLAN(virtual local area network) 接口使用它来记住从何处接收到真实设备入口流量。</p>
<pre><code>union &#123;…&#125; h
union &#123;…&#125; nh
union &#123;…&#125; mac
</code></pre>
<p>上面的3个指针表示了 TCP&#x2F;IP 协议栈中的协议头: h 代表 L4, nh 代表 L3, mac 代表 L2。每个字段都指向的是各种共用体结构，某个结构只能被内核中对应的层的协议理解。比如：h 共用体就包含了L4上的每个协议能理解的头信息。每个共用体的一个成员称为raw，用于初始化。 所有以后的访问都通过协议特定的成员进行。</p>
<p>当接收到数据包时，负责处理第 n 层协议头的函数从第 n-1 层接收一个 buffer，其中skb-&gt;data 指向第 n 层协议头的开头。处理第n层的函数会为此层初始化适当的指针（例如，L3 的处理函数会为 skb-&gt;nh 赋值）以保留 skb-&gt;data 字段，因为当 skb-&gt;data 被赋值为 buffer 内的其他偏移量时，该指针的内容将在下一层的处理过程中丢失。然后，该函数完成第 n 层的处理，并在将数据包传递到第 n+1 层处理程序之前，更新 skb-&gt;data 使其指向第 n 层协议头的末尾（即第n+1 层协议头的开始位置）。</p>
<p><img src="https://user-images.githubusercontent.com/87457873/127462034-7946a510-ed17-44ce-93b7-b9a23e142f68.png" alt="image"></p>
<h3 id="struct-dst-entry-dst"><a href="#struct-dst-entry-dst" class="headerlink" title="struct dst_entry dst"></a>struct dst_entry dst</h3><p>由路由子系统使用。 因为数据结构非常复杂，并且需要了解其他子系统的工作原理，所以留在以后在详解。</p>
<h3 id="char-cb-40"><a href="#char-cb-40" class="headerlink" title="char cb[40]"></a>char cb[40]</h3><p>control buffer 的简称，或存储一些私有信息，由各层维护以供内部使用。它是在 sk_buff 结构中静态分配的（当前大小为40个字节），并且足够大以容纳每一层所需的任何私有数据。在每一层的代码中，访问都是通过宏进行的，以使代码更具可读性。例如，TCP使用该空间存储 tcp_skb_cb 数据结构，该数据结构在 include&#x2F;net&#x2F;tcp.h 中定义：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">tcp_skb_cb</span> &#123;</span></span><br><span class="line">    <span class="comment">//...</span></span><br><span class="line">	__u32		seq;		<span class="comment">/* Starting sequence number	*/</span></span><br><span class="line">	__u32		end_seq;	<span class="comment">/* SEQ + FIN + SYN + datalen	*/</span></span><br><span class="line">	__u8		tcp_flags;	<span class="comment">/* TCP header flags. (tcp[13])	*/</span></span><br><span class="line">	__u32		ack_seq;	<span class="comment">/* Sequence number ACK&#x27;d	*/</span></span><br><span class="line">    <span class="comment">//...</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>这是 TCP 代码访问结构的宏。宏仅由一个指针转换组成：</p>
<pre><code>#define TCP_SKB_CB(__skb)	((struct tcp_skb_cb *)&amp;((__skb)-&gt;cb[0]))
</code></pre>
<p>这是一个示例，其中 TCP 模块在收到分段后填写 cb 结构：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">static</span> <span class="type">void</span> <span class="title function_">tcp_v4_fill_cb</span><span class="params">(<span class="keyword">struct</span> sk_buff *skb, <span class="type">const</span> <span class="keyword">struct</span> iphdr *iph, <span class="type">const</span> <span class="keyword">struct</span> tcphdr *th)</span> &#123;</span><br><span class="line">    TCP_SKB_CB(skb)-&gt;seq = ntohl(th-&gt;seq);</span><br><span class="line">    TCP_SKB_CB(skb)-&gt;end_seq = (TCP_SKB_CB(skb)-&gt;seq + th-&gt;syn + th-&gt;fin + skb-&gt;len - th-&gt;doff * <span class="number">4</span>);</span><br><span class="line">    TCP_SKB_CB(skb)-&gt;ack_seq = ntohl(th-&gt;ack_seq);</span><br><span class="line">    TCP_SKB_CB(skb)-&gt;tcp_flags = tcp_flag_byte(th);</span><br><span class="line">    TCP_SKB_CB(skb)-&gt;tcp_tw_isn = <span class="number">0</span>;</span><br><span class="line">    TCP_SKB_CB(skb)-&gt;ip_dsfield = ipv4_get_dsfield(iph);</span><br><span class="line">    TCP_SKB_CB(skb)-&gt;sacked	 = <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="unsigned-int-csum"><a href="#unsigned-int-csum" class="headerlink" title="unsigned int csum"></a>unsigned int csum</h3><h3 id="unsigned-char-ip-summed"><a href="#unsigned-char-ip-summed" class="headerlink" title="unsigned char ip_summed"></a>unsigned char ip_summed</h3><p>上面两个字段代表校验和和状态相关的标志。</p>
<h3 id="unsigned-char-cloned"><a href="#unsigned-char-cloned" class="headerlink" title="unsigned char cloned"></a>unsigned char cloned</h3><p>一个布尔标志，设置后表示此结构是另一个sk_buff缓冲区的克隆。</p>
<h3 id="unsigned-char-pkt-type"><a href="#unsigned-char-pkt-type" class="headerlink" title="unsigned char pkt_type"></a>unsigned char pkt_type</h3><p>该字段根据 L2 目的地址对帧的类型进行分类。可能的值在 include&#x2F;linux&#x2F;if_packet.h 中列出。对于以太网设备，此参数由函数 eth_type_trans 初始化。</p>
<p>主要的一些值：<br></p>
<ul>
<li>PACKET_HOST：接收到的帧的目的地址就是当前接收接口。也就是说，数据包已到达其目的地</li>
<li>PACKET_MULTICAST：接收到的帧的目标地址是当前接收接口已注册过的的多播地址之一</li>
<li>PACKET_BROADCAST：接收帧的目的地址是接收接口的广播地址</li>
<li>PACKET_OTHERHOST：接收帧的目的地址不属于与接口关联的目的地址（单播，组播和广播）；因此，如果启用了转发，则必须转发该帧，否则将其丢弃</li>
<li>PACKET_OUTGOING：表示数据包正在发送</li>
<li>PACKET_LOOPBACK：数据包被发送到回环设备。多亏了此标志，内核在处理回环设备时，可以跳过某些实际设备所需的操作</li>
<li>PACKET_FASTROUTE：数据包正在使用快速路由功能进行路由</li>
</ul>
<h3 id="unsigned-short-protocol"><a href="#unsigned-short-protocol" class="headerlink" title="unsigned short protocol"></a>unsigned short protocol</h3><p>从 L2 处的网卡设备驱动程序的角度来看，这是在更高层次上使用的协议。典型协议有 IP，IPv6和ARP。完整列表可在 include&#x2F;linux&#x2F;if_ether.h 中找到。由于每个协议都有其自己的处理传入数据包的处理函数，因此驱动程序使用此字段来通知其上一层使用什么处理函数。每个驱动程序都调用 netif_rx 来调用上层网络层的处理函数，因此必须在调用该函数之前初始化协议字段。</p>
<h3 id="unsigned-short-security"><a href="#unsigned-short-security" class="headerlink" title="unsigned short security"></a>unsigned short security</h3><p>表示数据包的安全级别。 该字段最初是为与 IPsec 一起使用而引入的。</p>
<h2 id="Feature-Specific-Fields"><a href="#Feature-Specific-Fields" class="headerlink" title="Feature-Specific Fields"></a>Feature-Specific Fields</h2><p>Linux内核是模块化的，允许你选择要包括的内容和要忽略的内容。因此，只有在编译内核时开启支持像 Netfilter 或 QoS 之类的特定功能的情况下，某些字段才会包含在 sk_buff 数据结构中：</p>
<p>unsigned long nfmark<br><br>__u32 nfcache<br><br>__u32 nfctinfo<br><br>struct nf_conntrack *nfct unsigned int nfdebug<br><br>struct nf_bridge_info *nf_bridge<br></p>
<p>这些参数由Netfilter使用。</p>
<p>union {…} private</p>
<p>高性能并行接口HIPPI使用此共用体。</p>
<p>__u32 tc_index<br><br>__u32 tc_verd<br><br>__u32 tc_classid<br></p>
<p>这些参数由流量控制使用。</p>
<h2 id="Management-Functions"><a href="#Management-Functions" class="headerlink" title="Management Functions"></a>Management Functions</h2><p>内核提供了许多很简短的简单函数来操纵 sk_buff 节点或链表。</p>
<p>如果查看文件 include&#x2F;linux&#x2F;skbuff.h 和 net&#x2F;core&#x2F;skbuff.c，你会发现几乎所有功能都有两个版本，名称分别为 do_ something 和 __do_something。通常，第一个是包装函数，它在对第二个调用的调用周围添加了额外的健全性检查或锁定机制。内部 __do_something 函数通常不直接调用。该规则的例外通常是编码不良的函数，这些函数最终将被修复。</p>
<p>下图为分别对 sk_buff 执行 skb_put(a)，skb_push(b)，skb_pull(c)，skb_reserve(d) 的前后对比：</p>
<p><img src="https://user-images.githubusercontent.com/87457873/127462588-5dd5787d-2bc4-4482-99fb-a0a0dc27d0a0.png" alt="image"></p>
<ul>
<li>skb_put：在数据域尾部追加一段空间</li>
<li>skb_push：在数据域的头部追加一段空间</li>
<li>skb_pull：将 skb-&gt;data 指针在数据域下移指定字节</li>
<li>skb_reserve：在 sk_buff 中 skb-&gt;data 之前的空间追加一段空间（在每层追加自己的协议头时常用到）</li>
</ul>
<h2 id="内存分配"><a href="#内存分配" class="headerlink" title="内存分配"></a>内存分配</h2><ul>
<li>alloc_skb</li>
<li>dev_alloc_skb</li>
</ul>
<p>alloc_skb 是分配缓冲区的主要函数，在 net&#x2F;core&#x2F;skbuff.c 中定义。由于数据缓冲区（由 sk_buff 的 head end data tail 指针维护的内存区域）和链表（sk_buff 自身）是两个不同的结构，所以创建单个缓冲区涉及两个内存分配（一个分配给数据缓冲区，另一个分配给 sk_buff 自身结构）。</p>
<p>alloc_skb 通过调用函数 kmem_cache_alloc 从缓存中获取 sk_buff 数据结构，并通过调用 kmalloc 获取数据缓冲区，而 kmalloc 也会使用缓存的内存（如果可用）：</p>
<pre><code>struct sk_buff *skb;
u8 *data

skb = kmem_cache_alloc_node(cache, gfp_mask &amp; ~__GFP_DMA, node);
size = SKB_DATA_ALIGN(size);
size += SKB_DATA_ALIGN(sizeof(struct skb_shared_info));
data = kmalloc_reserve(size, gfp_mask, node, &amp;pfmemalloc);
</code></pre>
<p>在调用 kmalloc 之前，使用宏 SKB_DATA_ALIGN 调整了大小参数以强制对齐。返回之前，该函数将初始化结构体中的一些参数，从而产生下图所示的最终结果：</p>
<p><img src="https://user-images.githubusercontent.com/87457873/127462806-b8830459-e68c-4b61-bd96-66427bdbbda2.png" alt="image"></p>
<p>在图右侧存储块的底部，可以看到为了强制对齐而引入的 Padding 区域。 skb_shared_info 块主要用于处理 IP 的分片（IP协议根据 MTU 和 MSS 对数据包进行的分片传输）。</p>
<h3 id="dev-alloc-skb"><a href="#dev-alloc-skb" class="headerlink" title="dev_alloc_skb"></a>dev_alloc_skb</h3><p>dev_alloc_skb 是供设备驱动程序使用的缓冲区分配函数。这类驱动程序预计将在中断模式下被执行。它就是简单的包装了下 alloc_skb, 相比 alloc_skb 多分配了一些字节的空间，并请求了原子操作（GFP_ATOMIC），因为设备驱动程序将在中断处理程序中调用。</p>
<h2 id="内存释放"><a href="#内存释放" class="headerlink" title="内存释放"></a>内存释放</h2><ul>
<li>kfree_skb</li>
<li>dev_kfree_skb</li>
</ul>
<p>这两个函数释放一个缓冲区，会让释放的缓冲区返回到缓冲池（缓存）中。dev_kfree_skb 只是通过宏定义的一个标示，内部还是调用的 kfree_skb。</p>
<p>kfree_skb 仅在 skb-&gt;users 计数器为1时（没有缓冲区的用户时）才释放缓冲区。 否则，该函数只会使该计数器递减。因此，如果一个缓冲区有三个用户，则只有当调用第三次 dev_kfree_skb 或 kfree_skb 时才会真正释放内存。</p>
<p><img src="https://user-images.githubusercontent.com/87457873/127462960-6fcf0432-7420-4ac2-84ca-008f8faec543.png" alt="image"></p>
<h2 id="数据保留和对齐"><a href="#数据保留和对齐" class="headerlink" title="数据保留和对齐"></a>数据保留和对齐</h2><ul>
<li>skb_reserve</li>
<li>skb_put</li>
<li>skb_push</li>
<li>skb_pull</li>
<li>skb_reserve 在缓冲区的头部保留一些空间，通常用于允许插入协议头或强制将数据在某个边界上对齐。它通过移动标记数据域开始和结束的 data 和 tail 指针来完成操作。</li>
</ul>
<p>查看以太网网卡驱动程序的代码（比如: drivers&#x2F;net&#x2F;ethernet&#x2F;3com&#x2F;3c59x.c vortex_rx 函数），你能看到它们在将任何数据存储在他们刚刚分配的缓冲区中之前都会使用以下命令：</p>
<pre><code>skb_reserve(skb, 2);	/* Align IP on 16 byte boundaries */
</code></pre>
<p>因为他们知道他们将要把协议头为 14 个字节的以太网帧复制到缓冲区中，所以参数2将缓冲区的 head 指针下移了 2 个字节。这将让紧跟在以太网头之后的 IP 头，从缓冲区的开头在 16 字节边界上对齐。</p>
<p><img src="https://user-images.githubusercontent.com/87457873/127463077-d110085e-493a-40d2-9130-af014e7c1acb.png" alt="image"></p>
<p>下图展示了 skb_reserve 在数据从上到下传递（发送数据）时的作用（为下层协议在数据区的头部分配空间）：</p>
<p><img src="https://user-images.githubusercontent.com/87457873/127463098-7f6f9bf7-64aa-49e6-8c19-b8d68891d9ba.png" alt="image"></p>
<p>1、当要求 TCP 传输某些数据时，它会按照某些条件（TCP Max Segment Size(mss)，对分散收集 I&#x2F;O 支持等）分配一个缓冲区。<br><br>2、TCP 在缓冲区的头部保留（通过调用 skb_reserve）足够的空间，以容纳所有层（TCP，IP，Link 层）的所有协议头。参数 MAX_TCP_HEADER 是所有级别的所有协议头的总和，并考虑到最坏的情况：因为 TCP 层不知道将使用哪种类型的接口进行传输，因此它为每个层保留最大的标头。它甚至考虑到多个 IP 协议头的可能性（因为当内核编译为支持 IP in IP 时，你可以拥有多个IP 协议头）。<br><br>3、TCP 的 payload （应用层传输的数据）被复制到缓冲区中。请注意上图只是个例子。TCP 的 payload 可以被不同地组织；例如，可以将其存储为片段。<br><br>4、TCP 层添加它的协议头。<br><br>5、TCP 层将缓冲区移交给 IP 层，IP层也添加协议头。<br><br>6、IP 层将缓冲区移交给下一层，下一层也添加它的协议头。<br></p>
<p>请注意，当缓冲区在网络栈中向下移动时，每个协议会将 skb-&gt;data 指针向下移动，在其协议头中复制，并更新 skb-&gt;len。</p>
<p>注意，skb_reserve 函数实际上并没有将任何内容移入或移出数据缓冲区。 它只是更新两个指针：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">static</span> <span class="keyword">inline</span> <span class="type">void</span> <span class="title function_">skb_reserve</span><span class="params">(<span class="keyword">struct</span> sk_buff *skb, <span class="type">int</span> len)</span></span><br><span class="line">&#123;</span><br><span class="line">	skb-&gt;data += len;</span><br><span class="line">	skb-&gt;tail += len;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<blockquote>
<p>感觉这里是用空间来换了时间，在一开始就分配需要用到的全部空间，然后就可以通过只移动指针来提高效率了。</p>
</blockquote>
<p>skb_push 将一个数据块添加到缓冲区的开头，而 skb_put 将一个数据块添加到末尾。像 skb_reserve 一样，这些函数实际上并不会向缓冲区添加任何数据。他们只是将指针移到它的头或尾。数据填充应该由其他功能显式操作。skb_pull 通过将 head 指针向前移动来从缓冲区的头中删除数据块。</p>
<h3 id="skb-shared-info-结构体-skb-shinfo-函数"><a href="#skb-shared-info-结构体-skb-shinfo-函数" class="headerlink" title="skb_shared_info 结构体 &amp; skb_shinfo 函数"></a>skb_shared_info 结构体 &amp; skb_shinfo 函数</h3><p>在上面网卡驱动拷贝帧到缓冲区的例子中出现过 skb_shared_info。它是用来保留与数据域有关的其他信息。这个数据结构紧跟在标记数据域结束的 end 指针后面。</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">skb_shared_info</span> &#123;</span></span><br><span class="line">    <span class="type">atomic_t</span>        dataref;</span><br><span class="line">    __u8            nr_frags;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">sk_buff</span>	*<span class="title">frag_list</span>;</span></span><br><span class="line">    <span class="type">skb_frag_t</span>	    frags[MAX_SKB_FRAGS];</span><br><span class="line">    <span class="comment">//...</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<ul>
<li>dataref：代表数据域的「用户」数（数据域被引用的次数）</li>
<li>nr_frags, frag_list, frags：用于处理 IP 片段</li>
</ul>
<p>skb_is_nonlinear 函数可用于检查缓冲区是否已分段，而 skb_linearize 函数可用于将多个片段合为单个缓冲区。</p>
<p>sk_buff 中没有专门的指针指向 skb_shared_info 区域，skb_shinfo 函数就是方便得到指向 skb_shared_info 区域指针的函数:</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">define</span> skb_shinfo(SKB)	((struct skb_shared_info *)(skb_end_pointer(SKB)))</span></span><br><span class="line"></span><br><span class="line"><span class="type">static</span> <span class="keyword">inline</span> <span class="type">unsigned</span> <span class="type">char</span> *<span class="title function_">skb_end_pointer</span><span class="params">(<span class="type">const</span> <span class="keyword">struct</span> sk_buff *skb)</span></span><br><span class="line">&#123;</span><br><span class="line">	<span class="keyword">return</span> skb-&gt;end;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="克隆和拷贝"><a href="#克隆和拷贝" class="headerlink" title="克隆和拷贝"></a>克隆和拷贝</h3><p>当相同的缓冲区需要由不同的消费者处理，并且他们可能更改 sk_buff 结构中的内容（协议头的h和 nh 指针等 Layout 字段）时，为了提高效率，内核并没有克隆缓冲区的结构和数据域，而是仅复制 sk_buff 的结构，并使用引用计数进行操作，以避免过早释放共享数据块。skb_clone 函数负责拷贝一个 buffer。</p>
<p>使用克隆的一种情况是，需要将入口数据包分发给多个接收者，例如协议处理程序和一个或多个网络分接头（Network taps）。</p>
<p>sk_buff 克隆不会链接到任何链表，也没有引用套接字所有者。克隆和原始缓冲区中的 skb-&gt;cloned 字段均设置为1。在克隆中将 skb-&gt;users 设置为1，以便第一次尝试删除它（被克隆的 sk_buff）时会成功，并且数据域的引用数（dataref）递增（因为现在有一个新的 sk_buff 指向了）。</p>
<p>skb_clone 会调用 __skb_clone:</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">static</span> <span class="class"><span class="keyword">struct</span> <span class="title">sk_buff</span> *__<span class="title">skb_clone</span>(<span class="keyword">struct</span> <span class="title">sk_buff</span> *<span class="title">n</span>, <span class="keyword">struct</span> <span class="title">sk_buff</span> *<span class="title">skb</span>) </span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> C(x) n-&gt;x = skb-&gt;x </span></span><br><span class="line"><span class="comment">// 定义的宏，如果 x 是普通变量则是值赋值</span></span><br><span class="line"><span class="comment">// 如果 x 是指针，则是指向同一块区域</span></span><br><span class="line"></span><br><span class="line">	n-&gt;next = n-&gt;prev = <span class="literal">NULL</span>;</span><br><span class="line">	n-&gt;sk = <span class="literal">NULL</span>;</span><br><span class="line">	__copy_skb_header(n, skb);</span><br><span class="line">    <span class="comment">//...</span></span><br><span class="line">	n-&gt;destructor = <span class="literal">NULL</span>;</span><br><span class="line">	C(tail);</span><br><span class="line">	C(end);</span><br><span class="line">	C(head);</span><br><span class="line">	C(head_frag);</span><br><span class="line">	C(data);    <span class="comment">// data 是一个指针, 所以没有克隆数据域，只是指向了数据域的内存地址</span></span><br><span class="line">	C(truesize);</span><br><span class="line">	refcount_set(&amp;n-&gt;users, <span class="number">1</span>); <span class="comment">//设置克隆的 sk_buff 的用户数为1</span></span><br><span class="line">	<span class="type">atomic_inc</span>(&amp;(skb_shinfo(skb)-&gt;dataref)); <span class="comment">//增加数据域的引用次数</span></span><br><span class="line">	skb-&gt;cloned = <span class="number">1</span>;</span><br><span class="line">	<span class="keyword">return</span> n;</span><br><span class="line"><span class="meta">#<span class="keyword">undef</span> C</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>下图为一个被分段（一个缓冲区，其中一些数据存储在与frags数组链接的数据片段中）了的缓冲区克隆的例子:</p>
<p><img src="https://user-images.githubusercontent.com/87457873/127463500-7ce7c75f-47ca-46f0-beba-68d57ffb9112.png" alt="image"></p>
<p>当缓冲区被克隆时，无法修改数据块的内容。这意味着代码无需做同步保证即可访问数据。但是，当一个函数不仅需要修改 sk_buff 结构的内容，还需要修改数据域时，就必须要克隆数据域了。如果真要修改数据域，开发者也有两个选项可用。</p>
<p>1、当开发者知道自己仅仅需要修改的数据在 skb-&gt;start 和 skb-&gt;end 的区域时，开发者可以使用 pskb_copy 方法只克隆那个区域。<br><br>2、当开发者认为自己或许也需要修改分段数据域时，就必须使用 skb_copy。<br></p>
<p>pskb_copy 和 skb_copy 的不同如下图中的(a)和(b):</p>
<p><img src="https://user-images.githubusercontent.com/87457873/127463640-4c822c4a-b66e-4e0c-9dec-37fd52aff195.png" alt="image"></p>
<p>在决定克隆或复制缓冲区时，每个子系统的程序员都无法预料其他内核组件（或其子系统的其他用户）是否需要该缓冲区中的原始信息。内核是非常模块化的，并且以非常动态和不可预测的方式进行更改，因此每个子系统都不知道其他子系统可以使用缓冲区做什么。因此，每个子系统的程序员只需跟踪他们对缓冲区所做的任何修改，并注意在修改任何内容之前先进行复制，以防内核的其他部分需要原始信息。</p>
<h2 id="队列管理函数"><a href="#队列管理函数" class="headerlink" title="队列管理函数"></a>队列管理函数</h2><p>有一些函数用来维护 sk_buff 双向链表（也可以称为队列 queue）中的节点。下面是一些常用的功能函数：</p>
<h3 id="skb-queue-head-init"><a href="#skb-queue-head-init" class="headerlink" title="skb_queue_head_init"></a>skb_queue_head_init</h3><p>使用空节点初始化 sk_buff_head。</p>
<h3 id="skb-queue-head-skb-queue-tail"><a href="#skb-queue-head-skb-queue-tail" class="headerlink" title="skb_queue_head, skb_queue_tail"></a>skb_queue_head, skb_queue_tail</h3><p>将一个缓冲区添加到队列的头部或尾部。</p>
<h3 id="skb-dequeue-skb-dequeue-tail"><a href="#skb-dequeue-skb-dequeue-tail" class="headerlink" title="skb_dequeue, skb_dequeue_tail"></a>skb_dequeue, skb_dequeue_tail</h3><p>从队列的头和尾取出一个节点。</p>
<h3 id="skb-queue-purge"><a href="#skb-queue-purge" class="headerlink" title="skb_queue_purge"></a>skb_queue_purge</h3><p>清空队列。</p>
<h3 id="skb-queue-walk"><a href="#skb-queue-walk" class="headerlink" title="skb_queue_walk"></a>skb_queue_walk</h3><p>使用 for 循环遍历队列，其实现如下：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">define</span> skb_queue_walk(queue, skb) </span></span><br><span class="line">       <span class="keyword">for</span> (skb = (<span class="built_in">queue</span>)-&gt;next;					</span><br><span class="line">            skb != (<span class="keyword">struct</span> sk_buff *)(<span class="built_in">queue</span>);				</span><br><span class="line">            skb = skb-&gt;next)</span><br></pre></td></tr></table></figure>
<p>可以看到其实现是定义了一个宏，预处理编译之后 skb_queue_walk 就会被替换为上面的代码，因为 sk_buff 的队列是一个双向链表，去过遍历到了头节点，说明遍历完成了。</p>
<p>操作队列的所有函数都必须保证是原子操作。也就是说，它们必须获取 sk_buff_head 结构提供的队列自旋锁。否则，它们可能会被异步事件中断，这些异步事件会使队列中的元素入队或出队，例如到期计时器调用的函数会导致争用条件。</p>
]]></content>
      <categories>
        <category>linux-doc 网络协议栈</category>
      </categories>
      <tags>
        <tag>Linux</tag>
      </tags>
  </entry>
  <entry>
    <title>Linux 总线、设备、驱动模型的探究</title>
    <url>/2023/01/15/linux-docs/%E8%AE%BE%E5%A4%87%E9%A9%B1%E5%8A%A8/Linux%20%E6%80%BB%E7%BA%BF%E3%80%81%E8%AE%BE%E5%A4%87%E3%80%81%E9%A9%B1%E5%8A%A8%E6%A8%A1%E5%9E%8B%E7%9A%84%E6%8E%A2%E7%A9%B6/</url>
    <content><![CDATA[<h2 id="设备驱动模型的需求"><a href="#设备驱动模型的需求" class="headerlink" title="设备驱动模型的需求"></a>设备驱动模型的需求</h2><p>总线、设备和驱动模型，如果把它们之间的关系比喻成生活中的例子是比较容易理解的。举个例子，充电墙壁插座安静的嵌入在墙面上，无论设备是电脑还是手机，插座都能依然不动的完成它的使命——充电，没有说为了满足各种设备充电而去更换插座的。其实这就是软件工程强调的高内聚、低耦合概念。</p>
<p>所谓高内聚低耦合是模块内各元素联系越紧密就代表内聚性就越高，模块间联系越不紧密就代表耦合性低。所以高内聚、低耦合强调的就是内部要紧紧抱团。设备和驱动就是基于这种模型去实现彼此隔离不相干的。这里，有的读者就要问了，高内聚、低耦合的软件模型理解，可设备和驱动为什么要采用这种模型呢？没错，好问题。下面进入今天的话题——总线、设备和驱动模型的探究。</p>
<p>设想一个叫 GITCHAT 的网卡，它需要接在 CPU 的内部总线上，需要地址总线、数据总线和控制总线，以及中断 pin 脚等。</p>
<p><img src="https://user-images.githubusercontent.com/87457873/127286715-07ef723d-37f8-4ca2-b33d-fc8d87aaf7bf.png" alt="image"></p>
<p>那么在 GITCHAT 的驱动里需要定义 GITCHAT 的基地址、中断号等信息。假设 GITCHAT 的地址为0x0001，中断号是 2，那么：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">define</span> GITCHAT_BASE 0x0001</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> GITCHAT_INTERRUPT 2</span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">gitchat_send</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">    writel(GITCHAT_BASE + REG, <span class="number">1</span>);</span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">gitchat_init</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">    request_init(GITCHAT_INTERRUPT, ...);</span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>但是世界上的板子千千万，有三星、华为、飞思卡尔……每个板子的信息也都不一样，站在驱动的角度看，当每次重新换板子的时候，<code>GITCHAT_BASE</code> 和 <code>GITCHAT_INTERRUPT</code> 就不再一样，那驱动代码也要随之改变。这样的话一万个开发板要写一万个驱动了，这就是文章刚开始提到的高内聚、低耦合的应用场景。</p>
<p>驱动想以不变应万变的姿态适配各种设备连接的话就要实现设备驱动模型。基本上我们可以认为驱动不会因为 CPU 的改变而改变，所以它应该是跨平台的。自然像 <code>“#define GITCHAT_BASE 0x0001，#define GITCHAT_INTERRUPT 2”</code> 这样描述和 CPU 相关信息的代码不应该出现在驱动里。</p>
<h2 id="设备驱动模型的实现"><a href="#设备驱动模型的实现" class="headerlink" title="设备驱动模型的实现"></a>设备驱动模型的实现</h2><p>现在 CPU 板级信息和驱动分开的需求已经刻不容缓。但是基地址、中断号等板级信息始终和驱动是有一定联系的，因为驱动毕竟要取出基地址、中断号等。怎么取？有一种方法是 GITCHAT 驱动满世界去询问各个板子：请问你的基地址是多少？中断号是几？细心的读者会发现这仍然是一个耦合的情况。</p>
<p><img src="https://user-images.githubusercontent.com/87457873/127286885-5cfc7135-a880-48b7-9549-13261e2916fe.png" alt="image"></p>
<p>对软件工程熟悉的读者肯定立刻想到能不能设计一个类似接口适配器的类（adapter）去适配不同的板级信息，这样板子上的基地址、中断号等信息都在一个 adapter 里去维护，然后驱动通过这个 adapter 不同的 API 去获取对应的硬件信息。没错，Linux 内核里就是运用了这种设计思想去对设备和驱动进行适配隔离的，只不过在内核里我们不叫做适配层，而取名为总线，意为通过这个总线去把驱动和对应的设备绑定一起，如图：</p>
<p><img src="https://user-images.githubusercontent.com/87457873/127286901-f967d825-2d27-4cdc-9a76-b117a2593f11.png" alt="image"></p>
<p>基于这种设计思想，Linux 把设备驱动分为了总线、设备和驱动三个实体，这三个实体在内核里的职责分别如下：</p>
<p><img src="https://user-images.githubusercontent.com/87457873/127286925-363b54c7-3e7d-4753-b306-f5cbd9972933.png" alt="image"></p>
<p>模型设计好后，下面来看一下具体驱动的实践，首先把板子的硬件信息填入设备端，然后让设备向总线注册，这样总线就间接的知道了设备的硬件信息。比如一个板子上有一个 GITCHAT，首先向总线注册：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">static</span> <span class="class"><span class="keyword">struct</span> <span class="title">resource</span> <span class="title">gitchat_resource</span>[] =</span> &#123;</span><br><span class="line">    &#123;</span><br><span class="line">            .start = ...,</span><br><span class="line">            .end = ...,</span><br><span class="line">            .flags = IORESOURCE_MEM</span><br><span class="line">    &#125;...</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="type">static</span> <span class="class"><span class="keyword">struct</span> <span class="title">platform_device</span> <span class="title">gitchat_device</span> =</span> &#123;</span><br><span class="line">    .name = <span class="string">&quot;gitchat&quot;</span>;</span><br><span class="line">    .id = <span class="number">0</span>;</span><br><span class="line">    .num_resources = ARRAY_SIZE(gitchat_resource);</span><br><span class="line">    .resource = gitchat_resource,</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="type">static</span> <span class="class"><span class="keyword">struct</span> <span class="title">platform_device</span> *<span class="title">ip0x_device</span> __<span class="title">initdata</span> =</span> &#123;</span><br><span class="line">    &amp;gitchat_device,</span><br><span class="line">    ...</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="type">static</span> ini __init <span class="title function_">ip0x_init</span><span class="params">(<span class="type">void</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">    platform_add_devices(ip0x_device, ARRAY_SIZE(ip0x_device));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>现在 platform 总线上自然知道了板子上关于 GITCHAT 设备的硬件信息，一旦 GITCHAT 的驱动也被注册的话，总线就会把驱动和设备绑定起来，从而驱动就获得了基地址、中断号等板级信息。总线存在的目的就是把设备和对应的驱动绑定起来，让内核成为该是谁的就是谁的和谐世界，有点像我们生活中红娘的角色，把有缘人通过红线牵在一起。设备注册总线的代码例子看完了，下面看下驱动注册总线的代码示例：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">static</span> <span class="class"><span class="keyword">struct</span> <span class="title">resource</span> <span class="title">gitchat_resource</span>[] =</span> &#123;</span><br><span class="line">    &#123;</span><br><span class="line">            .start = ...,</span><br><span class="line">            .end = ...,</span><br><span class="line">            .flags = IORESOURCE_MEM</span><br><span class="line">    &#125;...</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="type">static</span> <span class="class"><span class="keyword">struct</span> <span class="title">platform_device</span> <span class="title">gitchat_device</span> =</span> &#123;</span><br><span class="line">    .name = <span class="string">&quot;gitchat&quot;</span>;</span><br><span class="line">    .id = <span class="number">0</span>;</span><br><span class="line">    .num_resources = ARRAY_SIZE(gitchat_resource);</span><br><span class="line">    .resource = gitchat_resource,</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="type">static</span> <span class="class"><span class="keyword">struct</span> <span class="title">platform_device</span> *<span class="title">ip0x_device</span> __<span class="title">initdata</span> =</span> &#123;</span><br><span class="line">    &amp;gitchat_device,</span><br><span class="line">    ...</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="type">static</span> ini __init <span class="title function_">ip0x_init</span><span class="params">(<span class="type">void</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">    platform_add_devices(ip0x_device, ARRAY_SIZE(ip0x_device));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>现在 platform 总线上自然知道了板子上关于 GITCHAT 设备的硬件信息，一旦 GITCHAT 的驱动也被注册的话，总线就会把驱动和设备绑定起来，从而驱动就获得了基地址、中断号等板级信息。总线存在的目的就是把设备和对应的驱动绑定起来，让内核成为该是谁的就是谁的和谐世界，有点像我们生活中红娘的角色，把有缘人通过红线牵在一起。设备注册总线的代码例子看完了，下面看下驱动注册总线的代码示例：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">static</span> <span class="type">int</span> <span class="title function_">gitchat_probe</span><span class="params">(<span class="keyword">struct</span> platform_device *pdev)</span></span><br><span class="line">&#123;</span><br><span class="line">    ...</span><br><span class="line">    db-&gt;addr_res = platform_get_resource(pdev, IORESOURCE_MEM, <span class="number">0</span>);</span><br><span class="line">    db-&gt;data_res = platform_get_resource(pdev, IORESOURCE_MEM, <span class="number">1</span>);</span><br><span class="line">    db-&gt;irq_res  = platform_get_resource(pdev, IORESOURCE_IRQ, <span class="number">2</span>);</span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>从代码中看到驱动是通过总线 API 接口 platform_get_resource 取得板级信息，这样驱动和设备之间就实现了高内聚、低耦合的设计，无论你设备怎么换，我驱动就可以岿然不动。</p>
<p>看到这里，可能有些喜欢探究本质的读者又要问了，设备向总线注册了板级信息，驱动也向总线注册了驱动模块，但总线是怎么做到驱动和设备匹配的呢？接下来就讲下设备和驱动是怎么通过总线进行“联姻”的。</p>
<p>总线里有很多匹配方式，比如：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">static</span> <span class="type">int</span> <span class="title function_">platform_match</span><span class="params">(<span class="keyword">struct</span> device *dev, <span class="keyword">struct</span> device_driver *drv)</span></span><br><span class="line">&#123;</span><br><span class="line">        <span class="class"><span class="keyword">struct</span> <span class="title">platform_device</span> *<span class="title">pdev</span> =</span> to_platform_device(dev);</span><br><span class="line">        <span class="class"><span class="keyword">struct</span> <span class="title">platform_driver</span> *<span class="title">pdrv</span> =</span> to_platform_driver(drv);</span><br><span class="line"></span><br><span class="line">        <span class="comment">/* When driver_override is set, only bind to the matching driver */</span></span><br><span class="line">        <span class="keyword">if</span> (pdev-&gt;driver_override) </span><br><span class="line">                <span class="keyword">return</span> !<span class="built_in">strcmp</span>(pdev-&gt;driver_override, drv-&gt;name);</span><br><span class="line"></span><br><span class="line">        <span class="comment">/* Attempt an OF style match first */</span></span><br><span class="line">        <span class="keyword">if</span> (of_driver_match_device(dev, drv))</span><br><span class="line">                <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">        <span class="comment">/* Then try ACPI style match */</span></span><br><span class="line">        <span class="keyword">if</span> (acpi_driver_match_device(dev, drv))</span><br><span class="line">                <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">        <span class="comment">/* Then try to match against the id table */</span></span><br><span class="line">        <span class="keyword">if</span> (pdrv-&gt;id_table)</span><br><span class="line">                <span class="keyword">return</span> platform_match_id(pdrv-&gt;id_table, pdev) != <span class="literal">NULL</span>;</span><br><span class="line"></span><br><span class="line">        <span class="comment">/* fall-back to driver name match */</span></span><br><span class="line">        <span class="keyword">return</span> (<span class="built_in">strcmp</span>(pdev-&gt;name, drv-&gt;name) == <span class="number">0</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>从上面可知 platform 总线下的设备和驱动是通过名字进行匹配的，先去匹配 platform_driver 中的 id_table 表中的各个名字与 platform_device-&gt;name 名字是否相同，如果相同则匹配。</p>
<h2 id="设备驱动模型的改善"><a href="#设备驱动模型的改善" class="headerlink" title="设备驱动模型的改善"></a>设备驱动模型的改善</h2><p><img src="https://user-images.githubusercontent.com/87457873/127287143-eabdd51f-b8a8-44a8-b04f-131f132dcc7b.png" alt="image"></p>
<p>最底层是不同板子的板级文件代码，中间层是内核的总线，最上层是对应的驱动，现在描述板级的代码已经和驱动解耦了，这也是 Linux 设备驱动模型最早的实现机制，但随着时代的发展，就像是人类的贪婪促进了社会的进步一样，开发人员对这种模型有了更高的要求，虽然驱动和设备解耦了，但是天下设备千千万，每次设备的需求改动都要去修改 board-xxx.c 设备文件的话，这样下去，有太多的板级文件需要维护。完美的 Linux 怎么会允许这样的事情存在，于是乎，设备树（DTS）就登向了历史舞台</p>
]]></content>
      <categories>
        <category>linux-doc 设备驱动</category>
      </categories>
      <tags>
        <tag>Linux</tag>
      </tags>
  </entry>
  <entry>
    <title>Linux 设备和驱动的相遇</title>
    <url>/2023/01/15/linux-docs/%E8%AE%BE%E5%A4%87%E9%A9%B1%E5%8A%A8/Linux%20%E8%AE%BE%E5%A4%87%E5%92%8C%E9%A9%B1%E5%8A%A8%E7%9A%84%E7%9B%B8%E9%81%87/</url>
    <content><![CDATA[<p>本文结合设备信息集合的详细讲解来认识一下设备和驱动是如何绑定的。所谓设备信息集合，就是根据不同的外设寻找各自的外设信息，我们知道一个完整的开发板有 CPU 和各种控制器（如 I2C 控制器、SPI 控制器、DMA 控制器等），CPU 和控制器可以统称为 SOC，除此之外还有各种外设 IP，如 LCD、HDMI、SD、CAMERA 等，如下图：</p>
<p><img src="https://user-images.githubusercontent.com/87457873/127285796-ea083293-3263-4e05-a477-925592d05f9e.png" alt="image"></p>
<p>我们看到一个开发板有很多的设备，这些设备是如何一层一层展开的呢？设备和驱动又是如何绑定的呢？我们带着这些疑问进入本节的主题。</p>
<h2 id="各级设备的展开"><a href="#各级设备的展开" class="headerlink" title="各级设备的展开"></a>各级设备的展开</h2><p>内核启动的时候是一层一层展开地去寻找设备，设备树之所以叫设备树也是因为设备在内核中的结构就像树一样，从根部一层一层的向外展开，为了更形象的理解来看一张图：</p>
<p><img src="https://user-images.githubusercontent.com/87457873/127285861-e3271731-6448-4ac7-97c5-30bfdc2481bb.png" alt="image"></p>
<p>大的圆圈中就是我们常说的 soc，里面包括 CPU 和各种控制器 A、B、I2C、SPI，soc 外面接了外设 E 和 F。IP 外设有具体的总线，如 I2C 总线、SPI 总线，对应的 I2C 设备和 SPI 设备就挂在各自的总线上，但是在 soc 内部只有系统总线，是没有具体总线的。</p>
<p>第一节中讲了总线、设备和驱动模型的原理，即任何驱动都是通过对应的总线和设备发生联系的，故虽然 soc 内部没有具体的总线，但是内核通过 platform 这条虚拟总线，把控制器一个一个找到，一样遵循了内核高内聚、低耦合的设计理念。下面我们按照 platform 设备、i2c 设备、spi 设备的顺序探究设备是如何一层一层展开的。</p>
<h3 id="1-展开-platform-设备"><a href="#1-展开-platform-设备" class="headerlink" title="1.展开 platform 设备"></a>1.展开 platform 设备</h3><p>上图中可以看到红色字体标注的 simple-bus，这些就是连接各类控制器的总线，在内核里即为 platform 总线，挂载的设备为 platform 设备。下面看下 platform 设备是如何展开的。</p>
<p>还记得上一节讲到在内核初始化的时候有一个叫做 <code>init_machine()</code> 的回调函数吗？如果你在板级文件里注册了这个函数，那么在系统启动的时候这个函数会被调用，如果没有定义，则会通过调用 of_platform_populate() 来展开挂在“simple-bus”下的设备，如图（分别位于 kernel&#x2F;arch&#x2F;arm&#x2F;kernel&#x2F;setup.c，kernel&#x2F;drivers&#x2F;of&#x2F;platform.c）：</p>
<p><img src="https://user-images.githubusercontent.com/87457873/127285963-9362eaf2-3576-4635-b142-dc21a82b2c19.png" alt="image"></p>
<p>这样就把 simple-bus 下面的节点一个一个的展开为 platform 设备。</p>
<h3 id="2-展开-i2c-设备"><a href="#2-展开-i2c-设备" class="headerlink" title="2.展开 i2c 设备"></a>2.展开 i2c 设备</h3><p>有经验的小伙伴知道在写 i2c 控制器的时候肯定会调用 <code>i2c_register_adapter()</code> 函数，该函数的实现如下（kernel&#x2F;drivers&#x2F;i2c&#x2F;i2c-core.c）：</p>
<p><img src="https://user-images.githubusercontent.com/87457873/127286040-6b898b62-5943-421f-ad5e-cebb24e26b5b.png" alt="image"></p>
<p>注册函数的最后有一个函数 <code>of_i2c_register_devices(adap)</code>，实现如下：</p>
<p><img src="https://user-images.githubusercontent.com/87457873/127286068-fb94a65a-aecf-40d2-85dd-604df41878b7.png" alt="image"></p>
<p><code>of_i2c_register_devices()</code>函数中会遍历控制器下的节点，然后通过<code>of_i2c_register_device()</code>函数把 i2c 控制器下的设备注册进去。</p>
<h3 id="3-展开-spi-设备"><a href="#3-展开-spi-设备" class="headerlink" title="3.展开 spi 设备"></a>3.展开 spi 设备</h3><p>spi 设备的注册和 i2c 设备一样，在 spi 控制器下遍历 spi 节点下的设备，然后通过相应的注册函数进行注册，只是和 i2c 注册的 api 接口不一样，下面看一下具体的代码（kernel&#x2F;drivers&#x2F;spi&#x2F;spi.c)：</p>
<p><img src="https://user-images.githubusercontent.com/87457873/127286193-073f2998-5f50-4e44-a514-6c62f39942d6.png" alt="image"></p>
<p>当通过 spi_register_master 注册 spi 控制器的时候会通过 of_register_spi_devices 来遍历 spi 总线下的设备，从而注册。这样就完成了 spi 设备的注册。</p>
<h2 id="各级设备的展开-1"><a href="#各级设备的展开-1" class="headerlink" title="各级设备的展开"></a>各级设备的展开</h2><p>学到这里相信应该了解设备的硬件信息是从设备树里获取的，如寄存器地址、中断号、时钟等等。接下来我们一起看下这些信息在设备树里是怎么记录的，为下一节动手定制开发板做好准备。</p>
<h3 id="1-reg-寄存器"><a href="#1-reg-寄存器" class="headerlink" title="1.reg 寄存器"></a>1.reg 寄存器</h3><p><img src="https://user-images.githubusercontent.com/87457873/127286303-780312b8-d1b1-4dc3-a9e3-14f6eeebb1dc.png" alt="image"></p>
<p>我们先看设备树里的 soc 描述信息，红色标注的代表着寄存器地址用几个数据量来表述，绿色标注的代表着寄存器空间大小用几个数据量来表述。图中的含义是中断控制器的基地址是 0xfec00000，空间大小是 0x1000。如果 address-cells 的值是 2 的话表示需要两个数量级来表示基地址，比如寄存器是 64 位的话就需要两个数量级来表示，每个代表着 32 位的数。</p>
<h2 id="2-ranges-取值范围"><a href="#2-ranges-取值范围" class="headerlink" title="2.ranges 取值范围"></a>2.ranges 取值范围</h2><p><img src="https://user-images.githubusercontent.com/87457873/127286334-3a4c097c-bf2c-458f-b503-4ed7bc46b343.png" alt="image"></p>
<p>ranges 代表了 local 地址向 parent 地址的转换，如果 ranges 为空的话代表着与 cpu 是 1:1 的映射关系，如果没有 range 的话表示不是内存区域。</p>
]]></content>
      <categories>
        <category>linux-doc 设备驱动</category>
      </categories>
      <tags>
        <tag>Linux</tag>
      </tags>
  </entry>
  <entry>
    <title>Linux内核启动之zImage自解压过程</title>
    <url>/2023/01/15/linux-docs/%E8%AE%BE%E5%A4%87%E9%A9%B1%E5%8A%A8/Linux%E5%86%85%E6%A0%B8%E5%90%AF%E5%8A%A8%E4%B9%8BzImage%E8%87%AA%E8%A7%A3%E5%8E%8B%E8%BF%87%E7%A8%8B/</url>
    <content><![CDATA[<h2 id="1、zImage来历"><a href="#1、zImage来历" class="headerlink" title="1、zImage来历"></a><strong>1、zImage来历</strong></h2><p>顶层vmlinux —-&gt;</p>
<p>arch&#x2F;arm&#x2F;boot&#x2F;Image —&gt;</p>
<p>arch&#x2F;arm&#x2F;boot&#x2F;compressed&#x2F;piggy.gz —&gt;</p>
<p>arch&#x2F;arm&#x2F;boot&#x2F;compressed&#x2F;vmlinux —&gt;</p>
<p>arch&#x2F;arm&#x2F;boot&#x2F;<strong>zImage</strong></p>
<p>如果要分析zImage的反汇编反汇编文件，可将arch&#x2F;arm&#x2F;boot&#x2F;compressed&#x2F;vmlinux进行反汇编，</p>
<p>arm-linux-xxx-objdump –d vmlinux &gt; vmlinux.dis</p>
<p>对顶层的vmlinux反汇编得到的是未压缩的内核的反汇编文件，这个vmlinux才是真正的Linux内核。</p>
<h2 id="2、piggy-gz压缩文件的特点"><a href="#2、piggy-gz压缩文件的特点" class="headerlink" title="2、piggy.gz压缩文件的特点"></a>2、<strong>piggy.gz压缩文件的特点</strong></h2><p><strong>gzip -f -9 &lt; Image &gt; piggy.gz</strong></p>
<p>在piggy.gz的结尾四个字节表示的是 Image 镜像的大小，并且是以小端格式存放的。下面我们验证一下：</p>
<p><img src="https://pic1.zhimg.com/80/v2-3668c9d91b4e32ac2f7e76e2325fa340_720w.webp" alt="img"></p>
<p>可以看到，Image的大小是6806148B，十六进制值就是67DA84，接下来看看piggy.gz的结尾：</p>
<p><img src="https://pic3.zhimg.com/80/v2-4c4d80504e931db15b4c772ea4a8a83a_720w.webp" alt="img"></p>
<p><img src="https://pic4.zhimg.com/80/v2-195629b07facdc2f50d041e0c082a02b_720w.webp" alt="img"></p>
<p>可以看到，确实是将0x67DA84以小端的格式存放在了piggy.gz的结尾四字节中了。</p>
<p><strong>vmlinux.lds</strong></p>
<figure class="highlight text"><table><tr><td class="code"><pre><span class="line">1:  /*</span><br><span class="line">   2:   *  linux/arch/arm/boot/compressed/vmlinux.lds.in</span><br><span class="line">   3:   *</span><br><span class="line">   4:   *  Copyright (C) 2000 Russell King</span><br><span class="line">   5:   *</span><br><span class="line">   6:   * This program is free software; you can redistribute it and/or modify</span><br><span class="line">   7:   * it under the terms of the GNU General Public License version 2 as</span><br><span class="line">   8:   * published by the Free Software Foundation.</span><br><span class="line">   9:   */</span><br><span class="line">  10:  OUTPUT_ARCH(arm)</span><br><span class="line">  11:  ENTRY(_start)</span><br><span class="line">  12:  SECTIONS</span><br><span class="line">  13:  &#123;</span><br><span class="line">  14:    /DISCARD/ : &#123;</span><br><span class="line">  15:      *(.ARM.exidx*)</span><br><span class="line">  16:      *(.ARM.extab*)</span><br><span class="line">  17:      /*</span><br><span class="line">  18:       * Discard any r/w data - this produces a link error if we have any,</span><br><span class="line">  19:       * which is required for PIC decompression.  Local data generates</span><br><span class="line">  20:       * GOTOFF relocations, which prevents it being relocated independently</span><br><span class="line">  21:       * of the text/got segments.</span><br><span class="line">  22:       */</span><br><span class="line">  23:      *(.data)</span><br><span class="line">  24:    &#125;</span><br><span class="line">  25:   </span><br><span class="line">  26:    . = 0;</span><br><span class="line">  27:    _text = .;</span><br><span class="line">  28:   </span><br><span class="line">  29:    .text : &#123;</span><br><span class="line">  30:      _start = .;</span><br><span class="line">  31:      *(.start)</span><br><span class="line">  32:      *(.text)</span><br><span class="line">  33:      *(.text.*)</span><br><span class="line">  34:      *(.fixup)</span><br><span class="line">  35:      *(.gnu.warning)</span><br><span class="line">  36:      *(.rodata)</span><br><span class="line">  37:      *(.rodata.*)</span><br><span class="line">  38:      *(.glue_7)</span><br><span class="line">  39:      *(.glue_7t)</span><br><span class="line">  40:      *(.piggydata)</span><br><span class="line">  41:      . = ALIGN(4);</span><br><span class="line">  42:    &#125;</span><br><span class="line">  43:   </span><br><span class="line">  44:    _etext = .;</span><br><span class="line">  45:   </span><br><span class="line">  46:    _got_start = .;</span><br><span class="line">  47:    .got            : &#123; *(.got) &#125;</span><br><span class="line">  48:    _got_end = .;</span><br><span class="line">  49:    .got.plt        : &#123; *(.got.plt) &#125;</span><br><span class="line">  50:    _edata = .;</span><br><span class="line">  51:   </span><br><span class="line">  52:    . = ALIGN(8);</span><br><span class="line">  53:    __bss_start = .;</span><br><span class="line">  54:    .bss            : &#123; *(.bss) &#125;</span><br><span class="line">  55:    _end = .;</span><br><span class="line">  56:   </span><br><span class="line">  57:    . = ALIGN(8);        /* the stack must be 64-bit aligned */</span><br><span class="line">  58:    .stack        : &#123; *(.stack) &#125;</span><br><span class="line">  59:   </span><br><span class="line">  60:    .stab 0        : &#123; *(.stab) &#125;</span><br><span class="line">  61:    .stabstr 0        : &#123; *(.stabstr) &#125;</span><br><span class="line">  62:    .stab.excl 0        : &#123; *(.stab.excl) &#125;</span><br><span class="line">  63:    .stab.exclstr 0    : &#123; *(.stab.exclstr) &#125;</span><br><span class="line">  64:    .stab.index 0        : &#123; *(.stab.index) &#125;</span><br><span class="line">  65:    .stab.indexstr 0    : &#123; *(.stab.indexstr) &#125;</span><br><span class="line">  66:    .comment 0        : &#123; *(.comment) &#125;</span><br><span class="line">  67:  &#125;</span><br><span class="line">  68:  </span><br></pre></td></tr></table></figure>

<p><strong>arch&#x2F;arm&#x2F;boot&#x2F;compressed&#x2F;head.S</strong></p>
<figure class="highlight text"><table><tr><td class="code"><pre><span class="line">1:  .section &quot;.start&quot;, #alloc, #execinstr</span><br><span class="line">   2:  /*</span><br><span class="line">   3:  * 清理不同的调用约定</span><br><span class="line">   4:  */</span><br><span class="line">   5:  .align</span><br><span class="line">   6:  .arm @ 启动总是进入ARM状态</span><br><span class="line">   7:  start:</span><br><span class="line">   8:  .type start,#function</span><br><span class="line">   9:  .rept 7</span><br><span class="line">  10:  mov r0, r0</span><br><span class="line">  11:  .endr</span><br><span class="line">  12:  ARM( mov r0, r0 )</span><br><span class="line">  13:  ARM( b 1f )</span><br><span class="line">  14:  THUMB( adr r12, BSYM(1f) )</span><br><span class="line">  15:  THUMB( bx r12 )</span><br><span class="line">  16:  .word 0x016f2818 @ 用于boot loader的魔数</span><br><span class="line">  17:  .word start @ 加载/运行zImage的绝对地址（编译时确定）, 在vmlinux.lds中可以看到，zImage的链接起始地址是0</span><br><span class="line">  18:  .word _edata @ zImage结束地址,分析vmlinux.lds可以看到，_edata是 .got 段的结束地址，后面紧接的就是.bss段和.stack段</span><br><span class="line">  19:  THUMB( .thumb )</span><br><span class="line">  20:  1: mov r7, r1 @ 保存构架ID到r7（此前由bootloader放入r1）</span><br><span class="line">  21:     mov r8, r2 @ 保存内核启动参数地址到r8（此前由bootloader放入r2）</span><br><span class="line">  22:  #ifndef __ARM_ARCH_2__</span><br><span class="line">  23:  /*</span><br><span class="line">  24:  * 通过Angel调试器启动 - 必须进入 SVC模式且关闭FIQs/IRQs</span><br><span class="line">  25:  * (numeric definitions from angel arm.h source).</span><br><span class="line">  26:  * 如果进入时在user模式下，我们只需要做这些</span><br><span class="line">  27:  */</span><br><span class="line">  28:  mrs r2, cpsr @ 获取当前模式</span><br><span class="line">  29:  tst r2, #3 @ 判断是否是user模式</span><br><span class="line">  30:  bne not_angel</span><br><span class="line">  31:  mov r0, #0x17 @ angel_SWIreason_EnterSVC</span><br><span class="line">  32:  ARM( swi 0x123456 ) @ angel_SWI_ARM  swi会产生软中断，会跳入中断向量表，这个向量表用的是bootloader的，因为在head.S中并没有建立新的向量表</span><br><span class="line">  33:  THUMB( svc 0xab ) @ angel_SWI_THUMB</span><br><span class="line">  34:  not_angel:</span><br><span class="line">  35:  mrs r2, cpsr @ 关闭中断</span><br><span class="line">  36:  orr r2, r2, #0xc0 @ 以保护调试器的运作 关闭IRQ和FIQ</span><br><span class="line">  37:  msr cpsr_c, r2</span><br><span class="line">  38:  #else</span><br><span class="line">  39:  teqp pc, #0x0c000003@ 关闭中断（此外bootloader已设置模式为SVC）</span><br><span class="line">  40:  #endif</span><br><span class="line"> </span><br><span class="line"></span><br><span class="line">GOT表是什么？</span><br><span class="line"></span><br><span class="line">GOT（Global Offset Table）表中每一项都是本运行模块要引用的一个全局变量或函数的地址。可以用GOT表来间接引用全局变量、函数，也可以把GOT表的首地址作为一个基准，用相对于该基准的偏移量来引用静态变量、静态函数。</span><br><span class="line"></span><br><span class="line">更多介绍请参考：</span><br><span class="line"></span><br><span class="line">http://blog.sina.com.cn/s/blog_54f82cc201011oqy.html</span><br><span class="line"></span><br><span class="line">http://blog.sina.com.cn/s/blog_54f82cc201011oqv.html</span><br><span class="line"></span><br><span class="line">接着分析head.S</span><br><span class="line"></span><br><span class="line">   1:  /*</span><br><span class="line">   2:  * 注意一些缓存的刷新和其他事务可能需要在这里完成</span><br><span class="line">   3:  * - is there an Angel SWI call for this?</span><br><span class="line">   4:  */</span><br><span class="line">   5:  /*</span><br><span class="line">   6:  * 一些构架的特定代码可以在这里被连接器插入，</span><br><span class="line">   7:  * 但是不应使用 r7（保存构架ID）, r8（保存内核启动参数地址）, and r9.</span><br><span class="line">   8:  */</span><br><span class="line">   9:  .text</span><br><span class="line">  10:  /*</span><br><span class="line">  11:  * 此处确定解压后的内核映像的绝对地址（物理地址），保存于r4</span><br><span class="line">  12:  * 由于配置的不同可能有的结果</span><br><span class="line">  13:  * （1）定义了CONFIG_AUTO_ZRELADDR</span><br><span class="line">  14:  *      ZRELADDR是已解压内核最终存放的物理地址</span><br><span class="line">  15:  *      如果AUTO_ZRELADDR被选择了, 这个地址将会在运行是确定：</span><br><span class="line">  16:  *      将当pc值和0xf8000000做与操作，</span><br><span class="line">  17:  *      并加上TEXT_OFFSET（内核最终存放的物理地址与内存起始的偏移）</span><br><span class="line">  18:  *      这里假定zImage被放在内存开始的128MB内</span><br><span class="line">  19:  * （2）没有定义CONFIG_AUTO_ZRELADDR</span><br><span class="line">  20:  *      直接使用zreladdr（此值位于arch/arm/mach-xxx/Makefile.boot文件确定）</span><br><span class="line">  21:  */</span><br><span class="line">  22:  #ifdef CONFIG_AUTO_ZRELADDR</span><br><span class="line">  23:  @ 确定内核映像地址</span><br><span class="line">  24:  mov r4, pc</span><br><span class="line">  25:  and r4, r4, #0xf8000000</span><br><span class="line">  26:  add r4, r4, #TEXT_OFFSET</span><br><span class="line">  27:  #else</span><br><span class="line">  28:  ldr r4, =zreladdr                             以我的板子为例，它的值是0x80008000,即它的物理内存起始地址是0x80000000</span><br><span class="line">  29:  #endif</span><br><span class="line">  30:  bl cache_on /* 开启缓存（以及MMU） */         关于cache_on这部分，我在这里就不分析了</span><br><span class="line">  31:  restart: adr r0, LC0   获取LC0的运行地址，而不是链接地址</span><br><span class="line">  32:  ldmia r0, &#123;r1, r2, r3, r6, r10, r11, r12&#125;</span><br><span class="line">       /*</span><br><span class="line">            依次将LC0的链接地址放入r1中，bss段的链接起始和结束地址__bss_start和_end分别放入r2和r3中</span><br><span class="line">            _edata的链接地址放入r6中，piggy.gz的倒数第四个字节的地址放入r10中， got表的起始和结束链接地址分别放入r11和r12中</span><br><span class="line">      */</span><br><span class="line">33: ldr sp, [r0, #28]   此时r0中存放的还是LC0的运行地址，所以加28后正好是LC0数组中的.L_user_stack_end的值(栈的结束地址)，他在head.S的结尾定义</span><br><span class="line"></span><br><span class="line">reloc_code_end:</span><br><span class="line"></span><br><span class="line">        .align</span><br><span class="line">        .section &quot;.stack&quot;, &quot;aw&quot;, %nobits</span><br><span class="line">.L_user_stack:    .space    4096</span><br><span class="line">.L_user_stack_end:</span><br><span class="line"></span><br><span class="line">  34:  /*</span><br><span class="line">  35:  * 我们可能运行在一个与编译时定义的不同地址上，</span><br><span class="line">  36:  * 所以我们必须修正变量指针</span><br><span class="line">  37:  */</span><br><span class="line">  38:  sub r0, r0, r1 @ 计算偏移量                              编译地址与运行地址的差值，以此来修正其他符号的地址</span><br><span class="line">  39:  add r6, r6, r0 @ 重新计算_edata                          获得_edata的实际运行地址</span><br><span class="line">  40:  add r10, r10, r0 @ 重新获得压缩后的内核大小数据位置      获取Image大小存放的实际物理地址    </span><br><span class="line">  41:  /*</span><br><span class="line">  42:  * 内核编译系统将解压后的内核大小数据</span><br><span class="line">  43:  * 以小端格式</span><br><span class="line">  44:  * 附加在压缩数据的后面(其实是“gzip -f -9”命令的结果)</span><br><span class="line">  45:  * 下面代码的作用是将解压后的内核大小数据正确地放入r9中（避免了大小端问题）</span><br><span class="line">  46:  */</span><br><span class="line">  47:  ldrb r9, [r10, #0]      以我们的例子，此时r9为0x84</span><br><span class="line">  48:  ldrb lr, [r10, #1]                    lr为 0xDA</span><br><span class="line">  49:  orr r9, r9, lr, lsl #8                r9为0xDA84</span><br><span class="line">  50:  ldrb lr, [r10, #2]                    lr为0x67</span><br><span class="line">  51:  ldrb r10, [r10, #3]                   r10是0x00</span><br><span class="line">  52:  orr r9, r9, lr, lsl #16               r9为0x67DA84</span><br><span class="line">  53:  orr r9, r9, r10, lsl #24              r9是0x0067DA84</span><br><span class="line">  54:  /*</span><br><span class="line">  55:  * 下面代码的作用是将正确的当前执行映像的结束地址放入r10</span><br><span class="line">  56:  */</span><br><span class="line">  57:  #ifndef CONFIG_ZBOOT_ROM</span><br><span class="line">  58:  /* malloc 获取的内存空间位于重定向的栈指针之上 (64k max) */</span><br><span class="line">  59:  add sp, sp, r0           使用r0修正sp，得到堆栈的实际结束物理地址，为什么是结束地址？因为栈是向下生长的</span><br><span class="line">  60:  add r10, sp, #0x10000    执行这句之前sp中存放的是栈的结束地址，执行后，r10中存放的是堆空间的结束物理地址</span><br><span class="line">  61:  #else</span><br><span class="line">  62:  /*</span><br><span class="line">  63:  * 如果定义了 ZBOOT_ROM， bss/stack 是非可重定位的,</span><br><span class="line">  64:  * 但有些人依然可以将其放在RAM中运行,</span><br><span class="line">  65:  * 这时我们可以参考 _edata.</span><br><span class="line">  66:  */</span><br><span class="line">  67:  mov r10, r6</span><br><span class="line">  68:  #endif</span><br><span class="line">  69:  /*</span><br><span class="line">  70:  * 检测我们是否会发生自我覆盖的问题</span><br><span class="line">  71:  * r4 = 解压后的内核起始地址（最终执行位置）   在我们的例子中r4就是0x80008000</span><br><span class="line">  72:  * r9 = 解压后内核的大小                       即arch/arm/boot/Image的大小，0x67DA84</span><br><span class="line">  73:  * r10 = 当前执行映像的结束地址, 包含了 bss/stack/malloc 空间（假设是非XIP执行的）, 上面已经分析了r10存放的是堆空间的结束地址</span><br><span class="line">  74:  * 我们的基本需求是:</span><br><span class="line">  75:  * （若最终执行位置r4在当前映像之后）r4 - 16k 页目录 &gt;= r10 -&gt; OK</span><br><span class="line">  76:  * （若最终执行位置r4在当前映像之前）r4 + 解压后的内核大小 &lt;= 当前位置 (pc) -&gt; OK</span><br><span class="line">  77:  *  如果上面的条件不满足，就会自我覆盖，必须先搬运当前映像</span><br><span class="line">  78:  */</span><br><span class="line">  79:  add r10, r10, #16384</span><br><span class="line">  80:  cmp r4, r10         @ 假设最终执行位置r4在当前映像之后</span><br><span class="line">  81:  bhs wont_overwrite</span><br><span class="line">  82:  add r10, r4, r9     @ 假设最终执行位置r4在当前映像之前</span><br><span class="line">  83:  ARM( cmp r10, pc )  @ r10 = 解压后的内核结束地址，注：这里的r4+r9计算出的大小并不包含栈和堆空间</span><br><span class="line">  84:  THUMB( mov lr, pc )</span><br><span class="line">  85:  THUMB( cmp r10, lr )</span><br><span class="line">  86:  bls wont_overwrite</span><br></pre></td></tr></table></figure>

<p><strong>下面是LC0区域的数据内容：</strong></p>
<figure class="highlight text"><table><tr><td class="code"><pre><span class="line">1:          .align    2</span><br><span class="line">  2:          .type    LC0, #object</span><br><span class="line">  3:  LC0:        .word    LC0            @ r1</span><br><span class="line">  4:          .word    __bss_start        @ r2</span><br><span class="line">  5:          .word    _end     @ r3</span><br><span class="line">  6:          .word    _edata             @ r6</span><br><span class="line">  7:          .word    input_data_end - 4    @ r10 (inflated size location)</span><br><span class="line">  8:          .word    _got_start        @ r11</span><br><span class="line">  9:          .word    _got_end    @ ip</span><br><span class="line"> 10:          .word    .L_user_stack_end    @ sp</span><br><span class="line"> 11:          .size    LC0, . - LC0</span><br></pre></td></tr></table></figure>

<p>还记得piggy.gz的结尾四个字节的含义吗？他表示的是arch&#x2F;arm&#x2F;boot&#x2F;Image的大小，在LC0区域中：</p>
<p>.word input_data_end - 4 @ r10 (inflated size location)</p>
<p>的意思：</p>
<p>input_data_end 在piggy.gzip.S中定义：</p>
<figure class="highlight text"><table><tr><td class="code"><pre><span class="line">1:      .section .piggydata,#alloc</span><br><span class="line">2:      .globl    input_data</span><br><span class="line">3:  input_data:</span><br><span class="line">4:      .incbin    &quot;arch/arm/boot/compressed/piggy.gzip&quot;</span><br><span class="line">5:      .globl    input_data_end</span><br><span class="line">6:  input_data_end:</span><br></pre></td></tr></table></figure>

<p>所以，”input_data_end – 4” 表示的是piggy.gz的倒数第四个字节的地址，也是为了便于获得Image的大小。</p>
<p>接着分析head.S:</p>
<figure class="highlight text"><table><tr><td class="code"><pre><span class="line">  1:  /*</span><br><span class="line">  2:  * 将当前的映像重定向到解压后的内核之后（会发生自我覆盖时才执行，否则就被跳过）</span><br><span class="line">  3:  * r6 = _edata（已校正）</span><br><span class="line">  4:  * r10 = 解压后的内核结束地址   对于我的例子: r10就是  0x80008000 + 0x67DA84(arch/arm/boot/Image的大小)</span><br><span class="line">         这样可以保证一次重定位就可以达到预期目标</span><br><span class="line">  5:  * 因为我们要把当前映像向后移动, 所以我们必须由后往前复制代码，</span><br><span class="line">  6:  * 以防原数据和目标数据的重叠</span><br><span class="line">  7:  */</span><br><span class="line">  8:  /*</span><br><span class="line">  9:  * 将解压后的内核结束地址r10扩展（reloc_code_end - restart），</span><br><span class="line"> 10:  * 并对齐到下一个256B边界。</span><br><span class="line"> 11:  * 这样避免了当搬运的偏移较小时的自我覆盖</span><br><span class="line"> 12:  */</span><br><span class="line"> 13:      add r10, r10, #((reloc_code_end - restart + 256) &amp; ~255) </span><br><span class="line"> 14:      bic r10, r10, #255</span><br><span class="line"> 15:  /* 获取需要搬运的当前映像的起始位置r5，并向下做32B对齐. */</span><br><span class="line"> 16:      adr r5, restart</span><br><span class="line"> 17:      bic r5, r5, #31</span><br><span class="line"> 18:      sub r9, r6, r5  @ _edata - restart（已向下对齐）= 需要搬运的大小</span><br><span class="line"> 19:      add r9, r9, #31</span><br><span class="line"> 20:      bic r9, r9, #31 @ 做32B对齐 ，r9 = 需要搬运的大小</span><br><span class="line"> 21:      add r6, r9, r5  @ r6 = 当前映像需要搬运的结束地址，由于r5和r9都已经对齐，所以r6也对齐了。</span><br><span class="line">         /* 上面对齐以后，有利于后面的代码拷贝，而且对齐的同时又保证了拷贝代码的完整性，至少没有少拷贝代码*/</span><br><span class="line"> 22:      add r9, r9, r10 @ r9 = 当前映像搬运的目的地的结束地址</span><br><span class="line"> 23:  /* 搬运当前执行映像，不包含 bss/stack/malloc 空间*/</span><br><span class="line"> 24:      1: ldmdb r6!, &#123;r0 - r3, r10 - r12, lr&#125;</span><br><span class="line"> 25:      cmp r6, r5</span><br><span class="line"> 26:      stmdb r9!, &#123;r0 - r3, r10 - r12, lr&#125;</span><br><span class="line"> 27:      bhi 1b</span><br><span class="line"> 28:  /* 保存偏移量，用来修改sp和实现代码跳转 */</span><br><span class="line"> 29:      sub r6, r9, r6            求要搬移的代码的原始地址与目的地址的偏移量</span><br><span class="line"> 30:      #ifndef CONFIG_ZBOOT_ROM</span><br><span class="line"> 31:  /* cache_clean_flush 可能会使用栈，所以重定向sp指针 */</span><br><span class="line"> 32:      add sp, sp, r6            修正sp地址，修正后sp指向重定向后的代码的栈区的结束地址（栈向下生长），栈区后面紧跟的就是堆空间</span><br><span class="line"> 33:      #endif</span><br><span class="line"> 34:      bl cache_clean_flush @ 刷新缓存</span><br><span class="line"> 35:  /* 通过搬运的偏移和当前的实际 restart 地址来实现代码跳转*/</span><br><span class="line"> 36:      adr r0, BSYM(restart)    获得restart的运行地址</span><br><span class="line"> 37:      add r0, r0, r6           获得重定向后的代码的restart的物理地址</span><br><span class="line"> 38:      mov pc, r0               跳到重定向后的代码的restart处开始执行</span><br><span class="line"> 39:  /* 在上面的跳转之后，程序又从restart开始。</span><br><span class="line"> 40:  * 但这次在检查自我覆盖的时候，新的执行位置必然满足</span><br><span class="line"> 41:  * 最终执行位置r4在当前映像之前，r4 + 压缩后的内核大小 &lt;= 当前位置 (pc)</span><br><span class="line"> 42:  * 所以必然直接跳到了下面的wont_overwrite执行</span><br><span class="line"> 43:  */</span><br><span class="line"> 44:  wont_overwrite:</span><br><span class="line"> 45:  /*</span><br><span class="line"> 46:  * 如果delta（当前映像地址与编译时的地址偏移）为0, 我们运行的地址就是编译时确定的地址.</span><br><span class="line"> 47:  * r0 = delta</span><br><span class="line"> 48:  * r2 = BSS start（编译值）</span><br><span class="line"> 49:  * r3 = BSS end（编译值）</span><br><span class="line"> 50:  * r4 = 内核最终运行的物理地址</span><br><span class="line"> 51:  * r7 = 构架ID(bootlodaer传递值)</span><br><span class="line"> 52:  * r8 = 内核启动参数指针(bootlodaer传递值)</span><br><span class="line"> 53:  * r11 = GOT start（编译值）</span><br><span class="line"> 54:  * r12 = GOT end（编译值）</span><br><span class="line"> 55:  * sp = stack pointer（修正值）</span><br><span class="line"> 56:  */</span><br><span class="line"> 57:      teq r0, #0 @测试delta值</span><br><span class="line"> 58:      beq not_relocated @如果delta为0，无须对GOT表项和BSS进行重定位</span><br><span class="line"> 59:      add r11, r11, r0 @重定位GOT start</span><br><span class="line"> 60:      add r12, r12, r0 @重定位GOT end</span><br><span class="line"> 61:      #ifndef CONFIG_ZBOOT_ROM</span><br><span class="line"> 62:  /*</span><br><span class="line"> 63:  * 如果内核配置 CONFIG_ZBOOT_ROM = n,</span><br><span class="line"> 64:  * 我们必须修正BSS段的指针</span><br><span class="line"> 65:  * 注意：sp已经被修正</span><br><span class="line"> 66:  */</span><br><span class="line"> 67:      add r2, r2, r0 @重定位BSS start</span><br><span class="line"> 68:      add r3, r3, r0 @重定位BSS end</span><br><span class="line"> 69:  /*    </span><br><span class="line"> 70:  * 重定位所有GOT表的入口项</span><br><span class="line"> 71:  */</span><br><span class="line"> 72:      1: ldr r1, [r11, #0] @ 重定位GOT表的入口项</span><br><span class="line"> 73:      add r1, r1, r0 @ 这个修正了 C 引用</span><br><span class="line"> 74:      str r1, [r11], #4</span><br><span class="line"> 75:      cmp r11, r12</span><br><span class="line"> 76:      blo 1b</span><br><span class="line"> 77:      #else</span><br><span class="line"> 78:  /*</span><br><span class="line"> 79:  * 重定位所有GOT表的入口项.</span><br><span class="line"> 80:  * 我们只重定向在（已重定向后）BSS段外的入口</span><br><span class="line"> 81:  */</span><br><span class="line"> 82:      1: ldr r1, [r11, #0] @ 重定位GOT表的入口项</span><br><span class="line"> 83:      cmp r1, r2 @ entry &lt; bss_start ||</span><br><span class="line"> 84:      cmphs r3, r1 @ _end &lt; entry table</span><br><span class="line"> 85:      addlo r1, r1, r0 @ 这个修正了 C 引用</span><br><span class="line"> 86:      str r1, [r11], #4</span><br><span class="line"> 87:      cmp r11, r12</span><br><span class="line"> 88:      blo 1b</span><br><span class="line"> 89:      #endif</span><br><span class="line"> 90:  /*</span><br><span class="line"> 91:  * 至此当前映像的搬运和调整已经完成</span><br><span class="line"> 92:  * 可以开始真正的工作的</span><br><span class="line"> 93:  */</span><br><span class="line"> 94:      not_relocated: mov r0, #0</span><br><span class="line"> 95:      1: str r0, [r2], #4 @ 清零 bss（初始化BSS段）</span><br><span class="line"> 96:      str r0, [r2], #4</span><br><span class="line"> 97:      str r0, [r2], #4</span><br><span class="line"> 98:      str r0, [r2], #4</span><br><span class="line"> 99:      cmp r2, r3</span><br><span class="line">100:      blo 1b</span><br><span class="line">101:  /*</span><br><span class="line">102:  * C运行时环境已经充分建立.</span><br><span class="line">103:  * 设置一些指针就可以解压内核了.</span><br><span class="line">104:  * r4 = 内核最终运行的物理地址</span><br><span class="line">105:  * r7 = 构架ID</span><br><span class="line">106:  * r8 = 内核启动参数指针</span><br><span class="line">107:  *</span><br><span class="line">108:  * 下面对r0～r3的配置是decompress_kernel函数对应参数</span><br><span class="line">109:  * r0 = 解压后的输出位置首地址</span><br><span class="line">110:  * r1 = 可用RAM空间首地址  即堆空间的起始地址</span><br><span class="line">111:  * r2 = 可用RAM空间结束地址  即堆空间的结束地址</span><br><span class="line">112:  * r3 = 构架ID</span><br><span class="line">113:  * 就是这个decompress_kernel（C函数）输出了&quot;Uncompressing Linux...&quot;</span><br><span class="line">114:  * 以及&quot; done, booting the kernel.\n&quot;</span><br><span class="line">115:  */</span><br><span class="line">116:      mov r0, r4</span><br><span class="line">117:      mov r1, sp @ malloc 获取的内存空间位于栈指针之上</span><br><span class="line">118:      add r2, sp, #0x10000 @ 64k max</span><br><span class="line">119:      mov r3, r7</span><br><span class="line">120:      bl decompress_kernel</span><br><span class="line">121:  /*</span><br><span class="line">122:  * decompress_kernel(misc.c)--调用--&gt;</span><br><span class="line">123:  * do_decompress(decompress.c)--调用--&gt;</span><br><span class="line">124:  * decompress(../../../../lib/decompress_xxxx.c根据压缩方式的配置而不同)</span><br><span class="line">125:  */</span><br><span class="line">126:  /*</span><br><span class="line">127:  * 以下是为跳入解压后的内核，再次做准备（恢复解压前的状态）</span><br><span class="line">128:  */</span><br><span class="line">129:      bl cache_clean_flush</span><br><span class="line">130:      bl cache_off@ 数据缓存必须关闭（内核的要求）</span><br><span class="line">131:      mov r0, #0 @ r0必须为0</span><br><span class="line">132:      mov r1, r7@ 恢复构架ID到r1</span><br><span class="line">133:      mov r2, r8 @ 恢复内核启动参数指针到r2</span><br><span class="line">134:      mov pc, r4 @ 跳入解压后的内核映像(Image)入口（arch/arm/kernel/head.S）</span><br></pre></td></tr></table></figure>

<p>下面简要看一下解压缩程序的调用过程：</p>
<h2 id="3、arch-arm-boot-compressed-misc-c"><a href="#3、arch-arm-boot-compressed-misc-c" class="headerlink" title="3、arch&#x2F;arm&#x2F;boot&#x2F;compressed&#x2F;misc.c"></a>3、<strong>arch&#x2F;arm&#x2F;boot&#x2F;compressed&#x2F;misc.c</strong></h2><figure class="highlight text"><table><tr><td class="code"><pre><span class="line">1:  void</span><br><span class="line">  2:  decompress_kernel(unsigned long output_start, unsigned long free_mem_ptr_p,</span><br><span class="line">  3:          unsigned long free_mem_ptr_end_p,</span><br><span class="line">  4:          int arch_id)</span><br><span class="line">  5:  &#123;</span><br><span class="line">  6:      int ret;</span><br><span class="line">  7:   </span><br><span class="line">  8:      output_data        = (unsigned char *)output_start;    /*解压地址*/</span><br><span class="line">  9:      free_mem_ptr        = free_mem_ptr_p;               /*堆栈起始地址*/</span><br><span class="line"> 10:      free_mem_end_ptr    = free_mem_ptr_end_p;           /*堆栈结束地址*/</span><br><span class="line"> 11:      __machine_arch_type    = arch_id;                      /*uboot传入的machid*/</span><br><span class="line"> 12:   </span><br><span class="line"> 13:      arch_decomp_setup();</span><br><span class="line"> 14:   </span><br><span class="line"> 15:      putstr(&quot;Uncompressing Linux...&quot;);</span><br><span class="line"> 16:      ret = do_decompress(input_data, input_data_end - input_data,</span><br><span class="line"> 17:                  output_data, error);</span><br><span class="line"> 18:      if (ret)</span><br><span class="line"> 19:          error(&quot;decompressor returned an error&quot;);</span><br><span class="line"> 20:      else</span><br><span class="line"> 21:          putstr(&quot; done, booting the kernel.\n&quot;);</span><br><span class="line"> 22:  &#125;</span><br></pre></td></tr></table></figure>

<p><strong>arch&#x2F;arm&#x2F;boot&#x2F;compressed&#x2F;decompressed.c</strong></p>
<figure class="highlight text"><table><tr><td class="code"><pre><span class="line"> 1:  #  define Tracec(c,x)</span><br><span class="line">   2:  #  define Tracecv(c,x)</span><br><span class="line">   3:  #endif</span><br><span class="line">   4:   </span><br><span class="line">   5:  #ifdef CONFIG_KERNEL_GZIP</span><br><span class="line">   6:  #include &quot;../../../../lib/decompress_inflate.c&quot;</span><br><span class="line">   7:  #endif</span><br><span class="line">   8:   </span><br><span class="line">   9:  #ifdef CONFIG_KERNEL_LZO</span><br><span class="line">  10:  #include &quot;../../../../lib/decompress_unlzo.c&quot;</span><br><span class="line">  11:  #endif</span><br><span class="line">  12:   </span><br><span class="line">  13:  #ifdef CONFIG_KERNEL_LZMA</span><br><span class="line">  14:  #include &quot;../../../../lib/decompress_unlzma.c&quot;</span><br><span class="line">  15:  #endif</span><br><span class="line">  16:   </span><br><span class="line">  17:  int </span><br><span class="line">do_decompress</span><br><span class="line">(u8 *input, int len, u8 *output, void (*error)(char *x))</span><br><span class="line">  18:  &#123;</span><br><span class="line">  19:      return </span><br><span class="line">decompress</span><br><span class="line">(input, len, NULL, NULL, output, NULL, error);</span><br><span class="line">  20:  &#125;</span><br></pre></td></tr></table></figure>

<p><strong>lib&#x2F;decompress_inflate.c</strong></p>
<figure class="highlight text"><table><tr><td class="code"><pre><span class="line">1:  #ifdef STATIC</span><br><span class="line">  2:  /* Pre-boot environment: included */</span><br><span class="line">  3:   </span><br><span class="line">  4:  /* prevent inclusion of _LINUX_KERNEL_H in pre-boot environment: lots</span><br><span class="line">  5:   * errors about console_printk etc... on ARM */</span><br><span class="line">  6:  #define _LINUX_KERNEL_H</span><br><span class="line">  7:   </span><br><span class="line">  8:  #include &quot;zlib_inflate/inftrees.c&quot;</span><br><span class="line">  9:  #include &quot;zlib_inflate/inffast.c&quot;</span><br><span class="line"> 10:  #include &quot;zlib_inflate/inflate.c&quot;</span><br><span class="line"> 11:   </span><br><span class="line"> 12:  #else /* STATIC */</span><br><span class="line"> 13:  /* initramfs et al: linked */</span><br><span class="line"> 14:   </span><br><span class="line"> 15:  #include &lt;linux/zutil.h&gt;</span><br><span class="line"> 16:   </span><br><span class="line"> 17:  #include &quot;zlib_inflate/inftrees.h&quot;</span><br><span class="line"> 18:  #include &quot;zlib_inflate/inffast.h&quot;</span><br><span class="line"> 19:  #include &quot;zlib_inflate/inflate.h&quot;</span><br><span class="line"> 20:   </span><br><span class="line"> 21:  #include &quot;zlib_inflate/infutil.h&quot;</span><br><span class="line"> 22:   </span><br><span class="line"> 23:  #endif /* STATIC */</span><br><span class="line"> 24:   </span><br><span class="line"> 25:  #include &lt;linux/decompress/mm.h&gt;</span><br><span class="line"> 26:   </span><br><span class="line"> 27:  #define GZIP_IOBUF_SIZE (16*1024)</span><br><span class="line"> 28:   </span><br><span class="line"> 29:  static int INIT nofill(void *buffer, unsigned int len)</span><br><span class="line"> 30:  &#123;</span><br><span class="line"> 31:      return -1;</span><br><span class="line"> 32:  &#125;</span><br><span class="line"> 33:   </span><br><span class="line"> 34:  /* Included from initramfs et al code */</span><br><span class="line"> 35:  STATIC int INIT gunzip(unsigned char *buf, int len,</span><br><span class="line"> 36:                 int(*fill)(void*, unsigned int),</span><br><span class="line"> 37:                 int(*flush)(void*, unsigned int),</span><br><span class="line"> 38:                 unsigned char *out_buf,</span><br><span class="line"> 39:                 int *pos,</span><br><span class="line"> 40:                 void(*error)(char *x)) &#123;</span><br><span class="line"> 41:      u8 *zbuf;</span><br><span class="line"> 42:      struct z_stream_s *strm;</span><br><span class="line"> 43:      int rc;</span><br><span class="line"> 44:      size_t out_len;</span><br><span class="line"> 45:   </span><br><span class="line"> 46:      rc = -1;</span><br><span class="line"> 47:      if (flush) &#123;</span><br><span class="line"> 48:          out_len = 0x8000; /* 32 K */</span><br><span class="line"> 49:          out_buf = malloc(out_len);</span><br><span class="line"> 50:      &#125; else &#123;</span><br><span class="line"> 51:          out_len = 0x7fffffff; /* no limit */</span><br><span class="line"> 52:      &#125;</span><br><span class="line"> 53:      if (!out_buf) &#123;</span><br><span class="line"> 54:          error(&quot;Out of memory while allocating output buffer&quot;);</span><br><span class="line"> 55:          goto gunzip_nomem1;</span><br><span class="line"> 56:      &#125;</span><br><span class="line"> 57:   </span><br><span class="line"> 58:      if (buf)</span><br><span class="line"> 59:          zbuf = buf;</span><br><span class="line"> 60:      else &#123;</span><br><span class="line"> 61:          zbuf = malloc(GZIP_IOBUF_SIZE);</span><br><span class="line"> 62:          len = 0;</span><br><span class="line"> 63:      &#125;</span><br><span class="line"> 64:      if (!zbuf) &#123;</span><br><span class="line"> 65:          error(&quot;Out of memory while allocating input buffer&quot;);</span><br><span class="line"> 66:          goto gunzip_nomem2;</span><br><span class="line"> 67:      &#125;</span><br><span class="line"> 68:   </span><br><span class="line"> 69:      strm = malloc(sizeof(*strm));</span><br><span class="line"> 70:      if (strm == NULL) &#123;</span><br><span class="line"> 71:          error(&quot;Out of memory while allocating z_stream&quot;);</span><br><span class="line"> 72:          goto gunzip_nomem3;</span><br><span class="line"> 73:      &#125;</span><br><span class="line"> 74:   </span><br><span class="line"> 75:      strm-&gt;workspace = malloc(flush ? zlib_inflate_workspacesize() :</span><br><span class="line"> 76:                   sizeof(struct inflate_state));</span><br><span class="line"> 77:      if (strm-&gt;workspace == NULL) &#123;</span><br><span class="line"> 78:          error(&quot;Out of memory while allocating workspace&quot;);</span><br><span class="line"> 79:          goto gunzip_nomem4;</span><br><span class="line"> 80:      &#125;</span><br><span class="line"> 81:   </span><br><span class="line"> 82:      if (!fill)</span><br><span class="line"> 83:          fill = nofill;</span><br><span class="line"> 84:   </span><br><span class="line"> 85:      if (len == 0)</span><br><span class="line"> 86:          len = fill(zbuf, GZIP_IOBUF_SIZE);</span><br><span class="line"> 87:   </span><br><span class="line"> 88:      /* verify the gzip header */</span><br><span class="line"> 89:      if (len &lt; 10 ||</span><br><span class="line"> 90:         zbuf[0] != 0x1f || zbuf[1] != 0x8b || zbuf[2] != 0x08) &#123;</span><br><span class="line"> 91:          if (pos)</span><br><span class="line"> 92:              *pos = 0;</span><br><span class="line"> 93:          error(&quot;Not a gzip file&quot;);</span><br><span class="line"> 94:          goto gunzip_5;</span><br><span class="line"> 95:      &#125;</span><br><span class="line"> 96:   </span><br><span class="line"> 97:      /* skip over gzip header (1f,8b,08... 10 bytes total +</span><br><span class="line"> 98:       * possible asciz filename)</span><br><span class="line"> 99:       */</span><br><span class="line">100:      strm-&gt;next_in = zbuf + 10;</span><br><span class="line">101:      strm-&gt;avail_in = len - 10;</span><br><span class="line">102:      /* skip over asciz filename */</span><br><span class="line">103:      if (zbuf[3] &amp; 0x8) &#123;</span><br><span class="line">104:          do &#123;</span><br><span class="line">105:              /*</span><br><span class="line">106:               * If the filename doesn&#x27;t fit into the buffer,</span><br><span class="line">107:               * the file is very probably corrupt. Don&#x27;t try</span><br><span class="line">108:               * to read more data.</span><br><span class="line">109:               */</span><br><span class="line">110:              if (strm-&gt;avail_in == 0) &#123;</span><br><span class="line">111:                  error(&quot;header error&quot;);</span><br><span class="line">112:                  goto gunzip_5;</span><br><span class="line">113:              &#125;</span><br><span class="line">114:              --strm-&gt;avail_in;</span><br><span class="line">115:          &#125; while (*strm-&gt;next_in++);</span><br><span class="line">116:      &#125;</span><br><span class="line">117:   </span><br><span class="line">118:      strm-&gt;next_out = out_buf;</span><br><span class="line">119:      strm-&gt;avail_out = out_len;</span><br><span class="line">120:   </span><br><span class="line">121:      rc = zlib_inflateInit2(strm, -MAX_WBITS);</span><br><span class="line">122:   </span><br><span class="line">123:      if (!flush) &#123;</span><br><span class="line">124:          WS(strm)-&gt;inflate_state.wsize = 0;</span><br><span class="line">125:          WS(strm)-&gt;inflate_state.window = NULL;</span><br><span class="line">126:      &#125;</span><br><span class="line">127:   </span><br><span class="line">128:      while (rc == Z_OK) &#123;</span><br><span class="line">129:          if (strm-&gt;avail_in == 0) &#123;</span><br><span class="line">130:              /* TODO: handle case where both pos and fill are set */</span><br><span class="line">131:              len = fill(zbuf, GZIP_IOBUF_SIZE);</span><br><span class="line">132:              if (len &lt; 0) &#123;</span><br><span class="line">133:                  rc = -1;</span><br><span class="line">134:                  error(&quot;read error&quot;);</span><br><span class="line">135:                  break;</span><br><span class="line">136:              &#125;</span><br><span class="line">137:              strm-&gt;next_in = zbuf;</span><br><span class="line">138:              strm-&gt;avail_in = len;</span><br><span class="line">139:          &#125;</span><br><span class="line">140:          rc = zlib_inflate(strm, 0);</span><br><span class="line">141:   </span><br><span class="line">142:          /* Write any data generated */</span><br><span class="line">143:          if (flush &amp;&amp; strm-&gt;next_out &gt; out_buf) &#123;</span><br><span class="line">144:              int l = strm-&gt;next_out - out_buf;</span><br><span class="line">145:              if (l != flush(out_buf, l)) &#123;</span><br><span class="line">146:                  rc = -1;</span><br><span class="line">147:                  error(&quot;write error&quot;);</span><br><span class="line">148:                  break;</span><br><span class="line">149:              &#125;</span><br><span class="line">150:              strm-&gt;next_out = out_buf;</span><br><span class="line">151:              strm-&gt;avail_out = out_len;</span><br><span class="line">152:          &#125;</span><br><span class="line">153:   </span><br><span class="line">154:          /* after Z_FINISH, only Z_STREAM_END is &quot;we unpacked it all&quot; */</span><br><span class="line">155:          if (rc == Z_STREAM_END) &#123;</span><br><span class="line">156:              rc = 0;</span><br><span class="line">157:              break;</span><br><span class="line">158:          &#125; else if (rc != Z_OK) &#123;</span><br><span class="line">159:              error(&quot;uncompression error&quot;);</span><br><span class="line">160:              rc = -1;</span><br><span class="line">161:          &#125;</span><br><span class="line">162:      &#125;</span><br><span class="line">163:   </span><br><span class="line">164:      zlib_inflateEnd(strm);</span><br><span class="line">165:      if (pos)</span><br><span class="line">166:          /* add + 8 to skip over trailer */</span><br><span class="line">167:          *pos = strm-&gt;next_in - zbuf+8;</span><br><span class="line">168:   </span><br><span class="line">169:  gunzip_5:</span><br><span class="line">170:      free(strm-&gt;workspace);</span><br><span class="line">171:  gunzip_nomem4:</span><br><span class="line">172:      free(strm);</span><br><span class="line">173:  gunzip_nomem3:</span><br><span class="line">174:      if (!buf)</span><br><span class="line">175:          free(zbuf);</span><br><span class="line">176:  gunzip_nomem2:</span><br><span class="line">177:      if (flush)</span><br><span class="line">178:          free(out_buf);</span><br><span class="line">179:  gunzip_nomem1:</span><br><span class="line">180:      return rc; /* returns Z_OK (0) if successful */</span><br><span class="line">181:  &#125;</span><br><span class="line">182:   </span><br><span class="line">183:  #define decompress gunzip</span><br></pre></td></tr></table></figure>

<p>为了便于理解，可以参考下面一张图：</p>
<p><img src="https://pic1.zhimg.com/80/v2-ae8dd36b0679b027dd0cf237541655fc_720w.webp" alt="img"></p>
<hr>
<p>版权声明：本文为知乎博主「<a href="https://www.zhihu.com/people/linuxwang-xian-sheng">极致Linux内核</a>」的原创文章，遵循CC 4.0 BY-SA版权协议，转载请附上原文出处链接及本声明。</p>
<p>原文链接：<a href="https://zhuanlan.zhihu.com/p/548745216">https://zhuanlan.zhihu.com/p/548745216</a></p>
]]></content>
      <categories>
        <category>linux-doc 设备驱动</category>
      </categories>
      <tags>
        <tag>Linux</tag>
      </tags>
  </entry>
  <entry>
    <title>Linux内核字符设备Character Device</title>
    <url>/2023/01/15/linux-docs/%E8%AE%BE%E5%A4%87%E9%A9%B1%E5%8A%A8/Linux%E5%86%85%E6%A0%B8%E5%AD%97%E7%AC%A6%E8%AE%BE%E5%A4%87Character%20Device/</url>
    <content><![CDATA[<h2 id="1、前言"><a href="#1、前言" class="headerlink" title="1、前言"></a>1、前言</h2><p>上文中我们分析了虚拟文件系统的结构以及常见的文件操作从用户态到虚拟文件系统再到底层实际文件系统的过程。而实际上我们并没有说明实际的文件系统如ext4是如何和磁盘进行交互的，这就是本文和下篇文章的重点：I&#x2F;O之块设备和字符设备。输入输出设备我们大致可以分为两类：块设备（Block Device）和字符设备（Character Device）。</p>
<ul>
<li>块设备将信息存储在固定大小的块中，每个块都有自己的地址。如硬盘就是常见的块设备。</li>
<li>字符设备发送或接收的是字节流，而不用考虑任何块结构，没有办法寻址。如鼠标就是常见的字符设备。</li>
</ul>
<p>本文首先介绍虚拟文件系统下层直至硬件输入输出设备的结构关系，然后重点分析字符设备相关的整体逻辑情况。</p>
<h2 id="2、-I-O架构"><a href="#2、-I-O架构" class="headerlink" title="2、 I&#x2F;O架构"></a>2、 I&#x2F;O架构</h2><p>由于各种输入输出设备具有不同的硬件结构、驱动程序，因此我们采取了设备控制器这一中间层对上提供统一接口。设备控制器通过缓存来处理CPU和硬件I&#x2F;O之间的交互关系，通过中断进行通知，因此我们需要有中断处理器对各种中断进行统一。由于每种设备的控制器的寄存器、缓冲区等使用模式，指令都不同，所以对于操作系统还需要一层对接各个设备控制器的设备驱动程序。</p>
<p>这里需要注意的是，设备控制器不属于操作系统的一部分，但是设备驱动程序属于操作系统的一部分。操作系统的内核代码可以像调用本地代码一样调用驱动程序的代码，而驱动程序的代码需要发出特殊的面向设备控制器的指令，才能操作设备控制器。设备驱动程序中是一些面向特殊设备控制器的代码，不同的设备不同。但是对于操作系统其它部分的代码而言，设备驱动程序有统一的接口。</p>
<p><img src="https://pic3.zhimg.com/80/v2-52f763375b79876fbd4e38121d185d9a_720w.webp" alt="img"></p>
<p>设备驱动本身作为一个内核模块，通常以ko文件的形式存在，它有着其独特的代码结构：</p>
<ul>
<li>头文件部分,设备驱动程序至少需要以下头文件</li>
</ul>
<figure class="highlight text"><table><tr><td class="code"><pre><span class="line">#include &lt;linux/module.h&gt;</span><br><span class="line">#include &lt;linux/init.h&gt;</span><br></pre></td></tr></table></figure>

<ul>
<li>调用MODULE_LICENSE声明lisence</li>
<li>初始化函数module_init和退出函数module_exit的定义，用于加载和卸载ko文件</li>
<li>文件系统的接口file_operation结构体定义</li>
<li>定义需要的函数</li>
</ul>
<p>在下文的分析中，我们就将按照此顺序来剖析字符设备的源码，以弄懂字符设备的一般运行逻辑。关于设备驱动代码编写的详细知识可以参考《Linux设备驱动》一书，本文重点不在于如何编写代码，而是在于操作系统中的字符设备和块设备如何工作。</p>
<h2 id="3、字符设备基本构成"><a href="#3、字符设备基本构成" class="headerlink" title="3、字符设备基本构成"></a>3、字符设备基本构成</h2><p><strong>一个字符设备由3个部分组成：</strong></p>
<ul>
<li>封装对于外部设备的操作的设备驱动程序，即 ko 文件模块，里面有模块初始化函数、中断处理函数、设备操作函数等。加载设备驱动程序模块的时候，模块初始化函数会被调用。在内核维护所有字符设备驱动的数据结构 cdev_map 里面注册设备号后，我们就可以很容易根据设备号找到相应的设备驱动程序。</li>
<li>特殊的设备驱动文件系统 devtmpfs，在&#x2F;dev 目录下生成一个文件表示这个设备。打开一个字符设备文件和打开一个普通的文件有类似的数据结构，有文件描述符、有 struct file、指向字符设备文件的 dentry 和 inode。其对应的 inode 是一个特殊的 inode，里面有设备号。通过它我们可以在 cdev_map 中找到设备驱动程序，里面还有针对字符设备文件的默认操作 def_chr_fops。</li>
<li>字符设备文件的相关操作 file_operations 。一开始会指向 def_chr_fops，在调用 def_chr_fops 里面的 chrdev_open 函数的时候修改为指向设备操作函数，从而读写一个字符设备文件就会直接变成读写外部设备了。 这里主要涉及到了两个结构体：字符设备信息存储的struct cdev以及管理字符设备的cdev_map。</li>
</ul>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">struct</span> <span class="title class_">cdev</span> &#123;</span><br><span class="line">    <span class="keyword">struct</span> <span class="title class_">kobject</span> kobj;                  <span class="comment">//内嵌的内核对象.</span></span><br><span class="line">    <span class="keyword">struct</span> <span class="title class_">module</span> *owner;                 <span class="comment">//该字符设备所在的内核模块的对象指针.</span></span><br><span class="line">    <span class="type">const</span> <span class="keyword">struct</span> <span class="title class_">file_operations</span> *ops;    <span class="comment">//该结构描述了字符设备所能实现的方法，是极为关键的一个结构体.</span></span><br><span class="line">    <span class="keyword">struct</span> <span class="title class_">list_head</span> list;                <span class="comment">//用来将已经向内核注册的所有字符设备形成链表.</span></span><br><span class="line">    <span class="type">dev_t</span> dev;                            <span class="comment">//字符设备的设备号，由主设备号和次设备号构成.</span></span><br><span class="line">    <span class="type">unsigned</span> <span class="type">int</span> count;                   <span class="comment">//隶属于同一主设备号的次设备号的个数.</span></span><br><span class="line">&#125; __randomize_layout;</span><br></pre></td></tr></table></figure>

<p>cdev结构体还有另一个相关联的结构体char_device_struct。这里首先会定义主设备号和次设备号：主设备号用来标识与设备文件相连的驱动程序，用来反映设备类型。次设备号被驱动程序用来辨别操作的是哪个设备，用来区分同类型的设备。这里minorct指的是分配的区域，用于主设备号和次设备号的分配工作。</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="type">static</span> <span class="keyword">struct</span> <span class="title class_">char_device_struct</span> &#123;</span><br><span class="line">    <span class="keyword">struct</span> <span class="title class_">char_device_struct</span> *next;</span><br><span class="line">    <span class="type">unsigned</span> <span class="type">int</span> major;</span><br><span class="line">    <span class="type">unsigned</span> <span class="type">int</span> baseminor;</span><br><span class="line">    <span class="type">int</span> minorct;</span><br><span class="line">    <span class="type">char</span> name[<span class="number">64</span>];</span><br><span class="line">    <span class="keyword">struct</span> <span class="title class_">cdev</span> *cdev;		<span class="comment">/* will die */</span></span><br><span class="line">&#125; *chrdevs[CHRDEV_MAJOR_HASH_SIZE];</span><br></pre></td></tr></table></figure>

<p>cdev_map用于维护所有字符设备驱动，实际是结构体kobj_map，主要包括了一个互斥锁lock，一个probes[255]数组，数组元素为struct probe的指针，该结构体包括链表项、设备号、设备号范围等。所以我们将字符设备驱动最后保存为一个probe，并用cdev_map&#x2F;kobj_map进行统一管理。</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="type">static</span> <span class="keyword">struct</span> <span class="title class_">kobj_map</span> *cdev_map;</span><br><span class="line"></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">kobj_map</span> &#123;</span><br><span class="line">    <span class="keyword">struct</span> <span class="title class_">probe</span> &#123;</span><br><span class="line">        <span class="keyword">struct</span> <span class="title class_">probe</span> *next;</span><br><span class="line">        <span class="type">dev_t</span> dev;</span><br><span class="line">        <span class="type">unsigned</span> <span class="type">long</span> range;</span><br><span class="line">        <span class="keyword">struct</span> <span class="title class_">module</span> *owner;</span><br><span class="line">        <span class="type">kobj_probe_t</span> *get;</span><br><span class="line">        <span class="built_in">int</span> (*lock)(<span class="type">dev_t</span>, <span class="type">void</span> *);</span><br><span class="line">        <span class="type">void</span> *data;</span><br><span class="line">    &#125; *probes[<span class="number">255</span>];</span><br><span class="line">    <span class="keyword">struct</span> <span class="title class_">mutex</span> *lock;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h2 id="4、打开字符设备"><a href="#4、打开字符设备" class="headerlink" title="4、打开字符设备"></a>4、打开字符设备</h2><p>字符设备有很多种，这里以打印机设备为输出设备的例子，源码位于drivers&#x2F;char&#x2F;lp.c。以鼠标为输入设备的例子，源码位于drivers&#x2F;input&#x2F;mouse&#x2F;logibm.c。下面将根据上述的字符设备的三个组成部分分别剖析如何创建并打开字符设备。</p>
<h3 id="4-1-加载"><a href="#4-1-加载" class="headerlink" title="4.1 加载"></a>4.1 加载</h3><p>字符设备的使用从加载开始，通常我们会使用insmod命令或者modprobe命令加载ko文件，ko文件的加载则从module_init调用该设备自定义的初始函数开始。对于打印机来说，其初始化函数定义为lp_init_module()，实际调用lp_init()。lp_init()会初始化打印机结构体，并调用register_chardev()注册该字符设备。</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="built_in">module_init</span>(lp_init_module);</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">static</span> <span class="type">int</span> __init <span class="title">lp_init_module</span><span class="params">(<span class="type">void</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">......</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">lp_init</span>();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">static</span> <span class="type">int</span> __init <span class="title">lp_init</span><span class="params">(<span class="type">void</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">......</span><br><span class="line">    <span class="keyword">if</span> (<span class="built_in">register_chrdev</span>(LP_MAJOR, <span class="string">&quot;lp&quot;</span>, &amp;lp_fops)) &#123;</span><br><span class="line">        <span class="built_in">printk</span>(KERN_ERR <span class="string">&quot;lp: unable to get major %d\n&quot;</span>, LP_MAJOR);</span><br><span class="line">        <span class="keyword">return</span> -EIO;</span><br><span class="line">    &#125;</span><br><span class="line">......</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>register_chrdev()实际调用__register_chrdev()，该函数会进行字符设备的注册操作。其主要逻辑如下</p>
<ul>
<li>调用__register_chrdev_region()注册字符设备的主设备号和名称</li>
<li>调用cdev_alloc()分配结构体struct cdev</li>
<li>将 cdev 的 ops 成员变量指向这个模块声明的 file_operations</li>
<li>调用cdev_add()将这个字符设备添加到结构体 struct kobj_map *cdev_map ，该结构体用于统一管理所有字符设备。</li>
</ul>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">static</span> <span class="keyword">inline</span> <span class="type">int</span> <span class="title">register_chrdev</span><span class="params">(<span class="type">unsigned</span> <span class="type">int</span> major, <span class="type">const</span> <span class="type">char</span> *name,</span></span></span><br><span class="line"><span class="params"><span class="function">                  <span class="type">const</span> <span class="keyword">struct</span> file_operations *fops)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> __register_chrdev(major, <span class="number">0</span>, <span class="number">256</span>, name, fops);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> __register_chrdev(<span class="type">unsigned</span> <span class="type">int</span> major, <span class="type">unsigned</span> <span class="type">int</span> baseminor,</span><br><span class="line">              <span class="type">unsigned</span> <span class="type">int</span> count, <span class="type">const</span> <span class="type">char</span> *name,</span><br><span class="line">              <span class="type">const</span> <span class="keyword">struct</span> file_operations *fops)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">struct</span> <span class="title class_">char_device_struct</span> *cd;</span><br><span class="line">    <span class="keyword">struct</span> <span class="title class_">cdev</span> *cdev;</span><br><span class="line">    <span class="type">int</span> err = -ENOMEM;</span><br><span class="line">    cd = __register_chrdev_region(major, baseminor, count, name);</span><br><span class="line">    <span class="keyword">if</span> (<span class="built_in">IS_ERR</span>(cd))</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">PTR_ERR</span>(cd);</span><br><span class="line">    cdev = <span class="built_in">cdev_alloc</span>();</span><br><span class="line">    <span class="keyword">if</span> (!cdev)</span><br><span class="line">        <span class="keyword">goto</span> out2;</span><br><span class="line">    cdev-&gt;owner = fops-&gt;owner;</span><br><span class="line">    cdev-&gt;ops = fops;</span><br><span class="line">    <span class="built_in">kobject_set_name</span>(&amp;cdev-&gt;kobj, <span class="string">&quot;%s&quot;</span>, name);</span><br><span class="line">    err = <span class="built_in">cdev_add</span>(cdev, <span class="built_in">MKDEV</span>(cd-&gt;major, baseminor), count);</span><br><span class="line">......</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 拼接ma和mi</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> MINORBITS	20</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> MKDEV(ma,mi)	(((ma) &lt;&lt; MINORBITS) | (mi))</span></span><br></pre></td></tr></table></figure>

<p>对于鼠标来说，加载也是类似的：注册为logibm_init()函数。但是这里没有调用register_chrdev()而是使用input_register_device()，原因在于输入设备会统一由input_init()初始化，之后加入的输入设备通过input_register_device()注册到input的管理结构体中进行统一管理。</p>
<figure class="highlight text"><table><tr><td class="code"><pre><span class="line">module_init(logibm_init);</span><br><span class="line"></span><br><span class="line">static int __init logibm_init(void)</span><br><span class="line">&#123;</span><br><span class="line">......</span><br><span class="line">    err = input_register_device(logibm_dev);</span><br><span class="line">......</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="4-2-创建文件设备"><a href="#4-2-创建文件设备" class="headerlink" title="4.2 创建文件设备"></a>4.2 创建文件设备</h3><p>加载完ko文件后，Linux内核会通过mknod在&#x2F;dev目录下创建一个设备文件，只有有了这个设备文件，我们才能通过文件系统的接口对这个设备文件进行操作。mknod本身是一个系统调用，主要逻辑为调用user_path_create()为该设备文件创建dentry，然后对于S_IFCHAR或者S_IFBLK会调用vfs_mknod()去调用对应文件系统的操作。</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="built_in">SYSCALL_DEFINE3</span>(mknod, <span class="type">const</span> <span class="type">char</span> __user *, filename, <span class="type">umode_t</span>, mode, <span class="type">unsigned</span>, dev)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">sys_mknodat</span>(AT_FDCWD, filename, mode, dev);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="built_in">SYSCALL_DEFINE4</span>(mknodat, <span class="type">int</span>, dfd, <span class="type">const</span> <span class="type">char</span> __user *, filename, <span class="type">umode_t</span>, mode,</span><br><span class="line">    <span class="type">unsigned</span>, dev)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">struct</span> <span class="title class_">dentry</span> *dentry;</span><br><span class="line">    <span class="keyword">struct</span> <span class="title class_">path</span> path;</span><br><span class="line">......</span><br><span class="line">    dentry = <span class="built_in">user_path_create</span>(dfd, filename, &amp;path, lookup_flags);</span><br><span class="line">......</span><br><span class="line">    <span class="keyword">switch</span> (mode &amp; S_IFMT) &#123;</span><br><span class="line">......</span><br><span class="line">        <span class="keyword">case</span> S_IFCHR: <span class="keyword">case</span> S_IFBLK:</span><br><span class="line">            error = <span class="built_in">vfs_mknod</span>(path.dentry-&gt;d_inode,dentry,mode,</span><br><span class="line">            <span class="built_in">new_decode_dev</span>(dev));</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">......</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">vfs_mknod</span><span class="params">(<span class="keyword">struct</span> inode *dir, <span class="keyword">struct</span> dentry *dentry, <span class="type">umode_t</span> mode, <span class="type">dev_t</span> dev)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">......</span><br><span class="line">    error = dir-&gt;i_op-&gt;<span class="built_in">mknod</span>(dir, dentry, mode, dev);</span><br><span class="line">......</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>对于&#x2F;dev目录下的设备驱动来说，所属的文件系统为devtmpfs文件系统，即设备驱动临时文件系统。devtmpfs对应的文件系统定义如下</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="type">static</span> <span class="keyword">struct</span> <span class="title class_">file_system_type</span> dev_fs_type = &#123; </span><br><span class="line">    .name = <span class="string">&quot;devtmpfs&quot;</span>, </span><br><span class="line">    .mount = dev_mount, </span><br><span class="line">    .kill_sb = kill_litter_super,</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="type">static</span> <span class="keyword">struct</span> <span class="title class_">dentry</span> *<span class="built_in">dev_mount</span>(<span class="keyword">struct</span> file_system_type *fs_type, <span class="type">int</span> flags, </span><br><span class="line">         <span class="type">const</span> <span class="type">char</span> *dev_name, <span class="type">void</span> *data)</span><br><span class="line">&#123;</span><br><span class="line"><span class="meta">#<span class="keyword">ifdef</span> CONFIG_TMPFS </span></span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">mount_single</span>(fs_type, flags, data, shmem_fill_super);</span><br><span class="line"><span class="meta">#<span class="keyword">else</span> return </span></span><br><span class="line">    <span class="built_in">mount_single</span>(fs_type, flags, data, ramfs_fill_super);</span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>从这里可以看出，devtmpfs 在挂载的时候有两种模式：一种是 ramfs，一种是 shmem ，都是基于内存的文件系统。这两个 mknod 虽然实现不同，但是都会调用到同一个函数 init_special_inode()。显然这个文件是个特殊文件，inode 也是特殊的。这里这个 inode 可以关联字符设备、块设备、FIFO 文件、Socket 等。我们这里只看字符设备。这里的 inode 的 file_operations 指向一个 def_chr_fops，这里面只有一个 open，就等着你打开它。另外，inode 的 i_rdev 指向这个设备的 dev_t。通过这个 dev_t，可以找到我们刚刚加载的字符设备 cdev。</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="type">static</span> <span class="type">const</span> <span class="keyword">struct</span> <span class="title class_">inode_operations</span> ramfs_dir_inode_operations = &#123;</span><br><span class="line">......</span><br><span class="line">  .mknod    = ramfs_mknod,</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="type">static</span> <span class="type">const</span> <span class="keyword">struct</span> <span class="title class_">inode_operations</span> shmem_dir_inode_operations = &#123;</span><br><span class="line"><span class="meta">#<span class="keyword">ifdef</span> CONFIG_TMPFS</span></span><br><span class="line">......</span><br><span class="line">  .mknod    = shmem_mknod,</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">init_special_inode</span><span class="params">(<span class="keyword">struct</span> inode *inode, <span class="type">umode_t</span> mode, <span class="type">dev_t</span> rdev)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    inode-&gt;i_mode = mode;</span><br><span class="line">    <span class="keyword">if</span> (<span class="built_in">S_ISCHR</span>(mode)) &#123;</span><br><span class="line">        inode-&gt;i_fop = &amp;def_chr_fops;</span><br><span class="line">        inode-&gt;i_rdev = rdev;</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (<span class="built_in">S_ISBLK</span>(mode)) &#123;</span><br><span class="line">        inode-&gt;i_fop = &amp;def_blk_fops;</span><br><span class="line">        inode-&gt;i_rdev = rdev;</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (<span class="built_in">S_ISFIFO</span>(mode))</span><br><span class="line">        inode-&gt;i_fop = &amp;pipefifo_fops;</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span> (<span class="built_in">S_ISSOCK</span>(mode))</span><br><span class="line">        ;  <span class="comment">/* leave it no_open_fops */</span></span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">        <span class="built_in">printk</span>(KERN_DEBUG <span class="string">&quot;init_special_inode: bogus i_mode (%o) for&quot;</span></span><br><span class="line">                  <span class="string">&quot; inode %s:%lu\n&quot;</span>, mode, inode-&gt;i_sb-&gt;s_id,</span><br><span class="line">                  inode-&gt;i_ino);    </span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">const</span> <span class="keyword">struct</span> <span class="title class_">file_operations</span> def_chr_fops = &#123;</span><br><span class="line">    .open = chrdev_open,</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>由此我们完成了&#x2F;dev下文件的创建，并利用rdev和生成的字符设备进行了关联。</p>
<h3 id="4-3-打开字符设备"><a href="#4-3-打开字符设备" class="headerlink" title="4.3 打开字符设备"></a>4.3 打开字符设备</h3><p>如打开普通文件一样，打开字符设备也会首先分配对应的文件描述符fd，然后生成struct file结构体与其绑定，并将file关联到对应的dentry从而可以接触inode。在进程里面调用 open() 函数，最终会调用到这个特殊的 inode 的 open() 函数，也就是 chrdev_open()。</p>
<p><strong>chrdev_open()主要逻辑为;</strong></p>
<ul>
<li>调用kobj_lookup()，通过设备号i_cdev关联对应的设备驱动程序</li>
<li>调用fops_get()将设备驱动程序自己定义的文件操作p-&gt;ops赋值给fops</li>
<li>调用设备驱动程序的 file_operations 的 open() 函数真正打开设备。对于打印机，调用的是 lp_open()。对于鼠标调用的是 input_proc_devices_open()，最终会调用到 logibm_open()。</li>
</ul>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * Called every time a character special file is opened</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="type">static</span> <span class="type">int</span> <span class="title">chrdev_open</span><span class="params">(<span class="keyword">struct</span> inode *inode, <span class="keyword">struct</span> file *filp)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">const</span> <span class="keyword">struct</span> <span class="title class_">file_operations</span> *fops;</span><br><span class="line">    <span class="keyword">struct</span> <span class="title class_">cdev</span> *p;</span><br><span class="line">    <span class="keyword">struct</span> <span class="title class_">cdev</span> *<span class="keyword">new</span> = <span class="literal">NULL</span>;</span><br><span class="line">......</span><br><span class="line">    p = inode-&gt;i_cdev;</span><br><span class="line">......</span><br><span class="line">    kobj = <span class="built_in">kobj_lookup</span>(cdev_map, inode-&gt;i_rdev, &amp;idx);</span><br><span class="line">......      </span><br><span class="line">    fops = <span class="built_in">fops_get</span>(p-&gt;ops);</span><br><span class="line">......</span><br><span class="line">    <span class="built_in">replace_fops</span>(filp, fops);</span><br><span class="line">    <span class="keyword">if</span> (filp-&gt;f_op-&gt;open) &#123;</span><br><span class="line">        ret = filp-&gt;f_op-&gt;<span class="built_in">open</span>(inode, filp);</span><br><span class="line">......</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>上述过程借用极客时间中的图来作为总结：</strong></p>
<p><img src="https://pic3.zhimg.com/80/v2-462b2f8f647974148c76f413e19390a2_720w.webp" alt="img"></p>
<h2 id="5、-写入字符设备"><a href="#5、-写入字符设备" class="headerlink" title="5、 写入字符设备"></a>5、 写入字符设备</h2><p>写入字符设备和写入普通文件一样，调用write()函数执行。该函数在内核里查询系统调用表最终调用sys_write()，并根据fd描述符获取对应的file结构体，接着调用vfs_write()去调用对应的文件系统自定义的写入函数file-&gt;f_op-&gt;write()。对于打印机来说，最终调用的是自定义的lp_write()函数。</p>
<p>这里写入的重点在于调用 copy_from_user() 将数据从用户态拷贝到内核态的缓存中，然后调用 parport_write() 写入外部设备。这里还有一个 schedule() 函数，也即写入的过程中，给其他线程抢占 CPU 的机会。如果写入字节数多，不能一次写完，就会在循环里一直调用 copy_from_user() 和 parport_write()，直到写完为止。</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">static</span> <span class="type">ssize_t</span> <span class="title">lp_write</span><span class="params">(<span class="keyword">struct</span> file *file, <span class="type">const</span> <span class="type">char</span> __user *buf,</span></span></span><br><span class="line"><span class="params"><span class="function">            <span class="type">size_t</span> count, <span class="type">loff_t</span> *ppos)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">unsigned</span> <span class="type">int</span> minor = <span class="built_in">iminor</span>(<span class="built_in">file_inode</span>(file));</span><br><span class="line">    <span class="keyword">struct</span> <span class="title class_">parport</span> *port = lp_table[minor].dev-&gt;port;</span><br><span class="line">    <span class="type">char</span> *kbuf = lp_table[minor].lp_buffer;</span><br><span class="line">    <span class="type">ssize_t</span> retv = <span class="number">0</span>;</span><br><span class="line">    <span class="type">ssize_t</span> written;</span><br><span class="line">    <span class="type">size_t</span> copy_size = count;</span><br><span class="line">......</span><br><span class="line">    <span class="comment">/* Need to copy the data from user-space. */</span></span><br><span class="line">    <span class="keyword">if</span> (copy_size &gt; LP_BUFFER_SIZE)</span><br><span class="line">        copy_size = LP_BUFFER_SIZE;</span><br><span class="line">......</span><br><span class="line">    <span class="keyword">if</span> (<span class="built_in">copy_from_user</span>(kbuf, buf, copy_size)) &#123;</span><br><span class="line">        retv = -EFAULT;</span><br><span class="line">        <span class="keyword">goto</span> out_unlock;</span><br><span class="line">    &#125;</span><br><span class="line">......</span><br><span class="line">    <span class="keyword">do</span> &#123;</span><br><span class="line">        <span class="comment">/* Write the data. */</span></span><br><span class="line">        written = <span class="built_in">parport_write</span>(port, kbuf, copy_size);</span><br><span class="line">        <span class="keyword">if</span> (written &gt; <span class="number">0</span>) &#123;</span><br><span class="line">            copy_size -= written;</span><br><span class="line">            count -= written;</span><br><span class="line">            buf  += written;</span><br><span class="line">            retv += written;</span><br><span class="line">        &#125;</span><br><span class="line">......</span><br><span class="line">        <span class="keyword">if</span> (<span class="built_in">need_resched</span>())</span><br><span class="line">            <span class="built_in">schedule</span>(); </span><br><span class="line">        <span class="keyword">if</span> (count) &#123;</span><br><span class="line">            copy_size = count;</span><br><span class="line">            <span class="keyword">if</span> (copy_size &gt; LP_BUFFER_SIZE)</span><br><span class="line">                copy_size = LP_BUFFER_SIZE;</span><br><span class="line">            <span class="keyword">if</span> (<span class="built_in">copy_from_user</span>(kbuf, buf, copy_size)) &#123;</span><br><span class="line">                <span class="keyword">if</span> (retv == <span class="number">0</span>)</span><br><span class="line">                    retv = -EFAULT;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; <span class="keyword">while</span> (count &gt; <span class="number">0</span>);</span><br><span class="line">......</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="6、字符设备的控制"><a href="#6、字符设备的控制" class="headerlink" title="6、字符设备的控制"></a>6、字符设备的控制</h2><p>在Linux中，我们常用ioctl()来对I&#x2F;O设备进行一些读写之外的特殊操作。其参数主要由文件描述符fd，命令cmd以及命令参数arg构成。其中cmd由几个部分拼接成整型，主要结构为</p>
<ul>
<li>最低8位为 NR，表示命令号；</li>
<li>次低8位为 TYPE，表示类型；</li>
<li>14位表示参数的大小；</li>
<li>最高2位是 DIR，表示写入、读出，还是读写。</li>
</ul>
<p><img src="https://pic2.zhimg.com/80/v2-9fcd5c0b10447ecb5b31d1584ac3fb5d_720w.webp" alt="img"></p>
<p>ioctl()也是一个系统调用，其中fd 是这个设备的文件描述符，cmd 是传给这个设备的命令，arg 是命令的参数。主要调用do_vfs_ioctl()完成实际功能。</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="built_in">SYSCALL_DEFINE3</span>(ioctl, <span class="type">unsigned</span> <span class="type">int</span>, fd, <span class="type">unsigned</span> <span class="type">int</span>, cmd, <span class="type">unsigned</span> <span class="type">long</span>, arg)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">int</span> error;</span><br><span class="line">    <span class="keyword">struct</span> <span class="title class_">fd</span> f = <span class="built_in">fdget</span>(fd);</span><br><span class="line">......</span><br><span class="line">    error = <span class="built_in">do_vfs_ioctl</span>(f.file, fd, cmd, arg);</span><br><span class="line">    <span class="built_in">fdput</span>(f);</span><br><span class="line">    <span class="keyword">return</span> error;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>do_vfs_ioctl()对于已经定义好的 cmd进行相应的处理。如果不是默认定义好的 cmd，则执行默认操作：对于普通文件，调用 file_ioctl，对于其他文件调用 vfs_ioctl。</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * When you add any new common ioctls to the switches above and below</span></span><br><span class="line"><span class="comment"> * please update compat_sys_ioctl() too.</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * do_vfs_ioctl() is not for drivers and not intended to be EXPORT_SYMBOL()&#x27;d.</span></span><br><span class="line"><span class="comment"> * It&#x27;s just a simple helper for sys_ioctl and compat_sys_ioctl.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">do_vfs_ioctl</span><span class="params">(<span class="keyword">struct</span> file *filp, <span class="type">unsigned</span> <span class="type">int</span> fd, <span class="type">unsigned</span> <span class="type">int</span> cmd,</span></span></span><br><span class="line"><span class="params"><span class="function">         <span class="type">unsigned</span> <span class="type">long</span> arg)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">int</span> error = <span class="number">0</span>;</span><br><span class="line">    <span class="type">int</span> __user *argp = (<span class="type">int</span> __user *)arg;</span><br><span class="line">    <span class="keyword">struct</span> <span class="title class_">inode</span> *inode = <span class="built_in">file_inode</span>(filp);</span><br><span class="line">    <span class="keyword">switch</span> (cmd) &#123;</span><br><span class="line">    <span class="keyword">case</span> FIOCLEX:</span><br><span class="line">        <span class="built_in">set_close_on_exec</span>(fd, <span class="number">1</span>);</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">    <span class="keyword">case</span> FIONCLEX:</span><br><span class="line">        <span class="built_in">set_close_on_exec</span>(fd, <span class="number">0</span>);</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">    <span class="keyword">case</span> FIONBIO:</span><br><span class="line">        error = <span class="built_in">ioctl_fionbio</span>(filp, argp);</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">    <span class="keyword">case</span> FIOASYNC:</span><br><span class="line">        error = <span class="built_in">ioctl_fioasync</span>(fd, filp, argp);</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">......</span><br><span class="line">    <span class="keyword">default</span>:</span><br><span class="line">        <span class="keyword">if</span> (<span class="built_in">S_ISREG</span>(inode-&gt;i_mode))</span><br><span class="line">            error = <span class="built_in">file_ioctl</span>(filp, cmd, arg);</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">            error = <span class="built_in">vfs_ioctl</span>(filp, cmd, arg);</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> error;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>对于字符设备驱动程序，最终会调用vfs_ioctl()。这里面调用的是 struct file 里 file_operations 的 unlocked_ioctl() 函数。我们前面初始化设备驱动的时候，已经将 file_operations 指向设备驱动的 file_operations 了。这里调用的是设备驱动的 unlocked_ioctl。对于打印机程序来讲，调用的是 lp_ioctl()。</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">long</span> <span class="title">vfs_ioctl</span><span class="params">(<span class="keyword">struct</span> file *filp, <span class="type">unsigned</span> <span class="type">int</span> cmd, <span class="type">unsigned</span> <span class="type">long</span> arg)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">int</span> error = -ENOTTY;</span><br><span class="line">    <span class="keyword">if</span> (!filp-&gt;f_op-&gt;unlocked_ioctl)</span><br><span class="line">        <span class="keyword">goto</span> out;</span><br><span class="line">    error = filp-&gt;f_op-&gt;<span class="built_in">unlocked_ioctl</span>(filp, cmd, arg);</span><br><span class="line">    <span class="keyword">if</span> (error == -ENOIOCTLCMD)</span><br><span class="line">        error = -ENOTTY;</span><br><span class="line"> out:</span><br><span class="line">    <span class="keyword">return</span> error;</span><br><span class="line">&#125; <span class="built_in">EXPORT_SYMBOL</span>(vfs_ioctl);</span><br></pre></td></tr></table></figure>

<p>打印机的lp_do_ioctl()主要逻辑也是针对cmd采用switch()语句分情况进行处理。主要包括使用LP_XXX()宏定义赋值标记位和调用copy_to_user()将用户想得到的信息返回给用户态。</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">static</span> <span class="type">int</span> <span class="title">lp_do_ioctl</span><span class="params">(<span class="type">unsigned</span> <span class="type">int</span> minor, <span class="type">unsigned</span> <span class="type">int</span> cmd,</span></span></span><br><span class="line"><span class="params"><span class="function">    <span class="type">unsigned</span> <span class="type">long</span> arg, <span class="type">void</span> __user *argp)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">int</span> status;</span><br><span class="line">    <span class="type">int</span> retval = <span class="number">0</span>;</span><br><span class="line">......</span><br><span class="line">    <span class="keyword">switch</span> ( cmd ) &#123;</span><br><span class="line">        <span class="keyword">case</span> LPTIME:</span><br><span class="line">            <span class="keyword">if</span> (arg &gt; UINT_MAX / HZ)</span><br><span class="line">                <span class="keyword">return</span> -EINVAL;</span><br><span class="line">            <span class="built_in">LP_TIME</span>(minor) = arg * HZ/<span class="number">100</span>;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        <span class="keyword">case</span> LPCHAR:</span><br><span class="line">            <span class="built_in">LP_CHAR</span>(minor) = arg;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        <span class="keyword">case</span> LPABORT:</span><br><span class="line">            <span class="keyword">if</span> (arg)</span><br><span class="line">                <span class="built_in">LP_F</span>(minor) |= LP_ABORT;</span><br><span class="line">            <span class="keyword">else</span></span><br><span class="line">                <span class="built_in">LP_F</span>(minor) &amp;= ~LP_ABORT;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">    ......</span><br><span class="line">        <span class="keyword">case</span> LPGETIRQ:</span><br><span class="line">            <span class="keyword">if</span> (<span class="built_in">copy_to_user</span>(argp, &amp;<span class="built_in">LP_IRQ</span>(minor),</span><br><span class="line">                    <span class="built_in">sizeof</span>(<span class="type">int</span>)))</span><br><span class="line">                <span class="keyword">return</span> -EFAULT;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">......</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="7、总结"><a href="#7、总结" class="headerlink" title="7、总结"></a>7、总结</h2><p>本文简单介绍了设备驱动程序的结构，并在此基础上介绍了字符设备从创建到打开、写入以及控制的整个流程。</p>
<hr>
<p>版权声明：本文为知乎博主「玩转Linux内核」的原创文章，遵循CC 4.0 BY-SA版权协议，转载请附上原文出处链接及本声明。<br>原文链接：<a href="https://zhuanlan.zhihu.com/p/445188798">https://zhuanlan.zhihu.com/p/445188798</a></p>
]]></content>
      <categories>
        <category>linux-doc 设备驱动</category>
      </categories>
      <tags>
        <tag>Linux</tag>
      </tags>
  </entry>
  <entry>
    <title>Linux内核设备信息集合</title>
    <url>/2023/01/15/linux-docs/%E8%AE%BE%E5%A4%87%E9%A9%B1%E5%8A%A8/Linux%E5%86%85%E6%A0%B8%E8%AE%BE%E5%A4%87%E4%BF%A1%E6%81%AF%E9%9B%86%E5%90%88/</url>
    <content><![CDATA[<p>本文结合设备信息集合的详细讲解来认识一下设备和驱动是如何绑定的。所谓设备信息集合，就是根据不同的外设寻找各自的外设信息，我们知道一个完整的开发板有 CPU 和各种控制器（如 I2C 控制器、SPI 控制器、DMA 控制器等），CPU和控制器可以统称为 SOC，除此之外还有各种外设 IP，如 LCD、HDMI、SD、CAMERA 等，如下图：</p>
<p><img src="https://pic3.zhimg.com/80/v2-b2e80e1a301acb3711014f26011ecabe_720w.webp" alt="img"></p>
<p>我们看到一个开发板上有很多的设备，这些设备是如何一层一层展开的呢？设备和驱动又是如何绑定的呢？我们带着这些疑问进入本节的主题。</p>
<h2 id="各级设备的展开"><a href="#各级设备的展开" class="headerlink" title="各级设备的展开"></a>各级设备的展开</h2><p>内核启动的时候是一层一层展开地去寻找设备，设备树之所以叫设备树也是因为设备在内核中的结构就像树一样，从根部一层一层的向外展开，为了更形象的理解来看一张图：</p>
<p><img src="https://pic3.zhimg.com/80/v2-4dc92d630c83003fd9816c31d460a5e2_720w.webp" alt="img"></p>
<p>大的圆圈中就是我们常说的 soc，里面包括 CPU 和各种控制器 A、B、I2C、SPI，soc 外面接了外设 E 和 F。IP 外设有具体的总线，如 I2C 总线、SPI 总线，对应的 I2C 设备和 SPI 设备就挂在各自的总线上，但是在 soc 内部只有系统总线，是没有具体总线的。</p>
<p>第一节中讲了总线、设备和驱动模型的原理，即任何驱动都是通过对应的总线和设备发生联系的，故虽然 soc 内部没有具体的总线，但是内核通过 platform 这条虚拟总线，把控制器一个一个找到，一样遵循了内核高内聚、低耦合的设计理念。下面我们按照 platform 设备、i2c 设备、spi 设备的顺序探究设备是如何一层一层展开的。</p>
<h2 id="展开-platform-设备"><a href="#展开-platform-设备" class="headerlink" title="展开 platform 设备"></a>展开 platform 设备</h2><p>上图中可以看到红色字体标注的 simple-bus，这些就是连接各类控制器的总线，在内核里即为 platform 总线，挂载的设备为 platform 设备。下面看下 platform 设备是如何展开的。</p>
<p>还记得上一节讲到在内核初始化的时候有一个叫做 init_machine() 的回调函数吗？如果你在板级文件里注册了这个函数，那么在系统启动的时候这个函数会被调用，如果没有定义，则会通过调用 of_platform_populate() 来展开挂在“simple-bus”下的设备，如图（分别位于 kernel&#x2F;arch&#x2F;arm&#x2F;kernel&#x2F;setup.c，kernel&#x2F;drivers&#x2F;of&#x2F;platform.c）：</p>
<p><img src="https://pic3.zhimg.com/80/v2-e9aff7395466e769047e410f70fab02a_720w.webp" alt="img"></p>
<p>这样就把 simple-bus 下面的节点一个一个的展开为 platform 设备。</p>
<h2 id="展开-i2c-设备"><a href="#展开-i2c-设备" class="headerlink" title="展开 i2c 设备"></a>展开 i2c 设备</h2><p>有经验的小伙伴知道在写 i2c 控制器的时候肯定会调用 i2c_register_adapter() 函数，该函数的实现如下（kernel&#x2F;drivers&#x2F;i2c&#x2F;i2c-core.c）：</p>
<p><img src="https://pic3.zhimg.com/80/v2-b2e0a4c0da9a37abfb1d3622e8c1059a_720w.webp" alt="img"></p>
<p><strong>注册函数的最后有一个函数 of_i2c_register_devices(adap)，实现如下：</strong></p>
<p><img src="https://pic1.zhimg.com/80/v2-6644a7b5caa15712f60212bb9689fe74_720w.webp" alt="img"></p>
<p>of_i2c_register_devices()函数中会遍历控制器下的节点，然后通过of_i2c_register_device()函数把 i2c 控制器下的设备注册进去。</p>
<h2 id="展开-spi-设备"><a href="#展开-spi-设备" class="headerlink" title="展开 spi 设备"></a>展开 spi 设备</h2><p>spi 设备的注册和 i2c 设备一样，在 spi 控制器下遍历 spi 节点下的设备，然后通过相应的注册函数进行注册，只是和 i2c 注册的 api 接口不一样，下面看一下具体的代码（kernel&#x2F;drivers&#x2F;spi&#x2F;spi.c)：</p>
<p><img src="https://pic1.zhimg.com/80/v2-53ff6a836d12f09fac3df465a7af69e0_720w.webp" alt="img"></p>
<p>当通过 spi_register_master 注册 spi 控制器的时候会通过 of_register_spi_devices 来遍历 spi 总线下的设备，从而注册。这样就完成了spi设备的注册。</p>
<h2 id="各级设备的展开-1"><a href="#各级设备的展开-1" class="headerlink" title="各级设备的展开"></a>各级设备的展开</h2><p>学到这里相信应该了解设备的硬件信息是从设备树里获取的，如寄存器地址、中断号、时钟等等。接下来我们一起看下这些信息在设备树里是怎么记录的，为下一节动手定制开发板做好准备。</p>
<h2 id="reg-寄存器"><a href="#reg-寄存器" class="headerlink" title="reg 寄存器"></a>reg 寄存器</h2><p><img src="https://pic3.zhimg.com/80/v2-df55421ca88dcc840cf19e0f7e88c72e_720w.webp" alt="img"></p>
<p>我们先看设备树里的 soc 描述信息，红色标注的代表着寄存器地址用几个数据量来表述，绿色标注的代表着寄存器空间大小用几个数据量来表述。图中的含义是中断控制器的基地址是 0xfec00000，空间大小是 0x1000。如果 address-cells 的值是 2 的话表示需要两个数量级来表示基地址，比如寄存器是 64 位的话就需要两个数量级来表示，每个代表着 32 位的数。</p>
<h2 id="ranges-取值范围"><a href="#ranges-取值范围" class="headerlink" title="ranges 取值范围"></a>ranges 取值范围</h2><p><img src="https://pic2.zhimg.com/80/v2-510c055ffe4da05c75ee9b94d35ac4c9_720w.webp" alt="img"></p>
<p>ranges 代表了 local 地址向 parent 地址的转换，如果 ranges 为空的话代表着与 cpu 是 1:1 的映射关系，如果没有 range 的话表示不是内存区域。</p>
<hr>
<p>版权声明：本文为知乎博主「玩转Linux内核」的原创文章，遵循CC 4.0 BY-SA版权协议，转载请附上原文出处链接及本声明。</p>
<p>原文链接：<a href="https://zhuanlan.zhihu.com/p/445185233">https://zhuanlan.zhihu.com/p/445185233</a></p>
]]></content>
      <categories>
        <category>linux-doc 设备驱动</category>
      </categories>
      <tags>
        <tag>Linux</tag>
      </tags>
  </entry>
  <entry>
    <title>Linux内核设备驱动IO流程详解</title>
    <url>/2023/01/15/linux-docs/%E8%AE%BE%E5%A4%87%E9%A9%B1%E5%8A%A8/Linux%E5%86%85%E6%A0%B8%E8%AE%BE%E5%A4%87%E9%A9%B1%E5%8A%A8IO%E6%B5%81%E7%A8%8B%E8%AF%A6%E8%A7%A3/</url>
    <content><![CDATA[<p>我们之前的文章提到了操作系统的三个抽象，它们分别是进程、地址空间和文件，除此之外，操作系统还要控制所有的 I&#x2F;O 设备。操作系统必须向设备发送命令，捕捉中断并处理错误。它还应该在设备和操作系统的其余部分之间提供一个简单易用的接口。操作系统如何管理 I&#x2F;O 是我们接下来的重点。</p>
<p>不同的人对 I&#x2F;O 硬件的理解也不同。对于电子工程师而言，I&#x2F;O 硬件就是芯片、导线、电源和其他组成硬件的物理设备。而我们程序员眼中的 I&#x2F;O 其实就是硬件提供给软件的接口，比如硬件接受到的命令、执行的操作以及反馈的错误。我们着重探讨的是如何对硬件进行编程，而不是其工作原理。</p>
<h2 id="I-O-设备"><a href="#I-O-设备" class="headerlink" title="I&#x2F;O 设备"></a>I&#x2F;O 设备</h2><p>什么是 I&#x2F;O 设备？I&#x2F;O 设备又叫做输入&#x2F;输出设备，它是人类用来和计算机进行通信的外部硬件。输入&#x2F;输出设备能够向计算机发送数据（输出）并从计算机接收数据（输入）。</p>
<p>I&#x2F;O 设备(I&#x2F;O devices)可以分成两种：块设备(block devices) 和 字符设备(character devices)。</p>
<h2 id="块设备"><a href="#块设备" class="headerlink" title="块设备"></a>块设备</h2><p>块设备是一个能存储固定大小块信息的设备，它支持以固定大小地块，扇区或群集读取和（可选）写入数据。每个块都有自己的物理地址。通常块的大小在 512 - 65536 之间。所有传输的信息都会以连续地块为单位。块设备的基本特征是每个块都较为对立，能够独立地进行读写。常见的块设备有 硬盘、蓝光光盘、USB 盘</p>
<p>与字符设备相比，这块设备通常需要较少的引脚。</p>
<p><img src="https://pic4.zhimg.com/80/v2-103bd5a2722497532b208b3a32728bcf_720w.webp" alt="img"></p>
<p><strong>块设备的缺点</strong></p>
<p>基于给定固态存储器的块设备比基于相同类型的存储器的字节寻址要慢一些，因为必须在块的开头开始读取或写入。所以，要读取该块的任何部分，必须寻找到该块的开始，读取整个块，如果不使用该块，则将其丢弃。要写入块的一部分，必须寻找到块的开始，将整个块读入内存，修改数据，再次寻找到块的开头处，然后将整个块写回设备。</p>
<p><strong>字符设备</strong></p>
<p>另一类 I&#x2F;O 设备是字符设备。字符设备以字符为单位发送或接收一个字符流，而不考虑任何块结构。字符设备是不可寻址的，也没有任何寻道操作。常见的字符设备有 打印机、网络设备、鼠标、以及大多数与磁盘不同的设备。</p>
<p><img src="https://pic2.zhimg.com/80/v2-f05ebda6e42d4272f0bfe9e443944675_720w.webp" alt="img"></p>
<p><strong>下面显示了一些常见设备的数据速率：</strong></p>
<p><img src="https://pic4.zhimg.com/80/v2-be1dafc6c52d744492cca831dd2cf0b3_720w.webp" alt="img"></p>
<h2 id="设备控制器"><a href="#设备控制器" class="headerlink" title="设备控制器"></a>设备控制器</h2><p><strong>首先需要先了解一下设备控制器的概念：</strong></p>
<p>设备控制器是处理 CPU 传入和传出信号的系统。设备通过插头和插座连接到计算机，并且插座连接到设备控制器。设备控制器从连接的设备处接收数据，并将其存储在控制器内部的一些特殊目的寄存器(special purpose registers) 也就是本地缓冲区中。</p>
<p>特殊用途寄存器，顾名思义是为一项任务而设计的寄存器。例如，cs，ds，gs 和其他段寄存器属于特殊目的寄存器，因为它们的存在是为了保存段号。 eax，ecx 等是一般用途的寄存器，因为你可以无限制地使用它们。 例如，你不能移动 ds，但是可以移动 eax，ebx。</p>
<ul>
<li>通用目的寄存器比如有：eax、ecx、edx、ebx、esi、edi、ebp、esp</li>
<li>特殊目的寄存器比如有：cs、ds、ss、es、fs、gs、eip、flag</li>
</ul>
<p>每个设备控制器都会有一个应用程序与之对应，设备控制器通过应用程序的接口通过中断与操作系统进行通信。设备控制器是硬件，而设备驱动程序是软件。</p>
<p>I&#x2F;O 设备通常由机械组件(mechanical component)和电子组件(electronic component)构成。电子组件被称为 设备控制器(device controller)或者 适配器(adapter)。在个人计算机上，它通常采用可插入（PCIe）扩展插槽的主板上的芯片或印刷电路卡的形式。</p>
<p><img src="https://pic3.zhimg.com/80/v2-3d15c55972868c0c3093847c95b373d2_720w.webp" alt="img"></p>
<p><strong>机械设备就是它自己，它的组成如下：</strong></p>
<p><img src="https://pic4.zhimg.com/80/v2-207b863a1b2266e7653405ca9cfcbd7b_720w.webp" alt="img"></p>
<p>制器卡上通常会有一个连接器，通向设备本身的电缆可以插入到这个连接器中，很多控制器可以操作 2 个、4 个设置 8 个相同的设备。</p>
<p>控制器与设备之间的接口通常是一个低层次的接口。例如，磁盘可能被格式化为 2,000,000 个扇区，每个磁道 512 字节。然而，实际从驱动出来的却是一个串行的比特流，从一个前导符(preamble)开始，然后是一个扇区中的 4096 位，最后是一个校验和 或 ECC（错误码，Error-Correcting Code）。前导符是在对磁盘进行格式化的时候写上去的，它包括柱面数和扇区号，扇区大小以及类似的数据，此外还包含同步信息。</p>
<p>控制器的任务是把串行的位流转换为字节块，并进行必要的错误校正工作。字节块通常会在控制器内部的一个缓冲区按位进行组装，然后再对校验和进行校验并证明字节块没有错误后，再将它复制到内存中。</p>
<h2 id="内存映射-I-O"><a href="#内存映射-I-O" class="headerlink" title="内存映射 I&#x2F;O"></a>内存映射 I&#x2F;O</h2><p>每个控制器都会有几个寄存器用来和 CPU 进行通信。通过写入这些寄存器，操作系统可以命令设备发送数据，接收数据、开启或者关闭设备等。通过从这些寄存器中读取信息，操作系统能够知道设备的状态，是否准备接受一个新命令等。</p>
<p>为了控制寄存器，许多设备都会有数据缓冲区(data buffer)，来供系统进行读写。例如，在屏幕上显示一个像素的常规方法是使用一个视频 RAM，这一 RAM 基本上只是一个数据缓冲区，用来供程序和操作系统写入数据。</p>
<p>那么问题来了，CPU 如何与设备寄存器和设备数据缓冲区进行通信呢？存在两个可选的方式。第一种方法是，每个控制寄存器都被分配一个 I&#x2F;O 端口(I&#x2F;O port)号，这是一个 8 位或 16 位的整数。所有 I&#x2F;O 端口的集合形成了受保护的 I&#x2F;O 端口空间，以便普通用户程序无法访问它（只有操作系统可以访问）。使用特殊的 I&#x2F;O 指令像是</p>
<figure class="highlight text"><table><tr><td class="code"><pre><span class="line">IN REG,PORT</span><br></pre></td></tr></table></figure>

<p>CPU 可以读取控制寄存器 PORT 的内容并将结果放在 CPU 寄存器 REG 中。类似的，使用</p>
<figure class="highlight text"><table><tr><td class="code"><pre><span class="line">OUT PORT,REG</span><br></pre></td></tr></table></figure>

<p>CPU 可以将 REG 的内容写到控制寄存器中。大多数早期计算机，包括几乎所有大型计算机，如 IBM 360 及其所有后续机型，都是以这种方式工作的。</p>
<p>控制寄存器是一个处理器寄存器而改变或控制的一般行为 CPU 或者其他数字设备。控制寄存器执行的常见任务包括中断控制，切换寻址模式，分页控制和协处理器控制。</p>
<p><strong>在这一方案中，内存地址空间和 I&#x2F;O 地址空间是不相同的，如下图所示：</strong></p>
<p><img src="https://pic1.zhimg.com/80/v2-dafea15314a0290645f33fc6d663985c_720w.webp" alt="img"></p>
<p>指令</p>
<figure class="highlight text"><table><tr><td class="code"><pre><span class="line">IN R0,4</span><br></pre></td></tr></table></figure>

<p>和</p>
<figure class="highlight text"><table><tr><td class="code"><pre><span class="line">MOV R0,4</span><br></pre></td></tr></table></figure>

<p>这一设计中完全不同。<strong>前者读取 I&#x2F;O端口 4 的内容并未将其放入 R0，而后者读取存储器字 4 的内容并将其放入 R0</strong>。这些示例中的 4 代表不同且不相关的地址空间。</p>
<p>第二个方法是 PDP-11 引入的，</p>
<blockquote>
<p>什么是 PDP-11?</p>
</blockquote>
<p><img src="https://pic1.zhimg.com/80/v2-4aa9f5f9ff13921e439d3cf2497f1ea8_720w.webp" alt="img"></p>
<p>它将<strong>所有控制寄存器映射到内存空间</strong>中，如下图所示：</p>
<p><img src="https://pic3.zhimg.com/80/v2-a969368ece6403b14d29a2c422bec2ca_720w.webp" alt="img"></p>
<p>内存映射的 I&#x2F;O是在 CPU 与其连接的外围设备之间交换数据和指令的一种方式，这种方式是处理器和 IO 设备共享同一内存位置的内存，即处理器和 IO 设备使用内存地址进行映射。</p>
<p>在大多数系统中，分配给控制寄存器的地址位于或者靠近地址的顶部附近。</p>
<p><strong>下面是采用的一种混合方式：</strong></p>
<p><img src="https://pic4.zhimg.com/80/v2-8266dabbc6bdce4fed65881932284a6f_720w.webp" alt="img"></p>
<p>这种方式具有内存映射 I&#x2F;O 的数据缓冲区，而控制寄存器则具有单独的 I&#x2F;O 端口。x86 采用这一体系结构。在 IBM PC 兼容机中，除了 0 到 64K - 1 的 I&#x2F;O 端口之外，640 K 到 1M - 1 的内存地址保留给设备的数据缓冲区。</p>
<p>这些方案是如何工作的呢？当 CPU 想要读入一个字的时候，无论是从内存中读入还是从 I&#x2F;O 端口读入，它都要将需要的地址放到总线地址线上，然后在总线的一条控制线上调用一个 READ 信号。还有第二条信号线来表明需要的是什么 I&#x2F;O 空间还是内存空间。如果是内存空间，内存将响应请求。如果是 I&#x2F;O 空间，那么 I&#x2F;O 设备将响应请求。如果只有内存空间，那么每个内存模块和每个 I&#x2F;O 设备都会将地址线和它所服务的地址范围进行比较。如果地址落在这一范围之内，它就会响应请求。绝对不会出现地址既分配给内存又分配给 I&#x2F;O 设备，所以不会存在歧义和冲突。</p>
<h2 id="内存映射-I-O-的优点和缺点"><a href="#内存映射-I-O-的优点和缺点" class="headerlink" title="内存映射 I&#x2F;O 的优点和缺点"></a>内存映射 I&#x2F;O 的优点和缺点</h2><p>这两种寻址控制器的方案具有不同的优缺点。先来看一下内存映射 I&#x2F;O 的优点。</p>
<p>第一，如果需要特殊的东西 I&#x2F;O 指令读写设备控制寄存器，那么访问这些寄存器需要使用汇编代码，因为在 C 或 C++ 中不存在执行 IN 和 OUT指令的方法。调用这样的过程增加了 I&#x2F;O 的开销。在内存映射中，控制寄存器只是内存中的变量，在 C 语言中可以和其他变量一样进行寻址。</p>
<p>第二，对于内存映射 I&#x2F;O ，不需要特殊的保护机制就能够阻止用户进程执行 I&#x2F;O 操作。操作系统需要保证的是禁止把控制寄存器的地址空间放在用户的虚拟地址中就可以了。</p>
<p>第三，对于内存映射 I&#x2F;O，可以引用内存的每一条指令也可以引用控制寄存器，便于引用。</p>
<p>在计算机设计中，几乎所有的事情都要权衡。内存映射 I&#x2F;O 也是一样，它也有自己的缺点。首先，大部分计算机现在都会有一些对于内存字的缓存。缓存一个设备控制寄存器的代价是很大的。为了避免这种内存映射 I&#x2F;O 很多情况，硬件必须有选择性地禁用缓存，例如，在每个页面上禁用缓存，这个功能为硬件和操作系统增加了额外的复杂性，因此必须选择性的进行管理。</p>
<p>第二点，如果仅仅只有一个地址空间，那么所有的内存模块(memory modules)和所有的 I&#x2F;O 设备都必须检查所有的内存引用来推断出谁来进行响应。</p>
<p>什么是内存模块？在计算中，存储器模块是其上安装有存储器集成电路的印刷电路板。</p>
<p><img src="https://pic4.zhimg.com/80/v2-c729b9c647a4cee07d73dca1672d27a7_720w.webp" alt="img"></p>
<p><strong>如果计算机是一种单线体系结构的话，如下图所示：</strong></p>
<p><img src="https://pic2.zhimg.com/80/v2-c14783f47b14aca66ff4725e269ce4a5_720w.webp" alt="img"></p>
<p>让每个内存模块和 I&#x2F;O 设备查看每个地址是简单易行的。</p>
<p><strong>然而，现代个人计算机的趋势是专用的高速内存总线，如下图所示：</strong></p>
<p><img src="https://pic4.zhimg.com/80/v2-4a77648e5065b7eba73639d61a871c27_720w.webp" alt="img"></p>
<p>装备这一总线是为了优化内存访问速度，x86 系统还可以有多种总线（内存、PCIe、SCSI 和 USB）。如下图所示：</p>
<p><img src="https://pic2.zhimg.com/80/v2-29cfe64c20d7467d962e20068411026d_720w.webp" alt="img"></p>
<p>在内存映射机器上使用单独的内存总线的麻烦之处在于，I&#x2F;O 设备无法通过内存总线查看内存地址，因此它们无法对其进行响应。此外，必须采取特殊的措施使内存映射 I&#x2F;O 工作在具有多种线的系统上。一种可能的方法是首先将全部内存引用发送到内存，如果内存响应失败，CPU 再尝试其他总线。</p>
<p>第二种设计是在内存总线上放一个探查设备，放过所有潜在指向所关注的 I&#x2F;O 设备的地址。此处的问题是，I&#x2F;O 设备可能无法以内存所能达到的速度处理请求。</p>
<p>第三种可能的设计是在内存控制器中对地址进行过滤，这种设计与上图所描述的设计相匹配。这种情况下，内存控制器芯片中包含在引导时预装载的范围寄存器。这一设计的缺点是需要在引导时判定哪些内存地址而不是真正的内存地址。因而，每一设计都有支持它和反对它的论据，所以折中和权衡是不可避免的。</p>
<p><strong>直接内存访问</strong></p>
<p>无论一个 CPU 是否具有内存映射能力 I&#x2F;O，它都需要寻址设备控制器以便与它们交换数据。CPU 可以从 I&#x2F;O 控制器每次请求一个字节的数据，但是这么做会浪费 CPU 时间，所以经常会用到一种称为直接内存访问(Direct Memory Access) 的方案。为了简化，我们假设 CPU 通过单一的系统总线访问所有的设备和内存，该总线连接 CPU 、内存和 I&#x2F;O 设备，如下图所示</p>
<p><img src="https://pic4.zhimg.com/80/v2-4dd0d9ffd9a6f689646225d22b897197_720w.webp" alt="img"></p>
<p>现代操作系统实际更为复杂，但是原理是相同的。如果硬件有DMA 控制器，那么操作系统就只能使用 DMA。有时这个控制器会集成到磁盘控制器和其他控制器中，但这种设计需要在每个设备上都装有一个分离的 DMA 控制器。单个的 DMA 控制器可用于向多个设备传输，这种传输往往同时进行。</p>
<p>不管 DMA 控制器的物理地址在哪，它都能够独立于 CPU 从而访问系统总线，如上图所示。它包含几个可由 CPU 读写的寄存器，其中包括一个内存地址寄存器，字节计数寄存器和一个或多个控制寄存器。控制寄存器指定要使用的 I&#x2F;O 端口、传送方向（从 I&#x2F;O 设备读或写到 I&#x2F;O 设备）、传送单位（每次一个字节或者每次一个字）以及在一次突发传送中要传送的字节数。</p>
<p>为了解释 DMA 的工作原理，我们首先看一下如何使用 DMA 该如何进行磁盘读取。</p>
<p>首先，控制器从磁盘驱动器串行地、一位一位地读一个块（一个或多个扇区），直到将整块信息放入控制器的内部缓冲区。</p>
<p>读取校验可以保证没有发生读错误。然后控制器会产生一个中断，当操作系统开始运行时，它会重复地从控制器的缓冲区中一次一个字节或者一个字地读取该块的信息，并将其存入内存中。</p>
<h2 id="DMA-工作原理"><a href="#DMA-工作原理" class="headerlink" title="DMA 工作原理"></a>DMA 工作原理</h2><p>当使用 DMA 后面，这个过程就会变得不一样了。首先 CPU 通过设置 DMA 控制器的寄存器对它进行编程，所以 DMA 控制器知道将什么数据传送到什么地方。DMA 控制器还要向磁盘控制器发出一个命令，通知它从磁盘读数据到其内部的缓冲区并检验校验合格。当有效数据位于磁盘控制器的缓冲区中时，DMA 就可以开始了。</p>
<p>DMA 控制器通过在总线上发出一个读请求到磁盘控制器而发起 DMA 传送，这是第二步。这个读请求就像其他读请求一样，磁盘控制器并不知道或者并不关心它是来自 CPU 还是来自 DMA 控制器。通常情况下，要写的内存地址在总线的地址线上，所以当磁盘控制器去匹配下一个字时，它知道将该字写到什么地方。写到内存就是另外一个总线循环了，这是第三步。当写操作完成时，磁盘控制器在总线上发出一个应答信号到 DMA 控制器，这是第四步。</p>
<p>然后，DMA 控制器会增加内存地址并减少字节数量。如果字节数量仍然大于 0 ，就会循环步骤 2 - 步骤 4 ，直到字节计数变为 0 。此时，DMA 控制器会打断 CPU 并告诉它传输已经完成了。操作系统开始运行时，它不会把磁盘块拷贝到内存中，因为它已经在内存中了。</p>
<p>不同 DMA 控制器的复杂程度差别很大。最简单的 DMA 控制器每次处理一次传输，就像上面描述的那样。更为复杂的情况是一次同时处理很多次传输，这样的控制器内部具有多组寄存器，每个通道一组寄存器。在传输每一个字之后，DMA 控制器就决定下一次要为哪个设备提供服务。DMA 控制器可能被设置为使用 轮询算法，或者它也有可能具有一个优先级规划设计，以便让某些设备受到比其他设备更多的照顾。假如存在一个明确的方法分辨应答信号，那么在同一时间就可以挂起对不同设备控制器的多个请求。</p>
<p>许多总线能够以两种模式操作：每次一字模式和块模式。一些 DMA 控制器也能够使用这两种方式进行操作。在前一个模式中，DMA 控制器请求传送一个字并得到这个字。如果 CPU 想要使用总线，它必须进行等待。设备可能会偷偷进入并且从 CPU 偷走一个总线周期，从而轻微的延迟 CPU。这种机制称为 周期窃取(cycle stealing)。</p>
<p>在块模式中，DMA 控制器告诉设备获取总线，然后进行一系列的传输操作，然后释放总线。这一操作的形式称为 突发模式(burst mode)。这种模式要比周期窃取更有效因为获取总线占用了时间，并且一次总线获得的代价是可以同时传输多个字。缺点是如果此时进行的是长时间的突发传送，有可能将 CPU 和其他设备阻塞很长的时间。</p>
<p>在我们讨论的这种模型中，有时被称为 飞越模式(fly-by mode)，DMA 控制器会告诉设备控制器把数据直接传递到内存。一些 DMA 控制器使用的另一种模式是让设备控制器将字发送给 DMA 控制器，然后 DMA 控制器发出第二条总线请求，将字写到任何可以写入的地方。采用这种方案，每个传输的字都需要一个额外的总线周期，但是更加灵活，因为它还可以执行设备到设备的复制，甚至是内存到内存的复制（通过事先对内存进行读取，然后对内存进行写入）。</p>
<p>大部分的 DMA 控制器使用物理地址进行传输。使用物理地址需要操作系统将目标内存缓冲区的虚拟地址转换为物理地址，并将该物理地址写入 DMA 控制器的地址寄存器中。另一种方案是一些 DMA 控制器将虚拟地址写入 DMA 控制器中。然后，DMA 控制器必须使用 MMU 才能完成从虚拟到物理的转换。仅当 MMU 是内存的一部分而不是 CPU 的一部分时，才可以将虚拟地址放在总线上。</p>
<h2 id="重温中断"><a href="#重温中断" class="headerlink" title="重温中断"></a>重温中断</h2><p>在一台个人计算机体系结构中，中断结构会如下所示</p>
<p><img src="https://pic3.zhimg.com/80/v2-e261f8bfdd59b6aba2b211cb8d8199da_720w.webp" alt="img"></p>
<p>当一个 I&#x2F;O 设备完成它的工作后，它就会产生一个中断（默认操作系统已经开启中断），它通过在总线上声明已分配的信号来实现此目的。主板上的中断控制器芯片会检测到这个信号，然后执行中断操作。</p>
<p>如果在中断前没有其他中断操作阻塞的话，中断控制器将立刻对中断进行处理，如果在中断前还有其他中断操作正在执行，或者有其他设备发出级别更高的中断信号的话，那么这个设备将暂时不会处理。在这种情况下，该设备会继续在总线上置起中断信号，直到得到 CPU 服务。</p>
<p>为了处理中断，中断控制器在地址线上放置一个数字，指定要关注的设备是哪个，并声明一个信号以中断 CPU。中断信号导致 CPU 停止当前正在做的工作并且开始做其他事情。地址线上会有一个指向中断向量表 的索引，用来获取下一个程序计数器。这个新获取的程序计数器也就表示着程序将要开始，它会指向程序的开始处。一般情况下，陷阱和中断从这一点上看使用相同的机制，并且常常共享相同的中断向量。中断向量的位置可以硬连线到机器中，也可以位于内存中的任何位置，由 CPU 寄存器指向其起点。</p>
<p>中断服务程序开始运行后，中断服务程序通过将某个值写入中断控制器的 I&#x2F;O 端口来确认中断。告诉它中断控制器可以自由地发出另一个中断。通过让 CPU 延迟响应来达到多个中断同时到达 CPU 涉及到竞争的情况发生。一些老的计算机没有集中的中断控制器，通常每个设备请求自己的中断。</p>
<p>硬件通常在服务程序开始前保存当前信息。对于不同的 CPU 来说，哪些信息需要保存以及保存在哪里差别很大。不管其他的信息是否保存，程序计数器必须要被保存，这对所有的 CPU 来说都是相同的，以此来恢复中断的进程。所有可见寄存器和大量内部寄存器也应该被保存。</p>
<p>上面说到硬件应该保存当前信息，那么保存在哪里是个问题，一种选择是将其放入到内部寄存器中，在需要时操作系统可以读出这些内部寄存器。这种方法会造成的问题是：一段时间内设备无法响应，直到所有的内部寄存器中存储的信息被读出后，才能恢复运行，以免第二个内部寄存器重写内部寄存器的状态。</p>
<p>第二种方式是在堆栈中保存信息，这也是大部分 CPU 所使用的方式。但是，这种方法也存在问题，因为使用的堆栈不确定，如果使用的是当前堆栈，则它很可能是用户进程的堆栈。堆栈指针甚至不合法，这样当硬件试图在它所指的地址处写入时，将会导致致命错误。如果使用的是内核堆栈，堆栈指针是合法的并且指向一个固定的页面，这样的机会可能会更大。然而，切换到内核态需要切换 MMU 上下文，并且可能使高速缓存或者 TLB 失效。静态或动态重新装载这些东西将增加中断处理的时间，浪费 CPU 时间。</p>
<p><strong>精确中断和不精确中断</strong></p>
<p>另一个问题是：现代 CPU 大量的采用流水线并且有时还采用超标量(内部并行)。在一些老的系统中，每条指令执行完毕后，微程序或硬件将检查是否存在未完成的中断。如果存在，那么程序计数器和 PSW 将被压入堆栈中开始中断序列。在中断程序运行之后，旧的 PSW 和程序计数器将从堆栈中弹出恢复先前的进程。</p>
<p><strong>下面是一个流水线模型</strong></p>
<p><img src="https://pic3.zhimg.com/80/v2-fe8f498b4e5525c58c3d53f161b502e2_720w.webp" alt="img"></p>
<p>在流水线满的时候出现一个中断会发生什么情况？许多指令正处于不同的执行阶段，中断出现时，程序计数器的值可能无法正确地反应已经执行过的指令和尚未执行的指令的边界。事实上，许多指令可能部分执行力，不同的指令完成的程度或多或少。在这种情况下，a程序计数器更有可能反应的是将要被取出并压入流水线的下一条指令的地址，而不是刚刚被执行单元处理过的指令的地址。</p>
<p><strong>在超标量的设计中，可能更加糟糕：</strong></p>
<p><img src="https://pic2.zhimg.com/80/v2-0f96bbe09ee23d61faf596e9195df6f1_720w.webp" alt="img"></p>
<p>每个指令都可以分解成为微操作，微操作有可能乱序执行，这取决于内部资源（如功能单元和寄存器）的可用性。当中断发生时，某些很久以前启动的指令可能还没开始执行，而最近执行的指令可能将要马上完成。在中断信号出现时，可能存在许多指令处于不同的完成状态，它们与程序计数器之间没有什么关系。</p>
<p>使机器处于良好状态的中断称为精确中断(precise interrupt)。这样的中断具有四个属性：</p>
<ul>
<li>PC （程序计数器）保存在一个已知的地方</li>
<li>PC 所指向的指令之前所有的指令已经完全执行</li>
<li>PC 所指向的指令之后所有的指令都没有执行</li>
<li>PC 所指向的指令的执行状态是已知的</li>
</ul>
<p>不满足以上要求的中断称为 不精确中断(imprecise interrupt)，不精确中断让人很头疼。上图描述了不精确中断的现象。指令的执行时序和完成度具有不确定性，而且恢复起来也非常麻烦。</p>
<hr>
<p>版权声明：本文为知乎博主「玩转Linux内核」的原创文章，遵循CC 4.0 BY-SA版权协议，转载请附上原文出处链接及本声明。</p>
<p>原文链接：<a href="https://zhuanlan.zhihu.com/p/448718574">https://zhuanlan.zhihu.com/p/448718574</a></p>
]]></content>
      <categories>
        <category>linux-doc 设备驱动</category>
      </categories>
      <tags>
        <tag>Linux</tag>
      </tags>
  </entry>
  <entry>
    <title>Linux内核设备驱动硬件UART外设</title>
    <url>/2023/01/15/linux-docs/%E8%AE%BE%E5%A4%87%E9%A9%B1%E5%8A%A8/Linux%E5%86%85%E6%A0%B8%E8%AE%BE%E5%A4%87%E9%A9%B1%E5%8A%A8%E7%A1%AC%E4%BB%B6UART%E5%A4%96%E8%AE%BE/</url>
    <content><![CDATA[<p>今天给大家分享的是<strong>IAR下调试信息输出机制之硬件UART外设</strong>。</p>
<p>在嵌入式世界里，输出打印信息是一种非常常用的辅助调试手段，借助打印信息，我们可以比较容易地定位和分析程序问题。在嵌入式应用设计里实现打印信息输出的方式有很多，本系列将以 IAR 环境为例逐一介绍 ARM Cortex-M 内核 MCU 下打印信息输出方法。</p>
<p>本篇是第一篇，我们先介绍最常见的输出打印信息方式，即利用 MCU 芯片内的硬件 UART 外设。本篇其实并不是要具体介绍 UART 外设模块使用方法，而是重点分析 IAR 下是如何联系 C 标准头文件 stdio.h 定义的 printf() 函数与 UART 外设底层驱动函数的。</p>
<blockquote>
<p>Note：本文使用的 IAR EWARM 软件版本是 v9.10.2。</p>
</blockquote>
<h2 id="1、打印输出整体框图"><a href="#1、打印输出整体框图" class="headerlink" title="1、打印输出整体框图"></a><strong>1、打印输出整体框图</strong></h2><p>首先，介绍一下打印输出方法整体软硬件框图，硬件上主要是 PC 主机、MCU 目标板、一根连接线（连接线有两种方案：一种是 RS232 串口线、另一种是 TTL 串口转 USB 模块板）。</p>
<p>软件上 PC 这边需要安装一个串口调试助手软件，然后目标板 MCU 应用程序需要包含打印输出相关代码，当 MCU 程序运行起来后，驱动片内 UART 外设实现打印字符数据 (hello world.) 物理传输，在 PC 上串口调试助手软件里可以看到打印信息。</p>
<p><img src="https://pic3.zhimg.com/80/v2-79bec5c17ea37214f212e701451ab552_720w.webp" alt="img"></p>
<p>上图里的 MCU 应用程序是在 IAR 环境下编译链接的，因此我们的重点就是 stdio.h 头文件里的 printf() 在 IAR 下到底是如何与 UART 外设驱动函数“勾搭”起来的。</p>
<h2 id="2、C-标准头文件-stdio-h"><a href="#2、C-标准头文件-stdio-h" class="headerlink" title="2、C 标准头文件 stdio.h"></a><strong>2、C 标准头文件 stdio.h</strong></h2><p>熟悉嵌入式工程的朋友应该都知道 stdio.h 头文件并不在用户工程文件夹里，无需我们手动添加该文件进工程目录，该文件是 C 标准定义的头文件，由工具链自动提供。</p>
<p>stdio.h 是 C 语言为输入输出提供的标准库头文件，其前身是迈克·莱斯克 20 世纪 70 年代编写的“可移植输入输出程序库”。C 语言中的所有输入和输出都由抽象的字节流来完成，对文件的访问也通过关联的输入或输出流进行。</p>
<blockquote>
<p>stdio.h 原型：<a href="https://link.zhihu.com/?target=https://cplusplus.com/reference/cstdio/">https://cplusplus.com/reference/cstdio/</a></p>
</blockquote>
<p>大部分人学 C 语言一般都是在 Visual Studio &#x2F; C++ 环境下，在这个环境里 stdio.h 定义的那些函数底层实现都由 Visual Studio 软件直接搞定，我们通常无需关心其实现细节。</p>
<p>在嵌入式 IAR 环境下，这些标准 C 定义的头文件大部分也都是可以被支持的，我们可以在如下 IAR 软件目录找到它们，当我们在工程代码里加入 #include &lt;stdio.h&gt; 等语句时，实际上就是添加 IAR 软件目录里的文件进工程编译。</p>
<figure class="highlight text"><table><tr><td class="code"><pre><span class="line">\IAR Systems\Embedded Workbench 9.10.2\arm\inc\c\stdio.h</span><br></pre></td></tr></table></figure>

<p>但是 IAR 目录下 stdio.h 文件里定义的诸如 printf() 函数具体实现我们是需要关注的，毕竟是要编译链接生成具体机器码下载进 MCU 运行的，但是 printf() 函数原型在哪呢？我们先留个悬念。</p>
<h2 id="3、UART-外设驱动函数"><a href="#3、UART-外设驱动函数" class="headerlink" title="3、UART 外设驱动函数"></a><strong>3、UART 外设驱动函数</strong></h2><p>说到 UART 外设驱动函数，这个大家应该再熟悉不过了。我们以恩智浦 i.MXRT1060 型号（ARM Cortex-M7 内核）为例来具体介绍，在其官方 SDK 包里有相应的 LPUART 驱动文件：</p>
<figure class="highlight text"><table><tr><td class="code"><pre><span class="line">\SDK_2.11.0_EVK-MIMXRT1060\devices\MIMXRT1062\drivers\fsl_lpuart.h</span><br><span class="line">\SDK_2.11.0_EVK-MIMXRT1060\devices\MIMXRT1062\drivers\fsl_lpuart.c</span><br></pre></td></tr></table></figure>

<p>这个 LPUART 驱动库里的 LPUART_WriteBlocking() 和 LPUART_ReadBlocking() 函数可以完成用户数据包的发送和接收，其实单纯利用 LPUART_WriteBlocking() 函数也可以实现打印信息输出，只是没有 printf() 函数那样包含格式化输出的强大功能。</p>
<figure class="highlight text"><table><tr><td class="code"><pre><span class="line">status_t LPUART_Init(LPUART_Type *base, const lpuart_config_t *config, uint32_t srcClock_Hz)</span><br><span class="line">status_t LPUART_WriteBlocking(LPUART_Type *base, const uint8_t *data, size_t length)</span><br><span class="line">status_t LPUART_ReadBlocking(LPUART_Type *base, uint8_t *data, size_t length)</span><br></pre></td></tr></table></figure>

<h2 id="4、IAR-对-C-标准-I-O-库的支持"><a href="#4、IAR-对-C-标准-I-O-库的支持" class="headerlink" title="4、IAR 对 C 标准 I&#x2F;O 库的支持"></a><strong>4、IAR 对 C 标准 I&#x2F;O 库的支持</strong></h2><p>IAR 显然是对 C 标准 I&#x2F;O 库有支持的，不然我们不可能在工程里能使用 printf() 函数，只是这个支持我们如何去轻松发现呢？痞子衡今天教大家一个方法，就是看工程编译链接后生成的 .map 文件，这个 map 文件里会列出工程里所有函数的来源。</p>
<h3 id="4-1引出底层接口-write"><a href="#4-1引出底层接口-write" class="headerlink" title="4.1引出底层接口 __write()"></a><strong>4.1引出底层接口 __write()</strong></h3><p>我们以 \SDK_2.11.0_EVK-MIMXRT1060\boards\evkmimxrt1060\demo_apps\hello_world\iar 工程为例来介绍，需要简单改造一下工程里 hello_world.c 文件里的 main() 函数，将原来代码全部删掉（原来的打印输出涉及恩智浦 SDK 封装，本文没必要关心其实现），只要如下一句打印即可：</p>
<figure class="highlight text"><table><tr><td class="code"><pre><span class="line">#include &lt;stdio.h&gt;</span><br><span class="line">int main(void)</span><br><span class="line">&#123;</span><br><span class="line">    printf(&quot;hello world.\r\n&quot;);</span><br><span class="line">    while (1);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>然后注意工程选项里跟 Library 实现相关的如下三处设置。其中 <strong>Library</strong> 选项配置的是 runtime lib 的功能，有 Normal 和 Full 两个选项（可按需选择）；<strong>Printf formatter</strong> 选项决定格式化输出功能细节，分 Full、Large、Small、Tiny 四个选项（可按需选择）。</p>
<p><strong>Library low-level interface implementation</strong> 选项决定低层 I&#x2F;O 实现，这里我们选 None，即由用户来实现。</p>
<p><img src="https://pic1.zhimg.com/80/v2-2417b372d998a4473700b9575edc923c_720w.webp" alt="img"></p>
<p>配置好 Library 后编译工程会发现有如下报错，根据这个报错我们可以猜到 dl7M_tln.a 是 IAR 编译好的 C&#x2F;C++ 库，库里面实现了 printf() 函数及其所依赖的 putchar() 函数，而 puchar() 函数对外提供了底层 I&#x2F;O 接口函数，这个 I&#x2F;O 函数名字叫 __write()，它就是需要用户结合芯片 UART 外设去实现的发送函数。</p>
<figure class="highlight text"><table><tr><td class="code"><pre><span class="line">Error[Li005]: no definition for &quot;__write&quot; [referenced from putchar.o(dl7M_tln.a)]</span><br></pre></td></tr></table></figure>

<p>在 IAR 目录下我们可以找到 dl7M_tln.a 文件路径，经过测试，工程 <strong>Library</strong> 设置里 Normal 和 Full 选项其实就是选 dl7M_tln.a 还是 dl7M_tlf.a 进用户工程去链接。</p>
<p><img src="https://pic1.zhimg.com/80/v2-9c0c3c06803d513796a2f701d6209d58_720w.webp" alt="img"></p>
<h3 id="4-2DLIB底层-I-O-接口设计"><a href="#4-2DLIB底层-I-O-接口设计" class="headerlink" title="4.2DLIB底层 I&#x2F;O 接口设计"></a><strong>4.2DLIB底层 I&#x2F;O 接口设计</strong></h3><p>找到了 __write() 函数，但是它的原型到底是什么？我们该如何实现它？这时候需要去查万能的 \IAR Systems\Embedded Workbench 9.10.2\arm\doc\EWARM_DevelopmentGuide.ENU 手册，在里面搜索 __write 字样可以找到如下设计，原来我们在代码里调用的 C 标准 I&#x2F;O 接口均是由 IAR 底层预编译好的 DLIB 去具体实现的，这个 DLIB 库也留下了给用户实现的最底层与硬件相关的接口函数。</p>
<p><img src="https://pic1.zhimg.com/80/v2-ad69a3c14d92c80e6add86cb19d76eb0_720w.webp" alt="img"></p>
<p>IAR 为 DLIB 里那些最底层的 I&#x2F;O 接口函数都创建了模板源文件，在这些模板文件里我们可以找到它们的原型，所以我们在 write.c 文件里找到了 __write() 原型及其示例实现。</p>
<figure class="highlight text"><table><tr><td class="code"><pre><span class="line">size_t __write(int handle, const unsigned char * buffer, size_t size)</span><br></pre></td></tr></table></figure>

<p><img src="https://pic1.zhimg.com/80/v2-b53770f7edd58593a4f397555096b928_720w.webp" alt="img"></p>
<h3 id="4-3DLIB库-I-O-相关源码实现"><a href="#4-3DLIB库-I-O-相关源码实现" class="headerlink" title="4.3DLIB库 I&#x2F;O 相关源码实现"></a><strong>4.3DLIB库 I&#x2F;O 相关源码实现</strong></h3><p>有了 __write() 原型及示例代码，我们很容易便能用 LPUART_WriteBlocking() 函数去实现它，将这个代码添加进 hello_world 工程编译，这时候就不会报错了（当然要想真正在板子上测试打印功能，main 函数里还得加入 LPUART 初始化代码）。</p>
<figure class="highlight text"><table><tr><td class="code"><pre><span class="line">#include &quot;fsl_lpuart.h&quot;</span><br><span class="line">size_t __write(int handle, const unsigned char *buf, size_t size)</span><br><span class="line">&#123;</span><br><span class="line">    // 假设使用 LPUART1 去做输出</span><br><span class="line">    (void)LPUART_WriteBlocking(LPUART1, buf, size);</span><br><span class="line"></span><br><span class="line">    return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>工程编译完成后，查看生成的 hello_world.map 文件，找到 dl7M_tln.a 部分的信息，可以看到其由很多个 .o 文件组成（功能比较丰富），这些 .o 文件都是可以在 IAR 安装目录下找到其源码的。</p>
<figure class="highlight text"><table><tr><td class="code"><pre><span class="line">*******************************************************************************</span><br><span class="line">*** MODULE SUMMARY</span><br><span class="line">***</span><br><span class="line"></span><br><span class="line">    Module                ro code  ro data  rw data</span><br><span class="line">    ------                -------  -------  -------</span><br><span class="line">dl7M_tln.a: [10]</span><br><span class="line">    abort.o                     6</span><br><span class="line">    exit.o                      4</span><br><span class="line">    low_level_init.o            4</span><br><span class="line">    printf.o                   40</span><br><span class="line">    putchar.o                  32</span><br><span class="line">    xfail_s.o                  64                 4</span><br><span class="line">    xprintfsmall_nomb.o     1&#x27;281</span><br><span class="line">    xprout.o                   22</span><br><span class="line">    -----------------------------------------------</span><br><span class="line">    Total:                  1&#x27;453                 4</span><br></pre></td></tr></table></figure>

<p>DLIB 库中关于 I&#x2F;O 相关的源码放在了如下目录里，感兴趣的可以去查看其具体实现，这里特别提一下 formatter 文件夹下 xprintf 有很多种不同的源文件实现，其实就对应了工程选项 <strong>Printf formatter</strong> 里的不同配置。</p>
<figure class="highlight text"><table><tr><td class="code"><pre><span class="line">\IAR Systems\Embedded Workbench 9.10.2\arm\src\lib\dlib\file</span><br><span class="line">\IAR Systems\Embedded Workbench 9.10.2\arm\src\lib\dlib\formatters</span><br></pre></td></tr></table></figure>

<p><img src="https://pic4.zhimg.com/80/v2-042ef8125c5e923c3f5f185a28967bd7_720w.webp" alt="img"></p>
<p>至此，IAR下调试信息输出机制之硬件UART外设痞子衡便介绍完毕了。</p>
<hr>
<p>版权声明：本文为知乎博主「Linux内核库」的原创文章，遵循CC 4.0 BY-SA版权协议，转载请附上原文 出处链接及本声明。  </p>
<p>原文链接：<a href="https://zhuanlan.zhihu.com/p/586298947">https://zhuanlan.zhihu.com/p/586298947</a></p>
]]></content>
      <categories>
        <category>linux-doc 设备驱动</category>
      </categories>
      <tags>
        <tag>Linux</tag>
      </tags>
  </entry>
  <entry>
    <title>Linux内核设备驱动设备树概念与使用</title>
    <url>/2023/01/15/linux-docs/%E8%AE%BE%E5%A4%87%E9%A9%B1%E5%8A%A8/Linux%E5%86%85%E6%A0%B8%E8%AE%BE%E5%A4%87%E9%A9%B1%E5%8A%A8%E8%AE%BE%E5%A4%87%E6%A0%91%E6%A6%82%E5%BF%B5%E4%B8%8E%E4%BD%BF%E7%94%A8/</url>
    <content><![CDATA[<h2 id="一、设备树概念以及作用"><a href="#一、设备树概念以及作用" class="headerlink" title="一、设备树概念以及作用"></a>一、设备树概念以及作用</h2><h3 id="1-1设备树概念"><a href="#1-1设备树概念" class="headerlink" title="1.1设备树概念"></a>1.1设备树概念</h3><p>设备树(Device Tree)，将这个词分开就是“设备”和“树”，描述设备树的文件叫做 DTS(DeviceTree Source)，这个 DTS 文件采用树形结构描述板级设备，也就是开发板上的设备信息，比如CPU 数量、 内存基地址、 IIC 接口上接了哪些设备、 SPI 接口上接了哪些设备等等，如图 所示：</p>
<p><img src="https://pic3.zhimg.com/80/v2-8c62b3fc1d129b2298119383693a465a_720w.webp" alt="img"></p>
<p>在图中，树的主干就是系统总线， IIC 控制器、 GPIO 控制器、 SPI 控制器等都是接到系统主线上的分支。IIC 控制器有分为 IIC1 和 IIC2 两种，其中 IIC1 上接了 FT5206 和 AT24C02这两个 IIC 设备， IIC2 上只接了 MPU6050 这个设备。 DTS 文件的主要功能就是按照图所示的结构来描述板子上的设备信息， DTS 文件描述设备信息是有相应的语法规则要求的，稍后我们会详细的讲解 DTS 语法规则。</p>
<h3 id="1-2设备树引用以及概念"><a href="#1-2设备树引用以及概念" class="headerlink" title="1.2设备树引用以及概念"></a>1.2设备树引用以及概念</h3><p>以LED驱动为例，如果你要更换LED所用的GPIO引脚，需要修改驱动程序源码、重新编译驱动、重新加载驱动。</p>
<p>在内核中，使用同一个芯片的板子，它们所用的外设资源不一样，比如A板用GPIO A，B板用GPIO B。而GPIO的驱动程序既支持GPIO A也支持GPIO B，你需要指定使用哪一个引脚，怎么指定？在c代码中指定。</p>
<p>随着ARM芯片的流行，内核中针对这些ARM板保存有大量的、没有技术含量的文件。</p>
<p>Linus大发雷霆：”this whole ARM thing is a f*cking pain in the ass”。</p>
<p>于是，Linux内核开始引入设备树。设备树并不是重新发明出来的，在Linux内核中其他平台如PowerPC，早就使用设备树来描述硬件了。</p>
<p>Linus发火之后，内核开始全面使用设备树来改造，神人就神人。</p>
<p>&#x2F;sys&#x2F;firmware&#x2F;devicetree目录下是以目录结构程现的dtb文件, 根节点对应base目录, 每一个节点对应一个目录, 每一个属性对应一个文件。</p>
<p>这些属性的值如果是字符串，可以用cat命令把它打印出来；对于数值，可以用hexdump把它打印出来。</p>
<p>一个单板启动时，u-boot先运行，它的作用是启动内核。U-boot会把内核和设备树文件都读入内存，然后启动内核。在启动内核时会把设备树在内存中的地址告诉内核。</p>
<p><img src="https://pic2.zhimg.com/80/v2-c6f80070f43787af7d164bde5229a005_720w.webp" alt="img"></p>
<h3 id="1-3设备树名词关系"><a href="#1-3设备树名词关系" class="headerlink" title="1.3设备树名词关系"></a>1.3设备树名词关系</h3><p>设备树源文件扩展名为.dts，但是我们在前面移植 Linux 的时候却一直在使用.dtb 文件，那么 DTS 和 DTB 这两个文件是什么关系呢？ DTS 是设备树源码文件， DTB 是将DTS 编译以后得到的二进制文件。将.c 文件编译为.o 需要用到 gcc 编译器，那么将.dts 编译为.dtb需要什么工具呢？需要用到 DTC 工具！ DTC 工具源码在 Linux 内核的 scripts&#x2F;dtc 目录下.另外dtsi就相当于C语言的.h文件的概念</p>
<h2 id="二、设备树语法"><a href="#二、设备树语法" class="headerlink" title="二、设备树语法"></a>二、设备树语法</h2><h3 id="2-1Device格式"><a href="#2-1Device格式" class="headerlink" title="2.1Device格式"></a>2.1Device格式</h3><p><strong>DTS文件格式</strong></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">/dts-v1/;                // 表示版本</span><br><span class="line">[memory reservations]    // 格式为: /memreserve/ &lt;address&gt; &lt;length&gt;;</span><br><span class="line">/ &#123;</span><br><span class="line">    [property definitions]</span><br><span class="line">    [child nodes]</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p><strong>node格式</strong></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">设备树中的基本单元，被称为“node”，其格式为：</span><br><span class="line"></span><br><span class="line">[label:] node-name[@unit-address] &#123;</span><br><span class="line">    [properties definitions]</span><br><span class="line">    [child nodes]</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>label是标号，可以省略。label的作用是为了方便地引用node，比如：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">/dts-v1/;</span><br><span class="line">/ &#123;</span><br><span class="line">    uart0: uart@fe001000 &#123;</span><br><span class="line">        compatible=&quot;ns16550&quot;;</span><br><span class="line">        reg=&lt;0xfe001000 0x100&gt;;</span><br><span class="line">    &#125;;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>可以使用下面2种方法来修改uart@fe001000这个node：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">1. *</span><br><span class="line">   // 在根节点之外使用label引用node：*</span><br><span class="line">2. &amp;uart0 &#123;</span><br><span class="line">3. ​    status = “disabled”;</span><br><span class="line">4. &#125;;</span><br><span class="line">5. *//在根节点之外使用全路径：*</span><br><span class="line">6. &amp;&#123;/uart@fe001000&#125;  &#123;</span><br><span class="line">7. ​    status = “disabled”;</span><br></pre></td></tr></table></figure>

<p>可以使用下面2种方法来修改uart@fe001000这个node：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">// 在根节点之外使用label引用node：</span><br><span class="line">&amp;uart0 &#123;</span><br><span class="line">    status = “disabled”;</span><br><span class="line">&#125;;</span><br><span class="line">//在根节点之外使用全路径：</span><br><span class="line">&amp;&#123;/uart@fe001000&#125;  &#123;</span><br><span class="line">    status = “disabled”;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h3 id="2-2常用属性-properties"><a href="#2-2常用属性-properties" class="headerlink" title="2.2常用属性(properties)"></a>2.2常用属性(properties)</h3><p>简单地说，properties就是“name&#x3D;value”，value有多种取值方式。</p>
<p><strong>Property格式1:</strong></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">[label:] property-name = value;</span><br></pre></td></tr></table></figure>

<p><strong>Property格式2(没有值):</strong></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">[label:] property-name;</span><br></pre></td></tr></table></figure>

<p><strong>Property取值只有3种:</strong></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">arrays of cells(1个或多个32位数据, 64位数据使用2个32位数据表示), </span><br><span class="line">string(字符串), </span><br><span class="line">bytestring(1个或多个字节)</span><br></pre></td></tr></table></figure>

<h3 id="2-3-address-cells、-size-cells"><a href="#2-3-address-cells、-size-cells" class="headerlink" title="2.3#address-cells、#size-cells"></a>2.3#address-cells、#size-cells</h3><p>cell指一个32位的数值，</p>
<p>address-cells：address要用多少个32位数来表示；</p>
<p>size-cells：size要用多少个32位数来表示。</p>
<p>比如一段内存，怎么描述它的起始地址和大小？</p>
<p>下例中，address-cells为1，所以reg中用1个数来表示地址，即用0x80000000来表示地址；size-cells为1，所以reg中用1个数来表示大小，即用0x20000000表示大小：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">/ &#123;</span><br><span class="line">#address-cells = &lt;1&gt;;</span><br><span class="line">#size-cells = &lt;1&gt;;</span><br><span class="line">memory &#123;</span><br><span class="line">reg = &lt;0x80000000 0x20000000&gt;;</span><br><span class="line">    &#125;;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h3 id="2-2-compatible"><a href="#2-2-compatible" class="headerlink" title="2.2 compatible"></a>2.2 compatible</h3><p>“compatible”表示“兼容”，对于某个LED，内核中可能有A、B、C三个驱动都支持它，可以这样写：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">led &#123;</span><br><span class="line">compatible = “A”, “B”, “C”;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>内核启动时，就会为这个LED按这样的优先顺序为它找到驱动程序：A、B、C。</p>
<p>根节点下也有compatible属性，用来选择哪一个“machine desc”：一个内核可以支持machine A，也支持machine B，内核启动后会根据根节点的compatible属性找到对应的machine desc结构体，执行其中的初始化函数。</p>
<p>compatible的值，建议取这样的形式：”manufacturer,model”，即“厂家名,模块名”。</p>
<p>比如：compatible &#x3D; “fsl,imx6ull-gpmi-nand”, “fsl, imx6ul-gpmi-nand”;</p>
<p>注意：machine desc的意思就是“机器描述”，学到内核启动流程时才涉及。</p>
<h3 id="2-4model"><a href="#2-4model" class="headerlink" title="2.4model"></a>2.4model</h3><p>model属性与compatible属性有些类似，但是有差别。</p>
<p>compatible属性是一个字符串列表，表示可以你的硬件兼容A、B、C等驱动；</p>
<p>model用来准确地定义这个硬件是什么。</p>
<p>比如根节点中可以这样写：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">/ &#123;</span><br><span class="line">    compatible = &quot;samsung,smdk2440&quot;, &quot;samsung,mini2440&quot;;</span><br><span class="line">    model = &quot;jz2440_v3&quot;;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>它表示这个单板，可以兼容内核中的“smdk2440”，也兼容“mini2440”。</p>
<p>从compatible属性中可以知道它兼容哪些板，但是它到底是什么板？用model属性来明确。</p>
<h3 id="2-5status"><a href="#2-5status" class="headerlink" title="2.5status"></a>2.5status</h3><p>dtsi文件中定义了很多设备，但是在你的板子上某些设备是没有的。这时你可以给这个设备节点添加一个status属性，设置为“disabled”：</p>
<p><img src="https://pic4.zhimg.com/80/v2-4f3750a5c508253e807e6c870ee44b7b_720w.webp" alt="img"></p>
<h3 id="2-6reg"><a href="#2-6reg" class="headerlink" title="2.6reg"></a>2.6reg</h3><p>reg的本意是register，用来表示寄存器地址。</p>
<p>但是在设备树里，它可以用来描述一段空间。反正对于ARM系统，寄存器和内存是统一编址的，即访问寄存器时用某块地址，访问内存时用某块地址，在访问方法上没有区别。</p>
<p>reg属性的值，是一系列的“address size”，用多少个32位的数来表示address和size，由其父节点的#address-cells、#size-cells决定。</p>
<p>示例：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">/dts-v1/;</span><br><span class="line">/ &#123;</span><br><span class="line">#address-cells = &lt;1&gt;;</span><br><span class="line">#size-cells = &lt;1&gt;; </span><br><span class="line">memory &#123;</span><br><span class="line">reg = &lt;0x80000000 0x20000000&gt;;</span><br><span class="line">&#125;;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h3 id="2-7name-过时了，建议不用"><a href="#2-7name-过时了，建议不用" class="headerlink" title="2.7name(过时了，建议不用)"></a>2.7name(过时了，建议不用)</h3><p>它的值是字符串，用来表示节点的名字。在跟platform_driver匹配时，优先级最低。</p>
<p>compatible属性在匹配过程中，优先级最高。</p>
<h3 id="2-8device-type-过时了，建议不用"><a href="#2-8device-type-过时了，建议不用" class="headerlink" title="2.8device_type(过时了，建议不用)"></a>2.8device_type(过时了，建议不用)</h3><p>它的值是字符串，用来表示节点的类型。在跟platform_driver匹配时，优先级为中。</p>
<p>compatible属性在匹配过程中，优先级最高。</p>
<h2 id="3、常用节点"><a href="#3、常用节点" class="headerlink" title="3、常用节点"></a>3、常用节点</h2><h3 id="3-1跟节点"><a href="#3-1跟节点" class="headerlink" title="3.1跟节点"></a>3.1跟节点</h3><p>dts文件中必须有一个根节点：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">/dts-v1/;</span><br><span class="line">/ &#123;</span><br><span class="line">model = &quot;SMDK24440&quot;;</span><br><span class="line">compatible = &quot;samsung,smdk2440&quot;;</span><br><span class="line"> </span><br><span class="line">#address-cells = &lt;1&gt;;</span><br><span class="line">#size-cells = &lt;1&gt;; </span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>根节点中必须有这些属性：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">#address-cells // 在它的子节点的reg属性中, 使用多少个u32整数来描述地址(address)</span><br><span class="line">#size-cells   // 在它的子节点的reg属性中, 使用多少个u32整数来描述大小(size)</span><br><span class="line">compatible   // 定义一系列的字符串, 用来指定内核中哪个machine_desc可以支持本设备</span><br><span class="line">            // 即这个板子兼容哪些平台 </span><br><span class="line">            // uImage : smdk2410 smdk2440 mini2440     ==&gt; machine_desc         </span><br><span class="line">                 </span><br><span class="line">model       // 咱这个板子是什么</span><br><span class="line">            // 比如有2款板子配置基本一致, 它们的compatible是一样的</span><br><span class="line">            // 那么就通过model来分辨这2款板子</span><br></pre></td></tr></table></figure>

<h3 id="3-2CPU节点"><a href="#3-2CPU节点" class="headerlink" title="3.2CPU节点"></a>3.2CPU节点</h3><p>一般不需要我们设置，在dtsi文件中都定义好了：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">cpus &#123;</span><br><span class="line">        <span class="meta">#address-cells = <span class="string">&lt;1&gt;</span>;</span></span><br><span class="line">        <span class="meta">#size-cells = <span class="string">&lt;0&gt;</span>;</span></span><br><span class="line"> </span><br><span class="line">        cpu0: cpu@<span class="number">0</span> &#123;</span><br><span class="line">            .......</span><br><span class="line">        &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h3 id="3-3-memory节点"><a href="#3-3-memory节点" class="headerlink" title="3.3 memory节点"></a>3.3 memory节点</h3><p>芯片厂家不可能事先确定你的板子使用多大的内存，所以memory节点需要板厂设置，比如：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">memory &#123;</span><br><span class="line">reg = &lt;<span class="number">0x80000000</span> <span class="number">0x20000000</span>&gt;;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h3 id="3-4-chosen节点"><a href="#3-4-chosen节点" class="headerlink" title="3.4 chosen节点"></a>3.4 chosen节点</h3><p>我们可以通过设备树文件给内核传入一些参数，这要在chosen节点中设置bootargs属性：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">chosen &#123;</span><br><span class="line">bootargs = <span class="string">&quot;noinitrd root=/dev/mtdblock4 rw init=/linuxrc console=ttySAC0,115200&quot;</span>;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>3.5 aliases 子节点<br>单词 aliases 的意思是“别名”，因此 aliases 节点的主要功能就是定义别名，定义别名的目的就是为了方便访问节点。不过我们一般会在节点命名的时候会加上 label，然后通过&amp;label来访问节点，这样也很方便，而且设备树里面大量的使用&amp;label 的形式来访问节点。</p>
<p>打开 imx6ull.dtsi 文件， aliases 节点内容如下所示：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">aliases &#123;</span><br><span class="line"> can0 = &amp;flexcan1;</span><br><span class="line"> can1 = &amp;flexcan2;</span><br><span class="line"> ethernet0 = &amp;fec1;</span><br><span class="line"> ethernet1 = &amp;fec2;</span><br><span class="line"> gpio0 = &amp;gpio1;</span><br><span class="line"> gpio1 = &amp;gpio2;</span><br><span class="line">....</span><br><span class="line"> spi0 = &amp;ecspi1;</span><br><span class="line"> spi1 = &amp;ecspi2;</span><br><span class="line"> spi2 = &amp;ecspi3;</span><br><span class="line"> spi3 = &amp;ecspi4;</span><br><span class="line"> usbphy0 = &amp;usbphy1;</span><br><span class="line"> usbphy1 = &amp;usbphy2;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h2 id="4、设备树使用"><a href="#4、设备树使用" class="headerlink" title="4、设备树使用"></a>4、设备树使用</h2><h3 id="4-1编译设备树"><a href="#4-1编译设备树" class="headerlink" title="4.1编译设备树"></a>4.1编译设备树</h3><p>make dtbs</p>
<h3 id="4-2开发板使用设备树"><a href="#4-2开发板使用设备树" class="headerlink" title="4.2开发板使用设备树"></a>4.2开发板使用设备树</h3><p>我们来修改下一个设备树，在跟节点中增加一个测试节点</p>
<h4 id="4-1-1测试节点编写"><a href="#4-1-1测试节点编写" class="headerlink" title="4.1.1测试节点编写"></a>4.1.1测试节点编写</h4><p><img src="https://pic4.zhimg.com/80/v2-58cceeabd35a47fd5b9370fbb07f249b_720w.webp" alt="img"></p>
<h4 id="4-1-2编译dtbs"><a href="#4-1-2编译dtbs" class="headerlink" title="4.1.2编译dtbs"></a>4.1.2编译dtbs</h4><p><img src="https://pic1.zhimg.com/80/v2-ffeb86495e0de8b85a4cc9bcae7f20bc_720w.webp" alt="img"></p>
<h3 id="4-3通过配置tftp-boot"><a href="#4-3通过配置tftp-boot" class="headerlink" title="4.3通过配置tftp boot"></a>4.3通过配置tftp boot</h3><p>bootcmd以及bootargs配置为</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">setenv bootargs &#x27;console=ttymxc0,115200 root=/dev/mmcblk1p2 rootwait rw&#x27;</span><br><span class="line">setenv bootcmd &#x27;mmc dev 1; fatload mmc 1:1 80800000 zImage; fatload mmc 1:1 83000000</span><br><span class="line">imx6ull-alientek-emmc.dtb; bootz 80800000 - 83000000;</span><br><span class="line">saveenv</span><br></pre></td></tr></table></figure>

<h3 id="4-4板子启动后查看设备树信息"><a href="#4-4板子启动后查看设备树信息" class="headerlink" title="4.4板子启动后查看设备树信息"></a>4.4板子启动后查看设备树信息</h3><p><img src="https://pic4.zhimg.com/80/v2-2c42456af3559c855d1654a38618fa0b_720w.webp" alt="img"></p>
<p><img src="https://pic4.zhimg.com/80/v2-586e07a65c8d7e8e2e751e50b9ea9cbb_720w.webp" alt="img"></p>
<h2 id="5、内核操作设备树的函数"><a href="#5、内核操作设备树的函数" class="headerlink" title="5、内核操作设备树的函数"></a>5、内核操作设备树的函数</h2><p>设备树描述了设备的详细信息，这些信息包括数字类型的、字符串类型的、数组类型的，我们在编写驱动的时候需要获取到这些信息。比如设备树使用 reg 属性描述了某个外设的寄存器地址为 0X02005482，长度为 0X400，我们在编写驱动的时候需要获取到 reg 属性的 0X02005482 和 0X400 这两个值，然后初始化外设。 Linux 内核给我们提供了一系列的函数来获取设备树中的节点或者属性信息，这一系列的函数都有一个统一的前缀“of_”，所以在很多资料里面也被叫做 OF 函数。这些 OF 函数原型都定义在 include&#x2F;linux&#x2F;of.h 文件中。</p>
<h3 id="5-1查找节点的-OF-函数"><a href="#5-1查找节点的-OF-函数" class="headerlink" title="5.1查找节点的 OF 函数"></a>5.1查找节点的 OF 函数</h3><p>设备都是以节点的形式“挂”到设备树上的，因此要想获取这个设备的其他属性信息，必须先获取到这个设备的节点。 Linux 内核使用 device_node 结构体来描述一个节点，此结构体定义在文件 include&#x2F;linux&#x2F;of.h 中，定义如下：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"> struct device_node &#123;</span><br><span class="line">    const char *name;                    /* 节点名字 */</span><br><span class="line">    const char *type;                    /* 设备类型 */</span><br><span class="line">    phandle phandle;</span><br><span class="line">    const char *full_name;                /* 节点全名 */</span><br><span class="line">    struct fwnode_handle fwnode;</span><br><span class="line"> </span><br><span class="line">    struct    property *properties;        /* 属性 */</span><br><span class="line">    struct    property *deadprops;        /* removed 属性 */</span><br><span class="line">    struct    device_node *parent;        /* 父节点 */</span><br><span class="line">    struct    device_node *child;            /* 子节点 */</span><br><span class="line">    struct    device_node *sibling;</span><br><span class="line">    struct    kobject kobj;</span><br><span class="line">    unsigned long _flags;</span><br><span class="line">    void    *data;</span><br><span class="line">#if defined(CONFIG_SPARC)</span><br><span class="line">    const char *path_component_name;</span><br><span class="line">    unsigned int unique_id;</span><br><span class="line">    struct of_irq_controller *irq_trans;</span><br><span class="line">#endif</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>与查找节点有关的 OF 函数有 5 个，我们依次来看一下。</p>
<h4 id="5-1of-find-node-by-name-函数"><a href="#5-1of-find-node-by-name-函数" class="headerlink" title="5.1of_find_node_by_name 函数"></a>5.1of_find_node_by_name 函数</h4><p>of_find_node_by_name 函数通过节点名字查找指定的节点，函数原型如下：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">struct device_node *of_find_node_by_name(struct device_node *from,const char *name);</span><br></pre></td></tr></table></figure>

<p>from：开始查找的节点，如果为 NULL 表示从根节点开始查找整个设备树。</p>
<p>name：要查找的节点名字。</p>
<p>返回值： 找到的节点，如果为 NULL 表示查找失败。</p>
<h4 id="5-2of-find-node-by-type-函数"><a href="#5-2of-find-node-by-type-函数" class="headerlink" title="5.2of_find_node_by_type 函数"></a>5.2of_find_node_by_type 函数</h4><p>of_find_node_by_type 函数通过 device_type 属性查找指定的节点，函数原型如下：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">struct device_node *of_find_node_by_type(struct device_node *from, const char *type)</span><br></pre></td></tr></table></figure>

<p>from：开始查找的节点，如果为 NULL 表示从根节点开始查找整个设备树。</p>
<p>type：要查找的节点对应的 type 字符串，也就是 device_type 属性值。</p>
<p>返回值： 找到的节点，如果为 NULL 表示查找失败。</p>
<h4 id="5-3of-find-compatible-node-函数"><a href="#5-3of-find-compatible-node-函数" class="headerlink" title="5.3of_find_compatible_node 函数"></a>5.3of_find_compatible_node 函数</h4><p>of_find_compatible_node 函数根据 device_type 和 compatible 这两个属性查找指定的节点，</p>
<p>函数原型如下：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">struct device_node *of_find_compatible_node(struct device_node *from,</span><br><span class="line">                                            const char *type,</span><br><span class="line">                                            const char *compatible)</span><br></pre></td></tr></table></figure>

<p>from：开始查找的节点，如果为 NULL 表示从根节点开始查找整个设备树。</p>
<p>type：要查找的节点对应的 type 字符串，也就是 device_type 属性值，可以为 NULL，表示</p>
<p>忽略掉 device_type 属性。</p>
<p>compatible： 要查找的节点所对应的 compatible 属性列表。</p>
<p>返回值： 找到的节点，如果为 NULL 表示查找失败</p>
<h4 id="5-4of-find-matching-node-and-match-函数"><a href="#5-4of-find-matching-node-and-match-函数" class="headerlink" title="5.4of_find_matching_node_and_match 函数"></a>5.4of_find_matching_node_and_match 函数</h4><p>of_find_matching_node_and_match 函数通过 of_device_id 匹配表来查找指定的节点，函数原</p>
<p>型如下：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">struct device_node *of_find_matching_node_and_match(struct device_node *from,</span><br><span class="line">                                                    const struct of_device_id *matches,</span><br><span class="line">                                                    const struct of_device_id **match)</span><br></pre></td></tr></table></figure>

<p>from：开始查找的节点，如果为 NULL 表示从根节点开始查找整个设备树。</p>
<p>matches： of_device_id 匹配表，也就是在此匹配表里面查找节点。</p>
<p>match： 找到的匹配的 of_device_id。</p>
<p>返回值： 找到的节点，如果为 NULL 表示查找失败</p>
<h4 id="5-5of-find-node-by-path-函数"><a href="#5-5of-find-node-by-path-函数" class="headerlink" title="5.5of_find_node_by_path 函数"></a>5.5of_find_node_by_path 函数</h4><p>of_find_node_by_path 函数通过路径来查找指定的节点，函数原型如下：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">inline struct device_node *of_find_node_by_path(const char *path)</span><br></pre></td></tr></table></figure>

<p>path：带有全路径的节点名，可以使用节点的别名，比如“&#x2F;backlight”就是 backlight 这个</p>
<p>节点的全路径。</p>
<p>返回值： 找到的节点，如果为 NULL 表示查找失败</p>
<h3 id="5-2查找父-子节点的-OF-函数"><a href="#5-2查找父-子节点的-OF-函数" class="headerlink" title="5.2查找父&#x2F;子节点的 OF 函数"></a>5.2查找父&#x2F;子节点的 OF 函数</h3><p>Linux 内核提供了几个查找节点对应的父节点或子节点的 OF 函数，我们依次来看一下。</p>
<h4 id="5-2-1of-get-parent-函数"><a href="#5-2-1of-get-parent-函数" class="headerlink" title="5.2.1of_get_parent 函数"></a>5.2.1of_get_parent 函数</h4><p>of_get_parent 函数用于获取指定节点的父节点(如果有父节点的话)，函数原型如下：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">struct device_node *of_get_parent(const struct device_node *node)</span><br></pre></td></tr></table></figure>

<p>node：要查找的父节点的节点。</p>
<p>返回值： 找到的父节点。</p>
<h4 id="5-2-2of-get-next-child-函数"><a href="#5-2-2of-get-next-child-函数" class="headerlink" title="5.2.2of_get_next_child 函数"></a>5.2.2of_get_next_child 函数</h4><p>of_get_next_child 函数用迭代的查找子节点，函数原型如下：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">struct device_node *of_get_next_child(const struct device_node *node,</span><br><span class="line">                                    struct device_node *prev)</span><br></pre></td></tr></table></figure>

<p>node：父节点。</p>
<p>prev：前一个子节点，也就是从哪一个子节点开始迭代的查找下一个子节点。可以设置为</p>
<p>NULL，表示从第一个子节点开始。</p>
<p>返回值： 找到的下一个子节点。</p>
<h3 id="5-3提取属性值的-OF-函数"><a href="#5-3提取属性值的-OF-函数" class="headerlink" title="5.3提取属性值的 OF 函数"></a>5.3提取属性值的 OF 函数</h3><p>节点的属性信息里面保存了驱动所需要的内容，因此对于属性值的提取非常重要， Linux 内核中使用结构体 property 表示属性，此结构体同样定义在文件 include&#x2F;linux&#x2F;of.h 中，内容如下：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">struct property &#123;</span><br><span class="line">    char    *name;                /* 属性名字 */</span><br><span class="line">    int    length;                    /* 属性长度 */</span><br><span class="line">    void    *value;                /* 属性值 */</span><br><span class="line">    struct property *next;        /* 下一个属性 */</span><br><span class="line">    unsigned long _flags;</span><br><span class="line">    unsigned int unique_id;</span><br><span class="line">    struct bin_attribute attr;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>Linux 内核也提供了提取属性值的 OF 函数，我们依次来看一下</p>
<h4 id="5-3-1of-find-property-函数"><a href="#5-3-1of-find-property-函数" class="headerlink" title="5.3.1of_find_property 函数"></a>5.3.1of_find_property 函数</h4><p>of_find_property 函数用于查找指定的属性，函数原型如下</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">property *of_find_property(const struct device_node *np,</span><br><span class="line">                            const char *name,</span><br><span class="line">                            int *lenp)</span><br></pre></td></tr></table></figure>

<p>np：设备节点。</p>
<p>name： 属性名字。</p>
<p>lenp：属性值的字节数</p>
<p>返回值： 找到的属性</p>
<h4 id="5-3-2of-property-count-elems-of-size-函数"><a href="#5-3-2of-property-count-elems-of-size-函数" class="headerlink" title="5.3.2of_property_count_elems_of_size 函数"></a>5.3.2of_property_count_elems_of_size 函数</h4><p>of_property_count_elems_of_size 函数用于获取属性中元素的数量，比如 reg 属性值是一个</p>
<p>数组，那么使用此函数可以获取到这个数组的大小，此函数原型如下：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">int of_property_count_elems_of_size(const struct device_node *np,</span><br><span class="line">                                    const char *propname,</span><br><span class="line">                                    int elem_size)</span><br></pre></td></tr></table></figure>

<p>np：设备节点。</p>
<p>proname： 需要统计元素数量的属性名字。</p>
<p>elem_size：元素长度。</p>
<p>返回值： 得到的属性元素数量。</p>
<h4 id="5-3-3of-property-read-u32-index-函数"><a href="#5-3-3of-property-read-u32-index-函数" class="headerlink" title="5.3.3of_property_read_u32_index 函数"></a>5.3.3of_property_read_u32_index 函数</h4><p>of_property_read_u32_index 函数用于从属性中获取指定标号的 u32 类型数据值(无符号 32位)，比如某个属性有多个 u32 类型的值，那么就可以使用此函数来获取指定标号的数据值，此函数原型如下：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">int of_property_read_u32_index(const struct device_node *np,</span><br><span class="line">                                const char *propname,</span><br><span class="line">                                u32 index,</span><br><span class="line">                                u32 *out_value)</span><br></pre></td></tr></table></figure>

<p>np：设备节点。</p>
<p>proname： 要读取的属性名字。</p>
<p>index：要读取的值标号。</p>
<p>out_value：读取到的值</p>
<p>返回值： 0 读取成功，负值，读取失败， -EINVAL 表示属性不存在， -ENODATA 表示没有</p>
<p>要读取的数据， -EOVERFLOW 表示属性值列表太小。</p>
<hr>
<p>版权声明：本文为CSDN博主「Wireless_Link」的原创文章，遵循CC 4.0 BY-SA版权协议，转载请附上原文出处链接及本声明。<br>原文链接：<a href="http://t.csdn.cn/GAzK8">http://t.csdn.cn/GAzK8</a></p>
]]></content>
      <categories>
        <category>linux-doc 设备驱动</category>
      </categories>
      <tags>
        <tag>Linux</tag>
      </tags>
  </entry>
  <entry>
    <title>Linux内核驱动之GPIO子系统API接口</title>
    <url>/2023/01/15/linux-docs/%E8%AE%BE%E5%A4%87%E9%A9%B1%E5%8A%A8/Linux%E5%86%85%E6%A0%B8%E9%A9%B1%E5%8A%A8%E4%B9%8BGPIO%E5%AD%90%E7%B3%BB%E7%BB%9FAPI%E6%8E%A5%E5%8F%A3/</url>
    <content><![CDATA[<h2 id="1、前言"><a href="#1、前言" class="headerlink" title="1、前言"></a>1、前言</h2><p>在嵌入式Linux开发中，对嵌入式SoC中的GPIO进行控制非常重要，Linux内核中提供了GPIO子系统，驱动开发者在驱动代码中使用GPIO子系统提供的API函数，便可以达到对GPIO控制的效果，例如将IO口的方向设置为输入或输出，当IO口的方向为输入时，可以通过调用API函数获取相应的IO口电平，当IO口设置为输出方向时，可以调用相关的API函数去设置IO口电平，本文将简单描述如何去使用Linux内核中GPIO子系统的API接口。</p>
<p>下图是Linux内核中GPIO子系统的软件驱动分层图：</p>
<p><img src="https://pic4.zhimg.com/80/v2-1819f094948b9f5248ca89dcc0cc45bb_720w.webp" alt="img"></p>
<h2 id="2、常用API接口"><a href="#2、常用API接口" class="headerlink" title="2、常用API接口"></a>2、常用API接口</h2><p>当我们在驱动代码中要使用内核中提供的GPIO子系统，需要在驱动代码中包含&lt;linux&#x2F;gpio.h&gt;头文件，另外，关于API接口函数的实现在内核源码drivers&#x2F;gpio&#x2F;gpiolib.c文件中，关于GPIO子系统的使用说明文档为Documentation&#x2F;gpio.txt，该文档具有更详细的使用说明，接下来，将简单介绍一下常用的API接口。</p>
<figure class="highlight text"><table><tr><td class="code"><pre><span class="line">/*</span><br><span class="line"> * &quot;valid&quot; GPIO numbers are nonnegative and may be passed to</span><br><span class="line"> * setup routines like gpio_request().  only some valid numbers</span><br><span class="line"> * can successfully be requested and used.</span><br><span class="line"> *</span><br><span class="line"> * Invalid GPIO numbers are useful for indicating no-such-GPIO in</span><br><span class="line"> * platform data and other tables.</span><br><span class="line"> */</span><br><span class="line">static inline bool gpio_is_valid(int number)</span><br><span class="line">&#123;</span><br><span class="line">    return number &gt;= 0 &amp;&amp; number &lt; ARCH_NR_GPIOS;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>函数gpio_is_valid()用来判断获取到的gpio号是否是有效的，只有有效的gpio号，才能向内核中进行申请使用，因此，当我们从设备树的设备节点获取到gpio号，可以使用该函数进行判断是否有效。</p>
<figure class="highlight text"><table><tr><td class="code"><pre><span class="line">/* Always use the library code for GPIO management calls,</span><br><span class="line"> * or when sleeping may be involved.</span><br><span class="line"> */</span><br><span class="line">extern int gpio_request(unsigned gpio, const char *label);</span><br><span class="line">extern void gpio_free(unsigned gpio);</span><br></pre></td></tr></table></figure>

<p>上面这两个函数用来向系统中申请GPIO和释放已经申请的GPIO，在函数gpio_request()中传入的形参中，gpio为IO号，label为向系统中申请GPIO使用的标签，类似于GPIO的名称。</p>
<figure class="highlight text"><table><tr><td class="code"><pre><span class="line">/**</span><br><span class="line"> * struct gpio - a structure describing a GPIO with configuration</span><br><span class="line"> * @gpio:    the GPIO number</span><br><span class="line"> * @flags:    GPIO configuration as specified by GPIOF_*</span><br><span class="line"> * @label:    a literal description string of this GPIO</span><br><span class="line"> */</span><br><span class="line">struct gpio &#123;</span><br><span class="line">    unsigned    gpio;</span><br><span class="line">    unsigned long    flags;</span><br><span class="line">    const char    *label;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>结构体struct gpio用来描述一个需要配置的GPIO。</p>
<figure class="highlight text"><table><tr><td class="code"><pre><span class="line">extern int gpio_request_one(unsigned gpio, unsigned long flags, const char *label);</span><br><span class="line">extern int gpio_request_array(const struct gpio *array, size_t num);</span><br><span class="line">extern void gpio_free_array(const struct gpio *array, size_t num);</span><br></pre></td></tr></table></figure>

<p>上面的3个函数也是用来向系统申请或者释放GPIO资源，函数gpio_request_one()用来申请单个GPIO，但是在申请的时候可以设置flag标志，例如，该函数在申请GPIO资源的同时，直接将GPIO的方向设置为输入或者输出，函数gpio_request_array()和gpio_free_array()用来向系统中申请或者释放多个GPIO资源。</p>
<figure class="highlight text"><table><tr><td class="code"><pre><span class="line">/* CONFIG_GPIOLIB: bindings for managed devices that want to request gpios */</span><br><span class="line"></span><br><span class="line">struct device;</span><br><span class="line"></span><br><span class="line">int devm_gpio_request(struct device *dev, unsigned gpio, const char *label);</span><br><span class="line">int devm_gpio_request_one(struct device *dev, unsigned gpio,</span><br><span class="line">              unsigned long flags, const char *label);</span><br><span class="line">void devm_gpio_free(struct device *dev, unsigned int gpio);</span><br></pre></td></tr></table></figure>

<p>上面的3个函数也是用来向系统申请或者释放GPIO资源，但是函数带有devm_前缀，也就是说，这是带设备资源管理版本的函数，因此在使用上面的函数时，需要指定设备的struct device指针。</p>
<figure class="highlight text"><table><tr><td class="code"><pre><span class="line">static inline int gpio_direction_input(unsigned gpio)</span><br><span class="line">&#123;</span><br><span class="line">    return gpiod_direction_input(gpio_to_desc(gpio));</span><br><span class="line">&#125;</span><br><span class="line">static inline int gpio_direction_output(unsigned gpio, int value)</span><br><span class="line">&#123;</span><br><span class="line">    return gpiod_direction_output_raw(gpio_to_desc(gpio), value);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>当我们使用gpio_request()函数向系统中申请了GPIO资源后，可以使用上面的函数进行GPIO的方向设置，函数gpio_direction_input()用来设置GPIO的方向为输入，函数gpio_direction_output()用来设置GPIO的方向为输出，并且通过value值可以设置输出的电平。</p>
<figure class="highlight text"><table><tr><td class="code"><pre><span class="line">static inline int gpio_get_value(unsigned int gpio)</span><br><span class="line">&#123;</span><br><span class="line">    return __gpio_get_value(gpio);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">static inline void gpio_set_value(unsigned int gpio, int value)</span><br><span class="line">&#123;</span><br><span class="line">    __gpio_set_value(gpio, value);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>当我们将GPIO的方向设置为输入时，可以使用上面的函数gpio_get_value()来获取当前的IO口电平值，当GPIO的方向设置为输出时，使用函数gpio_set_value()可以设置IO口的电平值。</p>
<figure class="highlight text"><table><tr><td class="code"><pre><span class="line">static inline int gpio_cansleep(unsigned int gpio)</span><br><span class="line">&#123;</span><br><span class="line">    return __gpio_cansleep(gpio);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>使用函数gpio_cansleep()判断是否能处于休眠状态，当该函数返回非零值时，说明读或写GPIO的电平值时能够处于休眠状态。</p>
<figure class="highlight text"><table><tr><td class="code"><pre><span class="line">static inline int gpio_get_value_cansleep(unsigned gpio)</span><br><span class="line">&#123;</span><br><span class="line">    return gpiod_get_raw_value_cansleep(gpio_to_desc(gpio));</span><br><span class="line">&#125;</span><br><span class="line">static inline void gpio_set_value_cansleep(unsigned gpio, int value)</span><br><span class="line">&#123;</span><br><span class="line">    return gpiod_set_raw_value_cansleep(gpio_to_desc(gpio), value);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>上面的函数同样是获取或者设置GPIO的电平值，只不过是带休眠版本的函数。</p>
<figure class="highlight text"><table><tr><td class="code"><pre><span class="line">static inline int gpio_to_irq(unsigned int gpio)</span><br><span class="line">&#123;</span><br><span class="line">    return __gpio_to_irq(gpio);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>函数gpio_to_irq()用于将当前已经申请GPIO号转换为IRQ号，也就是获取当前GPIO的中断线，函数调用成功后，将返回对应的IRQ号。</p>
<p>以上就是Linux内核中GPIO子系统的常用的API接口，关于其代码的实现，可以进一步分析Linux内核源码。</p>
<h2 id="3、实例说明"><a href="#3、实例说明" class="headerlink" title="3、实例说明"></a>3、实例说明</h2><p>在上面，已经分析过了Linux驱动中GPIO子系统的常用API接口函数，接下来，将通过一个具体的实例来讲解GPIO子系统中API接口如何使用。</p>
<p>首先，先了解一下GPIO的使用思路，如下所示：</p>
<figure class="highlight text"><table><tr><td class="code"><pre><span class="line">#include &lt;linux/module.h&gt;</span><br><span class="line">#include &lt;linux/init.h&gt;</span><br><span class="line">#include &lt;linux/gpio.h&gt;</span><br><span class="line">...</span><br><span class="line"></span><br><span class="line">struct gpio_drvdata &#123;</span><br><span class="line">    /* gpio号 */</span><br><span class="line">    int gpio_num;</span><br><span class="line">    ...</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">static int __init gpio_init(void)</span><br><span class="line">&#123;</span><br><span class="line">   struct gpio_drvdata *ddata;</span><br><span class="line">   int ret;</span><br><span class="line">   </span><br><span class="line">   ddata = kzalloc(sizeof(*ddata), GFP_KERNEL);</span><br><span class="line">   if (!ddata)</span><br><span class="line">       return -ENOMEM;</span><br><span class="line">    ...</span><br><span class="line">    </span><br><span class="line">    /* gpio初始化 */</span><br><span class="line">    if (gpio_is_valid(ddata-&gt;gpio_num)) &#123;</span><br><span class="line">        /* 申请gpio资源 */</span><br><span class="line">        ret = gpio_request(ddata-&gt;gpio_num, &quot;test-gpio&quot;);</span><br><span class="line">        if (ret) &#123;</span><br><span class="line">            printk(&quot;failed to request gpio\n&quot;);</span><br><span class="line">            return ret;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        /* 设置gpio的方向(输出) */</span><br><span class="line">        ret = gpio_direction_output(ddata-&gt;gpio_num, 0);</span><br><span class="line">        if (ret) &#123;</span><br><span class="line">            printk(&quot;failed to set output direction\n&quot;);</span><br><span class="line">            return ret;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        /* 在sysfs中导出gpio(方向能改变) */</span><br><span class="line">        ret = gpio_export(ddata-&gt;gpio_num, true);</span><br><span class="line">        if (ret) &#123;</span><br><span class="line">            printk(&quot;failed to export gpio in sysfs\n&quot;);</span><br><span class="line">            return ret;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        /* 设置gpio电平值(高电平) */</span><br><span class="line">        gpio_set_value(ddata-&gt;gpio_num, 1);</span><br><span class="line">    &#125;</span><br><span class="line">    ...</span><br><span class="line">    </span><br><span class="line">    return 0;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">static void __exit gpio_exit(void)</span><br><span class="line">&#123;</span><br><span class="line">    ...</span><br><span class="line">    /* 释放已经申请的gpio资源 */</span><br><span class="line">    if (gpio_is_valid(ddata-&gt;gpio_num))</span><br><span class="line">        gpio_free(ddata-&gt;gpio_num);</span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">module_init(gpio_init);</span><br><span class="line">module_exit(gpio_exit);</span><br></pre></td></tr></table></figure>

<p>上面的代码已经很清楚地体现了GPIO的使用思路，当驱动模块加载的时候，需要获取要使用的GPIO号，然后需要向系统申请使用GPIO资源，资源申请成功后，我们需要设置GPIO的方向（输入或者输出），此外，还能使用gpio_export()函数在sysfs中导出GPIO，导出的好处在于可以方便地debug代码，当驱动模块卸载时，需要将已经申请的GPIO资源进行释放掉，基本的使用思路就这样，比较简单。</p>
<p>接下来，给出具体的实例，功能为简单的GPIO控制，驱动程序中嵌入platform_driver框架，另外，在设备节点中导出ctrl和gpio两个属性文件，应用层对ctrl属性文件进行读写操作，能够获取和设置GPIO的电平状态，对gpio读操作，能够获取使用的GPIO号，下面是具体实例的实现过程：</p>
<p>先定义相关的设备节点，如下：</p>
<figure class="highlight text"><table><tr><td class="code"><pre><span class="line">dev_gpio &#123;</span><br><span class="line">    status = &quot;okay&quot;;</span><br><span class="line">    compatible = &quot;dev-gpio&quot;;</span><br><span class="line">    label = &quot;test_gpio&quot;;</span><br><span class="line">    gpios = &lt;&amp;msm_gpio 68 0&gt;;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>使用了GPIO_68这个引脚，compatible属性的值用于和驱动程序进行匹配，接下来是驱动代码的实现：</p>
<figure class="highlight text"><table><tr><td class="code"><pre><span class="line">#include &lt;linux/module.h&gt;</span><br><span class="line">#include &lt;linux/init.h&gt;</span><br><span class="line">#include &lt;linux/of.h&gt;</span><br><span class="line">#include &lt;linux/of_gpio.h&gt;</span><br><span class="line">#include &lt;linux/platform_device.h&gt;</span><br><span class="line">#include &lt;linux/kernel.h&gt;</span><br><span class="line">#include &lt;linux/slab.h&gt;</span><br><span class="line">#include &lt;linux/errno.h&gt;</span><br><span class="line">#include &lt;linux/gpio.h&gt;</span><br><span class="line">#include &lt;linux/sysfs.h&gt;</span><br><span class="line"></span><br><span class="line">struct gpio_platform_data &#123;</span><br><span class="line">    const char *label;</span><br><span class="line">    unsigned int gpio_num;</span><br><span class="line">    enum of_gpio_flags gpio_flag;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">struct gpio_drvdata &#123;</span><br><span class="line">    struct gpio_platform_data *pdata;</span><br><span class="line">    </span><br><span class="line">    bool gpio_state;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">static ssize_t ctrl_show(struct device *dev, </span><br><span class="line">    struct device_attribute *attr, char *buf)</span><br><span class="line">&#123;</span><br><span class="line">    struct gpio_drvdata *ddata = dev_get_drvdata(dev);</span><br><span class="line">    int ret;</span><br><span class="line"></span><br><span class="line">    if (ddata-&gt;gpio_state)</span><br><span class="line">        ret = snprintf(buf, PAGE_SIZE - 2, &quot;%s&quot;, &quot;enable&quot;);</span><br><span class="line">    else</span><br><span class="line">        ret = snprintf(buf, PAGE_SIZE - 2, &quot;%s&quot;, &quot;disable&quot;);</span><br><span class="line">    </span><br><span class="line">    buf[ret++] = &#x27;\n&#x27;;</span><br><span class="line">    buf[ret] = &#x27;\0&#x27;;</span><br><span class="line"></span><br><span class="line">    return ret;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">static ssize_t ctrl_store(struct device *dev,</span><br><span class="line">    struct device_attribute *attr, const char *buf, size_t count)</span><br><span class="line">&#123;</span><br><span class="line">    struct gpio_drvdata *ddata = dev_get_drvdata(dev);</span><br><span class="line">    bool state = ddata-&gt;gpio_state;</span><br><span class="line"></span><br><span class="line">    if (!strncmp(buf, &quot;enable&quot;, strlen(&quot;enable&quot;))) &#123;</span><br><span class="line">        if (!state) &#123;</span><br><span class="line">            gpio_set_value(ddata-&gt;pdata-&gt;gpio_num, !state);</span><br><span class="line">            ddata-&gt;gpio_state = !state;</span><br><span class="line">            goto ret;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; else if (!strncmp(buf, &quot;disable&quot;, strlen(&quot;disable&quot;))) &#123;</span><br><span class="line">        if (state) &#123;</span><br><span class="line">            gpio_set_value(ddata-&gt;pdata-&gt;gpio_num, !state);</span><br><span class="line">            ddata-&gt;gpio_state = !state;</span><br><span class="line">            goto ret;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    return 0;</span><br><span class="line"></span><br><span class="line">ret:</span><br><span class="line">    return strlen(buf);</span><br><span class="line">&#125;</span><br><span class="line">static DEVICE_ATTR(ctrl, 0644, ctrl_show, ctrl_store);</span><br><span class="line"></span><br><span class="line">static ssize_t gpio_show(struct device *dev,</span><br><span class="line">    struct device_attribute *attr, char *buf)</span><br><span class="line">&#123;</span><br><span class="line">    struct gpio_drvdata *ddata = dev_get_drvdata(dev);</span><br><span class="line">    int ret;</span><br><span class="line"></span><br><span class="line">    ret = snprintf(buf, PAGE_SIZE - 2, &quot;gpio-number: GPIO_%d&quot;,</span><br><span class="line">        ddata-&gt;pdata-&gt;gpio_num - 911);</span><br><span class="line">    buf[ret++] = &#x27;\n&#x27;;</span><br><span class="line">    buf[ret] = &#x27;\0&#x27;;</span><br><span class="line">    </span><br><span class="line">    return ret;</span><br><span class="line">&#125;</span><br><span class="line">static DEVICE_ATTR(gpio, 0444, gpio_show, NULL);</span><br><span class="line"></span><br><span class="line">static struct attribute *gpio_attrs[] = &#123;</span><br><span class="line">    &amp;dev_attr_ctrl.attr,</span><br><span class="line">    &amp;dev_attr_gpio.attr,</span><br><span class="line">    NULL</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">static struct attribute_group attr_grp = &#123;</span><br><span class="line">    .attrs = gpio_attrs,</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">static struct gpio_platform_data *</span><br><span class="line">gpio_parse_dt(struct device *dev)</span><br><span class="line">&#123;</span><br><span class="line">    int ret;</span><br><span class="line">    struct device_node *np = dev-&gt;of_node;</span><br><span class="line">    struct gpio_platform_data *pdata;</span><br><span class="line">    </span><br><span class="line">    pdata = kzalloc(sizeof(*pdata), GFP_KERNEL);</span><br><span class="line">    if (!pdata) &#123;</span><br><span class="line">        dev_err(dev, &quot;failed to alloc memory of platform data\n&quot;);</span><br><span class="line">        return NULL;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    ret = of_property_read_string(np, &quot;label&quot;, &amp;pdata-&gt;label);</span><br><span class="line">    if (ret) &#123;</span><br><span class="line">        dev_err(dev, &quot;failed to read property of lable\n&quot;);</span><br><span class="line">        goto fail;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    pdata-&gt;gpio_num = of_get_named_gpio_flags(np, &quot;gpios&quot;,</span><br><span class="line">                0, &amp;pdata-&gt;gpio_flag);</span><br><span class="line">    if (pdata-&gt;gpio_num &lt; 0) &#123;</span><br><span class="line">        dev_err(dev, &quot;invalid gpio number %d\n&quot;, pdata-&gt;gpio_num);</span><br><span class="line">        ret = pdata-&gt;gpio_num;</span><br><span class="line">        goto fail;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    return pdata;</span><br><span class="line"></span><br><span class="line">fail:</span><br><span class="line">    kfree(pdata);</span><br><span class="line">    return ERR_PTR(ret);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">static int gpio_probe(struct platform_device *pdev)</span><br><span class="line">&#123;</span><br><span class="line">    struct gpio_drvdata *ddata;</span><br><span class="line">    struct gpio_platform_data *pdata;</span><br><span class="line">    struct device *dev = &amp;pdev-&gt;dev;</span><br><span class="line">    struct device_node *np = dev-&gt;of_node;</span><br><span class="line">    int ret;</span><br><span class="line"></span><br><span class="line">    printk(&quot;[%s]==========gpio_probe start==========\n&quot;, __func__);</span><br><span class="line">    </span><br><span class="line">    if (!np) &#123;</span><br><span class="line">        dev_err(dev, &quot;failed to find device node of gpio device\n&quot;);</span><br><span class="line">        return -ENODEV;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    ddata = kzalloc(sizeof(*ddata), GFP_KERNEL);</span><br><span class="line">    if (!ddata) &#123;</span><br><span class="line">        dev_err(dev, &quot;failed to alloc memory for driver data\n&quot;);</span><br><span class="line">        return -ENOMEM;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    pdata = gpio_parse_dt(dev);</span><br><span class="line">    if (IS_ERR(pdata)) &#123;</span><br><span class="line">        dev_err(dev, &quot;failed to parse device node\n&quot;);</span><br><span class="line">        ret = PTR_ERR(pdata);</span><br><span class="line">        goto fail1;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    if (gpio_is_valid(pdata-&gt;gpio_num)) &#123;</span><br><span class="line">        ret = gpio_request(pdata-&gt;gpio_num, pdata-&gt;label);</span><br><span class="line">        if (ret) &#123;</span><br><span class="line">            dev_err(dev, &quot;failed to request gpio number %d\n&quot;,</span><br><span class="line">                pdata-&gt;gpio_num);</span><br><span class="line">            goto fail2;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        ret = gpio_direction_output(pdata-&gt;gpio_num, 0);</span><br><span class="line">        if (ret) &#123;</span><br><span class="line">            dev_err(dev, &quot;failed to set gpio direction for output\n&quot;);</span><br><span class="line">            goto fail3;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        ret = gpio_export(pdata-&gt;gpio_num, false);</span><br><span class="line">        if (ret) &#123;</span><br><span class="line">            dev_err(dev, &quot;failed to export gpio %d\n&quot;, pdata-&gt;gpio_num);</span><br><span class="line">            goto fail3;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    ddata-&gt;gpio_state = false;</span><br><span class="line">    ddata-&gt;pdata = pdata;</span><br><span class="line">    platform_set_drvdata(pdev, ddata);</span><br><span class="line"></span><br><span class="line">    ret = sysfs_create_group(&amp;dev-&gt;kobj, &amp;attr_grp);</span><br><span class="line">    if (ret) &#123;</span><br><span class="line">        dev_err(dev, &quot;failed to create sysfs files\n&quot;);</span><br><span class="line">        goto fail3;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    printk(&quot;[%s]==========gpio_probe over==========\n&quot;, __func__);</span><br><span class="line">    return 0;</span><br><span class="line">    </span><br><span class="line">fail3:</span><br><span class="line">    gpio_free(pdata-&gt;gpio_num);</span><br><span class="line">fail2:</span><br><span class="line">    kfree(pdata);</span><br><span class="line">fail1:</span><br><span class="line">    kfree(ddata);</span><br><span class="line">    return ret;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">static int gpio_remove(struct platform_device *pdev)</span><br><span class="line">&#123;</span><br><span class="line">    struct gpio_drvdata *ddata = platform_get_drvdata(pdev);</span><br><span class="line">    struct gpio_platform_data *pdata = ddata-&gt;pdata;</span><br><span class="line"></span><br><span class="line">    sysfs_remove_group(&amp;pdev-&gt;dev.kobj, &amp;attr_grp);</span><br><span class="line">    </span><br><span class="line">    if (gpio_is_valid(pdata-&gt;gpio_num))</span><br><span class="line">        gpio_free(pdata-&gt;gpio_num);</span><br><span class="line"></span><br><span class="line">    kfree(pdata);</span><br><span class="line">    pdata = NULL;</span><br><span class="line">    </span><br><span class="line">    kfree(ddata);</span><br><span class="line">    ddata = NULL;</span><br><span class="line"></span><br><span class="line">    return 0;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">static struct of_device_id device_match_table[] = &#123;</span><br><span class="line">    &#123; .compatible = &quot;dev-gpio&quot;,&#125;,</span><br><span class="line">    &#123; &#125;,</span><br><span class="line">&#125;;</span><br><span class="line">MODULE_DEVICE_TABLE(of, device_match_table);</span><br><span class="line"></span><br><span class="line">static struct platform_driver dev_gpio_driver = &#123;</span><br><span class="line">    .probe = gpio_probe,</span><br><span class="line">    .remove = gpio_remove,</span><br><span class="line">    .driver = &#123;</span><br><span class="line">        .name = &quot;dev-gpio&quot;,</span><br><span class="line">        .owner = THIS_MODULE,</span><br><span class="line">        .of_match_table = device_match_table,</span><br><span class="line">    &#125;,</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">module_platform_driver(dev_gpio_driver);</span><br><span class="line"></span><br><span class="line">MODULE_AUTHOR(&quot;HLY&quot;);</span><br><span class="line">MODULE_LICENSE(&quot;GPL v2&quot;);</span><br></pre></td></tr></table></figure>

<p>实现的思路和前面给出的模板一样，只不过是嵌入了platform_driver这个驱动框架，另外，在设备节点中导出了ctrl和gpio属性文件，便可以很方便地在应用层进行设备的GPIO控制了。</p>
<p>接下来，看看实现的效果，首先是生成的设备节点信息，可以使用下面的命令：</p>
<figure class="highlight text"><table><tr><td class="code"><pre><span class="line"># ls -al</span><br><span class="line"># cat uevent</span><br></pre></td></tr></table></figure>

<p>输出如下：</p>
<p><img src="https://pic4.zhimg.com/80/v2-69253fd3a036cc94655531ac7e10dadb_720w.webp" alt="img"></p>
<p>通过uevent可以看到设备节点的路径以及驱动和设备匹配的属性值，此外，在上面图片中，也可以看到ctrl和gpio属性文件已经被成功导出到了该设备节点下面，使用下面的命令可以进行GPIO的控制：</p>
<figure class="highlight text"><table><tr><td class="code"><pre><span class="line">##将GPIO置高电平</span><br><span class="line"># echo &quot;enable&quot; &gt; ctrl</span><br><span class="line"></span><br><span class="line">##将GPIO置低电平</span><br><span class="line"># echo &quot;disable&quot; &gt; ctrl</span><br></pre></td></tr></table></figure>

<p>控制的效果如下所示：</p>
<p><img src="https://pic4.zhimg.com/80/v2-c773f3982a5e9adba2d3538c982c994b_720w.webp" alt="img"></p>
<p>另外，在驱动程序中，我们使用了函数gpio_export()在sysfs中导出相关的GPIO信息，我们可以到&#x2F;sys&#x2F;class&#x2F;gpio&#x2F;gpioN目录下查看相关的GPIO信息，如下：</p>
<p><img src="https://pic2.zhimg.com/80/v2-c30f3ee7839270f7013fe10cdf4abde1_720w.webp" alt="img"></p>
<p>属性文件value保存了当前GPIO的电平值，当我们调用gpio_export()函数时，将第二个形参传入为true时，表示GPIO的方向还能改变，将在上面的目录中生成direction属性文件，里面保存了当前GPIO的方向，我们还能使用echo命令对文件进行写操作，从而改变GPIO的方向。</p>
<h2 id="4、小结"><a href="#4、小结" class="headerlink" title="4、小结"></a>4、小结</h2><p>本文简单介绍了Linux中GPIO子系统中的常用的API接口函数，并且给出了驱动程序中使用GPIO子系统的思路，另外还通过一个简单的实例进行说明。</p>
<hr>
<p>版权声明：本文为知乎博主「<a href="https://www.zhihu.com/people/linuxwang-xian-sheng">极致Linux内核</a>」的原创文章，遵循CC 4.0 BY-SA版权协议，转载请附上原文出处链接及本声明。</p>
<p>原文链接：<a href="https://zhuanlan.zhihu.com/p/549470099">https://zhuanlan.zhihu.com/p/549470099</a></p>
]]></content>
      <categories>
        <category>linux-doc 设备驱动</category>
      </categories>
      <tags>
        <tag>Linux</tag>
      </tags>
  </entry>
  <entry>
    <title>Linux操作系统学习之字符设备</title>
    <url>/2023/01/15/linux-docs/%E8%AE%BE%E5%A4%87%E9%A9%B1%E5%8A%A8/Linux%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E5%AD%A6%E4%B9%A0%E4%B9%8B%E5%AD%97%E7%AC%A6%E8%AE%BE%E5%A4%87/</url>
    <content><![CDATA[<h2 id="一-前言"><a href="#一-前言" class="headerlink" title="一. 前言"></a>一. 前言</h2><p>  上文中我们分析了虚拟文件系统的结构以及常见的文件操作从用户态到虚拟文件系统再到底层实际文件系统的过程。而实际上我们并没有说明实际的文件系统如ext4是如何和磁盘进行交互的，这就是本文和下篇文章的重点：I&#x2F;O之块设备和字符设备。输入输出设备我们大致可以分为两类：块设备（Block Device）和字符设备（Character Device）。</p>
<ul>
<li>块设备将信息存储在固定大小的块中，每个块都有自己的地址。如硬盘就是常见的块设备。</li>
<li>字符设备发送或接收的是字节流，而不用考虑任何块结构，没有办法寻址。如鼠标就是常见的字符设备。</li>
</ul>
<p>  本文首先介绍虚拟文件系统下层直至硬件输入输出设备的结构关系，然后重点分析字符设备相关的整体逻辑情况。</p>
<h2 id="二-I-O架构"><a href="#二-I-O架构" class="headerlink" title="二. I&#x2F;O架构"></a>二. I&#x2F;O架构</h2><p>  由于各种输入输出设备具有不同的硬件结构、驱动程序，因此我们采取了设备控制器这一中间层对上提供统一接口。设备控制器通过缓存来处理CPU和硬件I&#x2F;O之间的交互关系，通过中断进行通知，因此我们需要有中断处理器对各种中断进行统一。由于每种设备的控制器的寄存器、缓冲区等使用模式，指令都不同，所以对于操作系统还需要一层对接各个设备控制器的设备驱动程序。</p>
<p>  这里需要注意的是，设备控制器不属于操作系统的一部分，但是设备驱动程序属于操作系统的一部分。操作系统的内核代码可以像调用本地代码一样调用驱动程序的代码，而驱动程序的代码需要发出特殊的面向设备控制器的指令，才能操作设备控制器。设备驱动程序中是一些面向特殊设备控制器的代码，不同的设备不同。但是对于操作系统其它部分的代码而言，设备驱动程序有统一的接口。</p>
<p><img src="https://user-images.githubusercontent.com/87457873/128175363-3655a3b9-e0a6-4980-ac7f-5e1b891dcc0e.png" alt="image"></p>
<p>设备驱动本身作为一个内核模块，通常以ko文件的形式存在，它有着其独特的代码结构：</p>
<ul>
<li>头文件部分。设备驱动程序至少需要以下头文件</li>
</ul>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;linux/module.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;linux/init.h&gt;</span></span></span><br></pre></td></tr></table></figure>
<ul>
<li>调用MODULE_LICENSE声明lisence</li>
<li>初始化函数module_init和退出函数module_exit的定义，用于加载和卸载ko文件</li>
<li>文件系统的接口file_operation结构体定义</li>
<li>定义需要的函数</li>
</ul>
<p>  在下文的分析中，我们就将按照此顺序来剖析字符设备的源码，以弄懂字符设备的一般运行逻辑。关于设备驱动代码编写的详细知识可以参考《Linux设备驱动》一书，本文重点不在于如何编写代码，而是在于操作系统中的字符设备和块设备如何工作。</p>
<h2 id="三-字符设备基本构成"><a href="#三-字符设备基本构成" class="headerlink" title="三. 字符设备基本构成"></a>三. 字符设备基本构成</h2><p>  一个字符设备由3个部分组成：</p>
<ul>
<li><p>封装对于外部设备的操作的设备驱动程序，即 ko 文件模块，里面有模块初始化函数、中断处理函数、设备操作函数等。加载设备驱动程序模块的时候，模块初始化函数会被调用。在内核维护所有字符设备驱动的数据结构 cdev_map 里面注册设备号后，我们就可以很容易根据设备号找到相应的设备驱动程序。</p>
</li>
<li><p>特殊的设备驱动文件系统 devtmpfs，在&#x2F;dev 目录下生成一个文件表示这个设备。打开一个字符设备文件和打开一个普通的文件有类似的数据结构，有文件描述符、有 struct file、指向字符设备文件的 dentry 和 inode。其对应的 inode 是一个特殊的 inode，里面有设备号。通过它我们可以在 cdev_map 中找到设备驱动程序，里面还有针对字符设备文件的默认操作 def_chr_fops。</p>
</li>
<li><p>字符设备文件的相关操作 file_operations 。一开始会指向 def_chr_fops，在调用 def_chr_fops 里面的 chrdev_open 函数的时候修改为指向设备操作函数，从而读写一个字符设备文件就会直接变成读写外部设备了。</p>
<p>这里主要涉及到了两个结构体：字符设备信息存储的struct cdev以及管理字符设备的cdev_map。</p>
</li>
</ul>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">cdev</span> &#123;</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">kobject</span> <span class="title">kobj</span>;</span>                  <span class="comment">//内嵌的内核对象.</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">module</span> *<span class="title">owner</span>;</span>                 <span class="comment">//该字符设备所在的内核模块的对象指针.</span></span><br><span class="line">    <span class="type">const</span> <span class="class"><span class="keyword">struct</span> <span class="title">file_operations</span> *<span class="title">ops</span>;</span>    <span class="comment">//该结构描述了字符设备所能实现的方法，是极为关键的一个结构体.</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">list_head</span> <span class="title">list</span>;</span>                <span class="comment">//用来将已经向内核注册的所有字符设备形成链表.</span></span><br><span class="line">    <span class="type">dev_t</span> dev;                            <span class="comment">//字符设备的设备号，由主设备号和次设备号构成.</span></span><br><span class="line">    <span class="type">unsigned</span> <span class="type">int</span> count;                   <span class="comment">//隶属于同一主设备号的次设备号的个数.</span></span><br><span class="line">&#125; __randomize_layout;</span><br></pre></td></tr></table></figure>
<p>  cdev结构体还有另一个相关联的结构体char_device_struct。这里首先会定义主设备号和次设备号：主设备号用来标识与设备文件相连的驱动程序，用来反映设备类型。次设备号被驱动程序用来辨别操作的是哪个设备，用来区分同类型的设备。这里minorct指的是分配的区域，用于主设备号和次设备号的分配工作。</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">static</span> <span class="class"><span class="keyword">struct</span> <span class="title">char_device_struct</span> &#123;</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">char_device_struct</span> *<span class="title">next</span>;</span></span><br><span class="line">    <span class="type">unsigned</span> <span class="type">int</span> major;</span><br><span class="line">    <span class="type">unsigned</span> <span class="type">int</span> baseminor;</span><br><span class="line">    <span class="type">int</span> minorct;</span><br><span class="line">    <span class="type">char</span> name[<span class="number">64</span>];</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">cdev</span> *<span class="title">cdev</span>;</span>		<span class="comment">/* will die */</span></span><br><span class="line">&#125; *chrdevs[CHRDEV_MAJOR_HASH_SIZE];</span><br></pre></td></tr></table></figure>
<p>  cdev_map用于维护所有字符设备驱动，实际是结构体kobj_map，主要包括了一个互斥锁lock，一个probes[255]数组，数组元素为struct probe的指针，该结构体包括链表项、设备号、设备号范围等。所以我们将字符设备驱动最后保存为一个probe，并用cdev_map&#x2F;kobj_map进行统一管理。</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">static</span> <span class="class"><span class="keyword">struct</span> <span class="title">kobj_map</span> *<span class="title">cdev_map</span>;</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">kobj_map</span> &#123;</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">probe</span> &#123;</span></span><br><span class="line">        <span class="class"><span class="keyword">struct</span> <span class="title">probe</span> *<span class="title">next</span>;</span></span><br><span class="line">        <span class="type">dev_t</span> dev;</span><br><span class="line">        <span class="type">unsigned</span> <span class="type">long</span> range;</span><br><span class="line">        <span class="class"><span class="keyword">struct</span> <span class="title">module</span> *<span class="title">owner</span>;</span></span><br><span class="line">        <span class="type">kobj_probe_t</span> *get;</span><br><span class="line">        <span class="type">int</span> (*lock)(<span class="type">dev_t</span>, <span class="type">void</span> *);</span><br><span class="line">        <span class="type">void</span> *data;</span><br><span class="line">    &#125; *probes[<span class="number">255</span>];</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">mutex</span> *<span class="title">lock</span>;</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h2 id="四-打开字符设备"><a href="#四-打开字符设备" class="headerlink" title="四. 打开字符设备"></a>四. 打开字符设备</h2><p>  字符设备有很多种，这里以打印机设备为输出设备的例子，源码位于drivers&#x2F;char&#x2F;lp.c。以鼠标为输入设备的例子，源码位于drivers&#x2F;input&#x2F;mouse&#x2F;logibm.c。下面将根据上述的字符设备的三个组成部分分别剖析如何创建并打开字符设备。</p>
<h3 id="4-1-加载"><a href="#4-1-加载" class="headerlink" title="4.1 加载"></a>4.1 加载</h3><p>  字符设备的使用从加载开始，通常我们会使用insmod命令或者modprobe命令加载ko文件，ko文件的加载则从module_init调用该设备自定义的初始函数开始。对于打印机来说，其初始化函数定义为lp_init_module()，实际调用lp_init()。lp_init()会初始化打印机结构体，并调用register_chardev()注册该字符设备。</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">module_init(lp_init_module);</span><br><span class="line"></span><br><span class="line"><span class="type">static</span> <span class="type">int</span> __init <span class="title function_">lp_init_module</span><span class="params">(<span class="type">void</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">......</span><br><span class="line">    <span class="keyword">return</span> lp_init();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">static</span> <span class="type">int</span> __init <span class="title function_">lp_init</span><span class="params">(<span class="type">void</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">......</span><br><span class="line">    <span class="keyword">if</span> (register_chrdev(LP_MAJOR, <span class="string">&quot;lp&quot;</span>, &amp;lp_fops)) &#123;</span><br><span class="line">        printk(KERN_ERR <span class="string">&quot;lp: unable to get major %d\n&quot;</span>, LP_MAJOR);</span><br><span class="line">        <span class="keyword">return</span> -EIO;</span><br><span class="line">    &#125;</span><br><span class="line">......</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>register_chrdev()实际调用__register_chrdev()，该函数会进行字符设备的注册操作。其主要逻辑如下</p>
<ul>
<li>调用__register_chrdev_region()注册字符设备的主设备号和名称</li>
<li>调用cdev_alloc()分配结构体struct cdev</li>
<li>将 cdev 的 ops 成员变量指向这个模块声明的 file_operations</li>
<li>调用cdev_add()将这个字符设备添加到结构体 struct kobj_map *cdev_map ，该结构体用于统一管理所有字符设备。</li>
</ul>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">static</span> <span class="keyword">inline</span> <span class="type">int</span> <span class="title function_">register_chrdev</span><span class="params">(<span class="type">unsigned</span> <span class="type">int</span> major, <span class="type">const</span> <span class="type">char</span> *name,</span></span><br><span class="line"><span class="params">                  <span class="type">const</span> <span class="keyword">struct</span> file_operations *fops)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">return</span> __register_chrdev(major, <span class="number">0</span>, <span class="number">256</span>, name, fops);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> __register_chrdev(<span class="type">unsigned</span> <span class="type">int</span> major, <span class="type">unsigned</span> <span class="type">int</span> baseminor,</span><br><span class="line">              <span class="type">unsigned</span> <span class="type">int</span> count, <span class="type">const</span> <span class="type">char</span> *name,</span><br><span class="line">              <span class="type">const</span> <span class="keyword">struct</span> file_operations *fops)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">char_device_struct</span> *<span class="title">cd</span>;</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">cdev</span> *<span class="title">cdev</span>;</span></span><br><span class="line">    <span class="type">int</span> err = -ENOMEM;</span><br><span class="line">    cd = __register_chrdev_region(major, baseminor, count, name);</span><br><span class="line">    <span class="keyword">if</span> (IS_ERR(cd))</span><br><span class="line">        <span class="keyword">return</span> PTR_ERR(cd);</span><br><span class="line">    cdev = cdev_alloc();</span><br><span class="line">    <span class="keyword">if</span> (!cdev)</span><br><span class="line">        <span class="keyword">goto</span> out2;</span><br><span class="line">    cdev-&gt;owner = fops-&gt;owner;</span><br><span class="line">    cdev-&gt;ops = fops;</span><br><span class="line">    kobject_set_name(&amp;cdev-&gt;kobj, <span class="string">&quot;%s&quot;</span>, name);</span><br><span class="line">    err = cdev_add(cdev, MKDEV(cd-&gt;major, baseminor), count);</span><br><span class="line">......</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 拼接ma和mi</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> MINORBITS	20</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> MKDEV(ma,mi)	(((ma) &lt;&lt; MINORBITS) | (mi))</span></span><br></pre></td></tr></table></figure>
<p>  对于鼠标来说，加载也是类似的：注册为logibm_init()函数。但是这里没有调用register_chrdev()而是使用input_register_device()，原因在于输入设备会统一由input_init()初始化，之后加入的输入设备通过input_register_device()注册到input的管理结构体中进行统一管理。</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">module_init(logibm_init);</span><br><span class="line"></span><br><span class="line"><span class="type">static</span> <span class="type">int</span> __init <span class="title function_">logibm_init</span><span class="params">(<span class="type">void</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">......</span><br><span class="line">    err = input_register_device(logibm_dev);</span><br><span class="line">......</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="4-2-创建文件设备"><a href="#4-2-创建文件设备" class="headerlink" title="4.2 创建文件设备"></a>4.2 创建文件设备</h3><p>  加载完ko文件后，Linux内核会通过mknod在&#x2F;dev目录下创建一个设备文件，只有有了这个设备文件，我们才能通过文件系统的接口对这个设备文件进行操作。mknod本身是一个系统调用，主要逻辑为调用user_path_create()为该设备文件创建dentry，然后对于S_IFCHAR或者S_IFBLK会调用vfs_mknod()去调用对应文件系统的操作。</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">SYSCALL_DEFINE3(mknod, <span class="type">const</span> <span class="type">char</span> __user *, filename, <span class="type">umode_t</span>, mode, <span class="type">unsigned</span>, dev)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">return</span> sys_mknodat(AT_FDCWD, filename, mode, dev);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">SYSCALL_DEFINE4(mknodat, <span class="type">int</span>, dfd, <span class="type">const</span> <span class="type">char</span> __user *, filename, <span class="type">umode_t</span>, mode,</span><br><span class="line">    <span class="type">unsigned</span>, dev)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">dentry</span> *<span class="title">dentry</span>;</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">path</span> <span class="title">path</span>;</span></span><br><span class="line">......</span><br><span class="line">    dentry = user_path_create(dfd, filename, &amp;path, lookup_flags);</span><br><span class="line">......</span><br><span class="line">    <span class="keyword">switch</span> (mode &amp; S_IFMT) &#123;</span><br><span class="line">......</span><br><span class="line">        <span class="keyword">case</span> S_IFCHR: <span class="keyword">case</span> S_IFBLK:</span><br><span class="line">            error = vfs_mknod(path.dentry-&gt;d_inode,dentry,mode,</span><br><span class="line">            new_decode_dev(dev));</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">......</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">vfs_mknod</span><span class="params">(<span class="keyword">struct</span> inode *dir, <span class="keyword">struct</span> dentry *dentry, <span class="type">umode_t</span> mode, <span class="type">dev_t</span> dev)</span></span><br><span class="line">&#123;</span><br><span class="line">......</span><br><span class="line">    error = dir-&gt;i_op-&gt;mknod(dir, dentry, mode, dev);</span><br><span class="line">......</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>  对于&#x2F;dev目录下的设备驱动来说，所属的文件系统为devtmpfs文件系统，即设备驱动临时文件系统。devtmpfs对应的文件系统定义如下</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">static</span> <span class="class"><span class="keyword">struct</span> <span class="title">file_system_type</span> <span class="title">dev_fs_type</span> =</span> &#123; </span><br><span class="line">    .name = <span class="string">&quot;devtmpfs&quot;</span>, </span><br><span class="line">    .mount = dev_mount, </span><br><span class="line">    .kill_sb = kill_litter_super,</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="type">static</span> <span class="keyword">struct</span> dentry *<span class="title function_">dev_mount</span><span class="params">(<span class="keyword">struct</span> file_system_type *fs_type, <span class="type">int</span> flags, </span></span><br><span class="line"><span class="params">         <span class="type">const</span> <span class="type">char</span> *dev_name, <span class="type">void</span> *data)</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="meta">#<span class="keyword">ifdef</span> CONFIG_TMPFS </span></span><br><span class="line">    <span class="keyword">return</span> mount_single(fs_type, flags, data, shmem_fill_super);</span><br><span class="line"><span class="meta">#<span class="keyword">else</span> return </span></span><br><span class="line">    mount_single(fs_type, flags, data, ramfs_fill_super);</span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>  从这里可以看出，devtmpfs 在挂载的时候有两种模式：一种是 ramfs，一种是 shmem ，都是基于内存的文件系统。这两个 mknod 虽然实现不同，但是都会调用到同一个函数 init_special_inode()。显然这个文件是个特殊文件，inode 也是特殊的。这里这个 inode 可以关联字符设备、块设备、FIFO 文件、Socket 等。我们这里只看字符设备。这里的 inode 的 file_operations 指向一个 def_chr_fops，这里面只有一个 open，就等着你打开它。另外，inode 的 i_rdev 指向这个设备的 dev_t。通过这个 dev_t，可以找到我们刚刚加载的字符设备 cdev。</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">static</span> <span class="type">const</span> <span class="class"><span class="keyword">struct</span> <span class="title">inode_operations</span> <span class="title">ramfs_dir_inode_operations</span> =</span> &#123;</span><br><span class="line">......</span><br><span class="line">  .mknod    = ramfs_mknod,</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="type">static</span> <span class="type">const</span> <span class="class"><span class="keyword">struct</span> <span class="title">inode_operations</span> <span class="title">shmem_dir_inode_operations</span> =</span> &#123;</span><br><span class="line"><span class="meta">#<span class="keyword">ifdef</span> CONFIG_TMPFS</span></span><br><span class="line">......</span><br><span class="line">  .mknod    = shmem_mknod,</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">init_special_inode</span><span class="params">(<span class="keyword">struct</span> inode *inode, <span class="type">umode_t</span> mode, <span class="type">dev_t</span> rdev)</span></span><br><span class="line">&#123;</span><br><span class="line">    inode-&gt;i_mode = mode;</span><br><span class="line">    <span class="keyword">if</span> (S_ISCHR(mode)) &#123;</span><br><span class="line">        inode-&gt;i_fop = &amp;def_chr_fops;</span><br><span class="line">        inode-&gt;i_rdev = rdev;</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (S_ISBLK(mode)) &#123;</span><br><span class="line">        inode-&gt;i_fop = &amp;def_blk_fops;</span><br><span class="line">        inode-&gt;i_rdev = rdev;</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (S_ISFIFO(mode))</span><br><span class="line">        inode-&gt;i_fop = &amp;pipefifo_fops;</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span> (S_ISSOCK(mode))</span><br><span class="line">        ;  <span class="comment">/* leave it no_open_fops */</span></span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">        printk(KERN_DEBUG <span class="string">&quot;init_special_inode: bogus i_mode (%o) for&quot;</span></span><br><span class="line">                  <span class="string">&quot; inode %s:%lu\n&quot;</span>, mode, inode-&gt;i_sb-&gt;s_id,</span><br><span class="line">                  inode-&gt;i_ino);    </span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">const</span> <span class="class"><span class="keyword">struct</span> <span class="title">file_operations</span> <span class="title">def_chr_fops</span> =</span> &#123;</span><br><span class="line">    .open = chrdev_open,</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>  由此我们完成了&#x2F;dev下文件的创建，并利用rdev和生成的字符设备进行了关联。</p>
<h3 id="4-3-打开字符设备"><a href="#4-3-打开字符设备" class="headerlink" title="4.3 打开字符设备"></a>4.3 打开字符设备</h3><p>  如打开普通文件一样，打开字符设备也会首先分配对应的文件描述符fd，然后生成struct file结构体与其绑定，并将file关联到对应的dentry从而可以接触inode。在进程里面调用 open() 函数，最终会调用到这个特殊的 inode 的 open() 函数，也就是 chrdev_open()。</p>
<p>  chrdev_open()主要逻辑为</p>
<ul>
<li>调用kobj_lookup()，通过设备号i_cdev关联对应的设备驱动程序</li>
<li>调用fops_get()将设备驱动程序自己定义的文件操作p-&gt;ops赋值给fops</li>
<li>调用设备驱动程序的 file_operations 的 open() 函数真正打开设备。对于打印机，调用的是 lp_open()。对于鼠标调用的是 input_proc_devices_open()，最终会调用到 logibm_open()。</li>
</ul>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * Called every time a character special file is opened</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="type">static</span> <span class="type">int</span> <span class="title function_">chrdev_open</span><span class="params">(<span class="keyword">struct</span> inode *inode, <span class="keyword">struct</span> file *filp)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">const</span> <span class="class"><span class="keyword">struct</span> <span class="title">file_operations</span> *<span class="title">fops</span>;</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">cdev</span> *<span class="title">p</span>;</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">cdev</span> *<span class="title">new</span> =</span> <span class="literal">NULL</span>;</span><br><span class="line">......</span><br><span class="line">    p = inode-&gt;i_cdev;</span><br><span class="line">......</span><br><span class="line">    kobj = kobj_lookup(cdev_map, inode-&gt;i_rdev, &amp;idx);</span><br><span class="line">......      </span><br><span class="line">    fops = fops_get(p-&gt;ops);</span><br><span class="line">......</span><br><span class="line">    replace_fops(filp, fops);</span><br><span class="line">    <span class="keyword">if</span> (filp-&gt;f_op-&gt;open) &#123;</span><br><span class="line">        ret = filp-&gt;f_op-&gt;open(inode, filp);</span><br><span class="line">......</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>上述过程借用极客时间中的图来作为总结。</p>
<p><img src="https://user-images.githubusercontent.com/87457873/128175400-ba80285b-b70d-45ee-9e47-50a81f135dc2.png" alt="image"></p>
<h2 id="五-写入字符设备"><a href="#五-写入字符设备" class="headerlink" title="五. 写入字符设备"></a>五. 写入字符设备</h2><p>  写入字符设备和写入普通文件一样，调用write()函数执行。该函数在内核里查询系统调用表最终调用sys_write()，并根据fd描述符获取对应的file结构体，接着调用vfs_write()去调用对应的文件系统自定义的写入函数file-&gt;f_op-&gt;write()。对于打印机来说，最终调用的是自定义的lp_write()函数。</p>
<p>  这里写入的重点在于调用 copy_from_user() 将数据从用户态拷贝到内核态的缓存中，然后调用 parport_write() 写入外部设备。这里还有一个 schedule() 函数，也即写入的过程中，给其他线程抢占 CPU 的机会。如果写入字节数多，不能一次写完，就会在循环里一直调用 copy_from_user() 和 parport_write()，直到写完为止。</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">static</span> <span class="type">ssize_t</span> <span class="title function_">lp_write</span><span class="params">(<span class="keyword">struct</span> file *file, <span class="type">const</span> <span class="type">char</span> __user *buf,</span></span><br><span class="line"><span class="params">            <span class="type">size_t</span> count, <span class="type">loff_t</span> *ppos)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">unsigned</span> <span class="type">int</span> minor = iminor(file_inode(file));</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">parport</span> *<span class="title">port</span> =</span> lp_table[minor].dev-&gt;port;</span><br><span class="line">    <span class="type">char</span> *kbuf = lp_table[minor].lp_buffer;</span><br><span class="line">    <span class="type">ssize_t</span> retv = <span class="number">0</span>;</span><br><span class="line">    <span class="type">ssize_t</span> written;</span><br><span class="line">    <span class="type">size_t</span> copy_size = count;</span><br><span class="line">......</span><br><span class="line">    <span class="comment">/* Need to copy the data from user-space. */</span></span><br><span class="line">    <span class="keyword">if</span> (copy_size &gt; LP_BUFFER_SIZE)</span><br><span class="line">        copy_size = LP_BUFFER_SIZE;</span><br><span class="line">......</span><br><span class="line">    <span class="keyword">if</span> (copy_from_user(kbuf, buf, copy_size)) &#123;</span><br><span class="line">        retv = -EFAULT;</span><br><span class="line">        <span class="keyword">goto</span> out_unlock;</span><br><span class="line">    &#125;</span><br><span class="line">......</span><br><span class="line">    <span class="keyword">do</span> &#123;</span><br><span class="line">        <span class="comment">/* Write the data. */</span></span><br><span class="line">        written = parport_write(port, kbuf, copy_size);</span><br><span class="line">        <span class="keyword">if</span> (written &gt; <span class="number">0</span>) &#123;</span><br><span class="line">            copy_size -= written;</span><br><span class="line">            count -= written;</span><br><span class="line">            buf  += written;</span><br><span class="line">            retv += written;</span><br><span class="line">        &#125;</span><br><span class="line">......</span><br><span class="line">        <span class="keyword">if</span> (need_resched())</span><br><span class="line">            schedule(); </span><br><span class="line">        <span class="keyword">if</span> (count) &#123;</span><br><span class="line">            copy_size = count;</span><br><span class="line">            <span class="keyword">if</span> (copy_size &gt; LP_BUFFER_SIZE)</span><br><span class="line">                copy_size = LP_BUFFER_SIZE;</span><br><span class="line">            <span class="keyword">if</span> (copy_from_user(kbuf, buf, copy_size)) &#123;</span><br><span class="line">                <span class="keyword">if</span> (retv == <span class="number">0</span>)</span><br><span class="line">                    retv = -EFAULT;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; <span class="keyword">while</span> (count &gt; <span class="number">0</span>);</span><br><span class="line">......</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="六-字符设备的控制"><a href="#六-字符设备的控制" class="headerlink" title="六. 字符设备的控制"></a>六. 字符设备的控制</h2><p>  在Linux中，我们常用ioctl()来对I&#x2F;O设备进行一些读写之外的特殊操作。其参数主要由文件描述符fd，命令cmd以及命令参数arg构成。其中cmd由几个部分拼接成整型，主要结构为</p>
<ul>
<li>最低8位为 NR，表示命令号；</li>
<li>次低8位为 TYPE，表示类型；</li>
<li>14位表示参数的大小；</li>
<li>最高2位是 DIR，表示写入、读出，还是读写。</li>
</ul>
<p><img src="https://user-images.githubusercontent.com/87457873/128175427-20a921aa-03cb-425d-a66e-bdd6884b4d49.png" alt="image"></p>
<p>ioctl()也是一个系统调用，其中fd 是这个设备的文件描述符，cmd 是传给这个设备的命令，arg 是命令的参数。主要调用do_vfs_ioctl()完成实际功能。</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">SYSCALL_DEFINE3(ioctl, <span class="type">unsigned</span> <span class="type">int</span>, fd, <span class="type">unsigned</span> <span class="type">int</span>, cmd, <span class="type">unsigned</span> <span class="type">long</span>, arg)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">int</span> error;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">fd</span> <span class="title">f</span> =</span> fdget(fd);</span><br><span class="line">......</span><br><span class="line">    error = do_vfs_ioctl(f.file, fd, cmd, arg);</span><br><span class="line">    fdput(f);</span><br><span class="line">    <span class="keyword">return</span> error;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>  do_vfs_ioctl()对于已经定义好的 cmd进行相应的处理。如果不是默认定义好的 cmd，则执行默认操作：对于普通文件，调用 file_ioctl，对于其他文件调用 vfs_ioctl。</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * When you add any new common ioctls to the switches above and below</span></span><br><span class="line"><span class="comment"> * please update compat_sys_ioctl() too.</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * do_vfs_ioctl() is not for drivers and not intended to be EXPORT_SYMBOL()&#x27;d.</span></span><br><span class="line"><span class="comment"> * It&#x27;s just a simple helper for sys_ioctl and compat_sys_ioctl.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="type">int</span> <span class="title function_">do_vfs_ioctl</span><span class="params">(<span class="keyword">struct</span> file *filp, <span class="type">unsigned</span> <span class="type">int</span> fd, <span class="type">unsigned</span> <span class="type">int</span> cmd,</span></span><br><span class="line"><span class="params">         <span class="type">unsigned</span> <span class="type">long</span> arg)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">int</span> error = <span class="number">0</span>;</span><br><span class="line">    <span class="type">int</span> __user *argp = (<span class="type">int</span> __user *)arg;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">inode</span> *<span class="title">inode</span> =</span> file_inode(filp);</span><br><span class="line">    <span class="keyword">switch</span> (cmd) &#123;</span><br><span class="line">    <span class="keyword">case</span> FIOCLEX:</span><br><span class="line">        set_close_on_exec(fd, <span class="number">1</span>);</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">    <span class="keyword">case</span> FIONCLEX:</span><br><span class="line">        set_close_on_exec(fd, <span class="number">0</span>);</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">    <span class="keyword">case</span> FIONBIO:</span><br><span class="line">        error = ioctl_fionbio(filp, argp);</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">    <span class="keyword">case</span> FIOASYNC:</span><br><span class="line">        error = ioctl_fioasync(fd, filp, argp);</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">......</span><br><span class="line">    <span class="keyword">default</span>:</span><br><span class="line">        <span class="keyword">if</span> (S_ISREG(inode-&gt;i_mode))</span><br><span class="line">            error = file_ioctl(filp, cmd, arg);</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">            error = vfs_ioctl(filp, cmd, arg);</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> error;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>  对于字符设备驱动程序，最终会调用vfs_ioctl()。这里面调用的是 struct file 里 file_operations 的 unlocked_ioctl() 函数。我们前面初始化设备驱动的时候，已经将 file_operations 指向设备驱动的 file_operations 了。这里调用的是设备驱动的 unlocked_ioctl。对于打印机程序来讲，调用的是 lp_ioctl()。</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">long</span> <span class="title function_">vfs_ioctl</span><span class="params">(<span class="keyword">struct</span> file *filp, <span class="type">unsigned</span> <span class="type">int</span> cmd, <span class="type">unsigned</span> <span class="type">long</span> arg)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">int</span> error = -ENOTTY;</span><br><span class="line">    <span class="keyword">if</span> (!filp-&gt;f_op-&gt;unlocked_ioctl)</span><br><span class="line">        <span class="keyword">goto</span> out;</span><br><span class="line">    error = filp-&gt;f_op-&gt;unlocked_ioctl(filp, cmd, arg);</span><br><span class="line">    <span class="keyword">if</span> (error == -ENOIOCTLCMD)</span><br><span class="line">        error = -ENOTTY;</span><br><span class="line"> out:</span><br><span class="line">    <span class="keyword">return</span> error;</span><br><span class="line">&#125; EXPORT_SYMBOL(vfs_ioctl);</span><br></pre></td></tr></table></figure>
<p>  打印机的lp_do_ioctl()主要逻辑也是针对cmd采用switch()语句分情况进行处理。主要包括使用LP_XXX()宏定义赋值标记位和调用copy_to_user()将用户想得到的信息返回给用户态。</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">static</span> <span class="type">int</span> <span class="title function_">lp_do_ioctl</span><span class="params">(<span class="type">unsigned</span> <span class="type">int</span> minor, <span class="type">unsigned</span> <span class="type">int</span> cmd,</span></span><br><span class="line"><span class="params">    <span class="type">unsigned</span> <span class="type">long</span> arg, <span class="type">void</span> __user *argp)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">int</span> status;</span><br><span class="line">    <span class="type">int</span> retval = <span class="number">0</span>;</span><br><span class="line">......</span><br><span class="line">    <span class="keyword">switch</span> ( cmd ) &#123;</span><br><span class="line">        <span class="keyword">case</span> LPTIME:</span><br><span class="line">            <span class="keyword">if</span> (arg &gt; UINT_MAX / HZ)</span><br><span class="line">                <span class="keyword">return</span> -EINVAL;</span><br><span class="line">            LP_TIME(minor) = arg * HZ/<span class="number">100</span>;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        <span class="keyword">case</span> LPCHAR:</span><br><span class="line">            LP_CHAR(minor) = arg;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        <span class="keyword">case</span> LPABORT:</span><br><span class="line">            <span class="keyword">if</span> (arg)</span><br><span class="line">                LP_F(minor) |= LP_ABORT;</span><br><span class="line">            <span class="keyword">else</span></span><br><span class="line">                LP_F(minor) &amp;= ~LP_ABORT;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">    ......</span><br><span class="line">        <span class="keyword">case</span> LPGETIRQ:</span><br><span class="line">            <span class="keyword">if</span> (copy_to_user(argp, &amp;LP_IRQ(minor),</span><br><span class="line">                    <span class="keyword">sizeof</span>(<span class="type">int</span>)))</span><br><span class="line">                <span class="keyword">return</span> -EFAULT;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">......</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>  本文简单介绍了设备驱动程序的结构，并在此基础上介绍了字符设备从创建到打开、写入以及控制的整个流程。</p>
]]></content>
      <categories>
        <category>linux-doc 设备驱动</category>
      </categories>
      <tags>
        <tag>Linux</tag>
      </tags>
  </entry>
  <entry>
    <title>Linux内核IO基础知识与概念</title>
    <url>/2023/01/15/linux-docs/%E8%BF%9B%E7%A8%8B%E7%AE%A1%E7%90%86/Linux%E5%86%85%E6%A0%B8IO%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86%E4%B8%8E%E6%A6%82%E5%BF%B5/</url>
    <content><![CDATA[<h2 id="什么是-IO"><a href="#什么是-IO" class="headerlink" title="什么是 IO"></a>什么是 IO</h2><p>在计算机操作系统中，所谓的I&#x2F;O就是 <strong>输入（Input）和输出（Output）</strong>，也可以理解为<strong>读（Read）和写（Write)<strong>，针对不同的对象，I&#x2F;O模式可以划分为</strong>磁盘IO</strong>模型和<strong>网络IO</strong>模型。</p>
<p>IO操作会涉及到<strong>用户空间</strong>和<strong>内核空间</strong>的转换，先来理解以下规则：</p>
<ul>
<li>内存空间分为用户空间和内核空间，也称为用户缓冲区和内核缓冲区；</li>
<li>用户的应用程序不能直接操作内核空间，需要将数据从内核空间拷贝到用户空间才能使用；</li>
<li>无论是read操作，还是write操作，都只能在内核空间里执行；</li>
<li>磁盘IO和网络IO请求加载到内存的数据都是先放在内核空间的；</li>
</ul>
<p>再来看看所谓的读（Read）和写（Write)操作：</p>
<ul>
<li><strong>读操作</strong>：操作系统检查内核缓冲区有没有需要的数据，如果内核缓冲区已经有需要的数据了，那么就直接把内核空间的数据copy到用户空间，供用户的应用程序使用。如果内核缓冲区没有需要的数据，对于磁盘IO，直接从磁盘中读取到内核缓冲区（这个过程可以不需要cpu参与）。而对于网络IO，应用程序需要等待客户端发送数据，如果客户端还没有发送数据，对应的应用程序将会被阻塞，直到客户端发送了数据，该应用程序才会被唤醒，从Socket协议找中读取客户端发送的数据到内核空间，然后把内核空间的数据copy到用户空间，供应用程序使用。</li>
<li><strong>写操作</strong>：用户的应用程序将数据从用户空间copy到内核空间的缓冲区中（如果用户空间没有相应的数据，则需要从磁盘—&gt;内核缓冲区—&gt;用户缓冲区依次读取），这时对用户程序来说写操作就已经完成，至于什么时候再写到磁盘或通过网络发送出去，由操作系统决定。除非应用程序显示地调用了sync 命令，立即把数据写入磁盘，或执行flush()方法，通过网络把数据发送出去。</li>
<li>绝大多数磁盘IO和网络IO的读写操作都是上述过程，除了后面要讲到的零拷贝IO。</li>
</ul>
<h2 id="用户空间-内核空间"><a href="#用户空间-内核空间" class="headerlink" title="用户空间&amp;内核空间"></a>用户空间&amp;内核空间</h2><p>野生程序员对于这个概念可能比较陌生，这其实是 Linux 操作系统中的概念。虚拟内存（操作系统中的概念，和物理内存是对应的）被操作系统划分成两块：User Space（用户空间 和 Kernel Space（内核空间），本质上电脑的物理内存是不划分这些的，只是操作系统开机启动后在逻辑上虚拟划分了地址和空间范围。</p>
<p>操作系统会给每个进程分配一个独立的、连续的虚拟内存地址空间（物理上可能不连续），以32位操作系统为例，该大小一般是4G，即232 。其中将高地址值的内存空间分配给系统内核占用（网上查资料得知：Linux下占1G，Windows下占2G），其余的内存地址空间分配给用户进程使用。</p>
<p>因为我们不是要深入学习操作系统，所以这里以32位系统举例旨在帮助你理解原理。32 位的 LInux 操作系统下，0<del>3G为<strong>用户空间</strong>，3</del>4G为<strong>内核空间</strong>：</p>
<p><img src="https://pic4.zhimg.com/80/v2-6697b79b29fec466f276b1b89765f337_720w.webp" alt="img"></p>
<p><strong>那为什么要这样划分出空间范围呢？</strong></p>
<p>也很好理解，毕竟操作系统身份高贵，太重要了，不能和用户应用程序在一起玩耍，各自的数据都要分开存储并且严格控制权限不能越界。这样才能保证操作系统的稳定运行，用户应用程序太不可控了，不同公司或者个人都可以开发，碰到坑爹的误操作或者恶意破坏系统数据直接宕机玩完了。隔离后应用程序要挂你就挂，操作系统可以正常运行。</p>
<p>简单说，<strong>内核空间</strong> 是操作系统 <strong>内核代码运行的地方</strong>，<strong>用户空间</strong> 是 <strong>用户程序代码运行的地方</strong>。当应用进程执行系统调用陷入内核代码中执行时就处于<strong>内核态</strong>，当应用进程在运行用户代码时就处于<strong>用户态</strong>。</p>
<p>同时内核空间可以执行任意的命令，而用户空间只能执行简单的运算，不能直接调用系统资源和数据。必须通过操作系统提供接口，向系统内核发送指令。</p>
<p>一旦调用系统接口，应用进程就从用户空间切换到内核空间了，因为开始运行内核代码了。</p>
<p><strong>简单看几行代码，分析下是应用程序在用户空间和内核空间之间的切换过程：</strong></p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">str = <span class="string">&quot;i am qige&quot;</span> <span class="comment">// 用户空间</span></span><br><span class="line">x = x + <span class="number">2</span></span><br><span class="line">file.<span class="built_in">write</span>(str) <span class="comment">// 切换到内核空间</span></span><br><span class="line">y = x + <span class="number">4</span> <span class="comment">// 切换回用户空间</span></span><br></pre></td></tr></table></figure>

<p>上面代码中，第一行和第二行都是简单的赋值运算，在<strong>用户空间</strong>执行。第三行需要写入文件，就要切换到<strong>内核空间</strong>，因为用户不能直接写文件，必须通过内核安排。第四行又是赋值运算，就切换回<strong>用户空间</strong>。</p>
<p><strong>用户态切换到内核态的3种方式：</strong></p>
<ul>
<li>系统调用。也称为 System Call，是说用户态进程主动要求切换到内核态的一种方式，用户态进程使用操作系统提供的服务程序完成工作，比如上面示例代码中的写文件调用，还有像 fork() 函数实际上就是执行了一个创建新进程的系统调用。而系统调用的机制其核心还是使用了操作系统为用户特别开放的一个中断来实现。</li>
<li>异常。当CPU在用户空间执行程序代码时发生了不可预期的异常，这时会触发由当前运行进程切换到处理此异常的内核相关程序中，切换到内核态，比如缺页异常。</li>
<li><strong>外围设备的中断。</strong> 当外围设备完成用户请求的某些操作后，会向CPU发送相应的中断信号，这时CPU会暂停执行下一条即将执行的指令转而去执行与中断信号对应的处理程序，如果当前正在运行用户态下的程序指令，自然就发了由用户态到内核态的切换。比如硬盘数据读写完成，系统会切换到中断处理程序中执行后续操作等。</li>
</ul>
<p>以上3种方式，除了系统调用是进程主动发起切换，异常和外围设备中断是被动切换的。</p>
<p>查看 CPU 时间在 User Space 与 Kernel Space 之间的分配情况，可以使用top命令。它的第三行输出就是 CPU 时间分配统计。</p>
<p><img src="https://pic1.zhimg.com/80/v2-0eb940b4447e13ec2376ef7e698fafbc_720w.webp" alt="img"></p>
<p><strong>我们来看看图中圈出来的 CPU 使用率的三个指标：</strong></p>
<p>其中，第一项 7.57% user 就是 CPU 消耗在 User Space 的时间百分比，第二项 7.0% sys是消耗在 Kernel Space 的时间百分比。第三项 85.4% idle 是 CPU 消耗在闲置进程的时间百分比，这个值越低，表示 CPU 越忙。</p>
<h2 id="PIO-DMA"><a href="#PIO-DMA" class="headerlink" title="PIO&amp;DMA"></a>PIO&amp;DMA</h2><p>大家都知道一般我们的数据是存储在磁盘上的，应用程序想要读写这些数据肯定就需要加载到内存中。接下来给大家介绍下 <strong>PIO</strong> 和 <strong>DMA</strong> 这两种 IO 设备和内存之间的数据传输方式。</p>
<h2 id="PIO-工作原理"><a href="#PIO-工作原理" class="headerlink" title="PIO 工作原理"></a>PIO 工作原理</h2><p><img src="https://pic4.zhimg.com/80/v2-90ecc965481a21f27b6afbf7f4b18993_720w.webp" alt="img"></p>
<ol>
<li>用户进程通过read等系统调用接口向操作系统（即CPU）发出IO请求，请求读取数据到自己的用户内存缓冲区中，然后该进程进入阻塞状态。</li>
<li>操作系统收到用户进程的请求后，进一步将IO请求发送给磁盘。</li>
<li>磁盘驱动器收到内核的IO请求后，把数据读取到自己的缓冲区中，此时不占用CPU。当磁盘的缓冲区被读满之后，向内核发起中断信号告知自己缓冲区已满。</li>
<li>内核收到磁盘发来的中断信号，使用CPU将磁盘缓冲区中的数据copy到内核缓冲区中。</li>
<li>如果内核缓冲区的数据少于用户申请读的数据，则重复步骤2、3、4，直到内核缓冲区的数据符合用户的要求为止。</li>
<li>内核缓冲区的数据已经符合用户的要求，CPU停止向磁盘IO请求。</li>
<li>CPU将数据从内核缓冲区拷贝到用户缓冲区，同时从系统调用中返回。</li>
<li>用户进程读取到数据后继续执行原来的任务。</li>
</ol>
<p><strong>PIO缺点：每次IO请求都需要CPU多次参与，效率很低。</strong></p>
<h2 id="DMA-工作原理"><a href="#DMA-工作原理" class="headerlink" title="DMA 工作原理"></a>DMA 工作原理</h2><p>DMA（直接内存访问，Direct Memory Access）。</p>
<p><img src="https://pic3.zhimg.com/80/v2-7bf1bfcef38e227b514d4e123edecb66_720w.webp" alt="img"></p>
<ol>
<li>用户进程通过read等系统调用接口向操作系统（即CPU）发出IO请求，请求读取数据到自己的用户内存缓冲区中，然后该进程进入阻塞状态。</li>
<li>操作系统收到用户进程的请求后，进一步将IO请求发送给DMA，然后CPU就可以去干别的事了。</li>
<li>DMA将IO请求转发给磁盘。</li>
<li>磁盘驱动器收到内核的IO请求后，把数据读取到自己的缓冲区中，当磁盘的缓冲区被读满后，向DMA发起中断信号告知自己缓冲区已满。</li>
<li>DMA收到磁盘驱动器的信号，将磁盘缓冲区中的数据copy到内核缓冲区中，此时不占用CPU（ PIO 这里是占用CPU的）。</li>
<li>如果内核缓冲区的数据少于用户申请读的数据，则重复步骤3、4、5，直到内核缓冲区的数据符合用户的要求为止。</li>
<li>内核缓冲区的数据已经符合用户的要求，DMA停止向磁盘发IO请求。</li>
<li>DMA发送中断信号给CPU。</li>
<li>CPU收到DMA的信号，知道数据已经准备好，于是将数据从内核空间copy到用户空间，系统调用返回。</li>
<li>用户进程读取到数据后继续执行原来的任务。</li>
</ol>
<p>跟PIO模式相比，DMA就是CPU的一个代理，它负责了一部分的拷贝工作，从而减轻了CPU的负担。</p>
<p>需要注意的是，DMA承担的工作是从磁盘的缓冲区到内核缓冲区或网卡设备到内核的 soket buffer的拷贝工作，以及内核缓冲区到磁盘缓冲区或内核的 soket buffer 到网卡设备的拷贝工作，而内核缓冲区到用户缓冲区之间的拷贝工作仍然由CPU负责。</p>
<p>可以肯定的是，PIO模式的计算机我们现在已经很少见到了。</p>
<h2 id="缓冲IO和直接IO"><a href="#缓冲IO和直接IO" class="headerlink" title="缓冲IO和直接IO"></a>缓冲IO和直接IO</h2><p>学习用户空间和内核空间的时候我们也说了，用户空间是不能直接访问内核空间的数据的，如果需要访问怎么办？很简单，就需要将数据从内核空间拷贝的用户空间。</p>
<ul>
<li>缓冲 IO：其实就是磁盘中的数据通过 DMA 先拷贝到内核空间，然后再从内核空间拷贝到用户空间。</li>
<li>直接 IO：磁盘中的数据直接通过 DMA 拷贝到用户空间。</li>
</ul>
<h2 id="缓冲-IO"><a href="#缓冲-IO" class="headerlink" title="缓冲 IO"></a>缓冲 IO</h2><p>缓冲 IO 也被成为标准 IO，大多数的文件系统系统默认都是以缓冲 IO 的方式来工作的。在Linux的缓冲I&#x2F;O机制中，数据先从磁盘复制到内核空间的缓冲区，然后从内核空间缓冲区复制到应用程序的地址空间。</p>
<p>接下来我们看看缓冲 IO 下读写操作是如何进行？</p>
<ul>
<li><strong>读操作：</strong></li>
</ul>
<p>操作系统检查内核的缓冲区有没有需要的数据，如果已经缓冲了，那么就直接从缓冲中返回；否则从磁盘中读取到内核缓冲中，然后再复制到用户空间缓冲中。</p>
<ul>
<li><strong>写操作：</strong></li>
</ul>
<p>将数据从用户空间复制到内核空间的缓冲中。这时对用户程序来说写操作就已经完成，至于什么时候再写到磁盘中由操作系统决定，除非显示地调用了sync同步命令。</p>
<p><strong>缓冲I&#x2F;O的优点：</strong></p>
<ol>
<li>在一定程度上分离了内核空间和用户空间，保护系统本身的运行安全；</li>
<li>因为内核中有缓冲，可以减少读盘的次数，从而提高性能。</li>
</ol>
<p><strong>缓冲I&#x2F;O的缺点：</strong></p>
<p>在缓冲 I&#x2F;O 机制中，DMA 方式可以将数据直接从磁盘读到内核空间页缓冲中，或者将数据从内核空间页缓冲直接写回到磁盘上，而不能直接在用户地址空间和磁盘之间进行数据传输，这样数据在传输过程中需要在<strong>应用程序地址空间（用户空间）和内核缓冲（内核空间）之间进行多次数据拷贝操作</strong>，这些数据拷贝操作所带来的CPU以及内存开销是非常大的。</p>
<h2 id="直接IO"><a href="#直接IO" class="headerlink" title="直接IO"></a>直接IO</h2><p>顾名思义，直接IO就是应用程序直接访问磁盘数据，而不经过内核缓冲区，也就是绕过内核缓冲区,自己管理I&#x2F;O缓冲区，这样做的目的是减少一次从内核缓冲区到用户程序缓冲的数据复制。</p>
<p><img src="https://pic3.zhimg.com/80/v2-eb9db484a5b08330cf904600e94ea512_720w.webp" alt="img"></p>
<p>引入内核缓冲区这个主要是为了提升从磁盘读写数据文件的性能，这也是很多系统优化中常见的手段，多一层缓存可以有效减少很多磁盘 IO 操作；而当用户程序需要向磁盘文件中写入数据时，实际上只需要写入到内核缓冲区便可以返回了，而真正的落盘是有一定的延迟策略的，但这无疑提升了应用程序写入文件的响应速度。</p>
<p>在数据库管理系统这类应用中，它们更倾向于选择自己实现的缓存机制，因为数据库管理系统往往比操作系统更了解数据库中存放的数据，数据库管理系统可以提供一种更加有效的缓存机制来提高数据库中数据的存取性能。</p>
<p><strong>直接I&#x2F;O的优点：</strong></p>
<p>应用程序直接访问磁盘数据，不经过操作系统内核数据缓冲区，<strong>这样做的最直观目的是减少一次从内核缓冲区到用户程序缓冲的数据复制</strong>。这种方式通常用在数据库、消息中间件中，由应用程序来实现数据的缓存管理。</p>
<p><strong>直接I&#x2F;O的缺点：</strong></p>
<p>如果访问的数据不在应用程序缓冲中，那么每次数据都会直接从磁盘进行加载，这种直接加载会非常缓慢。通常 直接I&#x2F;O 跟 异步I&#x2F;O 结合使用会得到较好的性能。（异步IO：当访问数据的线程发出请求之后，线程会接着去处理其他事，而不是阻塞等待）</p>
<h2 id="IO-访问方式"><a href="#IO-访问方式" class="headerlink" title="IO 访问方式"></a>IO 访问方式</h2><p>我们常说的 IO 操作，不仅仅是磁盘 IO，还有常见的网络数据传输即网络 IO。</p>
<h2 id="磁盘-IO"><a href="#磁盘-IO" class="headerlink" title="磁盘 IO"></a>磁盘 IO</h2><p><img src="https://pic4.zhimg.com/80/v2-34502a85bd457d72981015ca3b1894db_720w.webp" alt="img"></p>
<p><strong>读操作：</strong></p>
<p>当应用程序调用read()方法时，操作系统检查内核高速缓冲区中是否存在需要的数据，如果存在，那么就直接把内核空间的数据copy到用户空间，供用户的应用程序使用。如果内核缓冲区没有需要的数据，通过通过DMA方式从磁盘中读取数据到内核缓冲区，然后由CPU控制，把内核空间的数据copy到用户空间。</p>
<p>这个过程会涉及到<strong>两次缓冲区copy</strong>，第一次是从磁盘到内核缓冲区，第二次是从内核缓冲区到用户缓冲区，第一次是DMA的copy，第二次是CPU的copy。</p>
<p><strong>写操作：</strong></p>
<p>当应用程序调用write()方法时，应用程序将数据从用户空间copy到内核空间的缓冲区中（如果用户空间没有相应的数据，则需要从磁盘—&gt;内核缓冲区—&gt;用户缓冲区），这时对用户程序来说写操作就已经完成，至于什么时候把数据再写到磁盘（从内核缓冲区到磁盘的写操作也由DMA控制，不需要cpu参与），由操作系统决定。除非应用程序显示地调用了sync命令，立即把数据写入磁盘。</p>
<p>如果应用程序没准备好写的数据，则必须先从磁盘读取数据才能执行写操作，这时会涉及到<strong>四次缓冲区的copy</strong>，第一次是从磁盘的缓冲区到内核缓冲区，第二次是从内核缓冲区到用户缓冲区，第三次是从用户缓冲区到内核缓冲区，第四次是从内核缓冲区写回到磁盘。前两次是为了读，后两次是为了写。这其中有<strong>两次</strong> CPU <strong>拷贝，两次</strong>DMA<strong>拷贝。</strong></p>
<p><strong>磁盘IO的延时：</strong></p>
<p>为了读或写，磁头必须能移动到所指定的磁道上，并等待所指定的扇区的开始位置旋转到磁头下，然后再开始读或写数据。磁盘IO的延时分成以下三部分：</p>
<ul>
<li><strong>寻道时间</strong>：把磁头移动到指定磁道上所经历的时间；</li>
<li><strong>旋转延迟时间</strong> ：指定扇区移动到磁头下面所经历的时间；</li>
<li><strong>传输时间</strong> ：数据的传输时间（数据读出或写入的时间）；</li>
</ul>
<h2 id="网络-IO"><a href="#网络-IO" class="headerlink" title="网络 IO"></a>网络 IO</h2><p><img src="https://pic3.zhimg.com/80/v2-74328815b30250d425d8b52ddb3931a6_720w.webp" alt="img"></p>
<p><strong>读操作：</strong></p>
<p>网络 IO 既可以从物理磁盘中读数据，也可以从Socket中读数据（从网卡中获取）。当从物理磁盘中读数据的时候，其流程和磁盘IO的读操作一样。当从Socket中读数据，应用程序需要等待客户端发送数据，如果客户端还没有发送数据，对应的应用程序将会被阻塞，直到客户端发送了数据，该应用程序才会被唤醒，从Socket协议栈（网卡）中读取客户端发送的数据到内核空间（这个过程也由DMA控制），然后把内核空间的数据 copy 到用户空间，供应用程序使用。</p>
<p><strong>写操作：</strong></p>
<p>为了简化描述，我们假设网络IO的数据从磁盘中获取，读写操作的流程如下：</p>
<ul>
<li>当应用程序调用read()方法时，通过DMA方式将数据从磁盘拷贝到内核缓冲区；</li>
<li>由cpu控制，将内核缓冲区的数据拷贝到用户空间的缓冲区中，供应用程序使用；</li>
<li>当应用程序调用 write() 方法时，CPU 会把用户缓冲区中的数据 copy 到内核缓冲区的 Socket Buffer 中；</li>
<li>最后通过DMA方式将内核空间中的Socket Buffer拷贝到Socket协议栈（即网卡设备）中传输；</li>
</ul>
<p><strong>网络IO</strong> 的写操作也有四次缓冲区的copy，第一次是从磁盘缓冲区到内核缓冲区（由DMA控制），第二次是内核缓冲区到用户缓冲区（CPU控制），第三次是用户缓冲区到内核缓冲区的 Socket Buffer（由CPU控制），第四次是从内核缓冲区的 Socket Buffer 到网卡设备（由DMA控制）。四次缓冲区的copy工作<strong>两次由CPU控制，两次由DMA控制</strong>。</p>
<p><strong>网络IO的延时:</strong></p>
<p>网络IO主要延时是由：<strong>服务器响应延时+带宽限制+网络延时+跳转路由延时+本地接收延时</strong> 决定。一般为几十到几千毫秒，受环境影响较大。所以，一般来说，网络IO延时要大于磁盘IO延时(不过同数据中心的交互除外，会比磁盘 IO 更快)。</p>
<h2 id="零拷贝-IO"><a href="#零拷贝-IO" class="headerlink" title="零拷贝 IO"></a>零拷贝 IO</h2><p>在上述IO中，一次读写操作要经过<strong>四次缓冲区的拷贝</strong>，并经历了<strong>四次内核态和用户态的切换</strong>。 <strong>零拷贝（zero copy）IO</strong> 技术减少不必要的内核缓冲区跟用户缓冲区之间的拷贝，从而减少CPU的开销和状态切换带来的开销，达到性能的提升。</p>
<p><strong>我们还是对比上面不使用零拷贝时的网络 IO 传输过程来对比分析下：</strong></p>
<p><img src="https://pic3.zhimg.com/80/v2-74328815b30250d425d8b52ddb3931a6_720w.webp" alt="img"></p>
<p><strong>和上图普通的网络 IO 传输过程对比，零拷贝的传输过程</strong>：硬盘 -&gt; kernel buffer (快速拷贝到kernel socket buffer) -&gt; Socket协议栈（网卡设备中）。</p>
<ul>
<li>当应用程序调用read()方法时，通过DMA方式将数据从磁盘拷贝到内核缓冲区；</li>
<li>由CPU控制，将内核缓冲区的数据直接拷贝到另外一个与 Socket 相关的内核缓冲区，即kernel socket buffer；</li>
<li>然后由 DMA 把数据从 kernel socket buffer 直接拷贝给 Socket 协议栈（网卡设备中）；</li>
</ul>
<p>这里，只<strong>经历了三次缓冲区的拷贝</strong>，<strong>第一次</strong>是从磁盘缓冲区到内核缓冲区，<strong>第二次是</strong>从内核缓冲区到 kernel socket buffer，<strong>第三次</strong>是从 kernel socket buffer 到Socket 协议栈（网卡设备中）。只发生<strong>两次内核态和用户态的切换</strong>，第一次是当应用程序调用read方法时，用户态切换到内核态执行read系统调用，第二次是将数据从网络中发送出去后系统调用返回，从内核态切换到用户态。</p>
<p><strong>零拷贝（zero copy）的应用：</strong></p>
<ul>
<li>Linux 下提供了zero copy的接口：sendfile和splice，用户可通过这两个接口实现零拷贝传输；</li>
<li>Nginx 可以通过sendfile配置开启零拷贝；</li>
<li>在 Linux 系统中，Java NIO中 FileChannel.transferTo 的实现依赖于 sendfile()调用；</li>
<li>Apache 使用了 sendfile64() 来传送文件，sendfile64() 是 sendfile() 的扩展实现；</li>
<li>Kafka也用到了零拷贝的功能；</li>
</ul>
<p>注意：零拷贝要求输入的fd必须是文件句柄，不能是socket，输出的fd必须是socket，也就是说，<strong>数据的来源必须是从本地的磁盘，而不能是从网络中</strong>，如果数据来源于socket，就不能使用零拷贝功能了。我们看一下sendfile接口就知道了：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/sendfile.h&gt;</span></span></span><br><span class="line"><span class="function"><span class="type">ssize_t</span> <span class="title">sendfile</span><span class="params">(<span class="type">int</span> out_fd, <span class="type">int</span> in_fd, <span class="type">off_t</span> *offset, <span class="type">size_t</span> count)</span></span></span><br></pre></td></tr></table></figure>

<ul>
<li>out_fd：待写入文件描述符;</li>
<li>in_fd：待读出文件描述符;</li>
<li>offset：从读入文件流的哪个位置开始读，如果为空，则默认从起始位置开始；</li>
<li>count：指定在文件描述符in_fd 和out_fd之间传输的字节数；</li>
<li>返回值：成功时，返回出传输的字节数，失败返回-1；</li>
</ul>
<p><strong>in_fd 必须指向真实的文件，不能是socket和管道；而out_fd则必须是一个socket。由此可见，</strong>sendfile <strong>几乎是专门为在网络上传输文件而设计的。</strong></p>
<p>在Linxu系统中，一切皆文件，因此socket也是一个文件，也有文件句柄（或文件描述符）。</p>
<h2 id="同步-异步、阻塞-非阻塞"><a href="#同步-异步、阻塞-非阻塞" class="headerlink" title="同步&amp;异步、阻塞&amp;非阻塞"></a>同步&amp;异步、阻塞&amp;非阻塞</h2><p>这两组概念，我接触编程以来，经过听到别人说服务端是 <strong>同步非阻塞模型</strong> 或者 <strong>异步阻塞的 IO 模型</strong>，也前后了解过几次，但是理解都不够透彻，特别是这个<strong>非阻塞和异步</strong>、<strong>同步和阻塞</strong>的概念很容易懵逼，每个人的说法都不一样，最近我耐心看了几篇文章，这次我感觉我是顿悟了，这里分享下我的理解：</p>
<p><strong>同步和异步</strong>是针对应用程序向内核发起任务后的状态而言的：如果发起调用后，在没有得到结果之前，当前调用就不返回，不能接着做后面的事情，一直等待就是<strong>同步</strong>。<strong>异步</strong>就是发出调用后，虽然不能立即得到结果，但是可以继续执行后面的事情，等调用结果出来时，会通过状态、通知和回调来通知调用者。</p>
<p>举个例子加深下理解：</p>
<ol>
<li>在互联网普及之前，我们去医院看病都是排队的模式，想看病就得排队等，直到轮到你，在此之前你必须一直排队等待，这个就是同步；</li>
<li>现在互联网普及了，都是直接大屏叫号，我们预约登记后，就可以去休息厅坐着，打游戏啥的都可以干，到自己看病的时候会有通知的，这就是异步；</li>
</ol>
<p><strong>阻塞blocking、非阻塞non-blocking，则聚焦的是CPU在等待结果的过程中的状态</strong>。</p>
<p><strong>阻塞调用</strong>是指调用结果返回之前，当前线程会被挂起，只有在得到结果之后才会返回。你可能会把阻塞调用和同步调用等同起来，实际上它们是不同的，同步只是说必须等到出结果才可以返回，但是等的过程中线程可以是激活的，阻塞是说线程被挂起了。</p>
<p><strong>非阻塞</strong>和阻塞的概念相对应，指在不能立刻得到结果之前，该函数不会阻塞当前线程，而会立刻返回。</p>
<p>比如前面的例子，排队的过程中什么也不能做就是阻塞，CPU 执行权是交出去的；一边排队，一边看手机就是非阻塞，CPU 执行权还在自己手里，但是没看完病之前依旧是在排队死等，所以还是同步的。</p>
<h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>通过今天的学习，我们掌握了什么是 IO、常见的 IO 操作类型以及对应操作的原理，还有非常重要但是却很容易搞混的同步&amp;异步、阻塞&amp;非阻塞之间的区别，讲解的应该还是比较清楚的。</p>
<p>本文内容还是比较简单的，是一些基础知识，但是如果想深入学习网络编程这些基础是绕不开的，了解了操作系统对于 IO 操作的优化，才能搞明白各种高性能网络服务器的原理。</p>
<hr>
<p>版权声明：本文为知乎博主「玩转Linux内核」的原创文章，遵循CC 4.0 BY-SA版权协议，转载请附上原文出处链接及本声明。</p>
<p>原文链接：<a href="https://zhuanlan.zhihu.com/p/473639031">https://zhuanlan.zhihu.com/p/473639031</a></p>
]]></content>
      <categories>
        <category>linux-doc 进程管理</category>
      </categories>
      <tags>
        <tag>Linux</tag>
      </tags>
  </entry>
  <entry>
    <title>Linux内核Socket通信原理和实例讲解</title>
    <url>/2023/01/15/linux-docs/%E8%BF%9B%E7%A8%8B%E7%AE%A1%E7%90%86/Linux%E5%86%85%E6%A0%B8Socket%E9%80%9A%E4%BF%A1%E5%8E%9F%E7%90%86%E5%92%8C%E5%AE%9E%E4%BE%8B%E8%AE%B2%E8%A7%A3/</url>
    <content><![CDATA[<p>关于对 Socket 的认识，大致分为下面几个主题，Socket 是什么，Socket 是如何创建的，Socket 是如何连接并收发数据的，Socket 套接字的删除等。</p>
<h2 id="Socket-是什么以及创建过程"><a href="#Socket-是什么以及创建过程" class="headerlink" title="Socket 是什么以及创建过程"></a>Socket 是什么以及创建过程</h2><p>一个数据包经由应用程序产生，进入到协议栈中进行各种报文头的包装，然后操作系统调用网卡驱动程序指挥硬件，把数据发送到对端主机。整个过程的大体的图示如下。</p>
<p><img src="https://pic4.zhimg.com/80/v2-b838df0614d9571278458f5e9a66881b_720w.webp" alt="img"></p>
<p>我们大家知道，协议栈其实是位于操作系统中的一些协议的堆叠，这些协议包括 TCP、UDP、ARP、ICMP、IP等。</p>
<p>通常某个协议的设计都是为了解决某些问题，比如 TCP 的设计就负责安全可靠的传输数据，UDP 设计就是报文小，传输效率高，ARP 的设计是能够通过 IP 地址查询物理（Mac）地址，ICMP 的设计目的是返回错误报文给主机，IP 设计的目的是为了实现大规模主机的互联互通。</p>
<p>应用程序比如浏览器、电子邮件、文件传输服务器等产生的数据，会通过传输层协议进行传输，而应用程序是不会和传输层直接建立联系的，而是有一个能够连接应用层和传输层之间的套件，这个套件就是 <code>Socket</code>。</p>
<p>在上面这幅图中，应用程序包含 Socket 和解析器，解析器的作用就是向 DNS 服务器发起查询，查询目标 IP 地址。</p>
<p>应用程序的下面就是操作系统内部，操作系统内部包括协议栈，协议栈是一系列协议的堆叠。操作系统下面就是网卡驱动程序，网卡驱动程序负责控制网卡硬件，驱动程序驱动网卡硬件完成收发工作。</p>
<p>在操作系统内部有一块用于存放控制信息的存储空间，这块存储空间记录了用于控制通信的控制信息。其实这些控制信息就是 Socket 的实体，或者说存放控制信息的内存空间就是套接字的实体。</p>
<p>这里大家有可能不太清楚所以然，所以我用了一下 netstat 命令来给大伙看一下套接字是啥玩意。</p>
<p>我们在 Windows 的命令提示符中输入</p>
<figure class="highlight text"><table><tr><td class="code"><pre><span class="line">netstat -ano</span><br><span class="line"></span><br><span class="line"># netstat 用于显示套接字内容 , -ano 是可选选项</span><br><span class="line"># a 不仅显示正在通信的套接字，还显示包括尚未开始通信等状态的所有套接字</span><br><span class="line"># n 显示 IP 地址和端口号</span><br><span class="line"># o 显示套接字的程序 PID</span><br></pre></td></tr></table></figure>

<p>我的计算机会出现下面结果。</p>
<p><img src="https://pic3.zhimg.com/80/v2-a5b445147b1f4a683500901d35704662_720w.webp" alt="img"></p>
<p>图中的每一行都相当于一个套接字，每一列也被称为一个元组，所以一个套接字就是五元组（协议、本地地址、外部地址、状态、PID）。有的时候也被叫做四元组，四元组不包括协议。</p>
<p>比如图中的第一行，它的协议就是 TCP，本地地址和远程地址都是 0.0.0.0，这表示通信还没有开始，IP 地址暂时还未确定，而本地端口已知是 135，但是远程端口还未知，此时的状态是 <code>LISTENING</code>，LISTENING 表示应用程序已经打开，正在等待与远程主机建立连接最后一个元组是 PID，即进程标识符，PID 就像我们的身份证号码，能够精确定位唯一的进程。</p>
<p>现在你可能对 Socket 有了一个基本的认识，现在喝口水，休息一下，让我们继续探究 Socket。</p>
<blockquote>
<p>现在我有个问题，Socket 是如何创建的呢？</p>
</blockquote>
<p>Socket 是和应用程序一起创建的。应用程序中有一个 socket 组件，在应用程序启动时，会调用 socket 申请创建套接字，协议栈会根据应用程序的申请创建套接字：首先分配一个套接字所需的内存空间，这一步相当于是为控制信息准备一个容器，但只有容器并没有实际作用，所以你还需要向容器中放入控制信息；如果你不申请创建套接字所需要的内存空间，你创建的控制信息也没有地方存放，所以分配内存空间，放入控制信息缺一不可。至此套接字的创建就已经完成了。</p>
<p>套接字创建完成后，会返回一个套接字描述符给应用程序，这个描述符相当于是区分不同套接字的号码牌。根据这个描述符，应用程序在委托协议栈收发数据时就需要提供这个描述符。</p>
<h2 id="套接字连接"><a href="#套接字连接" class="headerlink" title="套接字连接"></a>套接字连接</h2><p>套接字创建完成后，最终还是为数据收发服务的，在数据收发之前，还需要进行一步 <code>connect</code>，也就是建立连接的过程。这个连接并不是真实的连接：用一根水管插在两个电脑之间。</p>
<p><img src="https://pic2.zhimg.com/80/v2-1265822e684296039e21bcdb407fca81_720w.webp" alt="img"></p>
<p>而是应用程序通过 TCP&#x2F;IP 协议标准从一个主机通过网络介质传输到另一个主机的过程。</p>
<p>套接字刚刚创建完成后，还没有数据，也不知道通信对象。在这种状态下，即使你让客户端应用程序委托协议栈发送数据，它也不知道发送到哪里。</p>
<p>所以浏览器需要根据网址来查询服务器的 IP 地址，做这项工作的协议是 DNS，查询到目标主机后，再把目标主机的 IP 告诉协议栈，至此，客户端这边就准备好了。</p>
<p>在服务器上，与客户端一样也需要创建套接字，但是同样的它也不知道通信对象是谁，所以我们需要让客户端向服务器告知客户端的必要信息：IP 地址和端口号。</p>
<p>现在通信双方建立连接的必要信息已经具备，只欠一股东南风了。通信双方收到数据之后，还需要一块<code>位置</code>来存放，这个位置就是缓冲区，它是内存的一部分，有了缓冲区，就能够进行数据的收发操作了。</p>
<p>OK，现在客户端想要给服务器发送一条数据，该进行哪些操作呢？</p>
<p>首先，客户端应用程序需要调用 <code>Socket</code> 库中的 connect 方法，提供 socket 描述符和服务器 IP 地址、端口号。</p>
<figure class="highlight text"><table><tr><td class="code"><pre><span class="line">connect(&lt;描述符&gt;、&lt;服务器IP地址和端口号&gt;)</span><br></pre></td></tr></table></figure>

<p>这些信息会传递给协议栈中的 TCP 模块，TCP 模块会对请求报文进行封装，再传递给 IP 模块，进行 IP 报文头的封装，然后传递给物理层，进行帧头封装，之后通过网络介质传递给服务器，服务器上会对帧头、IP 模块、TCP 模块的报文头进行解析，从而找到对应的套接字，套接字收到请求后，会写入相应的信息，并且把状态改为正在连接。请求过程完成后，服务器的 TCP 模块会返回响应，这个过程和客户端是一样的。</p>
<p>在一个完整的请求和响应过程中，控制信息起到非常关键的作用（具体的作用我们后面会说）。</p>
<ul>
<li>SYN 就是同步的缩写，客户端会首先发送 SYN 数据包，请求服务端建立连接。</li>
<li>ACK 就是相应的意思，它是对发送 SYN 数据包的响应。</li>
<li>FIN 是终止的意思，它表示客户端&#x2F;服务器想要终止连接。</li>
</ul>
<p>由于网络环境的复杂多变，经常会存在数据包丢失的情况，所以双方通信时需要相互确认对方的数据包是否已经到达，而判断的标准就是 ACK 的值。</p>
<p>当所有建立连接的报文都能够正常收发之后，此时套接字就已经进入可收发状态了，此时可以认为用一根管理把两个套接字连接了起来。</p>
<p>当然，实际上并不存在这个管子。建立连接之后，协议栈的连接操作就结束了，也就是说 connect 已经执行完毕，控制流程被交回给应用程序。</p>
<h2 id="收发数据"><a href="#收发数据" class="headerlink" title="收发数据"></a>收发数据</h2><p>当控制流程从 connect 回到应用程序之后，接下来就会直接进入数据收发阶段，数据收发操作是从应用程序调用 write 将要发送的数据交给协议栈开始的，协议栈收到数据之后执行发送操作。</p>
<p>协议栈不会关心应用程序传输过来的是什么数据，因为这些数据最终都会转换为二进制序列，协议栈在收到数据之后并不会马上把数据发送出去，而是会将数据放在发送缓冲区，再等待应用程序发送下一条数据。</p>
<blockquote>
<p>为什么收到数据包不会直接发送出去，而是放在缓冲区中呢？</p>
</blockquote>
<p>因为只要一旦收到数据就会发送，就有可能发送大量的小数据包，导致网络效率下降。所以协议栈需要将数据积攒到一定数量才能将其发送出去。</p>
<p>至于协议栈会向缓冲区放多少数据，这个不同版本和种类的操作系统有不同的说法，不过，所有的操作系统和种类都会遵循下面这几个标准：</p>
<ul>
<li>第一个判断要素是每个网络包能够容纳的数据长度，判断的标准是 <code>MTU</code>，它表示的是一个网络包的最大长度。最大长度包含头部，所以如果单论数据区的话，就会用 MTU - 包头长度，由此的出来的最大数据长度被称为 <code>MSS</code>。</li>
</ul>
<p><img src="https://pic4.zhimg.com/80/v2-670942c264b4cdf4f61136c33aaed673_720w.webp" alt="img"></p>
<ul>
<li>另一个判断标准是时间，当应用程序产生的数据比较少，协议栈向缓冲区放置数据效率不高时，如果每次都等到 MSS 再发送的话，可能因为等待时间太长造成延迟，在这种情况下，即使数据长度没有到达 MSS，也应该把数据发送出去。</li>
</ul>
<p>协议栈并没有告诉我们怎样平衡这两个因素，如果数据长度优先，那么效率有可能比较低；如果时间优先，那又会降低网络的效率。</p>
<p>经过了一段时间。。。。。。</p>
<p>假设我们使用的是长度有限法则，此时缓冲区已满，协议栈要发送数据了，协议栈刚要把数据发送出去，却发现无法一次性传输这么大数据量（相对的）的数据，那怎么办呢？</p>
<p>在这种情况下，发送缓冲区中的数据就会超过 MSS 的长度，发送缓冲区中的数据会以 MSS 大小为一个数据包进行拆分，拆分出来的每块数据都会加上 TCP，IP，以太网头部，然后被放进单独的网络包中。</p>
<p><img src="https://pic2.zhimg.com/80/v2-72b79d039f90d1c870ff1e2b3800358d_720w.webp" alt="img"></p>
<p>到现在，网络包已经准备好发往服务器了，但是数据发送操作还没有结束，因为服务器还未确认是否已经收到网络包。因此在客户端发送数据包之后，还需要服务器进行确认。</p>
<p>TCP 模块在拆分数据时，会计算出网络包偏移量，这个偏移量就是相对于数据从头开始计算的第几个字节，并将算好的字节数写在 TCP 头部，TCP 模块还会生成一个网络包的序号（SYN），这个序号是唯一的，这个序号就是用来让服务器进行确认的。</p>
<p>服务器会对客户端发送过来的数据包进行确认，确认无误之后，服务器会生成一个序号和确认号（ACK）并一起发送给客户端，客户端确认之后再发送确认号给服务器。</p>
<p>我们来看一下实际的工作过程。</p>
<p><img src="https://pic2.zhimg.com/80/v2-c1e671559bc61cec165eda2b17b11aa1_720w.webp" alt="img"></p>
<p>首先，客户端在连接时需要计算出序号初始值，并将这个值发送给服务器。接下来，服务器通过这个初始值计算出 确认号并返回给客户端。初始值在通信过程中有可能会丢弃，因此当服务器收到初始值后需要返回确认号用于确认。</p>
<p>同时，服务器也需要计算出从服务器到客户端方向的序号初始值，并将这个值发送给客户端。然后，客户端也需要根据服务器发来的初始值计算出确认号发送给服务器，至此，连接建立完成，接下来就可以进入数据收发阶段了。</p>
<p>数据收发阶段中，通信双方可以同时发送请求和响应，双方也可以同时对请求进行确认。</p>
<p>请求 - 确认机制非常强大，通过这一机制，我们可以确认接收方有没有收到某个包，如果没有收到则重新发送，这样一来，但凡网络中出现的任何错误，我们都可以即使发现并补救。</p>
<p>网卡、集线器、路由器都没有错误补救机制，一旦检测到错误就会直接丢弃数据包，应用程序也没有这种机制，起作用的只是 TCP&#x2F;IP 模块。</p>
<p>由于网络环境复杂多变，所以数据包会存在丢失情况，因此发送序号和确认号也存在一定规则，TCP 会通过窗口管理确认号。</p>
<h2 id="断开连接"><a href="#断开连接" class="headerlink" title="断开连接"></a>断开连接</h2><p>当通信双方不再需要收发数据时，需要断开连接。不同的应用程序断开连接的时机不同。以 Web 为例，浏览器向 Web 服务器发送请求消息，Web 服务器再返回响应消息，这时收发数据就全部结束了，服务器可能会首先发起断开响应，当然客户端也有可能会首先发起（谁先断开连接是应用程序做出的判断），与协议栈无关。</p>
<p><img src="https://pic1.zhimg.com/80/v2-6dea3d6396e50e893dce276ef83c1570_720w.webp" alt="img"></p>
<p>无论哪一方发起断开连接的请求，都会调用 Socket 库的 close 程序。我们以服务器断开连接为例，服务器发起断开连接请求，协议栈会生成断开连接的 TCP 头部，其实就是设置 FIN 位，然后委托 IP 模块向客户端发送数据，与此同时，服务器的套接字会记录下断开连接的相关信息。</p>
<p>收到服务器发来 FIN 请求后，客户端协议栈会将套接字标记为断开连接状态，然后，客户端会向服务器返回一个确认号，这是断开连接的第一步，在这一步之后，应用程序还会调用 read 来读取数据。等到服务器数据发送完成后，协议栈会通知客户端应用程序数据已经接收完毕。</p>
<p>只要收到服务器返回的所有数据，客户端就会调用 close 程序来结束收发操作，这时客户端会生成一个 FIN 发送给服务器，一段时间后服务器返回 ACK 号，至此，客户端和服务器的通信就结束了。</p>
<h2 id="删除套接字"><a href="#删除套接字" class="headerlink" title="删除套接字"></a>删除套接字</h2><p>通信完成后，用来通信的套接字就不再会使用了，此时我们就可以删除这个套接字了。不过，这时候套接字不会马上删除，而是等过一段时间再删除。</p>
<p>等待这段时间是为了防止误操作，最常见的误操作就是客户端返回的确认号丢失，至于等待多长时间，和数据包重传的方式有关。</p>
<hr>
<p>版权声明：本文为知乎博主「玩转Linux内核」的原创文章，遵循CC 4.0 BY-SA版权协议，转载请附上原文出处链接及本声明。</p>
<p>原文链接：<a href="https://zhuanlan.zhihu.com/p/456631465">https://zhuanlan.zhihu.com/p/456631465</a></p>
]]></content>
      <categories>
        <category>linux-doc 进程管理</category>
      </categories>
      <tags>
        <tag>Linux</tag>
      </tags>
  </entry>
  <entry>
    <title>Linux内核crash分析内核死锁实践</title>
    <url>/2023/01/15/linux-docs/%E8%BF%9B%E7%A8%8B%E7%AE%A1%E7%90%86/Linux%E5%86%85%E6%A0%B8crash%E5%88%86%E6%9E%90%E5%86%85%E6%A0%B8%E6%AD%BB%E9%94%81%E5%AE%9E%E8%B7%B5/</url>
    <content><![CDATA[<p><strong>上文</strong>讲了<a href="https://zhuanlan.zhihu.com/p/530245778">内核死锁的debug方法</a>通过lockdep的方式可以debug出死锁的信息，但是如果出问题的系统没有lockdep的配置，或者没有相关的日志该怎么办？这里分享通过crash工具来动态检测死锁时的问题</p>
<h2 id="1、用crash初步分析"><a href="#1、用crash初步分析" class="headerlink" title="1、用crash初步分析"></a>1、<strong>用crash初步分析</strong></h2><p>一般卡死时可能是因为核心线程处在UNINTERRUPTIBLE状态，所以先在crash环境下用ps命令查看系统中UNINTERRUPTIBLE状态的线程，参数-u可过滤掉内核线程：</p>
<p><img src="https://pic1.zhimg.com/80/v2-af83b50e3cb6e82e395c446479b405c8_720w.webp" alt="img"></p>
<p>bt命令可查看某个线程的调用栈，我们看一下上面UN状态的最关键的watchdog线程：</p>
<p><img src="https://pic3.zhimg.com/80/v2-0676823081756009a0ab52c5eadce836_720w.webp" alt="img"></p>
<p>从调用栈中可以看到proc_pid_cmdline_read()函数中被阻塞的，对应的代码为：</p>
<figure class="highlight text"><table><tr><td class="code"><pre><span class="line">static ssize_t proc_pid_cmdline_read(struct file *file, char __user *buf,</span><br><span class="line">         size_t _count, loff_t *pos)</span><br><span class="line">&#123;</span><br><span class="line">  ......</span><br><span class="line"> tsk = get_proc_task(file_inode(file));</span><br><span class="line"> if (!tsk)</span><br><span class="line">  return -ESRCH;</span><br><span class="line"> mm = get_task_mm(tsk);</span><br><span class="line"> put_task_struct(tsk);</span><br><span class="line">  ......</span><br><span class="line"> down_read(&amp;mm-&gt;mmap_sem);</span><br><span class="line">  ......</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这里是要获取被某个线程mm的mmap_sem锁，而这个锁又被另外一个线程持有。</p>
<h2 id="2、推导读写锁"><a href="#2、推导读写锁" class="headerlink" title="2、推导读写锁"></a>2、<strong>推导读写锁</strong></h2><p>要想知道哪个线程持有了这把锁，我们得先用汇编推导出这个锁的具体值。可用dis命令看一下proc_pid_cmdline_read()的汇编代码：</p>
<p><img src="https://pic1.zhimg.com/80/v2-618822b148611a685866300712d9e578_720w.webp" alt="img"></p>
<p>0xffffff99a680aaa0处就是调用down_read()的地方，它的第一个参数x0就是sem锁，如：</p>
<figure class="highlight text"><table><tr><td class="code"><pre><span class="line">void __sched down_read(struct rw_semaphore *sem)</span><br></pre></td></tr></table></figure>

<p>x0和x28寄存器存放的就是sem的值，那x21自然就是mm_struct的地址了，因为mm_struct的mmap_sem成员的offset就是104（0x68），用whatis命令可以查看结构体的声明，如：</p>
<p><img src="https://pic4.zhimg.com/80/v2-28b0837d9adbeb4131739c9c8b586f07_720w.webp" alt="img"></p>
<p>因此我们只需要知道<strong>x21</strong>或者<strong>x28</strong>就知道mm和mmap_sem锁的值。</p>
<p>函数调用时被调用函数会在自己的栈帧中保存即将被修改到的寄存器，所以我们可以在down_read()及它之后的函数调用中找到这两个寄存器：</p>
<p>也就是说下面几个函数中，只要找到用到x21或x28，必然会在它的栈帧中保存这些寄存器。</p>
<p><img src="https://pic3.zhimg.com/80/v2-41d9ab4c760b815cc8928610f87ce80a_720w.webp" alt="img"></p>
<p>先从最底部的down_read()开始找：</p>
<p><img src="https://pic2.zhimg.com/80/v2-3f0b47735415221a89761ca90982e5f5_720w.webp" alt="img"></p>
<p>显然它没有用到x21或x28，继续看rwsem_down_read_failed()的汇编代码：</p>
<p><img src="https://pic1.zhimg.com/80/v2-e22079801eb115f51f5f661a56e466f8_720w.webp" alt="img"></p>
<p>在这个函数中找到x21，它保存在rwsem_down_read_failed栈帧的偏移32字节的位置。rwsem_down_read_failed()的sp是0xffffffd6d9e4bcb0</p>
<p><img src="https://pic1.zhimg.com/80/v2-c16f4d079297c7590b798848d0f7d450_720w.webp" alt="img"></p>
<p>sp + 32 &#x3D;0xffffffd6d9e4bcd0，用rd命令查看地址0xffffffd6d9e4bcd0中存放的x21的值为：</p>
<p><img src="https://pic2.zhimg.com/80/v2-f907dbc910c60f04bbe19d62d70cfad9_720w.webp" alt="img"></p>
<p>用struct命令查看这个mm_struct：</p>
<p><img src="https://pic3.zhimg.com/80/v2-e9df81b47d226780e9de9ed57a3c8402_720w.webp" alt="img"></p>
<p>这里的owner是mm_struct所属线程的task_struct：</p>
<p><img src="https://pic2.zhimg.com/80/v2-6e4c4c75de9002d5500d7a9ec99efe99_720w.webp" alt="img"></p>
<p>sem锁的地址为0xffffffd76e349a00+0x68 &#x3D; <strong>0xffffffd76e349a68</strong>，所以：</p>
<p><img src="https://pic3.zhimg.com/80/v2-9ffa5ba58bda3876216ca0bc7413e0c2_720w.webp" alt="img"></p>
<p>分析到这里我们知道watchdog线程是在读取1651线程的proc节点时被阻塞了，原因是这个进程的mm，它的mmap_sem锁被其他线程给拿住了，那到底是谁持了这把锁呢？</p>
<h2 id="3、持读写锁的线程"><a href="#3、持读写锁的线程" class="headerlink" title="3、持读写锁的线程"></a><strong>3、持读写锁的线程</strong></h2><p>带着问题我们继续分析，通过search命令加-t参数从系统中所有的线程的栈空间里查找当前锁：</p>
<p><img src="https://pic4.zhimg.com/80/v2-32685f147f05f632f329effd8a510923_720w.webp" alt="img"></p>
<p>一般锁的值都会保存在寄存器中，而寄存器又会在子函数调用过程中保存在栈中。所以只要在栈空间中找到当前锁的值（<strong>0xffffffd76e349a68</strong>），那这个线程很可能就是持锁或者等锁线程</p>
<p>这里搜出的20个线程中19个就是前面提到的等锁线程，剩下的1个很可能就是持锁线程了：</p>
<p><img src="https://pic2.zhimg.com/80/v2-9816f4f7ac4253a82371c004c2a4b621_720w.webp" alt="img"></p>
<p>查看这个线程的调用栈：</p>
<p><img src="https://pic2.zhimg.com/80/v2-4ac94a68e687757b6ade9e3b1fbf2271_720w.webp" alt="img"></p>
<p>由于<strong>2124</strong>线程中存放锁的地址是0xffffffd6d396b8b0，这个是在handle_mm_fault()的栈帧范围内，因此可以推断持锁的函数应该是在handle_mm_fault()之前。</p>
<p>我们先看一下do_page_fault函数：</p>
<p><img src="https://pic3.zhimg.com/80/v2-0f6766d9b808edd1dc03ba347b7601d2_720w.webp" alt="img"></p>
<p>代码中确实是存在持mmap_sem的地方，并且是读者，因此可以确定是<strong>2124</strong>持有的读写锁阻塞了watchdog在内的19个线程。</p>
<p>接下来我们需要看一下<strong>2124</strong>线程为什么会持锁后迟迟不释放就可以了。</p>
<h2 id="4、死锁"><a href="#4、死锁" class="headerlink" title="4、死锁"></a>4、死锁</h2><p>可以看出2124线程是等待fuse的处理结果，而我们知道fuse的请求是sdcard来处理的。</p>
<p>在log中我们看到的确有sdcard相关的UNINTERRUPTIBLE状态的线程<strong>2767</strong>：</p>
<p><img src="https://pic3.zhimg.com/80/v2-8e77ae4d347f45d482c43afb400bf1a6_720w.webp" alt="img"></p>
<p>得2767线程等待的mutex锁是0xffffffd6948f4090，</p>
<p>它的owner的task和pid为：</p>
<p><img src="https://pic1.zhimg.com/80/v2-616923a2b415a2306f9765afe108baa0_720w.webp" alt="img"></p>
<p>先通过bt命令查找2124的栈范围为0xffffffd6d396b4b0～0xffffffd6d396be70：</p>
<p><img src="https://pic1.zhimg.com/80/v2-75e7a8881d999f518bbc62c9e5fd6084_720w.webp" alt="img"></p>
<p>从栈里面可以找到mutex：</p>
<p><img src="https://pic4.zhimg.com/80/v2-a1de4a1d80ec85e490fbaf680e02e2ff_720w.webp" alt="img"></p>
<p>mutex值在ffffffd6d396bc40这个地址上找到了，它是在__generic_file_write_iter的栈帧里。</p>
<p><img src="https://pic2.zhimg.com/80/v2-625bd18a344e15f11f707e70b53a9309_720w.webp" alt="img"></p>
<p>那可以肯定是在__generic_file_write_iter之前就持锁了，并且很可能是ext4_file_write_iter中，查看其源码：</p>
<p><img src="https://pic2.zhimg.com/80/v2-a1a16f2a1eff090dce02df44864b271d_720w.webp" alt="img"></p>
<p>这下清楚了，原来2124在等待2767处理fuse请求，而2767又被2124线程持有的mutex锁给锁住了，也就是说两个线程互锁了。</p>
<hr>
<p>版权声明：本文为知乎博主「Linux内核库」的原创文章，遵循CC 4.0 BY-SA版权协议，转载请附上原文 出处链接及本声明。</p>
<p>原文链接：<a href="https://zhuanlan.zhihu.com/p/530352450">https://zhuanlan.zhihu.com/p/530352450</a></p>
]]></content>
      <categories>
        <category>linux-doc 进程管理</category>
      </categories>
      <tags>
        <tag>Linux</tag>
      </tags>
  </entry>
  <entry>
    <title>Linux内核之进程和线程的创建和派生</title>
    <url>/2023/01/15/linux-docs/%E8%BF%9B%E7%A8%8B%E7%AE%A1%E7%90%86/Linux%E5%86%85%E6%A0%B8%E4%B9%8B%E8%BF%9B%E7%A8%8B%E5%92%8C%E7%BA%BF%E7%A8%8B%E7%9A%84%E5%88%9B%E5%BB%BA%E5%92%8C%E6%B4%BE%E7%94%9F/</url>
    <content><![CDATA[<h2 id="1、前言"><a href="#1、前言" class="headerlink" title="1、前言"></a>1、前言</h2><p>在前文中，我们分析了内核中进程和线程的统一结构体task_struct，本文将继续分析进程、线程的创建和派生的过程。首先介绍如何将一个程序编辑为执行文件最后成为进程执行，然后会介绍线程的执行，最后会分析如何通过已有的进程、线程实现多进程、多线程。因为进程和线程有诸多相似之处，也有一些不同之处，因此本文会对比进程和线程来加深理解和记忆。</p>
<h2 id="2、-进程的创建"><a href="#2、-进程的创建" class="headerlink" title="2、 进程的创建"></a>2、 进程的创建</h2><p>以C语言为例，我们在Linux下编写C语言代码，然后通过gcc编译和链接生成可执行文件后直接执行即可完成一个进程的创建和工作。下面将详细介绍这个创建进程的过程。在 Linux 下面，二进制的程序也要有严格的格式，这个格式我们称为 ELF（Executable and Linkable Format，可执行与可链接格式）。这个格式可以根据编译的结果不同，分为不同的格式。主要包括</p>
<p>1、可重定位的对象文件(Relocatable file)</p>
<p>由汇编器汇编生成的 .o 文件</p>
<p>2、可执行的对象文件(Executable file)</p>
<p>可执行应用程序</p>
<p>3、可被共享的对象文件(Shared object file)</p>
<p>动态库文件，也就是 .so 文件</p>
<p>下面在进程创建过程中会详细说明三种文件。</p>
<h3 id="2-1-编译"><a href="#2-1-编译" class="headerlink" title="2. 1 编译"></a>2. 1 编译</h3><p>写完C程序后第一步就是程序编译（其实还有IDE的预编译，那些属于编辑器操作这里不表）。编译指令如下所示</p>
<figure class="highlight text"><table><tr><td class="code"><pre><span class="line">gcc -c -fPIC xxxx.c</span><br></pre></td></tr></table></figure>

<p>-c表示编译、汇编指定的源文件，不进行链接。-fPIC表示生成与位置无关（Position-Independent Code）代码，即采用相对地址而非绝对地址，从而满足共享库加载需求。在编译的时候，先做预处理工作，例如将头文件嵌入到正文中，将定义的宏展开，然后就是真正的编译过程，最终编译成为.o 文件，这就是 ELF 的第一种类型，可重定位文件（Relocatable File）。之所以叫做可重定位文件，是因为对于编译好的代码和变量，将来加载到内存里面的时候，都是要加载到一定位置的。比如说，调用一个函数，其实就是跳到这个函数所在的代码位置执行；再比如修改一个全局变量，也是要到变量的位置那里去修改。但是现在这个时候，还是.o 文件，不是一个可以直接运行的程序，这里面只是部分代码片段。因此.o 里面的位置是不确定的，但是必须要重新定位以适应需求。</p>
<p><img src="https://pic1.zhimg.com/80/v2-b1b1c6683f929bec6653c449a1718864_720w.webp" alt="img"></p>
<p>ELF文件的开头是用于描述整个文件的。这个文件格式在内核中有定义，分别为 struct elf32_hdr 和struct elf64_hdr。</p>
<p><strong>其他各个section作用如下所示：</strong></p>
<ul>
<li>.text：放编译好的二进制可执行代码</li>
<li>.rodata：只读数据，例如字符串常量、const 的变量</li>
<li>.data：已经初始化好的全局变量</li>
<li>.bss：未初始化全局变量，运行时会置 0</li>
<li>.symtab：符号表，记录的则是函数和变量</li>
<li>.rel.text： .text部分的重定位表</li>
<li>.rel.data：.data部分的重定位表</li>
<li>.strtab：字符串表、字符串常量和变量名</li>
</ul>
<p>这些节的元数据信息也需要有一个地方保存，就是最后的节头部表（Section Header Table）。在这个表里面，每一个 section 都有一项，在代码里面也有定义 struct elf32_shdr和struct elf64_shdr。在 ELF 的头里面，有描述这个文件的接头部表的位置，有多少个表项等等信息。</p>
<h3 id="2-2-链接"><a href="#2-2-链接" class="headerlink" title="2.2 链接"></a>2.2 链接</h3><p>链接分为静态链接和动态链接。静态链接库会和目标文件通过链接生成一个可执行文件，而动态链接则会通过链接形成动态连接器，在可执行文件执行的时候动态的选择并加载其中的部分或全部函数。</p>
<p><strong>二者的各自优缺点如下所示：</strong></p>
<ul>
<li><strong>静态链接库的优点</strong></li>
</ul>
<p>(1) 代码装载速度快，执行速度略比动态链接库快；</p>
<p>(2) 只需保证在开发者的计算机中有正确的.LIB文件，在以二进制形式发布程序时不需考虑在用户的计算机上.LIB文件是否存在及版本问题，可避免DLL地狱等问题。</p>
<ul>
<li><strong>静态链接库的缺点</strong></li>
</ul>
<p>使用静态链接生成的可执行文件体积较大，包含相同的公共代码，造成浪费</p>
<ul>
<li><strong>动态链接库的优点</strong></li>
</ul>
<p>(1) 更加节省内存并减少页面交换；</p>
<p>(2) DLL文件与EXE文件独立，只要输出接口不变（即名称、参数、返回值类型和调用约定不变），更换DLL文件不会对EXE文件造成任何影响，因而极大地提高了可维护性和可扩展性；</p>
<p>(3) 不同编程语言编写的程序只要按照函数调用约定就可以调用同一个DLL函数；</p>
<p>(4)适用于大规模的软件开发，使开发过程独立、耦合度小，便于不同开发者和开发组织之间进行开发和测试。</p>
<ul>
<li><strong>动态链接库的缺点</strong></li>
</ul>
<p>使用动态链接库的应用程序不是自完备的，它依赖的DLL模块也要存在，如果使用载入时动态链接，程序启动时发现DLL不存在，系统将终止程序并给出错误信息。而使用运行时动态链接，系统不会终止，但由于DLL中的导出函数不可用，程序会加载失败；速度比静态连接慢。当某个模块更新后，如果新的模块与旧的模块不兼容，那么那些需要该模块才能运行的软件均无法执行。这在早期Windows中很常见。</p>
<p><strong>下面分别介绍静态链接和动态链接：</strong></p>
<h4 id="2-2-1-静态链接"><a href="#2-2-1-静态链接" class="headerlink" title="2.2.1 静态链接"></a>2.2.1 静态链接</h4><p>静态链接库.a文件（Archives）的执行指令如下</p>
<figure class="highlight text"><table><tr><td class="code"><pre><span class="line">ar cr libXXX.a XXX.o XXXX.o</span><br></pre></td></tr></table></figure>

<p>当需要使用该静态库的时候，会将.o文件从.a文件中依次抽取并链接到程序中，指令如下</p>
<figure class="highlight text"><table><tr><td class="code"><pre><span class="line">gcc -o XXXX XXX.O -L. -lsXXX</span><br></pre></td></tr></table></figure>

<p>-L表示在当前目录下找.a 文件，-lsXXXX会自动补全文件名，比如加前缀 lib，后缀.a，变成libXXX.a，找到这个.a文件后，将里面的 XXXX.o 取出来，和 XXX.o 做一个链接，形成二进制执行文件XXXX。在这里，重定位会从.o中抽取函数并和.a中的文件抽取的函数进行合并，找到实际的调用位置，形成最终的可执行文件(Executable file)，即ELF的第二种格式文件。</p>
<p><img src="https://pic1.zhimg.com/80/v2-78827771a0af63369ebee996d6d094bc_720w.webp" alt="img"></p>
<p>对比ELF第一种格式可重定位文件，这里可执行文件略去了重定位表相关段落。此处将ELF文件分为了代码段、数据段和不加载到内存中的部分，并加上了段头表（Segment Header Table）用以记录管理，在代码中定义为struct elf32_phdr和 struct elf64_phdr，这里面除了有对于段的描述之外，最重要的是 p_vaddr，这个是这个段加载到内存的虚拟地址。这部分会在内存篇章详细介绍。</p>
<h4 id="2-2-2-动态链接"><a href="#2-2-2-动态链接" class="headerlink" title="2.2.2 动态链接"></a>2.2.2 动态链接</h4><p>动态链接库（Shared Libraries)的作用主要是为了解决静态链接大量使用会造成空间浪费的问题，因此这里设计成了可以被多个程序共享的形式，其执行命令如下</p>
<figure class="highlight text"><table><tr><td class="code"><pre><span class="line">gcc -shared -fPIC -o libXXX.so XXX.o</span><br></pre></td></tr></table></figure>

<p>当一个动态链接库被链接到一个程序文件中的时候，最后的程序文件并不包括动态链接库中的代码，而仅仅包括对动态链接库的引用，并且不保存动态链接库的全路径，仅仅保存动态链接库的名称。</p>
<figure class="highlight text"><table><tr><td class="code"><pre><span class="line">gcc -o XXX XXX.O -L. -lXXX</span><br></pre></td></tr></table></figure>

<p>当运行这个程序的时候，首先寻找动态链接库，然后加载它。默认情况下，系统在 &#x2F;lib 和&#x2F;usr&#x2F;lib 文件夹下寻找动态链接库。如果找不到就会报错，我们可以设定 LD_LIBRARY_PATH环境变量，程序运行时会在此环境变量指定的文件夹下寻找动态链接库。动态链接库，就是 ELF 的第三种类型，共享对象文件（Shared Object）。</p>
<p><strong>动态链接的ELF相对于静态链接主要多了以下部分：</strong></p>
<ul>
<li>.interp段，里面是ld-linux.so，负责运行时的链接动作</li>
<li>.plt（Procedure Linkage Table），过程链接表</li>
<li>.got.plt（Global Offset Table），全局偏移量表</li>
</ul>
<p>当程序编译时，会对每个函数在PLT中建立新的项，如PLT[n]，而动态库中则存有该函数的实际地址，记为GOT[m]。</p>
<p><strong>整体寻址过程如下所示：</strong></p>
<ul>
<li><p>PLT[n]向GOT[m]寻求地址</p>
</li>
<li><p>GOT[m]初始并无地址，需要采取以下方式获取地址</p>
</li>
<li><ul>
<li>回调PLT[0]</li>
<li>PLT[0]调用GOT[2]，即ld-linux.so</li>
<li>ld-linux.so查找所需函数实际地址并存放在GOT[m]中</li>
</ul>
</li>
</ul>
<p>由此，我们建立了PLT[n]到GOT[m]的对应关系，从而实现了动态链接。</p>
<h3 id="2-3-加载运行"><a href="#2-3-加载运行" class="headerlink" title="2.3 加载运行"></a>2.3 加载运行</h3><p>完成了上述的编译、汇编、链接，我们最终形成了可执行文件，并加载运行。在内核中，有这样一个数据结构，用来定义加载二进制文件的方法。</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">struct</span> <span class="title class_">linux_binfmt</span> &#123;</span><br><span class="line">    <span class="keyword">struct</span> <span class="title class_">list_head</span> lh;</span><br><span class="line">    <span class="keyword">struct</span> <span class="title class_">module</span> *<span class="keyword">module</span>;</span><br><span class="line">    <span class="built_in">int</span> (*load_binary)(<span class="keyword">struct</span> linux_binprm *);</span><br><span class="line">    <span class="built_in">int</span> (*load_shlib)(<span class="keyword">struct</span> file *);</span><br><span class="line">    <span class="built_in">int</span> (*core_dump)(<span class="keyword">struct</span> coredump_params *cprm);</span><br><span class="line">    <span class="type">unsigned</span> <span class="type">long</span> min_coredump;     <span class="comment">/* minimal dump size */</span></span><br><span class="line">&#125; __randomize_layout;</span><br></pre></td></tr></table></figure>

<p><strong>对于ELF文件格式，其对应实现为：</strong></p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="type">static</span> <span class="keyword">struct</span> <span class="title class_">linux_binfmt</span> elf_format = &#123;</span><br><span class="line">    .<span class="keyword">module</span>         = THIS_MODULE,</span><br><span class="line">    .load_binary    = load_elf_binary,</span><br><span class="line">    .load_shlib     = load_elf_library,</span><br><span class="line">    .core_dump      = elf_core_dump,</span><br><span class="line">    .min_coredump   = ELF_EXEC_PAGESIZE,</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>其中加载的函数指针指向的函数和内核镜像加载是同一份函数，实际上通过exec函数完成调用。exec 比较特殊，它是一组函数：</p>
<ul>
<li>包含 p 的函数（execvp, execlp）会在 PATH 路径下面寻找程序；不包含 p 的函数需要输入程序的全路径；</li>
<li>包含 v 的函数（execv, execvp, execve）以数组的形式接收参数；</li>
<li>包含 l 的函数（execl, execlp, execle）以列表的形式接收参数；</li>
<li>包含 e 的函数（execve, execle）以数组的形式接收环境变量。</li>
</ul>
<p>当我们通过shell运行可执行文件或者通过fork派生子类，均是通过该类函数实现加载。</p>
<h2 id="3、线程的创建之用户态"><a href="#3、线程的创建之用户态" class="headerlink" title="3、线程的创建之用户态"></a>3、线程的创建之用户态</h2><p>线程的创建对应的函数是pthread_create()，线程不是一个完全由内核实现的机制，它是由内核态和用户态合作完成的。pthread_create()不是一个系统调用，是 Glibc 库的一个函数，所以我们还要从 Glibc 说起。但是在开始之前，我们先要提一下，线程的创建到了内核态和进程的派生会使用同一个函数：__do_fork()，这也很容易理解，因为对内核态来说，线程和进程是同样的task_struct结构体。本节介绍线程在用户态的创建，而内核态的创建则会和进程的派生放在一起说明。</p>
<p>在Glibc的ntpl&#x2F;pthread_create.c中定义了__pthread_create_2_1()函数，该函数主要进行了以下操作</p>
<p>处理线程的属性参数。例如前面写程序的时候，我们设置的线程栈大小。如果没有传入线程属性，就取默认值。</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="type">const</span> <span class="keyword">struct</span> <span class="title class_">pthread_attr</span> *iattr = (<span class="keyword">struct</span> pthread_attr *) attr;</span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">pthread_attr</span> default_attr;</span><br><span class="line"><span class="comment">//c11 thrd_create</span></span><br><span class="line"><span class="type">bool</span> c11 = (attr == ATTR_C11_THREAD);</span><br><span class="line"><span class="keyword">if</span> (iattr == <span class="literal">NULL</span> || c11)</span><br><span class="line">&#123;</span><br><span class="line">  ......</span><br><span class="line">    iattr = &amp;default_attr;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>就像在内核里每一个进程或者线程都有一个 task_struct 结构，在用户态也有一个用于维护线程的结构，就是这个 pthread 结构。</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">struct</span> <span class="title class_">pthread</span> *pd = <span class="literal">NULL</span>;</span><br></pre></td></tr></table></figure>

<p>凡是涉及函数的调用，都要使用到栈。每个线程也有自己的栈，接下来就是创建线程栈了。</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="type">int</span> err = <span class="built_in">ALLOCATE_STACK</span> (iattr, &amp;pd);</span><br></pre></td></tr></table></figure>

<p><strong>ALLOCATE_STACK 是一个宏，对应的函数allocate_stack()主要做了以下这些事情：</strong></p>
<ul>
<li>如果在线程属性里面设置过栈的大小，则取出属性值；</li>
<li>为了防止栈的访问越界在栈的末尾添加一块空间 guardsize，一旦访问到这里就会报错；</li>
<li>线程栈是在进程的堆里面创建的。如果一个进程不断地创建和删除线程，我们不可能不断地去申请和清除线程栈使用的内存块，这样就需要有一个缓存。get_cached_stack 就是根据计算出来的 size 大小，看一看已经有的缓存中，有没有已经能够满足条件的。如果缓存里面没有，就需要调用__mmap创建一块新的缓存，系统调用那一节我们讲过，如果要在堆里面 malloc 一块内存，比较大的话，用__mmap；</li>
<li>线程栈也是自顶向下生长的，每个线程要有一个pthread 结构，这个结构也是放在栈的空间里面的。在栈底的位置，其实是地址最高位；</li>
<li>计算出guard内存的位置，调用 setup_stack_prot 设置这块内存的是受保护的；</li>
<li>填充pthread 这个结构里面的成员变量 stackblock、stackblock_size、guardsize、specific。这里的 specific 是用于存放Thread Specific Data 的，也即属于线程的全局变量；</li>
<li>将这个线程栈放到 stack_used 链表中，其实管理线程栈总共有两个链表，一个是 stack_used，也就是这个栈正被使用；另一个是stack_cache，就是上面说的，一旦线程结束，先缓存起来，不释放，等有其他的线程创建的时候，给其他的线程用。</li>
</ul>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta"># <span class="keyword">define</span> ALLOCATE_STACK(attr, pd) allocate_stack (attr, pd, &amp;stackaddr)</span></span><br><span class="line"><span class="function"><span class="type">static</span> <span class="type">int</span></span></span><br><span class="line"><span class="function"><span class="title">allocate_stack</span> <span class="params">(<span class="type">const</span> <span class="keyword">struct</span> pthread_attr *attr, <span class="keyword">struct</span> pthread **pdp,</span></span></span><br><span class="line"><span class="params"><span class="function">                ALLOCATE_STACK_PARMS)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">struct</span> <span class="title class_">pthread</span> *pd;</span><br><span class="line">    <span class="type">size_t</span> size;</span><br><span class="line">    <span class="type">size_t</span> pagesize_m1 = __getpagesize () - <span class="number">1</span>;</span><br><span class="line">......</span><br><span class="line">    <span class="comment">/* Get the stack size from the attribute if it is set.  Otherwise we</span></span><br><span class="line"><span class="comment">       use the default we determined at start time.  */</span></span><br><span class="line">    <span class="keyword">if</span> (attr-&gt;stacksize != <span class="number">0</span>)</span><br><span class="line">        size = attr-&gt;stacksize;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">lll_lock</span> (__default_pthread_attr_lock, LLL_PRIVATE);</span><br><span class="line">        size = __default_pthread_attr.stacksize;</span><br><span class="line">        <span class="built_in">lll_unlock</span> (__default_pthread_attr_lock, LLL_PRIVATE);</span><br><span class="line">    &#125;</span><br><span class="line">......</span><br><span class="line">    <span class="comment">/* Allocate some anonymous memory.  If possible use the cache.  */</span></span><br><span class="line">    <span class="type">size_t</span> guardsize;</span><br><span class="line">    <span class="type">void</span> *mem;</span><br><span class="line">    <span class="type">const</span> <span class="type">int</span> prot = (PROT_READ | PROT_WRITE</span><br><span class="line">                   | ((<span class="built_in">GL</span>(dl_stack_flags) &amp; PF_X) ? PROT_EXEC : <span class="number">0</span>));</span><br><span class="line">    <span class="comment">/* Adjust the stack size for alignment.  */</span></span><br><span class="line">    size &amp;= ~__static_tls_align_m1;</span><br><span class="line">    <span class="comment">/* Make sure the size of the stack is enough for the guard and</span></span><br><span class="line"><span class="comment">       eventually the thread descriptor.  */</span></span><br><span class="line">    guardsize = (attr-&gt;guardsize + pagesize_m1) &amp; ~pagesize_m1;</span><br><span class="line">    size += guardsize;</span><br><span class="line">......    </span><br><span class="line">    <span class="comment">/* Try to get a stack from the cache.  */</span>  </span><br><span class="line">    pd = <span class="built_in">get_cached_stack</span> (&amp;size, &amp;mem);</span><br><span class="line">    <span class="keyword">if</span> (pd == <span class="literal">NULL</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">/* If a guard page is required, avoid committing memory by first</span></span><br><span class="line"><span class="comment">           allocate with PROT_NONE and then reserve with required permission</span></span><br><span class="line"><span class="comment">           excluding the guard page.  */</span></span><br><span class="line">        mem = __mmap (<span class="literal">NULL</span>, size, (guardsize == <span class="number">0</span>) ? prot : PROT_NONE,</span><br><span class="line">        MAP_PRIVATE | MAP_ANONYMOUS | MAP_STACK, <span class="number">-1</span>, <span class="number">0</span>);</span><br><span class="line">        <span class="comment">/* Place the thread descriptor at the end of the stack.  */</span></span><br><span class="line"><span class="meta">#<span class="keyword">if</span> TLS_TCB_AT_TP</span></span><br><span class="line">        pd = (<span class="keyword">struct</span> pthread *) ((<span class="type">char</span> *) mem + size) - <span class="number">1</span>;</span><br><span class="line"><span class="meta">#<span class="keyword">elif</span> TLS_DTV_AT_TP</span></span><br><span class="line">        pd = (<span class="keyword">struct</span> pthread *) ((((<span class="type">uintptr_t</span>) mem + size - __static_tls_size) &amp; ~__static_tls_align_m1) - TLS_PRE_TCB_SIZE);</span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line">        <span class="comment">/* Now mprotect the required region excluding the guard area. */</span></span><br><span class="line">        <span class="type">char</span> *guard = <span class="built_in">guard_position</span> (mem, size, guardsize, pd, pagesize_m1);</span><br><span class="line">        <span class="built_in">setup_stack_prot</span> (mem, size, guard, guardsize, prot);</span><br><span class="line">        pd-&gt;stackblock = mem;</span><br><span class="line">        pd-&gt;stackblock_size = size;</span><br><span class="line">        pd-&gt;guardsize = guardsize;</span><br><span class="line">        pd-&gt;specific[<span class="number">0</span>] = pd-&gt;specific_1stblock;</span><br><span class="line">        <span class="comment">/* And add to the list of stacks in use.  */</span></span><br><span class="line">        <span class="built_in">stack_list_add</span> (&amp;pd-&gt;list, &amp;stack_used);</span><br><span class="line">    &#125;</span><br><span class="line">  </span><br><span class="line">    *pdp = pd;</span><br><span class="line">    <span class="type">void</span> *stacktop;</span><br><span class="line"><span class="meta"># <span class="keyword">if</span> TLS_TCB_AT_TP</span></span><br><span class="line">    <span class="comment">/* The stack begins before the TCB and the static TLS block.  */</span></span><br><span class="line">    stacktop = ((<span class="type">char</span> *) (pd + <span class="number">1</span>) - __static_tls_size);</span><br><span class="line"><span class="meta"># <span class="keyword">elif</span> TLS_DTV_AT_TP</span></span><br><span class="line">    stacktop = (<span class="type">char</span> *) (pd - <span class="number">1</span>);</span><br><span class="line"><span class="meta"># <span class="keyword">endif</span></span></span><br><span class="line">    *stack = stacktop;</span><br><span class="line">...... </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="4、线程的内核态创建及进程的派生"><a href="#4、线程的内核态创建及进程的派生" class="headerlink" title="4、线程的内核态创建及进程的派生"></a>4、线程的内核态创建及进程的派生</h2><p>多进程是一种常见的程序实现方式，采用的系统调用为fork()函数。前文中已经详细叙述了系统调用的整个过程，对于fork()来说，最终会在系统调用表中查找到对应的系统调用sys_fork完成子进程的生成，而sys_fork 会调用 _do_fork()。</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="built_in">SYSCALL_DEFINE0</span>(fork)</span><br><span class="line">&#123;</span><br><span class="line">......</span><br><span class="line">    <span class="keyword">return</span> _do_fork(SIGCHLD, <span class="number">0</span>, <span class="number">0</span>, <span class="literal">NULL</span>, <span class="literal">NULL</span>, <span class="number">0</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>关于__do_fork()先按下不表，再接着看看线程。我们接着pthread_create ()看。其实有了用户态的栈，接着需要解决的就是用户态的程序从哪里开始运行的问题。start_routine() 就是给线程的函数，start_routine()， 参数 arg，以及调度策略都要赋值给 pthread。接下来 __nptl_nthreads 加一，说明又多了一个线程。</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">pd-&gt;start_routine = start_routine;</span><br><span class="line">pd-&gt;arg = arg;</span><br><span class="line">pd-&gt;schedpolicy = self-&gt;schedpolicy;</span><br><span class="line">pd-&gt;schedparam = self-&gt;schedparam;</span><br><span class="line"><span class="comment">/* Pass the descriptor to the caller.  */</span></span><br><span class="line">*newthread = (<span class="type">pthread_t</span>) pd;</span><br><span class="line"><span class="built_in">atomic_increment</span> (&amp;__nptl_nthreads);</span><br><span class="line">retval = <span class="built_in">create_thread</span> (pd, iattr, &amp;stopped_start, STACK_VARIABLES_ARGS, &amp;thread_ran);</span><br></pre></td></tr></table></figure>

<p>真正创建线程的是调用 create_thread() 函数，这个函数定义如下。同时，这里还规定了当完成了内核态线程创建后回调的位置：start_thread()。</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">static</span> <span class="type">int</span></span></span><br><span class="line"><span class="function"><span class="title">create_thread</span> <span class="params">(<span class="keyword">struct</span> pthread *pd, <span class="type">const</span> <span class="keyword">struct</span> pthread_attr *attr,</span></span></span><br><span class="line"><span class="params"><span class="function"><span class="type">bool</span> *stopped_start, STACK_VARIABLES_PARMS, <span class="type">bool</span> *thread_ran)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">const</span> <span class="type">int</span> clone_flags = (CLONE_VM | CLONE_FS | CLONE_FILES | CLONE_SYSVSEM | CLONE_SIGHAND | CLONE_THREAD | CLONE_SETTLS | CLONE_PARENT_SETTID | CLONE_CHILD_CLEARTID | <span class="number">0</span>);</span><br><span class="line">    <span class="built_in">ARCH_CLONE</span> (&amp;start_thread, STACK_VARIABLES_ARGS, clone_flags, pd, &amp;pd-&gt;tid, tp, &amp;pd-&gt;tid)；</span><br><span class="line">    <span class="comment">/* It&#x27;s started now, so if we fail below, we&#x27;ll have to cancel it</span></span><br><span class="line"><span class="comment">       and let it clean itself up.  */</span></span><br><span class="line">    *thread_ran = <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>在 start_thread() 入口函数中，才真正的调用用户提供的函数，在用户的函数执行完毕之后，会释放这个线程相关的数据。例如，线程本地数据 thread_local variables，线程数目也减一。如果这是最后一个线程了，就直接退出进程，另外 __free_tcb() 用于释放 pthread。</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">define</span> START_THREAD_DEFN \</span></span><br><span class="line"><span class="meta">  static int __attribute__ ((noreturn)) start_thread (void *arg)</span></span><br><span class="line"></span><br><span class="line">START_THREAD_DEFN</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">struct</span> <span class="title class_">pthread</span> *pd = START_THREAD_SELF;</span><br><span class="line">    <span class="comment">/* Run the code the user provided.  */</span></span><br><span class="line">    <span class="built_in">THREAD_SETMEM</span> (pd, result, pd-&gt;<span class="built_in">start_routine</span> (pd-&gt;arg));</span><br><span class="line">    <span class="comment">/* Call destructors for the thread_local TLS variables.  */</span></span><br><span class="line">    <span class="comment">/* Run the destructor for the thread-local data.  */</span></span><br><span class="line">    __nptl_deallocate_tsd ();</span><br><span class="line">    <span class="keyword">if</span> (__glibc_unlikely (<span class="built_in">atomic_decrement_and_test</span> (&amp;__nptl_nthreads)))</span><br><span class="line">        <span class="comment">/* This was the last thread.  */</span></span><br><span class="line">        <span class="built_in">exit</span> (<span class="number">0</span>);</span><br><span class="line">    __free_tcb (pd);</span><br><span class="line">    __exit_thread ();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>__free_tcb ()会调用 __deallocate_stack()来释放整个线程栈，这个线程栈要从当前使用线程栈的列表 stack_used 中拿下来，放到缓存的线程栈列表 stack_cache中，从而结束了线程的生命周期。</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="type">void</span></span><br><span class="line">internal_function</span><br><span class="line">__free_tcb (<span class="keyword">struct</span> pthread *pd)</span><br><span class="line">&#123;</span><br><span class="line">    ......</span><br><span class="line">    __deallocate_stack (pd);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span></span><br><span class="line">internal_function</span><br><span class="line">__deallocate_stack (<span class="keyword">struct</span> pthread *pd)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">/* Remove the thread from the list of threads with user defined</span></span><br><span class="line"><span class="comment">       stacks.  */</span></span><br><span class="line">    <span class="built_in">stack_list_del</span> (&amp;pd-&gt;list);</span><br><span class="line">    <span class="comment">/* Not much to do.  Just free the mmap()ed memory.  Note that we do</span></span><br><span class="line"><span class="comment">       not reset the &#x27;used&#x27; flag in the &#x27;tid&#x27; field.  This is done by</span></span><br><span class="line"><span class="comment">       the kernel.  If no thread has been created yet this field is</span></span><br><span class="line"><span class="comment">       still zero.  */</span></span><br><span class="line">    <span class="keyword">if</span> (__glibc_likely (! pd-&gt;user_stack))</span><br><span class="line">        (<span class="type">void</span>) <span class="built_in">queue_stack</span> (pd);</span><br><span class="line">&#125;</span><br><span class="line">  ARCH_CLONE其实调用的是 __clone()。</span><br><span class="line"></span><br><span class="line"><span class="meta"># <span class="keyword">define</span> ARCH_CLONE __clone</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/* The userland implementation is:</span></span><br><span class="line"><span class="comment">   int clone (int (*fn)(void *arg), void *child_stack, int flags, void *arg),</span></span><br><span class="line"><span class="comment">   the kernel entry is:</span></span><br><span class="line"><span class="comment">   int clone (long flags, void *child_stack).</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">   The parameters are passed in register and on the stack from userland:</span></span><br><span class="line"><span class="comment">   rdi: fn</span></span><br><span class="line"><span class="comment">   rsi: child_stack</span></span><br><span class="line"><span class="comment">   rdx: flags</span></span><br><span class="line"><span class="comment">   rcx: arg</span></span><br><span class="line"><span class="comment">   r8d: TID field in parent</span></span><br><span class="line"><span class="comment">   r9d: thread pointer</span></span><br><span class="line"><span class="comment">%esp+8: TID field in child</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">   The kernel expects:</span></span><br><span class="line"><span class="comment">   rax: system call number</span></span><br><span class="line"><span class="comment">   rdi: flags</span></span><br><span class="line"><span class="comment">   rsi: child_stack</span></span><br><span class="line"><span class="comment">   rdx: TID field in parent</span></span><br><span class="line"><span class="comment">   r10: TID field in child</span></span><br><span class="line"><span class="comment">   r8:  thread pointer  */</span></span><br><span class="line">    .<span class="function">text</span></span><br><span class="line"><span class="function"><span class="title">ENTRY</span> <span class="params">(__clone)</span></span></span><br><span class="line"><span class="function">    movq    $-EINVAL,%rax</span></span><br><span class="line"><span class="function">......</span></span><br><span class="line"><span class="function">    <span class="comment">/* Insert the argument onto the new stack.  */</span></span></span><br><span class="line"><span class="function">    subq    $16,%rsi</span></span><br><span class="line"><span class="function">    movq    %rcx,8<span class="params">(%rsi)</span></span></span><br><span class="line"><span class="function"></span></span><br><span class="line"><span class="function">    <span class="comment">/* Save the function pointer.  It will be popped off in the</span></span></span><br><span class="line"><span class="comment"><span class="function">       child in the ebx frobbing below.  */</span></span></span><br><span class="line"><span class="function">    movq    %rdi,0<span class="params">(%rsi)</span></span></span><br><span class="line"><span class="function"></span></span><br><span class="line"><span class="function">    <span class="comment">/* Do the system call.  */</span></span></span><br><span class="line"><span class="function">    movq    %rdx, %rdi</span></span><br><span class="line"><span class="function">    movq    %r8, %rdx</span></span><br><span class="line"><span class="function">    movq    %r9, %r8</span></span><br><span class="line"><span class="function">    mov     8<span class="params">(%rsp)</span>, %R10_LP</span></span><br><span class="line"><span class="function">    movl    $<span class="title">SYS_ify</span><span class="params">(clone)</span>,%eax</span></span><br><span class="line"><span class="function">......</span></span><br><span class="line"><span class="function">    syscall</span></span><br><span class="line"><span class="function">......</span></span><br><span class="line"><span class="function"><span class="title">PSEUDO_END</span> <span class="params">(__clone)</span></span></span><br></pre></td></tr></table></figure>

<p>内核中的clone()定义如下。如果在进程的主线程里面调用其他系统调用，当前用户态的栈是指向整个进程的栈，栈顶指针也是指向进程的栈，指令指针也是指向进程的主线程的代码。此时此刻执行到这里，调用 clone的时候，用户态的栈、栈顶指针、指令指针和其他系统调用一样，都是指向主线程的。但是对于线程来说，这些都要变。因为我们希望当 clone 这个系统调用成功的时候，除了内核里面有这个线程对应的 task_struct，当系统调用返回到用户态的时候，用户态的栈应该是线程的栈，栈顶指针应该指向线程的栈，指令指针应该指向线程将要执行的那个函数。所以这些都需要我们自己做，将线程要执行的函数的参数和指令的位置都压到栈里面，当从内核返回，从栈里弹出来的时候，就从这个函数开始，带着这些参数执行下去。</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="built_in">SYSCALL_DEFINE5</span>(clone, <span class="type">unsigned</span> <span class="type">long</span>, clone_flags, <span class="type">unsigned</span> <span class="type">long</span>, newsp,</span><br><span class="line">     <span class="type">int</span> __user *, parent_tidptr,</span><br><span class="line">     <span class="type">int</span> __user *, child_tidptr,</span><br><span class="line">     <span class="type">unsigned</span> <span class="type">long</span>, tls)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">return</span> _do_fork(clone_flags, newsp, <span class="number">0</span>, parent_tidptr, child_tidptr, tls);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>线程和进程到了这里殊途同归，进入了同一个函数__do_fork()工作。其源码如下所示，主要工作包括复制结构copy_process()和唤醒新进程wak_up_new()两部分。其中线程会根据create_thread()函数中的clone_flags完成上文所述的栈顶指针和指令指针的切换，以及一些线程和进程的微妙区别。</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="type">long</span> _do_fork(<span class="type">unsigned</span> <span class="type">long</span> clone_flags,</span><br><span class="line">        <span class="type">unsigned</span> <span class="type">long</span> stack_start,</span><br><span class="line">        <span class="type">unsigned</span> <span class="type">long</span> stack_size,</span><br><span class="line">        <span class="type">int</span> __user *parent_tidptr,</span><br><span class="line">        <span class="type">int</span> __user *child_tidptr,</span><br><span class="line">        <span class="type">unsigned</span> <span class="type">long</span> tls)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">struct</span> <span class="title class_">task_struct</span> *p;</span><br><span class="line">    <span class="type">int</span> trace = <span class="number">0</span>;</span><br><span class="line">    <span class="type">long</span> nr;</span><br><span class="line"></span><br><span class="line">......</span><br><span class="line">    p = <span class="built_in">copy_process</span>(clone_flags, stack_start, stack_size,</span><br><span class="line">       child_tidptr, <span class="literal">NULL</span>, trace, tls, NUMA_NO_NODE);</span><br><span class="line">......</span><br><span class="line">    <span class="keyword">if</span> (<span class="built_in">IS_ERR</span>(p))</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">PTR_ERR</span>(p);</span><br><span class="line">    <span class="keyword">struct</span> <span class="title class_">pid</span> *pid;</span><br><span class="line">    pid = <span class="built_in">get_task_pid</span>(p, PIDTYPE_PID);</span><br><span class="line">    nr = <span class="built_in">pid_vnr</span>(pid);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (clone_flags &amp; CLONE_PARENT_SETTID)</span><br><span class="line">        <span class="built_in">put_user</span>(nr, parent_tidptr);</span><br><span class="line">    <span class="keyword">if</span> (clone_flags &amp; CLONE_VFORK) &#123;</span><br><span class="line">        p-&gt;vfork_done = &amp;vfork;</span><br><span class="line">        <span class="built_in">init_completion</span>(&amp;vfork);</span><br><span class="line">        <span class="built_in">get_task_struct</span>(p);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">wake_up_new_task</span>(p);</span><br><span class="line">......</span><br><span class="line">    <span class="built_in">put_pid</span>(pid);</span><br><span class="line">    <span class="keyword">return</span> nr;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h3 id="4-1-任务结构体复制"><a href="#4-1-任务结构体复制" class="headerlink" title="4.1 任务结构体复制"></a>4.1 任务结构体复制</h3><p>如下所示为copy_process()函数源码精简版，task_struct结构复杂也注定了复制过程的复杂性，因此此处省略了很多，仅保留了各个部分的主要调用函数</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="type">static</span> __latent_entropy <span class="keyword">struct</span> <span class="title class_">task_struct</span> *<span class="built_in">copy_process</span>(</span><br><span class="line">          <span class="type">unsigned</span> <span class="type">long</span> clone_flags,</span><br><span class="line">          <span class="type">unsigned</span> <span class="type">long</span> stack_start,</span><br><span class="line">          <span class="type">unsigned</span> <span class="type">long</span> stack_size,</span><br><span class="line">          <span class="type">int</span> __user *child_tidptr,</span><br><span class="line">          <span class="keyword">struct</span> pid *pid,</span><br><span class="line">          <span class="type">int</span> trace,</span><br><span class="line">          <span class="type">unsigned</span> <span class="type">long</span> tls,</span><br><span class="line">          <span class="type">int</span> node)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">int</span> retval;</span><br><span class="line">    <span class="keyword">struct</span> <span class="title class_">task_struct</span> *p;</span><br><span class="line">......</span><br><span class="line">    <span class="comment">//分配task_struct结构</span></span><br><span class="line">    p = <span class="built_in">dup_task_struct</span>(current, node);  </span><br><span class="line">......</span><br><span class="line">    <span class="comment">//权限处理</span></span><br><span class="line">    retval = <span class="built_in">copy_creds</span>(p, clone_flags);</span><br><span class="line">......</span><br><span class="line">    <span class="comment">//设置调度相关变量</span></span><br><span class="line">    retval = <span class="built_in">sched_fork</span>(clone_flags, p);    </span><br><span class="line">......</span><br><span class="line">    <span class="comment">//初始化文件和文件系统相关变量</span></span><br><span class="line">    retval = <span class="built_in">copy_files</span>(clone_flags, p);</span><br><span class="line">    retval = <span class="built_in">copy_fs</span>(clone_flags, p);  </span><br><span class="line">......</span><br><span class="line">    <span class="comment">//初始化信号相关变量</span></span><br><span class="line">    <span class="built_in">init_sigpending</span>(&amp;p-&gt;pending);</span><br><span class="line">    retval = <span class="built_in">copy_sighand</span>(clone_flags, p);</span><br><span class="line">    retval = <span class="built_in">copy_signal</span>(clone_flags, p);  </span><br><span class="line">......</span><br><span class="line">    <span class="comment">//拷贝进程内存空间</span></span><br><span class="line">    retval = <span class="built_in">copy_mm</span>(clone_flags, p);</span><br><span class="line">...... </span><br><span class="line">    <span class="comment">//初始化亲缘关系变量</span></span><br><span class="line">    <span class="built_in">INIT_LIST_HEAD</span>(&amp;p-&gt;children);</span><br><span class="line">    <span class="built_in">INIT_LIST_HEAD</span>(&amp;p-&gt;sibling);</span><br><span class="line">......</span><br><span class="line">    <span class="comment">//建立亲缘关系</span></span><br><span class="line">    <span class="comment">//源码放在后面说明  </span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>1、copy_process()首先调用了dup_task_struct()分配task_struct结构，dup_task_struct() 主要做了下面几件事情：</p>
<ul>
<li>调用 alloc_task_struct_node 分配一个 task_struct结构；</li>
<li>调用 alloc_thread_stack_node 来创建内核栈，这里面调用 __vmalloc_node_range 分配一个连续的 THREAD_SIZE 的内存空间，赋值给 task_struct 的 void *stack成员变量；</li>
<li>调用 arch_dup_task_struct(struct task_struct *dst, struct task_struct *src)，将 task_struct 进行复制，其实就是调用 memcpy；</li>
<li>调用setup_thread_stack设置 thread_info。</li>
</ul>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="type">static</span> <span class="keyword">struct</span> <span class="title class_">task_struct</span> *<span class="built_in">dup_task_struct</span>(<span class="keyword">struct</span> task_struct *orig, <span class="type">int</span> node)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">struct</span> <span class="title class_">task_struct</span> *tsk;</span><br><span class="line">    <span class="type">unsigned</span> <span class="type">long</span> *stack;</span><br><span class="line">......</span><br><span class="line">    tsk = <span class="built_in">alloc_task_struct_node</span>(node);</span><br><span class="line">    <span class="keyword">if</span> (!tsk)</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line"></span><br><span class="line">    stack = <span class="built_in">alloc_thread_stack_node</span>(tsk, node);</span><br><span class="line">    <span class="keyword">if</span> (!stack)</span><br><span class="line">        <span class="keyword">goto</span> free_tsk; </span><br><span class="line">    <span class="keyword">if</span> (<span class="built_in">memcg_charge_kernel_stack</span>(tsk))</span><br><span class="line">        <span class="keyword">goto</span> free_stack;</span><br><span class="line"></span><br><span class="line">    stack_vm_area = <span class="built_in">task_stack_vm_area</span>(tsk);</span><br><span class="line"></span><br><span class="line">    err = <span class="built_in">arch_dup_task_struct</span>(tsk, orig);</span><br><span class="line">......    </span><br><span class="line">    <span class="built_in">setup_thread_stack</span>(tsk, orig);</span><br><span class="line">......    </span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>2、接着，调用copy_creds处理权限相关内容</p>
<ul>
<li>调用prepare_creds，准备一个新的 struct cred *new。如何准备呢？其实还是从内存中分配一个新的 struct cred结构，然后调用 memcpy 复制一份父进程的 cred；</li>
<li>接着 p-&gt;cred &#x3D; p-&gt;real_cred &#x3D; get_cred(new)，将新进程的“我能操作谁”和“谁能操作我”两个权限都指向新的 cred。</li>
</ul>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * Copy credentials for the new process created by fork()</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * We share if we can, but under some circumstances we have to generate a new</span></span><br><span class="line"><span class="comment"> * set.</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * The new process gets the current process&#x27;s subjective credentials as its</span></span><br><span class="line"><span class="comment"> * objective and subjective credentials</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">copy_creds</span><span class="params">(<span class="keyword">struct</span> task_struct *p, <span class="type">unsigned</span> <span class="type">long</span> clone_flags)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">struct</span> <span class="title class_">cred</span> *<span class="keyword">new</span>;</span><br><span class="line">    <span class="type">int</span> ret;</span><br><span class="line">......</span><br><span class="line">    <span class="keyword">new</span> = <span class="built_in">prepare_creds</span>();</span><br><span class="line">    <span class="keyword">if</span> (!<span class="keyword">new</span>)</span><br><span class="line">        <span class="keyword">return</span> -ENOMEM;</span><br><span class="line">......</span><br><span class="line">    <span class="built_in">atomic_inc</span>(&amp;<span class="keyword">new</span>-&gt;user-&gt;processes);</span><br><span class="line">    p-&gt;cred = p-&gt;real_cred = <span class="built_in">get_cred</span>(<span class="keyword">new</span>);</span><br><span class="line">    <span class="built_in">alter_cred_subscribers</span>(<span class="keyword">new</span>, <span class="number">2</span>);</span><br><span class="line">    <span class="built_in">validate_creds</span>(<span class="keyword">new</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>3、设置调度相关的变量。该部分源码先不展示，会在进程调度中详细介绍。sched_fork主要做了下面几件事情：</p>
<ul>
<li>调用__sched_fork，在这里面将on_rq设为 0，初始化sched_entity，将里面的 exec_start、sum_exec_runtime、prev_sum_exec_runtime、vruntime 都设为 0。这几个变量涉及进程的实际运行时间和虚拟运行时间。是否到时间应该被调度了，就靠它们几个；</li>
<li>设置进程的状态 p-&gt;state &#x3D; TASK_NEW；</li>
<li>初始化优先级 prio、normal_prio、static_prio；</li>
<li>设置调度类，如果是普通进程，就设置为 p-&gt;sched_class &#x3D; &amp;fair_sched_class；</li>
<li>调用调度类的 task_fork 函数，对于 CFS 来讲，就是调用 task_fork_fair。在这个函数里，先调用 update_curr，对于当前的进程进行统计量更新，然后把子进程和父进程的 vruntime 设成一样，最后调用 place_entity，初始化 sched_entity。这里有一个变量 sysctl_sched_child_runs_first，可以设置父进程和子进程谁先运行。如果设置了子进程先运行，即便两个进程的 vruntime 一样，也要把子进程的 sched_entity 放在前面，然后调用 resched_curr，标记当前运行的进程 TIF_NEED_RESCHED，也就是说，把父进程设置为应该被调度，这样下次调度的时候，父进程会被子进程抢占。</li>
</ul>
<p>4、初始化文件和文件系统相关变量</p>
<ul>
<li><p>copy_files 主要用于复制一个任务打开的文件信息。</p>
</li>
<li><ul>
<li>对于进程来说，这些信息用一个结构 files_struct 来维护，每个打开的文件都有一个文件描述符。在 copy_files 函数里面调用 dup_fd，在这里面会创建一个新的 files_struct，然后将所有的文件描述符数组 fdtable 拷贝一份。</li>
<li>对于线程来说，由于设置了CLONE_FILES 标识位变成将原来的files_struct 引用计数加一，并不会拷贝文件。</li>
</ul>
</li>
</ul>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">static</span> <span class="type">int</span> <span class="title">copy_files</span><span class="params">(<span class="type">unsigned</span> <span class="type">long</span> clone_flags, <span class="keyword">struct</span> task_struct *tsk)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">struct</span> <span class="title class_">files_struct</span> *oldf, *newf;</span><br><span class="line">    <span class="type">int</span> error = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">    * A background process may not have any files ...</span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line">    oldf = current-&gt;files;</span><br><span class="line">    <span class="keyword">if</span> (!oldf)</span><br><span class="line">        <span class="keyword">goto</span> out;</span><br><span class="line">    <span class="keyword">if</span> (clone_flags &amp; CLONE_FILES) &#123;</span><br><span class="line">        <span class="built_in">atomic_inc</span>(&amp;oldf-&gt;count);</span><br><span class="line">        <span class="keyword">goto</span> out;</span><br><span class="line">    &#125;</span><br><span class="line">    newf = <span class="built_in">dup_fd</span>(oldf, &amp;error);</span><br><span class="line">    <span class="keyword">if</span> (!newf)</span><br><span class="line">        <span class="keyword">goto</span> out;</span><br><span class="line"></span><br><span class="line">    tsk-&gt;files = newf;</span><br><span class="line">    error = <span class="number">0</span>;</span><br><span class="line">out:</span><br><span class="line">    <span class="keyword">return</span> error;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li><p>copy_fs 主要用于复制一个任务的目录信息。</p>
</li>
<li><ul>
<li>对于进程来说，这些信息用一个结构 fs_struct 来维护。一个进程有自己的根目录和根文件系统 root，也有当前目录 pwd 和当前目录的文件系统，都在 fs_struct 里面维护。copy_fs 函数里面调用 copy_fs_struct，创建一个新的 fs_struct，并复制原来进程的 fs_struct。</li>
<li>对于线程来说，由于设置了CLONE_FS 标识位变成将原来的fs_struct 的用户数加一，并不会拷贝文件系统结构。</li>
</ul>
</li>
</ul>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">static</span> <span class="type">int</span> <span class="title">copy_fs</span><span class="params">(<span class="type">unsigned</span> <span class="type">long</span> clone_flags, <span class="keyword">struct</span> task_struct *tsk)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">struct</span> <span class="title class_">fs_struct</span> *fs = current-&gt;fs;</span><br><span class="line">    <span class="keyword">if</span> (clone_flags &amp; CLONE_FS) &#123;</span><br><span class="line">        <span class="comment">/* tsk-&gt;fs is already what we want */</span></span><br><span class="line">        <span class="built_in">spin_lock</span>(&amp;fs-&gt;lock);</span><br><span class="line">        <span class="keyword">if</span> (fs-&gt;in_exec) &#123;</span><br><span class="line">            <span class="built_in">spin_unlock</span>(&amp;fs-&gt;lock);</span><br><span class="line">            <span class="keyword">return</span> -EAGAIN;</span><br><span class="line">        &#125;</span><br><span class="line">        fs-&gt;users++;</span><br><span class="line">        <span class="built_in">spin_unlock</span>(&amp;fs-&gt;lock);</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    tsk-&gt;fs = <span class="built_in">copy_fs_struct</span>(fs);</span><br><span class="line">    <span class="keyword">if</span> (!tsk-&gt;fs)</span><br><span class="line">        <span class="keyword">return</span> -ENOMEM;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>5、初始化信号相关变量</p>
<ul>
<li><p>整个进程里的所有线程共享一个shared_pending，这也是一个信号列表，是发给整个进程的，哪个线程处理都一样。由此我们可以做到发给进程的信号虽然可以被一个线程处理，但是影响范围应该是整个进程的。例如，kill 一个进程，则所有线程都要被干掉。如果一个信号是发给一个线程的 pthread_kill，则应该只有线程能够收到。</p>
</li>
<li><p>copy_sighand</p>
</li>
<li><ul>
<li>对于进程来说，会分配一个新的 sighand_struct。这里最主要的是维护信号处理函数，在 copy_sighand 里面会调用 memcpy，将信号处理函数 sighand-&gt;action 从父进程复制到子进程。</li>
<li>对于线程来说，由于设计了CLONE_SIGHAND标记位，会对引用计数加一并退出，没有分配新的信号变量。</li>
</ul>
</li>
</ul>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">static</span> <span class="type">int</span> <span class="title">copy_sighand</span><span class="params">(<span class="type">unsigned</span> <span class="type">long</span> clone_flags, <span class="keyword">struct</span> task_struct *tsk)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">struct</span> <span class="title class_">sighand_struct</span> *sig;</span><br><span class="line">    <span class="keyword">if</span> (clone_flags &amp; CLONE_SIGHAND) &#123;</span><br><span class="line">        <span class="built_in">refcount_inc</span>(&amp;current-&gt;sighand-&gt;count);</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    sig = <span class="built_in">kmem_cache_alloc</span>(sighand_cachep, GFP_KERNEL);</span><br><span class="line">    <span class="built_in">rcu_assign_pointer</span>(tsk-&gt;sighand, sig);</span><br><span class="line">    <span class="keyword">if</span> (!sig)</span><br><span class="line">        <span class="keyword">return</span> -ENOMEM;</span><br><span class="line">    <span class="built_in">refcount_set</span>(&amp;sig-&gt;count, <span class="number">1</span>);</span><br><span class="line">    <span class="built_in">spin_lock_irq</span>(&amp;current-&gt;sighand-&gt;siglock);</span><br><span class="line">    <span class="built_in">memcpy</span>(sig-&gt;action, current-&gt;sighand-&gt;action, <span class="built_in">sizeof</span>(sig-&gt;action));</span><br><span class="line">    <span class="built_in">spin_unlock_irq</span>(&amp;current-&gt;sighand-&gt;siglock);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>init_sigpending 和 copy_signal 用于初始化信号结构体，并且复制用于维护发给这个进程的信号的数据结构。copy_signal 函数会分配一个新的 signal_struct，并进行初始化。对于线程来说也是直接退出并未复制。</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">static</span> <span class="type">int</span> <span class="title">copy_signal</span><span class="params">(<span class="type">unsigned</span> <span class="type">long</span> clone_flags, <span class="keyword">struct</span> task_struct *tsk)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">struct</span> <span class="title class_">signal_struct</span> *sig;</span><br><span class="line">    <span class="keyword">if</span> (clone_flags &amp; CLONE_THREAD)</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    sig = <span class="built_in">kmem_cache_zalloc</span>(signal_cachep, GFP_KERNEL);</span><br><span class="line">......</span><br><span class="line">    <span class="comment">/* list_add(thread_node, thread_head) without INIT_LIST_HEAD() */</span></span><br><span class="line">    sig-&gt;thread_head = (<span class="keyword">struct</span> list_head)<span class="built_in">LIST_HEAD_INIT</span>(tsk-&gt;thread_node);</span><br><span class="line">    tsk-&gt;thread_node = (<span class="keyword">struct</span> list_head)<span class="built_in">LIST_HEAD_INIT</span>(sig-&gt;thread_head);</span><br><span class="line">    <span class="built_in">init_waitqueue_head</span>(&amp;sig-&gt;wait_chldexit);</span><br><span class="line">    sig-&gt;curr_target = tsk;</span><br><span class="line">    <span class="built_in">init_sigpending</span>(&amp;sig-&gt;shared_pending);</span><br><span class="line">    <span class="built_in">INIT_HLIST_HEAD</span>(&amp;sig-&gt;multiprocess);</span><br><span class="line">    <span class="built_in">seqlock_init</span>(&amp;sig-&gt;stats_lock);</span><br><span class="line">    <span class="built_in">prev_cputime_init</span>(&amp;sig-&gt;prev_cputime);</span><br><span class="line">......</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>6、复制进程内存空间</p>
<ul>
<li>进程都有自己的内存空间，用 mm_struct 结构来表示。copy_mm() 函数中调用 dup_mm()，分配一个新的 mm_struct 结构，调用 memcpy 复制这个结构。dup_mmap() 用于复制内存空间中内存映射的部分。前面讲系统调用的时候，我们说过，mmap 可以分配大块的内存，其实 mmap 也可以将一个文件映射到内存中，方便可以像读写内存一样读写文件，这个在内存管理那节我们讲。</li>
<li>线程不会复制内存空间，因此因为CLONE_VM标识位而直接指向了原来的mm_struct。</li>
</ul>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">static</span> <span class="type">int</span> <span class="title">copy_mm</span><span class="params">(<span class="type">unsigned</span> <span class="type">long</span> clone_flags, <span class="keyword">struct</span> task_struct *tsk)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">struct</span> <span class="title class_">mm_struct</span> *mm, *oldmm;</span><br><span class="line">    <span class="type">int</span> retval;</span><br><span class="line">......</span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">    * Are we cloning a kernel thread?</span></span><br><span class="line"><span class="comment">    * We need to steal a active VM for that..</span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line">    oldmm = current-&gt;mm;</span><br><span class="line">    <span class="keyword">if</span> (!oldmm)</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    <span class="comment">/* initialize the new vmacache entries */</span></span><br><span class="line">    <span class="built_in">vmacache_flush</span>(tsk);</span><br><span class="line">    <span class="keyword">if</span> (clone_flags &amp; CLONE_VM) &#123;</span><br><span class="line">        <span class="built_in">mmget</span>(oldmm);</span><br><span class="line">        mm = oldmm;</span><br><span class="line">        <span class="keyword">goto</span> good_mm;</span><br><span class="line">    &#125;</span><br><span class="line">    retval = -ENOMEM;</span><br><span class="line">    mm = <span class="built_in">dup_mm</span>(tsk);</span><br><span class="line">    <span class="keyword">if</span> (!mm)</span><br><span class="line">        <span class="keyword">goto</span> fail_nomem;</span><br><span class="line">good_mm:</span><br><span class="line">    tsk-&gt;mm = mm;</span><br><span class="line">    tsk-&gt;active_mm = mm;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">fail_nomem:</span><br><span class="line">    <span class="keyword">return</span> retval;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>7、分配 pid，设置 tid，group_leader，并且建立任务之间的亲缘关系。</p>
<ul>
<li>group_leader：进程的话 group_leader就是它自己，和旧进程分开。线程的话则设置为当前进程的group_leader。</li>
<li>tgid: 对进程来说是自己的pid，对线程来说是当前进程的pid</li>
<li>real_parent : 对进程来说即当前进程，对线程来说则是当前进程的real_parent</li>
</ul>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="type">static</span> __latent_entropy <span class="keyword">struct</span> <span class="title class_">task_struct</span> *<span class="built_in">copy_process</span>(......) &#123;</span><br><span class="line">......    </span><br><span class="line">    p-&gt;pid = <span class="built_in">pid_nr</span>(pid);</span><br><span class="line">    <span class="keyword">if</span> (clone_flags &amp; CLONE_THREAD) &#123;</span><br><span class="line">        p-&gt;exit_signal = <span class="number">-1</span>;</span><br><span class="line">        p-&gt;group_leader = current-&gt;group_leader;</span><br><span class="line">        p-&gt;tgid = current-&gt;tgid;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (clone_flags &amp; CLONE_PARENT)</span><br><span class="line">          p-&gt;exit_signal = current-&gt;group_leader-&gt;exit_signal;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">          p-&gt;exit_signal = (clone_flags &amp; CSIGNAL);</span><br><span class="line">        p-&gt;group_leader = p;</span><br><span class="line">        p-&gt;tgid = p-&gt;pid;</span><br><span class="line">    &#125;</span><br><span class="line">......</span><br><span class="line">    <span class="keyword">if</span> (clone_flags &amp; (CLONE_PARENT|CLONE_THREAD)) &#123;</span><br><span class="line">        p-&gt;real_parent = current-&gt;real_parent;</span><br><span class="line">        p-&gt;parent_exec_id = current-&gt;parent_exec_id;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        p-&gt;real_parent = current;</span><br><span class="line">        p-&gt;parent_exec_id = current-&gt;self_exec_id;</span><br><span class="line">    &#125; </span><br><span class="line">......  </span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h3 id="4-2-新进程的唤醒"><a href="#4-2-新进程的唤醒" class="headerlink" title="4.2 新进程的唤醒"></a>4.2 新进程的唤醒</h3><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">_do_fork 做的第二件大事是通过调用 <span class="built_in">wake_up_new_task</span>()唤醒进程。</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">wake_up_new_task</span><span class="params">(<span class="keyword">struct</span> task_struct *p)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">struct</span> <span class="title class_">rq_flags</span> rf;</span><br><span class="line">    <span class="keyword">struct</span> <span class="title class_">rq</span> *rq;</span><br><span class="line">......</span><br><span class="line">    p-&gt;state = TASK_RUNNING;</span><br><span class="line">......</span><br><span class="line">    <span class="built_in">activate_task</span>(rq, p, ENQUEUE_NOCLOCK);</span><br><span class="line">    <span class="built_in">trace_sched_wakeup_new</span>(p);</span><br><span class="line">    <span class="built_in">check_preempt_curr</span>(rq, p, WF_FORK);</span><br><span class="line">......</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>首先，我们需要将进程的状态设置为 TASK_RUNNING。activate_task() 函数中会调用 enqueue_task()。</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">activate_task</span><span class="params">(<span class="keyword">struct</span> rq *rq, <span class="keyword">struct</span> task_struct *p, <span class="type">int</span> flags)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (<span class="built_in">task_contributes_to_load</span>(p))</span><br><span class="line">        rq-&gt;nr_uninterruptible--;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">enqueue_task</span>(rq, p, flags);</span><br><span class="line"></span><br><span class="line">    p-&gt;on_rq = TASK_ON_RQ_QUEUED;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">static</span> <span class="keyword">inline</span> <span class="type">void</span> <span class="title">enqueue_task</span><span class="params">(<span class="keyword">struct</span> rq *rq, <span class="keyword">struct</span> task_struct *p, <span class="type">int</span> flags)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">.....</span><br><span class="line">    p-&gt;sched_class-&gt;<span class="built_in">enqueue_task</span>(rq, p, flags);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>如果是 CFS 的调度类，则执行相应的 enqueue_task_fair()。在 enqueue_task_fair() 中取出的队列就是 cfs_rq，然后调用 enqueue_entity()。在 enqueue_entity() 函数里面，会调用 update_curr()，更新运行的统计量，然后调用 __enqueue_entity，将 sched_entity 加入到红黑树里面，然后将 se-&gt;on_rq &#x3D; 1 设置在队列上。回到 enqueue_task_fair 后，将这个队列上运行的进程数目加一。然后，wake_up_new_task 会调用 check_preempt_curr，看是否能够抢占当前进程。</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">static</span> <span class="type">void</span></span></span><br><span class="line"><span class="function"><span class="title">enqueue_task_fair</span><span class="params">(<span class="keyword">struct</span> rq *rq, <span class="keyword">struct</span> task_struct *p, <span class="type">int</span> flags)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">struct</span> <span class="title class_">cfs_rq</span> *cfs_rq;</span><br><span class="line">    <span class="keyword">struct</span> <span class="title class_">sched_entity</span> *se = &amp;p-&gt;se;</span><br><span class="line">......</span><br><span class="line">    for_each_sched_entity(se) &#123;</span><br><span class="line">        <span class="keyword">if</span> (se-&gt;on_rq)</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        cfs_rq = <span class="built_in">cfs_rq_of</span>(se);</span><br><span class="line">        <span class="built_in">enqueue_entity</span>(cfs_rq, se, flags);</span><br><span class="line"></span><br><span class="line">        cfs_rq-&gt;h_nr_running++;</span><br><span class="line">        cfs_rq-&gt;idle_h_nr_running += idle_h_nr_running;</span><br><span class="line"></span><br><span class="line">        <span class="comment">/* end evaluation on encountering a throttled cfs_rq */</span></span><br><span class="line">        <span class="keyword">if</span> (<span class="built_in">cfs_rq_throttled</span>(cfs_rq))</span><br><span class="line">            <span class="keyword">goto</span> enqueue_throttle;</span><br><span class="line"></span><br><span class="line">        flags = ENQUEUE_WAKEUP;</span><br><span class="line">    &#125;</span><br><span class="line">......</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>在 check_preempt_curr 中，会调用相应的调度类的 rq-&gt;curr-&gt;sched_class-&gt;check_preempt_curr(rq, p, flags)。对于CFS调度类来讲，调用的是 check_preempt_wakeup。在 check_preempt_wakeup函数中，前面调用 task_fork_fair的时候，设置 sysctl_sched_child_runs_first 了，已经将当前父进程的 TIF_NEED_RESCHED 设置了，则直接返回。否则，check_preempt_wakeup 还是会调用 update_curr 更新一次统计量，然后 wakeup_preempt_entity 将父进程和子进程 PK 一次，看是不是要抢占，如果要则调用 resched_curr 标记父进程为 TIF_NEED_RESCHED。如果新创建的进程应该抢占父进程，在什么时间抢占呢？别忘了 fork 是一个系统调用，从系统调用返回的时候，是抢占的一个好时机，如果父进程判断自己已经被设置为 TIF_NEED_RESCHED，就让子进程先跑，抢占自己。</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">static</span> <span class="type">void</span> <span class="title">check_preempt_wakeup</span><span class="params">(<span class="keyword">struct</span> rq *rq, <span class="keyword">struct</span> task_struct *p, <span class="type">int</span> wake_flags)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">struct</span> <span class="title class_">task_struct</span> *curr = rq-&gt;curr;</span><br><span class="line">    <span class="keyword">struct</span> <span class="title class_">sched_entity</span> *se = &amp;curr-&gt;se, *pse = &amp;p-&gt;se;</span><br><span class="line">    <span class="keyword">struct</span> <span class="title class_">cfs_rq</span> *cfs_rq = <span class="built_in">task_cfs_rq</span>(curr);</span><br><span class="line">......</span><br><span class="line">    <span class="keyword">if</span> (<span class="built_in">test_tsk_need_resched</span>(curr))</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">......</span><br><span class="line">    <span class="built_in">find_matching_se</span>(&amp;se, &amp;pse);</span><br><span class="line">    <span class="built_in">update_curr</span>(<span class="built_in">cfs_rq_of</span>(se));</span><br><span class="line">    <span class="keyword">if</span> (<span class="built_in">wakeup_preempt_entity</span>(se, pse) == <span class="number">1</span>) &#123;</span><br><span class="line">        <span class="keyword">goto</span> preempt;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span>;</span><br><span class="line">preempt:</span><br><span class="line">    <span class="built_in">resched_curr</span>(rq);</span><br><span class="line">......</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>至此，我们就完成了任务的整个创建过程，并根据情况唤醒任务开始执行。</p>
<h2 id="5、总结"><a href="#5、总结" class="headerlink" title="5、总结"></a>5、总结</h2><p>本文十分之长，因为内容极多，源码复杂，本来想拆分为两篇文章，但是又因为过于紧密的联系因此合在了一起。本文介绍了进程的创建和线程的创建，而多进程的派生因为使用和线程内核态创建一样的函数因此放在了一起边对比边说明。由此，进程、线程的结构体以及创建过程就全部分析完了，下文将继续分析进程、线程的调度。</p>
<hr>
<p>版权声明：本文为知乎博主「玩转Linux内核」的原创文章，遵循CC 4.0 BY-SA版权协议，转载请附上原文出处链接及本声明。</p>
<p>原文链接：<a href="https://zhuanlan.zhihu.com/p/442916346">https://zhuanlan.zhihu.com/p/442916346</a></p>
]]></content>
      <categories>
        <category>linux-doc 进程管理</category>
      </categories>
      <tags>
        <tag>Linux</tag>
      </tags>
  </entry>
  <entry>
    <title>Linux内核六大进程通信机制原理</title>
    <url>/2023/01/15/linux-docs/%E8%BF%9B%E7%A8%8B%E7%AE%A1%E7%90%86/Linux%E5%86%85%E6%A0%B8%E5%85%AD%E5%A4%A7%E8%BF%9B%E7%A8%8B%E9%80%9A%E4%BF%A1%E6%9C%BA%E5%88%B6%E5%8E%9F%E7%90%86/</url>
    <content><![CDATA[<p>初学操作系统的时候，我就一直懵逼，为啥进程同步与互斥机制里有信号量机制，进程通信里又有信号量机制，然后你再看网络上的各种面试题汇总或者博客，你会发现很多都是千篇一律的进程通信机制有哪些？进程同步与互斥机制鲜有人问津。看多了我都想把 CSDN 屏了…..，最后知道真相的我只想说为啥不能一篇博客把东西写清楚，没头没尾真的浪费时间。</p>
<p>希望这篇文章能够拯救某段时间和我一样被绕晕的小伙伴。上篇文章我已经讲过进程间的同步与互斥机制，各位小伙伴看完这个再来看进程通信比较好。</p>
<p><strong>全文脉络思维导图如下：</strong></p>
<p><img src="https://pic2.zhimg.com/80/v2-05357079c73568813ec18658a5e803c1_720w.webp" alt="img"></p>
<h2 id="1、什么是进程通信"><a href="#1、什么是进程通信" class="headerlink" title="1、什么是进程通信"></a>1、什么是进程通信</h2><p>顾名思义，进程通信（ InterProcess Communication，IPC）就是指<strong>进程之间的信息交换</strong>。实际上，<strong>进程的同步与互斥本质上也是一种进程通信</strong>（这也就是待会我们会在进程通信机制中看见信号量和 PV 操作的原因了），只不过它传输的仅仅是信号量，通过修改信号量，使得进程之间建立联系，相互协调和协同工作，但是它<strong>缺乏传递数据的能力</strong>。</p>
<p>虽然存在某些情况，进程之间交换的信息量很少，比如仅仅交换某个状态信息，这样进程的同步与互斥机制完全可以胜任这项工作。但是大多数情况下，<strong>进程之间需要交换大批数据</strong>，比如传送一批信息或整个文件，这就需要通过一种新的通信机制来完成，也就是所谓的进程通信。</p>
<p>再来从操作系统层面直观的看一些进程通信：我们知道，为了保证安全，每个进程的用户地址空间都是独立的，一般而言一个进程不能直接访问另一个进程的地址空间，不过内核空间是每个进程都共享的，所以<strong>进程之间想要进行信息交换就必须通过内核</strong>。</p>
<p><img src="https://pic2.zhimg.com/80/v2-1c0a8bc38f13325491ab6a8b0f781be1_720w.webp" alt="img"></p>
<p>下面就来我们来列举一下 Linux 内核提供的常见的进程通信机制：</p>
<ul>
<li>管道（也称作共享文件）</li>
<li>消息队列（也称作消息传递）</li>
<li>共享内存（也称作共享存储）</li>
<li>信号量和 PV 操作</li>
<li>信号</li>
<li>套接字（Socket）</li>
</ul>
<h2 id="2、管道"><a href="#2、管道" class="headerlink" title="2、管道"></a>2、管道</h2><p><strong>匿名管道</strong></p>
<p>各位如果学过 Linux 命令，那对管道肯定不陌生，Linux 管道使用竖线 | 连接多个命令，这被称为管道符。</p>
<figure class="highlight text"><table><tr><td class="code"><pre><span class="line">$ command1 | command2</span><br></pre></td></tr></table></figure>

<p>以上这行代码就组成了一个管道，它的功能是将前一个命令（command1）的输出，作为后一个命令（command2）的输入，从这个功能描述中，我们可以看出<strong>管道中的数据只能单向流动</strong>，也就是半双工通信，如果想实现相互通信（全双工通信），我们需要创建两个管道才行。</p>
<p>另外，通过管道符 | 创建的管道是匿名管道，用完了就会被自动销毁。并且，匿名管道只能在具有亲缘关系（父子进程）的进程间使用，。也就是说，<strong>匿名管道只能用于父子进程之间的通信</strong>。</p>
<p>在 Linux 的实际编码中，是通过 pipe 函数来创建匿名管道的，若创建成功则返回 0，创建失败就返回 -1：</p>
<figure class="highlight text"><table><tr><td class="code"><pre><span class="line">int pipe (int fd[2]);</span><br></pre></td></tr></table></figure>

<p><strong>该函数拥有一个存储空间为 2 的文件描述符数组：</strong></p>
<ul>
<li>fd[0] 指向管道的读端，fd[1] 指向管道的写端</li>
<li>fd[1] 的输出是 fd[0] 的输入</li>
</ul>
<p><strong>粗略的解释一下通过匿名管道实现进程间通信的步骤：</strong></p>
<p>1）父进程创建两个匿名管道，管道 1（fd1[0]和 fd1[1]）和管道 2（fd2[0] 和 fd2[1]）；</p>
<blockquote>
<p>因为管道的数据是单向流动的，所以要想实现数据双向通信，就需要两个管道，每个方向一个。</p>
</blockquote>
<p>2）父进程 fork 出子进程，于是对于这两个匿名管道，子进程也分别有两个文件描述符指向匿名管道的读写两端；</p>
<p>3）父进程关闭管道 1 的读端 fd1[0] 和 管道 2 的写端 fd2[1]，子进程关闭管道 1 的写端 fd1[1] 和 管道 2 的读端 fd2[0]，这样，管道 1 只能用于父进程写、子进程读；管道 2 只能用于父进程读、子进程写。管道是用<strong>环形队列</strong>实现的，数据从写端流入从读端流出，这就实现了父子进程之间的双向通信。</p>
<p><img src="https://pic3.zhimg.com/80/v2-9a3131e0e838332fecaab3476eda26fa_720w.webp" alt="img"></p>
<p>看完上面这些讲述，我们来理解下管道的本质是什么：对于管道两端的进程而言，管道就是一个文件（这也就是为啥管道也被称为共享文件机制的原因了），但它不是普通的文件，它不属于某种文件系统，而是自立门户，单独构成一种文件系统，并且只存在于内存中。</p>
<p>简单来说，<strong>管道的本质就是内核在内存中开辟了一个缓冲区，这个缓冲区与管道文件相关联，对管道文件的操作，被内核转换成对这块缓冲区的操作</strong>。</p>
<p><strong>有名管道</strong></p>
<p>匿名管道由于没有名字，只能用于父子进程间的通信。为了克服这个缺点，提出了有名管道，也称做 FIFO，因为数据是先进先出的传输方式。</p>
<p>所谓有名管道也就是提供一个路径名与之关联，这样，即使与创建有名管道的进程不存在亲缘关系的进程，只要可以访问该路径，就能够通过这个有名管道进行相互通信。</p>
<p><strong>使用 Linux 命令 mkfifo 来创建有名管道：</strong></p>
<figure class="highlight text"><table><tr><td class="code"><pre><span class="line">$ mkfifo myPipe</span><br></pre></td></tr></table></figure>

<p><strong>myPipe 就是这个管道的名称，接下来，我们往 myPipe 这个有名管道中写入数据：</strong></p>
<figure class="highlight text"><table><tr><td class="code"><pre><span class="line">$ echo &quot;hello&quot; &gt; myPipe</span><br></pre></td></tr></table></figure>

<p>执行这行命令后，你会发现它就停在这了，这是因为管道里的内容没有被读取，只有当管道里的数据被读完后，命令才可以正常退出。于是，我们执行另外一个命令来读取这个有名管道里的数据：</p>
<figure class="highlight text"><table><tr><td class="code"><pre><span class="line">$ cat &lt; myPipe</span><br><span class="line">hello</span><br></pre></td></tr></table></figure>

<h2 id="3、消息队列"><a href="#3、消息队列" class="headerlink" title="3、消息队列"></a>3、消息队列</h2><p>可以看出，<strong>管道这种进程通信方式虽然使用简单，但是效率比较低，不适合进程间频繁地交换数据，并且管道只能传输无格式的字节流</strong>。为此，消息传递机制（Linux 中称消息队列）应用而生。比如，A 进程要给 B 进程发送消息，A 进程把数据放在对应的消息队列后就可以正常返回了，B 进程在需要的时候自行去消息队列中读取数据就可以了。同样的，B 进程要给 A 进程发送消息也是如此。</p>
<p><img src="https://pic1.zhimg.com/80/v2-a2caf6e76f9407a1752a220080b10134_720w.webp" alt="img"></p>
<p><strong>消息队列的本质就是存放在内存中的消息的链表，而消息本质上是用户自定义的数据结构</strong>。如果进程从消息队列中读取了某个消息，这个消息就会被从消息队列中删除。对比一下管道机制：</p>
<ul>
<li>消息队列允许一个或多个进程向它写入或读取消息。</li>
<li>消息队列可以实现消息的<strong>随机查询</strong>，不一定非要以先进先出的次序读取消息，也可以按消息的类型读取。比有名管道的先进先出原则更有优势。</li>
<li>对于消息队列来说，在某个进程往一个队列写入消息之前，并不需要另一个进程在该消息队列上等待消息的到达。而对于管道来说，除非读进程已存在，否则先有写进程进行写入操作是没有意义的。</li>
<li>消息队列的生命周期随内核，如果没有释放消息队列或者没有关闭操作系统，消息队列就会一直存在。而匿名管道随进程的创建而建立，随进程的结束而销毁。</li>
</ul>
<p>需要注意的是，消息队列对于交换较少数量的数据很有用，因为无需避免冲突。但是，由于用户进程写入数据到内存中的消息队列时，会发生从用户态<strong>拷贝</strong>数据到内核态的过程；同样的，另一个用户进程读取内存中的消息数据时，会发生从内核态拷贝数据到用户态的过程。因此，<strong>如果数据量较大，使用消息队列就会造成频繁的系统调用，也就是需要消耗更多的时间以便内核介入</strong>。</p>
<h2 id="4、共享内存"><a href="#4、共享内存" class="headerlink" title="4、共享内存"></a>4、共享内存</h2><p>为了避免像消息队列那样频繁的拷贝消息、进行系统调用，共享内存机制出现了。</p>
<p>顾名思义，共享内存就是允许不相干的进程将同一段物理内存连接到它们各自的地址空间中，使得这些进程可以访问同一个物理内存，这个物理内存就成为共享内存。如果某个进程向共享内存写入数据，所做的改动将<strong>立即</strong>影响到可以访问同一段共享内存的任何其他进程。</p>
<p>集合内存管理的内容，我们来深入理解下共享内存的原理。首先，每个进程都有属于自己的进程控制块（PCB）和逻辑地址空间（Addr Space），并且都有一个与之对应的页表，负责将进程的逻辑地址（虚拟地址）与物理地址进行映射，通过内存管理单元（MMU）进行管理。<strong>两个不同进程的逻辑地址通过页表映射到物理空间的同一区域，它们所共同指向的这块区域就是共享内存</strong>。</p>
<p><img src="https://pic4.zhimg.com/80/v2-30fd4ee32afadbc97fc602a8461ac74b_720w.webp" alt="img"></p>
<p>不同于消息队列频繁的系统调用，对于共享内存机制来说，仅在建立共享内存区域时需要系统调用，一旦建立共享内存，所有的访问都可作为常规内存访问，无需借助内核。这样，数据就不需要在进程之间来回拷贝，所以这是最快的一种进程通信方式。</p>
<p><img src="https://pic2.zhimg.com/80/v2-b2f88341dfb4ed26e5e11a7408e8766d_720w.webp" alt="img"></p>
<h2 id="5、信号量和-PV-操作"><a href="#5、信号量和-PV-操作" class="headerlink" title="5、信号量和 PV 操作"></a>5、信号量和 PV 操作</h2><p>实际上，对具有多 CPU 系统的最新研究表明，在这类系统上，消息传递的性能其实是要优于共享内存的，因为<strong>消息队列无需避免冲突，而共享内存机制可能会发生冲突</strong>。也就是说如果多个进程同时修改同一个共享内存，先来的那个进程写的内容就会被后来的覆盖。</p>
<p>并且，在多道批处理系统中，多个进程是可以并发执行的，但由于系统的资源有限，进程的执行不是一贯到底的， 而是走走停停，以不可预知的速度向前推进（异步性）。但有时候我们又希望多个进程能密切合作，按照某个特定的顺序依次执行，以实现一个共同的任务。</p>
<p>举个例子，如果有 A、B 两个进程分别负责读和写数据的操作，这两个线程是相互合作、相互依赖的。那么写数据应该发生在读数据之前。而实际上，由于异步性的存在，可能会发生先读后写的情况，而此时由于缓冲区还没有被写入数据，读进程 A 没有数据可读，因此读进程 A 被阻塞。</p>
<p><img src="https://pic2.zhimg.com/80/v2-44d3a2d42d9c6c0be7e636d192cdd749_720w.webp" alt="img"></p>
<p>因此，为了解决上述这两个问题，保证共享内存在任何时刻只有一个进程在访问（互斥），并且使得进程们能够按照某个特定顺序访问共享内存（同步），我们就可以使用进程的同步与互斥机制，常见的比如信号量与 PV 操作。</p>
<p><strong>进程的同步与互斥其实是一种对进程通信的保护机制，并不是用来传输进程之间真正通信的内容的，但是由于它们会传输信号量，所以也被纳入进程通信的范畴，称为低级通信</strong>。</p>
<blockquote>
<p>下面的内容和上篇文章【看完了进程同步与互斥机制，我终于彻底理解了 PV 操作】中所讲的差不多，看过的小伙伴可直接跳到下一标题。</p>
</blockquote>
<p>信号量其实就是一个变量 ，我们可以用一个信号量来表示系统中某种资源的数量，比如：系统中只有一台打印机，就可以设置一个初值为 1 的信号量。</p>
<p>用户进程可以通过使用操作系统提供的一对原语来对信号量进行操作，从而很方便的实现进程互斥或同步。这一对原语就是 PV 操作：</p>
<p>1）<strong>P 操作</strong>：将信号量值减 1，表示<strong>申请占用一个资源</strong>。如果结果小于 0，表示已经没有可用资源，则执行 P 操作的进程被阻塞。如果结果大于等于 0，表示现有的资源足够你使用，则执行 P 操作的进程继续执行。</p>
<p>可以这么理解，当信号量的值为 2 的时候，表示有 2 个资源可以使用，当信号量的值为 -2 的时候，表示有两个进程正在等待使用这个资源。不看这句话真的无法理解 V 操作，看完顿时如梦初醒。</p>
<p>2）<strong>V 操作</strong>：将信号量值加 1，表示<strong>释放一个资源</strong>，即使用完资源后归还资源。若加完后信号量的值小于等于 0，表示有某些进程正在等待该资源，由于我们已经释放出一个资源了，因此需要唤醒一个等待使用该资源（就绪态）的进程，使之运行下去。</p>
<p>我觉得已经讲的足够通俗了，不过对于 V 操作大家可能仍然有困惑，下面再来看两个关于 V 操作的问答：</p>
<p>问：<strong>信号量的值 大于 0 表示有共享资源可供使用，这个时候为什么不需要唤醒进程</strong>？</p>
<p>答：所谓唤醒进程是从就绪队列（阻塞队列）中唤醒进程，而信号量的值大于 0 表示有共享资源可供使用，也就是说这个时候没有进程被阻塞在这个资源上，所以不需要唤醒，正常运行即可。</p>
<p>问：<strong>信号量的值 等于 0 的时候表示没有共享资源可供使用，为什么还要唤醒进程</strong>？</p>
<p>答：V 操作是先执行信号量值加 1 的，也就是说，把信号量的值加 1 后才变成了 0，在此之前，信号量的值是 -1，即有一个进程正在等待这个共享资源，我们需要唤醒它。</p>
<p><strong>信号量和 PV 操作具体的定义如下：</strong></p>
<p><img src="https://pic4.zhimg.com/80/v2-7b74c0f4c727c73429e033d31686d257_720w.webp" alt="img"></p>
<p><strong>互斥访问共享内存</strong></p>
<p><strong>两步走即可实现不同进程对共享内存的互斥访问：</strong></p>
<ul>
<li>定义一个互斥信号量，并初始化为 1</li>
<li>把对共享内存的访问置于 P 操作和 V 操作之间</li>
</ul>
<p><img src="https://pic1.zhimg.com/80/v2-b9985c3b39adfc1318846b92b06f4a84_720w.webp" alt="img"></p>
<p><strong>P 操作和 V 操作必须成对出现</strong>。缺少 P 操作就不能保证对共享内存的互斥访问，缺少 V 操作就会导致共享内存永远得不到释放、处于等待态的进程永远得不到唤醒。</p>
<p><img src="https://pic2.zhimg.com/80/v2-bacaff7e77dc273c7bd9b7c206b7edf9_720w.webp" alt="img"></p>
<p><strong>实现进程同步</strong></p>
<p>回顾一下进程同步，就是要各并发进程按要求有序地运行。</p>
<p>举个例子，以下两个进程 P1、P2 并发执行，由于存在异步性，因此二者交替推进的次序是不确定的。假设 P2 的 “代码4” 要基于 P1 的 “代码1” 和 “代码2” 的运行结果才能执行，那么我们就必须保证 “代码4” 一定是在 “代码2” 之后才会执行。</p>
<p><img src="https://pic3.zhimg.com/80/v2-d235165c06aa584e182af579baeefa06_720w.webp" alt="img"></p>
<p>如果 P2 的 “代码4” 要基于 P1 的 “代码1” 和 “代码2” 的运行结果才能执行，那么我们就必须保证 “代码4” 一定是在 “代码2” 之后才会执行。</p>
<p><strong>使用信号量和 PV 操作实现进程的同步也非常方便，三步走：</strong></p>
<ul>
<li>定义一个同步信号量，并初始化为当前可用资源的数量</li>
<li>在优先级较<strong>高</strong>的操作的<strong>后</strong>面执行 V 操作，释放资源</li>
<li>在优先级较<strong>低</strong>的操作的<strong>前</strong>面执行 P 操作，申请占用资源</li>
</ul>
<p><img src="https://pic1.zhimg.com/80/v2-b96f4d81a066a07c78881580ed5d6a10_720w.webp" alt="img"></p>
<p><strong>配合下面这张图直观理解下：</strong></p>
<p><img src="https://pic1.zhimg.com/80/v2-5298a00e4d5f74ec0e6e7667761e695c_720w.webp" alt="img"></p>
<h2 id="6、-信号"><a href="#6、-信号" class="headerlink" title="6、 信号"></a>6、 信号</h2><p>注意！<strong>信号和信号量是完全不同的两个概念</strong>！</p>
<p>信号是进程通信机制中唯一的<strong>异步</strong>通信机制，它可以在任何时候发送信号给某个进程。<strong>通过发送指定信号来通知进程某个异步事件的发送，以迫使进程执行信号处理程序。信号处理完毕后，被中断进程将恢复执行</strong>。用户、内核和进程都能生成和发送信号。</p>
<p>信号事件的来源主要有硬件来源和软件来源。所谓硬件来源就是说我们可以通过键盘输入某些组合键给进程发送信号，比如常见的组合键 Ctrl+C 产生 SIGINT 信号，表示终止该进程；而软件来源就是通过 kill 系列的命令给进程发送信号，比如 kill -9 1111 ，表示给 PID 为 1111 的进程发送 SIGKILL 信号，让其立即结束。</p>
<p><strong>我们来查看一下 Linux 中有哪些信号：</strong></p>
<p><img src="https://pic3.zhimg.com/80/v2-09f8b9dcfea6a49418793954047a8f62_720w.webp" alt="img"></p>
<h2 id="7、Socket"><a href="#7、Socket" class="headerlink" title="7、Socket"></a>7、Socket</h2><p>至此，上面介绍的 5 种方法都是用于同一台主机上的进程之间进行通信的，如果想要<strong>跨网络与不同主机上的进程进行通信</strong>，那该怎么做呢？这就是 Socket 通信做的事情了（<strong>当然，Socket 也能完成同主机上的进程通信</strong>）。</p>
<p><img src="https://pic1.zhimg.com/80/v2-053f491fd42d5e7ba86295393e275310_720w.webp" alt="img"></p>
<p>Socket 起源于 Unix，原意是<strong>插座</strong>，在计算机通信领域，Socket 被翻译为<strong>套接字</strong>，它是计算机之间进行通信的一种约定或一种方式。通过 Socket 这种约定，一台计算机可以接收其他计算机的数据，也可以向其他计算机发送数据。</p>
<p>从计算机网络层面来说，<strong>Socket 套接字是网络通信的基石</strong>，是支持 TCP&#x2F;IP 协议的网络通信的基本操作单元。它是网络通信过程中端点的抽象表示，包含进行网络通信必须的五种信息：连接使用的协议，本地主机的 IP 地址，本地进程的协议端口，远地主机的 IP 地址，远地进程的协议端口。</p>
<p>Socket 的本质其实是一个编程接口（API），是应用层与 TCP&#x2F;IP 协议族通信的中间软件抽象层，它对 TCP&#x2F;IP 进行了封装。它<strong>把复杂的 TCP&#x2F;IP 协议族隐藏在 Socket 接口后面</strong>。对用户来说，只要通过一组简单的 API 就可以实现网络的连接。</p>
<h2 id="8、总结"><a href="#8、总结" class="headerlink" title="8、总结"></a>8、总结</h2><p>简单总结一下上面六种 Linux 内核提供的进程通信机制：</p>
<p>1）首先，最简单的方式就是<strong>管道</strong>，管道的本质是存放在内存中的特殊的文件。也就是说，内核在内存中开辟了一个缓冲区，这个缓冲区与管道文件相关联，对管道文件的操作，被内核转换成对这块缓冲区的操作。管道分为匿名管道和有名管道，匿名管道只能在父子进程之间进行通信，而有名管道没有限制。</p>
<p>2）虽然管道使用简单，但是效率比较低，不适合进程间频繁地交换数据，并且管道只能传输无格式的字节流。为此<strong>消息队列</strong>应用而生。消息队列的本质就是存放在内存中的消息的链表，而消息本质上是用户自定义的数据结构。如果进程从消息队列中读取了某个消息，这个消息就会被从消息队列中删除。</p>
<p>3）消息队列的速度比较慢，因为每次数据的写入和读取都需要经过用户态与内核态之间数据的拷贝过程，<strong>共享内存</strong>可以解决这个问题。所谓共享内存就是：两个不同进程的逻辑地址通过页表映射到物理空间的同一区域，它们所共同指向的这块区域就是共享内存。如果某个进程向共享内存写入数据，所做的改动将立即影响到可以访问同一段共享内存的任何其他进程。</p>
<p>对于共享内存机制来说，仅在建立共享内存区域时需要系统调用，一旦建立共享内存，所有的访问都可作为常规内存访问，无需借助内核。这样，数据就不需要在进程之间来回拷贝，所以这是最快的一种进程通信方式。</p>
<p>4）共享内存速度虽然非常快，但是存在冲突问题，为此，我们可以使用信号量和 PV 操作来实现对共享内存的互斥访问，并且还可以实现进程同步。</p>
<p>5）<strong>信号</strong>和信号量是完全不同的两个概念！信号是进程通信机制中唯一的异步通信机制，它可以在任何时候发送信号给某个进程。通过发送指定信号来通知进程某个异步事件的发送，以迫使进程执行信号处理程序。信号处理完毕后，被中断进程将恢复执行。用户、内核和进程都能生成和发送信号。</p>
<p>6）上面介绍的 5 种方法都是用于同一台主机上的进程之间进行通信的，如果想要跨网络与不同主机上的进程进行通信，就需要使用 <strong>Socket</strong> 通信。另外，Socket 也能完成同主机上的进程通信。</p>
<hr>
<p>版权声明：本文为知乎博主「玩转Linux内核」的原创文章，遵循CC 4.0 BY-SA版权协议，转载请附上原文出处链接及本声明。</p>
<p>原文链接：<a href="https://zhuanlan.zhihu.com/p/465574868">https://zhuanlan.zhihu.com/p/465574868</a></p>
]]></content>
      <categories>
        <category>linux-doc 进程管理</category>
      </categories>
      <tags>
        <tag>Linux</tag>
      </tags>
  </entry>
  <entry>
    <title>Linux内核调度和内核同步</title>
    <url>/2023/01/15/linux-docs/%E8%BF%9B%E7%A8%8B%E7%AE%A1%E7%90%86/Linux%E5%86%85%E6%A0%B8%E8%B0%83%E5%BA%A6%E5%92%8C%E5%86%85%E6%A0%B8%E5%90%8C%E6%AD%A5/</url>
    <content><![CDATA[<p>Linux2.6版本中的内核引入了一个全新的调度程序，称为O(1)调度程序，进程在被初始化并放到运行队列后，在某个时刻应该获得对CPU的访问，它负责把CPU的控制权传递到不同进程的两个函数schedule()和schedule_tick()中。下图是随着时间推移，CPU是如何在不同进程之间传递的，至于细节这里不多阐释，大家看待就可以理解的啦~</p>
<p><img src="https://pic4.zhimg.com/80/v2-646dc1655e2c1bd1ba66c313fd1f4c0b_720w.webp" alt="img"></p>
<p>下面开始介绍一下上下文切换，在操作系统中，CPU切换到另一个进程需要保存当前进程的状态并恢复另一个进程的状态：当前运行任务转为就绪（或者挂起、删除）状态，另一个被选定的就绪任务成为当前任务。上下文切换包括保存当前任务的运行环境，恢复将要运行任务的运行环境。</p>
<h2 id="1、如何获得上下文切换的次数？"><a href="#1、如何获得上下文切换的次数？" class="headerlink" title="1、如何获得上下文切换的次数？"></a>1、<strong>如何获得上下文切换的次数？</strong></h2><p>vmstat直接运行即可，在最后几列，有CPU的context switch次数。 这个是系统层面的，加入想看特定进程的情况，可以使用pidstat。</p>
<figure class="highlight text"><table><tr><td class="code"><pre><span class="line">$ vmstat 1 100</span><br><span class="line">procs -----------memory---------- ---swap-- -----io---- --system-- -----cpu------</span><br><span class="line"> r  b   swpd   free   buff  cache   si   so    bi    bo   in   cs us sy id wa st</span><br><span class="line"> 0  0     88 233484 288756 1784744    0    0     0    23    0    0  4  1 94  0  0</span><br><span class="line"> 4  0     88 233236 288756 1784752    0    0     0     0 6202 7880  4  1 96  0  0</span><br><span class="line"> 2  0     88 233360 288756 1784800    0    0     0   112 6277 7612  4  1 95  0  0</span><br><span class="line"> 0  0     88 232864 288756 1784804    0    0     0   644 5747 6593  6  0 92  2  0</span><br></pre></td></tr></table></figure>

<p>****执行pidstat，将输出系统启动后所有活动进程的cpu统计信息：</p>
<figure class="highlight text"><table><tr><td class="code"><pre><span class="line">linux:~ # pidstat</span><br><span class="line">Linux 2.6.32.12-0.7-default (linux)             06/18/12        _x86_64_</span><br><span class="line"></span><br><span class="line">11:37:19          PID    %usr %system  %guest    %CPU   CPU  Command</span><br><span class="line">……</span><br><span class="line">11:37:19        11452    0.00    0.00    0.00    0.00     2  bash</span><br><span class="line">11:37:19        11509    0.00    0.00    0.00    0.00     3  dd</span><br><span class="line">11:37:19: pidstat获取信息时间点</span><br><span class="line">PID: 进程pid</span><br><span class="line">%usr: 进程在用户态运行所占cpu时间比率</span><br><span class="line">%system: 进程在内核态运行所占cpu时间比率</span><br><span class="line">%CPU: 进程运行所占cpu时间比率</span><br><span class="line">CPU: 指示进程在哪个核运行</span><br><span class="line">Command: 拉起进程对应的命令</span><br><span class="line">备注:执行pidstat默认输出信息为系统启动后到执行时间点的统计信息，因而即使当前某进程的cpu占用率很高</span><br></pre></td></tr></table></figure>

<h2 id="2、上下文切换的性能消耗在哪里呢？"><a href="#2、上下文切换的性能消耗在哪里呢？" class="headerlink" title="2、上下文切换的性能消耗在哪里呢？"></a>2、<strong>上下文切换的性能消耗在哪里呢？</strong></h2><p>context switch过高，会导致CPU像个搬运工，频繁在寄存器和运行队列直接奔波 ，更多的时间花在了线程切换，而不是真正工作的线程上。直接的消耗包括CPU寄存器需要保存和加载，系统调度器的代码需要执行。间接消耗在于多核cache之间的共享数据。 ****</p>
<h2 id="3、引起上下文切换的原因有哪些？"><a href="#3、引起上下文切换的原因有哪些？" class="headerlink" title="3、引起上下文切换的原因有哪些？"></a>3、<strong>引起上下文切换的原因有哪些？</strong></h2><p>对于抢占式操作系统而言， 大体有几种：</p>
<ul>
<li>当前任务的时间片用完之后，系统CPU正常调度下一个任务；</li>
<li>当前任务碰到IO阻塞，调度线程将挂起此任务，继续下一个任务；</li>
<li>多个任务抢占锁资源，当前任务没有抢到，被调度器挂起，继续下一个任务；</li>
<li>用户代码挂起当前任务，让出CPU时间；</li>
<li>硬件中断；</li>
</ul>
<h2 id="4、如何测试上下文切换的时间消耗？"><a href="#4、如何测试上下文切换的时间消耗？" class="headerlink" title="4、如何测试上下文切换的时间消耗？"></a>4、<strong>如何测试上下文切换的时间消耗？</strong></h2><p>这里我再网上查找到了一个程序，代码不长，切换一个 差不多就是 20个微秒吧，这个程序望大神指教</p>
<figure class="highlight text"><table><tr><td class="code"><pre><span class="line">#include &lt;stdio.h&gt;</span><br><span class="line">#include &lt;unistd.h&gt;</span><br><span class="line">#include &lt;sys/time.h&gt;</span><br><span class="line">#include&lt;pthread.h&gt;</span><br><span class="line"></span><br><span class="line">int pipes[20][3];</span><br><span class="line">char buffer[10];</span><br><span class="line">int running = 1;</span><br><span class="line"></span><br><span class="line">void inti()</span><br><span class="line">&#123;</span><br><span class="line">    int i =20;</span><br><span class="line">    while(i--)</span><br><span class="line">    &#123;</span><br><span class="line">        if(pipe(pipes[i])&lt;0)</span><br><span class="line">            exit(1);</span><br><span class="line">        pipes[i][2] = i;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">void distroy()</span><br><span class="line">&#123;</span><br><span class="line">    int i =20;</span><br><span class="line">    while(i--)</span><br><span class="line">    &#123;</span><br><span class="line">        close(pipes[i][0]);</span><br><span class="line">        close(pipes[i][1]);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">double self_test()</span><br><span class="line">&#123;</span><br><span class="line">    int i =20000;</span><br><span class="line">    struct timeval start, end;</span><br><span class="line">    gettimeofday(&amp;start, NULL);</span><br><span class="line">    while(i--)</span><br><span class="line">    &#123;</span><br><span class="line">        if(write(pipes[0][1],buffer,10)==-1)</span><br><span class="line">            exit(1);</span><br><span class="line">        read(pipes[0][0],buffer,10);</span><br><span class="line">    &#125;</span><br><span class="line">    gettimeofday(&amp;end, NULL);</span><br><span class="line">    return (double)(1000000*(end.tv_sec-start.tv_sec)+ end.tv_usec-start.tv_usec)/20000;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">void *_test(void *arg)</span><br><span class="line">&#123;</span><br><span class="line">    int pos = ((int *)arg)[2];</span><br><span class="line">    int in = pipes[pos][0];</span><br><span class="line">    int to = pipes[(pos + 1)%20][1];</span><br><span class="line">    while(running)</span><br><span class="line">    &#123;</span><br><span class="line">        read(in,buffer,10);</span><br><span class="line">        if(write(to,buffer,10)==-1)</span><br><span class="line">            exit(1);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">double threading_test()</span><br><span class="line">&#123;</span><br><span class="line">    int i = 20;</span><br><span class="line">    struct timeval start, end;</span><br><span class="line">    pthread_t tid;</span><br><span class="line">    while(--i)</span><br><span class="line">    &#123;</span><br><span class="line">        pthread_create(&amp;tid,NULL,_test,(void *)pipes[i]);</span><br><span class="line">    &#125;</span><br><span class="line">    i = 10000;</span><br><span class="line">    gettimeofday(&amp;start, NULL);</span><br><span class="line">    while(i--)</span><br><span class="line">    &#123;</span><br><span class="line">        if(write(pipes[1][1],buffer,10)==-1)</span><br><span class="line">            exit(1);</span><br><span class="line">        read(pipes[0][0],buffer,10);</span><br><span class="line">    &#125;</span><br><span class="line">    gettimeofday(&amp;end, NULL);</span><br><span class="line">    running = 0;</span><br><span class="line">    if(write(pipes[1][1],buffer,10)==-1)</span><br><span class="line">        exit(1);</span><br><span class="line">    return (double)(1000000*(end.tv_sec-start.tv_sec)+ end.tv_usec-start.tv_usec)/10000/20;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">int main()</span><br><span class="line">&#123;</span><br><span class="line">    inti();</span><br><span class="line">    printf(&quot;%6.6f\n&quot;,self_test());</span><br><span class="line">    printf(&quot;%6.6f\n&quot;,threading_test());</span><br><span class="line">    distroy();</span><br><span class="line">    exit(0);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>总而言之，我们可以认为，这最多只能是依赖于底层操作系统的近似计算。 一个近似的解法是记录一个进程结束时的时间戳，另一个进程开始的时间戳及排除等待时间。如果所有进程总共用时为T，那么总的上下文切换时间为： T – (所有进程的等待时间和执行时间)</p>
<p>接下来来述说抢占，抢占是一个进程到另一个进程的切换，那么Linux是如何决定在何时进行切换的呢？下面我们一次来介绍这三种抢占方式。</p>
<p><strong>显式内核抢占：</strong></p>
<p>最容易的就是这个抢占啦，它发生在内核代码调用schedule(可以直接调用或者阻塞调用)时候的内核空间中。当这种方式抢占时，例如在wait_queue等待队列中设备驱动程序在等候时，控制权被简单地传递到调度程序，从而新的进程被选中执行。</p>
<p><strong>隐式用户抢占：</strong></p>
<p>当内核处理完内核空间的进程并准备把控制权传递到用户空间的进程时，它首先查看应该把控制权传递到哪一个用户空间的进程上，这个进程也行不是传递其控制权到内核的那个用户空间进程。系统中中的每一个进程有一个“必须重新调度”，在进程应该被重新调度的任何时候设置它。<strong>代码可以在include&#x2F;linux&#x2F;sched.h中查看</strong>~</p>
<figure class="highlight text"><table><tr><td class="code"><pre><span class="line">static inline void set_tsk_need_resched(struct task_struct *tsk)</span><br><span class="line">&#123;</span><br><span class="line">    set_tsk_thread_flag(tsk,TIF_NEED_RESCHED);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">static inline void clear_tsk_need_resched(struct task_struct *tsk)</span><br><span class="line">&#123;</span><br><span class="line">    clear_tsk_thread_flag(tsk,TIF_NEED_RESCHED);</span><br><span class="line">&#125;</span><br><span class="line">//set_tsk_need_resched和clear_tsk_need_resched是两个接口，用于设置体系结构特有的TIF_NEED_RESCHED标志</span><br><span class="line">stactic inline int need_resched(void)</span><br><span class="line">&#123;</span><br><span class="line">    return unlikely(test_thread_flag(TIF_NEED_RESCHED));</span><br><span class="line">&#125;//need_resched测试当前线程的标志，看看TIF_NEED_RESCHED是否被设置</span><br></pre></td></tr></table></figure>

<p><strong>隐式内核抢占：</strong></p>
<p>隐式内核抢占有两种可能性：内核代码出自使抢占禁止的代码块，或者处理正在从中断返回到内核代码时，如果控制权正在从一个中断返回到内核空间，该中断调用schedule()，一个新的 进程以刚才描述的同一种方式被选中，如果内核代码出自禁止抢占的代码块，激活抢占 的操作可能引起当前进程被抢占(代码在include&#x2F;linux&#x2F;preempt.h中查看到):</p>
<figure class="highlight text"><table><tr><td class="code"><pre><span class="line">#define preempt_enable() \</span><br><span class="line">do &#123; \</span><br><span class="line">    preempt_enable_no_resched(); \</span><br><span class="line">    preempt_check_resched(); \</span><br><span class="line">&#125; while(0)</span><br></pre></td></tr></table></figure>

<p>preempt_enable()调用preempt_enable_no_resched()，它把与当前进程相关的preempt_count减1，然后调用preempt_check_resched():</p>
<figure class="highlight text"><table><tr><td class="code"><pre><span class="line">#define preempt_check_resched() \</span><br><span class="line">do &#123; \</span><br><span class="line">    if(unlikely(test_thread_flag(TIF_NEED_RESCHED))); \</span><br><span class="line">    preempt_schedule(); \</span><br><span class="line">&#125; </span><br></pre></td></tr></table></figure>

<p>preempt_check_resched()判断当前进程是否被标记为重新调度，如果是，它调用preempt_schedule()。<br>当两个或者两个以上的进程请求对共享资源独自访问时候，它们需要具有这样一种条件，即它们是在给代码段中操作的唯一进程，在Linux内核锁的基本形式是自旋锁。自旋锁会因为连续循环等待或者试图两次获得锁这种方式的操作而导致死锁，所以在此之前必须初始化spin_lock_t，这个可以通过调用spin_lock_init()来完成(<strong>代码在include&#x2F;linux&#x2F;spinlock.h中查看</strong>)：</p>
<figure class="highlight text"><table><tr><td class="code"><pre><span class="line">#define spin_lock_init(x) \</span><br><span class="line">    do &#123; \</span><br><span class="line">        (x) -&gt; magic = SPINLOCK_MAGIC; \</span><br><span class="line">        (x) -&gt; lock = 0; \　　　　　　//设置自旋锁为&quot;开锁&quot;</span><br><span class="line">        (x) -&gt; babble = 5; \</span><br><span class="line">        (x) -&gt; module = __FILE__; \</span><br><span class="line">        (x) -&gt; owner = NULL; \</span><br><span class="line">        (x) -&gt; oline = 0; \</span><br><span class="line">    &#125; while(0)</span><br></pre></td></tr></table></figure>

<p>自旋锁被初始化后，可以通过调用spin_lock()或者spin_lock_irqsave()来获取，如果你使用spin_lock()那么进程可能在上锁的代码中被中断，为了在代码的临界区执行后释放，必须调用spin_unlock()或者spin_unlock_irqrestroe(),spin_unlock_irqrestroe()把中断寄存器的状态恢复成调用spin_lock_irq()时寄存器所处的状态。</p>
<p>自旋锁的缺点是它们频繁地循环直到等待锁的释放，那么对于等待时间长的代码区，最好是使用Linux kernel的另一个上锁工具：信号量。它的主要优势之一是：持有信号量的进程可以安全的阻塞，它们在SMP和中断中是保险的(<strong>代码在include&#x2F;asm-i386&#x2F;semaphore.h，include&#x2F;asm-ppc&#x2F;semaphore.h中可以查看</strong>)：</p>
<figure class="highlight text"><table><tr><td class="code"><pre><span class="line">struct semaphore&#123;</span><br><span class="line">    atomic_t count;</span><br><span class="line">    int sleepers;</span><br><span class="line">    wait_queue_head_t wait;</span><br><span class="line">#ifdef WAITQUEUE_DEBUG</span><br><span class="line">    long __magic;</span><br><span class="line">#endif</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>



<figure class="highlight text"><table><tr><td class="code"><pre><span class="line">struct semaphore&#123;</span><br><span class="line">    atomic_t count;</span><br><span class="line">    wait_queue_head_t wait;</span><br><span class="line">#ifdef WAITQUEUE_DEBUG</span><br><span class="line">    long __magic;</span><br><span class="line">#endif</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>两种体系结构的实现都提供了指向wait_queue的一个指针和一个计数，有了信号量我们能够让多于一个的进程同时进去代码的临界区，如果计数初始化为1，则表示只有一个进程能够进去代码的临界区，信号量用sema_init()来初始化，分别调用down()和up()来上锁和解锁，down()和up()函数的使用以及一些情况就不多说了看信号量的调用问题，很容易理解的。</p>
<hr>
<p>版权声明：本文为知乎博主「<a href="https://www.zhihu.com/people/linuxwang-xian-sheng">极致Linux内核</a>」的原创文章，遵循CC 4.0 BY-SA版权协议，转载请附上原文出处链接及本声明。</p>
<p>原文链接：<a href="https://zhuanlan.zhihu.com/p/548630794">https://zhuanlan.zhihu.com/p/548630794</a></p>
]]></content>
      <categories>
        <category>linux-doc 进程管理</category>
      </categories>
      <tags>
        <tag>Linux</tag>
      </tags>
  </entry>
  <entry>
    <title>Linux内核进程栈内存底层原理到Segmentation fault报错</title>
    <url>/2023/01/15/linux-docs/%E8%BF%9B%E7%A8%8B%E7%AE%A1%E7%90%86/Linux%E5%86%85%E6%A0%B8%E8%BF%9B%E7%A8%8B%E6%A0%88%E5%86%85%E5%AD%98%E5%BA%95%E5%B1%82%E5%8E%9F%E7%90%86%E5%88%B0Segmentation%20fault%E6%8A%A5%E9%94%99/</url>
    <content><![CDATA[<p>栈是编程中使用内存最简单的方式。例如，下面的简单代码中的局部变量 n 就是在堆栈中分配内存的。</p>
<figure class="highlight text"><table><tr><td class="code"><pre><span class="line">#include &lt;stdio.h&gt;</span><br><span class="line">void main()</span><br><span class="line">&#123;</span><br><span class="line"> int n = 0;</span><br><span class="line"> printf(&quot;0x%x\n&quot;,&amp;v); </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>那么我有几个问题想问问大家，看看大家对于堆栈内存是否真的了解。</p>
<ul>
<li>堆栈的物理内存是什么时候分配的？</li>
<li>堆栈的大小限制是多大？这个限制可以调整吗？</li>
<li>当堆栈发生溢出后应用程序会发生什么？</li>
</ul>
<p>如果你对以上问题还理解不是特别深刻，今天来带你好好修炼进程堆栈内存这块的内功！</p>
<h2 id="1、进程堆栈的初始化"><a href="#1、进程堆栈的初始化" class="headerlink" title="1、进程堆栈的初始化"></a>1、进程堆栈的初始化</h2><p>进程启动调用 exec 加载可执行文件过程的时候，会给进程栈申请一个 4 KB 的初始内存。我们今天来专门抽取并看一下这段逻辑。</p>
<p>加载系统调用 execve 依次调用 do_execve、do_execve_common 来完成实际的可执行程序加载。</p>
<figure class="highlight text"><table><tr><td class="code"><pre><span class="line">//file:fs/exec.c</span><br><span class="line">static int do_execve_common(const char *filename, ...)</span><br><span class="line">&#123;</span><br><span class="line"> bprm_mm_init(bprm);</span><br><span class="line"> ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>在 bprm_mm_init 中会申请一个全新的地址空间 mm_struct 对象，准备留着给新进程使用。</p>
<figure class="highlight text"><table><tr><td class="code"><pre><span class="line">//file:fs/exec.c</span><br><span class="line">static int bprm_mm_init(struct linux_binprm *bprm)</span><br><span class="line">&#123;</span><br><span class="line"> //申请个全新的地址空间 mm_struct 对象</span><br><span class="line"> bprm-&gt;mm = mm = mm_alloc();</span><br><span class="line"> __bprm_mm_init(bprm);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>还会给新进程的栈申请一页大小的虚拟内存空间，作为给新进程准备的栈内存。申请完后把栈的指针保存到 bprm-&gt;p 中记录起来。</p>
<figure class="highlight text"><table><tr><td class="code"><pre><span class="line">//file:fs/exec.c</span><br><span class="line">static int __bprm_mm_init(struct linux_binprm *bprm)</span><br><span class="line">&#123;</span><br><span class="line"> bprm-&gt;vma = vma = kmem_cache_zalloc(vm_area_cachep, GFP_KERNEL);</span><br><span class="line"> vma-&gt;vm_end = STACK_TOP_MAX;</span><br><span class="line"> vma-&gt;vm_start = vma-&gt;vm_end - PAGE_SIZE;</span><br><span class="line"> ...</span><br><span class="line"></span><br><span class="line"> bprm-&gt;p = vma-&gt;vm_end - sizeof(void *);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>我们平时所说的进程虚拟地址空间在 Linux 是通过一个个的 vm_area_struct 对象来表示的。</p>
<p><img src="https://pic1.zhimg.com/80/v2-65c9df9b151c25df39283157eb473f58_720w.webp" alt="img"></p>
<p>每一个 vm_area_struct（就是上面 __bprm_mm_init 函数中的 vma）对象表示进程虚拟地址空间里的一段范围，其 vm_start 和 vm_end 表示启用的虚拟地址范围的开始和结束。</p>
<figure class="highlight text"><table><tr><td class="code"><pre><span class="line">//file:include/linux/mm_types.h</span><br><span class="line">struct vm_area_struct &#123;</span><br><span class="line"> unsigned long vm_start;</span><br><span class="line"> unsigned long vm_end;</span><br><span class="line"> ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>要注意的是这只是地址范围，而不是真正的物理内存分配</strong> 。</p>
<p>在上面 __bprm_mm_init 函数中通过 kmem_cache_zalloc 申请了一个 vma 内核对象。vm_end 指向了 STACK_TOP_MAX（地址空间的顶部附近的位置），vm_start 和 vm_end 之间留了一个 Page 大小。<strong>也就是说默认给栈准备了 4KB 的大小</strong> 。最后把栈的指针记录到 bprm-&gt;p 中。</p>
<p><img src="https://pic3.zhimg.com/80/v2-b4460f3c4da6938f1548410ab562b612_720w.webp" alt="img"></p>
<p>接下来进程加载过程会使用 load_elf_binary 真正开始加载可执行二进制程序。在加载时，会把前面准备的进程栈的地址空间指针设置到了新进程 mm 对象上。</p>
<figure class="highlight text"><table><tr><td class="code"><pre><span class="line">//file:fs/binfmt_elf.c</span><br><span class="line">static int load_elf_binary(struct linux_binprm *bprm)</span><br><span class="line">&#123; //ELF 文件头解析</span><br><span class="line"> //Program Header 读取</span><br><span class="line"> //清空父进程继承来的资源</span><br><span class="line"> retval = flush_old_exec(bprm);</span><br><span class="line"> ...</span><br><span class="line"></span><br><span class="line"> current-&gt;mm-&gt;start_stack = bprm-&gt;p;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<p><img src="https://pic2.zhimg.com/80/v2-67dc52318a0b598168a2509acc495f29_720w.webp" alt="img"></p>
<p>这样新进程将来就可以使用栈进行函数调用，以及局部变量的申请了。</p>
<p>前面我们说了，这里只是给栈申请了地址空间对象，并没有真正申请物理内存。我们接着再来看一下，物理内存页究竟是什么时候分配的。</p>
<h2 id="2、物理页的申请"><a href="#2、物理页的申请" class="headerlink" title="2、物理页的申请"></a>2、物理页的申请</h2><p>当进程在运行的过程中在栈上开始分配和访问变量的时候，如果物理页还没有分配，会触发缺页中断。在缺页中断种来真正地分配物理内存。</p>
<p>为了避免篇幅过长，触发缺页中断的过程就先不展开了。我们直接看一下缺页中断的核心处理入口 __do_page_fault，它位于 arch&#x2F;x86&#x2F;mm&#x2F;fault.c 文件下。</p>
<figure class="highlight text"><table><tr><td class="code"><pre><span class="line">//file:arch/x86/mm/fault.c</span><br><span class="line">static void __kprobes</span><br><span class="line">__do_page_fault(struct pt_regs *regs, unsigned long error_code)</span><br><span class="line">&#123;</span><br><span class="line"> ...</span><br><span class="line"> //根据新的 address 查找对应的 vma</span><br><span class="line"> vma = find_vma(mm, address);</span><br><span class="line"></span><br><span class="line"> //如果找到的 vma 的开始地址比 address 小</span><br><span class="line"> //那么就不调用expand_stack了，直接调用</span><br><span class="line"> if (likely(vma-&gt;vm_start &lt;= address))</span><br><span class="line">  goto good_area;</span><br><span class="line"> ...</span><br><span class="line"> if (unlikely(expand_stack(vma, address))) &#123;</span><br><span class="line">  bad_area(regs, error_code, address);</span><br><span class="line">  return;</span><br><span class="line"> &#125;</span><br><span class="line">good_area:</span><br><span class="line"> //调用handle_mm_fault来完成真正的内存申请</span><br><span class="line"> fault = handle_mm_fault(mm, vma, address, flags);</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>当访问栈上变量的内存的时候，首先会调用 find_vma 根据变量地址 address 找到其所在的 vma 对象。接下来调用的 if (vma-&gt;vm_start &lt;&#x3D; address) 是在判断地址空间还够不够用。</p>
<p><img src="https://pic2.zhimg.com/80/v2-e3c4101a6975c49a4602c5c814892939_720w.webp" alt="img"></p>
<p>如果栈内存 vma 的 start 比要访问的 address 小，则证明地址空间够用，只需要分配物理内存页就行了。如果栈内存 vma 的 start 比要访问的 address 大，则需要调用 expand_stack 先扩展一下栈的虚拟地址空间 vma。扩展虚拟地址空间的具体细节我们在第三节再讲。</p>
<p>这里先假设要访问的变量地址 address 处于栈内存 vma 对象的 vm_start 和 vm_end 之间。那么缺页中断处理就会跳转到 good_area 处运行。在这里调用 handle_mm_fault 来<strong>完成真正物理内存的申请</strong> 。</p>
<figure class="highlight text"><table><tr><td class="code"><pre><span class="line">//file:mm/memory.c</span><br><span class="line">int handle_mm_fault(struct mm_struct *mm, struct vm_area_struct *vma,</span><br><span class="line">  unsigned long address, unsigned int flags)</span><br><span class="line">&#123;</span><br><span class="line"> ...</span><br><span class="line"></span><br><span class="line"> //依次查看每一级页表项</span><br><span class="line"> pgd = pgd_offset(mm, address);</span><br><span class="line"> pud = pud_alloc(mm, pgd, address);</span><br><span class="line"> pmd = pmd_alloc(mm, pud, address);</span><br><span class="line"> pte = pte_offset_map(pmd, address);</span><br><span class="line"></span><br><span class="line"> return handle_pte_fault(mm, vma, address, pte, pmd, flags);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>Linux 是用四级页表来管理虚拟地址空间到物理内存之间的映射管理的。所以在实际申请物理页面之前，需要先 check 一遍需要的每一级页表项是否存在，不存在的话需要申请。</p>
<p>为了好区分，Linux 还给每一级页表都起了一个名字。</p>
<ul>
<li>一级页表：Page Global Dir，简称 pgd</li>
<li>二级页表：Page Upper Dir，简称 pud</li>
<li>三级页表：Page Mid Dir，简称 pmd</li>
<li>四级页表：Page Table，简称 pte</li>
</ul>
<p>看一下下面这个图就比较好理解了</p>
<p><img src="https://pic4.zhimg.com/80/v2-29cda8752da193f919c7e1d79f1fdc1f_720w.webp" alt="img"></p>
<figure class="highlight text"><table><tr><td class="code"><pre><span class="line">//file:mm/memory.c</span><br><span class="line">int handle_pte_fault(struct mm_struct *mm,</span><br><span class="line">       struct vm_area_struct *vma, unsigned long address,</span><br><span class="line">       pte_t *pte, pmd_t *pmd, unsigned int flags)</span><br><span class="line">&#123;</span><br><span class="line"> ...</span><br><span class="line"></span><br><span class="line"> //匿名映射页处理</span><br><span class="line"> return do_anonymous_page(mm, vma, address,</span><br><span class="line">       pte, pmd, flags);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>在 handle_pte_fault 会处理很多种的内存缺页处理，比如文件映射缺页处理、swap缺页处理、写时复制缺页处理、匿名映射页处理等等几种情况。我们今天讨论的主题是栈内存，这个对应的是匿名映射页处理，会进入到 do_anonymous_page 函数中。</p>
<figure class="highlight text"><table><tr><td class="code"><pre><span class="line">//file:mm/memory.c</span><br><span class="line">static int do_anonymous_page(struct mm_struct *mm, struct vm_area_struct *vma,</span><br><span class="line">  unsigned long address, pte_t *page_table, pmd_t *pmd,</span><br><span class="line">  unsigned int flags)</span><br><span class="line">&#123;</span><br><span class="line"> // 分配可移动的匿名页面，底层通过 alloc_page</span><br><span class="line"> page = alloc_zeroed_user_highpage_movable(vma, address);</span><br><span class="line"> ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>在 do_anonymous_page 调用 alloc_zeroed_user_highpage_movable 分配一个可移动的匿名物理页出来。在底层会调用到伙伴系统的 alloc_pages 进行实际物理页面的分配。</p>
<p>内核是用伙伴系统来管理所有的物理内存页的。其它模块需要物理页的时候都会调用伙伴系统对外提供的函数来申请物理内存。</p>
<p><img src="https://pic4.zhimg.com/80/v2-a3ea1ac0ec54715a1b24f908b9c3e04b_720w.webp" alt="img"></p>
<p>到了这里，开篇的问题一就有答案了，堆栈的物理内存是什么时候分配的？进程在加载的时候只是会给新进程的栈内存分配一段地址空间范围。而真正的物理内存是等到访问的时候触发缺页中断，再从伙伴系统中申请的。</p>
<h2 id="3、栈的自动增长"><a href="#3、栈的自动增长" class="headerlink" title="3、栈的自动增长"></a>3、栈的自动增长</h2><p>前面我们看到了，进程在被加载启动的时候，栈内存默认只分配了 4 KB 的空间。那么随着程序的运行，当栈中保存的调用链，局部变量越来越多的时候，必然会超过 4 KB。</p>
<p>我回头看下缺页处理函数 __do_page_fault。如果栈内存 vma 的 start 比要访问的 address 大，则需要调用 expand_stack 先扩展一下栈的虚拟地址空间 vma。</p>
<p><img src="https://pic4.zhimg.com/80/v2-c40035a9cf5fa602efa48b7f43a689c7_720w.webp" alt="img"></p>
<p>回顾 __do_page_fault 源码，看到扩充栈空间的是由 expand_stack 函数来完成的。</p>
<figure class="highlight text"><table><tr><td class="code"><pre><span class="line">//file:arch/x86/mm/fault.c</span><br><span class="line">static void __kprobes</span><br><span class="line">__do_page_fault(struct pt_regs *regs, unsigned long error_code)</span><br><span class="line">&#123;</span><br><span class="line"> ...</span><br><span class="line"> if (likely(vma-&gt;vm_start &lt;= address))</span><br><span class="line">  goto good_area;</span><br><span class="line"> </span><br><span class="line"> //如果栈 vma 的开始地址比 address 大，需要扩大栈</span><br><span class="line"> if (unlikely(expand_stack(vma, address))) &#123;</span><br><span class="line">  bad_area(regs, error_code, address);</span><br><span class="line">  return;</span><br><span class="line"> &#125;</span><br><span class="line">good_area:</span><br><span class="line"> ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>我们来看下 expand_stack 的内部细节。</p>
<blockquote>
<p>其实在 Linux 栈地址空间增长是分两种方向的，一种是从高地址往低地址增长，一种是反过来。大部分情况都是由高往低增长的。本文只以向下增长为例。</p>
</blockquote>
<figure class="highlight text"><table><tr><td class="code"><pre><span class="line">//file:mm/mmap.c</span><br><span class="line">int expand_stack(struct vm_area_struct *vma, unsigned long address)</span><br><span class="line">&#123;</span><br><span class="line"> ...</span><br><span class="line"> return expand_downwards(vma, address);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">int expand_downwards(struct vm_area_struct *vma, unsigned long address)</span><br><span class="line">&#123;</span><br><span class="line"> ...</span><br><span class="line"> //计算栈扩大后的最后大小</span><br><span class="line"> size = vma-&gt;vm_end - address;</span><br><span class="line"></span><br><span class="line"> //计算需要扩充几个页面</span><br><span class="line"> grow = (vma-&gt;vm_start - address) &gt;&gt; PAGE_SHIFT;</span><br><span class="line"></span><br><span class="line"> //判断是否允许扩充</span><br><span class="line"> acct_stack_growth(vma, size, grow);</span><br><span class="line"></span><br><span class="line"> //如果允许则开始扩充</span><br><span class="line"> vma-&gt;vm_start = address;</span><br><span class="line"></span><br><span class="line"> return ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>在 expand_downwards 中先进行了几个计算。</p>
<ul>
<li>计算出新的堆栈大小。计算公式是 size &#x3D; vma-&gt;vm_end - address;</li>
<li>计算需要增长的页数。计算公式是 grow &#x3D; (vma-&gt;vm_start - address) &gt;&gt; PAGE_SHIFT;</li>
</ul>
<p>然后会判断此次栈空间是否被允许扩充， 判断是在 acct_stack_growth 中完成的。如果允许扩展，则简单修改一下 vma-&gt;vm_start 就可以了！</p>
<p><img src="https://pic1.zhimg.com/80/v2-cff6204b9aa9ec2e34875f38963c2d44_720w.webp" alt="img"></p>
<p>我们再来看 acct_stack_growth 都进行了哪些限制判断。</p>
<figure class="highlight text"><table><tr><td class="code"><pre><span class="line">//file:mm/mmap.c</span><br><span class="line">static int acct_stack_growth(struct vm_area_struct *vma, unsigned long size, unsigned long grow)</span><br><span class="line">&#123;</span><br><span class="line"> ...</span><br><span class="line"> //检查地址空间是否超出限制</span><br><span class="line"> if (!may_expand_vm(mm, grow))</span><br><span class="line">  return -ENOMEM;</span><br><span class="line"></span><br><span class="line"> //检查是否超出栈的大小限制</span><br><span class="line"> if (size &gt; ACCESS_ONCE(rlim[RLIMIT_STACK].rlim_cur))</span><br><span class="line">  return -ENOMEM;</span><br><span class="line"> ...</span><br><span class="line"> return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>在 acct_stack_growth 中只是进行一系列的判断。may_expand_vm 判断的是增长完这几个页后是否超出整体虚拟地址空间大小的限制。rlim[RLIMIT_STACK].rlim_cur 中记录的是栈空间大小的限制。这些限制都可以通过 ulimit 命令查看到。</p>
<figure class="highlight text"><table><tr><td class="code"><pre><span class="line"># ulimit -a</span><br><span class="line">......</span><br><span class="line">max memory size         (kbytes, -m) unlimited</span><br><span class="line">stack size              (kbytes, -s) 8192</span><br><span class="line">virtual memory          (kbytes, -v) unlimited</span><br></pre></td></tr></table></figure>

<p>上面的这个输出表示虚拟地址空间大小没有限制，栈空间的限制是 8 MB。如果进程栈大小超过了这个限制，会返回 -ENOMEM。如果觉得系统默认的大小不合适可以通过 ulimit 命令修改。</p>
<figure class="highlight text"><table><tr><td class="code"><pre><span class="line"># ulimit -s 10240</span><br><span class="line"># ulimit -a</span><br><span class="line">stack size              (kbytes, -s) 10240</span><br></pre></td></tr></table></figure>

<p>到这里开篇的第二个问题也有答案了，堆栈的大小限制是多大？这个限制可以调整吗？<br>进程堆栈大小的限制在每个机器上都是不一样的，可以通过 ulimit 命令来查看，也同样可以使用该命令修改。</p>
<p>至于开篇的问题3，当堆栈发生溢出后应用程序会发生什么？写个简单的无限递归调用就知道了，估计你也遇到过。报错结果就是</p>
<figure class="highlight text"><table><tr><td class="code"><pre><span class="line">&#x27;Segmentation fault (core dumped)</span><br></pre></td></tr></table></figure>

<h2 id="4、本文总结"><a href="#4、本文总结" class="headerlink" title="4、本文总结"></a>4、本文总结</h2><p>来总结下本文的内容，本文讨论了进程栈内存的工作原理。</p>
<p>第一，进程在加载的时候给进程栈申请了一块虚拟地址空间 vma 内核对象。vm_start 和 vm_end 之间留了一个 Page ，也就是说默认给栈准备了 4KB 的空间。<br>第二，当进程在运行的过程中在栈上开始分配和访问变量的时候，如果物理页还没有分配，会触发缺页中断。在缺页中断中调用内核的伙伴系统真正地分配物理内存。<br>第三，当栈中的存储超过 4KB 的时候会自动进行扩大。不过大小要受到限制，其大小限制可以通过 ulimit -s来查看和设置。</p>
<p><img src="https://pic4.zhimg.com/80/v2-a3ea1ac0ec54715a1b24f908b9c3e04b_720w.webp" alt="img"></p>
<p>注意，今天我们讨论的都是进程栈。线程栈和进程栈有些不一样。</p>
<p>在回顾和总结下开篇我们抛出的三个问题：</p>
<p>问题一：堆栈的物理内存是什么时候分配的？进程在加载的时候只是会给新进程的栈内存分配一段地址空间范围。而真正的物理内存是等到访问的时候触发缺页中断，再从伙伴系统中申请的。</p>
<p>问题二：堆栈的大小限制是多大？这个限制可以调整吗？<br>进程堆栈大小的限制在每个机器上都是不一样的，可以通过 ulimit 命令来查看，也同样可以使用该命令修改。</p>
<p>问题3：当堆栈发生溢出后应用程序会发生什么？当堆栈溢出的时候，我们会收到报错 “Segmentation fault (core dumped)”</p>
<p>最后，抛个问题大家一起思考吧。你觉得内核为什么要对进程栈的地址空间进行限制呢？</p>
<hr>
<p>版权声明：本文为知乎博主「Linux内核库」的原创文章，遵循CC 4.0 BY-SA版权协议，转载请附上原文 出处链接及本声明。</p>
<p>原文链接：<a href="https://zhuanlan.zhihu.com/p/606284748">https://zhuanlan.zhihu.com/p/606284748</a></p>
]]></content>
      <categories>
        <category>linux-doc 进程管理</category>
      </categories>
      <tags>
        <tag>Linux</tag>
      </tags>
  </entry>
  <entry>
    <title>Linux内核进程的管理与调度</title>
    <url>/2023/01/15/linux-docs/%E8%BF%9B%E7%A8%8B%E7%AE%A1%E7%90%86/Linux%E5%86%85%E6%A0%B8%E8%BF%9B%E7%A8%8B%E7%9A%84%E7%AE%A1%E7%90%86%E4%B8%8E%E8%B0%83%E5%BA%A6/</url>
    <content><![CDATA[<h2 id="一，前戏"><a href="#一，前戏" class="headerlink" title="一，前戏"></a><strong>一，前戏</strong></h2><h3 id="1-1-进程调度"><a href="#1-1-进程调度" class="headerlink" title="1.1 进程调度"></a><strong>1.1 进程调度</strong></h3><p>内存中保存了对每个进程的唯一描述, 并通过若干结构与其他进程连接起来.</p>
<p><strong>调度器</strong>面对的情形就是这样, 其任务是在程序之间共享CPU时间, 创造并行执行的错觉, 该任务分为两个不同的部分, 其中一个涉及<strong>调度策略</strong>, 另外一个涉及<strong>上下文切换</strong>.</p>
<h3 id="1-2-进程的分类"><a href="#1-2-进程的分类" class="headerlink" title="1.2 进程的分类"></a><strong>1.2 进程的分类</strong></h3><p>linux把进程区分为实时进程和非实时进程, 其中非实时进程进一步划分为交互式进程和批处理进程</p>
<p><strong>类型描述示例</strong>交互式进程(interactive process)此类进程经常与用户进行交互, 因此需要花费很多时间等待键盘和鼠标操作. 当接受了用户的输入后, 进程必须很快被唤醒, 否则用户会感觉系统反应迟钝shell, 文本编辑程序和图形应用程序批处理进程(batch process)此类进程不必与用户交互, 因此经常在后台运行. 因为这样的进程不必很快相应, 因此常受到调度程序的怠慢程序语言的编译程序, 数据库搜索引擎以及科学计算实时进程(real-time process)这些进程由很强的调度需要, 这样的进程绝不会被低优先级的进程阻塞. 并且他们的响应时间要尽可能的短视频音频应用程序, 机器人控制程序以及从物理传感器上收集数据的程序</p>
<p>在linux中, 调度算法可以明确的确认所有实时进程的身份, 但是没办法区分交互式程序和批处理程序, linux2.6的调度程序实现了基于进程过去行为的启发式算法, 以确定进程应该被当做交互式进程还是批处理进程. 当然与批处理进程相比, 调度程序有偏爱交互式进程的倾向</p>
<h3 id="1-3-不同进程采用不同的调度策略"><a href="#1-3-不同进程采用不同的调度策略" class="headerlink" title="1.3 不同进程采用不同的调度策略"></a><strong>1.3 不同进程采用不同的调度策略</strong></h3><p>根据进程的不同分类Linux采用不同的调度策略.</p>
<p>对于实时进程，采用FIFO或者Round Robin的调度策略.</p>
<p>对于普通进程，则需要区分交互式和批处理式的不同。传统Linux调度器提高交互式应用的优先级，使得它们能更快地被调度。而CFS和RSDL等新的调度器的核心思想是”完全公平”。这个设计理念不仅大大简化了调度器的代码复杂度，还对各种调度需求的提供了更完美的支持.</p>
<p>注意Linux通过将进程和线程调度视为一个，同时包含二者。进程可以看做是单个线程，但是进程可以包含共享一定资源（代码和&#x2F;或数据）的多个线程。因此进程调度也包含了线程调度的功能.</p>
<p>目前非实时进程的调度策略比较简单, 因为实时进程值只要求尽可能快的被响应, 基于优先级, 每个进程根据它重要程度的不同被赋予不同的优先级，调度器在每次调度时, 总选择优先级最高的进程开始执行. 低优先级不可能抢占高优先级, 因此FIFO或者Round Robin的调度策略即可满足实时进程调度的需求.</p>
<p>但是普通进程的调度策略就比较麻烦了, 因为普通进程不能简单的只看优先级, 必须公平的占有CPU, 否则很容易出现进程饥饿, 这种情况下用户会感觉操作系统很卡, 响应总是很慢，因此在linux调度器的发展历程中经过了多次重大变动, linux总是希望寻找一个最接近于完美的调度策略来公平快速的调度进程.</p>
<h3 id="1-4-linux调度器的演变"><a href="#1-4-linux调度器的演变" class="headerlink" title="1.4 linux调度器的演变"></a><strong>1.4 linux调度器的演变</strong></h3><p>一开始的调度器是复杂度为<strong>O(n)</strong></p>
<p><strong>O(n)的始调度算法</strong>(实际上每次会遍历所有任务，所以复杂度为O(n)), 这个算法的缺点是当内核中有很多任务时，调度器本身就会耗费不少时间，所以，从linux2.5开始引入赫赫有名的<strong>O(1)</strong></p>
<p><strong>O(1)调度器</strong></p>
<p>然而，linux是集全球很多程序员的聪明才智而发展起来的超级内核，没有最好，只有更好，在O(1)</p>
<p>O(1)调度器风光了没几天就又被另一个更优秀的调度器取代了，它就是<strong>CFS调度器Completely Fair Scheduler</strong>. 这个也是在2.6内核中引入的，具体为2.6.23，即从此版本开始，内核使用CFS作为它的默认调度器，O(1)</p>
<p>O(1)调度器被抛弃了。</p>
<p>所以完全有理由相信，后续如果再会出现一个更优秀的调度器，CFS也不会幸免。因为linux只要最好的那个。</p>
<h2 id="二，O-n-的始调度算法"><a href="#二，O-n-的始调度算法" class="headerlink" title="二，O(n)的始调度算法"></a><strong>二，</strong>O(n)的始调度算法</h2><h3 id="2-1-Linux2-4之前的内核调度器"><a href="#2-1-Linux2-4之前的内核调度器" class="headerlink" title="2.1 Linux2.4之前的内核调度器"></a><strong>2.1 Linux2.4之前的内核调度器</strong></h3><p>早期的Linux进程调度器使用了最低的设计，它显然不关注具有很多处理器的大型架构，更不用说是超线程了。</p>
<p>Linux调度器使用了环形队列用于可运行的任务管理, 使用循环调度策略.</p>
<p>此调度器添加和删除进程效率很高（具有保护结构的锁）。简而言之，该调度器并不复杂但是简单快捷.</p>
<p>Linux版本2.2引入了调度类的概念，允许针对实时任务、非抢占式任务、非实时任务的调度策略。调度器还包括对称多处理 (SMP) 支持。</p>
<h3 id="2-2-Linux2-4的调度器"><a href="#2-2-Linux2-4的调度器" class="headerlink" title="2.2 Linux2.4的调度器"></a><strong>2.2 Linux2.4的调度器</strong></h3><p><strong>2.2.1 概述</strong></p>
<p>在Linux2.4.18中(linux-2.5)之前的内核, 当很多任务都处于活动状态时, 调度器有很明显的限制. 这是由于调度器是使用一个复杂度为O(n)</p>
<p>O(n)的算法实现的调度器采用基于优先级的设计，这个调度器和Linus在1992年发布的调度器没有大的区别。该调度器的pick next算法非常简单：对runqueue中所有进程的优先级进行依次进行比较，选择最高优先级的进程作为下一个被调度的进程。(Runqueue是Linux 内核中保存所有就绪进程的队列). pick next用来指从所有候选进程中挑选下一个要被调度的进程的过程。</p>
<p>这种调度算法非常简单易懂: 在每次进程切换时, 内核扫描可运行进程的链表, 计算优先级,然胡选择”最佳”进程来运行.</p>
<p>在这种调度器中, 调度任务所花费的时间是一个系统中任务个数的函数. 换而言之, 活动的任务越多, 调度任务所花费的时间越长. 在任务负载非常重时, 处理器会因调度消耗掉大量的时间, 用于任务本身的时间就非常少了。因此，这个算法缺乏可伸缩性</p>
<p><strong>2.2.2 详情</strong></p>
<p>每个进程被创建时都被赋予一个时间片。时钟中断递减当前运行进程的时间片，当进程的时间片被用完时，它必须等待重新赋予时间片才能有机会运行。Linux2.4调度器保证只有当所有RUNNING进程的时间片都被用完之后，才对所有进程重新分配时间片。这段时间被称为一个epoch。这种设计保证了每个进程都有机会得到执行。每个epoch中，每个进程允许执行到其时间切片用完。如果某个进程没有使用其所有的时间切片，那么剩余时间切片的一半将被添加到新时间切片使其在下个epoch中可以执行更长时间。调度器只是迭代进程，应用goodness函数（指标）决定下面执行哪个进程。当然，各种进程对调度的需求并不相同，Linux 2.4调度器主要依靠改变进程的优先级，来满足不同进程的调度需求。事实上，所有后来的调度器都主要依赖修改进程优先级来满足不同的调度需求。</p>
<p>实时进程：实时进程的优先级是静态设定的，而且始终大于普通进程的优先级。因此只有当runqueue中没有实时进程的情况下，普通进程才能够获得调度。</p>
<blockquote>
<p>实时进程采用两种调度策略，SCHED_FIFO 和 SCHED_RR<br>FIFO 采用先进先出的策略，对于所有相同优先级的进程，最先进入 runqueue 的进程总能优先获得调度；Round Robin采用更加公平的轮转策略，使得相同优先级的实时进程能够轮流获得调度。</p>
</blockquote>
<p>普通进程：对于普通进程，调度器倾向于提高交互式进程的优先级，因为它们需要快速的用户响应。普通进程的优先级主要由进程描述符中的Counter字段决定 (还要加上 nice 设定的静态优先级) 。进程被创建时子进程的 counter值为父进程counter值的一半，这样保证了任何进程不能依靠不断地 fork() 子进程从而获得更多的执行机会。</p>
<p>Linux2.4调度器是如何提高交互式进程的优先级的呢？如前所述，当所有 RUNNING 进程的时间片被用完之后，调度器将重新计算所有进程的 counter 值，所有进程不仅包括 RUNNING 进程，也包括处于睡眠状态的进程。处于睡眠状态的进程的 counter 本来就没有用完，在重新计算时，他们的 counter 值会加上这些原来未用完的部分，从而提高了它们的优先级。交互式进程经常因等待用户输入而处于睡眠状态，当它们重新被唤醒并进入 runqueue 时，就会优先于其它进程而获得 CPU。从用户角度来看，交互式进程的响应速度就提高了。</p>
<p><strong>该调度器的主要缺点：</strong></p>
<ul>
<li>可扩展性不好</li>
<li>调度器选择进程时需要遍历整个 runqueue 从中选出最佳人选，因此该算法的执行时间与进程数成正比。另外每次重新计算 counter 所花费的时间也会随着系统中进程数的增加而线性增长，当进程数很大时，更新 counter 操作的代价会非常高，导致系统整体的性能下降。</li>
<li>高负载系统上的调度性能比较低</li>
<li>2.4的调度器预分配给每个进程的时间片比较大，因此在高负载的服务器上，该调度器的效率比较低，因为平均每个进程的等待时间于该时间片的大小成正比。</li>
<li>交互式进程的优化并不完善</li>
<li>Linux2.4识别交互式进程的原理基于以下假设，即交互式进程比批处理进程更频繁地处于SUSPENDED状态。然而现实情况往往并非如此，有些批处理进程虽然没有用户交互，但是也会频繁地进行IO操作，比如一个数据库引擎在处理查询时会经常地进行磁盘IO，虽然它们并不需要快速地用户响应，还是被提高了优先级。当系统中这类进程的负载较重时，会影响真正的交互式进程的响应时间。</li>
<li>对实时进程的支持不够</li>
<li>Linux2.4内核是非抢占的，当进程处于内核态时不会发生抢占，这对于真正的实时应用是不能接受的。</li>
</ul>
<p>为了解决这些问题，Ingo Molnar开发了新的$O(1)调度器，在CFS和RSDL之前，这个调度器不仅被Linux2.6采用，还被backport到Linux2.4中，很多商业的发行版本都采用了这个调度器</p>
<h2 id="三，O-1-的调度算法"><a href="#三，O-1-的调度算法" class="headerlink" title="三，O(1)的调度算法"></a><strong>三，</strong>O(1)的调度算法</h2><h3 id="3-1-概述"><a href="#3-1-概述" class="headerlink" title="3.1 概述"></a><strong>3.1 概述</strong></h3><p>由于进程优先级的最大值为139，因此MAX_PRIO的最大值取140(具体的是，普通进程使用100到139的优先级，实时进程使用0到99的优先级).</p>
<p>因此，该调度算法为每个优先级都设置一个可运行队列, 即包含140个可运行状态的进程链表，每一条优先级链表上的进程都具有相同的优先级，而不同进程链表上的进程都拥有不同的优先级。</p>
<p>除此之外, 还包括一个优先级位图bitmap。该位图使用一个位(bit)来代表一个优先级，而140个优先级最少需要5个32位来表示， 因此只需要一个int[5]就可以表示位图，该位图中的所有位都被置0，当某个优先级的进程处于可运行状态时，该优先级所对应的位就被置1。</p>
<p>如果确定了优先级，那么选取下一个进程就简单了，只需在queue数组中对应的链表上选取一个进程即可。</p>
<p>最后，在早期的内核中，抢占是不可能的；这意味着如果有一个低优先级的任务在执行，高优先级的任务只能等待它完成。</p>
<h3 id="3-2-详情"><a href="#3-2-详情" class="headerlink" title="3.2 详情"></a><strong>3.2 详情</strong></h3><p>从名字就可以看出O(1)调度器主要解决了以前版本中的扩展性问题。</p>
<p>O(1)调度算法所花费的时间为常数，与当前系统中的进程个数无关。</p>
<p>此外Linux 2.6内核支持内核态抢占，因此更好地支持了实时进程。</p>
<p>相对于前任，O(1)调度器还更好地区分了交互式进程和批处理式进程。</p>
<p>Linux 2.6内核也支持三种调度策略。其中SCHED_FIFO和SCHED_RR用于实时进程，而SCHED_NORMAL用于普通进程。</p>
<p>O(1)调度器在两个方面修改了Linux 2.4调度器，一是进程优先级的计算方法；二是pick next算法。</p>
<p>O(1)调度器跟踪运行队列中可运行的任务（实际上，每个优先级水平有两个运行队列，一个用于活动任务，一个用于过期任务）， 这意味着要确定接下来执行的任务，调度器只需按优先级将下一个任务从特定活动的运行队列中取出即可。</p>
<p><strong>3.2.1 普通进程的优先级计算</strong></p>
<p>不同类型的进程应该有不同的优先级。每个进程与生俱来（即从父进程那里继承而来）都有一个优先级，我们将其称为静态优先级。普通进程的静态优先级范围从100到139，100为最高优先级，139 为最低优先级，0－99保留给实时进程。当进程用完了时间片后，系统就会为该进程分配新的时间片（即基本时间片），静态优先级本质上决定了时间片分配的大小。</p>
<p><strong>静态优先级和基本时间片的关系如下：</strong></p>
<blockquote>
<p>静态优先级&lt;120，基本时间片&#x3D;max((140-静态优先级)*20, MIN_TIMESLICE)<br>静态优先级&gt;&#x3D;120，基本时间片&#x3D;max((140-静态优先级)*5, MIN_TIMESLICE)</p>
</blockquote>
<p>其中MIN_TIMESLICE为系统规定的最小时间片。从该计算公式可以看出，静态优先级越高（值越低），进程得到的时间片越长。其结果是，优先级高的进程会获得更长的时间片，而优先级低的进程得到的时间片则较短。进程除了拥有静态优先级外，还有动态优先级，其取值范围是100到139。当调度程序选择新进程运行时就会使用进程的动态优先级，动态优先级和静态优先级的关系可参考下面的公式：</p>
<blockquote>
<p>动态优先级&#x3D;max(100 , min(静态优先级 – bonus + 5) , 139)</p>
</blockquote>
<p>从上面看出，动态优先级的生成是以静态优先级为基础，再加上相应的惩罚或奖励(bonus)。这个bonus并不是随机的产生，而是根据进程过去的平均睡眠时间做相应的惩罚或奖励。</p>
<p>所谓平均睡眠时间（sleep_avg，位于task_struct结构中）就是进程在睡眠状态所消耗的总时间数，这里的平均并不是直接对时间求平均数。平均睡眠时间随着进程的睡眠而增长，随着进程的运行而减少。因此，平均睡眠时间记录了进程睡眠和执行的时间，它是用来判断进程交互性强弱的关键数据。如果一个进程的平均睡眠时间很大，那么它很可能是一个交互性很强的进程。反之，如果一个进程的平均睡眠时间很小，那么它很可能一直在执行。另外，平均睡眠时间也记录着进程当前的交互状态，有很快的反应速度。比如一个进程在某一小段时间交互性很强，那么sleep_avg就有可能暴涨（当然它不能超过 MAX_SLEEP_AVG），但如果之后都一直处于执行状态，那么sleep_avg就又可能一直递减。理解了平均睡眠时间，那么bonus的含义也就显而易见了。交互性强的进程会得到调度程序的奖励（bonus为正），而那些一直霸占CPU的进程会得到相应的惩罚（bonus为负）。其实bonus相当于平均睡眠时间的缩影，此时只是将sleep_avg调整成bonus数值范围内的大小。可见平均睡眠时间可以用来衡量进程是否是一个交互式进程。如果满足下面的公式，进程就被认为是一个交互式进程：</p>
<blockquote>
<p>动态优先级≤3*静态优先级&#x2F;4 + 28</p>
</blockquote>
<p>平均睡眠时间是进程处于等待睡眠状态下的时间，该值在进程进入睡眠状态时增加，而进入RUNNING状态后则减少。该值的更新时机分布在很多内核函数内：时钟中断scheduler_tick()；进程创建；进程从TASK_INTERRUPTIBLE状态唤醒；负载平衡等。</p>
<h3 id="3-2-2-实时进程的优先级计算"><a href="#3-2-2-实时进程的优先级计算" class="headerlink" title="3.2.2 实时进程的优先级计算"></a><strong>3.2.2 实时进程的优先级计算</strong></h3><p>实时进程的优先级由sys_sched_setschedule()设置。该值不会动态修改，而且总是比普通进程的优先级高。在进程描述符中用rt_priority域表示。</p>
<h3 id="3-2-3-pick-next算法"><a href="#3-2-3-pick-next算法" class="headerlink" title="3.2.3 pick next算法"></a><strong>3.2.3 pick next算法</strong></h3><p>普通进程的调度选择算法基于进程的优先级，拥有最高优先级的进程被调度器选中。</p>
<p>2.4中，时间片counter同时也表示了一个进程的优先级。2.6中时间片用任务描述符中的time_slice域表示，而优先级用prio（普通进程）或者rt_priority（实时进程）表示。调度器为每一个CPU维护了两个进程队列数组：指向活动运行队列的active数组和指向过期运行队列的expire数组。数组中的元素着保存某一优先级的进程队列指针。系统一共有140个不同的优先级，因此这两个数组大小都是140。它们是按照先进先出的顺序进行服务的。被调度执行的任务都会被添加到各自运行队列优先级列表的末尾。每个任务都有一个时间片，这取决于系统允许执行这个任务多长时间。运行队列的前100个优先级列表保留给实时任务使用，后40个用于用户任务，参见下图：</p>
<p><img src="https://pic4.zhimg.com/80/v2-37350dce681c50bcd70d138984dd3d7b_720w.webp" alt="img"></p>
<p>当需要选择当前最高优先级的进程时，2.6调度器不用遍历整个runqueue，而是直接从active数组中选择当前最高优先级队列中的第一个进程。假设当前所有进程中最高优先级为50（换句话说，系统中没有任何进程的优先级小于50）。则调度器直接读取 active[49]，得到优先级为50的进程队列指针。该队列头上的第一个进程就是被选中的进程。这种算法的复杂度为O(1)，从而解决了2.4调度器的扩展性问题。为了实现O(1)算法active数组维护了一个由5个32位的字（140个优先级）组成的bitmap，当某个优先级别上有进程被插入列表时，相应的比特位就被置位。 sched_find_first_bit()函数查询该bitmap，返回当前被置位的最高优先级的数组下标。在上例中sched_find_first_bit函数将返回49。在IA处理器上可以通过bsfl等指令实现。可见查找一个任务来执行所需要的时间并不依赖于活动任务的个数，而是依赖于优先级的数量。这使得 2.6 版本的调度器成为一个复杂度为 O(1) 的过程，因为调度时间既是固定的，而且也不会受到活动任务个数的影响。</p>
<p>为了提高交互式进程的响应时间，O(1)调度器不仅动态地提高该类进程的优先级，还采用以下方法：每次时钟tick中断时，进程的时间片(time_slice)被减一。当time_slice为0时，表示当前进程的时间片用完，调度器判断当前进程的类型，如果是交互式进程或者实时进程，则重置其时间片并重新插入active数组。如果不是交互式进程则从active数组中移到expired数组，并根据上述公式重新计算时间片。这样实时进程和交互式进程就总能优先获得CPU。然而这些进程不能始终留在active数组中，否则进入expire数组的进程就会产生饥饿现象。当进程已经占用CPU时间超过一个固定值后，即使它是实时进程或者交互式进程也会被移到expire数组中。当active数组中的所有进程都被移到expire数组中后，调度器交换active数组和expire数组。因此新的active数组又恢复了初始情况，而expire数组为空，从而开始新的一轮调度。</p>
<p>Linux 2.6调度器改进了前任调度器的可扩展性问题，schedule()函数的时间复杂度为O(1)。这取决于两个改进：</p>
<ul>
<li>pick next算法借助于active数组，无需遍历runqueue；</li>
<li>消了定期更新所有进程counter的操作，动态优先级的修改分布在进程切换，时钟tick中断以及其它一些内核函数中进行。</li>
</ul>
<p>O(1)调度器区分交互式进程和批处理进程的算法与以前虽大有改进，但仍然在很多情况下会失效。有一些著名的程序总能让该调度器性能下降，导致交互式进程反应缓慢。例如fiftyp.c, thud.c, chew.c, ring-test.c, massive_intr.c等。而且O(1)调度器对NUMA支持也不完善。为了解决这些问题，大量难以维护和阅读的复杂代码被加入Linux2.6.0的调度器模块，虽然很多性能问题因此得到了解决，可是另外一个严重问题始终困扰着许多内核开发者，那就是代码的复杂度问题。很多复杂的代码难以管理并且对于纯粹主义者而言未能体现算法的本质。</p>
<p>为了解决O(1)调度器面临的问题以及应对其他外部压力, 需要改变某些东西。这种改变来自Con Kolivas的内核补丁staircase scheduler（楼梯调度算法），以及改进的RSDL（Rotating Staircase Deadline Scheduler）。它为调度器设计提供了一个新的思路。Ingo Molnar在RSDL之后开发了CFS，并最终被2.6.23内核采用。接下来我们开始介绍这些新一代调度器。</p>
<h2 id="四，Linux-2-6的新一代调度器CFS"><a href="#四，Linux-2-6的新一代调度器CFS" class="headerlink" title="四，Linux 2.6的新一代调度器CFS"></a><strong>四，Linux 2.6的新一代调度器CFS</strong></h2><h3 id="4-1-楼梯调度算法staircase-scheduler"><a href="#4-1-楼梯调度算法staircase-scheduler" class="headerlink" title="4.1 楼梯调度算法staircase scheduler"></a><strong>4.1 楼梯调度算法staircase scheduler</strong></h3><p>楼梯算法(SD)在思路上和O(1)算法有很大不同，它抛弃了动态优先级的概念。而采用了一种完全公平的思路。前任算法的主要复杂性来自动态优先级的计算，调度器根据平均睡眠时间和一些很难理解的经验公式来修正进程的优先级以及区分交互式进程。这样的代码很难阅读和维护。楼梯算法思路简单，但是实验证明它对应交互式进程的响应比其前任更好，而且极大地简化了代码。</p>
<p>和O(1)算法一样，楼梯算法也同样为每一个优先级维护一个进程列表，并将这些列表组织在active数组中。当选取下一个被调度进程时，SD算法也同样从active数组中直接读取。与O(1)算法不同在于，当进程用完了自己的时间片后，并不是被移到expire数组中。而是被加入active数组的低一优先级列表中，即将其降低一个级别。不过请注意这里只是将该任务插入低一级优先级任务列表中，任务本身的优先级并没有改变。当时间片再次用完，任务被再次放入更低一级优先级任务队列中。就象一部楼梯，任务每次用完了自己的时间片之后就下一级楼梯。任务下到最低一级楼梯时，如果时间片再次用完，它会回到初始优先级的下一级任务队列中。比如某进程的优先级为1，当它到达最后一级台阶140后，再次用完时间片时将回到优先级为2的任务队列中，即第二级台阶。不过此时分配给该任务的time_slice将变成原来的2倍。比如原来该任务的时间片time_slice为10ms，则现在变成了20ms。基本的原则是，当任务下到楼梯底部时，再次用完时间片就回到上次下楼梯的起点的下一级台阶。并给予该任务相同于其最初分配的时间片。总结如下：设任务本身优先级为P，当它从第N级台阶开始下楼梯并到达底部后，将回到第N+1级台阶。并且赋予该任务N+1倍的时间片。</p>
<p><strong>以上描述的是普通进程的调度算法，实时进程还是采用原来的调度策略，即FIFO或者Round Robin。</strong></p>
<p>楼梯算法能避免进程饥饿现象，高优先级的进程会最终和低优先级的进程竞争，使得低优先级进程最终获得执行机会。对于交互式应用，当进入睡眠状态时，与它同等优先级的其他进程将一步一步地走下楼梯，进入低优先级进程队列。当该交互式进程再次唤醒后，它还留在高处的楼梯台阶上，从而能更快地被调度器选中，加速了响应时间。</p>
<p>楼梯算法的优点：从实现角度看，SD基本上还是沿用了O(1)的整体框架，只是删除了O(1)调度器中动态修改优先级的复杂代码；还淘汰了expire数组，从而简化了代码。它最重要的意义在于证明了完全公平这个思想的可行性。</p>
<h3 id="4-2-RSDL-Rotating-Staircase-Deadline-Scheduler"><a href="#4-2-RSDL-Rotating-Staircase-Deadline-Scheduler" class="headerlink" title="4.2 RSDL(Rotating Staircase Deadline Scheduler)"></a><strong>4.2 RSDL(Rotating Staircase Deadline Scheduler)</strong></h3><p>RSDL也是由Con Kolivas开发的，它是对SD算法的改进。核心的思想还是”完全公平”。没有复杂的动态优先级调整策略。RSDL重新引入了expire数组。它为每一个优先级都分配了一个 “组时间配额”，记为Tg；同一优先级的每个进程都拥有同样的”优先级时间配额”，用Tp表示。当进程用完了自身的Tp时，就下降到下一优先级进程组中。这个过程和SD相同，在RSDL中这个过程叫做minor rotation（次轮询）。请注意Tp不等于进程的时间片，而是小于进程的时间片。下图表示了minor rotation。进程从priority1的队列中一步一步下到priority140之后回到priority2的队列中，这个过程如下图左边所示，然后从priority 2开始再次一步一步下楼，到底后再次反弹到priority3队列中<strong>，如下图所示：</strong></p>
<p><img src="https://pic3.zhimg.com/80/v2-19aabcf6d63b82765722aee42087beba_720w.webp" alt="img"></p>
<p>在SD算法中，处于楼梯底部的低优先级进程必须等待所有的高优先级进程执行完才能获得CPU。因此低优先级进程的等待时间无法确定。RSDL中，当高优先级进程组用完了它们的Tg(即组时间配额)时，无论该组中是否还有进程Tp尚未用完，所有属于该组的进程都被强制降低到下一优先级进程组中。这样低优先级任务就可以在一个可以预计的未来得到调度。从而改善了调度的公平性。这就是RSDL中Deadline代表的含义。</p>
<p>进程用完了自己的时间片time_slice时（下图中T2），将放入expire数组指向的对应初始优先级队列中(priority 1)。</p>
<p><img src="https://pic2.zhimg.com/80/v2-f7df33d46e61495aff7521c87ac1fead_720w.webp" alt="img"></p>
<p>当active数组为空，或者所有的进程都降低到最低优先级时就会触发主轮询major rotation。Major rotation交换active数组和expire数组，所有进程都恢复到初始状态，再一次从新开始minor rotation的过程。</p>
<p>RSDL对交互式进程的支持：和SD同样的道理，交互式进程在睡眠时间时，它所有的竞争者都因为minor rotation而降到了低优先级进程队列中。当它重新进入RUNNING状态时，就获得了相对较高的优先级，从而能被迅速响应。</p>
<h3 id="4-3-完全公平的调度器CFS"><a href="#4-3-完全公平的调度器CFS" class="headerlink" title="4.3 完全公平的调度器CFS"></a><strong>4.3 完全公平的调度器CFS</strong></h3><p>CFS是最终被内核采纳的调度器。它从RSDL&#x2F;SD中吸取了完全公平的思想，不再跟踪进程的睡眠时间，也不再企图区分交互式进程。它将所有的进程都统一对待，这就是公平的含义。CFS的算法和实现都相当简单，众多的测试表明其性能也非常优越。</p>
<p>按照作者Ingo Molnar的说法（参考Documentation&#x2F;scheduler&#x2F;sched-design-CFS.txt），CFS百分之八十的工作可以用一句话概括：CFS在真实的硬件上模拟了完全理想的多任务处理器。在真空的硬件上，同一时刻我们只能运行单个进程，因此当一个进程占用CPU时，其它进程就必须等待，这就产生了不公平。但是在“完全理想的多任务处理器 “下，每个进程都能同时获得CPU的执行时间，即并行地每个进程占1&#x2F;nr_running的时间。例如当系统中有两个进程时，CPU的计算时间被分成两份，每个进程获得50%。假设runqueue中有n个进程，当前进程运行了10ms。在“完全理想的多任务处理器”中，10ms应该平分给n个进程(不考虑各个进程的nice值)，因此当前进程应得的时间是(10&#x2F;n)ms，但是它却运行了10ms。所以CFS将惩罚当前进程，使其它进程能够在下次调度时尽可能取代当前进程。最终实现所有进程的公平调度。</p>
<p>与之前的Linux调度器不同，CFS没有将任务维护在链表式的运行队列中，它抛弃了active&#x2F;expire数组，而是对每个CPU维护一个以时间为顺序的红黑树。</p>
<p><strong>该树方法能够良好运行的原因在于：</strong></p>
<ul>
<li>红黑树可以始终保持平衡，这意味着树上没有路径比任何其他路径长两倍以上。</li>
<li>由于红黑树是二叉树，查找操作的时间复杂度为O(log n)。但是除了最左侧查找以外，很难执行其他查找，并且最左侧的节点指针始终被缓存。</li>
<li>对于大多数操作（插入、删除、查找等），红黑树的执行时间为O(log n)，而以前的调度程序通过具有固定优先级的优先级数组使用 O(1)。O(log n) 行为具有可测量的延迟，但是对于较大的任务数无关紧要。Molnar在尝试这种树方法时，首先对这一点进行了测试。</li>
<li>红黑树可通过内部存储实现，即不需要使用外部分配即可对数据结构进行维护。</li>
</ul>
<p>要实现平衡，CFS使用”虚拟运行时”表示某个任务的时间量。任务的虚拟运行时越小，意味着任务被允许访问服务器的时间越短，其对处理器的需求越高。CFS还包含睡眠公平概念以便确保那些目前没有运行的任务（例如，等待 I&#x2F;O）在其最终需要时获得相当份额的处理器。</p>
<p><strong>4.3.1 CFS如何实现pick next</strong></p>
<p><strong>下图是一个红黑树的例子：</strong></p>
<p><img src="https://pic2.zhimg.com/80/v2-825df22daa0d29b4050efa74776aa9e9_720w.webp" alt="img"></p>
<p>所有可运行的任务通过不断地插入操作最终都存储在以时间为顺序的红黑树中（由 sched_entity 对象表示），对处理器需求最多的任务（最低虚拟运行时）存储在树的左侧，处理器需求最少的任务（最高虚拟运行时）存储在树的右侧。 为了公平，CFS调度器会选择红黑树最左边的叶子节点作为下一个将获得cpu的任务。这样，树左侧的进程就被给予时间运行了。</p>
<p><strong>4.3.2 tick中断</strong></p>
<p>在CFS中，tick中断首先更新调度信息。然后调整当前进程在红黑树中的位置。调整完成后如果发现当前进程不再是最左边的叶子，就标记need_resched标志，中断返回时就会调用scheduler()完成进程切换。否则当前进程继续占用CPU。从这里可以看到 CFS抛弃了传统的时间片概念。Tick中断只需更新红黑树，以前的所有调度器都在tick中断中递减时间片，当时间片或者配额被用完时才触发优先级调整并重新调度。</p>
<p><strong>4.3.3 红黑树键值计算</strong></p>
<p>理解CFS的关键就是了解红黑树键值的计算方法。该键值由三个因子计算而得：一是进程已经占用的CPU时间；二是当前进程的nice值；三是当前的cpu负载。进程已经占用的CPU时间对键值的影响最大，其实很大程度上我们在理解CFS时可以简单地认为键值就等于进程已占用的 CPU时间。因此该值越大，键值越大，从而使得当前进程向红黑树的右侧移动。另外CFS规定，nice值为1的进程比nice值为0的进程多获得10%的 CPU时间。在计算键值时也考虑到这个因素，因此nice值越大，键值也越大。</p>
<p>CFS为每个进程都维护两个重要变量：fair_clock和wait_runtime。这里我们将为每个进程维护的变量称为进程级变量，为每个CPU维护的称作CPU级变量，为每个runqueue维护的称为runqueue级变量。进程插入红黑树的键值即为fair_clock – wait_runtime。其中fair_clock从其字面含义上讲就是一个进程应获得的CPU时间，即等于进程已占用的CPU时间除以当前 runqueue中的进程总数；wait_runtime是进程的等待时间。它们的差值代表了一个进程的公平程度。该值越大，代表当前进程相对于其它进程越不公平。对于交互式任务，wait_runtime长时间得不到更新，因此它能拥有更高的红黑树键值，更靠近红黑树的左边。从而得到快速响应。</p>
<p>红黑树是平衡树，调度器每次总最左边读出一个叶子节点，该读取操作的时间复杂度是O(LogN)</p>
<p>O(LogN)</p>
<p><strong>4.3.4 调度器管理器</strong></p>
<p>为了支持实时进程，CFS提供了调度器模块管理器。各种不同的调度器算法都可以作为一个模块注册到该管理器中。不同的进程可以选择使用不同的调度器模块。2.6.23中，CFS实现了两个调度算法，CFS算法模块和实时调度模块。对应实时进程，将使用实时调度模块。对应普通进程则使用CFS算法。CFS 调度模块（在 kernel&#x2F;sched_fair.c 中实现）用于以下调度策略：SCHED_NORMAL、SCHED_BATCH 和 SCHED_IDLE。对于 SCHED_RR 和 SCHED_FIFO 策略，将使用实时调度模块（该模块在 kernel&#x2F;sched_rt.c 中实现）。</p>
<p><strong>4.3.5 CFS组调度</strong></p>
<p>CFS组调度（在 2.6.24 内核中引入）是另一种为调度带来公平性的方式，尤其是在处理产生很多其他任务的任务时。 假设一个产生了很多任务的服务器要并行化进入的连接（HTTP 服务器的典型架构）。不是所有任务都会被统一公平对待， CFS 引入了组来处理这种行为。产生任务的服务器进程在整个组中（在一个层次结构中）共享它们的虚拟运行时，而单个任务维持其自己独立的虚拟运行时。这样单个任务会收到与组大致相同的调度时间。您会发现 &#x2F;proc 接口用于管理进程层次结构，让您对组的形成方式有完全的控制。使用此配置，您可以跨用户、跨进程或其变体分配公平性。</p>
<p>考虑一个两用户示例，用户 A 和用户 B 在一台机器上运行作业。用户 A 只有两个作业正在运行，而用户 B 正在运行 48 个作业。组调度使 CFS 能够对用户 A 和用户 B 进行公平调度，而不是对系统中运行的 50 个作业进行公平调度。每个用户各拥有 50% 的 CPU 使用。用户 B 使用自己 50% 的 CPU 分配运行他的 48 个作业，而不会占用属于用户 A 的另外 50% 的 CPU 分配。</p>
<blockquote>
<p>更多CFS的信息, 请参照<br><a href="https://link.zhihu.com/?target=http://www.ibm.com/developerworks/cn/linux/l-completely-fair-scheduler/index.html?ca=drs-cn-0125">http://www.ibm.com/developerworks/cn/linux/l-completely-fair-scheduler/index.html?ca=drs-cn-0125</a><br>另外内核文档sched-design-CFS.txt中也有介绍。</p>
</blockquote>
<h2 id="五，返璞归真的Linux-BFS调度器"><a href="#五，返璞归真的Linux-BFS调度器" class="headerlink" title="五，返璞归真的Linux BFS调度器"></a><strong>五，返璞归真的Linux BFS调度器</strong></h2><p>BFS 是一个进程调度器，可以解释为“脑残调度器”。这古怪的名字有多重含义，比较容易被接受的一个说法为：它如此简单，却如此出色，这会让人对自己的思维能力产生怀疑。</p>
<p>BFS 不会被合并进入 Linus 维护的 Linux mainline，BFS 本身也不打算这么做。但 BFS 拥有众多的拥趸，这只有一个原因：BFS 非常出色，它让用户的桌面环境达到了前所未有的流畅。在硬件越来越先进，系统却依然常显得迟钝的时代，这实在让人兴奋。</p>
<p>进入 2010 年，Android 开发一个分支使用 BFS 作为其操作系统的标准调度器，这也证明了 BFS 的价值。后来放弃。</p>
<h3 id="5-1-BFS的引入"><a href="#5-1-BFS的引入" class="headerlink" title="5.1 BFS的引入"></a><strong>5.1 BFS的引入</strong></h3><p><strong>前些天突然在网上看到了下面的图片：</strong></p>
<p><img src="https://pic1.zhimg.com/80/v2-da89aee9e2b61b6ffa36682a019380f0_720w.webp" alt="img"></p>
<p>后来发现该图片是BFS调度器的引子, 太具有讽刺意义了。</p>
<h3 id="5-2-可配置型调度器的需求"><a href="#5-2-可配置型调度器的需求" class="headerlink" title="5.2 可配置型调度器的需求"></a><strong>5.2 可配置型调度器的需求</strong></h3><p>为了避免小手段，那就要彻底抛弃“鱼与熊掌可兼得”的思想，采用“一种调度器只适用于一种场景”的新思路. 如此我们可以设计多种调度器, 在安装操作系统的时候可以由管理员进行配置, 比如我们将其用于桌面，那么就使用”交互调度器”, 如果用于路由器, 那就使用”大吞吐调度器”, …消除了兼顾的要求，调度器设计起来就更佳简单和纯粹了.</p>
<p>面对需要大吞吐量的网络操作系统, 我们有传统的UNIX调度器, 然而面对日益桌面化的操作系统比如Android手机, 我们是否能摒弃那种大而全的调度策略呢?</p>
<p>Con Kolivas老大设计出的BFS调度器就是为桌面交互式应用量身打造的.</p>
<h3 id="5-3-问题在哪"><a href="#5-3-问题在哪" class="headerlink" title="5.3 问题在哪?"></a><strong>5.3 问题在哪?</strong></h3><p>Linux 2.6内核实现了那么多的调度器，然而其效果总是有美中不足的地方，到底问题出在哪里？事实上，Linux 2.6的各种调度器的实现都不是完全按照理论完成的，其中都添加了一些小手段. 比如虽然CFS号称支持大于2048的CPU个数，然而实际应用中，效果未必好，因为CFS调度器继承了O(1)调度器的load_balance特性，因此在那么多处理器之间进行基于调度域的load_balance，锁定以及独占的代价将会十分大，从而抵消了每CPU队列带来的消除锁定的优势.</p>
<p>总之，这些调度器太复杂了，而且越来越复杂，将80%的精力消耗在了20%的场景中. 实际上，做设计不要联想，完全依照我们目前所知道的和所遇到的来，在可用性和效率上被证明是明智的，当然不考虑太多的可扩展性。</p>
<h3 id="5-4-回到O-n-调度器"><a href="#5-4-回到O-n-调度器" class="headerlink" title="5.4 回到O(n)调度器"></a><strong>5.4 回到O(n)调度器</strong></h3><p>BFS调度器用一句话来总结就是”回到了O(n)调度器”，它在O(n)调度器的基础上进行了优化，而没有引入看起来很好的O(1)调度器, 这就是其实质.</p>
<p>O(n)调度器有什么不好么?有的, 大不了就是遍历的时间太长，BFS根据实际的测试数据忽略之；每个处理器都要锁定整个队列，BFS改之，做到这些既可，这才叫基于O(n)调度器的优化而不是彻底颠覆O(n)调度器而引入O(1)调度器-当然前提是桌面环境。如果说能回到原始的O(n)调度器进行修改使之重新发挥其作用而不是彻底抛弃它，这才是最佳的做法，反之，如果我们把问题的解决方案搞的越来越复杂，最终就是陷入一个泥潭而不可自拔。要知道方案复杂性的积累是一个笛卡儿积式的积累，你必须考虑到每一种排列组合才能，当你做不到这一点的时候，你就需要返璞归真。</p>
<h3 id="5-5-BFS调度器的原理"><a href="#5-5-BFS调度器的原理" class="headerlink" title="5.5 BFS调度器的原理"></a><strong>5.5 BFS调度器的原理</strong></h3><p>BFS的原理十分简单，其实质正是使用了O(1)调度器中的位图的概念，所有进程被安排到103个queue中，各个进程不是按照优先级而是按照优先级区间被排列到各自所在的区间，每一个区间拥有一个queue，如下图所示：</p>
<p><img src="https://pic4.zhimg.com/80/v2-aee225b6e1733975d773bf225d6146a3_720w.webp" alt="img"></p>
<p>内核在pick-next的时候，按照O(1)调度器的方式首先查找位图中不为0的那个queue，然后在该queue中执行O(n)查找，查找到virtual deadline(如下所述)最小的那个进程投入执行。过程很简单，就像流水一样。之所以规划103个队列而不是一个完全是为了进程按照其性质而分类，这个和每CPU没有任何关系，将进程按照其性质(RT?优先级?)分类而不是按照CPU分类是明智之举。内核中只有一个“103队列”，m个CPU和“103队列”完全是一个“消费者-生产者”的关系。O(1)调度器，内核中拥有m(CPU个数)个“消费者-生产者”的关系，每一个CPU附带一个“生产者(140队列组)”。</p>
<p>只有统一的，单一的“消费者-生产者”的关系才能做到调度的公平，避免了多个关系之间踢皮球现象，这是事实。在结构单一，功能确定且硬件简单的系统中，正确的调度器架构如下图所示：</p>
<p><img src="https://pic2.zhimg.com/80/v2-91783f7b13dd045382174121e498bdf9_720w.webp" alt="img"></p>
<p>在结构单一，功能确定且硬件简单的系统中，不正确的调度器架构如下图所示：</p>
<p><img src="https://pic1.zhimg.com/80/v2-879bc0babe1298338d54b6228837c484_720w.webp" alt="img"></p>
<p><strong>虚拟 Deadline ( Virtual Deadline )</strong></p>
<p>当一个进程被创建时，它被赋予一个固定的时间片，和一个虚拟 Deadline。该虚拟 deadline 的计算公式非常简单：</p>
<p>Virtual Deadline &#x3D; jiffies + (user_priority * rr_interval)</p>
<ul>
<li>1</li>
</ul>
<p>其中 jiffies 是当前时间 , user_priority 是进程的优先级，rr_interval 代表 round-robin interval，近似于一个进程必须被调度的最后期限，所谓 Deadline 么。不过在这个 Deadline 之前还有一个形容词为 Virtual，因此这个 Deadline 只是表达一种愿望而已，并非很多领导们常说的那种 deadline。</p>
<p>虚拟 Deadline 将用于调度器的 picknext 决策</p>
<p><strong>进程队列的表示方法和调度策略</strong></p>
<p>在操作系统内部，所有的 Ready 进程都被存放在进程队列中，调度器从进程队列中选取下一个被调度的进程。因此如何设计进程队列是我们研究调度器的一个重要话题。BFS 采用了非常传统的进程队列表示方法，即 bitmap 加 queue。</p>
<p><strong>BFS 将所有进程分成 4 类，分别表示不同的调度策略 :</strong></p>
<p>Realtime，实时进程 SCHED_ISO，isochronous 进程，用于交互式任务 SCHED_NORMAL，普通进程 SCHED_IDELPRO，低优先级任务 实时进程总能获得 CPU，采用 Round Robin 或者 FIFO 的方法来选择同样优先级的实时进程。他们需要 superuser 的权限，通常限于那些占用 CPU 时间不多却非常在乎 Latency 的进程。</p>
<p>SCHED_ISO 在主流内核中至今仍未实现，Con 早在 2003 年就提出了这个 patch，但一直无法进入主流内核，这种调度策略是为了那些 near-realtime 的进程设计的。如前所述，实时进程需要用户有 superuser 的权限，这类进程能够独占 CPU，因此只有很少的进程可以被配置为实时进程。对于那些对交互性要求比较高的，又无法成为实时进程的进程，BFS 将采用 SCHED_ISO，这些进程能够抢占 SCHED_NORMAL 进程。他们的优先级比 SCHED_NORMAL 高，但又低于实时进程。此外当 SCHED_ISO 进程占用 CPU 时间达到一定限度后，会被降级为 SCHED_NORMAL，防止其独占整个系统资源。</p>
<p>SCHED_NORMAL 类似于主流调度器 CFS 中的 SCHED_OTHER，是基本的分时调度策略。</p>
<p>SCHED_IDELPRO 类似于 CFS 中的 SCHED_IDLE，即只有当 CPU 即将处于 IDLE 状态时才被调度的进程。</p>
<p>在这些不同的调度策略中，实时进程分成 100 个不同的优先级，加上其他三个调度策略，一共有 103 个不</p>
<p>同的进程类型。对于每个进程类型，系统中都有可能有多个进程同时 Ready，比如很可能有两个优先级为 10 的 RT 进程同时 Ready，所以对于每个类型，还需要一个队列来存储属于该类型的 ready 进程。</p>
<p>BFS 用 103 个 bitmap 来表示是否有相应类型的进程准备进行调度。如图所示：</p>
<p>当任何一种类型的进程队列非空时，即存在 Ready 进程时，相应的 bitmap 位被设置为 1。</p>
<p>调度器如何在这样一个 bitmap 加 queue 的复杂结构中选择下一个被调度的进程的问题被称为 Task Selection 或者 pick next。</p>
<p><strong>Task Selection i.e. Pick Next</strong></p>
<p>当调度器决定进行进程调度的时候，BFS 将按照下面的原则来进行任务的选择：</p>
<p>首先查看 bitmap 是否有置位的比特。比如上图，对应于 SCHED_NORMAL 的 bit 被置位，表明有类型为 SCHED_NORMAL 的进程 ready。如果有 SCHED_ISO 或者 RT task 的比特被置位，则优先处理他们。</p>
<p>选定了相应的 bit 位之后，便需要遍历其相应的子队列。假如是一个 RT 进程的子队列，则选取其中的第一个进程。如果是其他的队列，那么就采用 EEVDF 算法来选取合适的进程。</p>
<p>EEVDF，即 earliest eligible virtual deadline first。BFS 将遍历该子队列，一个双向列表，比较队列中的每一个进程的 Virtual Deadline 值，找到最小的那个。最坏情况下，这是一个 O(n) 的算法，即需要遍历整个双向列表，假如其中有 n 个进程，就需要进行 n 此读取和比较。</p>
<p>但实际上，往往不需要遍历整个 n 个进程，这是因为 BFS 还有这样一个搜索条件：</p>
<p>当某个进程的 Virtual Deadline 小于当前的 jiffies 值时，直接返回该进程。并将其从就绪队列中删除，下次再 insert 时会放到队列的尾部，从而保证每个进程都有可能被选中，而不会出现饥饿现象。</p>
<p>这条规则对应于这样一种情况，即进程已经睡眠了比较长的时间，以至于已经睡过了它的 Virtual Deadline，</p>
<h3 id="5-6-BFS调度器初始版本的链表的非O-n-遍历"><a href="#5-6-BFS调度器初始版本的链表的非O-n-遍历" class="headerlink" title="5.6 BFS调度器初始版本的链表的非O(n)遍历"></a><strong>5.6 BFS调度器初始版本的链表的非O(n)遍历</strong></h3><p>BFS调度器的发展历程中也经历了一个为了优化性能而引入“小手段”的时期，该“小手段”是如此合理，以至于每一个细节都值得品味，现表述如下：</p>
<p>大家都知道，遍历一个链表的时间复杂度是O(n)，然而这只是遍历的开销，在BFS调度器中，遍历的目的其实就是pick-next，如果该链表某种意义上是预排序的，那么pick-next的开销可以减少到接近O(1)。BFS如何做到的呢？</p>
<p>我们首先看一下virtual deadline的概念</p>
<p>virtual deadline(VD)</p>
<p>VD&#x3D;jiffies + (prio_ratio * rr_interval)</p>
<ul>
<li>1</li>
<li>2</li>
</ul>
<p>其中prio_ratio为进程优先级，rr_interval为一个Deadline，表示该进程在最多多久内被调度，链表中的每一个entry代表一个进程，都有一个VD与之相关。VD的存在使得entry在链表的位置得以预排序，这里的预排序指的是vitrual deadline expire的影响下的预排序，BFS和O(n)的差别就在于这个expire，由于这个expire在，一般都会在遍历的途中遇到VD expire，进而不需要O(n)。基于VD的O(n)和基于优先级的O(n)是不同的，其区别在于根据上述的计算公式，VD是单调向前的，而优先级几乎是不怎么变化的，因此基于VD的O(n)调度器某种程度上和基于红黑树的CFS是一样的，VD也正类似于CFS中的虚拟时钟，只是数据结构不同而已，BFS用链表实现，CFS用红黑树实现。</p>
<p>其实，O(n)并没有那么可怕，特别是在桌面环境中，你倒是有多少进程需要调度呢？理论上O(n)会随着进程数量的增加而效率降低，然而桌面环境下实际上没有太多的进程需要被调度，所以采用了BFS而抛弃了诸多小手段的调度器效果会更好些。理论上，CFS或者O(1)可以支持SMP下的诸多进程调度的高效性，然而，桌面环境下，第一，SMP也只是2到4个处理器，进程数也大多不超过1000个，进程在CPU之间蹦来蹦去，很累，何必杀鸡用牛刀呢？瓶颈不是鸡，而是杀鸡的刀，是吧！</p>
<p><strong>5.7 pick-next算法</strong></p>
<p>BFS的pick-next算法对于SCHED_ISO进程依照以下的原则进行：</p>
<ul>
<li>依照FIFO原则进行，不再遍历链表</li>
</ul>
<p>BFS的pick-next算法对于SCHED_NORMAL或者SCHED_IDLEPRIO进程依照以下的原则进行：</p>
<ul>
<li>遍历运行链表，比较每一个entry的VD，找出最小的entry，从链表中删除，投入运行</li>
<li>如果发现有entry的VD小于当前的jiffers，则停止遍历，取出该entry，投入运行–小手段</li>
</ul>
<p>以上的原则可以总结为“最小最负最优先”原则。作者一席话如下：</p>
<blockquote>
<p>BFS has 103 priority queues. 100 of these are dedicated to the static priority of realtime tasks, and the remaining 3 are, in order of best to worst priority, SCHED_ISO (isochronous), SCHED_NORMAL, and SCHED_IDLEPRIO (idle priority scheduling). When a task of these priorities is queued, a bitmap of running priorities is set showing which of these priorities has tasks waiting for CPU time. When a CPU is made to reschedule, the lookup for the next task to get CPU time is performed in the following way:<br>First the bitmap is checked to see what static priority tasks are queued. If any realtime priorities are found, the corresponding queue is checked and the first task listed there is taken (provided CPU affinity is suitable) and lookup is complete. If the priority corresponds to a SCHED_ISO task, they are also taken in FIFO order (as they behave like SCHED_RR). If the priority corresponds to either SCHED_NORMAL or SCHED_IDLEPRIO, then the lookup becomes O(n). At this stage, every task in the runlist that corresponds to that priority is checked<br>to see which has the earliest set deadline, and (provided it has suitable CPU affinity) it is taken off the runqueue and given the CPU. If a task has an expired deadline, it is taken and the rest of the lookup aborted (as they are<br>chosen in FIFO order).<br>Thus, the lookup is O(n) in the worst case only, where n is as described earlier, as tasks may be chosen before the whole task list is looked over.</p>
</blockquote>
<p>使用virtual deadline，类似于CFS的virtual runtime的概念，然而不要红黑树，而采用了双向链表来实现，因为红黑树的插入效率不如链表插入效率，在pick-next算法上虽然红黑树占优势，然而由于VD expire的存在也使得pick-next不再是O(n)了</p>
<p>BFS初始版本的小手段的意义在于减少O(n)遍历比较时间复杂度带来的恐惧。</p>
<h3 id="5-8-去除了小手段的BFS调度器"><a href="#5-8-去除了小手段的BFS调度器" class="headerlink" title="5.8 去除了小手段的BFS调度器"></a><strong>5.8 去除了小手段的BFS调度器</strong></h3><p>最终将小手段去除是重要的，否则BFS最终还是会陷入类似O(1)，CFS等复杂化的泥潭里面不可自拔，因此在后续的patch中，BFS去除了上述的小手段，用统一的O(n)复杂度来pick-next，毕竟前面已经说了O(n)在特定环境下并不是问题的关键，该patch在<br>2.6.31.14-bfs318-330test.patch中体现。</p>
<h3 id="5-9-队列外部执行"><a href="#5-9-队列外部执行" class="headerlink" title="5.9 队列外部执行"></a><strong>5.9 队列外部执行</strong></h3><p>BFS调度器和CFS是一样的，都是队列外执行进程的，这样可以减少锁争用带来的性能问题。再列出作者的一席话：</p>
<blockquote>
<p>BFS has one single lock protecting the process local data of every task in the global queue. Thus every insertion, removal and modification of task data in the global runqueue needs to grab the global lock. However, once a task is taken by a CPU, the CPU has its own local data copy of the running process’ accounting information which only that CPU accesses and modifies (such as during a timer tick) thus allowing the accounting data to be updated lockless. Once a CPU has taken a task to run, it removes it from the global queue. Thus the<br>global queue only ever has, at most,<br>(number of tasks requesting cpu time) - (number of logical CPUs) + 1<br>tasks in the global queue. This value is relevant for the time taken to look up tasks during scheduling. This will increase if many tasks with CPU affinity set in their policy to limit which CPUs they’re allowed to run on if they outnumber the number of CPUs. The +1 is because when rescheduling a task, the CPU’s currently running task is put back on the queue. Lookup will be described after the virtual deadline mechanism is explained.</p>
</blockquote>
<p>在schedule核心函数中，使用return_task来把prev进程重新入队，在earliest_deadline_task这个pick-next中，使用take_task将选中的next从队列取出，从而实现队列外执行。</p>
<h3 id="5-10-结论"><a href="#5-10-结论" class="headerlink" title="5.10 结论"></a><strong>5.10 结论</strong></h3><p>从上面的论述，我们丝毫没有看到有任何的诸如“SMP负载均衡”，“CPU亲和力”，“补偿”，“惩罚”之类的字眼，是的，这些字眼在BFS中完全不需要，BFS也正是摒弃了这些字眼才获得成功的，毕竟在一个一般人使用的桌面操作系统中，没有这么多的套套，大多数人使用的就是一个只有一个到两个处理器核心的系统，难道有必要搞什么调度域么？难道有必要搞什么NUMA么？需求决定一切，面对大型服务器，有UNIX的机制站在那里，而如果我们想把Linux推广到每一个掌上设备，那就没必要复制UNIX的那套了，BFS完全可以完美的搞定一切。小手段的去除，说明BFS调度器的发展方向起码是正确的。</p>
<p>BFS对SMP的支持如何呢？答案是它仅仅支持少量CPU的SMP体系，别忘了BFS的应用场合。因为在调度过程中需要一个遍历所有CPU的O(m)复杂度的计算，这就明确告诉人们，别指望BFS使用在拥有4096个CPU的系统上，正如没人用这种系统看视频一样，那样的话，还是乖乖使用CFS吧。</p>
<p>BFS调度器思想很简单：集中精力做好一件事，适应一种场景，代码同样十分简单，因此即使贴上代码整个文章也不会显得过于冗长，你再也看不到诸如load_balance或者for_each_domain之类的东西了，至于CPU cache的亲和力智能判断，如果你非要做，那么就自己调用sched_setaffinity系统调用设置吧，把一个线程或者一组相关的进程设置到一个或者一组共享Cache的CPU上，让内核这些，在进程不那么多，CPU个数不那么多，没有NUMA的系统上，真的太累了。</p>
<hr>
<p>版权声明：本文为知乎博主「玩转Linux内核」的原创文章，遵循CC 4.0 BY-SA版权协议，转载请附上原文出处链接及本声明。<br>原文链接：<a href="https://zhuanlan.zhihu.com/p/472955572">https://zhuanlan.zhihu.com/p/472955572</a></p>
]]></content>
      <categories>
        <category>linux-doc 进程管理</category>
      </categories>
      <tags>
        <tag>Linux</tag>
      </tags>
  </entry>
  <entry>
    <title>Linux内核进程管理之进程ID</title>
    <url>/2023/01/15/linux-docs/%E8%BF%9B%E7%A8%8B%E7%AE%A1%E7%90%86/Linux%E5%86%85%E6%A0%B8%E8%BF%9B%E7%A8%8B%E7%AE%A1%E7%90%86%E4%B9%8B%E8%BF%9B%E7%A8%8BID/</url>
    <content><![CDATA[<p>Linux 内核使用 <code>task_struct</code> 数据结构来关联所有与进程有关的数据和结构，Linux 内核所有涉及到进程和程序的所有算法都是围绕该数据结构建立的，是内核中最重要的数据结构之一。该数据结构在内核文件 <code>include/linux/sched.h</code> 中定义，在Linux 3.8 的内核中，该数据结构足足有 380 行之多，在这里我不可能逐项去描述其表示的含义，本篇文章只关注该数据结构如何来组织和管理进程ID的。</p>
<h2 id="1、进程ID类型"><a href="#1、进程ID类型" class="headerlink" title="1、进程ID类型"></a>1、<strong>进程ID类型</strong></h2><p>要想了解内核如何来组织和管理进程ID，先要知道进程ID的类型：</p>
<ul>
<li><strong>PID</strong>：这是 Linux 中在其命名空间中唯一标识进程而分配给它的一个号码，称做进程ID号，简称PID。在使用 fork 或 clone 系统调用时产生的进程均会由内核分配一个新的唯一的PID值。</li>
<li><strong>TGID</strong>：在一个进程中，如果以CLONE_THREAD标志来调用clone建立的进程就是该进程的一个线程，它们处于一个线程组，该线程组的ID叫做TGID。处于相同的线程组中的所有进程都有相同的TGID；线程组组长的TGID与其PID相同；一个进程没有使用线程，则其TGID与PID也相同。</li>
<li><strong>PGID</strong>：另外，独立的进程可以组成进程组（使用setpgrp系统调用），进程组可以简化向所有组内进程发送信号的操作，例如用管道连接的进程处在同一进程组内。进程组ID叫做PGID，进程组内的所有进程都有相同的PGID，等于该组组长的PID。</li>
<li><strong>SID</strong>：几个进程组可以合并成一个会话组（使用setsid系统调用），可以用于终端程序设计。会话组中所有进程都有相同的SID。</li>
</ul>
<h2 id="2、PID-命名空间"><a href="#2、PID-命名空间" class="headerlink" title="2、PID 命名空间"></a>2、<strong>PID 命名空间</strong></h2><p>命名空间是为操作系统层面的虚拟化机制提供支撑，目前实现的有六种不同的命名空间，分别为mount命名空间、UTS命名空间、IPC命名空间、用户命名空间、PID命名空间、网络命名空间。命名空间简单来说提供的是对全局资源的一种抽象，将资源放到不同的容器中（不同的命名空间），各容器彼此隔离。命名空间有的还有层次关系，如PID命名空间，图1 为命名空间的层次关系图。</p>
<p><img src="https://pic3.zhimg.com/80/v2-9ac007352713d497921ef39e70fcfb02_720w.webp" alt="img"></p>
<p>在上图有四个命名空间，一个父命名空间衍生了两个子命名空间，其中的一个子命名空间又衍生了一个子命名空间。以PID命名空间为例，由于各个命名空间彼此隔离，所以每个命名空间都可以有 PID 号为 1 的进程；但又由于命名空间的层次性，父命名空间是知道子命名空间的存在，因此子命名空间要映射到父命名空间中去，因此上图中 level 1 中两个子命名空间的六个进程分别映射到其父命名空间的PID 号5~10。</p>
<p>命名空间增大了 PID 管理的复杂性，对于某些进程可能有多个PID——在其自身命名空间的PID以及其父命名空间的PID，凡能看到该进程的命名空间都会为其分配一个PID。因此就有：</p>
<ul>
<li><strong>全局ID</strong>：在内核本身和初始命名空间中唯一的ID，在系统启动期间开始的 init 进程即属于该初始命名空间。系统中每个进程都对应了该命名空间的一个PID，叫全局ID，保证在整个系统中唯一。</li>
<li><strong>局部ID</strong>：对于属于某个特定的命名空间，它在其命名空间内分配的ID为局部ID，该ID也可以出现在其他的命名空间中。</li>
</ul>
<h2 id="3、进程ID管理数据结构"><a href="#3、进程ID管理数据结构" class="headerlink" title="3、进程ID管理数据结构"></a>3、<strong>进程ID管理数据结构</strong></h2><p>Linux 内核在设计管理ID的数据结构时，要充分考虑以下因素：</p>
<ol>
<li>如何快速地根据进程的 task_struct、ID类型、命名空间找到局部ID</li>
<li>如何快速地根据局部ID、命名空间、ID类型找到对应进程的 task_struct</li>
<li>如何快速地给新进程在可见的命名空间内分配一个唯一的 PID</li>
</ol>
<p>如果将所有因素考虑到一起，将会很复杂，下面将会由简到繁设计该结构。</p>
<h3 id="3-1一个PID对应一个task-struct"><a href="#3-1一个PID对应一个task-struct" class="headerlink" title="3.1一个PID对应一个task_struct"></a>3.1<strong>一个PID对应一个task_struct</strong></h3><p>如果先不考虑进程之间的关系，不考虑命名空间，仅仅是一个PID号对应一个task_struct，那么我们可以设计这样的数据结构：</p>
<figure class="highlight text"><table><tr><td class="code"><pre><span class="line">struct task_struct &#123;</span><br><span class="line">    //...</span><br><span class="line">    struct pid_link pids;</span><br><span class="line">    //...</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">struct pid_link &#123;</span><br><span class="line">    struct hlist_node node;  </span><br><span class="line">    struct pid *pid;          </span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">struct pid &#123;</span><br><span class="line">    struct hlist_head tasks;        //指回 pid_link 的 node</span><br><span class="line">    int nr;                       //PID</span><br><span class="line">    struct hlist_node pid_chain;    //pid hash 散列表结点</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>每个进程的 task_struct 结构体中有一个指向 pid 结构体的指针，pid 结构体包含了 PID 号。</p>
<ul>
<li><p>pid_hash[]: 这是一个hash表的结构，根据 pid 的 nr 值哈希到其某个表项，若有多个 pid 结构对应到同一个表项，这里解决冲突使用的是散列表法。这样，就能解决开始提出的第2个问题了，根据PID值怎样快速地找到task_struct结构体：</p>
</li>
<li><ul>
<li>首先通过 PID 计算 pid 挂接到哈希表 pid_hash[] 的表项</li>
<li>遍历该表项，找到 pid 结构体中 nr 值与 PID 值相同的那个 pid</li>
<li>再通过该 pid 结构体的 tasks 指针找到 node</li>
<li>最后根据内核的 container_of 机制就能找到 task_struct 结构体</li>
</ul>
</li>
<li><p>pid_map：这是一个位图，用来唯一分配PID值的结构，图中灰色表示已经分配过的值，在新建一个进程时，只需在其中找到一个为分配过的值赋给 pid 结构体的 nr，再将pid_map 中该值设为已分配标志。这也就解决了上面的第3个问题——如何快速地分配一个全局的PID。</p>
</li>
</ul>
<p>至于上面的第1个问题就更加简单，已知 task_struct 结构体，根据其 pid_link 的 pid 指针找到 pid 结构体，取出其 nr 即为 PID 号。</p>
<h3 id="3-2进程ID有类型之分"><a href="#3-2进程ID有类型之分" class="headerlink" title="3.2进程ID有类型之分"></a>3.2<strong>进程ID有类型之分</strong></h3><p>如果考虑进程之间有复杂的关系，如线程组、进程组、会话组，这些组均有组ID，分别为 TGID、PGID、SID，所以原来的 task_struct 中pid_link 指向一个 pid 结构体需要增加几项，用来指向到其组长的 pid 结构体，相应的 struct pid 原本只需要指回其 PID 所属进程的task_struct，现在要增加几项，用来链接那些以该 pid 为组长的所有进程组内进程。数据结构如下：</p>
<figure class="highlight text"><table><tr><td class="code"><pre><span class="line">enum pid_type</span><br><span class="line">&#123;</span><br><span class="line">    PIDTYPE_PID,</span><br><span class="line">    PIDTYPE_PGID,</span><br><span class="line">    PIDTYPE_SID,</span><br><span class="line">    PIDTYPE_MAX</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">struct task_struct &#123;</span><br><span class="line">    //...</span><br><span class="line">    pid_t pid;     //PID</span><br><span class="line">    pid_t tgid;    //thread group id</span><br><span class="line"></span><br><span class="line">    struct task_struct *group_leader;   // threadgroup leader</span><br><span class="line"></span><br><span class="line">    struct pid_link pids[PIDTYPE_MAX];</span><br><span class="line"></span><br><span class="line">    //...</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">struct pid_link &#123;</span><br><span class="line">    struct hlist_node node;  </span><br><span class="line">    struct pid *pid;          </span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">struct pid &#123;</span><br><span class="line">    struct hlist_head tasks[PIDTYPE_MAX];</span><br><span class="line">    int nr;                         //PID</span><br><span class="line">    struct hlist_node pid_chain;    // pid hash 散列表结点</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>上面 ID 的类型 PIDTYPE_MAX 表示 ID 类型数目。之所以不包括线程组ID，是因为内核中已经有指向到线程组的 task_struct 指针 group_leader，线程组 ID 无非就是 group_leader 的PID。</p>
<p>假如现在有三个进程A、B、C为同一个进程组，进程组长为A</p>
<h3 id="3-3增加进程PID命名空间"><a href="#3-3增加进程PID命名空间" class="headerlink" title="3.3增加进程PID命名空间"></a>3.3<strong>增加进程PID命名空间</strong></h3><p>若在第二种情形下再增加PID命名空间，一个进程就可能有多个PID值了，因为在每一个可见的命名空间内都会分配一个PID，这样就需要改变 pid 的结构了，如下：</p>
<figure class="highlight text"><table><tr><td class="code"><pre><span class="line">struct pid</span><br><span class="line">&#123;</span><br><span class="line">    unsigned int level;  </span><br><span class="line">    /* lists of tasks that use this pid */</span><br><span class="line">    struct hlist_head tasks[PIDTYPE_MAX];</span><br><span class="line">    struct upid numbers[1];</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">struct upid &#123;</span><br><span class="line">    int nr;</span><br><span class="line">    struct pid_namespace *ns;</span><br><span class="line">    struct hlist_node pid_chain;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>在 pid 结构体中增加了一个表示该进程所处的命名空间的层次level，以及一个可扩展的 upid 结构体。对于struct upid，表示在该命名空间所分配的进程的ID，ns指向是该ID所属的命名空间，pid_chain 表示在该命名空间的散列表。</p>
<h2 id="4、进程ID管理函数"><a href="#4、进程ID管理函数" class="headerlink" title="4、进程ID管理函数"></a>4、<strong>进程ID管理函数</strong></h2><p>有了上面的复杂的数据结构，再加上散列表等数据结构的操作，就可以写出我们前面所提到的三个问题的函数了：</p>
<h3 id="4-1获得局部ID"><a href="#4-1获得局部ID" class="headerlink" title="4.1获得局部ID"></a>4.1<strong>获得局部ID</strong></h3><p>根据进程的 task_struct、ID类型、命名空间，可以很容易获得其在命名空间内的局部ID：</p>
<ol>
<li>获得与task_struct 关联的pid结构体。辅助函数有 task_pid、task_tgid、task_pgrp和task_session，分别用来获取不同类型的ID的pid 实例，如获取 PID 的实例：<br><strong>static<strong><strong>inline</strong></strong>struct</strong> pid <em><strong>task_pid</strong>(<strong>struct</strong> task_struct *<strong><strong>task) { <strong>return</strong> task</strong>-&gt;*<em>pids[PIDTYPE_PID].pid; }<br>获取线程组的ID，前面也说过，TGID不过是线程组组长的PID而已，所以：<br><strong>static</strong></em>*inline</strong>*</em>struct** pid <em><strong>task_tgid</strong>(<strong>struct</strong> task_struct *<strong><strong>task) { <strong>return</strong> task</strong>-&gt;<strong>group_leader</strong>-&gt;*<em>pids[PIDTYPE_PID].pid; }<br>而获得PGID和SID，首先需要找到该线程组组长的task_struct，再获得其相应的 pid：<br><strong>static</strong></em>*inline</strong>*</em>struct** pid <em><strong>task_pgrp</strong>(<strong>struct</strong> task_struct *<strong><strong>task) { <strong>return</strong> task</strong>-&gt;<strong>group_leader</strong>-&gt;*<em>pids[PIDTYPE_PGID].pid; } <strong>static</strong></em>*inline</strong>*</em>struct** pid *<strong>task_session</strong>(<strong>struct</strong> task_struct ***<strong>task) { <strong>return</strong> task</strong>-&gt;<strong>group_leader</strong>-&gt;**pids[PIDTYPE_SID].pid; }</li>
<li>获得 pid 实例之后，再根据 pid 中的numbers 数组中 uid 信息，获得局部PID。<br><strong>pid_t****pid_nr_ns</strong>(<strong>struct</strong> pid *****pid, <strong>struct</strong> pid_namespace *****ns) { <strong>struct</strong> upid ***<strong>upid; <strong>pid_t</strong> nr <strong>&#x3D;</strong> 0; <strong>if</strong> (pid <strong>&amp;&amp;</strong> ns</strong>-&gt;**level **&lt;&#x3D;** pid**-&gt;*<em>level) { upid <strong>&#x3D;</strong></em>*&amp;<strong>pid</strong>-&gt;<strong>numbers[ns</strong>-&gt;<strong>level]; <strong>if</strong> (upid</strong>-&gt;<strong>ns <strong>&#x3D;&#x3D;</strong> ns) nr <strong>&#x3D;</strong> upid</strong>-&gt;**nr; } <strong>return</strong> nr; }<br>这里值得注意的是，由于PID命名空间的层次性，父命名空间能看到子命名空间的内容，反之则不能，因此，函数中需要确保当前命名空间的level 小于等于产生局部PID的命名空间的level。<br>除了这个函数之外，内核还封装了其他函数用来从 pid 实例获得 PID 值，如 pid_nr、pid_vnr 等。在此不介绍了。</li>
</ol>
<p>结合这两步，内核提供了更进一步的封装，提供以下函数：</p>
<figure class="highlight text"><table><tr><td class="code"><pre><span class="line">pid_t task_pid_nr_ns(struct task_struct *tsk, struct pid_namespace *ns);</span><br><span class="line">pid_t task_tgid_nr_ns(struct task_struct *tsk, struct pid_namespace *ns);</span><br><span class="line">pid_t task_pigd_nr_ns(struct task_struct *tsk, struct pid_namespace *ns);</span><br><span class="line">pid_t task_session_nr_ns(struct task_struct *tsk, struct pid_namespace *ns);</span><br></pre></td></tr></table></figure>

<p>从函数名上就能推断函数的功能，其实不外于封装了上面的两步。</p>
<h3 id="4-2查找进程task-struct"><a href="#4-2查找进程task-struct" class="headerlink" title="4.2查找进程task_struct"></a>4.2<strong>查找进程task_struct</strong></h3><p>根据局部ID、以及命名空间，怎样获得进程的task_struct结构体呢？也是分两步：</p>
<ol>
<li>获得 pid 实体。根据局部PID以及命名空间计算在 pid_hash 数组中的索引，然后遍历散列表找到所要的 upid， 再根据内核的 container_of 机制找到 pid 实例。代码如下：<br><strong>struct</strong> pid *<strong>find_pid_ns</strong>(<strong>int</strong> nr, <strong>struct</strong> pid_namespace *****ns) { <strong>struct</strong> hlist_node ****<em>elem; <strong>struct</strong> upid <em><strong><strong>pnr; <em>&#x2F;&#x2F;遍历散列表</em> hlist_for_each_entry_rcu(pnr, elem, <strong>&amp;<strong>pid_hash[pid_hashfn(nr, ns)], pid_chain) <em>&#x2F;&#x2F;pid_hashfn() 获得hash的索引</em></strong>if</strong> (pnr</strong>-&gt;<strong>nr <strong>&#x3D;&#x3D;</strong> nr <strong>&amp;&amp;</strong> pnr</strong>-&gt;<strong>ns <strong>&#x3D;&#x3D;</strong> ns) <em>&#x2F;&#x2F;比较 nr 与 ns 是否都相同</em></strong>return</strong> container_of(pnr, <strong>struct</strong> pid, <em>&#x2F;&#x2F;根据container_of机制取得pid 实体</em> numbers[ns</em></em>-&gt;**level]); <strong>return</strong> NULL; }</li>
<li>根据ID类型取得task_struct 结构体。<br><strong>struct</strong> task_struct *<strong>pid_task</strong>(<strong>struct</strong> pid *****pid, <strong>enum</strong> pid_type type) { <strong>struct</strong> task_struct *****result <strong>&#x3D;</strong> NULL; <strong>if</strong> (pid) { <strong>struct</strong> hlist_node ***<strong>first; first <strong>&#x3D;</strong> rcu_dereference_check(hlist_first_rcu(</strong>&amp;<strong>pid</strong>-&gt;**tasks[type]), lockdep_tasklist_lock_is_held()); <strong>if</strong> (first) result <strong>&#x3D;</strong> hlist_entry(first, <strong>struct</strong> task_struct, pids[(type)].node); } <strong>return</strong> result; }</li>
</ol>
<p>内核还提供其它函数用来实现上面两步：</p>
<figure class="highlight text"><table><tr><td class="code"><pre><span class="line">struct task_struct *find_task_by_pid_ns(pid_t nr, struct pid_namespace *ns);</span><br><span class="line">struct task_struct *find_task_by_vpid(pid_t vnr);</span><br><span class="line">struct task_struct *find_task_by_pid(pid_t vnr);</span><br></pre></td></tr></table></figure>

<p>具体函数实现的功能也比较简单。</p>
<h3 id="4-3生成唯一的PID"><a href="#4-3生成唯一的PID" class="headerlink" title="4.3生成唯一的PID"></a>4.3<strong>生成唯一的PID</strong></h3><p>内核中使用下面两个函数来实现分配和回收PID的：</p>
<figure class="highlight text"><table><tr><td class="code"><pre><span class="line">static int alloc_pidmap(struct pid_namespace *pid_ns);</span><br><span class="line">static void free_pidmap(struct upid *upid);</span><br></pre></td></tr></table></figure>

<p>在这里我们不关注这两个函数的实现，反而应该关注分配的 PID 如何在多个命名空间中可见，这样需要在每个命名空间生成一个局部ID，函数 alloc_pid 为新建的进程分配PID，简化版如下：</p>
<figure class="highlight text"><table><tr><td class="code"><pre><span class="line">struct pid *alloc_pid(struct pid_namespace *ns)</span><br><span class="line">&#123;</span><br><span class="line">    struct pid *pid;</span><br><span class="line">    enum pid_type type;</span><br><span class="line">    int i, nr;</span><br><span class="line">    struct pid_namespace *tmp;</span><br><span class="line">    struct upid *upid;</span><br><span class="line"></span><br><span class="line">    tmp = ns;</span><br><span class="line">    pid-&gt;level = ns-&gt;level;</span><br><span class="line">    // 初始化 pid-&gt;numbers[] 结构体</span><br><span class="line">    for (i = ns-&gt;level; i &gt;= 0; i--) &#123;</span><br><span class="line">        nr = alloc_pidmap(tmp);            //分配一个局部ID</span><br><span class="line">        pid-&gt;numbers[i].nr = nr;</span><br><span class="line">        pid-&gt;numbers[i].ns = tmp;</span><br><span class="line">        tmp = tmp-&gt;parent;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    // 初始化 pid-&gt;task[] 结构体</span><br><span class="line">    for (type = 0; type &lt; PIDTYPE_MAX; ++type)</span><br><span class="line">        INIT_HLIST_HEAD(&amp;pid-&gt;tasks[type]);</span><br><span class="line"></span><br><span class="line">    // 将每个命名空间经过哈希之后加入到散列表中</span><br><span class="line">    upid = pid-&gt;numbers + ns-&gt;level;</span><br><span class="line">    for ( ; upid &gt;= pid-&gt;numbers; --upid) &#123;</span><br><span class="line">        hlist_add_head_rcu(&amp;upid-&gt;pid_chain,</span><br><span class="line">                &amp;pid_hash[pid_hashfn(upid-&gt;nr, upid-&gt;ns)]);</span><br><span class="line">        upid-&gt;ns-&gt;nr_hashed++;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    return pid;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<hr>
<p>版权声明：本文为知乎博主「<a href="https://www.zhihu.com/people/linuxwang-xian-sheng">极致Linux内核</a>」的原创文章，遵循CC 4.0 BY-SA版权协议，转载请附上原文出处链接及本声明。</p>
<p>原文链接：<a href="https://zhuanlan.zhihu.com/p/546814252">https://zhuanlan.zhihu.com/p/546814252</a></p>
]]></content>
      <categories>
        <category>linux-doc 进程管理</category>
      </categories>
      <tags>
        <tag>Linux</tag>
      </tags>
  </entry>
  <entry>
    <title>Linux内核进程管理几种CPU调度策略</title>
    <url>/2023/01/15/linux-docs/%E8%BF%9B%E7%A8%8B%E7%AE%A1%E7%90%86/Linux%E5%86%85%E6%A0%B8%E8%BF%9B%E7%A8%8B%E7%AE%A1%E7%90%86%E5%87%A0%E7%A7%8DCPU%E8%B0%83%E5%BA%A6%E7%AD%96%E7%95%A5/</url>
    <content><![CDATA[<h2 id="CPU调度"><a href="#CPU调度" class="headerlink" title="CPU调度"></a>CPU调度</h2><p>我们知道，程序需要获得CPU的资源才能被调度和执行，那么当一个进程由于某种原因放弃CPU然后进入阻塞状态，下一个获得CPU资源去被调度执行的进程会是谁呢？下图中，进程1因为阻塞放弃CPU资源，此时，进程2刚IO操作结束，可以获得CPU资源去被调度，进程3的时间片轮转结束，也同样可以获得CPU资源去被调度，那么，此时的操作系统应该安排哪个进程去获得CPU资源呢？这就涉及到我们操作系统的CPU调度策略了。</p>
<p><img src="https://pic3.zhimg.com/80/v2-df827b93d79b11b04e623bf5e249bbe6_720w.webp" alt="img"></p>
<p>根据生活中的例子，我们很容易想到以下两种策略</p>
<h2 id="CPU调度的直观想法"><a href="#CPU调度的直观想法" class="headerlink" title="CPU调度的直观想法"></a>CPU调度的直观想法</h2><p><strong>1.FIFO</strong></p>
<p>谁先进入，先调度谁，这是一种非常简单有效的方法，就好比我们去饭堂打饭，谁先到就给谁先打饭。但是这种策略会遇到一个问题：如果遇到一个很小的任务，但是它是最后进入的，那么必须得前面一大堆任务结束完后才能执行这个小小的任务，这样就感觉很不划算呀！因为我只是简简单单的一个小任务，但是从打开这个任务到结束这个任务要很久。这显然不符合我们的需求，因而我们会想到第2种策略，就是先调度小任务，后调度大任务。</p>
<p><strong>2.Priority</strong></p>
<p>很简单，就是任务短的优先执行，但是此时又有问题了，任务虽然短，但是它的执行时间不一定短，就好比在一个银行业务中，客户填写一个表，这是一个非常短的任务吧——就单单填个表，但是这个表很长很长，那么这个短任务它的执行时间就很长了，我们怎么知道这个短的任务将来会执行多长的时间呢？所以，这样的策略还是依然有问题。</p>
<p><strong>那么，面对诸多的场景，如何设计调度算法呢？</strong></p>
<p>首先，我们要明白我们的算法应该让什么更好呢？<strong>面对客户</strong>：银行调度算法的设计目标应该是<strong>让用户满意</strong>；而<strong>面对进程</strong>：CPU调度的目标应该是<strong>进程满意</strong>。</p>
<p>那怎么才能让进程满意呢？那就是时间了。</p>
<p>进程希望<strong>尽早地结束任务</strong>，这就是<strong>周转时间(从任务到达到任务结束)要短</strong>，而且希望<strong>用户的操作能够尽快地被响应</strong>，这就是<strong>响应时间(从操作发生到响应)要短</strong>。而且<strong>系统内耗时间要少，吞吐量(任务的完成量)要大</strong>，系统需要把更多的时间用在任务的执行上，而不能老是去做无关紧要的事情，例如：频繁切换任务，切换栈，分配资源等事情。同时，系统还要合理地调配任务。</p>
<p><strong>那么，CPU的调度策略如何做到合理呢？</strong></p>
<p><strong>首先得明白系统中有以下的几种矛盾。</strong></p>
<p><strong>1.吞吐量和响应时间之间有矛盾</strong></p>
<p>响应时间小&#x3D;&gt;切换次数多&#x3D;&gt;系统内耗大&#x3D;&gt;吞吐量小</p>
<p>由于需要较短的响应时间，那么就得频繁地切换任务，这样系统的很多时间都花在切换任务上面了，系统的内耗大了，吞吐量就小了。</p>
<p><strong>2.前台任务和后台任务的关注点不同</strong></p>
<p>前台任务关注响应时间，后台任务关注周转时间。</p>
<p>前台任务例如我们的word文档，我们打一个字，需要立马显示在文档中，这就是word文档这个任务关注的是响应时间；而后台任务中，例如我们的javac编译java代码，它的周转时间要小，即该任务从进入到结束所花的时间要小，即编译完成的时间要小。</p>
<p><strong><a href="https://link.zhihu.com/?target=http://3.IO">http://3.IO</a>约束型任务和CPU约束型任务各有各的特点</strong></p>
<p>IO约束型任务就是使用CPU的时间较少，进行IO操作的时间较长，CPU约束型的任务就是使用CPU的时间较长。</p>
<p>因此，要做到合理，需要折中、综合考虑以上的几种矛盾；由此，产生了以下一些CPU的调度算法。</p>
<h2 id="各种CPU调度算法"><a href="#各种CPU调度算法" class="headerlink" title="各种CPU调度算法"></a>各种CPU调度算法</h2><p><strong>1.First Come，First Served(FCFS)</strong></p>
<p>就是先来先服务的调度算法，哪个任务先进来，就为哪个任务先服务。</p>
<p><img src="https://pic3.zhimg.com/80/v2-c17f86b7333dfaafcb0f6e06e380c3da_720w.webp" alt="img"></p>
<p>我们上面说过，周转时间&#x3D;任务结束的时间-任务到达的时间，因此，我们算一算以上四个任务的平均周转时间。进程A到达时间为0时刻，进程B到达时间为1时刻，进程C到达时间为2时刻，进程D到达时间为3时刻，因此，按照FCFS调度算法，我们一词调度A、B、C、D.</p>
<p><img src="https://pic4.zhimg.com/80/v2-6ec4a1806d2db7bf0942d8b2f535dd3b_720w.webp" alt="img"></p>
<p>四个任务的平均周转时间&#x3D;(5-0)+(65-1)+(165-2)+(175-3) &#x2F; 4 &#x3D; 101.</p>
<p>那么，因为一个系统中，可能短任务占的比重较多，那些后来进入的短任务，就得等前面一大堆的任务执行完后，CPU才为这些短任务服务，这样的话，很多短任务即使服务时间短，但是它们的周转时间都比较长。我们可以尝试着把短任务提前，短任务提前了，减少以短任务为主的系统的平均周转时间，由此我们产生了<strong>短作业优先</strong>的CPU调度算法。</p>
<p><strong>2.SJF(Short Job First，短作业优先)</strong></p>
<p>也很简单，就是哪个任务的服务时间短就先调度哪个。还是上面那四个进程。</p>
<p><img src="https://pic4.zhimg.com/80/v2-9c0dadb64472ec2f57d9152ed473ae33_720w.webp" alt="img"></p>
<p>进程A的服务时间为5，进程B的服务时间为60，进程C的服务时间为100，进程D的服务时间为10，因此，按照短作业优先的CPU调度算法，我们依次调度A、D、B、C.</p>
<p><img src="https://pic4.zhimg.com/80/v2-6ddb54fc7a3b24551bed20d1e63686ef_720w.webp" alt="img"></p>
<p>因此，这四个任务的平均周转时间&#x3D;(5-0)+(15-3)+(75-1)+(175-2) &#x2F; 4 &#x3D; 66.</p>
<p>很明显看到，在以短作业为主的系统中，短作业优先的调度算法的平均周转时间比先来先服务的调度算法平均周转时间要低.</p>
<p>现在问题又来了，如果任务C这个任务是急需要响应的，比如是word文档任务，那么它就要快速响应用户的按键输入请求，就是要求其响应时间要小。很明显，上面的SJF调度策略没有考虑到响应时间这个问题，使得任务C仅仅是周转时间短，而下响应时间较长(必须等A、D、B任务结束后才会响应C)。</p>
<p><img src="https://pic1.zhimg.com/80/v2-1f2d24356758eb90be07851e2d81441c_720w.webp" alt="img"></p>
<p>由此，我们想到了按时间轮转的方式去调度。</p>
<p><strong>3.RR算法(按时间片来轮转调度)</strong></p>
<p>还是以上面的那四个进程为例。</p>
<p><img src="https://pic4.zhimg.com/80/v2-9c0dadb64472ec2f57d9152ed473ae33_720w.webp" alt="img"></p>
<p>那按时间片轮转的调度算法是设置一个时间片，比如为10的CPU时间，然后不停地在A、B、C、D四个进程中切换，每个进程执行时间10，时间到了就切换到下一个进程执行时间10，直到全部执行完毕。</p>
<p><img src="https://pic1.zhimg.com/80/v2-69e018255654b4ffeb6156c51f9d8a04_720w.webp" alt="img"></p>
<p>为每个进程分配10的CPU时间，轮转调度执行，这样每个进程的响应时间就变小了。</p>
<p>如果时间片设置过大，那响应的时间就会太长，如果时间片设置过小，那整个系统都在不停地切换进程，系统很多时间都浪费在切换进程上面了，造成系统的吞吐量小，折中考虑后，时间片设置为10<del>100ms，切换的时间为0.1</del>1ms.</p>
<p>说到这里，SJF算法是关注系统的平均周转时间，而RR算法是关注系统的响应时间，但是如果一个系统需要<strong>响应时间小和周转时间小同时存在</strong>，那该怎么办？</p>
<p>比如word很关心响应时间，而javac编译java程序更关心周转时间，两类任务同时存在该怎么办？</p>
<p><strong>前台的任务</strong>更关心响应时间，因为前台任务是与用户直接进行交互的，需要快速响应用户的请求，<strong>后台任务</strong>更关心周转时间，需要快速的结束任务的。</p>
<p>一个很直观的想法，定义前台任务和后台任务两条队列，前台使用RR算法，后台使用SJF算法，只有前台任务没有时才调度后台任务。</p>
<p><img src="https://pic2.zhimg.com/80/v2-e5e15a3f91fe33a536a6ba7428f39e09_720w.webp" alt="img"></p>
<p>但是这样又会产生问题，如果一直有前台任务怎么办，那这样后台任务就永远得不到调度了。在这里有一个有趣的小故事想跟大家讲：1973年有位工作人员去关闭MIT的IBM7094计算机时，发现有一个进程在1967年提交但一直未运行。</p>
<p>这时候我们可以让<strong>后台的任务优先级动态升高</strong>，但后台任务(用SJF调度)一旦执行，那前台任务的响应时间又得变大了。</p>
<p>如果我们<strong>前后台任务都用时间片</strong>，那又退化为了RR算法。</p>
<p>所以，问题还有很多等着我们去发现去想办法解决。</p>
<p>如我们怎么知道哪些是前台任务哪些是后台任务呢，前台任务难道就没有后台任务的工作？后台任务难道没有前台任务的工作？SJF中的短作业优先如何体现？如何判断作业的长度？</p>
<p>等等这些问题到现在都在疯狂地探讨和研究当中，有兴趣向这方面进行深入了解的可以阅读相关文献，或者阅读以下linux的CPU调度算法源码。单单一个CPU的调度算法就要考虑这么多东西了，可以看到，我们的操作系统真的是人类的一项很伟大的发明。</p>
<p><img src="https://pic1.zhimg.com/80/v2-dc106588ddbb32b1d11c323edd1e83f0_720w.webp" alt="img"></p>
<hr>
<p>版权声明：本文为知乎博主「玩转Linux内核」的原创文章，遵循CC 4.0 BY-SA版权协议，转载请附上原文出处链接及本声明。<br>原文链接：<a href="https://zhuanlan.zhihu.com/p/455680633">https://zhuanlan.zhihu.com/p/455680633</a></p>
]]></content>
      <categories>
        <category>linux-doc 进程管理</category>
      </categories>
      <tags>
        <tag>Linux</tag>
      </tags>
  </entry>
  <entry>
    <title>Linux内核进程管理几种进程状态</title>
    <url>/2023/01/15/linux-docs/%E8%BF%9B%E7%A8%8B%E7%AE%A1%E7%90%86/Linux%E5%86%85%E6%A0%B8%E8%BF%9B%E7%A8%8B%E7%AE%A1%E7%90%86%E5%87%A0%E7%A7%8D%E8%BF%9B%E7%A8%8B%E7%8A%B6%E6%80%81/</url>
    <content><![CDATA[<h2 id="进程生命周期"><a href="#进程生命周期" class="headerlink" title="进程生命周期"></a>进程生命周期</h2><p>在Linux内核里，无论是进程还是线程，统一使用 task_struct{} 结构体来表示，也就是统一抽象为任务（task）。task_struct{} 定义在 include&#x2F;linux&#x2F;sched.h 文件中，十分复杂，这里简单了解下。</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">// include/linux/sched.h</span></span><br><span class="line"><span class="comment">// ... 省略</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">task_struct</span> &#123;</span><br><span class="line"><span class="meta">#<span class="keyword">ifdef</span> CONFIG_THREAD_INFO_IN_TASK</span></span><br><span class="line">	<span class="comment">/*</span></span><br><span class="line"><span class="comment">	 * For reasons of header soup (see current_thread_info()), this</span></span><br><span class="line"><span class="comment">	 * must be the first element of task_struct.</span></span><br><span class="line"><span class="comment">	 */</span></span><br><span class="line">	<span class="keyword">struct</span> <span class="title class_">thread_info</span>		thread_info;</span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line">	<span class="comment">/* -1 unrunnable, 0 runnable, &gt;0 stopped: */</span></span><br><span class="line">	<span class="keyword">volatile</span> <span class="type">long</span>			state;</span><br><span class="line">	<span class="type">int</span>				exit_state;</span><br><span class="line">	<span class="type">int</span>				exit_code;</span><br><span class="line">	<span class="type">int</span>				exit_signal;</span><br><span class="line"></span><br><span class="line">	<span class="comment">/*</span></span><br><span class="line"><span class="comment">	 * This begins the randomizable portion of task_struct. Only</span></span><br><span class="line"><span class="comment">	 * scheduling-critical items should be added above here.</span></span><br><span class="line"><span class="comment">	 */</span></span><br><span class="line">	randomized_struct_fields_start</span><br><span class="line"></span><br><span class="line">	<span class="type">void</span>				*stack;</span><br><span class="line">	<span class="type">refcount_t</span>			usage;</span><br><span class="line">	<span class="comment">/* Per task flags (PF_*), defined further below: */</span></span><br><span class="line">	<span class="type">unsigned</span> <span class="type">int</span>			flags;</span><br><span class="line">	<span class="type">unsigned</span> <span class="type">int</span>			ptrace;</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">ifdef</span> CONFIG_SMP</span></span><br><span class="line">	<span class="type">int</span>				on_cpu;</span><br><span class="line">	<span class="keyword">struct</span> <span class="title class_">__call_single_node</span>	wake_entry;</span><br><span class="line"><span class="meta">#<span class="keyword">ifdef</span> CONFIG_THREAD_INFO_IN_TASK</span></span><br><span class="line">	<span class="comment">/* Current CPU: */</span></span><br><span class="line">	<span class="type">unsigned</span> <span class="type">int</span>			cpu;</span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line">	<span class="type">unsigned</span> <span class="type">int</span>			wakee_flips;</span><br><span class="line">	<span class="type">unsigned</span> <span class="type">long</span>			wakee_flip_decay_ts;</span><br><span class="line">	<span class="keyword">struct</span> <span class="title class_">task_struct</span>		*last_wakee;</span><br><span class="line">  <span class="comment">// ...省略</span></span><br><span class="line">  <span class="keyword">struct</span> <span class="title class_">sched_info</span>		sched_info;</span><br><span class="line">	<span class="keyword">struct</span> <span class="title class_">list_head</span>		tasks;   <span class="comment">// 链表，将所有task_struct串起来</span></span><br><span class="line"></span><br><span class="line">	<span class="type">pid_t</span>				pid;    <span class="comment">// process id，指的是线程id</span></span><br><span class="line">	<span class="type">pid_t</span>				tgid;   <span class="comment">// thread group ID，指的是进程的主线程id</span></span><br><span class="line">  <span class="keyword">struct</span> <span class="title class_">task_struct</span>		*group_leader;  <span class="comment">// 指向的是进程的主线程</span></span><br><span class="line"></span><br><span class="line">	<span class="comment">/* Signal handlers: */</span></span><br><span class="line">	<span class="keyword">struct</span> <span class="title class_">signal_struct</span>		*signal;</span><br><span class="line">	<span class="keyword">struct</span> <span class="title class_">sighand_struct</span> __rcu		*sighand;</span><br><span class="line">	<span class="type">sigset_t</span>			blocked;</span><br><span class="line">	<span class="type">sigset_t</span>			real_blocked;</span><br><span class="line">	<span class="comment">/* Restored if set_restore_sigmask() was used: */</span></span><br><span class="line">	<span class="type">sigset_t</span>			saved_sigmask;</span><br><span class="line">	<span class="keyword">struct</span> <span class="title class_">sigpending</span>		pending;</span><br><span class="line">	<span class="type">unsigned</span> <span class="type">long</span>			sas_ss_sp;</span><br><span class="line">	<span class="type">size_t</span>				sas_ss_size;</span><br><span class="line">	<span class="type">unsigned</span> <span class="type">int</span>			sas_ss_flags;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// ... 省略</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>查阅相关资料后，对Linux中进程的生命周期总结如下：</strong></p>
<p><img src="https://pic1.zhimg.com/80/v2-e5a63b6d74aaca755243cda0f15a75fc_720w.webp" alt="img"></p>
<p>从图上可以看出，进程的睡眠状态是最多的，那进程一般在何时进入睡眠状态呢？答案是I&#x2F;O操作时，因为I&#x2F;O操作的速度与CPU运行速度相比，相差太大，所以此时进程会释放CPU，进入睡眠状态。</p>
<p><img src="https://pic1.zhimg.com/80/v2-0fbc601c3e6455cf70b41588ea249f44_720w.webp" alt="img"></p>
<p>进程状态相关的定义同样在 include&#x2F;linux&#x2F;sched.h 文件的开头部分，以 #define TASK_KILLABLE (TASK_WAKEKILL | TASK_UNINTERRUPTIBLE) 为例，TASK_WAKEKILL表示用于在接收到致命信号时唤醒进程，将它与 TASK_UNINTERRUPTIBLE 按位或，就得到了 TASK_KILLABLE。代码注释中提到了 fs&#x2F;proc&#x2F;array.c，所以也将其代码贴出，作为补充。</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">// include/linux/sched.h</span></span><br><span class="line"><span class="comment">// ... 省略</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * Task state bitmask. NOTE! These bits are also</span></span><br><span class="line"><span class="comment"> * encoded in fs/proc/array.c: get_task_state().</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * We have two separate sets of flags: task-&gt;state</span></span><br><span class="line"><span class="comment"> * is about runnability, while task-&gt;exit_state are</span></span><br><span class="line"><span class="comment"> * about the task exiting. Confusing, but this way</span></span><br><span class="line"><span class="comment"> * modifying one set can&#x27;t modify the other one by</span></span><br><span class="line"><span class="comment"> * mistake.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/* Used in tsk-&gt;state: */</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> TASK_RUNNING			0x0000</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> TASK_INTERRUPTIBLE		0x0001</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> TASK_UNINTERRUPTIBLE		0x0002</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> __TASK_STOPPED			0x0004</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> __TASK_TRACED			0x0008</span></span><br><span class="line"><span class="comment">/* Used in tsk-&gt;exit_state: */</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> EXIT_DEAD			0x0010</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> EXIT_ZOMBIE			0x0020</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> EXIT_TRACE			(EXIT_ZOMBIE | EXIT_DEAD)</span></span><br><span class="line"><span class="comment">/* Used in tsk-&gt;state again: */</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> TASK_PARKED			0x0040</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> TASK_DEAD			0x0080</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> TASK_WAKEKILL			0x0100</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> TASK_WAKING			0x0200</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> TASK_NOLOAD			0x0400</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> TASK_NEW			0x0800</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> TASK_STATE_MAX			0x1000</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/* Convenience macros for the sake of set_current_state: */</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> TASK_KILLABLE			(TASK_WAKEKILL | TASK_UNINTERRUPTIBLE)</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> TASK_STOPPED			(TASK_WAKEKILL | __TASK_STOPPED)</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> TASK_TRACED			(TASK_WAKEKILL | __TASK_TRACED)</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> TASK_IDLE			(TASK_UNINTERRUPTIBLE | TASK_NOLOAD)</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/* Convenience macros for the sake of wake_up(): */</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> TASK_NORMAL			(TASK_INTERRUPTIBLE | TASK_UNINTERRUPTIBLE)</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/* get_task_state(): */</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> TASK_REPORT			(TASK_RUNNING | TASK_INTERRUPTIBLE | \</span></span><br><span class="line"><span class="meta">					 TASK_UNINTERRUPTIBLE | __TASK_STOPPED | \</span></span><br><span class="line"><span class="meta">					 __TASK_TRACED | EXIT_DEAD | EXIT_ZOMBIE | \</span></span><br><span class="line"><span class="meta">					 TASK_PARKED)</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> task_is_traced(task)		((task-&gt;state &amp; __TASK_TRACED) != 0)</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> task_is_stopped(task)		((task-&gt;state &amp; __TASK_STOPPED) != 0)</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> task_is_stopped_or_traced(task)	((task-&gt;state &amp; (__TASK_STOPPED | __TASK_TRACED)) != 0)</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// ... 省略</span></span><br><span class="line"><span class="comment">// fs/proc/array.c</span></span><br><span class="line"><span class="comment">// ... 省略</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * The task state array is a strange &quot;bitmap&quot; of</span></span><br><span class="line"><span class="comment"> * reasons to sleep. Thus &quot;running&quot; is zero, and</span></span><br><span class="line"><span class="comment"> * you can test for combinations of others with</span></span><br><span class="line"><span class="comment"> * simple bit tests.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="type">static</span> <span class="type">const</span> <span class="type">char</span> * <span class="type">const</span> task_state_array[] = &#123;</span><br><span class="line"></span><br><span class="line">	<span class="comment">/* states in TASK_REPORT: */</span></span><br><span class="line">	<span class="string">&quot;R (running)&quot;</span>,		<span class="comment">/* 0x00 */</span></span><br><span class="line">	<span class="string">&quot;S (sleeping)&quot;</span>,		<span class="comment">/* 0x01 */</span></span><br><span class="line">	<span class="string">&quot;D (disk sleep)&quot;</span>,	<span class="comment">/* 0x02 */</span></span><br><span class="line">	<span class="string">&quot;T (stopped)&quot;</span>,		<span class="comment">/* 0x04 */</span></span><br><span class="line">	<span class="string">&quot;t (tracing stop)&quot;</span>,	<span class="comment">/* 0x08 */</span></span><br><span class="line">	<span class="string">&quot;X (dead)&quot;</span>,		<span class="comment">/* 0x10 */</span></span><br><span class="line">	<span class="string">&quot;Z (zombie)&quot;</span>,		<span class="comment">/* 0x20 */</span></span><br><span class="line">	<span class="string">&quot;P (parked)&quot;</span>,		<span class="comment">/* 0x40 */</span></span><br><span class="line"></span><br><span class="line">	<span class="comment">/* states beyond TASK_REPORT: */</span></span><br><span class="line">	<span class="string">&quot;I (idle)&quot;</span>,		<span class="comment">/* 0x80 */</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">static</span> <span class="keyword">inline</span> <span class="type">const</span> <span class="type">char</span> *<span class="title">get_task_state</span><span class="params">(<span class="keyword">struct</span> task_struct *tsk)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="built_in">BUILD_BUG_ON</span>(<span class="number">1</span> + <span class="built_in">ilog2</span>(TASK_REPORT_MAX) != <span class="built_in">ARRAY_SIZE</span>(task_state_array));</span><br><span class="line">	<span class="keyword">return</span> task_state_array[<span class="built_in">task_state_index</span>(tsk)];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// ... 省略</span></span><br></pre></td></tr></table></figure>

<p>在单核的CPU上，同一时刻只有一个task会被调度，所以即使看到了 R 状态，也不代表进程就被分配到了CPU时间片。但了解了进程状态之后，我们再通过 top, ps aux 等命令查看进程，<strong>分析问题起来效率就更高了:</strong></p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">top - <span class="number">17</span>:<span class="number">24</span>:<span class="number">07</span> up <span class="number">10</span>:<span class="number">20</span>,  <span class="number">1</span> user,  load average: <span class="number">0.15</span>, <span class="number">0.08</span>, <span class="number">0.02</span></span><br><span class="line">Tasks: <span class="number">216</span> total,   <span class="number">1</span> running, <span class="number">215</span> sleeping,   <span class="number">0</span> stopped,   <span class="number">0</span> zombie</span><br><span class="line">%<span class="built_in">Cpu</span>(s):  <span class="number">0.4</span> us,  <span class="number">0.3</span> sy,  <span class="number">0.0</span> ni, <span class="number">99.2</span> id,  <span class="number">0.0</span> wa,  <span class="number">0.0</span> hi,  <span class="number">0.0</span> si,  <span class="number">0.0</span> st</span><br><span class="line">MiB Mem :   <span class="number">5945.2</span> total,   <span class="number">2655.4</span> free,   <span class="number">1580.8</span> used,   <span class="number">1709.1</span> buff/cache</span><br><span class="line">MiB Swap:   <span class="number">2048.0</span> total,   <span class="number">2048.0</span> free,      <span class="number">0.0</span> used.   <span class="number">4084.6</span> avail Mem </span><br><span class="line"></span><br><span class="line">    PID USER      PR  NI    VIRT    RES    SHR S  %CPU  %MEM     TIME+ COMMAND                                                                            </span><br><span class="line">   <span class="number">1914</span> demonlee  <span class="number">20</span>   <span class="number">0</span> <span class="number">5252100</span> <span class="number">395940</span> <span class="number">132816</span> S   <span class="number">1.0</span>   <span class="number">6.5</span>   <span class="number">1</span>:<span class="number">33.09</span> gnome-shell                                                                        </span><br><span class="line">    <span class="number">824</span> root      <span class="number">20</span>   <span class="number">0</span> <span class="number">2495652</span>  <span class="number">89512</span>  <span class="number">48936</span> S   <span class="number">0.7</span>   <span class="number">1.5</span>   <span class="number">0</span>:<span class="number">05.59</span> dockerd                                                                            </span><br><span class="line">   <span class="number">1687</span> demonlee  <span class="number">20</span>   <span class="number">0</span> <span class="number">1153156</span>  <span class="number">81436</span>  <span class="number">50128</span> S   <span class="number">0.3</span>   <span class="number">1.3</span>   <span class="number">0</span>:<span class="number">15.90</span> Xorg                                                                               </span><br><span class="line">   <span class="number">1957</span> demonlee  <span class="number">20</span>   <span class="number">0</span>  <span class="number">206556</span>  <span class="number">28348</span>  <span class="number">18504</span> S   <span class="number">0.3</span>   <span class="number">0.5</span>   <span class="number">0</span>:<span class="number">00.26</span> ibus-x11                                                                           </span><br><span class="line">   <span class="number">2897</span> demonlee  <span class="number">20</span>   <span class="number">0</span>  <span class="number">874684</span>  <span class="number">61296</span>  <span class="number">44532</span> S   <span class="number">0.3</span>   <span class="number">1.0</span>   <span class="number">0</span>:<span class="number">06.22</span> gnome-terminal-                                                                    </span><br><span class="line">  <span class="number">19984</span> demonlee  <span class="number">20</span>   <span class="number">0</span>   <span class="number">20632</span>   <span class="number">4036</span>   <span class="number">3376</span> R   <span class="number">0.3</span>   <span class="number">0.1</span>   <span class="number">0</span>:<span class="number">00.02</span> top                                                                                </span><br><span class="line">      <span class="number">1</span> root      <span class="number">20</span>   <span class="number">0</span>  <span class="number">169076</span>  <span class="number">12952</span>   <span class="number">8288</span> S   <span class="number">0.0</span>   <span class="number">0.2</span>   <span class="number">0</span>:<span class="number">04.61</span> systemd                                                                            </span><br><span class="line">      <span class="number">2</span> root      <span class="number">20</span>   <span class="number">0</span>       <span class="number">0</span>      <span class="number">0</span>      <span class="number">0</span> S   <span class="number">0.0</span>   <span class="number">0.0</span>   <span class="number">0</span>:<span class="number">00.01</span> kthreadd                                                                           </span><br><span class="line">      <span class="number">3</span> root       <span class="number">0</span> <span class="number">-20</span>       <span class="number">0</span>      <span class="number">0</span>      <span class="number">0</span> I   <span class="number">0.0</span>   <span class="number">0.0</span>   <span class="number">0</span>:<span class="number">00.00</span> rcu_gp                                                                             </span><br><span class="line">      <span class="number">4</span> root       <span class="number">0</span> <span class="number">-20</span>       <span class="number">0</span>      <span class="number">0</span>      <span class="number">0</span> I   <span class="number">0.0</span>   <span class="number">0.0</span>   <span class="number">0</span>:<span class="number">00.00</span> rcu_par_gp                                                                         </span><br><span class="line">      <span class="number">6</span> root       <span class="number">0</span> <span class="number">-20</span>       <span class="number">0</span>      <span class="number">0</span>      <span class="number">0</span> I   <span class="number">0.0</span>   <span class="number">0.0</span>   <span class="number">0</span>:<span class="number">00.00</span> kworker/<span class="number">0</span>:<span class="number">0</span>H-kblockd                                                               </span><br><span class="line">      <span class="number">9</span> root       <span class="number">0</span> <span class="number">-20</span>       <span class="number">0</span>      <span class="number">0</span>      <span class="number">0</span> I   <span class="number">0.0</span>   <span class="number">0.0</span>   <span class="number">0</span>:<span class="number">00.00</span> mm_percpu_wq                                                                       </span><br><span class="line">     <span class="number">10</span> root      <span class="number">20</span>   <span class="number">0</span>       <span class="number">0</span>      <span class="number">0</span>      <span class="number">0</span> S   <span class="number">0.0</span>   <span class="number">0.0</span>   <span class="number">0</span>:<span class="number">00.08</span> ksoftirqd/<span class="number">0</span>                                                                        </span><br><span class="line">     <span class="number">11</span> root      <span class="number">20</span>   <span class="number">0</span>       <span class="number">0</span>      <span class="number">0</span>      <span class="number">0</span> I   <span class="number">0.0</span>   <span class="number">0.0</span>   <span class="number">0</span>:<span class="number">03.60</span> rcu_sched                                                                          </span><br><span class="line">     <span class="number">12</span> root      rt   <span class="number">0</span>       <span class="number">0</span>      <span class="number">0</span>      <span class="number">0</span> S   <span class="number">0.0</span>   <span class="number">0.0</span>   <span class="number">0</span>:<span class="number">00.51</span> migration/<span class="number">0</span>                                                                        </span><br><span class="line">     <span class="number">13</span> root     <span class="number">-51</span>   <span class="number">0</span>       <span class="number">0</span>      <span class="number">0</span>      <span class="number">0</span> S   <span class="number">0.0</span>   <span class="number">0.0</span>   <span class="number">0</span>:<span class="number">00.00</span> idle_inject/<span class="number">0</span>                                                                      </span><br><span class="line">     <span class="number">14</span> root      <span class="number">20</span>   <span class="number">0</span>       <span class="number">0</span>      <span class="number">0</span>      <span class="number">0</span> S   <span class="number">0.0</span>   <span class="number">0.0</span>   <span class="number">0</span>:<span class="number">00.00</span> cpuhp/<span class="number">0</span>                                                                            </span><br><span class="line">     <span class="number">15</span> root      <span class="number">20</span>   <span class="number">0</span>       <span class="number">0</span>      <span class="number">0</span>      <span class="number">0</span> S   <span class="number">0.0</span>   <span class="number">0.0</span>   <span class="number">0</span>:<span class="number">00.00</span> cpuhp/<span class="number">1</span>                                                                            </span><br><span class="line">     <span class="number">16</span> root     <span class="number">-51</span>   <span class="number">0</span>       <span class="number">0</span>      <span class="number">0</span>      <span class="number">0</span> S   <span class="number">0.0</span>   <span class="number">0.0</span>   <span class="number">0</span>:<span class="number">00.00</span> idle_inject/<span class="number">1</span>                                                                      </span><br><span class="line">     <span class="number">17</span> root      rt   <span class="number">0</span>       <span class="number">0</span>      <span class="number">0</span>      <span class="number">0</span> S   <span class="number">0.0</span>   <span class="number">0.0</span>   <span class="number">0</span>:<span class="number">00.89</span> migration/<span class="number">1</span>                                                                        </span><br><span class="line">     <span class="number">18</span> root      <span class="number">20</span>   <span class="number">0</span>       <span class="number">0</span>      <span class="number">0</span>      <span class="number">0</span> S   <span class="number">0.0</span>   <span class="number">0.0</span>   <span class="number">0</span>:<span class="number">00.09</span> ksoftirqd/<span class="number">1</span>                                                                        </span><br><span class="line">     <span class="number">20</span> root       <span class="number">0</span> <span class="number">-20</span>       <span class="number">0</span>      <span class="number">0</span>      <span class="number">0</span> I   <span class="number">0.0</span>   <span class="number">0.0</span>   <span class="number">0</span>:<span class="number">00.00</span> kworker/<span class="number">1</span>:<span class="number">0</span>H                                                                       </span><br><span class="line">     <span class="number">21</span> root      <span class="number">20</span>   <span class="number">0</span>       <span class="number">0</span>      <span class="number">0</span>      <span class="number">0</span> S   <span class="number">0.0</span>   <span class="number">0.0</span>   <span class="number">0</span>:<span class="number">00.00</span> cpuhp/<span class="number">2</span>                                                                            </span><br><span class="line">     <span class="number">22</span> root     <span class="number">-51</span>   <span class="number">0</span>       <span class="number">0</span>      <span class="number">0</span>      <span class="number">0</span> S   <span class="number">0.0</span>   <span class="number">0.0</span>   <span class="number">0</span>:<span class="number">00.00</span> idle_inject/<span class="number">2</span>                                                                      </span><br><span class="line">     <span class="number">23</span> root      rt   <span class="number">0</span>       <span class="number">0</span>      <span class="number">0</span>      <span class="number">0</span> S   <span class="number">0.0</span>   <span class="number">0.0</span>   <span class="number">0</span>:<span class="number">00.83</span> migration/<span class="number">2</span>                                                                        </span><br><span class="line">     <span class="number">24</span> root      <span class="number">20</span>   <span class="number">0</span>       <span class="number">0</span>      <span class="number">0</span>      <span class="number">0</span> S   <span class="number">0.0</span>   <span class="number">0.0</span>   <span class="number">0</span>:<span class="number">00.07</span> ksoftirqd/<span class="number">2</span>                                                                        </span><br><span class="line">     <span class="number">26</span> root       <span class="number">0</span> <span class="number">-20</span>       <span class="number">0</span>      <span class="number">0</span>      <span class="number">0</span> I   <span class="number">0.0</span>   <span class="number">0.0</span>   <span class="number">0</span>:<span class="number">00.00</span> kworker/<span class="number">2</span>:<span class="number">0</span>H-kblockd                                                               </span><br><span class="line">     <span class="number">27</span> root      <span class="number">20</span>   <span class="number">0</span>       <span class="number">0</span>      <span class="number">0</span>      <span class="number">0</span> S   <span class="number">0.0</span>   <span class="number">0.0</span>   <span class="number">0</span>:<span class="number">00.00</span> cpuhp/<span class="number">3</span>                                                                            </span><br><span class="line">     <span class="number">28</span> root     <span class="number">-51</span>   <span class="number">0</span>       <span class="number">0</span>      <span class="number">0</span>      <span class="number">0</span> S   <span class="number">0.0</span>   <span class="number">0.0</span>   <span class="number">0</span>:<span class="number">00.00</span> idle_inject/<span class="number">3</span>                                                                      </span><br><span class="line">     <span class="number">29</span> root      rt   <span class="number">0</span>       <span class="number">0</span>      <span class="number">0</span>      <span class="number">0</span> S   <span class="number">0.0</span>   <span class="number">0.0</span>   <span class="number">0</span>:<span class="number">00.77</span> migration/<span class="number">3</span>                                                                        </span><br><span class="line">     <span class="number">30</span> root      <span class="number">20</span>   <span class="number">0</span>       <span class="number">0</span>      <span class="number">0</span>      <span class="number">0</span> S   <span class="number">0.0</span>   <span class="number">0.0</span>   <span class="number">0</span>:<span class="number">00.18</span> ksoftirqd/<span class="number">3</span>                                                                        </span><br><span class="line">     <span class="number">32</span> root       <span class="number">0</span> <span class="number">-20</span>       <span class="number">0</span>      <span class="number">0</span>      <span class="number">0</span> I   <span class="number">0.0</span>   <span class="number">0.0</span>   <span class="number">0</span>:<span class="number">00.00</span> kworker/<span class="number">3</span>:<span class="number">0</span>H-kblockd                                                               </span><br><span class="line">     <span class="number">33</span> root      <span class="number">20</span>   <span class="number">0</span>       <span class="number">0</span>      <span class="number">0</span>      <span class="number">0</span> S   <span class="number">0.0</span>   <span class="number">0.0</span>   <span class="number">0</span>:<span class="number">00.00</span> kdevtmpfs                                                                          </span><br><span class="line">     <span class="number">34</span> root       <span class="number">0</span> <span class="number">-20</span>       <span class="number">0</span>      <span class="number">0</span>      <span class="number">0</span> I   <span class="number">0.0</span>   <span class="number">0.0</span>   <span class="number">0</span>:<span class="number">00.00</span> netns                                                                              </span><br><span class="line">     <span class="number">35</span> root      <span class="number">20</span>   <span class="number">0</span>       <span class="number">0</span>      <span class="number">0</span>      <span class="number">0</span> S   <span class="number">0.0</span>   <span class="number">0.0</span>   <span class="number">0</span>:<span class="number">00.00</span> rcu_tasks_kthre                                                                    </span><br><span class="line">     <span class="number">36</span> root      <span class="number">20</span>   <span class="number">0</span>       <span class="number">0</span>      <span class="number">0</span>      <span class="number">0</span> S   <span class="number">0.0</span>   <span class="number">0.0</span>   <span class="number">0</span>:<span class="number">00.00</span> rcu_tasks_rude_                                                                    </span><br><span class="line">     <span class="number">37</span> root      <span class="number">20</span>   <span class="number">0</span>       <span class="number">0</span>      <span class="number">0</span>      <span class="number">0</span> S   <span class="number">0.0</span>   <span class="number">0.0</span>   <span class="number">0</span>:<span class="number">00.00</span> rcu_tasks_trace                                                                    </span><br><span class="line">     <span class="number">38</span> root      <span class="number">20</span>   <span class="number">0</span>       <span class="number">0</span>      <span class="number">0</span>      <span class="number">0</span> S   <span class="number">0.0</span>   <span class="number">0.0</span>   <span class="number">0</span>:<span class="number">00.00</span> kauditd                                                                            </span><br><span class="line">     <span class="number">39</span> root      <span class="number">20</span>   <span class="number">0</span>       <span class="number">0</span>      <span class="number">0</span>      <span class="number">0</span> S   <span class="number">0.0</span>   <span class="number">0.0</span>   <span class="number">0</span>:<span class="number">00.03</span> khungtaskd                                                                         </span><br><span class="line">demonlee@demonlee-ubuntu:~$</span><br></pre></td></tr></table></figure>

<p>最后，再补充一个知识点：使用ps命令查看进程时，会发现状态上面有其他符号，比如 S+、Z+ 等，如下所示，</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">demonlee@demonlee-ubuntu:~$ </span><br><span class="line">demonlee    <span class="number">1704</span>  <span class="number">0.0</span>  <span class="number">0.6</span> <span class="number">557904</span> <span class="number">37256</span> ?        Sl   <span class="number">05</span>:<span class="number">01</span>   <span class="number">0</span>:<span class="number">00</span> /usr/libexec/goa-daemon</span><br><span class="line">demonlee    <span class="number">1707</span>  <span class="number">0.0</span>  <span class="number">0.1</span> <span class="number">172652</span>  <span class="number">6936</span> tty2     Ssl+ <span class="number">05</span>:<span class="number">01</span>   <span class="number">0</span>:<span class="number">00</span> /usr/lib/gdm3/gdm-x-session --run-script env GNOME_SHELL_SESSION_MODE=ubuntu /usr/bin/g</span><br><span class="line">demonlee    <span class="number">1714</span>  <span class="number">0.0</span>  <span class="number">0.1</span> <span class="number">323388</span>  <span class="number">9068</span> ?        Sl   <span class="number">05</span>:<span class="number">01</span>   <span class="number">0</span>:<span class="number">00</span> /usr/libexec/goa-identity-service</span><br><span class="line">demonlee    <span class="number">1720</span>  <span class="number">0.1</span>  <span class="number">1.3</span> <span class="number">1151880</span> <span class="number">80576</span> tty2    Sl+  <span class="number">05</span>:<span class="number">01</span>   <span class="number">1</span>:<span class="number">05</span> /usr/lib/xorg/Xorg vt2 -displayfd <span class="number">3</span> -auth /run/user/<span class="number">1000</span>/gdm/Xauthority -background non</span><br><span class="line">demonlee    <span class="number">1723</span>  <span class="number">0.0</span>  <span class="number">0.1</span> <span class="number">325356</span>  <span class="number">9016</span> ?        Ssl  <span class="number">05</span>:<span class="number">01</span>   <span class="number">0</span>:<span class="number">02</span> /usr/libexec/gvfs-afc-volume-monitor</span><br><span class="line">demonlee    <span class="number">1728</span>  <span class="number">0.0</span>  <span class="number">0.1</span> <span class="number">244336</span>  <span class="number">6532</span> ?        Ssl  <span class="number">05</span>:<span class="number">01</span>   <span class="number">0</span>:<span class="number">00</span> /usr/libexec/gvfs-mtp-volume-monitor</span><br><span class="line">demonlee    <span class="number">1759</span>  <span class="number">0.0</span>  <span class="number">0.2</span> <span class="number">197052</span> <span class="number">14276</span> tty2     Sl+  <span class="number">05</span>:<span class="number">01</span>   <span class="number">0</span>:<span class="number">00</span> /usr/libexec/gnome-session-binary --systemd --systemd --session=ubuntu</span><br><span class="line">...</span><br></pre></td></tr></table></figure>

<p>这个 + 是啥意思呢，其实manps中就有描述，只是我们从来都没认真看说明文档：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">PROCESS STATE CODES</span><br><span class="line">       Here are the different values that the s, <span class="function">stat <span class="keyword">and</span> state output <span class="title">specifiers</span> <span class="params">(header <span class="string">&quot;STAT&quot;</span> <span class="keyword">or</span> <span class="string">&quot;S&quot;</span>)</span> will display to describe the state of a</span></span><br><span class="line"><span class="function">       process:</span></span><br><span class="line"><span class="function"></span></span><br><span class="line"><span class="function">               D    uninterruptible sleep (usually IO)</span></span><br><span class="line"><span class="function">               I    Idle kernel thread</span></span><br><span class="line"><span class="function">               R    running or runnable (on run queue)</span></span><br><span class="line"><span class="function">               S    interruptible sleep (waiting for an event to complete)</span></span><br><span class="line"><span class="function">               T    stopped by job control signal</span></span><br><span class="line"><span class="function">               t    stopped by debugger during the tracing</span></span><br><span class="line"><span class="function">               W    paging (not valid since the <span class="number">2.6</span>.xx kernel)</span></span><br><span class="line"><span class="function">               X    dead (should never be seen)</span></span><br><span class="line"><span class="function">               Z    defunct (<span class="string">&quot;zombie&quot;</span>) process, terminated but not reaped by its parent</span></span><br><span class="line"><span class="function"></span></span><br><span class="line"><span class="function">       For BSD formats and when the stat keyword is used, additional characters may be displayed:</span></span><br><span class="line"><span class="function"></span></span><br><span class="line"><span class="function">               &lt;    high-priority (not nice to other users)</span></span><br><span class="line"><span class="function">               N    low-priority (nice to other users)</span></span><br><span class="line"><span class="function">               L    has pages locked into memory (for real-time and custom IO)</span></span><br><span class="line"><span class="function">               s    is a session leader</span></span><br><span class="line"><span class="function">               l    is multi-threaded (using CLONE_THREAD, like NPTL pthreads do)</span></span><br><span class="line"><span class="function">               +    is in the foreground process group</span></span><br></pre></td></tr></table></figure>

<hr>
<p>版权声明：本文为知乎博主「玩转Linux内核」的原创文章，遵循CC 4.0 BY-SA版权协议，转载请附上原文出处链接及本声明。<br>原文链接：<a href="https://zhuanlan.zhihu.com/p/442905446">https://zhuanlan.zhihu.com/p/442905446</a></p>
]]></content>
      <categories>
        <category>linux-doc 进程管理</category>
      </categories>
      <tags>
        <tag>Linux</tag>
      </tags>
  </entry>
  <entry>
    <title>Linux内核进程管理原理详解(代码演示)</title>
    <url>/2023/01/15/linux-docs/%E8%BF%9B%E7%A8%8B%E7%AE%A1%E7%90%86/Linux%E5%86%85%E6%A0%B8%E8%BF%9B%E7%A8%8B%E7%AE%A1%E7%90%86%E5%8E%9F%E7%90%86%E8%AF%A6%E8%A7%A3(%E4%BB%A3%E7%A0%81%E6%BC%94%E7%A4%BA)/</url>
    <content><![CDATA[<blockquote>
<p><strong>前言：</strong>Linux内核里大部分都是C语言。建议先看《Linux内核设计与实现(Linux Kernel Development)》,Robert Love，也就是LKD。</p>
</blockquote>
<p>Linux是一种动态系统，能够适应不断变化的计算需求。Linux计算需求的表现是以进程的通用抽象为中心的。进程可以是短期的（从命令行执行的一个命令），也可以是长期的（一种网络服务）。因此，对进程及其调度进行一般管理就显得极为重要。</p>
<p>在用户空间，进程是由进程标识符（PID）表示的。从用户的角度来看，一个 PID 是一个数字值，可惟一标识一个进程。一个 PID 在进程的整个生命期间不会更改，但 PID 可以在进程销毁后被重新使用，所以对它们进行缓存并不见得总是理想的。在用户空间，创建进程可以采用几种方式。可以 执行一个程序（这会导致新进程的创建），也可以 在程序内，调用一个 fork或 exec 系统调用。fork调用会导致创建一个子进程，而exec调用则会用新程序代替当前进程上下文。这里将对这几种方法进行讨论以便您能很好地理解它们的工作原理。</p>
<p>这里将按照下面的顺序展开对进程的介绍，首先展示进程的内核表示以及它们是如何在内核内被管理的，然后来看看进程创建和调度的各种方式（在一个或多个处理器上），最后介绍进程的销毁。内核的版本为2.6.32.45。</p>
<h2 id="1，进程描述符"><a href="#1，进程描述符" class="headerlink" title="1，进程描述符"></a>1，<strong>进程描述符</strong></h2><p>在Linux内核内，进程是由相当大的一个称为 task_struct 的结构表示的。此结构包含所有表示此进程所必需的数据，此外，还包含了大量的其他数据用来统计（accounting）和维护与其他进程的关系（如父和子）。task_struct 位于 .&#x2F;<a href="https://link.zhihu.com/?target=http://lib.csdn.net/base/linux">linux</a>&#x2F;include&#x2F;<a href="https://link.zhihu.com/?target=https://so.csdn.net/so/search?from=pc_blog_highlight&q=linux">linux</a>&#x2F;sched.h（注意.&#x2F;linux&#x2F;指向内核源代码树）。</p>
<p><strong>下面是task_struct结构：</strong></p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">struct</span> <span class="title class_">task_struct</span> &#123;  </span><br><span class="line">     <span class="keyword">volatile</span> <span class="type">long</span> state;    <span class="comment">/* -1 不可运行, 0 可运行, &gt;0 已停止 */</span>  </span><br><span class="line">     <span class="type">void</span> *stack;            <span class="comment">/* 堆栈 */</span>  </span><br><span class="line">     <span class="type">atomic_t</span> usage;  </span><br><span class="line">     <span class="type">unsigned</span> <span class="type">int</span> flags; <span class="comment">/* 一组标志 */</span>  </span><br><span class="line">     <span class="type">unsigned</span> <span class="type">int</span> ptrace;  </span><br><span class="line">     <span class="comment">/* ...  */</span>  </span><br><span class="line">   </span><br><span class="line">     <span class="type">int</span> prio, static_prio, normal_prio;  <span class="comment">/* 优先级  */</span>  </span><br><span class="line">    <span class="comment">/* ...  */</span>  </span><br><span class="line">  </span><br><span class="line">    <span class="keyword">struct</span> <span class="title class_">list_head</span> tasks;  <span class="comment">/* 执行的线程（可以有很多）  */</span>  </span><br><span class="line">    <span class="keyword">struct</span> <span class="title class_">plist_node</span> pushable_tasks;  </span><br><span class="line">  </span><br><span class="line">    <span class="keyword">struct</span> <span class="title class_">mm_struct</span> *mm, *active_mm;   <span class="comment">/* 内存页（进程地址空间）  */</span>  </span><br><span class="line">  </span><br><span class="line">    <span class="comment">/* 进行状态 */</span>  </span><br><span class="line">    <span class="type">int</span> exit_state;  </span><br><span class="line">    <span class="type">int</span> exit_code, exit_signal;  </span><br><span class="line">    <span class="type">int</span> pdeath_signal;  <span class="comment">/*  当父进程死亡时要发送的信号  */</span>  </span><br></pre></td></tr></table></figure>



<p><span style="font-family: Arial, Helvetica, sans-serif;"><em>&#x2F;* … *&#x2F;</em> </span></p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">    <span class="type">pid_t</span> pid;  <span class="comment">/* 进程号 */</span>  </span><br><span class="line">    <span class="type">pid_t</span> tgid;  </span><br><span class="line"> </span><br><span class="line">    <span class="comment">/* ... */</span>  </span><br><span class="line">    <span class="keyword">struct</span> <span class="title class_">task_struct</span> *real_parent; <span class="comment">/* 实际父进程real parent process */</span>  </span><br><span class="line">    <span class="keyword">struct</span> <span class="title class_">task_struct</span> *parent; <span class="comment">/* SIGCHLD的接受者，由wait4()报告 */</span>  </span><br><span class="line">    <span class="keyword">struct</span> <span class="title class_">list_head</span> children;  <span class="comment">/* 子进程列表 */</span>  </span><br><span class="line">    <span class="keyword">struct</span> <span class="title class_">list_head</span> sibling;   <span class="comment">/* 兄弟进程列表 */</span>  </span><br><span class="line">    <span class="keyword">struct</span> <span class="title class_">task_struct</span> *group_leader;   <span class="comment">/* 线程组的leader */</span>  </span><br><span class="line">    <span class="comment">/* ... */</span>  </span><br><span class="line">  </span><br><span class="line">    <span class="type">char</span> comm[TASK_COMM_LEN]; <span class="comment">/* 可执行程序的名称（不包含路径） */</span>  </span><br><span class="line">    <span class="comment">/* 文件系统信息 */</span>  </span><br><span class="line">    <span class="type">int</span> link_count, total_link_count;  </span><br><span class="line">    <span class="comment">/* ... */</span>  </span><br><span class="line">  </span><br><span class="line">    <span class="comment">/* 特定CPU架构的状态 */</span>  </span><br><span class="line">    <span class="keyword">struct</span> <span class="title class_">thread_struct</span> thread;  </span><br><span class="line">   <span class="comment">/* 进程当前所在的目录描述 */</span>  </span><br><span class="line">     <span class="keyword">struct</span> <span class="title class_">fs_struct</span> *fs;  </span><br><span class="line">    <span class="comment">/* 打开的文件描述信息 */</span>  </span><br><span class="line">    <span class="keyword">struct</span> <span class="title class_">files_struct</span> *files;  </span><br><span class="line">    <span class="comment">/* ... */</span>  </span><br><span class="line">&#125;;  </span><br></pre></td></tr></table></figure>

<p>在task_struct结构中，可以看到几个预料之中的项，比如执行的状态、堆栈、一组标志、父进程、执行的线程（可以有很多）以及开放文件。state 变量是一些表明任务状态的比特位。最常见的状态有：TASK_RUNNING 表示进程正在运行，或是排在运行队列中正要运行；TASK_INTERRUPTIBLE 表示进程正在休眠、TASK_UNINTERRUPTIBLE表示进程正在休眠但不能叫醒；TASK_STOPPED 表示进程停止等等。这些标志的完整列表可以在 .&#x2F;linux&#x2F;include&#x2F;linux&#x2F;sched.h 内找到。</p>
<p>flags 定义了很多指示符，表明进程是否正在被创建（PF_STARTING）或退出（PF_EXITING），或是进程当前是否在分配内存（PF_MEMALLOC）。可执行程序的名称（不包含路径）占用 comm（命令）字段。每个进程都会被赋予优先级（称为 static_prio），但进程的实际优先级是基于加载以及其他几个因素动态决定的。优先级值越低，实际的优先级越高。tasks字段提供了链接列表的能力。它包含一个 prev 指针（指向前一个任务）和一个 next 指针（指向下一个任务）。</p>
<p>进程的地址空间由mm 和 active_mm 字段表示。mm代表的是进程的内存描述符，而 active_mm 则是前一个进程的内存描述符（为改进上下文切换时间的一种优化）。thread_struct thread结构则用来标识进程的存储状态，此元素依赖于Linux在其上运行的特定架构。例如对于x86架构，在.&#x2F;linux&#x2F;arch&#x2F;x86&#x2F;include&#x2F;asm&#x2F;processor.h的thread_struct结构中可以找到该进程自执行上下文切换后的存储（硬件注册表、程序计数器等）。</p>
<p><strong>代码如下：</strong></p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">struct</span> <span class="title class_">thread_struct</span> &#123;</span><br><span class="line">	<span class="comment">/* Cached TLS descriptors: */</span></span><br><span class="line">	<span class="keyword">struct</span> <span class="title class_">desc_struct</span>	tls_array[GDT_ENTRY_TLS_ENTRIES];</span><br><span class="line">	<span class="type">unsigned</span> <span class="type">long</span>		sp0;</span><br><span class="line">	<span class="type">unsigned</span> <span class="type">long</span>		sp;</span><br><span class="line"><span class="meta">#<span class="keyword">ifdef</span> CONFIG_X86_32</span></span><br><span class="line">	<span class="type">unsigned</span> <span class="type">long</span>		sysenter_cs;</span><br><span class="line"><span class="meta">#<span class="keyword">else</span></span></span><br><span class="line">	<span class="type">unsigned</span> <span class="type">long</span>		usersp;	<span class="comment">/* Copy from PDA */</span></span><br><span class="line">	<span class="type">unsigned</span> <span class="type">short</span>		es;</span><br><span class="line">	<span class="type">unsigned</span> <span class="type">short</span>		ds;</span><br><span class="line">	<span class="type">unsigned</span> <span class="type">short</span>		fsindex;</span><br><span class="line">	<span class="type">unsigned</span> <span class="type">short</span>		gsindex;</span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">ifdef</span> CONFIG_X86_32</span></span><br><span class="line">	<span class="type">unsigned</span> <span class="type">long</span>		ip;</span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line">	<span class="comment">/* ... */</span></span><br><span class="line"><span class="meta">#<span class="keyword">ifdef</span> CONFIG_X86_32</span></span><br><span class="line">	<span class="comment">/* Virtual 86 mode info */</span></span><br><span class="line">	<span class="keyword">struct</span> <span class="title class_">vm86_struct</span> __user *vm86_info;</span><br><span class="line">	<span class="type">unsigned</span> <span class="type">long</span>		screen_bitmap;</span><br><span class="line">	<span class="type">unsigned</span> <span class="type">long</span>		v86flags;</span><br><span class="line">	<span class="type">unsigned</span> <span class="type">long</span>		v86mask;</span><br><span class="line">	<span class="type">unsigned</span> <span class="type">long</span>		saved_sp0;</span><br><span class="line">	<span class="type">unsigned</span> <span class="type">int</span>		saved_fs;</span><br><span class="line">	<span class="type">unsigned</span> <span class="type">int</span>		saved_gs;</span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line">	<span class="comment">/* IO permissions: */</span></span><br><span class="line">	<span class="type">unsigned</span> <span class="type">long</span>		*io_bitmap_ptr;</span><br><span class="line">	<span class="type">unsigned</span> <span class="type">long</span>		iopl;</span><br><span class="line">	<span class="comment">/* Max allowed port in the bitmap, in bytes: */</span></span><br><span class="line">	<span class="type">unsigned</span>		io_bitmap_max;</span><br><span class="line"><span class="comment">/* MSR_IA32_DEBUGCTLMSR value to switch in if TIF_DEBUGCTLMSR is set.  */</span></span><br><span class="line">	<span class="type">unsigned</span> <span class="type">long</span>	debugctlmsr;</span><br><span class="line">	<span class="comment">/* Debug Store context; see asm/ds.h */</span></span><br><span class="line">	<span class="keyword">struct</span> <span class="title class_">ds_context</span>	*ds_ctx;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h2 id="2，进程管理"><a href="#2，进程管理" class="headerlink" title="2，进程管理"></a>2，进程管理</h2><p>在很多情况下，进程都是动态创建并由一个动态分配的 task_struct 表示。一个例外是init 进程本身，它总是存在并由一个静态分配的task_struct表示，参看.&#x2F;linux&#x2F;arch&#x2F;x86&#x2F;kernel&#x2F;init_task.c。</p>
<p><strong>代码如下：</strong></p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="type">static</span> <span class="keyword">struct</span> <span class="title class_">signal_struct</span> init_signals = <span class="built_in">INIT_SIGNALS</span>(init_signals);</span><br><span class="line"><span class="type">static</span> <span class="keyword">struct</span> <span class="title class_">sighand_struct</span> init_sighand = <span class="built_in">INIT_SIGHAND</span>(init_sighand);</span><br><span class="line"> </span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * 初始化线程结构</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">union</span> <span class="title class_">thread_union</span> init_thread_union __init_task_data =</span><br><span class="line">	&#123; <span class="built_in">INIT_THREAD_INFO</span>(init_task) &#125;;</span><br><span class="line"> </span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * 初始化init进程的结构。所有其他进程的结构将由fork.c中的slabs来分配</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">task_struct</span> init_task = <span class="built_in">INIT_TASK</span>(init_task);</span><br><span class="line"><span class="built_in">EXPORT_SYMBOL</span>(init_task);</span><br><span class="line"> </span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * per-CPU TSS segments. </span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="built_in">DEFINE_PER_CPU_SHARED_ALIGNED</span>(<span class="keyword">struct</span> tss_struct, init_tss) = INIT_TSS;</span><br></pre></td></tr></table></figure>

<p>注意进程虽然都是动态分配的，但还是需要考虑最大进程数。在内核内最大进程数是由一个称为max_threads的符号表示的，它可以在 .&#x2F;linux&#x2F;kernel&#x2F;fork.c 内找到。可以通过&#x2F;proc&#x2F;sys&#x2F;kernel&#x2F;threads-max 的 proc 文件系统从用户空间更改此值。</p>
<p>Linux 内所有进程的分配有两种方式。第一种方式是通过一个哈希表，由PID 值进行哈希计算得到；第二种方式是通过双链循环表。循环表非常适合于对任务列表进行迭代。由于列表是循环的，没有头或尾；但是由于 init_task 总是存在，所以可以将其用作继续向前迭代的一个锚点。让我们来看一个遍历当前任务集的例子。任务列表无法从用户空间访问，但该问题很容易解决，方法是以模块形式向内核内插入代码。下面给出一个很简单的程序，它会迭代任务列表并会提供有关每个任务的少量信息（name、pid和 parent 名）。注意，在这里，此模块使用 printk 来发出结果。要查看具体的结果，可以通过 cat 实用工具（或实时的 tail -f&#x2F;var&#x2F;log&#x2F;messages）查看 &#x2F;var&#x2F;log&#x2F;messages 文件。next_task函数是 sched.h 内的一个宏，它简化了任务列表的迭代（返回下一个任务的 task_struct 引用）。</p>
<p><strong>如下：</strong></p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">define</span> next_task(p) \</span></span><br><span class="line"><span class="meta">	list_entry_rcu((p)-&gt;tasks.next, struct task_struct, tasks)</span></span><br></pre></td></tr></table></figure>

<p><strong>查询任务列表信息的简单内核模块：</strong></p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">&lt;pre name=<span class="string">&quot;code&quot;</span> <span class="keyword">class</span>=<span class="string">&quot;cpp&quot;</span>&gt;<span class="meta">#<span class="keyword">include</span> <span class="string">&lt;linux/kernel.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;linux/module.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;linux/sched.h&gt;</span></span></span><br><span class="line"> </span><br><span class="line"><span class="type">int</span> <span class="built_in">init_module</span>(<span class="type">void</span>)</span><br><span class="line">&#123;</span><br><span class="line">	<span class="comment">/* Set up the anchor point */</span></span><br><span class="line">	<span class="keyword">struct</span> task_struct *task=&amp;init_task;</span><br><span class="line">	<span class="comment">/* Walk through the task list, until we hit the init_task again */</span></span><br><span class="line">	<span class="keyword">do</span> &#123;</span><br><span class="line">		<span class="built_in">printk</span>(KERN_INFO <span class="string">&quot;=== %s [%d] parent %s\n&quot;</span>,</span><br><span class="line">			task-&gt;comm,task-&gt;pid,task-&gt;parent-&gt;comm);</span><br><span class="line">	&#125; <span class="keyword">while</span>((task=<span class="built_in">next_task</span>(task))!=&amp;init_task);</span><br><span class="line">	</span><br><span class="line">	<span class="built_in">printk</span>(KERN_INFO <span class="string">&quot;Current task is %s [%d]\n&quot;</span>, current-&gt;comm,current-&gt;pid);</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">cleanup_module</span><span class="params">(<span class="type">void</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>编译此模块的Makefile文件如下：</strong></p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">obj-m += procsview.o</span><br><span class="line"> </span><br><span class="line">KDIR := /lib/modules/$(shell uname -r)/build</span><br><span class="line">PWD := $(shell pwd)</span><br><span class="line"> </span><br><span class="line"><span class="keyword">default</span>:</span><br><span class="line">	$(MAKE) -C $(KDIR) SUBDIRS=$(PWD) modules</span><br></pre></td></tr></table></figure>

<p>在编译后，可以用insmod procsview.ko 插入模块对象，也可以用 rmmod procsview 删除它。插入后，&#x2F;var&#x2F;log&#x2F;messages可显示输出，如下所示。从中可以看到，这里有一个空闲任务（称为 swapper）和init 任务（pid 1）。</p>
<blockquote>
<p>Dec 28 23:18:16 ubuntu kernel: [12128.910863]&#x3D;&#x3D;&#x3D; swapper [0] parent swapper<br>Dec 28 23:18:16 ubuntu kernel: [12128.910934]&#x3D;&#x3D;&#x3D; init [1] parent swapper<br>Dec 28 23:18:16 ubuntu kernel: [12128.910945]&#x3D;&#x3D;&#x3D; kthreadd [2] parent swapper<br>Dec 28 23:18:16 ubuntu kernel: [12128.910953]&#x3D;&#x3D;&#x3D; migration&#x2F;0 [3] parent kthreadd<br>……<br>Dec 28 23:24:12 ubuntu kernel: [12485.295015]Current task is insmod [6051]</p>
</blockquote>
<p>Linux 维护一个称为current的宏，标识当前正在运行的进程（类型是 task_struct）。模块尾部的那行prink用于输出当前进程的运行命令及进程号。注意到当前的任务是 insmod，这是因为 init_module 函数是在insmod 命令执行的上下文运行的。current 符号实际指的是一个函数（get_current），可在一个与 arch 有关的头部中找到它。比如 .&#x2F;linux&#x2F;arch&#x2F;x86&#x2F;include&#x2F;asm&#x2F;current.h，<strong>如下：</strong></p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;linux/compiler.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;asm/percpu.h&gt;</span></span></span><br><span class="line"> </span><br><span class="line"><span class="meta">#<span class="keyword">ifndef</span> __ASSEMBLY__</span></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">task_struct</span>;</span><br><span class="line"> </span><br><span class="line"><span class="built_in">DECLARE_PER_CPU</span>(<span class="keyword">struct</span> task_struct *, current_task);</span><br><span class="line"> </span><br><span class="line"><span class="type">static</span> __always_inline <span class="keyword">struct</span> <span class="title class_">task_struct</span> *<span class="built_in">get_current</span>(<span class="type">void</span>)</span><br><span class="line">&#123;</span><br><span class="line">	<span class="keyword">return</span> <span class="built_in">percpu_read_stable</span>(current_task);</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"><span class="meta">#<span class="keyword">define</span> current get_current()</span></span><br><span class="line"> </span><br><span class="line"><span class="meta">#<span class="keyword">endif</span> <span class="comment">/* __ASSEMBLY__ */</span></span></span><br><span class="line"> </span><br><span class="line"><span class="meta">#<span class="keyword">endif</span> <span class="comment">/* _ASM_X86_CURRENT_H */</span></span></span><br></pre></td></tr></table></figure>

<h2 id="3，进程创建"><a href="#3，进程创建" class="headerlink" title="3，进程创建"></a>3，<strong>进程创建</strong></h2><p>用户空间内可以通过执行一个程序、或者在程序内调用fork（或exec）系统调用来创建进程，fork调用会导致创建一个子进程，而exec调用则会用新程序代替当前进程上下文。一个新进程的诞生还可以分别通过vfork()和clone()。fork、vfork和clone三个用户态函数均由libc库提供，它们分别会调用Linux内核提供的同名系统调用fork,vfork和clone。下面以fork系统调用为例来介绍。</p>
<p>传统的创建一个新进程的方式是子进程拷贝父进程所有资源，这无疑使得进程的创建效率低，因为子进程需要拷贝父进程的整个地址空间。更糟糕的是，如果子进程创建后又立马去执行exec族函数，那么刚刚才从父进程那里拷贝的地址空间又要被清除以便装入新的进程映像。为了解决这个问题，<strong>内核中提供了上述三种不同的系统调用。</strong></p>
<ol>
<li>内核采用写时复制技术对传统的fork函数进行了下面的优化。即子进程创建后，父子以只读的方式共享父进程的资源（并不包括父进程的页表项）。当子进程需要修改进程地址空间的某一页时，才为子进程复制该页。采用这样的技术可以避免对父进程中某些数据不必要的复制。</li>
<li>使用vfork函数创建的子进程会完全共享父进程的地址空间，甚至是父进程的页表项。父子进程任意一方对任何数据的修改使得另一方都可以感知到。为了使得双方不受这种影响，vfork函数创建了子进程后，父进程便被阻塞直至子进程调用了exec()或exit()。由于现在fork函数引入了写时复制技术，在不考虑复制父进程页表项的情况下，vfork函数几乎不会被使用。</li>
<li>clone函数创建子进程时灵活度比较大，因为它可以通过传递不同的clone标志参数来选择性的复制父进程的资源。</li>
</ol>
<p>大部分系统调用对应的例程都被命名为 sys_* 并提供某些初始功能以实现调用（例如错误检查或用户空间的行为），实际的工作常常会委派给另外一个名为 do_* 的函数。</p>
<p>在.&#x2F;linux&#x2F;include&#x2F;asm-generic&#x2F;unistd.h中记录了所有的系统调用号及名称。注意fork实现与体系结构相关，对32位的x86系统会使用.&#x2F;linux&#x2F;arch&#x2F;x86&#x2F;include&#x2F;asm&#x2F;unistd_32.h中的定义，fork系统调用编号为2。</p>
<p><strong>fork系统调用在unistd.h中的宏关联如下：</strong></p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">define</span> __NR_fork 1079</span></span><br><span class="line"><span class="meta">#<span class="keyword">ifdef</span> CONFIG_MMU</span></span><br><span class="line">__SYSCALL(__NR_fork, sys_fork)</span><br><span class="line"><span class="meta">#<span class="keyword">else</span></span></span><br><span class="line">__SYSCALL(__NR_fork, sys_ni_syscall)</span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br></pre></td></tr></table></figure>

<p><strong>在unistd_32.h中的调用号关联为：</strong> #define __NR_fork 2</p>
<p>在很多情况下，用户空间任务和内核任务的底层机制是一致的。系统调用fork、vfork和clone在内核中对应的服务例程分别为sys_fork()，sys_vfork()和sys_clone()。它们最终都会依赖于一个名为do_fork 的函数来创建新进程。例如在创建内核线程时，内核会调用一个名为 kernel_thread 的函数（对32位系统）参见.&#x2F;linux&#x2F;arch&#x2F;x86&#x2F;kernel&#x2F;process_32.c，注意process.c是包含32&#x2F;64bit都适用的代码，process_32.c是特定于32位架构，process_64.c是特定于64位架构），此函数执行某些初始化后会调用 do_fork。创建用户空间进程的情况与此类似。在用户空间，一个程序会调用fork，通过int $0x80之类的软中断会导致对名为sys_fork的内核函数的系统调用（参见 .&#x2F;linux&#x2F;arch&#x2F;x86&#x2F;kernel&#x2F;process_32.c），如下：</p>
<figure class="highlight text"><table><tr><td class="code"><pre><span class="line">int sys_fork(struct pt_regs *regs)</span><br><span class="line">&#123;</span><br><span class="line">	return do_fork(SIGCHLD, regs-&gt;sp, regs, 0, NULL, NULL);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>最终都是直接调用do_fork。进程创建的函数层次结构如下图：</strong></p>
<p><img src="https://pic4.zhimg.com/v2-8ab27fddbeee6271cbad74129d3467a3_b.jpg" alt="动图封面"></p>
<p>进程创建的函数层次结构</p>
<p>从图中可以看到 do_fork 是进程创建的基础。可以在 .&#x2F;linux&#x2F;kernel&#x2F;fork.c 内找到 do_fork 函数（以及合作函数 copy_process）。</p>
<p>当用户态的进程调用一个系统调用时，CPU切换到内核态并开始执行一个内核函数。在X86体系中，可以通过两种不同的方式进入系统调用：执行int $0×80汇编命令和执行sysenter汇编命令。后者是Intel在Pentium II中引入的指令，内核从2.6版本开始支持这条命令。这里将集中讨论以int $0×80方式进入系统调用的过程。</p>
<p>通过int $0×80方式调用系统调用实际上是用户进程产生一个中断向量号为0×80的软中断。当用户态fork()调用发生时，用户态进程会保存调用号以及参数，然后发出int $0×80指令，陷入0x80中断。CPU将从用户态切换到内核态并开始执行system_call()。这个函数是通过汇编命令来实现的，它是0×80号软中断对应的中断处理程序。对于所有系统调用来说，它们都必须先进入system_call()，也就是所谓的系统调用处理程序。再通过系统调用号跳转到具体的系统调用服务例程处。32位x86系统的系统调用处理程序在.&#x2F;linux&#x2F;arch&#x2F;x86&#x2F;kernel&#x2F;entry_32.S中，代码如下：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">.macro SAVE_ALL</span><br><span class="line">	cld</span><br><span class="line">	PUSH_GS</span><br><span class="line">	pushl %fs</span><br><span class="line">	CFI_ADJUST_CFA_OFFSET <span class="number">4</span></span><br><span class="line">	<span class="comment">/*CFI_REL_OFFSET fs, 0;*/</span></span><br><span class="line">	pushl %es</span><br><span class="line">	CFI_ADJUST_CFA_OFFSET <span class="number">4</span></span><br><span class="line">	<span class="comment">/*CFI_REL_OFFSET es, 0;*/</span></span><br><span class="line">	pushl %ds</span><br><span class="line">	CFI_ADJUST_CFA_OFFSET <span class="number">4</span></span><br><span class="line">	<span class="comment">/*CFI_REL_OFFSET ds, 0;*/</span></span><br><span class="line">	pushl %eax</span><br><span class="line">	CFI_ADJUST_CFA_OFFSET <span class="number">4</span></span><br><span class="line">	CFI_REL_OFFSET eax, <span class="number">0</span></span><br><span class="line">	pushl %ebp</span><br><span class="line">	CFI_ADJUST_CFA_OFFSET <span class="number">4</span></span><br><span class="line">	CFI_REL_OFFSET ebp, <span class="number">0</span></span><br><span class="line">	pushl %edi</span><br><span class="line">	CFI_ADJUST_CFA_OFFSET <span class="number">4</span></span><br><span class="line">	CFI_REL_OFFSET edi, <span class="number">0</span></span><br><span class="line">	pushl %esi</span><br><span class="line">	CFI_ADJUST_CFA_OFFSET <span class="number">4</span></span><br><span class="line">	CFI_REL_OFFSET esi, <span class="number">0</span></span><br><span class="line">	pushl %edx</span><br><span class="line">	CFI_ADJUST_CFA_OFFSET <span class="number">4</span></span><br><span class="line">	CFI_REL_OFFSET edx, <span class="number">0</span></span><br><span class="line">	pushl %ecx</span><br><span class="line">	CFI_ADJUST_CFA_OFFSET <span class="number">4</span></span><br><span class="line">	CFI_REL_OFFSET ecx, <span class="number">0</span></span><br><span class="line">	pushl %ebx</span><br><span class="line">	CFI_ADJUST_CFA_OFFSET <span class="number">4</span></span><br><span class="line">	CFI_REL_OFFSET ebx, <span class="number">0</span></span><br><span class="line">	movl $(__USER_DS), %edx</span><br><span class="line">	movl %edx, %ds</span><br><span class="line">	movl %edx, %es</span><br><span class="line">	movl $(__KERNEL_PERCPU), %edx</span><br><span class="line">	movl %edx, %fs</span><br><span class="line">	SET_KERNEL_GS %edx</span><br><span class="line">.endm</span><br><span class="line"><span class="comment">/* ... */</span></span><br><span class="line"><span class="built_in">ENTRY</span>(system_call)</span><br><span class="line">	RING0_INT_FRAME			# 无论如何不能进入用户空间</span><br><span class="line">	pushl %eax			# 将保存的系统调用编号压入栈中</span><br><span class="line">	CFI_ADJUST_CFA_OFFSET <span class="number">4</span></span><br><span class="line">	<span class="function">SAVE_ALL</span></span><br><span class="line"><span class="function">	<span class="title">GET_THREAD_INFO</span><span class="params">(%ebp)</span></span></span><br><span class="line"><span class="function">					# 检测进程是否被跟踪</span></span><br><span class="line"><span class="function">	testl $_TIF_WORK_SYSCALL_ENTRY,<span class="title">TI_flags</span><span class="params">(%ebp)</span></span></span><br><span class="line"><span class="function">	jnz syscall_trace_entry</span></span><br><span class="line"><span class="function">	cmpl $<span class="params">(nr_syscalls)</span>, %eax</span></span><br><span class="line"><span class="function">	jae syscall_badsys</span></span><br><span class="line"><span class="function">syscall_call:</span></span><br><span class="line"><span class="function">	call *sys_call_table(,%eax,<span class="number">4</span>)	# 跳入对应服务例程</span></span><br><span class="line"><span class="function">	movl %eax,PT_EAX(%esp)		# 保存进程的返回值</span></span><br><span class="line"><span class="function">syscall_exit:</span></span><br><span class="line"><span class="function">	LOCKDEP_SYS_EXIT</span></span><br><span class="line"><span class="function">	DISABLE_INTERRUPTS(CLBR_ANY)	# 不要忘了在中断返回前关闭中断</span></span><br><span class="line"><span class="function">	TRACE_IRQS_OFF</span></span><br><span class="line"><span class="function">	movl TI_flags(%ebp), %ecx</span></span><br><span class="line"><span class="function">	testl $_TIF_ALLWORK_MASK, %ecx	# current-&gt;work</span></span><br><span class="line"><span class="function">	jne syscall_exit_work</span></span><br><span class="line"><span class="function">restore_all:</span></span><br><span class="line"><span class="function">	TRACE_IRQS_IRET</span></span><br><span class="line"><span class="function">restore_all_notrace:</span></span><br><span class="line"><span class="function">	movl PT_EFLAGS(%esp), %eax	# mix EFLAGS, SS and CS</span></span><br><span class="line"><span class="function">	# Warning: PT_OLDSS(%esp) contains the wrong/random values if we</span></span><br><span class="line"><span class="function">	# are returning to the kernel.</span></span><br><span class="line"><span class="function">	# See comments in process.c:copy_thread() for details.</span></span><br><span class="line"><span class="function">	movb PT_OLDSS(%esp), %ah</span></span><br><span class="line"><span class="function">	movb PT_CS(%esp), %al</span></span><br><span class="line"><span class="function">	andl $(X86_EFLAGS_VM | (SEGMENT_TI_MASK &lt;&lt; <span class="number">8</span>) | SEGMENT_RPL_MASK), %eax</span></span><br><span class="line"><span class="function">	cmpl $((SEGMENT_LDT &lt;&lt; <span class="number">8</span>) | USER_RPL), %eax</span></span><br><span class="line"><span class="function">	CFI_REMEMBER_STATE</span></span><br><span class="line"><span class="function">	je ldt_ss			# returning to user-space with LDT SS</span></span><br><span class="line"><span class="function">restore_nocheck:</span></span><br><span class="line"><span class="function">	RESTORE_REGS <span class="number">4</span>			# skip orig_eax/error_code</span></span><br><span class="line"><span class="function">	CFI_ADJUST_CFA_OFFSET <span class="number">-4</span></span></span><br><span class="line"><span class="function">irq_return:</span></span><br><span class="line"><span class="function">	INTERRUPT_RETURN</span></span><br><span class="line"><span class="function">.section .fixup,<span class="string">&quot;ax&quot;</span></span></span><br></pre></td></tr></table></figure>

<p><strong>分析：</strong></p>
<p>（1）在system_call函数执行之前，CPU控制单元已经将eflags、cs、eip、ss和esp寄存器的值自动保存到该进程对应的内核栈中。随之，在 system_call内部首先将存储在eax寄存器中的系统调用号压入栈中。接着执行SAVE_ALL宏。该宏在栈中保存接下来的系统调用可能要用到的所有CPU寄存器。</p>
<p>（2）通过GET_THREAD_INFO宏获得当前进程的thread_inof结构的地址；再检测当前进程是否被其他进程所跟踪(例如调试一个程序时，被调试的程序就处于被跟踪状态)，也就是thread_info结构中flag字段的_TIF_ALLWORK_MASK被置1。如果发生被跟踪的情况则转向syscall_trace_entry标记的处理命令处。</p>
<p>（3）对用户态进程传递过来的系统调用号的合法性进行检查。如果不合法则跳入到syscall_badsys标记的命令处。</p>
<p>（4）如果系统调用好合法，则根据系统调用号查找.&#x2F;linux&#x2F;arch&#x2F;x86&#x2F;kernel&#x2F;syscall_table_32.S中的系统调用表sys_call_table，找到相应的函数入口点，跳入sys_fork这个服务例程当中。由于 sys_call_table表的表项占4字节，因此获得服务例程指针的具体方法是将由eax保存的系统调用号乘以4再与sys_call_table表的基址相加。</p>
<p><strong>syscall_table_32.S中的代码如下：</strong></p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="built_in">ENTRY</span>(sys_call_table)</span><br><span class="line">	.<span class="type">long</span> sys_restart_syscall	<span class="comment">/* 0 - old &quot;setup()&quot; system call, used for restarting */</span></span><br><span class="line">	.<span class="type">long</span> sys_exit</span><br><span class="line">	.<span class="type">long</span> ptregs_fork</span><br><span class="line">	.<span class="type">long</span> sys_read</span><br><span class="line">	.<span class="type">long</span> sys_write</span><br><span class="line">	.<span class="type">long</span> sys_open		<span class="comment">/* 5 */</span></span><br><span class="line">	.<span class="type">long</span> sys_close</span><br><span class="line">	<span class="comment">/* ... */</span></span><br></pre></td></tr></table></figure>

<p>sys_call_table是系统调用多路分解表，使用 eax 中提供的索引来确定要调用该表中的哪个系统调用。</p>
<p>（5）当系统调用服务例程结束时，从eax寄存器中获得当前进程的的返回值，并把这个返回值存放在曾保存用户态eax寄存器值的那个栈单元的位置上。这样，用户态进程就可以在eax寄存器中找到系统调用的返回码。</p>
<p>经过的调用链为fork()—&gt;int$0×80软中断—&gt;ENTRY(system_call)—&gt;ENTRY(sys_call_table)—&gt;sys_fork()—&gt;do_fork()。实际上fork、vfork和clone三个系统调最终都是调用do_fork()。只不过在调用时所传递的参数有所不同，而参数的不同正好导致了子进程与父进程之间对资源的共享程度不同。因此，分析do_fork()成为我们的首要任务。在进入do_fork函数进行分析之前，很有必要了解一下它的参数。</p>
<p>clone_flags：该标志位的4个字节分为两部分。最低的一个字节为子进程结束时发送给父进程的信号代码，通常为SIGCHLD；剩余的三个字节则是各种clone标志的组合（本文所涉及的标志含义详见下表），也就是若干个标志之间的或运算。通过 clone标志可以有选择的对父进程的资源进行复制。</p>
<p><strong>本文所涉及到的clone标志详见下表：</strong></p>
<p><img src="https://pic2.zhimg.com/v2-3c5e230e7cf07cefad9b856ae3dd2c6d_b.jpg" alt="动图封面"></p>
<ul>
<li><strong>stack_start：</strong>子进程用户态堆栈的地址。</li>
<li><strong>regs：</strong>指向pt_regs结构体的指针。当系统发生系统调用，即用户进程从用户态切换到内核态时，该结构体保存通用寄存器中的值，并被存放于内核态的堆栈中。</li>
<li><strong>stack_size：</strong>未被使用，通常被赋值为0。</li>
<li><strong>parent_tidptr：</strong>父进程在用户态下pid的地址，该参数在CLONE_PARENT_SETTID标志被设定时有意义。</li>
<li><strong>child_tidptr：</strong>子进程在用户态下pid的地址，该参数在CLONE_CHILD_SETTID标志被设定时有意义。</li>
<li>do_fork函数在.&#x2F;linux&#x2F;kernel&#x2F;fork.c中，主要工作就是复制原来的进程成为另一个新的进程，它完成了整个进程创建中的大部分工作。</li>
</ul>
<p><strong>代码如下：</strong></p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">long</span> <span class="title">do_fork</span><span class="params">(<span class="type">unsigned</span> <span class="type">long</span> clone_flags,</span></span></span><br><span class="line"><span class="params"><span class="function">	      <span class="type">unsigned</span> <span class="type">long</span> stack_start,</span></span></span><br><span class="line"><span class="params"><span class="function">	      <span class="keyword">struct</span> pt_regs *regs,</span></span></span><br><span class="line"><span class="params"><span class="function">	      <span class="type">unsigned</span> <span class="type">long</span> stack_size,</span></span></span><br><span class="line"><span class="params"><span class="function">	      <span class="type">int</span> __user *parent_tidptr,</span></span></span><br><span class="line"><span class="params"><span class="function">	      <span class="type">int</span> __user *child_tidptr)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">struct</span> <span class="title class_">task_struct</span> *p;</span><br><span class="line">	<span class="type">int</span> trace = <span class="number">0</span>;</span><br><span class="line">	<span class="type">long</span> nr;</span><br><span class="line"> </span><br><span class="line">	<span class="comment">/*</span></span><br><span class="line"><span class="comment">	 * 做一些预先的参数和权限检查</span></span><br><span class="line"><span class="comment">	 */</span></span><br><span class="line">	<span class="keyword">if</span> (clone_flags &amp; CLONE_NEWUSER) &#123;</span><br><span class="line">		<span class="keyword">if</span> (clone_flags &amp; CLONE_THREAD)</span><br><span class="line">			<span class="keyword">return</span> -EINVAL;</span><br><span class="line">		<span class="comment">/* 希望当用户名称被支持时，这里的检查可去掉</span></span><br><span class="line"><span class="comment">		 */</span></span><br><span class="line">		<span class="keyword">if</span> (!<span class="built_in">capable</span>(CAP_SYS_ADMIN) || !<span class="built_in">capable</span>(CAP_SETUID) ||</span><br><span class="line">				!<span class="built_in">capable</span>(CAP_SETGID))</span><br><span class="line">			<span class="keyword">return</span> -EPERM;</span><br><span class="line">	&#125;</span><br><span class="line"> </span><br><span class="line">	<span class="comment">/*</span></span><br><span class="line"><span class="comment">	 * 希望在2.6.26之后这些标志能实现循环</span></span><br><span class="line"><span class="comment">	 */</span></span><br><span class="line">	<span class="keyword">if</span> (<span class="built_in">unlikely</span>(clone_flags &amp; CLONE_STOPPED)) &#123;</span><br><span class="line">		<span class="type">static</span> <span class="type">int</span> __read_mostly count = <span class="number">100</span>;</span><br><span class="line"> </span><br><span class="line">		<span class="keyword">if</span> (count &gt; <span class="number">0</span> &amp;&amp; <span class="built_in">printk_ratelimit</span>()) &#123;</span><br><span class="line">			<span class="type">char</span> comm[TASK_COMM_LEN];</span><br><span class="line"> </span><br><span class="line">			count--;</span><br><span class="line">			<span class="built_in">printk</span>(KERN_INFO <span class="string">&quot;fork(): process `%s&#x27; used deprecated &quot;</span></span><br><span class="line">					<span class="string">&quot;clone flags 0x%lx\n&quot;</span>,</span><br><span class="line">				<span class="built_in">get_task_comm</span>(comm, current),</span><br><span class="line">				clone_flags &amp; CLONE_STOPPED);</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line"> </span><br><span class="line">	<span class="comment">/*</span></span><br><span class="line"><span class="comment">	 * 当从kernel_thread调用本do_fork时，不使用跟踪</span></span><br><span class="line"><span class="comment">	 */</span></span><br><span class="line">	<span class="keyword">if</span> (<span class="built_in">likely</span>(<span class="built_in">user_mode</span>(regs)))	<span class="comment">/* 如果从用户态进入本调用，则使用跟踪 */</span></span><br><span class="line">		trace = <span class="built_in">tracehook_prepare_clone</span>(clone_flags);</span><br><span class="line"> </span><br><span class="line">	p = <span class="built_in">copy_process</span>(clone_flags, stack_start, regs, stack_size,</span><br><span class="line">			 child_tidptr, <span class="literal">NULL</span>, trace);</span><br><span class="line">	<span class="comment">/*</span></span><br><span class="line"><span class="comment">	 * 在唤醒新线程之前做下面的工作，因为新线程唤醒后本线程指针会变成无效（如果退出很快的话）</span></span><br><span class="line"><span class="comment">	 */</span></span><br><span class="line">	<span class="keyword">if</span> (!<span class="built_in">IS_ERR</span>(p)) &#123;</span><br><span class="line">		<span class="keyword">struct</span> <span class="title class_">completion</span> vfork;</span><br><span class="line"> </span><br><span class="line">		<span class="built_in">trace_sched_process_fork</span>(current, p);</span><br><span class="line"> </span><br><span class="line">		nr = <span class="built_in">task_pid_vnr</span>(p);</span><br><span class="line"> </span><br><span class="line">		<span class="keyword">if</span> (clone_flags &amp; CLONE_PARENT_SETTID)</span><br><span class="line">			<span class="built_in">put_user</span>(nr, parent_tidptr);</span><br><span class="line"> </span><br><span class="line">		<span class="keyword">if</span> (clone_flags &amp; CLONE_VFORK) &#123;</span><br><span class="line">			p-&gt;vfork_done = &amp;vfork;</span><br><span class="line">			<span class="built_in">init_completion</span>(&amp;vfork);</span><br><span class="line">		&#125;</span><br><span class="line"> </span><br><span class="line">		<span class="built_in">audit_finish_fork</span>(p);</span><br><span class="line">		<span class="built_in">tracehook_report_clone</span>(regs, clone_flags, nr, p);</span><br><span class="line"> </span><br><span class="line">		<span class="comment">/*</span></span><br><span class="line"><span class="comment">		 * 我们在创建时设置PF_STARTING，以防止跟踪进程想使用这个标志来区分一个完全活着的进程</span></span><br><span class="line"><span class="comment">		 * 和一个还没有获得trackhook_report_clone()的进程。现在我们清除它并且设置子进程运行</span></span><br><span class="line"><span class="comment">		 */</span></span><br><span class="line">		p-&gt;flags &amp;= ~PF_STARTING;</span><br><span class="line"> </span><br><span class="line">		<span class="keyword">if</span> (<span class="built_in">unlikely</span>(clone_flags &amp; CLONE_STOPPED)) &#123;</span><br><span class="line">			<span class="comment">/*</span></span><br><span class="line"><span class="comment">			 * 我们将立刻启动一个即时的SIGSTOP</span></span><br><span class="line"><span class="comment">			 */</span></span><br><span class="line">			<span class="built_in">sigaddset</span>(&amp;p-&gt;pending.signal, SIGSTOP);</span><br><span class="line">			<span class="built_in">set_tsk_thread_flag</span>(p, TIF_SIGPENDING);</span><br><span class="line">			__set_task_state(p, TASK_STOPPED);</span><br><span class="line">		&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">			<span class="built_in">wake_up_new_task</span>(p, clone_flags);</span><br><span class="line">		&#125;</span><br><span class="line"> </span><br><span class="line">		<span class="built_in">tracehook_report_clone_complete</span>(trace, regs,</span><br><span class="line">						clone_flags, nr, p);</span><br><span class="line"> </span><br><span class="line">		<span class="keyword">if</span> (clone_flags &amp; CLONE_VFORK) &#123;</span><br><span class="line">			<span class="built_in">freezer_do_not_count</span>();</span><br><span class="line">			<span class="built_in">wait_for_completion</span>(&amp;vfork);</span><br><span class="line">			<span class="built_in">freezer_count</span>();</span><br><span class="line">			<span class="built_in">tracehook_report_vfork_done</span>(p, nr);</span><br><span class="line">		&#125;</span><br><span class="line">	&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">		nr = <span class="built_in">PTR_ERR</span>(p);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> nr;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>（1）在一开始，该函数定义了一个task_struct类型的指针p，用来接收即将为新进程（子进程）所分配的进程描述符。trace表示跟踪状态，nr表示新进程的pid。接着做一些预先的参数和权限检查。</p>
<p>（2）接下来检查clone_flags是否设置了CLONE_STOPPED标志。如果设置了，则做相应处理，打印消息说明进程已过时。通常这样的情况很少发生，因此在判断时使用了unlikely修饰符。使用该修饰符的判断语句执行结果与普通判断语句相同，只不过在执行效率上有所不同。正如该单词的含义所表示的那样，当前进程很少为停止状态。因此，编译器尽量不会把if内的语句与当前语句之前的代码编译在一起，以增加cache的命中率。与此相反，likely修饰符则表示所修饰的代码很可能发生。tracehook_prepare_clone用于设置子进程是否被跟踪。所谓跟踪，最常见的例子就是处于调试状态下的进程被debugger进程所跟踪。进程的ptrace字段非0说明debugger程序正在跟踪它。如果调用是从用户态进来的（而不从kernel_thread进来的），且当前进程（父进程）被另外一个进程所跟踪，那么子进程也要设置为被跟踪，并且将跟踪标志CLONE_PTRACE加入标志变量clone_flags中。如果父进程不被跟踪，则子进程也不会被跟踪，设置好后返回trace。</p>
<p>（3）接下来的这条语句要做的是整个创建过程中最核心的工作：通过copy_process()创建子进程的描述符，分配pid，并创建子进程执行时所需的其他数据结构，最终则会返回这个创建好的进程描述符p。该函数中的参数意义与do_fork函数相同。注意原来内核中为子进程分配pid的工作是在do_fork中完成，现在新的内核已经移到copy_process中了。</p>
<p>（4）如果copy_process函数执行成功，那么将继续执行if(!IS_ERR(p))部分。首先定义了一个完成量vfork，用task_pid_vnr(p)从p中获取新进程的pid。如果clone_flags包含CLONE_VFORK标志，那么将进程描述符中的vfork_done字段指向这个完成量，之后再对vfork完成量进行初始化。完成量的作用是，直到任务A发出信号通知任务B发生了某个特定事件时，任务B才会开始执行，否则任务B一直等待。我们知道，如果使用vfork系统调用来创建子进程，那么必然是子进程先执行。究其原因就是此处vfork完成量所起到的作用。当子进程调用exec函数或退出时就向父进程发出信号，此时父进程才会被唤醒，否则一直等待。此处的代码只是对完成量进行初始化，具体的阻塞语句则在后面的代码中有所体现。</p>
<p>（5）如果子进程被跟踪或者设置了CLONE_STOPPED标志，那么通过sigaddset函数为子进程增加挂起信号，并将子进程的状态设置为TASK_STOPPED。signal对应一个unsignedlong类型的变量，该变量的每个位分别对应一种信号。具体的操作是将SIGSTOP信号所对应的那一位置1。如果子进程并未设置CLONE_STOPPED标志，那么通过wake_up_new_task将进程放到运行队列上，从而让调度器进行调度运行。wake_up_new_task()在.&#x2F;linux&#x2F;kernel&#x2F;sched.c中，用于唤醒第一次新创建的进程，它将为新进程做一些初始的必须的调度器统计操作，然后把进程放到运行队列中。一旦当然正在运行的进程时间片用完（通过时钟tick中断来控制），就会调用schedule()，从而进行进程调度。</p>
<p><strong>代码如下：</strong></p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">wake_up_new_task</span><span class="params">(<span class="keyword">struct</span> task_struct *p, <span class="type">unsigned</span> <span class="type">long</span> clone_flags)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="type">unsigned</span> <span class="type">long</span> flags;</span><br><span class="line">	<span class="keyword">struct</span> <span class="title class_">rq</span> *rq;</span><br><span class="line">	<span class="type">int</span> cpu = <span class="built_in">get_cpu</span>();</span><br><span class="line"> </span><br><span class="line"><span class="meta">#<span class="keyword">ifdef</span> CONFIG_SMP</span></span><br><span class="line">	rq = <span class="built_in">task_rq_lock</span>(p, &amp;flags);</span><br><span class="line">	p-&gt;state = TASK_WAKING;</span><br><span class="line"> </span><br><span class="line">	<span class="comment">/*</span></span><br><span class="line"><span class="comment">	 * Fork balancing, do it here and not earlier because:</span></span><br><span class="line"><span class="comment">	 *  - cpus_allowed can change in the fork path</span></span><br><span class="line"><span class="comment">	 *  - any previously selected cpu might disappear through hotplug</span></span><br><span class="line"><span class="comment">	 *</span></span><br><span class="line"><span class="comment">	 * We set TASK_WAKING so that select_task_rq() can drop rq-&gt;lock</span></span><br><span class="line"><span class="comment">	 * without people poking at -&gt;cpus_allowed.</span></span><br><span class="line"><span class="comment">	 */</span></span><br><span class="line">	cpu = <span class="built_in">select_task_rq</span>(rq, p, SD_BALANCE_FORK, <span class="number">0</span>);</span><br><span class="line">	<span class="built_in">set_task_cpu</span>(p, cpu);</span><br><span class="line"> </span><br><span class="line">	p-&gt;state = TASK_RUNNING;</span><br><span class="line">	<span class="built_in">task_rq_unlock</span>(rq, &amp;flags);</span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line"> </span><br><span class="line">	rq = <span class="built_in">task_rq_lock</span>(p, &amp;flags);</span><br><span class="line">	<span class="built_in">update_rq_clock</span>(rq);</span><br><span class="line">	<span class="built_in">activate_task</span>(rq, p, <span class="number">0</span>);</span><br><span class="line">	<span class="built_in">trace_sched_wakeup_new</span>(rq, p, <span class="number">1</span>);</span><br><span class="line">	<span class="built_in">check_preempt_curr</span>(rq, p, WF_FORK);</span><br><span class="line"><span class="meta">#<span class="keyword">ifdef</span> CONFIG_SMP</span></span><br><span class="line">	<span class="keyword">if</span> (p-&gt;sched_class-&gt;task_woken)</span><br><span class="line">		p-&gt;sched_class-&gt;<span class="built_in">task_woken</span>(rq, p);</span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line">	<span class="built_in">task_rq_unlock</span>(rq, &amp;flags);</span><br><span class="line">	<span class="built_in">put_cpu</span>();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这里先用get_cpu()获取CPU，如果是对称多处理系统（SMP），先设置我为TASK_WAKING状态，由于有多个CPU（每个CPU上都有一个运行队列），需要进行负载均衡，选择一个最佳CPU并设置我使用这个CPU，然后设置我为TASK_RUNNING状态。这段操作是互斥的，因此需要加锁。注意TASK_RUNNING并不表示进程一定正在运行，无论进程是否正在占用CPU，只要具备运行条件，都处于该状态。 Linux把处于该状态的所有PCB组织成一个可运行队列run_queue，调度程序从这个队列中选择进程运行。事实上，Linux是将就绪态和运行态合并为了一种状态。然后用.&#x2F;linux&#x2F;kernel&#x2F;sched.c:activate_task()把当前进程插入到对应CPU的runqueue上，最终完成入队的函数是active_task()—&gt;enqueue_task()，其中核心代码行为：p-&gt;sched_class-&gt;enqueue_task(rq, p,wakeup, head);sched_class在.&#x2F;linux&#x2F;include&#x2F;linux&#x2F;sched.h中，是调度器一系列操作的面向对象抽象，这个类包括进程入队、出队、进程运行、进程切换等接口，用于完成对进程的调度运行。</p>
<p>（6）tracehook_report_clone_complete函数用于在进程复制快要完成时报告跟踪情况。如果父进程被跟踪，则将子进程的pid赋值给父进程的进程描述符的pstrace_message字段，并向父进程的父进程发送SIGCHLD信号。</p>
<p>（7）如果CLONE_VFORK标志被设置，则通过wait操作将父进程阻塞，直至子进程调用exec函数或者退出。</p>
<p>（8）如果copy_process()在执行的时候发生错误，则先释放已分配的pid，再根据PTR_ERR()的返回值得到错误代码，保存于nr中。</p>
<hr>
<p>版权声明：本文为知乎博主「玩转Linux内核」的原创文章，遵循CC 4.0 BY-SA版权协议，转载请附上原文出处链接及本声明。<br>原文链接：<a href="https://zhuanlan.zhihu.com/p/425886322">https://zhuanlan.zhihu.com/p/425886322</a></p>
]]></content>
      <categories>
        <category>linux-doc 进程管理</category>
      </categories>
      <tags>
        <tag>Linux</tag>
      </tags>
  </entry>
  <entry>
    <title>Linux内核进程管理并发同步与原子操作</title>
    <url>/2023/01/15/linux-docs/%E8%BF%9B%E7%A8%8B%E7%AE%A1%E7%90%86/Linux%E5%86%85%E6%A0%B8%E8%BF%9B%E7%A8%8B%E7%AE%A1%E7%90%86%E5%B9%B6%E5%8F%91%E5%90%8C%E6%AD%A5%E4%B8%8E%E5%8E%9F%E5%AD%90%E6%93%8D%E4%BD%9C/</url>
    <content><![CDATA[<h2 id="并发同步"><a href="#并发同步" class="headerlink" title="并发同步"></a>并发同步</h2><p>并发 是指在某一时间段内能够处理多个任务的能力，而 并行 是指同一时间能够处理多个任务的能力。并发和并行看起来很像，但实际上是有区别的，如下图（图片来源于网络）：</p>
<p><img src="https://pic1.zhimg.com/80/v2-3055dc26275b76efe6b40dc3a9f2853c_720w.webp" alt="img"></p>
<p>上图的意思是，有两条在排队买咖啡的队列，并且只有一架咖啡机在处理，而并行就有两架的咖啡机在处理。咖啡机的数量越多，并行能力就越强。可以把上面的两条队列看成两个进程，并发就是指只有单个CPU在处理，而并行就有两个CPU在处理。为了让两个进程在单核CPU中也能得到执行，一般的做法就是让每个进程交替执行一段时间，比如让每个进程固定执行100毫秒 ，执行时间使用完后切换到其他进程执行。而并行就没有这种问题，因为有两个CPU，所以两个进程可以同时执行。<strong>如下图：</strong></p>
<p><img src="https://pic3.zhimg.com/80/v2-32f1e9f4e3cb505781ac5e8ebf272d62_720w.webp" alt="img"></p>
<p><img src="https://pic1.zhimg.com/80/v2-80bb91a6d72321793e9d1ed802d34394_720w.webp" alt="img"></p>
<p>上面介绍过，并发有可能会打断当前执行的进程，然后替切换成其他进程执行。如果有两个进程同时对一个共享变量 count 进行加一操作，由于C语言的 count++ 操作会被翻译成如下指令：</p>
<figure class="highlight text"><table><tr><td class="code"><pre><span class="line">mov eax, [count]</span><br><span class="line">inc eax</span><br><span class="line">mov [count], eax</span><br></pre></td></tr></table></figure>

<p><strong>那么在并发的情况下，有可能出现如下问题：</strong></p>
<p><img src="https://pic1.zhimg.com/80/v2-9a608fdcac2aa432b0cf4817c87b0ee4_720w.webp" alt="img"></p>
<p><strong>假设count变量初始值为0：</strong></p>
<ul>
<li>进程1执行完 mov eax, [count] 后，寄存器eax内保存了count的值0。</li>
<li>进程2被调度执行。进程2执行 count++ 的所有指令，将累加后的count值1写回到内存。</li>
<li>进程1再次被调度执行，计算count的累加值仍为1，写回到内存。</li>
</ul>
<p>虽然进程1和进程2执行了两次 count++ 操作，但是count最后的值为1，而不是2。要解决这个问题就需要使用 原子操作 ，原子操作是指不能被打断的操作，在单核CPU中，一条指令就是原子操作。比如上面的问题可以把 count++ 语句翻译成指令 inc [count] 即可。Linux也提供了这样的原子操作，<strong>如对整数加一操作的 atomic_inc() ：</strong></p>
<figure class="highlight text"><table><tr><td class="code"><pre><span class="line">static __inline__ void atomic_inc(atomic_t *v)</span><br><span class="line">&#123;</span><br><span class="line">__asm__ __volatile__(</span><br><span class="line">LOCK &quot;incl %0&quot;</span><br><span class="line">:&quot;=m&quot; (v-&gt;counter)</span><br><span class="line">:&quot;m&quot; (v-&gt;counter));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>在多核CPU中，一条指令也不一定是原子操作，比如 inc [count] 指令在多核CPU中需要进行如下过程：</p>
<ul>
<li>\1. 从内存将count的数据读取到cpu。</li>
<li>\2. 累加读取的值。</li>
<li>\3. 将修改的值写回count内存。</li>
</ul>
<p><strong>Intel x86 CPU 提供了 lock 前缀来锁住总线，可以让指令保证不被其他CPU中断，如下：</strong></p>
<figure class="highlight text"><table><tr><td class="code"><pre><span class="line">lock</span><br><span class="line">inc [count]</span><br></pre></td></tr></table></figure>

<h2 id="锁"><a href="#锁" class="headerlink" title="锁"></a>锁</h2><p>原子操作 能够保证操作不被其他人干扰，但有时候一个复杂的操作需要由多条指令来实现，那么就不能使用原子操作了，这时候可以使用 锁 来实现。计算机科学中的 锁 与日常生活的 锁 有点类似，举个例子：比如要上公厕，首先找到一个没有人的厕所，然后把厕所门锁上。其他人要使用的话，必须等待当前这人使用完毕，并且把门锁打开才能使用。在计算机中，要对某个公共资源进行操作时，必须对公共资源进行上锁，然后才能使用。如果不上锁，那么就可能导致数据混乱的情况发生。</p>
<p>在Linux内核中，比较常用的锁有： 自旋锁 、 信号量 、 读写锁 等，下面介绍一下自旋锁和信号量的实现。</p>
<h2 id="自旋锁"><a href="#自旋锁" class="headerlink" title="自旋锁"></a>自旋锁</h2><p>自旋锁 只能在多核CPU系统中，其核心原理是 原子操作 ，原理如下图：</p>
<p><img src="https://pic1.zhimg.com/80/v2-719889aa0cae515dfe7ece639955efa8_720w.webp" alt="img"></p>
<p><strong>使用自旋锁时，必须先对自旋锁进行初始化（设置为1），上锁过程如下：</strong></p>
<ul>
<li>\1. 对自旋锁 lock 进行减一操作，判断结果是否等于0，如果是表示上锁成功并返回。</li>
<li>\2. 如果不等于0，表示其他进程已经上锁，此时必须不断比较自旋锁 lock 的值是否等于1（表示已经解锁）。</li>
<li>\3. 如果自旋锁 lock 等于1，跳转到第一步继续进行上锁操作。</li>
</ul>
<p><strong>由于Linux的自旋锁使用汇编实现，所以比较苦涩难懂，这里使用C语言来模拟一下：</strong></p>
<figure class="highlight text"><table><tr><td class="code"><pre><span class="line">void spin_lock(amtoic_t *lock)</span><br><span class="line">&#123;</span><br><span class="line">again:</span><br><span class="line">result = --(*lock);</span><br><span class="line">if (result == 0) &#123;</span><br><span class="line">return;</span><br><span class="line">&#125;</span><br><span class="line">while (true) &#123;</span><br><span class="line">if (*lock == 1) &#123;</span><br><span class="line">goto again;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>上面代码将 result &#x3D; –(*lock); 当成原子操作，解锁过程只需要把 lock 设置为1即可。由于自旋锁会不断尝试上锁操作，并不会对进程进行调度，所以在单核CPU中可能会导致 100% 的CPU占用率。另外，自选锁只适合粒度比较小的操作，如果操作粒度比较大，就需要使用信号量这种可调度进程的锁。</p>
<h2 id="信号量"><a href="#信号量" class="headerlink" title="信号量"></a>信号量</h2><p>与 自旋锁 不一样，当前进程对 信号量 进行上锁时，如果其他进程已经对其进行上锁，那么当前进程会进入睡眠状态，等待其他人对信号量进行解锁。过程如下图：</p>
<p><img src="https://pic3.zhimg.com/80/v2-fb3105e3dcc6df896debc2619721c93e_720w.webp" alt="img"></p>
<p><strong>在Linux内核中，信号量使用 struct semaphore 表示，定义如下：</strong></p>
<figure class="highlight text"><table><tr><td class="code"><pre><span class="line">struct semaphore &#123;</span><br><span class="line">raw_spinlock_t lock;</span><br><span class="line">unsigned int count;</span><br><span class="line">struct list_head wait_list;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p><strong>各个字段的作用如下：</strong></p>
<ol>
<li>lock ：自旋锁，用于对多核CPU平台进行同步。</li>
<li>count ：信号量的计数器，上锁时对其进行减一操作(count–)，如果得到的结果为大于等于0，表示成功上锁，如果小于0表示已经被其他进程上锁。</li>
<li>wait_list ：正在等待信号量解锁的进程队列。</li>
</ol>
<p><strong>信号量 上锁通过 down() 函数实现，代码如下：</strong></p>
<figure class="highlight text"><table><tr><td class="code"><pre><span class="line">void down(struct semaphore *sem)</span><br><span class="line">&#123;</span><br><span class="line">unsigned long flags;</span><br><span class="line">spin_lock_irqsave(&amp;sem-&gt;lock, flags);</span><br><span class="line">if (likely(sem-&gt;count &gt; 0))</span><br><span class="line">sem-&gt;count--;</span><br><span class="line">else</span><br><span class="line">__down(sem);</span><br><span class="line">spin_unlock_irqrestore(&amp;sem-&gt;lock, flags);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>上面代码可以看出， down() 函数首先对信号量进行自旋锁操作（为了避免多核CPU竞争），然后比较计数器是否大于0，如果是对计数器进行减一操作，并且返回，否则调用 __down() 函数进行下一步操作。</p>
<p><strong>__down() 函数实现如下：</strong></p>
<figure class="highlight text"><table><tr><td class="code"><pre><span class="line">static noinline void __sched __down(struct semaphore *sem)</span><br><span class="line">&#123;</span><br><span class="line">__down_common(sem, TASK_UNINTERRUPTIBLE, MAX_SCHEDULE_TIMEOUT);</span><br><span class="line">&#125;</span><br><span class="line">static inline int __down_common(struct semaphore *sem,</span><br><span class="line">long state, long timeout)</span><br><span class="line">&#123;</span><br><span class="line">struct task_struct *task = current;</span><br><span class="line">struct semaphore_waiter waiter;</span><br><span class="line">// 把当前进程添加到等待队列中</span><br><span class="line">list_add_tail(&amp;waiter.list, &amp;sem-&gt;wait_list);</span><br><span class="line">waiter.task = task;</span><br><span class="line">waiter.up = 0;</span><br><span class="line">for (;;) &#123;</span><br><span class="line">...</span><br><span class="line">__set_task_state(task, state);</span><br><span class="line">spin_unlock_irq(&amp;sem-&gt;lock);</span><br><span class="line">timeout = schedule_timeout(timeout);</span><br><span class="line">spin_lock_irq(&amp;sem-&gt;lock);</span><br><span class="line">if (waiter.up) // 当前进程是否获得信号量锁?</span><br><span class="line">return 0;</span><br><span class="line">&#125;</span><br><span class="line">...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>__down() 函数最终调用 __down_common() 函数，而 __down_common() 函数的操作过程如下：</strong></p>
<ul>
<li>把当前进程添加到信号量的等待队列中。</li>
<li>切换到其他进程运行，直到被其他进程唤醒。</li>
<li>如果当前进程获得信号量锁（由解锁进程传递），那么函数返回。</li>
</ul>
<p><strong>接下来看看解锁过程，解锁过程主要通过 up() 函数实现，代码如下：</strong></p>
<figure class="highlight text"><table><tr><td class="code"><pre><span class="line">void up(struct semaphore *sem)</span><br><span class="line">&#123;</span><br><span class="line">unsigned long flags;</span><br><span class="line">raw_spin_lock_irqsave(&amp;sem-&gt;lock, flags);</span><br><span class="line">if (likely(list_empty(&amp;sem-&gt;wait_list))) // 如果没有等待的进程, 直接对计数器加一操作</span><br><span class="line">sem-&gt;count++;</span><br><span class="line">else</span><br><span class="line">__up(sem); // 如果有等待进程, 那么调用 __up() 函数进行唤醒</span><br><span class="line">raw_spin_unlock_irqrestore(&amp;sem-&gt;lock, flags);</span><br><span class="line">&#125;</span><br><span class="line">static noinline void __sched __up(struct semaphore *sem)</span><br><span class="line">&#123;</span><br><span class="line">// 获取到等待队列的第一个进程</span><br><span class="line">struct semaphore_waiter *waiter = list_first_entry(</span><br><span class="line">&amp;sem-&gt;wait_list, struct semaphore_waiter, list);</span><br><span class="line">list_del(&amp;waiter-&gt;list); // 把进程从等待队列中删除</span><br><span class="line">waiter-&gt;up = 1; // 告诉进程已经获得信号量锁</span><br><span class="line">wake_up_process(waiter-&gt;task); // 唤醒进程</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>解锁过程如下：</strong></p>
<ul>
<li>判断当前信号量是否有等待的进程，如果没有等待的进程, 直接对计数器加以操作</li>
<li>如果有等待的进程，那么获取到等待队列的第一个进程。</li>
<li>把进程从等待队列中删除。</li>
<li>告诉进程已经获得信号量锁</li>
<li>唤醒进程</li>
</ul>
<hr>
<p>版权声明：本文为知乎博主「玩转Linux内核」的原创文章，遵循CC 4.0 BY-SA版权协议，转载请附上原文出处链接及本声明。<br>原文链接：<a href="https://zhuanlan.zhihu.com/p/441558619">https://zhuanlan.zhihu.com/p/441558619</a></p>
]]></content>
      <categories>
        <category>linux-doc 进程管理</category>
      </categories>
      <tags>
        <tag>Linux</tag>
      </tags>
  </entry>
  <entry>
    <title>Linux内核进程管理进程优先级</title>
    <url>/2023/01/15/linux-docs/%E8%BF%9B%E7%A8%8B%E7%AE%A1%E7%90%86/Linux%E5%86%85%E6%A0%B8%E8%BF%9B%E7%A8%8B%E7%AE%A1%E7%90%86%E8%BF%9B%E7%A8%8B%E4%BC%98%E5%85%88%E7%BA%A7/</url>
    <content><![CDATA[<blockquote>
<p><strong>前言：</strong>进程优先级实际上是系统对进程重要性的一个客观评价。根据这个评价的结果来为进程分配不同的系统资源，这个资源包括内存资源和CPU资源。为了保证“公平公正”的评价每个进程，Google工程师为此设计了一套评价系统。</p>
</blockquote>
<p><img src="https://pic3.zhimg.com/80/v2-ed56495e2c5f289842576ffebae899e2_720w.webp" alt="img"></p>
<h2 id="为什么要有进程优先级？"><a href="#为什么要有进程优先级？" class="headerlink" title="为什么要有进程优先级？"></a>为什么要有进程优先级？</h2><p>这似乎不用过多的解释，毕竟自从多任务操作系统诞生以来，进程执行占用cpu的能力就是一个必须要可以人为控制的事情。因为有的进程相对重要，而有的进程则没那么重要。进程优先级起作用的方式从发明以来基本没有什么变化，无论是只有一个cpu的时代，还是多核cpu时代，都是通过控制进程占用cpu时间的长短来实现的。就是说在同一个调度周期中，优先级高的进程占用的时间长些，而优先级低的进程占用的短些。从这个角度看，进程优先级其实也跟cgroup的cpu限制一样，都是一种针对cpu占用的QOS机制。我曾经一直很困惑一点，为什么已经有了优先级，还要再设计一个针对cpu的cgroup？得到的答案大概是因为，优先级这个值不能很直观的反馈出资源分配的比例吧？不过这不重要，实际上从内核目前的进程调度器cfs的角度说，同时实现cpushare方式的cgroup和优先级这两个机制完全是相同的概念，并不会因为增加一个机制而提高什么实现成本。既然如此，而cgroup又显得那么酷，那么何乐而不为呢？</p>
<h2 id="NICE值"><a href="#NICE值" class="headerlink" title="NICE值"></a>NICE值</h2><p>nice值应该是熟悉Linux&#x2F;UNIX的人很了解的概念了，我们都知它是一个反映一个进程“优先级”状态的值，其取值范围是-20至19，一共40个级别。这个值越小，表示进程”优先级”越高，而值越大“优先级”越低。我们可以通过nice命令来对一个将要执行的命令进行nice值设置，方法是：</p>
<figure class="highlight text"><table><tr><td class="code"><pre><span class="line">[root@zorrozou-pc0 zorro]# nice -n 10 bash</span><br></pre></td></tr></table></figure>

<p>这样我就又打开了一个bash，并且其nice值设置为10，而默认情况下，进程的优先级应该是从父进程继承来的，这个值一般是0。我们可以通过nice命令直接查看到当前shell的nice值</p>
<figure class="highlight text"><table><tr><td class="code"><pre><span class="line">[root@zorrozou-pc0 zorro]# nice</span><br></pre></td></tr></table></figure>

<p><strong>对比一下正常情况：</strong></p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">[root@zorrozou-pc0 zorro]<span class="meta"># exit</span></span><br></pre></td></tr></table></figure>

<p><strong>退出当前nice值为10的bash，打开一个正常的bash：</strong></p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">[root@zorrozou-pc0 zorro]<span class="meta"># bash</span></span><br><span class="line">[root@zorrozou-pc0 zorro]<span class="meta"># nice</span></span><br></pre></td></tr></table></figure>

<p>另外，使用renice命令可以对一个正在运行的进程进行nice值的调整，我们也可以使用比如top、ps等命令查看进程的nice值，具体方法我就不多说了，大家可以参阅相关manpage。</p>
<p>需要大家注意的是，我在这里都在使用nice值这一称谓，而非优先级（priority）这个说法。当然，nice和renice的man手册中，也说的是priority这个概念，但是要强调一下，请大家真的不要混淆了系统中的这两个概念，一个是nice值，一个是priority值，他们有着千丝万缕的关系，但对于当前的Linux系统来说，它们并不是同一个概念。</p>
<p><strong>我们看这个命令：</strong></p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">[root@zorrozou-pc0 zorro]<span class="meta"># ps -l</span></span><br><span class="line">F S   UID   PID  PPID  C PRI  NI ADDR SZ WCHAN  TTY          TIME CMD</span><br><span class="line"><span class="number">4</span> S     <span class="number">0</span>  <span class="number">6924</span>  <span class="number">5776</span>  <span class="number">0</span>  <span class="number">80</span>   <span class="number">0</span> - <span class="number">17952</span> poll_s pts/<span class="number">5</span>    <span class="number">00</span>:<span class="number">00</span>:<span class="number">00</span> sudo</span><br><span class="line"><span class="number">4</span> S     <span class="number">0</span>  <span class="number">6925</span>  <span class="number">6924</span>  <span class="number">0</span>  <span class="number">80</span>   <span class="number">0</span> -  <span class="number">4435</span> wait   pts/<span class="number">5</span>    <span class="number">00</span>:<span class="number">00</span>:<span class="number">00</span> bash</span><br><span class="line"><span class="number">0</span> R     <span class="number">0</span> <span class="number">12971</span>  <span class="number">6925</span>  <span class="number">0</span>  <span class="number">80</span>   <span class="number">0</span> -  <span class="number">8514</span> -      pts/<span class="number">5</span>    <span class="number">00</span>:<span class="number">00</span>:<span class="number">00</span> ps</span><br></pre></td></tr></table></figure>

<p><strong>大家是否真的明白其中PRI列和NI列的具体含义有什么区别？同样的，如果是top命令：</strong></p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">Tasks: <span class="number">1587</span> total,   <span class="number">7</span> running, <span class="number">1570</span> sleeping,   <span class="number">0</span> stopped,  <span class="number">10</span> <span class="function">zombie</span></span><br><span class="line"><span class="function"><span class="title">Cpu</span><span class="params">(s)</span>: <span class="number">13.0</span>%us,  <span class="number">6.9</span>%sy,  <span class="number">0.0</span>%ni, <span class="number">78.6</span>%id,  <span class="number">0.0</span>%wa,  <span class="number">0.0</span>%hi,  <span class="number">1.5</span>%si,  <span class="number">0.0</span>%st</span></span><br><span class="line"><span class="function">Mem:  <span class="number">132256952</span>k total, <span class="number">107483920</span>k used, <span class="number">24773032</span>k free,  <span class="number">2264772</span>k buffers</span></span><br><span class="line"><span class="function">Swap:  <span class="number">2101192</span>k total,      <span class="number">508</span>k used,  <span class="number">2100684</span>k free, <span class="number">88594404</span>k cached</span></span><br><span class="line"><span class="function"></span></span><br><span class="line"><span class="function">  PID USER      PR  NI  VIRT  RES  SHR S %CPU %MEM    TIME+  COMMAND                                                                                                                                                                                                                                                                          </span></span><br><span class="line"><span class="function"> <span class="number">3001</span> root      <span class="number">20</span>   <span class="number">0</span>  <span class="number">232</span>m  <span class="number">21</span>m <span class="number">4500</span> S <span class="number">12.9</span>  <span class="number">0.0</span>   <span class="number">0</span>:<span class="number">15.09</span> python                                                                                                                                                                                                                                                                                </span></span><br><span class="line"><span class="function"><span class="number">11541</span> root      <span class="number">20</span>   <span class="number">0</span> <span class="number">17456</span> <span class="number">2400</span>  <span class="number">888</span> R  <span class="number">7.4</span>  <span class="number">0.0</span>   <span class="number">0</span>:<span class="number">00.06</span> top    </span></span><br></pre></td></tr></table></figure>

<p>大家是否搞清楚了这其中PR值和NI值的差别？如果没有，那么我们可以首先搞清楚什么是nice值。</p>
<p>nice值虽然不是priority，但是它确实可以影响进程的优先级。在英语中，如果我们形容一个人nice，那一般说明这个人的人缘比较好。什么样的人人缘好？往往是谦让、有礼貌的人。比如，你跟一个nice的人一起去吃午饭，点了两个一样的饭，先上了一份后，nice的那位一般都会说：“你先吃你先吃！”，这就是人缘好，这人nice！但是如果另一份上的很晚，那么这位nice的人就要饿着了。这说明什么？越nice的人抢占资源的能力就越差，而越不nice的人抢占能力就越强。这就是nice值大小的含义，nice值越低，说明进程越不nice，抢占cpu的能力就越强，优先级就越高。在原来使用O1调度的Linux上，我们还会把nice值叫做静态优先级，这也基本符合nice值的特点，就是当nice值设定好了之后，除非我们用renice去改它，否则它是不变的。而priority的值在之前内核的O1调度器上表现是会变化的，所以也叫做动态优先级。</p>
<h2 id="优先级和实时进程"><a href="#优先级和实时进程" class="headerlink" title="优先级和实时进程"></a>优先级和实时进程</h2><p>简单了解nice值的概念之后，我们再来看看什么是priority值，就是ps命令中看到的PRI值或者top命令中看到的PR值。本文为了区分这些概念，以后统一用nice值表示NI值，或者叫做静态优先级，也就是用nice和renice命令来调整的优先级；而实用priority值表示PRI和PR值，或者叫动态优先级。我们也统一将“优先级”这个词的概念规定为表示priority值的意思。</p>
<p>在内核中，进程优先级的取值范围是通过一个宏定义的，这个宏的名称是MAX_PRIO，它的值为140。而这个值又是由另外两个值相加组成的，一个是代表nice值取值范围的NICE_WIDTH宏，另一个是代表实时进程（realtime）优先级范围的MAX_RT_PRIO宏。说白了就是，Linux实际上实现了140个优先级范围，取值范围是从0-139，这个值越小，优先级越高。nice值的-20到19，映射到实际的优先级范围是100-139。新产生进程的默认优先级被定义为：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">define</span> DEFAULT_PRIO            (MAX_RT_PRIO + NICE_WIDTH / 2)</span></span><br></pre></td></tr></table></figure>

<p>实际上对应的就是nice值的0。正常情况下，任何一个进程的优先级都是这个值，即使我们通过nice和renice命令调整了进程的优先级，它的取值范围也不会超出100-139的范围，除非这个进程是一个实时进程，那么它的优先级取值才会变成0-99这个范围中的一个。这里隐含了一个信息，就是说当前的Linux是一种已经支持实时进程的操作系统。</p>
<p>什么是实时操作系统，我们就不再这里详细解释其含义以及在工业领域的应用了，有兴趣的可以参考一下实时操作系统的维基百科。简单来说，实时操作系统需要保证相关的实时进程在较短的时间内响应，不会有较长的延时，并且要求最小的中断延时和进程切换延时。对于这样的需求，一般的进程调度算法，无论是O1还是CFS都是无法满足的，所以内核在设计的时候，将实时进程单独映射了100个优先级，这些优先级都要高与正常进程的优先级（nice值），而实时进程的调度算法也不同，它们采用更简单的调度算法来减少调度开销。</p>
<p><strong>总的来说，Linux系统中运行的进程可以分成两类：</strong></p>
<ol>
<li><strong>实时进程</strong></li>
<li><strong>非实时进程</strong></li>
</ol>
<p>它们的主要区别就是通过优先级来区分的。所有优先级值在0-99范围内的，都是实时进程，所以这个优先级范围也可以叫做实时进程优先级，而100-139范围内的是非实时进程。在系统中可以使用chrt命令来查看、设置一个进程的实时优先级状态。</p>
<p><strong>我们可以先来看一下chrt命令的使用：</strong></p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">[root@zorrozou-pc0 zorro]<span class="meta"># chrt</span></span><br><span class="line">Show <span class="keyword">or</span> change the real-time scheduling attributes of a process.</span><br><span class="line"></span><br><span class="line">Set policy:</span><br><span class="line"> chrt [options] &lt;priority&gt; &lt;command&gt; [&lt;arg&gt;...]</span><br><span class="line"> chrt [options] -p &lt;priority&gt; &lt;pid&gt;</span><br><span class="line"></span><br><span class="line">Get policy:</span><br><span class="line"> chrt [options] -p &lt;pid&gt;</span><br><span class="line"></span><br><span class="line">Policy options:</span><br><span class="line"> -b, --batch          set policy to SCHED_OTHER</span><br><span class="line"> -f, --fifo           set policy to SCHED_FIFO</span><br><span class="line"> -i, --idle           set policy to SCHED_IDLE</span><br><span class="line"> -o, --other          set policy to SCHED_OTHER</span><br><span class="line"> -r, --<span class="function">rr             set policy to <span class="title">SCHED_RR</span> <span class="params">(<span class="keyword">default</span>)</span></span></span><br><span class="line"><span class="function"></span></span><br><span class="line"><span class="function">Scheduling flag:</span></span><br><span class="line"><span class="function"> -R, --reset-on-fork  set SCHED_RESET_ON_FORK for FIFO or RR</span></span><br><span class="line"><span class="function"></span></span><br><span class="line"><span class="function">Other options:</span></span><br><span class="line"><span class="function"> -a, --all-tasks      operate on all the tasks (threads) for a given pid</span></span><br><span class="line"><span class="function"> -m, --max            show min and max valid priorities</span></span><br><span class="line"><span class="function"> -p, --pid            operate on existing given pid</span></span><br><span class="line"><span class="function"> -v, --verbose        display status information</span></span><br><span class="line"><span class="function"></span></span><br><span class="line"><span class="function"> -h, --help     display this help and exit</span></span><br><span class="line"><span class="function"> -V, --version  output version information and exit</span></span><br><span class="line"><span class="function"></span></span><br><span class="line"><span class="function">For more details see chrt(<span class="number">1</span>).</span></span><br></pre></td></tr></table></figure>

<p>我们先来关注显示出的Policy options部分，会发现系统给个种进程提供了5种调度策略。但是这里并没有说明的是，这五种调度策略是分别给两种进程用的，对于实时进程可以用的调度策略是：<strong>SCHED_FIFO</strong>、<strong>SCHED_RR</strong>，而对于非实时进程则是：<strong>SCHED_OTHER</strong>、<strong>SCHED_OTHER</strong>、<strong>SCHED_IDLE</strong>。</p>
<p>系统的整体优先级策略是：如果系统中存在需要执行的实时进程，则优先执行实时进程。直到实时进程退出或者主动让出CPU时，才会调度执行非实时进程。实时进程可以指定的优先级范围为1-99，将一个要执行的程序以实时方式执行的方法为：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">[root@zorrozou-pc0 zorro]<span class="meta"># chrt 10 bash</span></span><br><span class="line">[root@zorrozou-pc0 zorro]<span class="meta"># chrt -p $$</span></span><br><span class="line">pid <span class="number">14840&#x27;</span>s current scheduling policy: SCHED_RR</span><br><span class="line">pid <span class="number">14840&#x27;</span>s current scheduling priority: <span class="number">10</span></span><br></pre></td></tr></table></figure>

<p>可以看到，新打开的bash已经是实时进程，默认调度策略为SCHED_RR，优先级为10。如果想修改调度策略，就加个参数：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">[root@zorrozou-pc0 zorro]<span class="meta"># chrt -f 10 bash</span></span><br><span class="line">[root@zorrozou-pc0 zorro]<span class="meta"># chrt -p $$</span></span><br><span class="line">pid <span class="number">14843&#x27;</span>s current scheduling policy: SCHED_FIFO</span><br><span class="line">pid <span class="number">14843&#x27;</span>s current scheduling priority: <span class="number">10</span></span><br></pre></td></tr></table></figure>

<p>刚才说过，SCHED_RR和SCHED_FIFO都是实时调度策略，只能给实时进程设置。对于所有实时进程来说，优先级高的（就是priority数字小的）进程一定会保证先于优先级低的进程执行。SCHED_RR和SCHED_FIFO的调度策略只有当两个实时进程的优先级一样的时候才会发生作用，其区别也是顾名思义：</p>
<p>**SCHED_FIFO:**以先进先出的队列方式进行调度，在优先级一样的情况下，谁先执行的就先调度谁，除非它退出或者主动释放CPU。</p>
<p>**SCHED_RR:**以时间片轮转的方式对相同优先级的多个进程进行处理。时间片长度为100ms。</p>
<p>这就是Linux对于实时进程的优先级和相关调度算法的描述。整体很简单，也很实用。而相对更麻烦的是非实时进程，它们才是Linux上进程的主要分类。对于非实时进程优先级的处理，我们首先还是要来介绍一下它们相关的调度算法：O1和CFS。</p>
<h2 id="O1调度"><a href="#O1调度" class="headerlink" title="O1调度"></a>O1调度</h2><p>O1调度算法是在Linux 2.6开始引入的，到Linux 2.6.23之后内核将调度算法替换成了CFS。虽然O1算法已经不是当前内核所默认使用的调度算法了，但是由于大量线上的服务器可能使用的Linux版本还是老版本，所以我相信很多服务器还是在使用着O1调度器，那么费一点口舌简单交代一下这个调度器也是有意义的。这个调度器的名字之所以叫做O1，主要是因为其算法的时间复杂度是O1。</p>
<p>O1调度器仍然是根据经典的时间片分配的思路来进行整体设计的。简单来说，时间片的思路就是将CPU的执行时间分成一小段一小段的，假如是5ms一段。于是多个进程如果要“同时”执行，实际上就是每个进程轮流占用5ms的cpu时间，而从1s的时间尺度上看，这些进程就是在“同时”执行的。当然，对于多核系统来说，就是把每个核心都这样做就行了。而在这种情况下，如何支持优先级呢？实际上就是将时间片分配成大小不等的若干种，优先级高的进程使用大的时间片，优先级小的进程使用小的时间片。这样在一个周期结速后，优先级大的进程就会占用更多的时间而因此得到特殊待遇。O1算法还有一个比较特殊的地方是，即使是相同的nice值的进程，也会再根据其CPU的占用情况将其分成两种类型：CPU消耗型和IO消耗性。典型的CPU消耗型的进程的特点是，它总是要一直占用CPU进行运算，分给它的时间片总是会被耗尽之后，程序才可能发生调度。比如常见的各种算数运算程序。而IO消耗型的特点是，它经常时间片没有耗尽就自己主动先释放CPU了，比如vi，emacs这样的编辑器就是典型的IO消耗型进程。</p>
<p>为什么要这样区分呢？因为IO消耗型的进程经常是跟人交互的进程，比如shell、编辑器等。当系统中既有这种进程，又有CPU消耗型进程存在，并且其nice值一样时，假设给它们分的时间片长度是一样的，都是500ms，那么人的操作可能会因为CPU消耗型的进程一直占用CPU而变的卡顿。可以想象，当bash在等待人输入的时候，是不占CPU的，此时CPU消耗的程序会一直运算，假设每次都分到500ms的时间片，此时人在bash上敲入一个字符的时候，那么bash很可能要等个几百ms才能给出响应，因为在人敲入字符的时候，别的进程的时间片很可能并没有耗尽，所以系统不会调度bash程度进行处理。为了提高IO消耗型进程的响应速度，系统将区分这两类进程，并动态调整CPU消耗的进程将其优先级降低，而IO消耗型的将其优先级变高，以降低CPU消耗进程的时间片的实际长度。已知nice值的范围是-20-19，其对应priority值的范围是100－139，对于一个默认nice值为0的进程来说，其初始priority值应该是120，随着其不断执行，内核会观察进程的CPU消耗状态，并动态调整priority值，可调整的范围是+-5。就是说，最高其优先级可以呗自动调整到115，最低到125。这也是为什么nice值叫做静态优先级而priority值叫做动态优先级的原因。不过这个动态调整的功能在调度器换成CFS之后就不需要了，因为CFS换了另外一种CPU时间分配方式，这个我们后面再说。</p>
<p>再简单了解了O1算法按时间片分配CPU的思路之后，我们再来结合进程的状态简单看看其算法描述。我们都知道进程有5种状态：</p>
<ol>
<li><strong>S（Interruptible sleep）：</strong>可中断休眠状态。</li>
<li><strong>D（Uninterruptible sleep）：</strong>不可中断休眠状态。</li>
<li><strong>R（Running or runnable）：</strong>执行或者在可执行队列中。</li>
<li><strong>Z（Zombie process）：</strong>僵尸。</li>
<li><strong>T（Stopped）：</strong>暂停。</li>
</ol>
<p>在CPU调度时，主要只关心R状态进程，因为其他状态进程并不会被放倒调度队列中进行调度。调度队列中的进程一般主要有两种情况，一种是进程已经被调度到CPU上执行，另一种是进程正在等待被调度。出现这两种状态的原因应该好理解，因为需要执行的进程数可能多于硬件的CPU核心数，比如需要执行的进程有8个而CPU核心只有4个，此时cpu满载的时候，一定会有4个进程处在“等待”状态，因为此时有另外四个进程正在占用CPU执行。</p>
<p>根据以上情况我们可以理解，系统当下需要同时进行调度处理的进程数（R状态进程数）和系统CPU的比值，可以一定程度的反应系统的“繁忙”程度。需要调度的进程越多，核心越少，则意味着系统越繁忙。除了进程执行本身需要占用CPU以外，多个进程的调度切换也会让系统繁忙程度增加的更多。所以，我们往往会发现，R状态进程数量在增长的情况下，系统的性能表现会下降。系统中可以使用uptime命令查看系统平均负载指数（load average）：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">[zorro@zorrozou-pc0 ~]$ uptime </span><br><span class="line"> <span class="number">16</span>:<span class="number">40</span>:<span class="number">56</span> up  <span class="number">2</span>:<span class="number">12</span>,  <span class="number">1</span> user,  load average: <span class="number">0.05</span>, <span class="number">0.11</span>, <span class="number">0.16</span></span><br></pre></td></tr></table></figure>

<p>其中load average中分别显示的是1分钟，5分钟，15分钟之内的平均负载指数（可以简单认为是相映时间范围内的R状态进程个数）。但是这个命令显示的数字是绝对个数，并没有表示出不同CPU核心数的实际情况。比如，如果我们的1分钟load average为16，而CPU核心数为32的话，那么这个系统的其实并不繁忙。但是如果CPU个数是8的话，那可能就意味着比较忙了。但是实际情况往往可能比这更加复杂，比如进程消耗类型也会对这个数字的解读有影响。总之，这个值的绝对高低并不能直观的反馈出来当前系统的繁忙程度，还需要根据系统的其它指标综合考虑。</p>
<p><strong>O1调度器在处理流程上大概是这样进行调度的：</strong></p>
<ol>
<li>首先，进程产生（fork）的时候会给一个进程分配一个时间片长度。这个新进程的时间片一般是父进程的一半，而父进程也会因此减少它的时间片长度为原来的一半。就是说，如果一个进程产生了子进程，那么它们将会平分当前时间片长度。比如，如果父进程时间片还剩100ms，那么一个fork产生一个子进程之后，子进程的时间片是50ms，父进程剩余的时间片是也是50ms。这样设计的目的是，为了防止进程通过fork的方式让自己所处理的任务一直有时间片。不过这样做也会带来少许的不公平，因为先产生的子进程获得的时间片将会比后产生的长，第一个子进程分到父进程的一半，那么第二个子进程就只能分到1&#x2F;4。对于一个长期工作的进程组来说，这种影响可以忽略，因为第一轮时间片在耗尽后，系统会在给它们分配长度相当的时间片。</li>
<li>针对所有R状态进程，O1算法使用两个队列组织进程，其中一个叫做活动队列，另一个叫做过期队列。活动队列中放的都是时间片未被耗尽的进程，而过期队列中放时间片被耗尽的进程。</li>
<li>如1所述，新产生的进程都会先获得一个时间片，进入活动队列等待调度到CPU执行。而内核会在每个tick间隔期间对正在CPU上执行的进程进行检查。一般的tick间隔时间就是cpu时钟中断间隔，每秒钟会有1000个，即频率为1000HZ。每个tick间隔周期主要检查两个内容：1、当前正在占用CPU的进程是不是时间片已经耗尽了？2、是不是有更高优先级的进程在活动队列中等待调度？如果任何一种情况成立，就把则当前进程的执行状态终止，放到等待队列中，换当前在等待队列中优先级最高的那个进程执行。</li>
</ol>
<p>以上就是O1调度的基本调度思路，当然实际情况是，还要加上SMP（对称多处理）的逻辑，以满足多核CPU的需求。目前在我的archlinux上可以用以下命令查看内核HZ的配置：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">[zorro@zorrozou-pc0 ~]$ zgrep CONFIG_HZ /proc/config.gz </span><br><span class="line"># CONFIG_HZ_PERIODIC is <span class="keyword">not</span> set</span><br><span class="line"># CONFIG_HZ_100 is <span class="keyword">not</span> set</span><br><span class="line"># CONFIG_HZ_250 is <span class="keyword">not</span> set</span><br><span class="line">CONFIG_HZ_300=y</span><br><span class="line"># CONFIG_HZ_1000 is <span class="keyword">not</span> set</span><br><span class="line">CONFIG_HZ=<span class="number">300</span></span><br></pre></td></tr></table></figure>

<p>我们发现我当前系统的HZ配置为300，而不是一般情况下的1000。大家也可以思考一下，配置成不同的数字（100、250、300、1000），对系统的性能到底会有什么影响？</p>
<h2 id="CFS完全公平调度"><a href="#CFS完全公平调度" class="headerlink" title="CFS完全公平调度"></a>CFS完全公平调度</h2><p>O1已经是上一代调度器了，由于其对多核、多CPU系统的支持性能并不好，并且内核功能上要加入cgroup等因素，Linux在2.6.23之后开始启用CFS作为对一般优先级(SCHED_OTHER)进程调度方法。在这个重新设计的调度器中，时间片，动态、静态优先级以及IO消耗，CPU消耗的概念都不再重要。CFS采用了一种全新的方式，对上述功能进行了比较完善的支持。</p>
<p>其设计的基本思路是，我们想要实现一个对所有进程完全公平的调度器。又是那个老问题：如何做到完全公平？答案跟上一篇IO调度中CFQ的思路类似：如果当前有n个进程需要调度执行，那么调度器应该在一个比较小的时间范围内，把这n个进程全都调度执行一遍，并且它们平分cpu时间，这样就可以做到所有进程的公平调度。那么这个比较小的时间就是任意一个R状态进程被调度的最大延时时间，即：任意一个R状态进程，都一定会在这个时间范围内被调度相应。这个时间也可以叫做调度周期，其英文名字叫做：sched_latency_ns。进程越多，每个进程在周期内被执行的时间就会被平分的越小。调度器只需要对所有进程维护一个累积占用CPU时间数，就可以衡量出每个进程目前占用的CPU时间总量是不是过大或者过小，这个数字记录在每个进程的vruntime中。所有待执行进程都以vruntime为key放到一个由红黑树组成的队列中，每次被调度执行的进程，都是这个红黑树的最左子树上的那个进程，即vruntime时间最少的进程，这样就保证了所有进程的相对公平。</p>
<p>在基本驱动机制上CFS跟O1一样，每次时钟中断来临的时候，都会进行队列调度检查，判断是否要进程调度。当然还有别的时机需要调度检查，<strong>发生调度的时机可以总结为这样几个：</strong></p>
<ol>
<li>当前进程的状态转换时。主要是指当前进程终止退出或者进程休眠的时候。</li>
<li>当前进程主动放弃CPU时。状态变为sleep也可以理解为主动放弃CPU，但是当前内核给了一个方法，可以使用sched_yield()在不发生状态切换的情况下主动让出CPU。</li>
<li>当前进程的vruntime时间大于每个进程的理想占用时间时（delta_exec &gt;<br>ideal_runtime）。这里的ideal_runtime实际上就是上文说的sched_latency_ns／进程数n。当然这个值并不是一定这样得出，下文会有更详细解释。</li>
<li>当进程从中断、异常或系统调用返回时，会发生调度检查。比如时钟中断。</li>
</ol>
<h2 id="CFS的优先级"><a href="#CFS的优先级" class="headerlink" title="CFS的优先级"></a>CFS的优先级</h2><p>当然，CFS中还需要支持优先级。在新的体系中，优先级是以时间消耗（vruntime增长）的快慢来决定的。就是说，对于CFS来说，衡量的时间累积的绝对值都是一样纪录在vruntime中的，但是不同优先级的进程时间增长的比率是不同的，高优先级进程时间增长的慢，低优先级时间增长的快。比如，优先级为19的进程，实际占用cpu为1秒，那么在vruntime中就记录1s。但是如果是-20优先级的进程，那么它很可能实际占CPU用10s，在vruntime中才会纪录1s。CFS真实实现的不同nice值的cpu消耗时间比例在内核中是按照“每差一级cpu占用时间差10%左右”这个原则来设定的。这里的大概意思是说，如果有两个nice值为0的进程同时占用cpu，那么它们应该每人占50%的cpu，如果将其中一个进程的nice值调整为1的话，那么此时应保证优先级高的进程比低的多占用10%的cpu，就是nice值为0的占55%，nice值为1的占45%。那么它们占用cpu时间的比例为55:45。这个值的比例约为1.25。就是说，相邻的两个nice值之间的cpu占用时间比例的差别应该大约为1.25。根据这个原则，内核对40个nice值做了时间计算比例的对应关系，<strong>它在内核中以一个数组存在：</strong></p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="type">static</span> <span class="type">const</span> <span class="type">int</span> prio_to_weight[<span class="number">40</span>] = &#123;</span><br><span class="line"> <span class="comment">/* -20 */</span>     <span class="number">88761</span>,     <span class="number">71755</span>,     <span class="number">56483</span>,     <span class="number">46273</span>,     <span class="number">36291</span>,</span><br><span class="line"> <span class="comment">/* -15 */</span>     <span class="number">29154</span>,     <span class="number">23254</span>,     <span class="number">18705</span>,     <span class="number">14949</span>,     <span class="number">11916</span>,</span><br><span class="line"> <span class="comment">/* -10 */</span>      <span class="number">9548</span>,      <span class="number">7620</span>,      <span class="number">6100</span>,      <span class="number">4904</span>,      <span class="number">3906</span>,</span><br><span class="line"> <span class="comment">/*  -5 */</span>      <span class="number">3121</span>,      <span class="number">2501</span>,      <span class="number">1991</span>,      <span class="number">1586</span>,      <span class="number">1277</span>,</span><br><span class="line"> <span class="comment">/*   0 */</span>      <span class="number">1024</span>,       <span class="number">820</span>,       <span class="number">655</span>,       <span class="number">526</span>,       <span class="number">423</span>,</span><br><span class="line"> <span class="comment">/*   5 */</span>       <span class="number">335</span>,       <span class="number">272</span>,       <span class="number">215</span>,       <span class="number">172</span>,       <span class="number">137</span>,</span><br><span class="line"> <span class="comment">/*  10 */</span>       <span class="number">110</span>,        <span class="number">87</span>,        <span class="number">70</span>,        <span class="number">56</span>,        <span class="number">45</span>,</span><br><span class="line"> <span class="comment">/*  15 */</span>        <span class="number">36</span>,        <span class="number">29</span>,        <span class="number">23</span>,        <span class="number">18</span>,        <span class="number">15</span>,</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>我们看到，实际上nice值的最高优先级和最低优先级的时间比例差距还是很大的，绝不仅仅是例子中的十倍。由此我们也可以推导出每一个nice值级别计算vruntime的公式为：</p>
<figure class="highlight text"><table><tr><td class="code"><pre><span class="line">delta vruntime ＝ delta Time * 1024 / load</span><br></pre></td></tr></table></figure>

<p>这个公式的意思是说，在nice值为0的时候（对应的比例值为1024），计算这个进程vruntime的实际增长时间值（delta vruntime）为：CPU占用时间（delta Time）* 1024 &#x2F; load。在这个公式中load代表当前sched_entity的值，其实就可以理解为需要调度的进程（R状态进程）个数。load越大，那么每个进程所能分到的时间就越少。CPU调度是内核中会频繁进行处理的一个时间，于是上面的delta vruntime的运算会被频繁计算。除法运算会占用更多的cpu时间，所以内核编程中的一个原则就是，尽可能的不用除法。内核中要用除法的地方，基本都用乘法和位移运算来代替，所以上面这个公式就会变成：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">delta vruntime ＝ </span><br><span class="line">delta time * <span class="number">1024</span> * (<span class="number">2</span>^<span class="number">32</span> / (load * <span class="number">2</span>^<span class="number">32</span>)) =</span><br><span class="line"> (delta time * <span class="number">1024</span> * Inverse（load）) &gt;&gt; <span class="number">32</span></span><br></pre></td></tr></table></figure>

<p>内核中为了方便不同nice值的Inverse(load)的相关计算，对做好了一个跟prio_to_weight数组一一对应的数组，在计算中可以直接拿来使用，<strong>减少计算时的CPU消耗：</strong></p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="type">static</span> <span class="type">const</span> u32 prio_to_wmult[<span class="number">40</span>] = &#123;</span><br><span class="line"> <span class="comment">/* -20 */</span>     <span class="number">48388</span>,     <span class="number">59856</span>,     <span class="number">76040</span>,     <span class="number">92818</span>,    <span class="number">118348</span>,</span><br><span class="line"> <span class="comment">/* -15 */</span>    <span class="number">147320</span>,    <span class="number">184698</span>,    <span class="number">229616</span>,    <span class="number">287308</span>,    <span class="number">360437</span>,</span><br><span class="line"> <span class="comment">/* -10 */</span>    <span class="number">449829</span>,    <span class="number">563644</span>,    <span class="number">704093</span>,    <span class="number">875809</span>,   <span class="number">1099582</span>,</span><br><span class="line"> <span class="comment">/*  -5 */</span>   <span class="number">1376151</span>,   <span class="number">1717300</span>,   <span class="number">2157191</span>,   <span class="number">2708050</span>,   <span class="number">3363326</span>,</span><br><span class="line"> <span class="comment">/*   0 */</span>   <span class="number">4194304</span>,   <span class="number">5237765</span>,   <span class="number">6557202</span>,   <span class="number">8165337</span>,  <span class="number">10153587</span>,</span><br><span class="line"> <span class="comment">/*   5 */</span>  <span class="number">12820798</span>,  <span class="number">15790321</span>,  <span class="number">19976592</span>,  <span class="number">24970740</span>,  <span class="number">31350126</span>,</span><br><span class="line"> <span class="comment">/*  10 */</span>  <span class="number">39045157</span>,  <span class="number">49367440</span>,  <span class="number">61356676</span>,  <span class="number">76695844</span>,  <span class="number">95443717</span>,</span><br><span class="line"> <span class="comment">/*  15 */</span> <span class="number">119304647</span>, <span class="number">148102320</span>, <span class="number">186737708</span>, <span class="number">238609294</span>, <span class="number">286331153</span>,</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>具体计算细节不在这里细解释了，有兴趣的可以自行阅读代码：kernel&#x2F;shced&#x2F;fair.c（Linux 4.4）中的__calc_delta（）函数实现。</p>
<p>根据CFS的特性，我们知道调度器总是选择vruntime最小的进程进行调度。那么如果有两个进程的初始化vruntime时间一样时，一个进程被选择进行调度处理，那么只要一进行处理，它的vruntime时间就会大于另一个进程，CFS难道要马上换另一个进程处理么？出于减少频繁切换进程所带来的成本考虑，显然并不应该这样。CFS设计了一个sched_min_granularity_ns参数，用来设定进程被调度执行之后的最小CPU占用时间。</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">[zorro@zorrozou-pc0 ~]$ cat /proc/sys/kernel/sched_min_granularity_ns </span><br><span class="line"><span class="number">2250000</span></span><br></pre></td></tr></table></figure>

<p>一个进程被调度执行后至少要被执行这么长时间才会发生调度切换。我们知道无论到少个进程要执行，它们都有一个预期延迟时间，即：sched_latency_ns，系统中可以通过如下命令来查看这个时间：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">[zorro@zorrozou-pc0 ~]$ cat /proc/sys/kernel/sched_latency_ns </span><br><span class="line"><span class="number">18000000</span></span><br></pre></td></tr></table></figure>

<p>在这种情况下，如果需要调度的进程个数为n，那么平均每个进程占用的CPU时间为sched_latency_ns／n。显然，每个进程实际占用的CPU时间会因为n的增大而减小。但是实现上不可能让它无限的变小，所以sched_min_granularity_ns的值也限定了每个进程可以获得的执行时间周期的最小值。当进程很多，导致使用了sched_min_granularity_ns作为最小调度周期时，对应的调度延时也就不在遵循sched_latency_ns的限制，而是以实际的需要调度的进程个数n * sched_min_granularity_ns进行计算。当然，我们也可以把这理解为CFS的”时间片”，不过我们还是要强调，CFS是没有跟O1类似的“时间片“的概念的，具体区别大家可以自己琢磨一下。</p>
<h2 id="新进程的VRUNTIME值"><a href="#新进程的VRUNTIME值" class="headerlink" title="新进程的VRUNTIME值"></a>新进程的VRUNTIME值</h2><p>CFS是通过vruntime最小值来选择需要调度的进程的，那么可以想象，在一个已经有多个进程执行了相对较长的系统中，这个队列中的vruntime时间纪录的数值都会比较长。如果新产生的进程直接将自己的vruntime值设置为0的话，那么它将在执行开始的时间内抢占很多的CPU时间，直到自己的vruntime追赶上其他进程后才可能调度其他进程，这种情况显然是不公平的。所以CFS对每个CPU的执行队列都维护一个min_vruntime值，这个值纪录了这个CPU执行队列中vruntime的最小值，当队列中出现一个新建的进程时，它的初始化vruntime将不会被设置为0，而是根据min_vruntime的值为基础来设置。这样就保证了新建进程的vruntime与老进程的差距在一定范围内，不会因为vruntime设置为0而在进程开始的时候占用过多的CPU。</p>
<p>新建进程获得的实际vruntime值跟一些设置有关，比如：</p>
<figure class="highlight text"><table><tr><td class="code"><pre><span class="line">[zorro@zorrozou-pc0 ~]$ cat /proc/sys/kernel/sched_child_runs_first </span><br></pre></td></tr></table></figure>

<p>这个文件是fork之后是否让子进程优先于父进程执行的开关。0为关闭，1为打开。如果这个开关打开，就意味着子进程创建后，保证子进程在父进程之前被调度。另外，在源代码目录下的kernel&#x2F;sched&#x2F;features.h文件中，还规定了一系列调度器属性开关。而其中：</p>
<figure class="highlight text"><table><tr><td class="code"><pre><span class="line">/*</span><br><span class="line"> * Place new tasks ahead so that they do not starve already running</span><br><span class="line"> * tasks</span><br><span class="line"> */</span><br><span class="line">SCHED_FEAT(START_DEBIT, true)</span><br></pre></td></tr></table></figure>

<p>这个参数规定了新进程启动之后第一次运行会有延时。这意味着新进程的vruntime设置要比默认值大一些，这样做的目的是防止应用通过不停的fork来尽可能多的获得执行时间。子进程在创建的时候，vruntime的定义的步骤如下，首先vruntime被设置为min_vruntime。然后判断START_DEBIT位是否被值为true，如果是则会在min_vruntime的基础上增大一些，增大的时间实际上就是一个进程的调度延时时间，即上面描述过的calc_delta_fair()函数得到的结果。这个时间设置完毕之后，就检查sched_child_runs_first开关是否打开，如果打开（值被设置为1），就比较新进程的vruntime和父进程的vruntime哪个更小，并将新进程的vruntime设置为更小的那个值，而父进程的vruntime设置为更大的那个值，以此保证子进程一定在父进程之前被调度。</p>
<h2 id="IO消耗型进程的处理"><a href="#IO消耗型进程的处理" class="headerlink" title="IO消耗型进程的处理"></a>IO消耗型进程的处理</h2><p>根据前文，我们知道除了可能会一直占用CPU时间的CPU消耗型进程以外，还有一类叫做IO消耗类型的进程，它们的特点是基本不占用CPU，主要行为是在S状态等待响应。这类进程典型的是vim，bash等跟人交互的进程，以及一些压力不大的，使用了多进程（线程）的或select、poll、epoll的网络代理程序。如果CFS采用默认的策略处理这些程序的话，相比CPU消耗程序来说，这些应用由于绝大多数时间都处在sleep状态，它们的vruntime时间基本是不变的，一旦它们进入了调度队列，将会很快被选择调度执行。对比O1调度算法，这种行为相当于自然的提高了这些IO消耗型进程的优先级，于是就不需要特殊对它们的优先级进行“动态调整”了。</p>
<p>但这样的默认策略也是有问题的，有时CPU消耗型和IO消耗型进程的区分不是那么明显，有些进程可能会等一会，然后调度之后也会长时间占用CPU。这种情况下，如果休眠的时候进程的vruntime保持不变，那么等到休眠被唤醒之后，这个进程的vruntime时间就可能会比别人小很多，从而导致不公平。所以对于这样的进程，CFS也会对其进行时间补偿。补偿方式为，如果进程是从sleep状态被唤醒的，而且GENTLE_FAIR_SLEEPERS属性的值为true，则vruntime被设置为sched_latency_ns的一半和当前进程的vruntime值中比较大的那个。sched_latency_ns的值可以在这个文件中进行设置：</p>
<figure class="highlight text"><table><tr><td class="code"><pre><span class="line">[zorro@zorrozou-pc0 ~]$ cat /proc/sys/kernel/sched_latency_ns </span><br><span class="line">18000000</span><br></pre></td></tr></table></figure>

<p>因为系统中这种调度补偿的存在，IO消耗型的进程总是可以更快的获得响应速度。这是CFS处理与人交互的进程时的策略，即：通过提高响应速度让人的操作感受更好。但是有时候也会因为这样的策略导致整体性能受损。在很多使用了多进程（线程）或select、poll、epoll的网络代理程序，一般是由多个进程组成的进程组进行工作，典型的如apche、nginx和php-fpm这样的处理程序。它们往往都是由一个或者多个进程使用nanosleep()进行周期性的检查是否有新任务，如果有责唤醒一个子进程进行处理，子进程的处理可能会消耗CPU，而父进程则主要是sleep等待唤醒。这个时候，由于系统对sleep进程的补偿策略的存在，新唤醒的进程就可能会打断正在处理的子进程的过程，抢占CPU进行处理。当这种打断很多很频繁的时候，CPU处理的过程就会因为频繁的进程上下文切换而变的很低效，从而使系统整体吞吐量下降。此时我们可以使用开关禁止唤醒抢占的特性。</p>
<figure class="highlight text"><table><tr><td class="code"><pre><span class="line">[root@zorrozou-pc0 zorro]# cat /sys/kernel/debug/sched_features</span><br><span class="line">GENTLE_FAIR_SLEEPERS START_DEBIT NO_NEXT_BUDDY LAST_BUDDY CACHE_HOT_BUDDY WAKEUP_PREEMPTION NO_HRTICK NO_DOUBLE_TICK LB_BIAS NONTASK_CAPACITY TTWU_QUEUE RT_PUSH_IPI NO_FORCE_SD_OVERLAP RT_RUNTIME_SHARE NO_LB_MIN ATTACH_AGE_LOAD</span><br></pre></td></tr></table></figure>

<p>上面显示的这个文件的内容就是系统中用来控制kernel&#x2F;sched&#x2F;features.h这个文件所列内容的开关文件，其中WAKEUP_PREEMPTION表示：目前的系统状态是打开sleep唤醒进程的抢占属性的。可以使用如下命令关闭这个属性：</p>
<figure class="highlight text"><table><tr><td class="code"><pre><span class="line">[root@zorrozou-pc0 zorro]# echo NO_WAKEUP_PREEMPTION &gt; /sys/kernel/debug/sched_features</span><br><span class="line">[root@zorrozou-pc0 zorro]# cat /sys/kernel/debug/sched_features</span><br><span class="line">GENTLE_FAIR_SLEEPERS START_DEBIT NO_NEXT_BUDDY LAST_BUDDY CACHE_HOT_BUDDY NO_WAKEUP_PREEMPTION NO_HRTICK NO_DOUBLE_TICK LB_BIAS NONTASK_CAPACITY TTWU_QUEUE RT_PUSH_IPI NO_FORCE_SD_OVERLAP RT_RUNTIME_SHARE NO_LB_MIN ATTACH_AGE_LOAD</span><br></pre></td></tr></table></figure>

<p>其他相关参数的调整也是类似这样的方式。其他我没讲到的属性的含义，大家可以看kernel&#x2F;sched&#x2F;features.h文件中的注释。</p>
<p>系统中还提供了一个sched_wakeup_granularity_ns配置文件，这个文件的值决定了唤醒进程是否可以抢占的一个时间粒度条件。默认CFS的调度策略是，如果唤醒的进程vruntime小于当前正在执行的进程，那么就会发生唤醒进程抢占的情况。而sched_wakeup_granularity_ns这个参数是说，只有在当前进程的vruntime时间减唤醒进程的vruntime时间所得的差大于sched_wakeup_granularity_ns时，才回发生抢占。就是说sched_wakeup_granularity_ns的值越大，越不容易发生抢占。</p>
<h2 id="CFS和其他调度策略"><a href="#CFS和其他调度策略" class="headerlink" title="CFS和其他调度策略"></a>CFS和其他调度策略</h2><p><strong>SCHED_BATCH</strong></p>
<p>在上文中我们说过，CFS调度策略主要是针对chrt命令显示的SCHED_OTHER范围的进程，实际上就是一般的非实时进程。我们也已经知道，这样的一般进程还包括另外两种：SCHED_BATCH和SCHED_IDLE。在CFS的实现中，集成了对SCHED_BATCH策略的支持，并且其功能和SCHED_OTHER策略几乎是一致的。唯一的区别在于，如果一个进程被用chrt命令标记成SCHED_OTHER策略的话，CFS将永远认为这个进程是CPU消耗型的进程，不会对其进行IO消耗进程的时间补偿。这样做的唯一目的是，可以在确认进程是CPU消耗型的进程的前提下，对其尽可能的进行批处理方式调度（batch），以减少进程切换带来的损耗，提高吞度量。实际上这个策略的作用并不大，内核中真正的处理区别只是在标记为SCHED_BATCH时进程在sched_yield主动让出cpu的行为发生是不去更新cfs的队列时间，这样就让这些进程在主动让出CPU的时候（执行sched_yield）不会纪录其vruntime的更新，从而可以继续优先被调度到。对于其他行为，并无不同。</p>
<p><strong>SCHED_IDLE</strong></p>
<p>如果一个进程被标记成了SCHED_IDLE策略，调度器将认为这个优先级是很低很低的，比nice值为19的优先级还要低。系统将只在CPU空闲的时候才会对这样的进程进行调度执行。若果存在多个这样的进程，它们之间的调度方式跟正常的CFS相同。</p>
<p><strong>SCHED_DEADLINE</strong></p>
<p>最新的Linux内核还实现了一个最新的调度方式叫做SCHED_DEADLINE。跟IO调度类似，这个算法也是要实现一个可以在最终期限到达前让进程可以调度执行的方法，保证进程不会饿死。目前大多数系统上的chrt还没给配置接口，暂且不做深入分析。</p>
<p>另外要注意的是，SCHED_BATCH和SCHED_IDLE一样，只能对静态优先级（即nice值）为0的进程设置。操作命令如下：</p>
<figure class="highlight text"><table><tr><td class="code"><pre><span class="line">[zorro@zorrozou-pc0 ~]$ chrt -i 0 bash</span><br><span class="line">[zorro@zorrozou-pc0 ~]$ chrt -p $$</span><br><span class="line">pid 5478&#x27;s current scheduling policy: SCHED_IDLE</span><br><span class="line">pid 5478&#x27;s current scheduling priority: 0</span><br><span class="line"></span><br><span class="line">[zorro@zorrozou-pc0 ~]$ chrt -b 0 bash</span><br><span class="line">[zorro@zorrozou-pc0 ~]$ chrt -p $$</span><br><span class="line">pid 5502&#x27;s current scheduling policy: SCHED_BATCH</span><br><span class="line">pid 5502&#x27;s current scheduling priority: 0</span><br></pre></td></tr></table></figure>

<h2 id="多CPU的CFS调度"><a href="#多CPU的CFS调度" class="headerlink" title="多CPU的CFS调度"></a>多CPU的CFS调度</h2><p>在上面的叙述中，我们可以认为系统中只有一个CPU，那么相关的调度队列只有一个。实际情况是系统是有多核甚至多个CPU的，CFS从一开始就考虑了这种情况，它对每个CPU核心都维护一个调度队列，这样每个CPU都对自己的队列进程调度即可。这也是CFS比O1调度算法更高效的根本原因：每个CPU一个队列，就可以避免对全局队列使用大内核锁，从而提高了并行效率。当然，这样最直接的影响就是CPU之间的负载可能不均，为了维持CPU之间的负载均衡，CFS要定期对所有CPU进行load balance操作，于是就有可能发生进程在不同CPU的调度队列上切换的行为。这种操作的过程也需要对相关的CPU队列进行锁操作，从而降低了多个运行队列带来的并行性。不过总的来说，CFS的并行队列方式还是要比O1的全局队列方式要高效。尤其是在CPU核心越来越多的情况下，全局锁的效率下降显著增加。</p>
<p>CFS对多个CPU进行负载均衡的行为是idle_balance()函数实现的，这个函数会在CPU空闲的时候由schedule()进行调用，让空闲的CPU从其他繁忙的CPU队列中取进程来执行。我们可以通过查看&#x2F;proc&#x2F;sched_debug的信息来查看所有CPU的调度队列状态信息以及系统中所有进程的调度信息。内容较多，我就不在这里一一列出了，有兴趣的同学可以自己根据相关参考资料（最好的资料就是内核源码）了解其中显示的相关内容分别是什么意思。</p>
<p>在CFS对不同CPU的调度队列做均衡的时候，可能会将某个进程切换到另一个CPU上执行。此时，CFS会在将这个进程出队的时候将vruntime减去当前队列的min_vruntime，其差值作为结果会在入队另一个队列的时候再加上所入队列的min_vruntime，以此来保持队列切换后CPU队列的相对公平。</p>
<h2 id="最后"><a href="#最后" class="headerlink" title="最后"></a>最后</h2><p>本文的目的是从Linux系统进程的优先级为出发点，通过了解相关的知识点，希望大家对系统的进程调度有个整体的了解。其中我们也对CFS调度算法进行了比较深入的分析。在我的经验来看，这些知识对我们在观察系统的状态和相关优化的时候都是非常有用的。比如在使用top命令的时候，NI和PR值到底是什么意思？类似的地方还有ps命令中的NI和PRI值、ulimit命令-e和-r参数的区别等等。当然，希望看完本文后，能让大家对这些命令显示的了解更加深入。除此之外，我们还会发现，虽然top命令中的PR值和ps -l命令中的PRI值的含义是一样的，但是在优先级相同的情况下，它们显示的值确不一样。那么你知道为什么它们显示会有区别吗？这个问题的答案留给大家自己去寻找吧。</p>
<hr>
<p>版权声明：本文为知乎博主「玩转Linux内核」的原创文章，遵循CC 4.0 BY-SA版权协议，转载请附上原文出处链接及本声明。<br>原文链接：<a href="https://zhuanlan.zhihu.com/p/426399519">https://zhuanlan.zhihu.com/p/426399519</a></p>
]]></content>
      <categories>
        <category>linux-doc 进程管理</category>
      </categories>
      <tags>
        <tag>Linux</tag>
      </tags>
  </entry>
  <entry>
    <title>Linux内核进程调度O(1)调度算法</title>
    <url>/2023/01/15/linux-docs/%E8%BF%9B%E7%A8%8B%E7%AE%A1%E7%90%86/Linux%E5%86%85%E6%A0%B8%E8%BF%9B%E7%A8%8B%E8%B0%83%E5%BA%A6O(1)%E8%B0%83%E5%BA%A6%E7%AE%97%E6%B3%95/</url>
    <content><![CDATA[<p>Linux是一个支持多任务的操作系统，而多个任务之间的切换是通过 调度器 来完成，调度器 使用不同的调度算法会有不同的效果。Linux2.4版本使用的调度算法的时间复杂度为O(n)，其主要原理是通过轮询所有可运行任务列表，然后挑选一个最合适的任务运行，所以其时间复杂度与可运行任务队列的长度成正比。而Linux2.6开始替换成名为 O(1)调度算法，顾名思义，其时间复杂度为O(1)。虽然在后面的版本开始使用 CFS调度算法（完全公平调度算法），但了解 O(1)调度算法 对学习Linux调度器还是有很大帮助的，所以本文主要介绍 O(1)调度算法 的原理与实现。由于在 Linux 内核中，任务和进程是相同的概念，所以在本文混用了任务和进程这两个名词。</p>
<h2 id="1、O-1-调度算法原理"><a href="#1、O-1-调度算法原理" class="headerlink" title="1、O(1)调度算法原理"></a>1、O(1)调度算法原理</h2><h3 id="1-1prio-array-结构"><a href="#1-1prio-array-结构" class="headerlink" title="1.1prio_array 结构"></a>1.1prio_array 结构</h3><p>O(1)调度算法 通过优先级来对任务进行分组，可分为140个优先级（0 ~ 139，数值越小优先级越高），每个优先级的任务由一个队列来维护。</p>
<p><strong>prio_array 结构就是用来维护这些任务队列，如下代码：</strong></p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">define</span> MAX_USER_RT_PRIO    100</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> MAX_RT_PRIO         MAX_USER_RT_PRIO</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> MAX_PRIO            (MAX_RT_PRIO + 40)</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> BITMAP_SIZE ((((MAX_PRIO+1+7)/8)+sizeof(long)-1)/sizeof(long))</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">prio_array</span> &#123;</span><br><span class="line">    <span class="type">int</span> nr_active;</span><br><span class="line">    <span class="type">unsigned</span> <span class="type">long</span> bitmap[BITMAP_SIZE];</span><br><span class="line">    <span class="keyword">struct</span> <span class="title class_">list_head</span> queue[MAX_PRIO];</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p><strong>下面介绍 prio_array 结构各个字段的作用：</strong></p>
<ol>
<li>nr_active: 所有优先级队列中的总任务数。</li>
<li>bitmap: 位图，每个位对应一个优先级的任务队列，用于记录哪个任务队列不为空，能通过 bitmap 够快速找到不为空的任务队列。</li>
<li>queue: 优先级队列数组，每个元素维护一个优先级队列，比如索引为0的元素维护着优先级为0的任务队列。</li>
</ol>
<p><strong>下图更直观地展示了 prio_array 结构各个字段的关系：</strong></p>
<p><img src="https://pic1.zhimg.com/80/v2-dd9cfa164bdd3cdd6044d5a260419f50_720w.webp" alt="img"></p>
<p>如上图所述，bitmap 的第2位和第6位为1（红色代表为1，白色代表为0），表示优先级为2和6的任务队列不为空，也就是说 queue 数组的第2个元素和第6个元素的队列不为空。</p>
<h3 id="1-2runqueue-结构"><a href="#1-2runqueue-结构" class="headerlink" title="1.2runqueue 结构"></a>1.2runqueue 结构</h3><p>另外，为了减少多核CPU之间的竞争，所以每个CPU都需要维护一份本地的优先队列。因为如果使用全局的优先队列，那么多核CPU就需要对全局优先队列进行上锁，从而导致性能下降。</p>
<p>每个CPU都需要维护一个 runqueue 结构，runqueue 结构主要维护任务调度相关的信息，比如优先队列、调度次数、CPU负载信息等。其定义如下：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">struct</span> <span class="title class_">runqueue</span> &#123;</span><br><span class="line">    <span class="type">spinlock_t</span> lock;</span><br><span class="line">    <span class="type">unsigned</span> <span class="type">long</span> nr_running,</span><br><span class="line">                  nr_switches,</span><br><span class="line">                  expired_timestamp,</span><br><span class="line">                  nr_uninterruptible;</span><br><span class="line">    <span class="type">task_t</span> *curr, *idle;</span><br><span class="line">    <span class="keyword">struct</span> <span class="title class_">mm_struct</span> *prev_mm;</span><br><span class="line">    <span class="type">prio_array_t</span> *active, *expired, arrays[<span class="number">2</span>];</span><br><span class="line">    <span class="type">int</span> prev_cpu_load[NR_CPUS];</span><br><span class="line">    <span class="type">task_t</span> *migration_thread;</span><br><span class="line">    <span class="keyword">struct</span> <span class="title class_">list_head</span> migration_queue;</span><br><span class="line">    <span class="type">atomic_t</span> nr_iowait;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>runqueue 结构有两个重要的字段：active 和 expired，这两个字段在 O(1)调度算法 中起着至关重要的作用。我们先来了解一下 O(1)调度算法 的大概原理。</p>
<p>我们注意到 active 和 expired 字段的类型为 prio_array，指向任务优先队列。active 代表可以调度的任务队列，而 expired 字段代表时间片已经用完的任务队列。active 和 expired 会进行以下两个过程：</p>
<ol>
<li>当 active 中的任务时间片用完，那么就会被移动到 expired 中。</li>
<li>当 active 中已经没有任务可以运行，就把 expired 与 active 交换，从而 expired 中的任务可以重新被调度。</li>
</ol>
<p><strong>如下图所示：</strong></p>
<p><img src="https://pic2.zhimg.com/80/v2-0eeec7bdf4973608a5f5d7b8e4b86a65_720w.webp" alt="img"></p>
<p><img src="https://pic1.zhimg.com/80/v2-e5162b2cc5934a8cf8f11b59246f9be8_720w.webp" alt="img"></p>
<p>O(1)调度算法 把140个优先级的前100个（0 ~ 99）作为 实时进程优先级，而后40个（100 ~ 139）作为 普通进程优先级。实时进程被放置到实时进程优先级的队列中，而普通进程放置到普通进程优先级的队列中。</p>
<h2 id="2、实时进程调度"><a href="#2、实时进程调度" class="headerlink" title="2、实时进程调度"></a>2、实时进程调度</h2><p>实时进程分为 FIFO（先进先出） 和 RR（时间轮询） 两种，其调度算法比较简单，如下：</p>
<ol>
<li>先进先出的实时进程调度：如果调度器在执行某个先进先出的实时进程，那么调度器会一直运行这个进程，直至其主动放弃运行权（退出进程或者sleep等）。</li>
<li>时间轮询的实时进程调度：如果调度器在执行某个时间轮询的实时进程，那么调度器会判断当前进程的时间片是否用完，如果用完的话，那么重新分配时间片给它，并且重新放置回 active 队列中，然后调度到其他同优先级或者优先级更高的实时进程进行运行。</li>
</ol>
<h3 id="2-1普通进程调度"><a href="#2-1普通进程调度" class="headerlink" title="2.1普通进程调度"></a>2.1普通进程调度</h3><p>每个进程都要一个动态优先级和静态优先级，静态优先级不会变化（进程创建时被设置），而动态优先级会随着进程的睡眠时间而发生变化。动态优先级可以通过以下公式进行计算：</p>
<figure class="highlight text"><table><tr><td class="code"><pre><span class="line">动态优先级 = max(100, min(静态优先级 – bonus + 5), 139))</span><br></pre></td></tr></table></figure>

<p>上面公式的 bonus（奖励或惩罚） 是通过进程的睡眠时间计算出来，进程的睡眠时间越大，bonus 的值就越大，那么动态优先级就越高（前面说过优先级的值越小，优先级越高）。</p>
<blockquote>
<p>另外要说明一下，实时进程的动态优先级与静态优先级相同。</p>
</blockquote>
<p>当一个普通进程被添加到运行队列时，会先计算其动态优先级，然后按照动态优先级的值来添加到对应优先级的队列中。而调度器调度进程时，会先选择优先级最高的任务队列中的进程进行调度运行。</p>
<h3 id="2-2运行时间片计算"><a href="#2-2运行时间片计算" class="headerlink" title="2.2运行时间片计算"></a>2.2运行时间片计算</h3><p>当进程的时间用完后，就需要重新进行计算。进程的运行时间片与静态优先级有关，可以通过以下公式进行计算：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">静态优先级 &lt; <span class="number">120</span>，运行时间片 = <span class="built_in">max</span>((<span class="number">140</span>-静态优先级)*<span class="number">20</span>, MIN_TIMESLICE)</span><br><span class="line">静态优先级 &gt;= <span class="number">120</span>，运行时间片 = <span class="built_in">max</span>((<span class="number">140</span>-静态优先级)*<span class="number">5</span>, MIN_TIMESLICE)</span><br></pre></td></tr></table></figure>

<h2 id="3、O-1-调度算法实现"><a href="#3、O-1-调度算法实现" class="headerlink" title="3、O(1)调度算法实现"></a>3、O(1)调度算法实现</h2><p>接下来我们分析一下 O(1)调度算法 在内核中的实现。</p>
<h3 id="3-1时钟中断"><a href="#3-1时钟中断" class="headerlink" title="3.1时钟中断"></a>3.1时钟中断</h3><p>时钟中断是由硬件触发的，可以通过编程来设置其频率，Linux内核一般设置为每秒产生100 ~ 1000次。时钟中断会触发调用 scheduler_tick() 内核函数，其主要工作是：减少进程的可运行时间片，如果时间片用完，那么把进程从 active 队列移动到 expired 队列中。代码如下：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">scheduler_tick</span><span class="params">(<span class="type">int</span> user_ticks, <span class="type">int</span> sys_ticks)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">runqueue_t</span> *rq = <span class="built_in">this_rq</span>();</span><br><span class="line">    <span class="type">task_t</span> *p = current;</span><br><span class="line"></span><br><span class="line">    ...</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 处理普通进程</span></span><br><span class="line">    <span class="keyword">if</span> (!--p-&gt;time_slice) &#123;                <span class="comment">// 减少时间片, 如果时间片用完</span></span><br><span class="line">        <span class="built_in">dequeue_task</span>(p, rq-&gt;active);       <span class="comment">// 把进程从运行队列中删除</span></span><br><span class="line">        <span class="built_in">set_tsk_need_resched</span>(p);           <span class="comment">// 设置要重新调度标志</span></span><br><span class="line">        p-&gt;prio = <span class="built_in">effective_prio</span>(p);       <span class="comment">// 重新计算动态优先级</span></span><br><span class="line">        p-&gt;time_slice = <span class="built_in">task_timeslice</span>(p); <span class="comment">// 重新计算时间片</span></span><br><span class="line">        p-&gt;first_time_slice = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (!rq-&gt;expired_timestamp)</span><br><span class="line">            rq-&gt;expired_timestamp = jiffies;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 如果不是交互进程或者没有出来饥饿状态</span></span><br><span class="line">        <span class="keyword">if</span> (!<span class="built_in">TASK_INTERACTIVE</span>(p) || <span class="built_in">EXPIRED_STARVING</span>(rq)) &#123;</span><br><span class="line">            <span class="built_in">enqueue_task</span>(p, rq-&gt;expired); <span class="comment">// 移动到expired队列</span></span><br><span class="line">        &#125; <span class="keyword">else</span></span><br><span class="line">            <span class="built_in">enqueue_task</span>(p, rq-&gt;active);  <span class="comment">// 重新放置到active队列</span></span><br><span class="line">    &#125;</span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>上面代码主要完成以下几个工作：</strong></p>
<ol>
<li>减少进程的时间片，并且判断时间片是否已经使用完。</li>
<li>如果时间片使用完，那么把进程从 active 队列中删除。</li>
<li>调用 set_tsk_need_resched() 函数设 TIF_NEED_RESCHED 标志，表示当前进程需要重新调度。</li>
<li>调用 effective_prio() 函数重新计算进程的动态优先级。</li>
<li>调用 task_timeslice() 函数重新计算进程的可运行时间片。</li>
<li>如果当前进程是交互进程或者出来饥饿状态，那么重新加入到 active 队列。</li>
<li>否则把今天移动到 expired 队列。</li>
</ol>
<h3 id="3-2任务调度"><a href="#3-2任务调度" class="headerlink" title="3.2任务调度"></a>3.2任务调度</h3><p>如果进程设置了 TIF_NEED_RESCHED 标志，那么当从时钟中断返回到用户空间时，会调用 schedule() 函数进行任务调度。</p>
<p><strong>schedule() 函数代码如下：</strong></p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">schedule</span><span class="params">(<span class="type">void</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    ...</span><br><span class="line">    prev = current;  <span class="comment">// 当前需要被调度的进程</span></span><br><span class="line">    rq = <span class="built_in">this_rq</span>();  <span class="comment">// 获取当前CPU的runqueue</span></span><br><span class="line"></span><br><span class="line">    array = rq-&gt;active; <span class="comment">// active队列</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 如果active队列中没有进程, 那么替换成expired队列</span></span><br><span class="line">    <span class="keyword">if</span> (<span class="built_in">unlikely</span>(!array-&gt;nr_active)) &#123;</span><br><span class="line">        rq-&gt;active = rq-&gt;expired;</span><br><span class="line">        rq-&gt;expired = array;</span><br><span class="line">        array = rq-&gt;active;</span><br><span class="line">        rq-&gt;expired_timestamp = <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    idx = <span class="built_in">sched_find_first_bit</span>(array-&gt;bitmap); <span class="comment">// 找到最高优先级的任务队列</span></span><br><span class="line">    queue = array-&gt;queue + idx;</span><br><span class="line">    next = <span class="built_in">list_entry</span>(queue-&gt;next, <span class="type">task_t</span>, run_list); <span class="comment">// 获取到下一个将要运行的进程</span></span><br><span class="line"></span><br><span class="line">    ...</span><br><span class="line">    prev-&gt;sleep_avg -= run_time; <span class="comment">// 减少当前进程的睡眠时间</span></span><br><span class="line">    ...</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (<span class="built_in">likely</span>(prev != next)) &#123;</span><br><span class="line">        ...</span><br><span class="line">        prev = <span class="built_in">context_switch</span>(rq, prev, next); <span class="comment">// 切换到next进程进行运行</span></span><br><span class="line">        ...</span><br><span class="line">    &#125;</span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>上面代码主要完成以下几个步骤：</strong></p>
<ol>
<li>如果当前 runqueue 的 active 队列为空，那么把 active 队列与 expired 队列进行交换。</li>
<li>调用 sched_find_first_bit() 函数在 bitmap 中找到优先级最高并且不为空的任务队列索引。</li>
<li>减少当前进程的睡眠时间。</li>
<li>调用 context_switch() 函数切换到next进程进行运行。</li>
</ol>
<hr>
<p>版权声明：本文为知乎博主「玩转Linux内核」的原创文章，遵循CC 4.0 BY-SA版权协议，转载请附上原文<br>出处链接及本声明。<br>原文链接：<a href="https://zhuanlan.zhihu.com/p/464176766">https://zhuanlan.zhihu.com/p/464176766</a></p>
]]></content>
      <categories>
        <category>linux-doc 进程管理</category>
      </categories>
      <tags>
        <tag>Linux</tag>
      </tags>
  </entry>
  <entry>
    <title>Linux内核进程述符和进程状态</title>
    <url>/2023/01/15/linux-docs/%E8%BF%9B%E7%A8%8B%E7%AE%A1%E7%90%86/Linux%E5%86%85%E6%A0%B8%E8%BF%9B%E7%A8%8B%E8%BF%B0%E7%AC%A6%E5%92%8C%E8%BF%9B%E7%A8%8B%E7%8A%B6%E6%80%81/</url>
    <content><![CDATA[<h2 id="一，进程"><a href="#一，进程" class="headerlink" title="一，进程"></a>一，进程</h2><p>程序是指储存在外部存储(如硬盘)的一个可执行文件, 而进程是指处于执行期间的程序, 进程包括 代码段(textsection) 和 数据段(data section) , 除了代码段和数据段外, 进程一般还包含打开的文件, 要处理的信号和CPU上下文等等。</p>
<h2 id="二，进程描述符"><a href="#二，进程描述符" class="headerlink" title="二，进程描述符"></a>二，进程描述符</h2><p>Linux进程使用 struct task_struct根据描述(include&#x2F;linux&#x2F;sched.h), 如下:</p>
<figure class="highlight text"><table><tr><td class="code"><pre><span class="line">struct task_struct &#123;/** offsets of these are hardcoded elsewhere - touch with care */ </span><br><span class="line">  volatile long state; /* -1 unrunnable, 0 runnable, &gt;0 stopped */ </span><br><span class="line">  unsigned long flags; /* per process flags, defined below */ </span><br><span class="line">  int sigpending; mm_segment_t addr_limit; /* thread address space: 0-0xBFFFFFFF for user-thead 0-0xFFFFFFFF for kernel-thread */ </span><br><span class="line">  struct exec_domain *exec_domain; </span><br><span class="line">  volatile long need_resched;</span><br><span class="line">  unsigned long ptrace;</span><br><span class="line">  int lock_depth; /* Lock depth */ /** offset 32 begins here on 32-bit platforms. We keep * all fields in a single cacheline that are needed for * the goodness() loop in schedule(). */</span><br><span class="line">  long counter; </span><br><span class="line">  long nice; </span><br><span class="line">  unsigned long policy; </span><br><span class="line">  struct mm_struct *mm;</span><br><span class="line">  int processor;</span><br><span class="line">  ... &#125;</span><br></pre></td></tr></table></figure>

<p><strong>Linux把所有的进程使用双向链表连接起来, 如下图(来源&lt;Linux设计与实现&gt;):</strong></p>
<p><img src="https://pic3.zhimg.com/80/v2-43d9ec266d5c37594e4de7d5758ba50e_720w.webp" alt="img"></p>
<p>Linux内核为了加快获取当前进程的的task_struct结构, 使用了一个技巧, 就是把task_struct放置在内核栈的栈底, 这样就可以通过esp寄存器快速获取到当前运行进程的task_struct结构. 如下图:</p>
<p><img src="https://pic4.zhimg.com/80/v2-eedd18a394eedd6829849cc25e89dc17_720w.webp" alt="img"></p>
<p><strong>获取当前运行进程的task_struct代码如下:</strong></p>
<figure class="highlight text"><table><tr><td class="code"><pre><span class="line">static inline struct task_struct * get_current(void) &#123; </span><br><span class="line">          struct task_struct *current; __asm__(</span><br><span class="line">        &quot;andl %%esp,%0; &quot;:&quot;=r&quot; (current) : &quot;0&quot; (~8191UL)</span><br><span class="line">); </span><br><span class="line">return current;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="三，进程状态"><a href="#三，进程状态" class="headerlink" title="三，进程状态"></a>三，进程状态</h2><p><strong>进程描述符的state字段用于保存进程的当前状态, 进程的状态有以下几种:</strong></p>
<ol>
<li>TASK_RUNNING (运行) – 进程处于可执行状态, 在这个状态下的进程要么正在被CPU执行, 要么在等待执行(CPU被其他进程占用的情况下)</li>
<li>TASK_INTERRUPTIBLE (可中断等待) – 进程处于等待状态, 其在等待某些条件成立或者接收到某些信号, 进程会被唤醒变为运行状态</li>
<li>TASK_UNINTERRUPTIBLE (不可中断等待) – 进程处于等待状态, 其在等待某些条件成立, 进程会被唤醒变为运行状态, 但不能被信号唤醒.</li>
<li>TASK_TRACED (被追踪) – 进程处于被追踪状态, 例如通过ptrace命令对进程进行调试.</li>
<li>TASK_STOPPED (停止) – 进程处于停止状态, 进程不能被执行. 一般接收到SIGSTOP, SIGTSTP,SIGTTIN, SIGTTOU信号进程会变成TASK_STOPPED状态.</li>
</ol>
<p><strong>各种状态间的转换如下图:</strong></p>
<p><img src="https://pic3.zhimg.com/80/v2-c0b28d06c4e8f8436d3e94efd820af9e_720w.webp" alt="img"></p>
<h2 id="四，进程的创建"><a href="#四，进程的创建" class="headerlink" title="四，进程的创建"></a>四，进程的创建</h2><p>在Linux系统中，进程的创建使用fork()系统调用，fork()调用会创建一个与父进程一样的子进程，唯一不同就是fork()的返回值，父进程返回的是子进程的进程ID，而子进程返回的是0。Linux创建子进程时使用了 写时复制（Copy On Write） ，也就是创建子进程时使用的是父进程的内存空间，当子进程或者父进程修改数据时才会复制相应的内存页。当调用fork()系统调用时会陷入内核空间并且调用sys_fork()函数，sys_fork()函数会调用do_fork()函数，代码如下(arch&#x2F;i386&#x2F;kernel&#x2F;process.c)：</p>
<figure class="highlight text"><table><tr><td class="code"><pre><span class="line">asmlinkage int sys_fork(struct pt_regs regs) &#123; </span><br><span class="line">  return do_fork(SIGCHLD, regs.esp, &amp;regs, 0); </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>do_fork()主要的工作是申请一个进程描述符, 然后初始化进程描述符的各个字段, 包括调用 copy_files() 函数复制打开的文件, 调用 copy_sighand() 函数复制信号处理函数, 调用 copy_mm() 函数复制进程虚拟内存空间, 调用 copy_namespace() 函数复制命名空间. <strong>代码如下:</strong></p>
<figure class="highlight text"><table><tr><td class="code"><pre><span class="line">int do_fork( </span><br><span class="line">  unsigned long clone_flags, unsigned long stack_start, struct pt_regs *regs, </span><br><span class="line">  unsigned long stack_size) &#123; </span><br><span class="line">  ... p = alloc_task_struct(); // 申请进程描述符 ... </span><br><span class="line">  if (copy_files(clone_flags, p)) goto bad_fork_cleanup;</span><br><span class="line">  if (copy_fs(clone_flags, p)) goto bad_fork_cleanup_files; </span><br><span class="line">  if (copy_sighand(clone_flags, p)) goto bad_fork_cleanup_fs;</span><br><span class="line">  if (copy_mm(clone_flags, p)) goto bad_fork_cleanup_sighand; </span><br><span class="line">  if (copy_namespace(clone_flags, p)) goto bad_fork_cleanup_mm; </span><br><span class="line">  retval = copy_thread(0, clone_flags, stack_start, stack_size, p, regs); </span><br><span class="line">  ... wake_up_process(p); ... </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>值得注意的是do_fork() 还调用了 copy_thread() 这个函数, copy_thread()这个函数主要用于设置进程的CPU执行上下文 struct thread_struct 结构代码如下:</p>
<figure class="highlight text"><table><tr><td class="code"><pre><span class="line">int copy_thread(</span><br><span class="line">  int nr, unsigned long clone_flags, unsigned long esp, </span><br><span class="line">  unsigned long unused, </span><br><span class="line">  struct task_struct * p, struct pt_regs * regs) &#123; </span><br><span class="line">  struct pt_regs * childregs; // 指向栈顶(见图2) </span><br><span class="line">  childregs = ((struct pt_regs *) (THREAD_SIZE + (unsigned long) p)) - 1;</span><br><span class="line">  struct_cpy(childregs, regs); // 复制父进程的栈信息 </span><br><span class="line">  childregs-&gt;eax = 0; // 这个是子进程调用fork()之后的返回值, 也就是0 </span><br><span class="line">  childregs-&gt;esp = esp;</span><br><span class="line">  p-&gt;thread.esp = (unsigned long) childregs; // 子进程当前的栈地址, 调用 switch_to()的时候esp设置为这个地址 </span><br><span class="line">  p-&gt;thread.esp0 = (unsigned long) (childregs+1); // 子进程内核空间栈地址 </span><br><span class="line">  p-&gt;thread.eip = (unsigned long) ret_from_fork; // 子进程将要执行的代码地址 </span><br><span class="line">  savesegment(fs,p-&gt;thread.fs</span><br><span class="line">             ); savesegment(gs,p-&gt;thread.gs); </span><br><span class="line">  unlazy_fpu(current); </span><br><span class="line">  struct_cpy(&amp;p-&gt;thread.i387,</span><br><span class="line">             </span><br><span class="line">  &amp;current-&gt;thread.i387); </span><br><span class="line">  return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>do_fork() 函数最后调用 wake_up_process() 函数唤醒子进程, 让子进程进入运行状态</p>
<h2 id="五，内核线程"><a href="#五，内核线程" class="headerlink" title="五，内核线程"></a>五，内核线程</h2><p>Linux内核有很多任务需要去做, 例如定时把缓冲器中的数据刷到硬盘上, 当内存不足的时候进行内存的回收等, 这些所有工作都需要通过内核线程来完成. 内核线程与普通进程的主要区别就是: 内核线程没有自己的 虚拟空间结构(struct mm) , 每次内核线程执行的时候都是借助当前运行进程的虚拟内存空间结构来运行, 因为内核线程只会运行在内核状态, 而每个进程的内核态空间都是一样的, 所以借助其他进程的虚拟内存空间结构来运行是完成可行的内核线程使用 kernel_thread() 函数来创建, 代码如下:</p>
<figure class="highlight text"><table><tr><td class="code"><pre><span class="line">int kernel_thread(int (*fn)(void *), void * arg, unsigned long flags)</span><br><span class="line">      &#123;</span><br><span class="line">                  long retval, d0;</span><br><span class="line">                  __asm__ __volatile__(</span><br><span class="line">                  &quot;movl %%esp,%%esi\n\t&quot;</span><br><span class="line">                  &quot;int $0x80\n\t&quot; /* Linux/i386 system call */ </span><br><span class="line">                  &quot;cmpl %%esp,%%esi\n\t&quot; /* child or parent? */ </span><br><span class="line">                  &quot;je 1f\n\t&quot; /* parent - jump */</span><br><span class="line">                  /* Load the argument into eax, and push it. That way, it does * not matter  </span><br><span class="line">                whether the called function is compiled with * -mregparm or not. */</span><br><span class="line">               &quot;movl %4,%%eax\n\t&quot;</span><br><span class="line">                  &quot;pushl %%eax\n\t&quot; </span><br><span class="line">                  &quot;call *%5\n\t&quot; /* call fn */ </span><br><span class="line">                  &quot;movl %3,%0\n\t&quot; /* exit */</span><br><span class="line">                  &quot;int $0x80\n&quot; &quot;1:\t&quot;</span><br><span class="line">                  :&quot;=&amp;a&quot; (retval), &quot;=&amp;S&quot; (d0) :&quot;0&quot; (__NR_clone), &quot;i&quot; (__NR_exit), &quot;r&quot; (arg), &quot;r&quot; (fn), &quot;b&quot; (flags | CLONE_VM) : &quot;memory&quot;);</span><br><span class="line">return retval; </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>因为这个函数是使用嵌入汇编来实现的, 所以有点难懂, 不过主要过程就是通过调用 _clone() 函数来创建一个新的进程, 而创建进程是通过传入CLONE_VM 标志来指定进程借用其他进程的虚拟内存空间结构。</p>
<p><strong>特别说明一下：</strong>d0局部变量的作用是为了在创建内核线程时保证 struct pt_regs 结构的完整，这是因为创建内核线程是在内核态进行的，所以在内核态调用系统调用是不会压入 ss 和esp寄存器的，这样就会导致系统调用的 struct pt_regs参数信息不完整，所以 kernel_thread() 函数定义了一个 d0 局部变量是为了补充没压栈的ss和esp的。</p>
<hr>
<p>版权声明：本文为知乎博主「玩转Linux内核」的原创文章，遵循CC 4.0 BY-SA版权协议，转载请附上原文出处链接及本声明。<br>原文链接：<a href="https://zhuanlan.zhihu.com/p/441346358">https://zhuanlan.zhihu.com/p/441346358</a></p>
]]></content>
      <categories>
        <category>linux-doc 进程管理</category>
      </categories>
      <tags>
        <tag>Linux</tag>
      </tags>
  </entry>
  <entry>
    <title>Linux内核进程间通信-管道</title>
    <url>/2023/01/15/linux-docs/%E8%BF%9B%E7%A8%8B%E7%AE%A1%E7%90%86/Linux%E5%86%85%E6%A0%B8%E8%BF%9B%E7%A8%8B%E9%97%B4%E9%80%9A%E4%BF%A1-%E7%AE%A1%E9%81%93/</url>
    <content><![CDATA[<h2 id="1、管道的定义"><a href="#1、管道的定义" class="headerlink" title="1、管道的定义"></a>1、<strong>管道的定义</strong></h2><ul>
<li>管道是第一个广泛应用的进程间通信手段。日常在终端执行shell命令时，会大量用到管道。但管道的缺陷在于只能在有亲缘关系（有共同的祖先）的进程之间使用。为了突破这个限制，后来引入了命名管道。</li>
</ul>
<p><img src="https://pic2.zhimg.com/80/v2-13b4a46233ad254912d9bf9ba6bbdb95_720w.webp" alt="img"></p>
<p><img src="https://pic1.zhimg.com/80/v2-011bb4b9ebed933a31b219d5599307d8_720w.webp" alt="img"></p>
<h2 id="2、管道的用途"><a href="#2、管道的用途" class="headerlink" title="2、管道的用途"></a>2、<strong>管道的用途</strong></h2><ul>
<li>管道是最早出现的进程间通信的手段。在shell中执行命令，经常会将上一个命令的输出作为下一个命令的输入，由多个命令配合完成一件事情。而这就是通过管道来实现的。<br>在图9-3中，进程who的标准输出，通过管道传递给下游的wc进程作为标准输入，从而通过相互配合完成了一件任务。</li>
</ul>
<p><img src="https://pic3.zhimg.com/80/v2-6026b2f409cd9c1afad043993753b3aa_720w.webp" alt="img"></p>
<h2 id="3、管道的操作"><a href="#3、管道的操作" class="headerlink" title="3、管道的操作"></a>3、<strong>管道的操作</strong></h2><ul>
<li>管道的作用是在具有亲缘关系的进程之间传递消息，所谓有亲缘关系，是指有同一个祖先。<strong>所以管道并不是只可以用于父子进程通信，也可以在兄弟进程之间还可以用在祖孙之间等，反正只要共同的祖先调用了pipe函数，打开的管道文件就会在fork之后，被各个后代所共享</strong>。</li>
<li>不过由于管道是字节流通信，没有消息边界，多个进程同时发送的字节流混在一起，则无法分辨消息，所有管道一般用于2个进程之间通信，另外管道的内容读完后不会保存，管道是单向的，一边要么读，一边要么写，不可以又读又写，想要一边读一边写，那就创建2个管道，如下图</li>
</ul>
<p><img src="https://pic4.zhimg.com/80/v2-e551506e0ee9b917160021358b8b45b7_720w.webp" alt="img"></p>
<ul>
<li>管道是一种文件，可以调用read、write和close等操作文件的接口来操作管道。<strong>另一方面管道又不是一种普通的文件，它属于一种独特的文件系统：pipefs。管道的本质是内核维护了一块缓冲区与管道文件相关联，对管道文件的操作，被内核转换成对这块缓冲区内存的操作</strong>。下面我们来看一下如何使用管道。</li>
</ul>
<figure class="highlight text"><table><tr><td class="code"><pre><span class="line">#include&lt;unistd.h&gt;</span><br><span class="line">int pipe(int fd[2])</span><br></pre></td></tr></table></figure>

<p>如果成功，则返回值是0，如果失败，则返回值是-1，并且设置errno。<br>成功调用pipe函数之后，会返回两个打开的文件描述符，<strong>一个是管道的读取端描述符pipefd[0]，另一个是管道的写入端描述符pipefd[1]。管道没有文件名与之关联，因此程序没有选择，只能通过文件描述符来访问管道，只有那些能看到这两个文件描述符的进程才能够使用管道</strong>。<em>那么谁能看到进程打开的文件描述符呢？只有该进程及该进程的子孙进程才能看到。这就限制了管道的使用范围</em>。</p>
<ul>
<li>成功调用pipe函数之后，可以对写入端描述符pipefd[1]调用write，向管道里面写入数据，代码如下所示：</li>
</ul>
<figure class="highlight text"><table><tr><td class="code"><pre><span class="line">write(pipefd[1],wbuf,count);</span><br></pre></td></tr></table></figure>

<p>一旦向管道的写入端写入数据后，就可以对读取端描述符pipefd[0]调用read，读出管道里面的内容。如下所示，管道上的read调用返回的字节数等于请求字节数和管道中当前存在的字节数的最小值。如果当前管道为空，那么read调用会阻塞（如果没有设置O_NONBLOCK标志位的话）。</p>
<h2 id="4、管道非法read与write内核实现解析"><a href="#4、管道非法read与write内核实现解析" class="headerlink" title="4、管道非法read与write内核实现解析"></a>4、<strong>管道非法read与write内核实现解析</strong></h2><p>调用pipe函数返回的两个文件描述符中，读取端pipefd[0]支持的文件操作定义在read_pipefifo_fops，写入端pipefd[1]支持的文件操作定义在write_pipefifo_fops，其定义如下：</p>
<figure class="highlight text"><table><tr><td class="code"><pre><span class="line">const struct file_operations read_pipefifo_fops = &#123; //读端相关操作</span><br><span class="line"> .llseek = no_llseek,</span><br><span class="line"> .read = do_sync_read,</span><br><span class="line"> .aio_read = pipe_read,</span><br><span class="line"> .write = bad_pipe_w, //一旦写，将调用bad_pipe_w</span><br><span class="line"> .poll = pipe_poll,</span><br><span class="line"> .unlocked_ioctl = pipe_ioctl,</span><br><span class="line"> .open = pipe_read_open,</span><br><span class="line"> .release = pipe_read_release,</span><br><span class="line"> .fasync = pipe_read_fasync,</span><br><span class="line">&#125;;</span><br><span class="line">const struct file_operations write_pipefifo_fops = &#123;//写端相关操作</span><br><span class="line"> .llseek = no_llseek,</span><br><span class="line"> .read = bad_pipe_r, //一旦读，将调用bad_pipe_r</span><br><span class="line"> .write = do_sync_write,</span><br><span class="line"> .aio_write = pipe_write,</span><br><span class="line"> .poll = pipe_poll,</span><br><span class="line"> .unlocked_ioctl = pipe_ioctl,</span><br><span class="line"> .open = pipe_write_open,</span><br><span class="line"> .release = pipe_write_release,</span><br><span class="line"> .fasync = pipe_write_fasync,</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>我们可以看到，<strong>对读取端描述符执行write操作，内核就会执行bad_pipe_w函数；对写入端描述符执行read操作，内核就会执行bad_pipe_r函数。这两个函数比较简单，都是直接返回-EBADF。因此对应的read和write调用都会失败，返回-1，并置errno为EBADF</strong>。</p>
<figure class="highlight text"><table><tr><td class="code"><pre><span class="line">static ssize_t </span><br><span class="line">bad_pipe_r(struct file filp, char __user buf, size_t count, loff_t ppos) </span><br><span class="line">&#123; </span><br><span class="line">return -EBADF; //返回错误 </span><br><span class="line">&#125; </span><br><span class="line">static ssize_t </span><br><span class="line">bad_pipe_w(struct file filp, const char __user buf, size_t count,loff_t ppos) </span><br><span class="line">&#123; </span><br><span class="line">return -EBADF; </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="5、管道通信原理及其亲戚通信解析"><a href="#5、管道通信原理及其亲戚通信解析" class="headerlink" title="5、管道通信原理及其亲戚通信解析"></a>5、<strong>管道通信原理及其亲戚通信解析</strong></h2><h3 id="5-1父子进程通信解析"><a href="#5-1父子进程通信解析" class="headerlink" title="5.1父子进程通信解析"></a>5.1<strong>父子进程通信解析</strong></h3><p><strong>我们只介绍了pipe函数接口，至今尚看不出来该如何使用pipe函数进行进程间通信。调用pipe之后，进程发生了什么呢？请看图9-5</strong>。</p>
<p><img src="https://pic3.zhimg.com/80/v2-96b1020e08c5ee4afd1da7dd51bf43b6_720w.webp" alt="img"></p>
<p>可以看到，调用pipe函数之后，系统给进程分配了两个文件描述符，即pipe函数返回的两个描述符。该进程既可以往写入端描述符写入信息，也可以从读取端描述符读出信息。可是一个进程管道，起不到任何通信的作用。这不是通信，而是自言自语。<br>如果调用pipe函数的进程随后调用fork函数，创建了子进程，情况就不一样了。fork以后，子进程复制了父进程打开的文件描述符（如图9-6所示），两条通信的通道就建立起来了。此时，可以是父进程往管道里写，子进程从管道里面读；也可以是子进程往管道里写，父进程从管道里面读。这两条通路都是可选的，但是不能都选。<strong>原因前面介绍过，管道里面是字节流，父子进程都写、都读，就会导致内容混在一起，对于读管道的一方，解析起来就比较困难</strong>。常规的使用方法是父子进程一方只能写入，另一方只能读出，管道变成一个单向的通道，以方便使用。如图9-7所示，父进程放弃读，子进程放弃写，变成父进程写入，子进程读出，成为一个通信的通道…</p>
<p><img src="https://pic3.zhimg.com/80/v2-0395cc21e8cf14f00477245e3e5b638e_720w.webp" alt="img"></p>
<ul>
<li><strong>父进程如何放弃读，子进程又如何放弃写</strong>？其实很简单，父进程把读端口pipefd[0]这个文件描述符关闭掉，子进程把写端口pipefd[1]这个文件描述符关闭掉就可以了，示例代码如下：</li>
</ul>
<figure class="highlight text"><table><tr><td class="code"><pre><span class="line">int pipefd[2]; </span><br><span class="line">pipe(pipefd); </span><br><span class="line">switch(fork()) </span><br><span class="line">&#123; </span><br><span class="line">case -1: </span><br><span class="line">/fork failed, error handler here/ </span><br><span class="line">case 0: /子进程/ </span><br><span class="line">close(pipefd[1]) ; /关闭掉写入端对应的文件描述符/ </span><br><span class="line">/子进程可以对pipefd[0]调用read/ </span><br><span class="line">break； </span><br><span class="line">default: /父进程/ </span><br><span class="line">close(pipefd[0]); /父进程关闭掉读取端对应的文件描述符/ </span><br><span class="line">/父进程可以对pipefd[1]调用write, 写入想告知子进程的内容/ </span><br><span class="line">break </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><img src="https://pic4.zhimg.com/80/v2-c773670f4666bf0aab36d630d88562eb_720w.webp" alt="img"></p>
<h3 id="5-2亲缘关系的进程管道通信解析"><a href="#5-2亲缘关系的进程管道通信解析" class="headerlink" title="5.2亲缘关系的进程管道通信解析"></a>5.2<strong>亲缘关系的进程管道通信解析</strong></h3><ul>
<li>图9-8也讲述了如何在兄弟进程之间通过管道通信。如图9-8所示，父进程再次创建一个子进程B，子进程B就持有管道写入端，这时候两个子进程之间就可以通过管道通信了。父进程为了不干扰两个子进程通信，很自觉地关闭了自己的写入端。从此管道成为了两个子进程之间的单向的通信通道。在shell中执行管道命令就是这种情景，只是略有特殊之处，其特殊的地方是管道描述符占用了标准输入和标准输出两个文件描述符</li>
</ul>
<p><img src="https://pic2.zhimg.com/80/v2-c5b7f0c17357dc449edd3596133e2c49_720w.webp" alt="img"></p>
<h2 id="6、管道的注意事项及其性质"><a href="#6、管道的注意事项及其性质" class="headerlink" title="6、管道的注意事项及其性质"></a>6、<strong>管道的注意事项及其性质</strong></h2><h3 id="6-1管道有以下三条性质"><a href="#6-1管道有以下三条性质" class="headerlink" title="6.1管道有以下三条性质"></a>6.1<strong>管道有以下三条性质</strong></h3><ul>
<li>只有当所有的写入端描述符都已经关闭了，而且管道中的数据都被读出，对读取描述符调用read函数才返回0（及读到EOF标志）。</li>
<li>如果所有的读取端描述符都已经关闭了，此时进程再次往管道里面写入数据，写操作将会失败，并且内核会像进程发送一个SIGPIPE信号(默认杀死进程)。</li>
<li>当所有的读端与写端都已经关闭时，管道才会关闭.</li>
<li><strong>就因为有这些特性，我们要即使关闭没用的管道文件描述符</strong></li>
</ul>
<h3 id="6-2shell管道的实现"><a href="#6-2shell管道的实现" class="headerlink" title="6.2shell管道的实现"></a>6.2<strong>shell管道的实现</strong></h3><ul>
<li>shell编程会大量使用管道，我们经常看到前一个命令的标准输出作为后一个命令的标准输入，来协作完成任务，如图9-9所示。管道是如何做到的呢？<br>兄弟进程可以通过管道来传递消息，这并不稀奇，前面已经图示了做法。<strong>关键是如何使得一个程序的标准输出被重定向到管道中，而另一个程序的标准输入从管道中读取呢？</strong></li>
</ul>
<p><img src="https://pic4.zhimg.com/80/v2-afc1997ad3bb948e98ec7e6c38d8793f_720w.webp" alt="img"></p>
<p><strong>答案就是复制文件描述符。</strong><br>对于第一个子进程，执行dup2之后，标准输出对应的文件描述符1，也成为了管道的写入端。这时候，管道就有了两个写入端，按照前面的建议，需要关闭不相干的写入端，使读取端可以顺利地读到EOF，所以应将刚开始分配的管道写入端的文件描述符pipefd[1]关闭掉。</p>
<figure class="highlight text"><table><tr><td class="code"><pre><span class="line">if(pipefd[1] != STDOUT_FILENO)</span><br><span class="line">&#123;</span><br><span class="line">dup2(pipefd[1],STDOUT_FILENO);</span><br><span class="line">close(pipefd[1]);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>同样的道理,对于第二个子进程,如法炮制:</p>
<figure class="highlight text"><table><tr><td class="code"><pre><span class="line">if(pipefd[0] != STDIN_FILENO)</span><br><span class="line">&#123;</span><br><span class="line">dup2(pipefd[0],STDIN_FILENO);</span><br><span class="line">close(pipefd[0]);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li>简单来说，就是第一个子进程的标准输出被绑定到了管道的写入端，于是第一个命令的输出，写入了管道，而第二个子进程管道将其标准输入绑定到管道的读取端，只要管道里面有了内容，这些内容就成了标准输入。</li>
<li>两个示例代码，为什么要判断管道的文件描述符是否等于标准输入和标准输出呢？原因是，在调用pipe时，进程很可能已经关闭了标准输入和标准输出，调用pipe函数时，内核会分配最小的文件描述符，所以pipe的文件描述符可能等于0或1。在这种情况下，如果没有if判断加以保护，代码就变成了：</li>
</ul>
<figure class="highlight text"><table><tr><td class="code"><pre><span class="line">dup2(1,1);</span><br><span class="line">close(1);</span><br></pre></td></tr></table></figure>

<p>这样的话，第一行代码什么也没做，第二行代码就把管道的写入端给关闭了，于是便无法传递信息了</p>
<h3 id="6-3与shell命令进行通信"><a href="#6-3与shell命令进行通信" class="headerlink" title="6.3与shell命令进行通信"></a>6.3<strong>与shell命令进行通信</strong></h3><p>道的一个重要作用是和外部命令进行通信。在日常编程中，经常会需要调用一个外部命令，并且要获取命令的输出。而有些时候，需要给外部命令提供一些内容，让外部命令处理这些输入。Linux提供了popen接口来帮助程序员做这些事情。<br>就像system函数，即使没有system函数，我们通过fork、exec及wait家族函数一样也可以实现system的功能。但终归是不方便，system函数为我们提供了一些便利。同样的道理，只用pipe函数及dup2等函数，也能完成popen要完成的工作，但popen接口给我们提供了便利。<br>popen接口定义如下：</p>
<figure class="highlight text"><table><tr><td class="code"><pre><span class="line">#include &lt;stdio.h&gt;</span><br><span class="line">FILE *popen(const char *command, const char *type);</span><br><span class="line">int pclose(FILE *stream);</span><br></pre></td></tr></table></figure>

<p>popen函数会创建一个管道，并且创建一个子进程来执行shell，shell会创建一个子进程来执行command。根据type值的不同，分成以下两种情况。<br>如果type是r：command执行的标准输出，就会写入管道，从而被调用popen的进程读到。通过对popen返回的FILE类型指针执行read或fgets等操作，就可以读取到command的标准输出，如图9-10所示。</p>
<p><img src="https://pic1.zhimg.com/80/v2-c08b21beae3b080597b1eb9847e3a5f0_720w.webp" alt="img"></p>
<p>如果type是w：调用popen的进程，可以通过对FILE类型的指针fp执行write、fputs等操作，负责往管道里面写入，写入的内容经过管道传给执行command的进程，作为命令的输入，如图9-11所示</p>
<p><img src="https://pic3.zhimg.com/80/v2-0c6714d4c36f7f4a9c14dcea2915fce2_720w.webp" alt="img"></p>
<p>popen函数成功时，会返回stdio库封装的FILE类型的指针，失败时会返回NULL，并且设置errno。常见的失败有fork失败，pipe失败，或者分配内存失败。</p>
<p>I&#x2F;O结束了以后，可以调用pclose函数来关闭管道，并且等待子进程的退出。尽管popen函数返回的是FILE类型的指针，也不应调用fclose函数来关闭popen函数打开的文件流指针，因为fclose不会等待子进程的退出。pclose函数成功时会返回子进程中shell的终止状态。popen函数和system函数类似，如果command对应的命令无法执行，就如同执行了exit（127）一样。如果发生其他错误，pclose函数则返回-1。可以从errno中获取到失败的原因。</p>
<p>下面给出一个简单的例子，来示范下popen的用法：</p>
<figure class="highlight text"><table><tr><td class="code"><pre><span class="line">#include&lt;stdio.h&gt;</span><br><span class="line">#include&lt;stdlib.h&gt;</span><br><span class="line">#include&lt;unistd.h&gt;</span><br><span class="line">#include&lt;string.h&gt;</span><br><span class="line">#include&lt;errno.h&gt;</span><br><span class="line">#include&lt;sys/wait.h&gt;</span><br><span class="line">#include&lt;signal.h&gt;</span><br><span class="line">#define MAX_LINE_SIZE 8192</span><br><span class="line">void print_wait_exit(int status)</span><br><span class="line">&#123;</span><br><span class="line">    printf(&quot;status = %d\n&quot;,status);</span><br><span class="line">    if(WIFEXITED(status))</span><br><span class="line">    &#123;</span><br><span class="line">        printf(&quot;normal termination,exit status = %d\n&quot;,WEXITSTATUS(status));</span><br><span class="line">    &#125;</span><br><span class="line">    else if(WIFSIGNALED(status))</span><br><span class="line">    &#123;</span><br><span class="line">        printf(&quot;abnormal termination,signal number =%d%s\n&quot;,</span><br><span class="line">                WTERMSIG(status),</span><br><span class="line">#ifdef WCOREDUMP</span><br><span class="line">                WCOREDUMP(status)?&quot;core file generated&quot; : &quot;&quot;);</span><br><span class="line">#else</span><br><span class="line">        &quot;&quot;);</span><br><span class="line">#endif</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">int main(int argc ,char* argv[])</span><br><span class="line">&#123;</span><br><span class="line">    FILE *fp = NULL ;</span><br><span class="line">    char command[MAX_LINE_SIZE],buffer[MAX_LINE_SIZE];</span><br><span class="line">    if(argc != 2 )</span><br><span class="line">    &#123;</span><br><span class="line">        fprintf(stderr,&quot;Usage: %s filename \n&quot;,argv[0]);</span><br><span class="line">        exit(1);</span><br><span class="line">    &#125;</span><br><span class="line">       snprintf(command,sizeof(command),&quot;cat %s&quot;,argv[1]);</span><br><span class="line">    fp = popen(command,&quot;r&quot;);</span><br><span class="line">    if(fp == NULL)</span><br><span class="line">    &#123;</span><br><span class="line">        fprintf(stderr,&quot;popen failed (%s)&quot;,strerror(errno));</span><br><span class="line">        exit(2);</span><br><span class="line">    &#125;</span><br><span class="line">    while(fgets(buffer,MAX_LINE_SIZE,fp) != NULL)</span><br><span class="line">    &#123;</span><br><span class="line">        fprintf(stdout,&quot;%s&quot;,buffer);</span><br><span class="line">    &#125;</span><br><span class="line">    int ret = pclose(fp);</span><br><span class="line">    if(ret == 127 )</span><br><span class="line">    &#123;</span><br><span class="line">        fprintf(stderr,&quot;bad command : %s\n&quot;,command);</span><br><span class="line">        exit(3);</span><br><span class="line">    &#125;</span><br><span class="line">    else if(ret == -1)</span><br><span class="line">    &#123;</span><br><span class="line">        fprintf(stderr,&quot;failed to get child status (%s)\n&quot;,</span><br><span class="line">strerror(errno));</span><br><span class="line">        exit(4);</span><br><span class="line">    &#125;</span><br><span class="line">    else</span><br><span class="line">    &#123;</span><br><span class="line">        print_wait_exit(ret);</span><br><span class="line">    &#125;</span><br><span class="line">    exit(0);</span><br><span class="line">&#125; </span><br></pre></td></tr></table></figure>

<ul>
<li>将文件名作为参数传递给程序，执行cat filename的命令。popen创建子进程来负责执行cat filename的命令，子进程的标准输出通过管道传给父进程，父进程可以通过fgets来读取command的标准输出。</li>
</ul>
<h3 id="6-4system函数与popen函数区别"><a href="#6-4system函数与popen函数区别" class="headerlink" title="6.4system函数与popen函数区别"></a>6.4<strong>system函数与popen函数区别</strong></h3><ul>
<li>popen函数和system有很多相似的地方，但是也有显著的不同。调用system函数时，shell命令的执行被封装在了函数内部，所以若system函数不返回，调用system的进程就不再继续执行。但是popen函数不同，一旦调用popen函数，调用进程和执行command的进程便处于并行状态。然后pclose函数才会关闭管道，等待执行command的进程退出。换句话说，在popen之后，pclose之前，调用popen的进程和执行command的进程是并行的，这种差异带来了两种显著的不同：</li>
<li>在并行期间，调用popen的进程可能会创建其他子进程，所以标准规定popen不能阻塞SIGCHLD信号.这也意味着，popen创建的子进程可能被提前执行的等待操作所捕获。若发生这种情况，调用pclose函数时，已经无法等待command子进程的退出，这种情况下，将返回-1，并且errno为ECHILD。</li>
<li>调用进程和command子进程是并行的，所以标准要求popen不能忽略SIGINT和SIGQUIT信号。如果是从键盘产生的上述信号，那么，调用进程和command子进程都会收到信号。</li>
</ul>
<hr>
<p>版权声明：本文为知乎博主「<a href="https://www.zhihu.com/people/linuxwang-xian-sheng">极致Linux内核</a>」的原创文章，遵循CC 4.0 BY-SA版权协议，转载请附上原文出处链接及本声明。</p>
<p>原文链接：<a href="https://zhuanlan.zhihu.com/p/548003903">https://zhuanlan.zhihu.com/p/548003903</a></p>
]]></content>
      <categories>
        <category>linux-doc 进程管理</category>
      </categories>
      <tags>
        <tag>Linux</tag>
      </tags>
  </entry>
  <entry>
    <title>Linux进程、线程、调度(一)</title>
    <url>/2023/01/15/linux-docs/%E8%BF%9B%E7%A8%8B%E7%AE%A1%E7%90%86/Linux%E8%BF%9B%E7%A8%8B%E3%80%81%E7%BA%BF%E7%A8%8B%E3%80%81%E8%B0%83%E5%BA%A6(%E4%B8%80)/</url>
    <content><![CDATA[<p>希望可以通过本小结 彻底地搞清楚进程生命周期，进程生命周期创建、退出、停止，以及僵尸进程的本质；</p>
<p>进程 是处于执行期的程序以及相关的资源的总称，是操作系统资源分配的单位。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">进程的资源到底包括什么？</span><br><span class="line">1.打开的文件</span><br><span class="line">2.挂起的信号</span><br><span class="line">3.内核的内部数据</span><br><span class="line">4.处理器的状态</span><br><span class="line">5.内存映射的内存地址空间 等等</span><br></pre></td></tr></table></figure>

<p>Linux系统 对线程和进程并不特别区分。线程仅仅被视为一个与其他线程共享某些资源的进程。每个线程都拥有唯一自己的task_struct。</p>
<p>内核调度的对象是根据task_struct结构体。可以说是线程，而不是进程。</p>
<p>不仅仅要有资源，还需要有进程的描述，例如：pid</p>
<h3 id="进程描述符及task-struct"><a href="#进程描述符及task-struct" class="headerlink" title="进程描述符及task_struct"></a>进程描述符及task_struct</h3><p>linux通过task_struct结构体描述一个进程。</p>
<p>mm 成员：描述内存资源<br><br>fs 成员：描述文件系统资源<br><br>files 成员：进程运行时打开了多少文件，fd的数组<br><br>signal 成员：进程接收的信号资源<br></p>
<p><img src="https://user-images.githubusercontent.com/87457873/127093984-949e7c2a-e29b-495f-a88d-437b84008205.png" alt="image"></p>
<p>Linux通过slab分配器分配task_struct结构，只需在栈底创建新的结构，struct thread_info。<br><br>每个任务的thread_info结构在它的内核栈的尾端分配。</p>
<p>pid的数量是有限的</p>
<p>$ cat &#x2F;proc&#x2F;sys&#x2F;kernel&#x2F;pid_max<br><br>32768</p>
<p>task_struct被管理<br><br>形成链表 –&gt; 形成树 –&gt;形成哈希： pid –&gt; task_struct</p>
<p>根据哈希来进行pid检索</p>
<h3 id="Linux进程生命周期（就绪、运行、睡眠、停止、僵死）"><a href="#Linux进程生命周期（就绪、运行、睡眠、停止、僵死）" class="headerlink" title="Linux进程生命周期（就绪、运行、睡眠、停止、僵死）"></a>Linux进程生命周期（就绪、运行、睡眠、停止、僵死）</h3><p><img src="https://user-images.githubusercontent.com/87457873/127104656-fbe9cbad-c4bf-4ba2-9635-f502240198b8.png" alt="image"></p>
<h3 id="进程、线程、协程"><a href="#进程、线程、协程" class="headerlink" title="进程、线程、协程"></a>进程、线程、协程</h3><p>在linux系统里，进程和线程都是通过task_struct结构体来描述。<br>进程之间不共享地址空间，而线程与创建它的进程是共享地址空间的。</p>
<p>线程又分为：内核线程、用户级线程和 协程。</p>
<p>对于I&#x2F;O密集型场景，就算开多个线程来处理，也未必能提升CPU的利用率，反而会增加线程切换的开销。</p>
<p>此外，多线程之间如果存在临界区或者共享数据，那么同步的开销也不容忽视。</p>
<p>而协程就是用来解决这个问题的，一个用户线程上可以跑多个协程，以此提升单核的利用率。</p>
<p>tips: Linux中对进程和线程创建的几个系统调用发现， 创建时最终都会调用do_fork()函数，不同之处是传入的参数不同(clone_flags)，最终结果就是进程有独立的地址空间和栈 ，而用户线程 可以自己制定用户栈，地址空间和父进程共享，内核线程则 只有和内核共享的一个栈，同一个地址空间。 不管是进程还是线程，do_fork最终会创建一个task_struct结构。</p>
<h3 id="什么是僵尸进程？"><a href="#什么是僵尸进程？" class="headerlink" title="什么是僵尸进程？"></a>什么是僵尸进程？</h3><p>僵尸是子进程死了，资源已经释放。所以不可能有内存泄漏等。但是父进程还没有来得及去wait回收它。task_struct 还在，父进程可以查到子进程的死因。</p>
<p>kill -9 僵尸进程，无效。 [a.out]&lt; defunct&gt; Z+</p>
<p>僵尸进程是一个特别短暂的状态。</p>
<h3 id="停止状态与作业控制，cpulimit"><a href="#停止状态与作业控制，cpulimit" class="headerlink" title="停止状态与作业控制，cpulimit"></a>停止状态与作业控制，cpulimit</h3><p>Linux在早期使用cpulimit 进行 cpu利用率控制。<br><br>cpulimit 限制进程 CPU利用率的原理如上，利用进程的停止态。但是不是精确的。<br></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">cpulimit -l 10 -p 12296  把进程12296CPU使用率控制在 10%以内</span><br><span class="line">cpulimit -l 40 -p 12296</span><br></pre></td></tr></table></figure>
<p>ctrl+z ，fg&#x2F;bg</p>
<h3 id="进程的睡眠"><a href="#进程的睡眠" class="headerlink" title="进程的睡眠"></a>进程的睡眠</h3><p><img src="https://user-images.githubusercontent.com/87457873/127094157-01f55c77-f53b-4b59-97b8-7f69347227c2.png" alt="image"></p>
<p>深睡眠 和 浅睡眠，都是自发的。停止态是被动的。</p>
<p>深：必须等到资源才能wake_up.<br><br>浅：除了被资源wake_up，还可以被信号唤醒。</p>
<p>睡眠是主动的，暂停是人为的信号控制，属于作业控制。深度睡眠，只能在内核中进入。</p>
<p>睡眠态等到资源后，为什么不能直接进入运行态？<br><br>进程醒来后，优先级不一定是最高的。醒来后，先就绪。</p>
<p>执行应用程序代码段发生page fault，代码段还没有进内存。接下来，要从硬盘中读到内存，此时，会把进程设置到深度睡眠。<br>为什么？<br><br>发生两次pagefault，非常难控制。</p>
<p>进程的睡眠实现，依赖内核数据结构wait queue。类似设计模式的，发布者和订阅者。</p>
<p>进程P1,P2,P3,P4 把自己放在等待队列，资源来了只需要唤醒等待队列。等待队列类似订阅消息的中间媒介</p>
<h3 id="初见fork"><a href="#初见fork" class="headerlink" title="初见fork"></a>初见fork</h3><figure class="highlight c"><table><tr><td class="code"><pre><span class="line">main()</span><br><span class="line">&#123;</span><br><span class="line">	fork();</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;hello\n&quot;</span>);</span><br><span class="line">    fork();</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;hello\n&quot;</span>);</span><br><span class="line">    <span class="keyword">while</span>(<span class="number">1</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="内存泄漏的真实含义"><a href="#内存泄漏的真实含义" class="headerlink" title="内存泄漏的真实含义"></a>内存泄漏的真实含义</h3><p>内存泄漏，不是（进程死了，内存没释放），而是，进程活着，运行越久，耗费内存越多。</p>
<p>如何观察 内存泄漏？</p>
<p>连续多点观察法。</p>
]]></content>
      <categories>
        <category>linux-doc 进程管理</category>
      </categories>
      <tags>
        <tag>Linux</tag>
      </tags>
  </entry>
  <entry>
    <title>Linux进程、线程、调度(三)</title>
    <url>/2023/01/15/linux-docs/%E8%BF%9B%E7%A8%8B%E7%AE%A1%E7%90%86/Linux%E8%BF%9B%E7%A8%8B%E3%80%81%E7%BA%BF%E7%A8%8B%E3%80%81%E8%B0%83%E5%BA%A6(%E4%B8%89)/</url>
    <content><![CDATA[<p>本节主要介绍进程的调度器，设计的目标：吞吐和响应，轮流让其他进程获取CPU资源。</p>
<h3 id="进程调度机制的架构"><a href="#进程调度机制的架构" class="headerlink" title="进程调度机制的架构"></a>进程调度机制的架构</h3><p>操作系统通过中断机制，来周期性地触发调度算法进行进程的切换。</p>
<ul>
<li>rq: 可运行队列，每个CPU对应一个，包含自旋锁，进程数量，用于公平调度的CFS结构体，当前正在运行的进程描述符。</li>
<li>cfs_rq: cfs调度的运行队列信息，包含红黑色的根节点，正在运行的进程指针，用于负载均衡的叶子队列等。</li>
<li>sched_entity: 调度实体，包含负载权重值，对应红黑树节点，虚拟运行时vruntime等。</li>
<li>sched_class: 调度算法抽象成的调度类，包含一组通用的调度操作接口，将接口和实现分离。</li>
</ul>
<p><img src="https://user-images.githubusercontent.com/87457873/127105320-a7646493-0a85-4467-b5a8-f10a5bb96942.png" alt="image"></p>
<p>schedule函数的流程包括：</p>
<p>1、关闭内核抢占，标识cpu状态。通知RCU更新状态，关闭本地终端，获取所要保护的运行队列的自旋锁，为查找可运行进程做准备。<br><br>2、检查prev状态，决定是否将进程插入到运行队列，或者从运行队列中删除。<br><br>3、task_on_rq_queued(prev) : 将pre进程插入到运行队列的队尾。<br><br>4、pick_next_task : 选取下一个将要执行的进程。<br><br>5、context_switch(rq, prev, next) 进行进程上下文切换。<br></p>
<h3 id="CPU-IO消耗型进程"><a href="#CPU-IO消耗型进程" class="headerlink" title="CPU&#x2F;IO消耗型进程"></a>CPU&#x2F;IO消耗型进程</h3><p>吞吐 vs. 响应</p>
<ul>
<li>响应：最小化某个任务的响应时间，哪怕牺牲其他的任务为代价。</li>
<li>吞吐：全局视野，整个系统的workload被最大化处理。</li>
<li>任何操作系统的调度器设计只追求2个目标：吞吐率大和延迟低。这2个目标有点类似零和游戏，因为吞吐率要大，势必要把更多的时间放在做真实的有用功，而不是把时间浪费在频繁的进程上下文切换；而延迟要低，势必要求优先级高的进程可以随时抢占进来，打断别人，强行插队。但是，抢占会引起上下文切换，上下文切换的时间本身对吞吐率来讲，是一个消耗，这个消耗可以低到2us或者更低（这看起来没什么？），但是上下文切换更大的消耗不是切换本身，而是切换会引起大量的cache miss。你明明weibo跑的很爽，现在切过去微信，那么CPU的cache是不太容易命中微信的。</li>
</ul>
<p>操作系统中估算”上下文切换”对吞吐能力影响时，不是计算上下文切换本身，而是在CPU 高速cache中的miss。一旦从一个进程切到另一个进程，会造成比较多的cache miss，从而影响吞吐能力。</p>
<p>在内核编译的时候，Kernel Features —&gt; Preemption Model选项实际上可以让我们编译内核的时候，是倾向于支持吞吐，还是支持响应</p>
<p>preemption model：选择内核的抢占模型，影响调度算法<br><br>1、No Forced Preemption （Server）： 不强制抢占，更在意吞吐，支撑比较大的连接等。<br><br>2、Voluntary kernel preemption (Desktop)： 内核不能抢占。<br><br>3、Preemtible Kernel（low-latency desktop）： 内核都可以抢占，更在意响应，滑动触摸屏等操作需要立刻响应。</p>
<p>I&#x2F;O消耗型 vs. CPU消耗型</p>
<ul>
<li>IO bound： CPU利用率低，进程的运行效率主要受限于I&#x2F;O速度；</li>
<li>tips: IO 消耗型对拿到CPU(延迟)比较敏感，应该被优先调度。一般需要CPU的响应速度快，即优先级要求比较高。</li>
<li>CPU bound： 多数时间花在CPU上面（做运算）；</li>
</ul>
<h3 id="调度算法：-策略-优先级"><a href="#调度算法：-策略-优先级" class="headerlink" title="调度算法： 策略 + 优先级"></a>调度算法： 策略 + 优先级</h3><p>早期2.6调度器：优先级数组 和 Bitmaps</p>
<ul>
<li>0～ 139： 在内核空间， 把整个Linux优先级划分为0～139，数字越小，优先级越高。用户空间设置时，是反过来的。<br></li>
<li>某个优先级有TASK_RUNNING进程，响应bit设置1。<br></li>
<li>调度第一个bitmap设置为1的进程</li>
</ul>
<p><img src="https://user-images.githubusercontent.com/87457873/127105805-547271f8-e1d5-4236-a7dc-4bb0d6ef51ca.png" alt="image"></p>
<h4 id="SCHED-FIFO、SCHED-RR"><a href="#SCHED-FIFO、SCHED-RR" class="headerlink" title="SCHED_FIFO、SCHED_RR"></a>SCHED_FIFO、SCHED_RR</h4><p>实时（RT）进程调度策略： 0～99采用的RT，100～139是非RT的。</p>
<ul>
<li>SCHED_FIFO： 不同优先级按照优先级高的先跑到睡眠，优先级低的再跑；同等优先级先进先出。</li>
<li>SCHED_RR：不同优先级按照优先级高的先跑到睡眠，优先级低的再跑；同等优先级轮转。</li>
</ul>
<p><img src="https://user-images.githubusercontent.com/87457873/127105885-b0cf808e-2d8e-4dfc-82a3-cf1fdcd1486f.png" alt="image"></p>
<p>当所有的SCHED_FIFO和SCHED_RR都运行至睡眠态，就开始运行 100～139之间的 普通task_struct。这些进程讲究 nice，</p>
<h4 id="SCHED-NORMAL"><a href="#SCHED-NORMAL" class="headerlink" title="SCHED_NORMAL"></a>SCHED_NORMAL</h4><p><strong>非实时进程的调度和动态优先级：</strong></p>
<p>早期内核2.6的调度器，100对应nice值为 -20，139对应nice值为19。对于普通进程，优先级高不会形成对优先级低的绝对优势，并不会阻塞优先级低的进程拿到时间片。<br><br>普通进程在不同优先级之间进行轮转，nice值越高，优先级越低。此时优先级的具体作用是：</p>
<p>1、时间片。优先级高的进程可以得到更多时间片。<br><br>2、抢占。从睡眠状态到醒来，可以优先去抢占优先级低的进程。<br><br><strong>Linux根据睡眠情况，动态奖励和惩罚。</strong> 越睡，优先级越高。想让CPU消耗型进程和IO消耗型进程竞争时，IO消耗型的进程可以竞争过CPU消耗型。</p>
<h4 id="rt的门限"><a href="#rt的门限" class="headerlink" title="rt的门限"></a>rt的门限</h4><p>Linux内核在period的时间里RT最多只能跑runtime的时间。<br><br>在参数 &#x2F;proc&#x2F;sys&#x2F;kernel&#x2F;sched_rt_period_us 和 &#x2F;proc&#x2F;sys&#x2F;kernel&#x2F;sched_rt_runtime_us 中设置。单位：微秒。</p>
<h4 id="CFS-完全公平调度"><a href="#CFS-完全公平调度" class="headerlink" title="CFS 完全公平调度"></a>CFS 完全公平调度</h4><p>后期，Linux对普通进程调度，提供了 完全公平调度算法，每次都会调vruntime最小的进程调度。</p>
<p>红黑树，左边节点小于右边节点的值，运行到目前为止 （vruntime最小）的进程，同时考虑了CPU&#x2F;IO和nice。</p>
<p><img src="https://user-images.githubusercontent.com/87457873/127106097-30790100-6fa1-4af4-ba7a-bc4e7ce0c336.png" alt="image"></p>
<p><img src="https://user-images.githubusercontent.com/87457873/127106110-7eb7a50d-fdcd-45f2-9919-9a4ec58061fc.png" alt="image"></p>
<p>vruntime: virtual runtime，＝ pruntime&#x2F;weight 权重* 系数。</p>
<p>随着时间运行，分子pruntime变大，vruntime也就变大，优先级变低。喜欢睡眠、IO消耗型的进程，分子小。nice值低的，分母大。但是RT的进程，优先级高于所有普通的进程。</p>
<p>红黑树实现的CFS，用分子pruntime来照顾 睡眠情况，用分母来照顾nice值。</p>
<p>当进程里fork了多个线程，每个线程的 调度策略都可以不同，优先级可以不同。原因显然。</p>
<h4 id="工具-chrt-和-renice"><a href="#工具-chrt-和-renice" class="headerlink" title="工具 chrt 和 renice"></a>工具 chrt 和 renice</h4><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;pthread.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/types.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">void</span> *<span class="title function_">thread_fun</span><span class="params">(<span class="type">void</span> *param)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;thread pid:%d, tid:%lu\n&quot;</span>, getpid(), pthread_self());</span><br><span class="line">    <span class="keyword">while</span> (<span class="number">1</span>) ;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">(<span class="type">void</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">pthread_t</span> tid1, tid2;</span><br><span class="line">    <span class="type">int</span> ret;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;main pid:%d, tid:%lu\n&quot;</span>, getpid(), pthread_self());</span><br><span class="line">    ret = pthread_create(&amp;tid1, <span class="literal">NULL</span>, thread_fun, <span class="literal">NULL</span>);</span><br><span class="line">    <span class="keyword">if</span> (ret == <span class="number">-1</span>) &#123;</span><br><span class="line">        perror(<span class="string">&quot;cannot create new thread&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    ret = pthread_create(&amp;tid2, <span class="literal">NULL</span>, thread_fun, <span class="literal">NULL</span>);</span><br><span class="line">    <span class="keyword">if</span> (ret == <span class="number">-1</span>) &#123;</span><br><span class="line">        perror(<span class="string">&quot;cannot create new thread&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (pthread_join(tid1, <span class="literal">NULL</span>) != <span class="number">0</span>) &#123;</span><br><span class="line">        perror(<span class="string">&quot;call pthread_join function fail&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (pthread_join(tid2, <span class="literal">NULL</span>) != <span class="number">0</span>) &#123;</span><br><span class="line">        perror(<span class="string">&quot;call pthread_join function fail&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="number">1.</span>编译two-loops.c, gcc two-loops.c -pthread，运行两份</span><br><span class="line">root@whale:~/develop$ gcc two-loops.c -pthread</span><br><span class="line">root@whale:~/develop$ ./a.out &amp;</span><br><span class="line">[<span class="number">1</span>] <span class="number">13682</span></span><br><span class="line">root@whale:~/develop$ main pid:<span class="number">13682</span>, tid:<span class="number">3075434240</span></span><br><span class="line">thread pid:<span class="number">13682</span>, tid:<span class="number">3067038528</span></span><br><span class="line">thread pid:<span class="number">13682</span>, tid:<span class="number">3075431232</span></span><br><span class="line"></span><br><span class="line">root@whale:~/develop$ ./a.out &amp;</span><br><span class="line">[<span class="number">2</span>] <span class="number">13685</span></span><br><span class="line">root@whale:~/develop$</span><br><span class="line">main pid:<span class="number">13685</span>, tid:<span class="number">3075925760</span></span><br><span class="line">thread pid:<span class="number">13685</span>, tid:<span class="number">3067530048</span></span><br><span class="line">thread pid:<span class="number">13685</span>, tid:<span class="number">3075922752</span> </span><br><span class="line"></span><br><span class="line">##<span class="meta"># top命令观察CPU利用率：</span></span><br><span class="line">    <span class="number">13682</span> root   <span class="number">20</span>   <span class="number">0</span>   <span class="number">18684</span>    <span class="number">616</span>    <span class="number">552</span> S  <span class="number">98.4</span>  <span class="number">0.0</span>   <span class="number">1</span>:<span class="number">12.09</span> a.out</span><br><span class="line">    <span class="number">13685</span>  root    <span class="number">20</span>   <span class="number">0</span>   <span class="number">18684</span>    <span class="number">644</span>    <span class="number">580</span> S  <span class="number">98.1</span>  <span class="number">0.0</span>   <span class="number">1</span>:<span class="number">07.32</span> a.out  </span><br><span class="line">    </span><br><span class="line">##<span class="meta"># renice其中之一，再观察CPU利用率</span></span><br><span class="line">    </span><br><span class="line">    sudo renice -n <span class="number">-5</span> -g <span class="number">13682</span></span><br><span class="line"></span><br><span class="line">      PID USER      PR  NI    VIRT    RES    SHR S  %CPU %MEM     TIME+ COMMAND</span><br><span class="line">    <span class="number">13682</span>  root    <span class="number">15</span>  <span class="number">-5</span>   <span class="number">18684</span>    <span class="number">616</span>    <span class="number">552</span> S <span class="number">147.4</span>  <span class="number">0.0</span>   <span class="number">4</span>:<span class="number">52.73</span> a.out</span><br><span class="line">    <span class="number">13685</span>  root     <span class="number">20</span>   <span class="number">0</span>   <span class="number">18684</span>    <span class="number">644</span>    <span class="number">580</span> S  <span class="number">48.6</span>  <span class="number">0.0</span>   <span class="number">4</span>:<span class="number">12.77</span> a.out</span><br><span class="line">    </span><br><span class="line">killall a.out</span><br><span class="line"></span><br><span class="line"><span class="number">2.</span>编译two-loops.c, gcc two-loops.c -pthread，运行一份</span><br><span class="line">top发现其CPU利用率接近<span class="number">200</span>%</span><br><span class="line">-f：把它的所有线程设置为SCHED_FIFO</span><br><span class="line">-a : 所有线程</span><br><span class="line"></span><br><span class="line">  chrt -f -a -p <span class="number">50</span> 进程PID</span><br><span class="line">  </span><br><span class="line">再观察它的CPU利用率</span><br><span class="line"></span><br><span class="line">答：CPU利用率会下降，rt的限制，<span class="number">1</span>s中只能占<span class="number">0.95</span>。</span><br><span class="line">此时虽然CPU使用率下降，但是服务器的响应更慢了。因为鼠标等应用的优先级没有a.out 这个进程的优先级高。</span><br><span class="line"></span><br></pre></td></tr></table></figure>


]]></content>
      <categories>
        <category>linux-doc 进程管理</category>
      </categories>
      <tags>
        <tag>Linux</tag>
      </tags>
  </entry>
  <entry>
    <title>Linux进程、线程、调度(二)</title>
    <url>/2023/01/15/linux-docs/%E8%BF%9B%E7%A8%8B%E7%AE%A1%E7%90%86/Linux%E8%BF%9B%E7%A8%8B%E3%80%81%E7%BA%BF%E7%A8%8B%E3%80%81%E8%B0%83%E5%BA%A6(%E4%BA%8C)/</url>
    <content><![CDATA[<h3 id="fork-、vfork、clone"><a href="#fork-、vfork、clone" class="headerlink" title="fork 、vfork、clone"></a>fork 、vfork、clone</h3><p><img src="https://user-images.githubusercontent.com/87457873/127104795-7ec16416-cbee-4022-a36d-84de40a5e229.png" alt="image"></p>
<p>Linux 内核的调度算法，是根据task_struct结构体来进行调度的。</p>
<h3 id="写时拷贝技术"><a href="#写时拷贝技术" class="headerlink" title="写时拷贝技术"></a>写时拷贝技术</h3><p>当p1把p2创建出来时，会把task_struct里描述的资源结构体对拷给p2。<br><br>区分进程的标志，就是 p2的资源不是p1的资源。两个task_struct 的资源都相同，那就不叫两个进程了。</p>
<p>执行一个copy，但是任何修改都造成分裂，如：chroot,open，写memory，<br><br>最难copy的是 mm 这个部分，因为要做写时拷贝。</p>
<p>Linux通过MMU进行虚拟地址到物理地址的转换，当进程执行fork()后，会把页表中的权限设置为RD-ONLY，当P1,P2去写该页时，CPU会收到page fault，申请新的内存。Linux再将页表中的virt1指向新的物理地址。</p>
<p><img src="https://user-images.githubusercontent.com/87457873/127104867-e304952e-ff6c-4094-8bd0-f2992277ed06.png" alt="image"></p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sched.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="type">int</span> data = <span class="number">10</span>;</span><br><span class="line"><span class="type">int</span> <span class="title function_">child_process</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;Child process %d, data %d\n&quot;</span>,getpid(),data);</span><br><span class="line">    data = <span class="number">20</span>;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;Child process %d, data %d\n&quot;</span>,getpid(),data);</span><br><span class="line">    _exit(<span class="number">0</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">(<span class="type">int</span> argc, <span class="type">char</span>* argv[])</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">int</span> pid;</span><br><span class="line">    pid = fork();</span><br><span class="line">    <span class="keyword">if</span>(pid==<span class="number">0</span>) &#123;</span><br><span class="line">        child_process();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span>&#123;</span><br><span class="line">        sleep(<span class="number">1</span>);</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;Parent process %d, data %d\n&quot;</span>,getpid(), data);</span><br><span class="line">        <span class="built_in">exit</span>(<span class="number">0</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>CoW，严重依赖CPU的MMU。Mmu-less Linux 无copy-on-write, 没有fork，而使用vfork。</p>
<p>使用vfork：父进程p1 vfork出子进程p2之后阻塞，直到子进程发生以下两种情况。<br><br>1） exit<br><br>2） exec<br></p>
<p><img src="https://user-images.githubusercontent.com/87457873/127104939-ee0a4312-0921-4c47-b047-5ec659634140.png" alt="image"></p>
<p>进程执行vfork时，P2的task_struct中的*mm 与 P1共享，P1的内存资源就是P2的内存资源。</p>
<p>pthread_create -&gt; clone</p>
<p><img src="https://user-images.githubusercontent.com/87457873/127104959-d6f13b93-095f-4bda-b5dc-7c239ae69e34.png" alt="image"></p>
<p>Linux创建线程的API，本质上去调 clone。要求把P2的所有资源的指针，都指向P1。线程，也被称为 Light weight process。</p>
<p>而Linux在clone线程时也十分灵活，可以选择共享&#x2F;不共享部分资源。</p>
<p><img src="https://user-images.githubusercontent.com/87457873/127104969-6a37ba07-0291-4e63-9503-324d37cf00ff.png" alt="image"></p>
<p>POSIX标准要求，进程里面如果有多个线程，在用户空间 getpid() 看到的都是同一个id，这个id其实是TGID。</p>
<p>一个进程里面创建了多个线程，在&#x2F;proc 下 的是 tgid，&#x2F;proc&#x2F;tgid&#x2F;task&#x2F;{pidx,y,z}</p>
<p>pthread_self() 看到的是用户空间pthread线程库里获得的id 。</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;pthread.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;linux/unistd.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/syscall.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">static</span> <span class="type">pid_t</span> <span class="title function_">gettid</span><span class="params">( <span class="type">void</span> )</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">return</span> syscall(__NR_gettid);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">static</span> <span class="type">void</span> *<span class="title function_">thread_fun</span><span class="params">(<span class="type">void</span> *param)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;thread pid:%d, tid:%d pthread_self:%lu\n&quot;</span>, getpid(), gettid(),pthread_self());</span><br><span class="line">    <span class="keyword">while</span>(<span class="number">1</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">(<span class="type">void</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">pthread_t</span> tid1, tid2;</span><br><span class="line">    <span class="type">int</span> ret;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;thread pid:%d, tid:%d pthread_self:%lu\n&quot;</span>, getpid(), gettid(),pthread_self());</span><br><span class="line">    ret = pthread_create(&amp;tid1, <span class="literal">NULL</span>, thread_fun, <span class="literal">NULL</span>);</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">if</span> (ret == <span class="number">-1</span>) &#123;</span><br><span class="line">        perror(<span class="string">&quot;cannot create new thread&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    ret = pthread_create(&amp;tid2, <span class="literal">NULL</span>, thread_fun, <span class="literal">NULL</span>);</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">if</span> (ret == <span class="number">-1</span>) &#123;</span><br><span class="line">        perror(<span class="string">&quot;cannot create new thread&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (pthread_join(tid1, <span class="literal">NULL</span>) != <span class="number">0</span>) &#123;</span><br><span class="line">        perror(<span class="string">&quot;call pthread_join function fail&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (pthread_join(tid2, <span class="literal">NULL</span>) != <span class="number">0</span>) &#123;</span><br><span class="line">        perror(<span class="string">&quot;call pthread_join function fail&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">gcc thread.c -pthread</span><br></pre></td></tr></table></figure>
<h3 id="总结-fork-vfork-clone"><a href="#总结-fork-vfork-clone" class="headerlink" title="总结 fork , vfork, clone"></a>总结 fork , vfork, clone</h3><p>由于执行fork()引入了 写时拷贝并且明确了子进程先执行，所以 vfork()的好处就仅限于不拷贝父进程的页表项mm_struct。vfork()系统调用的实现是通过向clone()系统调用传递一个特殊标志来进行。</p>
<p>vfork场景下父进程会先休眠，等唤醒子进程后，再唤醒父进程。</p>
<p>这么做的好处是：由于子进程被创建出来，与父进程共享地址空间，且只读。只有在执行exec的创建新的内存映射时才会拷贝父进程的数据，来创建新的地址空间。如果此时，父进程还在执行，就有可能产生脏数据，或发生死锁。</p>
<h3 id="进程0和进程1"><a href="#进程0和进程1" class="headerlink" title="进程0和进程1"></a>进程0和进程1</h3><p>init进程是被Linux 0进程创建，0进程把init进程fork出来后，就退化成IDLE进程。这个进程，是特殊调度类，所有进程都停止或睡眠后，就会调度进程0运行，此时处于CPU低功耗状态。</p>
<h3 id="孤儿进程与托孤，subreaper"><a href="#孤儿进程与托孤，subreaper" class="headerlink" title="孤儿进程与托孤，subreaper"></a>孤儿进程与托孤，subreaper</h3><p><img src="https://user-images.githubusercontent.com/87457873/127105118-3de38b9e-1d18-46b9-b189-afe098ec47da.png" alt="image"></p>
<p>当父进程退出后，子进程会寻找subreaper 或 init进程。</p>
]]></content>
      <categories>
        <category>linux-doc 进程管理</category>
      </categories>
      <tags>
        <tag>Linux</tag>
      </tags>
  </entry>
  <entry>
    <title>Linux进程、线程、调度(四)</title>
    <url>/2023/01/15/linux-docs/%E8%BF%9B%E7%A8%8B%E7%AE%A1%E7%90%86/Linux%E8%BF%9B%E7%A8%8B%E3%80%81%E7%BA%BF%E7%A8%8B%E3%80%81%E8%B0%83%E5%BA%A6(%E5%9B%9B)/</url>
    <content><![CDATA[<p>延续（三）中，调度器的其他内容：关于多核、分群、硬实时</p>
<h3 id="多核下的负载均衡"><a href="#多核下的负载均衡" class="headerlink" title="多核下的负载均衡"></a>多核下的负载均衡</h3><p>Linux 每个CPU可能有多个操作线程，每个核均运行的调度算法是 SCHED_FIFO, SCHED_RR，SCHED_NORMAL(CFS)等，每个核都“以劳动为乐”。</p>
<p>tips: 旧的调度算法是通过+&#x2F;- 5 nice值，来照顾IO型，惩罚CPU型。新的进程调度算法CFS，会根据ptime&#x2F;nice值进行红黑树匹配。</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;pthread.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/types.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">void</span> *<span class="title function_">thread_fun</span><span class="params">(<span class="type">void</span> *param)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;thread pid:%d, tid:%lu\n&quot;</span>, getpid(), pthread_self());</span><br><span class="line">    <span class="keyword">while</span> (<span class="number">1</span>) ;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">(<span class="type">void</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">pthread_t</span> tid1, tid2;</span><br><span class="line">    <span class="type">int</span> ret;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;main pid:%d, tid:%lu\n&quot;</span>, getpid(), pthread_self());</span><br><span class="line">    ret = pthread_create(&amp;tid1, <span class="literal">NULL</span>, thread_fun, <span class="literal">NULL</span>);</span><br><span class="line">    <span class="keyword">if</span> (ret == <span class="number">-1</span>) &#123;</span><br><span class="line">        perror(<span class="string">&quot;cannot create new thread&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    ret = pthread_create(&amp;tid2, <span class="literal">NULL</span>, thread_fun, <span class="literal">NULL</span>);</span><br><span class="line">    <span class="keyword">if</span> (ret == <span class="number">-1</span>) &#123;</span><br><span class="line">        perror(<span class="string">&quot;cannot create new thread&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (pthread_join(tid1, <span class="literal">NULL</span>) != <span class="number">0</span>) &#123;</span><br><span class="line">        perror(<span class="string">&quot;call pthread_join function fail&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (pthread_join(tid2, <span class="literal">NULL</span>) != <span class="number">0</span>) &#123;</span><br><span class="line">        perror(<span class="string">&quot;call pthread_join function fail&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="number">1.</span>编译two-loops.c, gcc two-loops.c -pthread，运行:</span><br><span class="line">$ time ./a.out </span><br><span class="line">main pid:<span class="number">14958</span>, tid:<span class="number">3075917568</span></span><br><span class="line">thread pid:<span class="number">14958</span>, tid:<span class="number">3067521856</span></span><br><span class="line">thread pid:<span class="number">14958</span>, tid:<span class="number">3075914560</span></span><br><span class="line">^C</span><br><span class="line"></span><br><span class="line">real	<span class="number">1</span>m10<span class="number">.050</span>s</span><br><span class="line">user	<span class="number">2</span>m20<span class="number">.016</span>s</span><br><span class="line">sys	<span class="number">0</span>m0<span class="number">.004</span>s </span><br><span class="line"></span><br><span class="line">* 我们得到时间分布比例，理解<span class="number">2</span>个死循环被均分到<span class="number">2</span>个core。</span><br><span class="line">* (user+sys)/<span class="number">2</span>=real ，原因：两个线程被Linux自动分配到两个核上，但是两个线程可能随机分配到任意CPU上运行。</span><br></pre></td></tr></table></figure>
<ul>
<li>RT进程（task_struct）： 保证N个优先级最高的RT分布到N个核<br>pull_rt_task()<br><br>push_rt_task()</li>
</ul>
<p>RT的进程，更多强调的是实时性，因为优先级大于Normal 进程。例如，4核CPU，有8个RT的进程，会优先找其中4个优先级最高的让他们运行到4个核上。</p>
<ul>
<li>普通进程：<br>周期性负载均衡： 当操作系统的时钟节拍来临，会查这个核是否空闲，旁边一个核是否忙，当旁边的核忙到一定程度，会自动从旁边较忙的CPU核上，pull task过来。<br><br>IDLE时负载均衡： 当CPU IDLE为0，会从旁边的CPU核上pull task。<br><br>fork和exec时负载均衡：fork时会创建一个新的task_struct，会把这个task_struct放在最空闲的核上运行。<br><br>总结：每个核通过push&#x2F;pull task来实现任务的负载均衡。所以，Linux上运行的多线程，可能会“动态”的出现在各个不同的CPU核上。</li>
</ul>
<h3 id="设置-CPU-task-affinity"><a href="#设置-CPU-task-affinity" class="headerlink" title="设置 CPU task affinity"></a>设置 CPU task affinity</h3><p>程序员通过设置 affinity，即设置某个线程跟哪个CPU更亲和。<br><br>内核API提供了两个系统调用，让用户可以修改位掩码或查看当前的位掩码。<br><br>而该位掩码 , 正是对应 进程task_struct数据结构中的cpus_allowed属性，与cpu的每个逻辑核心一一对应。</p>
<p><img src="https://user-images.githubusercontent.com/87457873/127106385-d594a83f-d399-4cf3-b2a8-59a47c674e40.png" alt="image"></p>
<p>上图 np代表 none posix，比如电脑有7个核，但线程只想在第1、2个核上运行。就把cpu_set_t设置为 0x6，代表 110。如果线程只想在第2个核上，就设置为 0x4。</p>
<p>还可以通过 taskset工具 设置进程的线程在哪个CPU上跑。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">2. 编译two-loops.c, gcc two-loops.c -pthread，运行一份</span><br><span class="line">top发现其CPU利用率接近200%</span><br><span class="line"></span><br><span class="line">把它的所有线程affinity设置为01, 02, 03后分辨来看看CPU利用率</span><br><span class="line"></span><br><span class="line"> taskset -a -p 02 进程PID</span><br><span class="line"> taskset -a -p 01 进程PID</span><br><span class="line"> taskset -a -p 03 进程PID</span><br><span class="line"> </span><br><span class="line">前两次设置后，a.out CPU利用率应该接近100%，最后一次接近200%</span><br><span class="line"></span><br><span class="line">03代表，第1个或第2个CPU核上运行。</span><br><span class="line">-a 代表 进程下的所有线程。</span><br><span class="line"></span><br><span class="line">运行结果：前两次，a.out程序CPU的使用率均为100%，第3次，a.out程序CPU的使用率为200%。</span><br></pre></td></tr></table></figure>

<h3 id="中断负载均衡、RPS软中断负载均衡"><a href="#中断负载均衡、RPS软中断负载均衡" class="headerlink" title="中断负载均衡、RPS软中断负载均衡"></a>中断负载均衡、RPS软中断负载均衡</h3><p>IRQ affinity</p>
<p>中断也可以负载均衡，Linux每个中断号下面smp_affinity。</p>
<ul>
<li>分配IRQ到某个CPU<br>[root@boss ~]# echo 01 &gt; &#x2F;proc&#x2F;irq&#x2F;145&#x2F;smp_affinity<br><br>[root@boss ~]# cat &#x2F;proc&#x2F;irq&#x2F;145&#x2F;smp_affinity<br><br>00000001</li>
</ul>
<p><img src="https://user-images.githubusercontent.com/87457873/127106458-2e0bf69f-ae1a-4c82-bb01-7e90704b2d7b.png" alt="image"></p>
<p>比如上图，有个网卡有4个收发队列，分别是 74，75，76，77。把4个网卡收发队列的中断分别设置为01，02，04，08，那么这个网卡4个队列的中断就被均分到4个核上。</p>
<p>但是有些中断不能被负载均衡。比如，一张网卡只有1个队列，8个核。队列上的中断就发到1个核上。网卡中断里，CPU0收到一个中断irq之后，如果在这个irq中调用了soft irq，那么这个soft irq也会运行在CPU0。因为CPU0上中断中调度的软中断，也是会运行在CPU0上。那么这个核上 ，中断的负载和 软中断的负载 均很重，因为TCP&#x2F;IP协议栈的处理，都丢到软中断中，此时网卡的吞吐率肯定上不来。</p>
<p>此时，出现了RPS补丁，实现 多核间的softIRQ 负载均衡</p>
<ul>
<li>RPS将包处理负载均衡到多个CPU</li>
</ul>
<p>[root@whale<del>]# echo fffe &gt; &#x2F;sys&#x2F;class&#x2F;net&#x2F;eth1&#x2F;queues&#x2F;rx-0&#x2F;rps_cpus<br><br>fffe<br><br>[root@whale</del>]# watch -d “cat &#x2F;proc&#x2F;softirqs |grep NET_RX”</p>
<p>每个网卡的队列下面，均有一个文件 rps_cpus， 如果echo fffe到这个文件，就会让某个核上的软中断，负载均衡到0～15个核上。一般来说，CPU0上收到的中断，软中断都会在CPU0。但是CPU0会把收到中断的软中断派发到其他核上，这样其他核也可以处理TCP&#x2F;IP收到的包处理的工作。</p>
<h3 id="cgroups和CPU资源分群分配"><a href="#cgroups和CPU资源分群分配" class="headerlink" title="cgroups和CPU资源分群分配"></a>cgroups和CPU资源分群分配</h3><p>比如，有两个用户在OS上执行编译程序，用户A创建1000个线程，用户B创建32个线程。如果这1010个线程nice值均为0，那么按照CFS的调度算法，用户A可以拿到1000&#x2F;1032的cpu时间片，用户B只能拿到 32&#x2F;1032的cpu时间片。</p>
<p>此时，Linux通过分层调度，把某些task_struct 加到cgroup A，另外的task_struct加到cgroup B , cgroup A和B 先按照某个权重进行CPU的分配，再到不同cgroup里面，按照调度算法进行调度。</p>
<ul>
<li>定义不同cgroup CPU分享的share –&gt; cpu.shares</li>
<li>定义某个cgroup在某个周期里面最多跑多久 –&gt; cpu.cfs_quota_us 和 cpu.cfs_period_us</li>
</ul>
<p>cpu.cfs_period_us：默认100000 us&#x3D; 100ms<br><br>cpu.cfs_quota_us：<br></p>
<p>demo</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">3.编译two-loops.c, gcc two-loops.c -pthread，运行三份</span><br><span class="line">用top观察CPU利用率，大概各自66%。</span><br><span class="line">创建A,B两个cgroup</span><br><span class="line"></span><br><span class="line">  root@whale:/sys/fs/cgroup/cpu$ sudo mkdir A</span><br><span class="line">  root@whale:/sys/fs/cgroup/cpu$ sudo mkdir B</span><br><span class="line"></span><br><span class="line">把3个a.out中的2个加到A，1个加到B。</span><br><span class="line"></span><br><span class="line">此时，发现两个cgroup下的cpu.shares 相同，均为1024.</span><br><span class="line"></span><br><span class="line">然后把两个进程下的所有线程都加入到cgroupA，如果只想加某个线程，则echo pid到tasks文件。</span><br><span class="line"></span><br><span class="line">  root@whale:/sys/fs/cgroup/cpu/A$ sudo sh -c &#x27;echo 14995 &gt; cgroup.procs&#x27;</span><br><span class="line">  root@whale:/sys/fs/cgroup/cpu/A$ sudo sh -c &#x27;echo 14998 &gt; cgroup.procs&#x27;</span><br><span class="line">  root@whale:/sys/fs/cgroup/cpu/A$ cd ..</span><br><span class="line">  root@whale:/sys/fs/cgroup/cpu$ cd B/</span><br><span class="line">  root@whale:/sys/fs/cgroup/cpu/B$ sudo sh -c &#x27;echo 15001 &gt; cgroup.procs&#x27;</span><br><span class="line"></span><br><span class="line">这次发现3个a.out的CPU利用率大概是50%, 50%, 100%。</span><br><span class="line"></span><br><span class="line">杀掉第2个和第3个a.out，然后调整cgroup A的quota，观察14995的CPU利用率变化</span><br><span class="line"></span><br><span class="line">  root@whale:/sys/fs/cgroup/cpu/B$ kill 14998</span><br><span class="line">  root@whale:/sys/fs/cgroup/cpu/B$ kill 15001</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">设置A group的quota为20ms：</span><br><span class="line"></span><br><span class="line">  root@whale:/sys/fs/cgroup/cpu/A$ sudo sh -c &#x27;echo 20000 &gt; cpu.cfs_quota_us&#x27;</span><br><span class="line">  </span><br><span class="line">设置A group的quota为40ms：</span><br><span class="line"></span><br><span class="line">  root@whale:/sys/fs/cgroup/cpu/A$ sudo sh -c &#x27;echo 40000 &gt; cpu.cfs_quota_us&#x27;</span><br><span class="line">  </span><br><span class="line">  </span><br><span class="line">以上各自情况，用top观察a.out CPU利用率。</span><br><span class="line"></span><br><span class="line">  当设置为 20000 us = 20ms , CPU利用率立即变为20%；  当设置为 40000 us = 40ms ,CPU利用率立即变为40%</span><br><span class="line">  当设置为 120000 us 时， CPU利用率立即变为120%。quota可以大于period，因为此时 CPU为多核，100ms里面可以运行200ms，该值最大为CPU核数* period。</span><br></pre></td></tr></table></figure>

<h3 id="Android和Docker对cgroup的采用"><a href="#Android和Docker对cgroup的采用" class="headerlink" title="Android和Docker对cgroup的采用"></a>Android和Docker对cgroup的采用</h3><ul>
<li>apps, bg_non_interactive<br>安卓把应用分为app group ，和 bg_non_interactive 背景非交互的group，<br><br>并且bg_non_interactive的group权重非常低，这样做的好处是，让桌面运行的程序可以更大程度的抢到CPU。<br></li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">Shares：</span><br><span class="line">apps: cpu.shares = 1024</span><br><span class="line">bg_non_interactive: cpu.shares = 52</span><br><span class="line"></span><br><span class="line">Quota:</span><br><span class="line">apps:</span><br><span class="line">cpu.rt_period_us: 1000000 cpu.rt_runtime_us: 800000</span><br><span class="line">bg_non_interactive: </span><br><span class="line">cpu.rt_period_us: 1000000 cpu.rt_runtime_us: 700000</span><br></pre></td></tr></table></figure>

<ul>
<li>docker run时也可以指定 –cpu-quota 、–cpu-period、 –cpu-shares参数</li>
</ul>
<p>Linux 通过Cgroup控制多个容器在运行时，如何分享CPU。这些会在之后的Cgroups详解中详细阐述。</p>
<p>比如说A容器配置的–cpu-period&#x3D;100000 –cpu-quota&#x3D;50000，那么A容器就可以最多使用50%个CPU资源，如果配置的–cpu-quota&#x3D;200000，那就可以使用200%个CPU资源。所有对采集到的CPU used的绝对值没有意义，还需要参考上限。还是这个例子–cpu-period&#x3D;100000 –cpu-quota&#x3D;50000，如果容器试图在0.1秒内使用超过0.05秒，则throttled就会触发，所有throttled的count和time是衡量CPU是否达到瓶颈的最直观指标。</p>
<h3 id="Linux为什么不是硬实时的"><a href="#Linux为什么不是硬实时的" class="headerlink" title="Linux为什么不是硬实时的"></a>Linux为什么不是硬实时的</h3><p>如何理解硬实时？并不代表越快越好，硬实时最主要的意思是：可预期。</p>
<p><img src="https://user-images.githubusercontent.com/87457873/127106738-b19f18a4-703a-45aa-87b1-a06a4275cb46.png" alt="image"></p>
<p>如上图，在一个硬实时操作系统中，当唤醒一个高优先级的RT任务，从“你唤醒它”到“它可以被调度”的这段时间，是不会超过截止期限的。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">4.cyclictest -p 99 -t1 -n</span><br><span class="line">观察min, max, act, avg时间，分析hard realtime问题</span><br><span class="line">加到系统负载，运行一些硬盘访问，狂收发包的程序，观察cyclictest的max变化</span><br><span class="line">延迟具有不确定性，最大值可能随着load改变而改变。</span><br></pre></td></tr></table></figure>

<p>Kernel 越发支持抢占</p>
<p><img src="https://user-images.githubusercontent.com/87457873/127106783-7d364233-80be-4aea-989d-ea9a124232de.png" alt="image"></p>
<p>Linux为什么不是硬实时？</p>
<p>Linux运行时，CPU时间主要花在“四类区间”上，包括中断、软中断、进程上下文（spin_lock），进程上下文（可调度）。<br><br>其中 进程上下文陷入内核拿到spin_lock，此时拿到spin_lock的CPU核上的调度器就会被关掉，该核就无法进行调度。<br></p>
<p>程序运行在只有 进程上下文（可调度）这个区间可以调度，其他区间都不能被调度。</p>
<p>中断是指 进程收到硬件的中断信号，就算在中断里唤醒一个高优先级的RT，也无法调度。<br><br>软中断和中断的唯一区别是，软中断中可以再中断，但中断中不能再中断。Linux 2.6.32之后完全不允许中断嵌套。软中断里唤醒一个高优先级的RT，也无法调度。<br></p>
<p>如下图，一个绿色的普通进程在T1时刻持有spin_lock进入一个critical section（该核调度被关），绿色进程T2时刻被中断打断，而后T3时刻IRQ1里面唤醒了红色的RT进程（如果是硬实时RTOS，这个时候RT进程应该能抢入），之后IRQ1后又执行了IRQ2，到T4时刻IRQ1和IRQ2都结束了，红色RT进程仍然不能执行（因为绿色进程还在spin_lock里面），直到T5时刻，普通进程释放spin_lock后，红色RT进程才抢入。从T3到T5要多久，鬼都不知道，这样就无法满足硬实时系统的“可预期”延迟性，因此Linux不是硬实时操作系统。</p>
<p><img src="https://user-images.githubusercontent.com/87457873/127106839-4bbdd672-43ba-4642-a2a6-96092d56cb0d.png" alt="image"></p>
<h3 id="preempt-rt对Linux实时性的改造"><a href="#preempt-rt对Linux实时性的改造" class="headerlink" title="preempt-rt对Linux实时性的改造"></a>preempt-rt对Linux实时性的改造</h3><p><img src="https://user-images.githubusercontent.com/87457873/127106866-dc49efc2-0a54-434c-8b06-30e8a5d09e97.png" alt="image"></p>
<p>Linux的preempt-rt补丁试图把中断、软中断线程化，变成可以被抢占的区间，而把会关本核调度器的spin_lock替换为可以调度的mutex，它实现了在T3时刻唤醒RT进程的时刻，RT进程可以立即抢占调度进入的目标，避免了T3-T5之间延迟的非确定性。</p>
]]></content>
      <categories>
        <category>linux-doc 进程管理</category>
      </categories>
      <tags>
        <tag>Linux</tag>
      </tags>
  </entry>
  <entry>
    <title>Linux进程状态总结</title>
    <url>/2023/01/15/linux-docs/%E8%BF%9B%E7%A8%8B%E7%AE%A1%E7%90%86/Linux%E8%BF%9B%E7%A8%8B%E7%8A%B6%E6%80%81%E6%80%BB%E7%BB%93/</url>
    <content><![CDATA[<h2 id="进程生命周期"><a href="#进程生命周期" class="headerlink" title="进程生命周期"></a>进程生命周期</h2><p>在Linux内核里，无论是进程还是线程，统一使用 task_struct{} 结构体来表示，也就是统一抽象为任务（task）。task_struct{} 定义在 include&#x2F;linux&#x2F;sched.h 文件中，十分复杂，这里简单了解下。</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">// include/linux/sched.h</span></span><br><span class="line"><span class="comment">// ... 省略</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">task_struct</span> &#123;</span></span><br><span class="line"><span class="meta">#<span class="keyword">ifdef</span> CONFIG_THREAD_INFO_IN_TASK</span></span><br><span class="line">	<span class="comment">/*</span></span><br><span class="line"><span class="comment">	 * For reasons of header soup (see current_thread_info()), this</span></span><br><span class="line"><span class="comment">	 * must be the first element of task_struct.</span></span><br><span class="line"><span class="comment">	 */</span></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">thread_info</span>		<span class="title">thread_info</span>;</span></span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line">	<span class="comment">/* -1 unrunnable, 0 runnable, &gt;0 stopped: */</span></span><br><span class="line">	<span class="keyword">volatile</span> <span class="type">long</span>			state;</span><br><span class="line">	<span class="type">int</span>				exit_state;</span><br><span class="line">	<span class="type">int</span>				exit_code;</span><br><span class="line">	<span class="type">int</span>				exit_signal;</span><br><span class="line"></span><br><span class="line">	<span class="comment">/*</span></span><br><span class="line"><span class="comment">	 * This begins the randomizable portion of task_struct. Only</span></span><br><span class="line"><span class="comment">	 * scheduling-critical items should be added above here.</span></span><br><span class="line"><span class="comment">	 */</span></span><br><span class="line">	randomized_struct_fields_start</span><br><span class="line"></span><br><span class="line">	<span class="type">void</span>				*<span class="built_in">stack</span>;</span><br><span class="line">	<span class="type">refcount_t</span>			usage;</span><br><span class="line">	<span class="comment">/* Per task flags (PF_*), defined further below: */</span></span><br><span class="line">	<span class="type">unsigned</span> <span class="type">int</span>			flags;</span><br><span class="line">	<span class="type">unsigned</span> <span class="type">int</span>			ptrace;</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">ifdef</span> CONFIG_SMP</span></span><br><span class="line">	<span class="type">int</span>				on_cpu;</span><br><span class="line">	<span class="class"><span class="keyword">struct</span> __<span class="title">call_single_node</span>	<span class="title">wake_entry</span>;</span></span><br><span class="line"><span class="meta">#<span class="keyword">ifdef</span> CONFIG_THREAD_INFO_IN_TASK</span></span><br><span class="line">	<span class="comment">/* Current CPU: */</span></span><br><span class="line">	<span class="type">unsigned</span> <span class="type">int</span>			cpu;</span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line">	<span class="type">unsigned</span> <span class="type">int</span>			wakee_flips;</span><br><span class="line">	<span class="type">unsigned</span> <span class="type">long</span>			wakee_flip_decay_ts;</span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">task_struct</span>		*<span class="title">last_wakee</span>;</span></span><br><span class="line">  <span class="comment">// ...省略</span></span><br><span class="line">  <span class="class"><span class="keyword">struct</span> <span class="title">sched_info</span>		<span class="title">sched_info</span>;</span></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">list_head</span>		<span class="title">tasks</span>;</span>   <span class="comment">// 链表，将所有task_struct串起来</span></span><br><span class="line"></span><br><span class="line">	<span class="type">pid_t</span>				pid;    <span class="comment">// process id，指的是线程id</span></span><br><span class="line">	<span class="type">pid_t</span>				tgid;   <span class="comment">// thread group ID，指的是进程的主线程id</span></span><br><span class="line">  <span class="class"><span class="keyword">struct</span> <span class="title">task_struct</span>		*<span class="title">group_leader</span>;</span>  <span class="comment">// 指向的是进程的主线程</span></span><br><span class="line"></span><br><span class="line">	<span class="comment">/* Signal handlers: */</span></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">signal_struct</span>		*<span class="title">signal</span>;</span></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">sighand_struct</span> __<span class="title">rcu</span>		*<span class="title">sighand</span>;</span></span><br><span class="line">	<span class="type">sigset_t</span>			blocked;</span><br><span class="line">	<span class="type">sigset_t</span>			real_blocked;</span><br><span class="line">	<span class="comment">/* Restored if set_restore_sigmask() was used: */</span></span><br><span class="line">	<span class="type">sigset_t</span>			saved_sigmask;</span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">sigpending</span>		<span class="title">pending</span>;</span></span><br><span class="line">	<span class="type">unsigned</span> <span class="type">long</span>			sas_ss_sp;</span><br><span class="line">	<span class="type">size_t</span>				sas_ss_size;</span><br><span class="line">	<span class="type">unsigned</span> <span class="type">int</span>			sas_ss_flags;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// ... 省略</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>查阅相关资料后，对Linux中进程的生命周期总结如下：</p>
<p><img src="https://user-images.githubusercontent.com/87457873/127657434-bfca795a-6388-486a-bae9-f66d4eff8b9e.png" alt="image"></p>
<p>从图上可以看出，进程的睡眠状态是最多的，那进程一般在何时进入睡眠状态呢？答案是I&#x2F;O操作时，因为I&#x2F;O操作的速度与CPU运行速度相比，相差太大，所以此时进程会释放CPU，进入睡眠状态。</p>
<p><img src="https://user-images.githubusercontent.com/87457873/127657493-bb1839f9-d6f1-4f6e-8259-4bbd27104026.png" alt="image"></p>
<p>进程状态相关的定义同样在 include&#x2F;linux&#x2F;sched.h 文件的开头部分，以 #define TASK_KILLABLE (TASK_WAKEKILL | TASK_UNINTERRUPTIBLE) 为例，TASK_WAKEKILL表示用于在接收到致命信号时唤醒进程，将它与 TASK_UNINTERRUPTIBLE 按位或，就得到了 TASK_KILLABLE。代码注释中提到了 fs&#x2F;proc&#x2F;array.c，所以也将其代码贴出，作为补充。</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">// include/linux/sched.h</span></span><br><span class="line"><span class="comment">// ... 省略</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * Task state bitmask. NOTE! These bits are also</span></span><br><span class="line"><span class="comment"> * encoded in fs/proc/array.c: get_task_state().</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * We have two separate sets of flags: task-&gt;state</span></span><br><span class="line"><span class="comment"> * is about runnability, while task-&gt;exit_state are</span></span><br><span class="line"><span class="comment"> * about the task exiting. Confusing, but this way</span></span><br><span class="line"><span class="comment"> * modifying one set can&#x27;t modify the other one by</span></span><br><span class="line"><span class="comment"> * mistake.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/* Used in tsk-&gt;state: */</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> TASK_RUNNING			0x0000</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> TASK_INTERRUPTIBLE		0x0001</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> TASK_UNINTERRUPTIBLE		0x0002</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> __TASK_STOPPED			0x0004</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> __TASK_TRACED			0x0008</span></span><br><span class="line"><span class="comment">/* Used in tsk-&gt;exit_state: */</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> EXIT_DEAD			0x0010</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> EXIT_ZOMBIE			0x0020</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> EXIT_TRACE			(EXIT_ZOMBIE | EXIT_DEAD)</span></span><br><span class="line"><span class="comment">/* Used in tsk-&gt;state again: */</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> TASK_PARKED			0x0040</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> TASK_DEAD			0x0080</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> TASK_WAKEKILL			0x0100</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> TASK_WAKING			0x0200</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> TASK_NOLOAD			0x0400</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> TASK_NEW			0x0800</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> TASK_STATE_MAX			0x1000</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/* Convenience macros for the sake of set_current_state: */</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> TASK_KILLABLE			(TASK_WAKEKILL | TASK_UNINTERRUPTIBLE)</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> TASK_STOPPED			(TASK_WAKEKILL | __TASK_STOPPED)</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> TASK_TRACED			(TASK_WAKEKILL | __TASK_TRACED)</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> TASK_IDLE			(TASK_UNINTERRUPTIBLE | TASK_NOLOAD)</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/* Convenience macros for the sake of wake_up(): */</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> TASK_NORMAL			(TASK_INTERRUPTIBLE | TASK_UNINTERRUPTIBLE)</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/* get_task_state(): */</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> TASK_REPORT			(TASK_RUNNING | TASK_INTERRUPTIBLE | \</span></span><br><span class="line"><span class="meta">					 TASK_UNINTERRUPTIBLE | __TASK_STOPPED | \</span></span><br><span class="line"><span class="meta">					 __TASK_TRACED | EXIT_DEAD | EXIT_ZOMBIE | \</span></span><br><span class="line"><span class="meta">					 TASK_PARKED)</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> task_is_traced(task)		((task-&gt;state &amp; __TASK_TRACED) != 0)</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> task_is_stopped(task)		((task-&gt;state &amp; __TASK_STOPPED) != 0)</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> task_is_stopped_or_traced(task)	((task-&gt;state &amp; (__TASK_STOPPED | __TASK_TRACED)) != 0)</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// ... 省略</span></span><br></pre></td></tr></table></figure>

<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">// fs/proc/array.c</span></span><br><span class="line"><span class="comment">// ... 省略</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * The task state array is a strange &quot;bitmap&quot; of</span></span><br><span class="line"><span class="comment"> * reasons to sleep. Thus &quot;running&quot; is zero, and</span></span><br><span class="line"><span class="comment"> * you can test for combinations of others with</span></span><br><span class="line"><span class="comment"> * simple bit tests.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="type">static</span> <span class="type">const</span> <span class="type">char</span> * <span class="type">const</span> task_state_array[] = &#123;</span><br><span class="line"></span><br><span class="line">	<span class="comment">/* states in TASK_REPORT: */</span></span><br><span class="line">	<span class="string">&quot;R (running)&quot;</span>,		<span class="comment">/* 0x00 */</span></span><br><span class="line">	<span class="string">&quot;S (sleeping)&quot;</span>,		<span class="comment">/* 0x01 */</span></span><br><span class="line">	<span class="string">&quot;D (disk sleep)&quot;</span>,	<span class="comment">/* 0x02 */</span></span><br><span class="line">	<span class="string">&quot;T (stopped)&quot;</span>,		<span class="comment">/* 0x04 */</span></span><br><span class="line">	<span class="string">&quot;t (tracing stop)&quot;</span>,	<span class="comment">/* 0x08 */</span></span><br><span class="line">	<span class="string">&quot;X (dead)&quot;</span>,		<span class="comment">/* 0x10 */</span></span><br><span class="line">	<span class="string">&quot;Z (zombie)&quot;</span>,		<span class="comment">/* 0x20 */</span></span><br><span class="line">	<span class="string">&quot;P (parked)&quot;</span>,		<span class="comment">/* 0x40 */</span></span><br><span class="line"></span><br><span class="line">	<span class="comment">/* states beyond TASK_REPORT: */</span></span><br><span class="line">	<span class="string">&quot;I (idle)&quot;</span>,		<span class="comment">/* 0x80 */</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="type">static</span> <span class="keyword">inline</span> <span class="type">const</span> <span class="type">char</span> *<span class="title function_">get_task_state</span><span class="params">(<span class="keyword">struct</span> task_struct *tsk)</span></span><br><span class="line">&#123;</span><br><span class="line">	BUILD_BUG_ON(<span class="number">1</span> + ilog2(TASK_REPORT_MAX) != ARRAY_SIZE(task_state_array));</span><br><span class="line">	<span class="keyword">return</span> task_state_array[task_state_index(tsk)];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// ... 省略</span></span><br></pre></td></tr></table></figure>

<p>在单核的CPU上，同一时刻只有一个task会被调度，所以即使看到了 R 状态，也不代表进程就被分配到了CPU时间片。但了解了进程状态之后，我们再通过 top, ps aux 等命令查看进程，分析问题起来效率就更高了:</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">top - <span class="number">17</span>:<span class="number">24</span>:<span class="number">07</span> up <span class="number">10</span>:<span class="number">20</span>,  <span class="number">1</span> user,  load average: <span class="number">0.15</span>, <span class="number">0.08</span>, <span class="number">0.02</span></span><br><span class="line">Tasks: <span class="number">216</span> total,   <span class="number">1</span> running, <span class="number">215</span> sleeping,   <span class="number">0</span> stopped,   <span class="number">0</span> zombie</span><br><span class="line">%Cpu(s):  <span class="number">0.4</span> us,  <span class="number">0.3</span> sy,  <span class="number">0.0</span> ni, <span class="number">99.2</span> id,  <span class="number">0.0</span> wa,  <span class="number">0.0</span> hi,  <span class="number">0.0</span> si,  <span class="number">0.0</span> st</span><br><span class="line">MiB Mem :   <span class="number">5945.2</span> total,   <span class="number">2655.4</span> <span class="built_in">free</span>,   <span class="number">1580.8</span> used,   <span class="number">1709.1</span> buff/cache</span><br><span class="line">MiB Swap:   <span class="number">2048.0</span> total,   <span class="number">2048.0</span> <span class="built_in">free</span>,      <span class="number">0.0</span> used.   <span class="number">4084.6</span> avail Mem </span><br><span class="line"></span><br><span class="line">    PID USER      PR  NI    VIRT    RES    SHR S  %CPU  %MEM     TIME+ COMMAND                                                                            </span><br><span class="line">   <span class="number">1914</span> demonlee  <span class="number">20</span>   <span class="number">0</span> <span class="number">5252100</span> <span class="number">395940</span> <span class="number">132816</span> S   <span class="number">1.0</span>   <span class="number">6.5</span>   <span class="number">1</span>:<span class="number">33.09</span> gnome-shell                                                                        </span><br><span class="line">    <span class="number">824</span> root      <span class="number">20</span>   <span class="number">0</span> <span class="number">2495652</span>  <span class="number">89512</span>  <span class="number">48936</span> S   <span class="number">0.7</span>   <span class="number">1.5</span>   <span class="number">0</span>:<span class="number">05.59</span> dockerd                                                                            </span><br><span class="line">   <span class="number">1687</span> demonlee  <span class="number">20</span>   <span class="number">0</span> <span class="number">1153156</span>  <span class="number">81436</span>  <span class="number">50128</span> S   <span class="number">0.3</span>   <span class="number">1.3</span>   <span class="number">0</span>:<span class="number">15.90</span> Xorg                                                                               </span><br><span class="line">   <span class="number">1957</span> demonlee  <span class="number">20</span>   <span class="number">0</span>  <span class="number">206556</span>  <span class="number">28348</span>  <span class="number">18504</span> S   <span class="number">0.3</span>   <span class="number">0.5</span>   <span class="number">0</span>:<span class="number">00.26</span> ibus-x11                                                                           </span><br><span class="line">   <span class="number">2897</span> demonlee  <span class="number">20</span>   <span class="number">0</span>  <span class="number">874684</span>  <span class="number">61296</span>  <span class="number">44532</span> S   <span class="number">0.3</span>   <span class="number">1.0</span>   <span class="number">0</span>:<span class="number">06.22</span> gnome-terminal-                                                                    </span><br><span class="line">  <span class="number">19984</span> demonlee  <span class="number">20</span>   <span class="number">0</span>   <span class="number">20632</span>   <span class="number">4036</span>   <span class="number">3376</span> R   <span class="number">0.3</span>   <span class="number">0.1</span>   <span class="number">0</span>:<span class="number">00.02</span> top                                                                                </span><br><span class="line">      <span class="number">1</span> root      <span class="number">20</span>   <span class="number">0</span>  <span class="number">169076</span>  <span class="number">12952</span>   <span class="number">8288</span> S   <span class="number">0.0</span>   <span class="number">0.2</span>   <span class="number">0</span>:<span class="number">04.61</span> systemd                                                                            </span><br><span class="line">      <span class="number">2</span> root      <span class="number">20</span>   <span class="number">0</span>       <span class="number">0</span>      <span class="number">0</span>      <span class="number">0</span> S   <span class="number">0.0</span>   <span class="number">0.0</span>   <span class="number">0</span>:<span class="number">00.01</span> kthreadd                                                                           </span><br><span class="line">      <span class="number">3</span> root       <span class="number">0</span> <span class="number">-20</span>       <span class="number">0</span>      <span class="number">0</span>      <span class="number">0</span> I   <span class="number">0.0</span>   <span class="number">0.0</span>   <span class="number">0</span>:<span class="number">00.00</span> rcu_gp                                                                             </span><br><span class="line">      <span class="number">4</span> root       <span class="number">0</span> <span class="number">-20</span>       <span class="number">0</span>      <span class="number">0</span>      <span class="number">0</span> I   <span class="number">0.0</span>   <span class="number">0.0</span>   <span class="number">0</span>:<span class="number">00.00</span> rcu_par_gp                                                                         </span><br><span class="line">      <span class="number">6</span> root       <span class="number">0</span> <span class="number">-20</span>       <span class="number">0</span>      <span class="number">0</span>      <span class="number">0</span> I   <span class="number">0.0</span>   <span class="number">0.0</span>   <span class="number">0</span>:<span class="number">00.00</span> kworker/<span class="number">0</span>:<span class="number">0</span>H-kblockd                                                               </span><br><span class="line">      <span class="number">9</span> root       <span class="number">0</span> <span class="number">-20</span>       <span class="number">0</span>      <span class="number">0</span>      <span class="number">0</span> I   <span class="number">0.0</span>   <span class="number">0.0</span>   <span class="number">0</span>:<span class="number">00.00</span> mm_percpu_wq                                                                       </span><br><span class="line">     <span class="number">10</span> root      <span class="number">20</span>   <span class="number">0</span>       <span class="number">0</span>      <span class="number">0</span>      <span class="number">0</span> S   <span class="number">0.0</span>   <span class="number">0.0</span>   <span class="number">0</span>:<span class="number">00.08</span> ksoftirqd/<span class="number">0</span>                                                                        </span><br><span class="line">     <span class="number">11</span> root      <span class="number">20</span>   <span class="number">0</span>       <span class="number">0</span>      <span class="number">0</span>      <span class="number">0</span> I   <span class="number">0.0</span>   <span class="number">0.0</span>   <span class="number">0</span>:<span class="number">03.60</span> rcu_sched                                                                          </span><br><span class="line">     <span class="number">12</span> root      rt   <span class="number">0</span>       <span class="number">0</span>      <span class="number">0</span>      <span class="number">0</span> S   <span class="number">0.0</span>   <span class="number">0.0</span>   <span class="number">0</span>:<span class="number">00.51</span> migration/<span class="number">0</span>                                                                        </span><br><span class="line">     <span class="number">13</span> root     <span class="number">-51</span>   <span class="number">0</span>       <span class="number">0</span>      <span class="number">0</span>      <span class="number">0</span> S   <span class="number">0.0</span>   <span class="number">0.0</span>   <span class="number">0</span>:<span class="number">00.00</span> idle_inject/<span class="number">0</span>                                                                      </span><br><span class="line">     <span class="number">14</span> root      <span class="number">20</span>   <span class="number">0</span>       <span class="number">0</span>      <span class="number">0</span>      <span class="number">0</span> S   <span class="number">0.0</span>   <span class="number">0.0</span>   <span class="number">0</span>:<span class="number">00.00</span> cpuhp/<span class="number">0</span>                                                                            </span><br><span class="line">     <span class="number">15</span> root      <span class="number">20</span>   <span class="number">0</span>       <span class="number">0</span>      <span class="number">0</span>      <span class="number">0</span> S   <span class="number">0.0</span>   <span class="number">0.0</span>   <span class="number">0</span>:<span class="number">00.00</span> cpuhp/<span class="number">1</span>                                                                            </span><br><span class="line">     <span class="number">16</span> root     <span class="number">-51</span>   <span class="number">0</span>       <span class="number">0</span>      <span class="number">0</span>      <span class="number">0</span> S   <span class="number">0.0</span>   <span class="number">0.0</span>   <span class="number">0</span>:<span class="number">00.00</span> idle_inject/<span class="number">1</span>                                                                      </span><br><span class="line">     <span class="number">17</span> root      rt   <span class="number">0</span>       <span class="number">0</span>      <span class="number">0</span>      <span class="number">0</span> S   <span class="number">0.0</span>   <span class="number">0.0</span>   <span class="number">0</span>:<span class="number">00.89</span> migration/<span class="number">1</span>                                                                        </span><br><span class="line">     <span class="number">18</span> root      <span class="number">20</span>   <span class="number">0</span>       <span class="number">0</span>      <span class="number">0</span>      <span class="number">0</span> S   <span class="number">0.0</span>   <span class="number">0.0</span>   <span class="number">0</span>:<span class="number">00.09</span> ksoftirqd/<span class="number">1</span>                                                                        </span><br><span class="line">     <span class="number">20</span> root       <span class="number">0</span> <span class="number">-20</span>       <span class="number">0</span>      <span class="number">0</span>      <span class="number">0</span> I   <span class="number">0.0</span>   <span class="number">0.0</span>   <span class="number">0</span>:<span class="number">00.00</span> kworker/<span class="number">1</span>:<span class="number">0</span>H                                                                       </span><br><span class="line">     <span class="number">21</span> root      <span class="number">20</span>   <span class="number">0</span>       <span class="number">0</span>      <span class="number">0</span>      <span class="number">0</span> S   <span class="number">0.0</span>   <span class="number">0.0</span>   <span class="number">0</span>:<span class="number">00.00</span> cpuhp/<span class="number">2</span>                                                                            </span><br><span class="line">     <span class="number">22</span> root     <span class="number">-51</span>   <span class="number">0</span>       <span class="number">0</span>      <span class="number">0</span>      <span class="number">0</span> S   <span class="number">0.0</span>   <span class="number">0.0</span>   <span class="number">0</span>:<span class="number">00.00</span> idle_inject/<span class="number">2</span>                                                                      </span><br><span class="line">     <span class="number">23</span> root      rt   <span class="number">0</span>       <span class="number">0</span>      <span class="number">0</span>      <span class="number">0</span> S   <span class="number">0.0</span>   <span class="number">0.0</span>   <span class="number">0</span>:<span class="number">00.83</span> migration/<span class="number">2</span>                                                                        </span><br><span class="line">     <span class="number">24</span> root      <span class="number">20</span>   <span class="number">0</span>       <span class="number">0</span>      <span class="number">0</span>      <span class="number">0</span> S   <span class="number">0.0</span>   <span class="number">0.0</span>   <span class="number">0</span>:<span class="number">00.07</span> ksoftirqd/<span class="number">2</span>                                                                        </span><br><span class="line">     <span class="number">26</span> root       <span class="number">0</span> <span class="number">-20</span>       <span class="number">0</span>      <span class="number">0</span>      <span class="number">0</span> I   <span class="number">0.0</span>   <span class="number">0.0</span>   <span class="number">0</span>:<span class="number">00.00</span> kworker/<span class="number">2</span>:<span class="number">0</span>H-kblockd                                                               </span><br><span class="line">     <span class="number">27</span> root      <span class="number">20</span>   <span class="number">0</span>       <span class="number">0</span>      <span class="number">0</span>      <span class="number">0</span> S   <span class="number">0.0</span>   <span class="number">0.0</span>   <span class="number">0</span>:<span class="number">00.00</span> cpuhp/<span class="number">3</span>                                                                            </span><br><span class="line">     <span class="number">28</span> root     <span class="number">-51</span>   <span class="number">0</span>       <span class="number">0</span>      <span class="number">0</span>      <span class="number">0</span> S   <span class="number">0.0</span>   <span class="number">0.0</span>   <span class="number">0</span>:<span class="number">00.00</span> idle_inject/<span class="number">3</span>                                                                      </span><br><span class="line">     <span class="number">29</span> root      rt   <span class="number">0</span>       <span class="number">0</span>      <span class="number">0</span>      <span class="number">0</span> S   <span class="number">0.0</span>   <span class="number">0.0</span>   <span class="number">0</span>:<span class="number">00.77</span> migration/<span class="number">3</span>                                                                        </span><br><span class="line">     <span class="number">30</span> root      <span class="number">20</span>   <span class="number">0</span>       <span class="number">0</span>      <span class="number">0</span>      <span class="number">0</span> S   <span class="number">0.0</span>   <span class="number">0.0</span>   <span class="number">0</span>:<span class="number">00.18</span> ksoftirqd/<span class="number">3</span>                                                                        </span><br><span class="line">     <span class="number">32</span> root       <span class="number">0</span> <span class="number">-20</span>       <span class="number">0</span>      <span class="number">0</span>      <span class="number">0</span> I   <span class="number">0.0</span>   <span class="number">0.0</span>   <span class="number">0</span>:<span class="number">00.00</span> kworker/<span class="number">3</span>:<span class="number">0</span>H-kblockd                                                               </span><br><span class="line">     <span class="number">33</span> root      <span class="number">20</span>   <span class="number">0</span>       <span class="number">0</span>      <span class="number">0</span>      <span class="number">0</span> S   <span class="number">0.0</span>   <span class="number">0.0</span>   <span class="number">0</span>:<span class="number">00.00</span> kdevtmpfs                                                                          </span><br><span class="line">     <span class="number">34</span> root       <span class="number">0</span> <span class="number">-20</span>       <span class="number">0</span>      <span class="number">0</span>      <span class="number">0</span> I   <span class="number">0.0</span>   <span class="number">0.0</span>   <span class="number">0</span>:<span class="number">00.00</span> netns                                                                              </span><br><span class="line">     <span class="number">35</span> root      <span class="number">20</span>   <span class="number">0</span>       <span class="number">0</span>      <span class="number">0</span>      <span class="number">0</span> S   <span class="number">0.0</span>   <span class="number">0.0</span>   <span class="number">0</span>:<span class="number">00.00</span> rcu_tasks_kthre                                                                    </span><br><span class="line">     <span class="number">36</span> root      <span class="number">20</span>   <span class="number">0</span>       <span class="number">0</span>      <span class="number">0</span>      <span class="number">0</span> S   <span class="number">0.0</span>   <span class="number">0.0</span>   <span class="number">0</span>:<span class="number">00.00</span> rcu_tasks_rude_                                                                    </span><br><span class="line">     <span class="number">37</span> root      <span class="number">20</span>   <span class="number">0</span>       <span class="number">0</span>      <span class="number">0</span>      <span class="number">0</span> S   <span class="number">0.0</span>   <span class="number">0.0</span>   <span class="number">0</span>:<span class="number">00.00</span> rcu_tasks_trace                                                                    </span><br><span class="line">     <span class="number">38</span> root      <span class="number">20</span>   <span class="number">0</span>       <span class="number">0</span>      <span class="number">0</span>      <span class="number">0</span> S   <span class="number">0.0</span>   <span class="number">0.0</span>   <span class="number">0</span>:<span class="number">00.00</span> kauditd                                                                            </span><br><span class="line">     <span class="number">39</span> root      <span class="number">20</span>   <span class="number">0</span>       <span class="number">0</span>      <span class="number">0</span>      <span class="number">0</span> S   <span class="number">0.0</span>   <span class="number">0.0</span>   <span class="number">0</span>:<span class="number">00.03</span> khungtaskd                                                                         </span><br><span class="line">demonlee@demonlee-ubuntu:~$</span><br></pre></td></tr></table></figure>

<p>最后，再补充一个知识点：使用ps命令查看进程时，会发现状态上面有其他符号，比如 S+、Z+ 等，如下所示，</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">demonlee@demonlee-ubuntu:~$ </span><br><span class="line">demonlee    <span class="number">1704</span>  <span class="number">0.0</span>  <span class="number">0.6</span> <span class="number">557904</span> <span class="number">37256</span> ?        Sl   <span class="number">05</span>:<span class="number">01</span>   <span class="number">0</span>:<span class="number">00</span> /usr/libexec/goa-daemon</span><br><span class="line">demonlee    <span class="number">1707</span>  <span class="number">0.0</span>  <span class="number">0.1</span> <span class="number">172652</span>  <span class="number">6936</span> tty2     Ssl+ <span class="number">05</span>:<span class="number">01</span>   <span class="number">0</span>:<span class="number">00</span> /usr/lib/gdm3/gdm-x-session --run-script env GNOME_SHELL_SESSION_MODE=ubuntu /usr/bin/g</span><br><span class="line">demonlee    <span class="number">1714</span>  <span class="number">0.0</span>  <span class="number">0.1</span> <span class="number">323388</span>  <span class="number">9068</span> ?        Sl   <span class="number">05</span>:<span class="number">01</span>   <span class="number">0</span>:<span class="number">00</span> /usr/libexec/goa-identity-service</span><br><span class="line">demonlee    <span class="number">1720</span>  <span class="number">0.1</span>  <span class="number">1.3</span> <span class="number">1151880</span> <span class="number">80576</span> tty2    Sl+  <span class="number">05</span>:<span class="number">01</span>   <span class="number">1</span>:<span class="number">05</span> /usr/lib/xorg/Xorg vt2 -displayfd <span class="number">3</span> -auth /run/user/<span class="number">1000</span>/gdm/Xauthority -background non</span><br><span class="line">demonlee    <span class="number">1723</span>  <span class="number">0.0</span>  <span class="number">0.1</span> <span class="number">325356</span>  <span class="number">9016</span> ?        Ssl  <span class="number">05</span>:<span class="number">01</span>   <span class="number">0</span>:<span class="number">02</span> /usr/libexec/gvfs-afc-volume-monitor</span><br><span class="line">demonlee    <span class="number">1728</span>  <span class="number">0.0</span>  <span class="number">0.1</span> <span class="number">244336</span>  <span class="number">6532</span> ?        Ssl  <span class="number">05</span>:<span class="number">01</span>   <span class="number">0</span>:<span class="number">00</span> /usr/libexec/gvfs-mtp-volume-monitor</span><br><span class="line">demonlee    <span class="number">1759</span>  <span class="number">0.0</span>  <span class="number">0.2</span> <span class="number">197052</span> <span class="number">14276</span> tty2     Sl+  <span class="number">05</span>:<span class="number">01</span>   <span class="number">0</span>:<span class="number">00</span> /usr/libexec/gnome-session-binary --systemd --systemd --session=ubuntu</span><br><span class="line">...</span><br></pre></td></tr></table></figure>

<p>这个 + 是啥意思呢，其实 man ps 中就有描述，只是我们从来都没认真看说明文档：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">PROCESS STATE CODES</span><br><span class="line">       Here are the different values that the s, stat and state output <span class="title function_">specifiers</span> <span class="params">(header <span class="string">&quot;STAT&quot;</span> or <span class="string">&quot;S&quot;</span>)</span> will display to describe the state of a</span><br><span class="line">       process:</span><br><span class="line"></span><br><span class="line">               D    uninterruptible <span class="title function_">sleep</span> <span class="params">(usually IO)</span></span><br><span class="line">               I    Idle kernel thread</span><br><span class="line">               R    running or <span class="title function_">runnable</span> <span class="params">(on run <span class="built_in">queue</span>)</span></span><br><span class="line">               S    interruptible <span class="title function_">sleep</span> <span class="params">(waiting <span class="keyword">for</span> an event to complete)</span></span><br><span class="line">               T    stopped by job control signal</span><br><span class="line">               t    stopped by debugger during the tracing</span><br><span class="line">               W    <span class="title function_">paging</span> <span class="params">(not valid since the <span class="number">2.6</span>.xx kernel)</span></span><br><span class="line">               X    <span class="title function_">dead</span> <span class="params">(should never be seen)</span></span><br><span class="line">               Z    <span class="title function_">defunct</span> <span class="params">(<span class="string">&quot;zombie&quot;</span>)</span> process, terminated but not reaped by its parent</span><br><span class="line"></span><br><span class="line">       For BSD formats and when the stat keyword is used, additional characters may be displayed:</span><br><span class="line"></span><br><span class="line">               &lt;    high-<span class="title function_">priority</span> <span class="params">(not nice to other users)</span></span><br><span class="line">               N    low-<span class="title function_">priority</span> <span class="params">(nice to other users)</span></span><br><span class="line">               L    has pages locked into <span class="title function_">memory</span> <span class="params">(<span class="keyword">for</span> real-time and custom IO)</span></span><br><span class="line">               s    is a session leader</span><br><span class="line">               l    is multi-<span class="title function_">threaded</span> <span class="params">(using CLONE_THREAD, like NPTL pthreads <span class="keyword">do</span>)</span></span><br><span class="line">               +    is in the foreground process group</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>linux-doc 进程管理</category>
      </categories>
      <tags>
        <tag>Linux</tag>
      </tags>
  </entry>
  <entry>
    <title>一文带你，彻底了解，零拷贝Zero-Copy技术</title>
    <url>/2023/01/15/linux-docs/%E8%BF%9B%E7%A8%8B%E7%AE%A1%E7%90%86/%E4%B8%80%E6%96%87%E5%B8%A6%E4%BD%A0%EF%BC%8C%E5%BD%BB%E5%BA%95%E4%BA%86%E8%A7%A3%EF%BC%8C%E9%9B%B6%E6%8B%B7%E8%B4%9DZero-Copy%E6%8A%80%E6%9C%AF/</url>
    <content><![CDATA[<h2 id="1、数据拷贝基础过程"><a href="#1、数据拷贝基础过程" class="headerlink" title="1、数据拷贝基础过程"></a>1、数据拷贝基础过程</h2><p>在Linux系统内部缓存和内存容量都是有限的，更多的数据都是存储在磁盘中。对于Web服务器来说，经常需要从磁盘中读取数据到内存，然后再通过网卡传输给用户：</p>
<p><img src="https://user-images.githubusercontent.com/87457873/127449894-80a158a7-c372-4fef-9466-29aab372762a.png" alt="image"></p>
<h3 id="1-1-仅CPU方式"><a href="#1-1-仅CPU方式" class="headerlink" title="1.1 仅CPU方式"></a>1.1 仅CPU方式</h3><ul>
<li>当应用程序需要读取磁盘数据时，调用read()从用户态陷入内核态，read()这个系统调用最终由CPU来完成；</li>
<li>CPU向磁盘发起I&#x2F;O请求，磁盘收到之后开始准备数据；</li>
<li>磁盘将数据放到磁盘缓冲区之后，向CPU发起I&#x2F;O中断，报告CPU数据已经Ready了；</li>
<li>CPU收到磁盘控制器的I&#x2F;O中断之后，开始拷贝数据，完成之后read()返回，再从内核态切换到用户态；</li>
</ul>
<p><img src="https://user-images.githubusercontent.com/87457873/127450013-8ab8b3b6-e17c-4a23-88bf-50ca3d1f37df.png" alt="image"></p>
<h3 id="1-2-CPU-DMA方式"><a href="#1-2-CPU-DMA方式" class="headerlink" title="1.2 CPU&amp;DMA方式"></a>1.2 CPU&amp;DMA方式</h3><p>CPU的时间宝贵，让它做杂活就是浪费资源。</p>
<p>直接内存访问（Direct Memory Access），是一种硬件设备绕开CPU独立直接访问内存的机制。所以DMA在一定程度上解放了CPU，把之前CPU的杂活让硬件直接自己做了，提高了CPU效率。</p>
<p>目前支持DMA的硬件包括：网卡、声卡、显卡、磁盘控制器等。</p>
<p><img src="https://user-images.githubusercontent.com/87457873/127450062-5cc66c49-176f-4787-a3e0-6b91ef43823d.png" alt="image"></p>
<p>有了DMA的参与之后的流程发生了一些变化：</p>
<p><img src="https://user-images.githubusercontent.com/87457873/127450081-fe549f4d-bfe8-4b49-a80c-d23c2456f57b.png" alt="image"></p>
<p>最主要的变化是，CPU不再和磁盘直接交互，而是DMA和磁盘交互并且将数据从磁盘缓冲区拷贝到内核缓冲区，之后的过程类似。</p>
<blockquote>
<p>无论从仅CPU方式和DMA&amp;CPU方式，都存在多次冗余数据拷贝和内核态&amp;用户态的切换。</p>
</blockquote>
<p>继续思考Web服务器读取本地磁盘文件数据再通过网络传输给用户的详细过程。</p>
<h2 id="2、普通模式数据交互"><a href="#2、普通模式数据交互" class="headerlink" title="2、普通模式数据交互"></a>2、普通模式数据交互</h2><p>一次完成的数据交互包括几个部分：系统调用syscall、CPU、DMA、网卡、磁盘等。</p>
<p><img src="https://user-images.githubusercontent.com/87457873/127450145-ec9cca4a-3aeb-4f55-9f50-e33980f94602.png" alt="image"></p>
<p>系统调用syscall是应用程序和内核交互的桥梁，每次进行调用&#x2F;返回就会产生两次切换：</p>
<ul>
<li>调用syscall 从用户态切换到内核态</li>
<li>syscall返回 从内核态切换到用户态</li>
</ul>
<p><img src="https://user-images.githubusercontent.com/87457873/127450184-5a82e639-f93d-4159-8a22-072dfb13b014.png" alt="image"></p>
<p>来看下完整的数据拷贝过程简图：</p>
<p><img src="https://user-images.githubusercontent.com/87457873/127450210-cdb1cdf3-b4e9-47e3-b83d-8c6e39a44240.png" alt="image"></p>
<h4 id="读数据过程："><a href="#读数据过程：" class="headerlink" title="读数据过程："></a>读数据过程：</h4><ul>
<li>应用程序要读取磁盘数据，调用read()函数从而实现用户态切换内核态，这是第1次状态切换；</li>
<li>DMA控制器将数据从磁盘拷贝到内核缓冲区，这是第1次DMA拷贝；</li>
<li>CPU将数据从内核缓冲区复制到用户缓冲区，这是第1次CPU拷贝；</li>
<li>CPU完成拷贝之后，read()函数返回实现用户态切换用户态，这是第2次状态切换；</li>
</ul>
<h4 id="写数据过程："><a href="#写数据过程：" class="headerlink" title="写数据过程："></a>写数据过程：</h4><ul>
<li>应用程序要向网卡写数据，调用write()函数实现用户态切换内核态，这是第1次切换；</li>
<li>CPU将用户缓冲区数据拷贝到内核缓冲区，这是第1次CPU拷贝；</li>
<li>DMA控制器将数据从内核缓冲区复制到socket缓冲区，这是第1次DMA拷贝；</li>
<li>完成拷贝之后，write()函数返回实现内核态切换用户态，这是第2次切换；</li>
</ul>
<h4 id="综上所述："><a href="#综上所述：" class="headerlink" title="综上所述："></a>综上所述：</h4><ul>
<li>读过程涉及2次空间切换、1次DMA拷贝、1次CPU拷贝；</li>
<li>写过程涉及2次空间切换、1次DMA拷贝、1次CPU拷贝；</li>
</ul>
<p>可见传统模式下，涉及多次空间切换和数据冗余拷贝，效率并不高，接下来就该零拷贝技术出场了。</p>
<h2 id="3、零拷贝技术"><a href="#3、零拷贝技术" class="headerlink" title="3、零拷贝技术"></a>3、零拷贝技术</h2><h3 id="3-1-出现原因"><a href="#3-1-出现原因" class="headerlink" title="3.1 出现原因"></a>3.1 出现原因</h3><p>可以看到，如果应用程序不对数据做修改，从内核缓冲区到用户缓冲区，再从用户缓冲区到内核缓冲区。两次数据拷贝都需要CPU的参与，并且涉及用户态与内核态的多次切换，加重了CPU负担。<br>需要降低冗余数据拷贝、解放CPU，这也就是零拷贝Zero-Copy技术。</p>
<h3 id="3-2-解决思路"><a href="#3-2-解决思路" class="headerlink" title="3.2 解决思路"></a>3.2 解决思路</h3><p>目前来看，零拷贝技术的几个实现手段包括：mmap+write、sendfile、sendfile+DMA收集、splice等。</p>
<p><img src="https://user-images.githubusercontent.com/87457873/127450420-bf72cc4c-f8cf-4f6b-be18-8f517ac7b931.png" alt="image"></p>
<h4 id="3-2-1-mmap方式"><a href="#3-2-1-mmap方式" class="headerlink" title="3.2.1 mmap方式"></a>3.2.1 mmap方式</h4><p>mmap是Linux提供的一种内存映射文件的机制，它实现了将内核中读缓冲区地址与用户空间缓冲区地址进行映射，从而实现内核缓冲区与用户缓冲区的共享。</p>
<p>这样就减少了一次用户态和内核态的CPU拷贝，但是在内核空间内仍然有一次CPU拷贝。</p>
<p><img src="https://user-images.githubusercontent.com/87457873/127450469-dc43f9d9-44c5-490f-b70e-69a161bdd45a.png" alt="image"></p>
<p>mmap对大文件传输有一定优势，但是小文件可能出现碎片，并且在多个进程同时操作文件时可能产生引发coredump的signal。</p>
<h4 id="3-2-2-sendfile方式"><a href="#3-2-2-sendfile方式" class="headerlink" title="3.2.2 sendfile方式"></a>3.2.2 sendfile方式</h4><p>mmap+write方式有一定改进，但是由系统调用引起的状态切换并没有减少。</p>
<p>sendfile系统调用是在 Linux 内核2.1版本中被引入，它建立了两个文件之间的传输通道。</p>
<p>sendfile方式只使用一个函数就可以完成之前的read+write 和 mmap+write的功能，这样就少了2次状态切换，由于数据不经过用户缓冲区，因此该数据无法被修改。</p>
<p><img src="https://user-images.githubusercontent.com/87457873/127450532-b7d01312-b980-43d5-b18b-4b703453e8fc.png" alt="image"></p>
<p><img src="https://user-images.githubusercontent.com/87457873/127450545-0a62516f-b836-43b6-aa45-6e95d190f5ca.png" alt="image"></p>
<p>从图中可以看到，应用程序只需要调用sendfile函数即可完成，只有2次状态切换、1次CPU拷贝、2次DMA拷贝。</p>
<p>但是sendfile在内核缓冲区和socket缓冲区仍然存在一次CPU拷贝，或许这个还可以优化。</p>
<h4 id="3-2-3-sendfile-DMA收集"><a href="#3-2-3-sendfile-DMA收集" class="headerlink" title="3.2.3 sendfile+DMA收集"></a>3.2.3 sendfile+DMA收集</h4><p>Linux 2.4 内核对 sendfile 系统调用进行优化，但是需要硬件DMA控制器的配合。</p>
<p>升级后的sendfile将内核空间缓冲区中对应的数据描述信息（文件描述符、地址偏移量等信息）记录到socket缓冲区中。</p>
<p>DMA控制器根据socket缓冲区中的地址和偏移量将数据从内核缓冲区拷贝到网卡中，从而省去了内核空间中仅剩1次CPU拷贝。</p>
<p><img src="https://user-images.githubusercontent.com/87457873/127450590-70ca2ef8-075a-4866-bf5b-c38049656d98.png" alt="image"></p>
<p>这种方式有2次状态切换、0次CPU拷贝、2次DMA拷贝，但是仍然无法对数据进行修改，并且需要硬件层面DMA的支持，并且sendfile只能将文件数据拷贝到socket描述符上，有一定的局限性。</p>
<h4 id="3-2-4-splice方式"><a href="#3-2-4-splice方式" class="headerlink" title="3.2.4 splice方式"></a>3.2.4 splice方式</h4><p>splice系统调用是Linux 在 2.6 版本引入的，其不需要硬件支持，并且不再限定于socket上，实现两个普通文件之间的数据零拷贝。</p>
<p><img src="https://user-images.githubusercontent.com/87457873/127450634-25fa7212-dd37-4e0e-82a1-de52b6139272.png" alt="image"></p>
<p>splice 系统调用可以在内核缓冲区和socket缓冲区之间建立管道来传输数据，避免了两者之间的 CPU 拷贝操作。</p>
<p><img src="https://user-images.githubusercontent.com/87457873/127450662-6316fa68-a493-42e2-9de1-b2857794142d.png" alt="image"></p>
<p>splice也有一些局限，它的两个文件描述符参数中有一个必须是管道设备。</p>
]]></content>
      <categories>
        <category>linux-doc 进程管理</category>
      </categories>
      <tags>
        <tag>Linux</tag>
      </tags>
  </entry>
  <entry>
    <title>任务调度</title>
    <url>/2023/01/15/linux-docs/%E8%BF%9B%E7%A8%8B%E7%AE%A1%E7%90%86/%E4%BB%BB%E5%8A%A1%E8%B0%83%E5%BA%A6/</url>
    <content><![CDATA[<h2 id="一-前言"><a href="#一-前言" class="headerlink" title="一. 前言"></a>一. 前言</h2><p>  在前文中，我们分析了内核中进程和线程的统一结构体task_struct，并分析进程、线程的创建和派生的过程。在本文中，我们会对任务间调度进行详细剖析，了解其原理和整个执行过程。由此，进程、线程部分的大体框架就算是介绍完了。本节主要分为三个部分：Linux内核中常见的调度策略，调度的基本结构体以及调度发生的整个流程。下面将详细展开说明。</p>
<h2 id="二-调度策略"><a href="#二-调度策略" class="headerlink" title="二. 调度策略"></a>二. 调度策略</h2><p>  Linux 作为一个多任务操作系统，将每个 CPU 的时间划分为很短的时间片，再通过调度器轮流分配给各个任务使用，因此造成多任务同时运行的错觉。为了维护 CPU 时间，Linux 通过事先定义的节拍率（内核中表示为 HZ），触发时间中断，并使用全局变量 Jiffies 记录了开机以来的节拍数。每发生一次时间中断，Jiffies 的值就加 1。节拍率 HZ 是内核的可配选项，可以设置为 100、250、1000 等。不同的系统可能设置不同数值，以通过查询 &#x2F;boot&#x2F;config 内核选项来查看它的配置值。</p>
<p>  Linux的调度策略主要分为实时任务和普通任务。实时任务需求尽快返回结果，而普通任务则没有较高的要求。在前文中我们提到了task_struct中调度策略相应的变量为policy，调度优先级有prio, static_prio, normal_prio, rt_priority几个。优先级其实就是一个数值，对于实时进程，优先级的范围是 0～99；对于普通进程，优先级的范围是 100～139。数值越小，优先级越高。</p>
<h3 id="2-1-实时调度策略"><a href="#2-1-实时调度策略" class="headerlink" title="2.1 实时调度策略"></a>2.1 实时调度策略</h3><p>  实时调度策略主要包括以下几种</p>
<ul>
<li>SCHED_FIFO：先来先出型策略，顾名思义相同优先级的情况下先到先得</li>
<li>SCHED_RR：轮询策略，注重公平性，相同优先级的任务会使用相同的时间片轮流执行</li>
<li>SCHED_DEADLINE：根据任务结束时间来进行调度，即将结束的拥有较高的优先级</li>
</ul>
<h3 id="2-2-普通调度策略"><a href="#2-2-普通调度策略" class="headerlink" title="2.2 普通调度策略"></a>2.2 普通调度策略</h3><p>  普通调度策略主要包括以下几种</p>
<ul>
<li>SCHED_NORMAL：普通任务</li>
<li>SCHED_BATCH：后台任务，优先级较低</li>
<li>SCHED_IDLE：空闲时间才会跑的任务</li>
<li>CFS：完全公平调度策略，较为特殊的一种策略。CFS 会为每一个任务安排一个虚拟运行时间 vruntime。如果一个任务在运行，随着一个个 CPU时钟tick 的到来，任务的 vruntime 将不断增大，而没有得到执行的任务的 vruntime 不变。由此，当调度的时候，vruntime较小的就拥有较高的优先级。 vruntime的实际计算方式和权重相关，由此保证了优先级高的按比例拥有更多的执行时间，从而达到完全公平。</li>
</ul>
<h2 id="三-调度相关的结构体"><a href="#三-调度相关的结构体" class="headerlink" title="三. 调度相关的结构体"></a>三. 调度相关的结构体</h2><p>  首先，我们需要一个结构体去执行调度策略，即sched_class。该类有几种实现</p>
<ul>
<li><p>stop_sched_class 优先级最高的任务会使用这种策略，会中断所有其他线程，且不会被其他任务打断；</p>
</li>
<li><p>dl_sched_class 就对应上面的 deadline 调度策略；</p>
</li>
<li><p>rt_sched_class 就对应 RR 算法或者 FIFO 算法的调度策略，具体调度策略由进程的 task_struct-&gt;policy 指定；</p>
</li>
<li><p>fair_sched_class 就是普通进程的调度策略；</p>
</li>
<li><p>idle_sched_class 就是空闲进程的调度策略。</p>
<p>其次，我们需要一个调度结构体来集合调度信息，用于调度，即sched_entity，主要有</p>
</li>
<li><p>struct sched_entity se：普通任务调度实体</p>
</li>
<li><p>struct sched_rt_entity rt：实时调度实体</p>
</li>
<li><p>struct sched_dl_entity dl：DEADLINE调度实体</p>
</li>
</ul>
<p>  普通任务调度实体源码如下，这里面包含了 vruntime 和权重 load_weight，以及对于运行时间的统计。</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">sched_entity</span> &#123;</span></span><br><span class="line">    <span class="comment">/* For load-balancing: */</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">load_weight</span>		<span class="title">load</span>;</span></span><br><span class="line">    <span class="type">unsigned</span> <span class="type">long</span>			runnable_weight;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">rb_node</span>			<span class="title">run_node</span>;</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">list_head</span>		<span class="title">group_node</span>;</span></span><br><span class="line">    <span class="type">unsigned</span> <span class="type">int</span>			on_rq;</span><br><span class="line">    u64				exec_start;</span><br><span class="line">    u64				sum_exec_runtime;</span><br><span class="line">    u64				vruntime;</span><br><span class="line">    u64				prev_sum_exec_runtime;</span><br><span class="line">    u64				nr_migrations;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">sched_statistics</span>		<span class="title">statistics</span>;</span></span><br><span class="line"><span class="meta">#<span class="keyword">ifdef</span> CONFIG_FAIR_GROUP_SCHED</span></span><br><span class="line">    <span class="type">int</span>				depth;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">sched_entity</span>		*<span class="title">parent</span>;</span></span><br><span class="line">    <span class="comment">/* rq on which this entity is (to be) queued: */</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">cfs_rq</span>			*<span class="title">cfs_rq</span>;</span></span><br><span class="line">    <span class="comment">/* rq &quot;owned&quot; by this entity/group: */</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">cfs_rq</span>			*<span class="title">my_q</span>;</span></span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">ifdef</span> CONFIG_SMP</span></span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">     * Per entity load average tracking.</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * Put into separate cache line so it does not</span></span><br><span class="line"><span class="comment">     * collide with read-mostly values above.</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">sched_avg</span>		<span class="title">avg</span>;</span></span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>  在调度时，多个任务调度实体会首先区分是实时任务还是普通任务，然后通过以时间为顺序的红黑树结构组合起来，vruntime 最小的在树的左侧，vruntime最多的在树的右侧。以CFS策略为例，则会选择红黑树最左边的叶子节点作为下一个将获得 CPU 的任务。而这颗红黑树，我们称之为运行时队列（run queue），即struct rq。</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * This is the main, per-CPU runqueue data structure.</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * Locking rule: those places that want to lock multiple runqueues</span></span><br><span class="line"><span class="comment"> * (such as the load balancing or the thread migration code), lock</span></span><br><span class="line"><span class="comment"> * acquire operations must be ordered by ascending &amp;runqueue.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">rq</span> &#123;</span></span><br><span class="line">    <span class="comment">/* runqueue lock: */</span></span><br><span class="line">    <span class="type">raw_spinlock_t</span>		lock;</span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">     * nr_running and cpu_load should be in the same cacheline because</span></span><br><span class="line"><span class="comment">     * remote CPUs use both these fields when doing load calculation.</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="type">unsigned</span> <span class="type">int</span>		nr_running;</span><br><span class="line">......</span><br><span class="line">    <span class="meta">#<span class="keyword">define</span> CPU_LOAD_IDX_MAX 5</span></span><br><span class="line">    <span class="type">unsigned</span> <span class="type">long</span>		cpu_load[CPU_LOAD_IDX_MAX];</span><br><span class="line">......</span><br><span class="line">    <span class="comment">/* capture load from *all* tasks on this CPU: */</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">load_weight</span>	<span class="title">load</span>;</span></span><br><span class="line">    <span class="type">unsigned</span> <span class="type">long</span>		nr_load_updates;</span><br><span class="line">    u64			nr_switches;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">cfs_rq</span>		<span class="title">cfs</span>;</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">rt_rq</span>		<span class="title">rt</span>;</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">dl_rq</span>		<span class="title">dl</span>;</span></span><br><span class="line">......</span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">     * This is part of a global counter where only the total sum</span></span><br><span class="line"><span class="comment">     * over all CPUs matters. A task can increase this counter on</span></span><br><span class="line"><span class="comment">     * one CPU and if it got migrated afterwards it may decrease</span></span><br><span class="line"><span class="comment">     * it on another CPU. Always updated under the runqueue lock:</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="type">unsigned</span> <span class="type">long</span>		nr_uninterruptible;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">task_struct</span>	*<span class="title">curr</span>;</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">task_struct</span>	*<span class="title">idle</span>;</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">task_struct</span>	*<span class="title">stop</span>;</span></span><br><span class="line">    <span class="type">unsigned</span> <span class="type">long</span>		next_balance;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">mm_struct</span>	*<span class="title">prev_mm</span>;</span></span><br><span class="line">    <span class="type">unsigned</span> <span class="type">int</span>		clock_update_flags;</span><br><span class="line">    u64			clock;</span><br><span class="line">    <span class="comment">/* Ensure that all clocks are in the same cache line */</span></span><br><span class="line">    u64			clock_task ____cacheline_aligned;</span><br><span class="line">    u64			clock_pelt;</span><br><span class="line">    <span class="type">unsigned</span> <span class="type">long</span>		lost_idle_time;</span><br><span class="line">    <span class="type">atomic_t</span>		nr_iowait;</span><br><span class="line">......</span><br><span class="line">    <span class="comment">/* calc_load related fields */</span></span><br><span class="line">    <span class="type">unsigned</span> <span class="type">long</span>		calc_load_update;</span><br><span class="line">    <span class="type">long</span>			calc_load_active;</span><br><span class="line">......</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>  其中包含结构体cfs_rq，其定义如下，主要是CFS调度相关的结构体，主要有权值相关变量、vruntime相关变量以及红黑树指针，其中结构体rb_root_cached即为红黑树的节点</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">/* CFS-related fields in a runqueue */</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">cfs_rq</span> &#123;</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">load_weight</span>	<span class="title">load</span>;</span></span><br><span class="line">    <span class="type">unsigned</span> <span class="type">long</span>		runnable_weight;</span><br><span class="line">    <span class="type">unsigned</span> <span class="type">int</span>		nr_running;</span><br><span class="line">    <span class="type">unsigned</span> <span class="type">int</span>		h_nr_running;</span><br><span class="line">    u64			exec_clock;</span><br><span class="line">    u64			min_vruntime;</span><br><span class="line"><span class="meta">#<span class="keyword">ifndef</span> CONFIG_64BIT</span></span><br><span class="line">    u64			min_vruntime_copy;</span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">rb_root_cached</span>	<span class="title">tasks_timeline</span>;</span></span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">     * &#x27;curr&#x27; points to currently running entity on this cfs_rq.</span></span><br><span class="line"><span class="comment">     * It is set to NULL otherwise (i.e when none are currently running).</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">sched_entity</span>	*<span class="title">curr</span>;</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">sched_entity</span>	*<span class="title">next</span>;</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">sched_entity</span>	*<span class="title">last</span>;</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">sched_entity</span>	*<span class="title">skip</span>;</span></span><br><span class="line">......</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>  对结构体dl_rq有类似的定义，运行队列由红黑树结构体构成，并按照deadline策略进行管理</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">/* Deadline class&#x27; related fields in a runqueue */</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">dl_rq</span> &#123;</span></span><br><span class="line">    <span class="comment">/* runqueue is an rbtree, ordered by deadline */</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">rb_root_cached</span>	<span class="title">root</span>;</span></span><br><span class="line">    <span class="type">unsigned</span> <span class="type">long</span>		dl_nr_running;</span><br><span class="line"><span class="meta">#<span class="keyword">ifdef</span> CONFIG_SMP</span></span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">     * Deadline values of the currently executing and the</span></span><br><span class="line"><span class="comment">     * earliest ready task on this rq. Caching these facilitates</span></span><br><span class="line"><span class="comment">     * the decision whether or not a ready but not running task</span></span><br><span class="line"><span class="comment">     * should migrate somewhere else.</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> &#123;</span></span><br><span class="line">        u64		curr;</span><br><span class="line">        u64		next;</span><br><span class="line">    &#125; earliest_dl;</span><br><span class="line">    <span class="type">unsigned</span> <span class="type">long</span>		dl_nr_migratory;</span><br><span class="line">    <span class="type">int</span>			overloaded;</span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">     * Tasks on this rq that can be pushed away. They are kept in</span></span><br><span class="line"><span class="comment">     * an rb-tree, ordered by tasks&#x27; deadlines, with caching</span></span><br><span class="line"><span class="comment">     * of the leftmost (earliest deadline) element.</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">rb_root_cached</span>	<span class="title">pushable_dl_tasks_root</span>;</span></span><br><span class="line"><span class="meta">#<span class="keyword">else</span></span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">dl_bw</span>		<span class="title">dl_bw</span>;</span></span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">     * &quot;Active utilization&quot; for this runqueue: increased when a</span></span><br><span class="line"><span class="comment">     * task wakes up (becomes TASK_RUNNING) and decreased when a</span></span><br><span class="line"><span class="comment">     * task blocks</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    u64			running_bw;</span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">     * Utilization of the tasks &quot;assigned&quot; to this runqueue (including</span></span><br><span class="line"><span class="comment">     * the tasks that are in runqueue and the tasks that executed on this</span></span><br><span class="line"><span class="comment">     * CPU and blocked). Increased when a task moves to this runqueue, and</span></span><br><span class="line"><span class="comment">     * decreased when the task moves away (migrates, changes scheduling</span></span><br><span class="line"><span class="comment">     * policy, or terminates).</span></span><br><span class="line"><span class="comment">     * This is needed to compute the &quot;inactive utilization&quot; for the</span></span><br><span class="line"><span class="comment">     * runqueue (inactive utilization = this_bw - running_bw).</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    u64			this_bw;</span><br><span class="line">    u64			extra_bw;</span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">     * Inverse of the fraction of CPU utilization that can be reclaimed</span></span><br><span class="line"><span class="comment">     * by the GRUB algorithm.</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    u64			bw_ratio;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>  对于实施队列相应的rt_rq则有所不同，并没有用红黑树实现。</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">/* Real-Time classes&#x27; related field in a runqueue: */</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">rt_rq</span> &#123;</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">rt_prio_array</span>	<span class="title">active</span>;</span></span><br><span class="line">    <span class="type">unsigned</span> <span class="type">int</span>		rt_nr_running;</span><br><span class="line">    <span class="type">unsigned</span> <span class="type">int</span>		rr_nr_running;</span><br><span class="line"><span class="meta">#<span class="keyword">if</span> defined CONFIG_SMP || defined CONFIG_RT_GROUP_SCHED</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> &#123;</span></span><br><span class="line">        <span class="type">int</span>		curr; <span class="comment">/* highest queued rt task prio */</span></span><br><span class="line"><span class="meta">#<span class="keyword">ifdef</span> CONFIG_SMP</span></span><br><span class="line">        <span class="type">int</span>		next; <span class="comment">/* next highest */</span></span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line">    &#125; highest_prio;</span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">ifdef</span> CONFIG_SMP</span></span><br><span class="line">    <span class="type">unsigned</span> <span class="type">long</span>		rt_nr_migratory;</span><br><span class="line">    <span class="type">unsigned</span> <span class="type">long</span>		rt_nr_total;</span><br><span class="line">    <span class="type">int</span>			overloaded;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">plist_head</span>	<span class="title">pushable_tasks</span>;</span></span><br><span class="line"><span class="meta">#<span class="keyword">endif</span> <span class="comment">/* CONFIG_SMP */</span></span></span><br><span class="line">    <span class="type">int</span>			rt_queued;</span><br><span class="line">    <span class="type">int</span>			rt_throttled;</span><br><span class="line">    u64			rt_time;</span><br><span class="line">    u64			rt_runtime;</span><br><span class="line">    <span class="comment">/* Nests inside the rq lock: */</span></span><br><span class="line">    <span class="type">raw_spinlock_t</span>		rt_runtime_lock;</span><br><span class="line"><span class="meta">#<span class="keyword">ifdef</span> CONFIG_RT_GROUP_SCHED</span></span><br><span class="line">    <span class="type">unsigned</span> <span class="type">long</span>		rt_nr_boosted;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">rq</span>		*<span class="title">rq</span>;</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">task_group</span>	*<span class="title">tg</span>;</span></span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>  下面再看看调度类sched_class，该类以函数指针的形式定义了诸多队列操作，如</p>
<ul>
<li>enqueue_task 向就绪队列中添加一个任务，当某个任务进入可运行状态时，调用这个函数；</li>
<li>dequeue_task 将一个任务从就绪队列中删除；</li>
<li>yield_task将主动放弃CPU；</li>
<li>yield_to_task主动放弃CPU并执行指定的task_struct；</li>
<li>check_preempt_curr检查当前任务是否可被强占；</li>
<li>pick_next_task 选择接下来要运行的任务；</li>
<li>put_prev_task 用另一个进程代替当前运行的任务；</li>
<li>set_curr_task 用于修改调度策略；</li>
<li>task_tick 每次周期性时钟到的时候，这个函数被调用，可能触发调度。</li>
<li>task_dead:进程结束时调用</li>
<li>switched_from、switched_to:进程改变调度器时使用</li>
<li>prio_changed:改变进程优先级</li>
</ul>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">sched_class</span> &#123;</span></span><br><span class="line">    <span class="type">const</span> <span class="class"><span class="keyword">struct</span> <span class="title">sched_class</span> *<span class="title">next</span>;</span></span><br><span class="line">    <span class="type">void</span> (*enqueue_task) (<span class="keyword">struct</span> rq *rq, <span class="keyword">struct</span> task_struct *p, <span class="type">int</span> flags);</span><br><span class="line">    <span class="type">void</span> (*dequeue_task) (<span class="keyword">struct</span> rq *rq, <span class="keyword">struct</span> task_struct *p, <span class="type">int</span> flags);</span><br><span class="line">    <span class="type">void</span> (*yield_task)   (<span class="keyword">struct</span> rq *rq);</span><br><span class="line">    <span class="type">bool</span> (*yield_to_task)(<span class="keyword">struct</span> rq *rq, <span class="keyword">struct</span> task_struct *p, <span class="type">bool</span> preempt);</span><br><span class="line">    <span class="type">void</span> (*check_preempt_curr)(<span class="keyword">struct</span> rq *rq, <span class="keyword">struct</span> task_struct *p, <span class="type">int</span> flags);</span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">     * It is the responsibility of the pick_next_task() method that will</span></span><br><span class="line"><span class="comment">     * return the next task to call put_prev_task() on the @prev task or</span></span><br><span class="line"><span class="comment">     * something equivalent.</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * May return RETRY_TASK when it finds a higher prio class has runnable</span></span><br><span class="line"><span class="comment">     * tasks.</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">task_struct</span> * (*<span class="title">pick_next_task</span>)(<span class="keyword">struct</span> <span class="title">rq</span> *<span class="title">rq</span>,</span></span><br><span class="line"><span class="class">                           <span class="keyword">struct</span> <span class="title">task_struct</span> *<span class="title">prev</span>,</span></span><br><span class="line"><span class="class">                    *        <span class="keyword">struct</span> <span class="title">rq_flags</span> *<span class="title">rf</span>);</span></span><br><span class="line">    <span class="type">void</span> (*put_prev_task)(<span class="keyword">struct</span> rq *rq, <span class="keyword">struct</span> task_struct *p);</span><br><span class="line">......</span><br><span class="line">    <span class="type">void</span> (*set_curr_task)(<span class="keyword">struct</span> rq *rq);</span><br><span class="line">    <span class="type">void</span> (*task_tick)(<span class="keyword">struct</span> rq *rq, <span class="keyword">struct</span> task_struct *p, <span class="type">int</span> queued);</span><br><span class="line">    <span class="type">void</span> (*task_fork)(<span class="keyword">struct</span> task_struct *p);</span><br><span class="line">    <span class="type">void</span> (*task_dead)(<span class="keyword">struct</span> task_struct *p);</span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">     * The switched_from() call is allowed to drop rq-&gt;lock, therefore we</span></span><br><span class="line"><span class="comment">     * cannot assume the switched_from/switched_to pair is serliazed by</span></span><br><span class="line"><span class="comment">     * rq-&gt;lock. They are however serialized by p-&gt;pi_lock.</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="type">void</span> (*switched_from)(<span class="keyword">struct</span> rq *this_rq, <span class="keyword">struct</span> task_struct *task);</span><br><span class="line">    <span class="type">void</span> (*switched_to)  (<span class="keyword">struct</span> rq *this_rq, <span class="keyword">struct</span> task_struct *task);</span><br><span class="line">    <span class="type">void</span> (*prio_changed) (<span class="keyword">struct</span> rq *this_rq, <span class="keyword">struct</span> task_struct *task,</span><br><span class="line">                  <span class="type">int</span> oldprio);</span><br><span class="line">    <span class="type">unsigned</span> <span class="title function_">int</span> <span class="params">(*get_rr_interval)</span><span class="params">(<span class="keyword">struct</span> rq *rq,</span></span><br><span class="line"><span class="params">                    <span class="keyword">struct</span> task_struct *task)</span>;</span><br><span class="line">    <span class="type">void</span> (*update_curr)(<span class="keyword">struct</span> rq *rq);</span><br><span class="line"><span class="meta">#<span class="keyword">define</span> TASK_SET_GROUP		0</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> TASK_MOVE_GROUP		1</span></span><br><span class="line">......</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>  调度类分为下面几种：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="keyword">extern</span> <span class="type">const</span> <span class="class"><span class="keyword">struct</span> <span class="title">sched_class</span> <span class="title">stop_sched_class</span>;</span></span><br><span class="line"><span class="keyword">extern</span> <span class="type">const</span> <span class="class"><span class="keyword">struct</span> <span class="title">sched_class</span> <span class="title">dl_sched_class</span>;</span></span><br><span class="line"><span class="keyword">extern</span> <span class="type">const</span> <span class="class"><span class="keyword">struct</span> <span class="title">sched_class</span> <span class="title">rt_sched_class</span>;</span></span><br><span class="line"><span class="keyword">extern</span> <span class="type">const</span> <span class="class"><span class="keyword">struct</span> <span class="title">sched_class</span> <span class="title">fair_sched_class</span>;</span></span><br><span class="line"><span class="keyword">extern</span> <span class="type">const</span> <span class="class"><span class="keyword">struct</span> <span class="title">sched_class</span> <span class="title">idle_sched_class</span>;</span></span><br></pre></td></tr></table></figure>
<p>  队列操作中函数指针指向不同策略队列的实际执行函数函数，在linux&#x2F;kernel&#x2F;sched&#x2F;目录下，fair.c、idle.c、rt.c等文件对不同类型的策略实现了不同的函数，如fair.c中定义了</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * All the scheduling class methods:</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="type">const</span> <span class="class"><span class="keyword">struct</span> <span class="title">sched_class</span> <span class="title">fair_sched_class</span> =</span> &#123;</span><br><span class="line">    .next			    = &amp;idle_sched_class,</span><br><span class="line">    .enqueue_task		= enqueue_task_fair,</span><br><span class="line">    .dequeue_task		= dequeue_task_fair,</span><br><span class="line">    .yield_task		    = yield_task_fair,</span><br><span class="line">    .yield_to_task		= yield_to_task_fair,</span><br><span class="line">    .check_preempt_curr	 = check_preempt_wakeup,</span><br><span class="line">    .pick_next_task		 = pick_next_task_fair,</span><br><span class="line">    .put_prev_task		 = put_prev_task_fair,</span><br><span class="line">......</span><br><span class="line">    .set_curr_task       = set_curr_task_fair,</span><br><span class="line">    .task_tick		    = task_tick_fair,</span><br><span class="line">    .task_fork		    = task_fork_fair,</span><br><span class="line">    .prio_changed		= prio_changed_fair,</span><br><span class="line">    .switched_from		= switched_from_fair,</span><br><span class="line">    .switched_to		= switched_to_fair,</span><br><span class="line">    .get_rr_interval	= get_rr_interval_fair,</span><br><span class="line">    .update_curr		= update_curr_fair,</span><br><span class="line">......</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>以选择下一个任务为例，CFS对应的是pick_next_task_fair，而rt_rq对应的则是pick_next_task_rt，等等。</p>
<p>  由此，我们来总结一下：</p>
<ul>
<li>每个CPU都有一个struct rq结构体，里面会有着cfs_rq, rt_rq等一系列队列</li>
<li>每个队列由一个红黑树组织，红黑树里每一个节点为一个任务实体sched_entity</li>
<li>每一个任务实体sched_entity对应于一个任务task_struct</li>
<li>在task_struct中对应的sched_class会根据不同策略申明不同的对应处理函数，处理实际的调度工作</li>
</ul>
<h2 id="四-调度流程"><a href="#四-调度流程" class="headerlink" title="四. 调度流程"></a>四. 调度流程</h2><p>  有了上述的基本策略和基本调度结构体，我们可以形成大致的骨架，下面就是需要核心的调度流程将其拼凑成一个整体，实现调度系统。调度分为两种，主动调度和抢占式调度。</p>
<ul>
<li>主动调度即任务执行一定时间以后主动让出CPU，通过调度策略选择合适的下一个任务执行。</li>
<li>抢占式调度即任务执行中收到了其他任务的中断，由此停止执行并切换至下一个任务。</li>
</ul>
<h3 id="4-1-主动调度"><a href="#4-1-主动调度" class="headerlink" title="4.1 主动调度"></a>4.1 主动调度</h3><p>  说到调用，逃不过核心函数schedule()。其中sched_submit_work()函数完成当前任务的收尾工作，以避免出现如死锁或者IO中断等情况。之后首先禁止抢占式调度的发生，然后调用__schedule()函数完成调度，之后重新打开抢占式调度，如果需要重新调度则会一直重复该过程，否则结束函数。</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">asmlinkage __visible <span class="type">void</span> __sched <span class="title function_">schedule</span><span class="params">(<span class="type">void</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">task_struct</span> *<span class="title">tsk</span> =</span> current;</span><br><span class="line">    sched_submit_work(tsk);</span><br><span class="line">    <span class="keyword">do</span> &#123;</span><br><span class="line">        preempt_disable();</span><br><span class="line">        __schedule(<span class="literal">false</span>);</span><br><span class="line">        sched_preempt_enable_no_resched();</span><br><span class="line">    &#125; <span class="keyword">while</span> (need_resched());</span><br><span class="line">&#125;</span><br><span class="line">EXPORT_SYMBOL(schedule);</span><br></pre></td></tr></table></figure>
<p>而__schedule()函数则是实际的核心调度函数，该函数主要操作包括选取下一进程和进行上下文切换，而上下文切换又包括用户态空间切换和内核态的切换。具体的解释可以参照英文源码注释以及中文对各个步骤的注释。</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * __schedule() is the main scheduler function.</span></span><br><span class="line"><span class="comment"> * The main means of driving the scheduler and thus entering this function are:</span></span><br><span class="line"><span class="comment"> *   1. Explicit blocking: mutex, semaphore, waitqueue, etc.</span></span><br><span class="line"><span class="comment"> *   2. TIF_NEED_RESCHED flag is checked on interrupt and userspace return</span></span><br><span class="line"><span class="comment"> *      paths. For example, see arch/x86/entry_64.S.</span></span><br><span class="line"><span class="comment"> *      To drive preemption between tasks, the scheduler sets the flag in timer</span></span><br><span class="line"><span class="comment"> *      interrupt handler scheduler_tick().</span></span><br><span class="line"><span class="comment"> *   3. Wakeups don&#x27;t really cause entry into schedule(). They add a</span></span><br><span class="line"><span class="comment"> *      task to the run-queue and that&#x27;s it.</span></span><br><span class="line"><span class="comment"> *      Now, if the new task added to the run-queue preempts the current</span></span><br><span class="line"><span class="comment"> *      task, then the wakeup sets TIF_NEED_RESCHED and schedule() gets</span></span><br><span class="line"><span class="comment"> *      called on the nearest possible occasion:</span></span><br><span class="line"><span class="comment"> *       - If the kernel is preemptible (CONFIG_PREEMPT=y):</span></span><br><span class="line"><span class="comment"> *         - in syscall or exception context, at the next outmost</span></span><br><span class="line"><span class="comment"> *           preempt_enable(). (this might be as soon as the wake_up()&#x27;s</span></span><br><span class="line"><span class="comment"> *           spin_unlock()!)</span></span><br><span class="line"><span class="comment"> *         - in IRQ context, return from interrupt-handler to</span></span><br><span class="line"><span class="comment"> *           preemptible context</span></span><br><span class="line"><span class="comment"> *       - If the kernel is not preemptible (CONFIG_PREEMPT is not set)</span></span><br><span class="line"><span class="comment"> *         then at the next:</span></span><br><span class="line"><span class="comment"> *          - cond_resched() call</span></span><br><span class="line"><span class="comment"> *          - explicit schedule() call</span></span><br><span class="line"><span class="comment"> *          - return from syscall or exception to user-space</span></span><br><span class="line"><span class="comment"> *          - return from interrupt-handler to user-space</span></span><br><span class="line"><span class="comment"> * WARNING: must be called with preemption disabled!</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="type">static</span> <span class="type">void</span> __sched notrace __schedule(<span class="type">bool</span> preempt)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">task_struct</span> *<span class="title">prev</span>, *<span class="title">next</span>;</span></span><br><span class="line">    <span class="type">unsigned</span> <span class="type">long</span> *switch_count;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">rq_flags</span> <span class="title">rf</span>;</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">rq</span> *<span class="title">rq</span>;</span></span><br><span class="line">    <span class="type">int</span> cpu;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//从当前的CPU中取出任务队列rq，prev赋值为当前任务</span></span><br><span class="line">    cpu = smp_processor_id();</span><br><span class="line">    rq = cpu_rq(cpu);</span><br><span class="line">    prev = rq-&gt;curr;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//检测当前任务是否可以调度</span></span><br><span class="line">    schedule_debug(prev);</span><br><span class="line">    <span class="keyword">if</span> (sched_feat(HRTICK))</span><br><span class="line">        hrtick_clear(rq);</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//禁止中断，RCU抢占关闭，队列加锁，SMP加锁</span></span><br><span class="line">    local_irq_disable();</span><br><span class="line">    rcu_note_context_switch(preempt);</span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">     * Make sure that signal_pending_state()-&gt;signal_pending() below</span></span><br><span class="line"><span class="comment">     * can&#x27;t be reordered with __set_current_state(TASK_INTERRUPTIBLE)</span></span><br><span class="line"><span class="comment">     * done by the caller to avoid the race with signal_wake_up().</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * The membarrier system call requires a full memory barrier</span></span><br><span class="line"><span class="comment">     * after coming from user-space, before storing to rq-&gt;curr.</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    rq_lock(rq, &amp;rf);</span><br><span class="line">    smp_mb__after_spinlock();</span><br><span class="line">    </span><br><span class="line">    <span class="comment">/* Promote REQ to ACT */</span></span><br><span class="line">    rq-&gt;clock_update_flags &lt;&lt;= <span class="number">1</span>;</span><br><span class="line">    update_rq_clock(rq);</span><br><span class="line">    switch_count = &amp;prev-&gt;nivcsw;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">if</span> (!preempt &amp;&amp; prev-&gt;state) &#123;</span><br><span class="line">        <span class="comment">//不可中断的任务则继续执行</span></span><br><span class="line">        <span class="keyword">if</span> (signal_pending_state(prev-&gt;state, prev)) &#123;</span><br><span class="line">            prev-&gt;state = TASK_RUNNING;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="comment">//当前任务从队列rq中出队，on_rq设置为0，如果存在I/O未完成则延时完成</span></span><br><span class="line">            deactivate_task(rq, prev, DEQUEUE_SLEEP | DEQUEUE_NOCLOCK);</span><br><span class="line">            prev-&gt;on_rq = <span class="number">0</span>;</span><br><span class="line">            <span class="keyword">if</span> (prev-&gt;in_iowait) &#123;</span><br><span class="line">                <span class="type">atomic_inc</span>(&amp;rq-&gt;nr_iowait);</span><br><span class="line">                delayacct_blkio_start();</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">/* 唤醒睡眠进程</span></span><br><span class="line"><span class="comment">             * If a worker went to sleep, notify and ask workqueue</span></span><br><span class="line"><span class="comment">             * whether it wants to wake up a task to maintain</span></span><br><span class="line"><span class="comment">             * concurrency.</span></span><br><span class="line"><span class="comment">             */</span></span><br><span class="line">            <span class="keyword">if</span> (prev-&gt;flags &amp; PF_WQ_WORKER) &#123;</span><br><span class="line">                <span class="class"><span class="keyword">struct</span> <span class="title">task_struct</span> *<span class="title">to_wakeup</span>;</span></span><br><span class="line">                to_wakeup = wq_worker_sleeping(prev);</span><br><span class="line">                <span class="keyword">if</span> (to_wakeup)</span><br><span class="line">                    try_to_wake_up_local(to_wakeup, &amp;rf);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        switch_count = &amp;prev-&gt;nvcsw;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 调用pick_next_task获取下一个任务，赋值给next</span></span><br><span class="line">    next = pick_next_task(rq, prev, &amp;rf);</span><br><span class="line">    clear_tsk_need_resched(prev);</span><br><span class="line">    clear_preempt_need_resched();</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 如果产生了任务切换，则需要切换上下文</span></span><br><span class="line">    <span class="keyword">if</span> (likely(prev != next)) &#123;</span><br><span class="line">        rq-&gt;nr_switches++;</span><br><span class="line">        rq-&gt;curr = next;</span><br><span class="line">        <span class="comment">/*</span></span><br><span class="line"><span class="comment">         * The membarrier system call requires each architecture</span></span><br><span class="line"><span class="comment">         * to have a full memory barrier after updating</span></span><br><span class="line"><span class="comment">         * rq-&gt;curr, before returning to user-space.</span></span><br><span class="line"><span class="comment">         *</span></span><br><span class="line"><span class="comment">         * Here are the schemes providing that barrier on the</span></span><br><span class="line"><span class="comment">         * various architectures:</span></span><br><span class="line"><span class="comment">         * - mm ? switch_mm() : mmdrop() for x86, s390, sparc, PowerPC.</span></span><br><span class="line"><span class="comment">         *   switch_mm() rely on membarrier_arch_switch_mm() on PowerPC.</span></span><br><span class="line"><span class="comment">         * - finish_lock_switch() for weakly-ordered</span></span><br><span class="line"><span class="comment">         *   architectures where spin_unlock is a full barrier,</span></span><br><span class="line"><span class="comment">         * - switch_to() for arm64 (weakly-ordered, spin_unlock</span></span><br><span class="line"><span class="comment">         *   is a RELEASE barrier),</span></span><br><span class="line"><span class="comment">         */</span></span><br><span class="line">        ++*switch_count;</span><br><span class="line">        trace_sched_switch(preempt, prev, next);</span><br><span class="line">        <span class="comment">/* Also unlocks the rq: */</span></span><br><span class="line">        rq = context_switch(rq, prev, next, &amp;rf);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="comment">// 清除标记位，重开中断</span></span><br><span class="line">        rq-&gt;clock_update_flags &amp;= ~(RQCF_ACT_SKIP|RQCF_REQ_SKIP);</span><br><span class="line">        rq_unlock_irq(rq, &amp;rf);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//队列自平衡：红黑树平衡操作</span></span><br><span class="line">    balance_callback(rq);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>  其中核心函数是获取下一个任务的pick_next_task()以及上下文切换的context_switch()，下面详细展开剖析。首先看看pick_next_task()，该函数会根据调度策略分类，调用该类对应的调度函数选择下一个任务实体。根据前文分析我们知道，最终是在不同的红黑树上选择最左节点作为下一个任务实体并返回。</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * Pick up the highest-prio task:</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="type">static</span> <span class="keyword">inline</span> <span class="keyword">struct</span> task_struct *</span><br><span class="line"><span class="title function_">pick_next_task</span><span class="params">(<span class="keyword">struct</span> rq *rq, <span class="keyword">struct</span> task_struct *prev, <span class="keyword">struct</span> rq_flags *rf)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">const</span> <span class="class"><span class="keyword">struct</span> <span class="title">sched_class</span> *<span class="keyword">class</span>;</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">task_struct</span> *<span class="title">p</span>;</span></span><br><span class="line">    <span class="comment">/* 这里做了一个优化：如果是普通调度策略则直接调用fair_sched_class中的pick_next_task</span></span><br><span class="line"><span class="comment">     * Optimization: we know that if all tasks are in the fair class we can</span></span><br><span class="line"><span class="comment">     * call that function directly, but only if the @prev task wasn&#x27;t of a</span></span><br><span class="line"><span class="comment">     * higher scheduling class, because otherwise those loose the</span></span><br><span class="line"><span class="comment">     * opportunity to pull in more work from other CPUs.</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">if</span> (likely((prev-&gt;sched_class == &amp;idle_sched_class ||</span><br><span class="line">            prev-&gt;sched_class == &amp;fair_sched_class) &amp;&amp;</span><br><span class="line">           rq-&gt;nr_running == rq-&gt;cfs.h_nr_running)) &#123;</span><br><span class="line">        p = fair_sched_class.pick_next_task(rq, prev, rf);</span><br><span class="line">        <span class="keyword">if</span> (unlikely(p == RETRY_TASK))</span><br><span class="line">            <span class="keyword">goto</span> again;</span><br><span class="line">        <span class="comment">/* Assumes fair_sched_class-&gt;next == idle_sched_class */</span></span><br><span class="line">        <span class="keyword">if</span> (unlikely(!p))</span><br><span class="line">            p = idle_sched_class.pick_next_task(rq, prev, rf);</span><br><span class="line">        <span class="keyword">return</span> p;</span><br><span class="line">    &#125;</span><br><span class="line">again:</span><br><span class="line">    <span class="comment">//依次调用类中的选择函数，如果正确选择到下一个任务则返回</span></span><br><span class="line">    for_each_class(class) &#123;</span><br><span class="line">        p = class-&gt;pick_next_task(rq, prev, rf);</span><br><span class="line">        <span class="keyword">if</span> (p) &#123;</span><br><span class="line">            <span class="keyword">if</span> (unlikely(p == RETRY_TASK))</span><br><span class="line">                <span class="keyword">goto</span> again;</span><br><span class="line">            <span class="keyword">return</span> p;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">/* The idle class should always have a runnable task: */</span></span><br><span class="line">    BUG();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>  下面来看看上下文切换。上下文切换主要干两件事情，一是切换任务空间，也即虚拟内存；二是切换寄存器和 CPU 上下文。关于任务空间的切换放在内存部分的文章中详细介绍，这里先按下不表，通过任务空间切换实际完成了用户态的上下文切换工作。下面我们重点看一下内核态切换，即寄存器和CPU上下文的切换。</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * context_switch - switch to the new MM and the new thread&#x27;s register state.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="type">static</span> __always_inline <span class="keyword">struct</span> rq *</span><br><span class="line"><span class="title function_">context_switch</span><span class="params">(<span class="keyword">struct</span> rq *rq, <span class="keyword">struct</span> task_struct *prev,</span></span><br><span class="line"><span class="params">           <span class="keyword">struct</span> task_struct *next, <span class="keyword">struct</span> rq_flags *rf)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">mm_struct</span> *<span class="title">mm</span>, *<span class="title">oldmm</span>;</span></span><br><span class="line">    prepare_task_switch(rq, prev, next);</span><br><span class="line">    mm = next-&gt;mm;</span><br><span class="line">    oldmm = prev-&gt;active_mm;</span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">     * For paravirt, this is coupled with an exit in switch_to to</span></span><br><span class="line"><span class="comment">     * combine the page table reload and the switch backend into</span></span><br><span class="line"><span class="comment">     * one hypercall.</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    arch_start_context_switch(prev);</span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">     * If mm is non-NULL, we pass through switch_mm(). If mm is</span></span><br><span class="line"><span class="comment">     * NULL, we will pass through mmdrop() in finish_task_switch().</span></span><br><span class="line"><span class="comment">     * Both of these contain the full memory barrier required by</span></span><br><span class="line"><span class="comment">     * membarrier after storing to rq-&gt;curr, before returning to</span></span><br><span class="line"><span class="comment">     * user-space.</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">if</span> (!mm) &#123;</span><br><span class="line">        next-&gt;active_mm = oldmm;</span><br><span class="line">        mmgrab(oldmm);</span><br><span class="line">        enter_lazy_tlb(oldmm, next);</span><br><span class="line">    &#125; <span class="keyword">else</span></span><br><span class="line">        switch_mm_irqs_off(oldmm, mm, next);</span><br><span class="line">    <span class="keyword">if</span> (!prev-&gt;mm) &#123;</span><br><span class="line">        prev-&gt;active_mm = <span class="literal">NULL</span>;</span><br><span class="line">        rq-&gt;prev_mm = oldmm;</span><br><span class="line">    &#125;</span><br><span class="line">    rq-&gt;clock_update_flags &amp;= ~(RQCF_ACT_SKIP|RQCF_REQ_SKIP);</span><br><span class="line">    prepare_lock_switch(rq, next, rf);</span><br><span class="line">    <span class="comment">/* Here we just switch the register state and the stack. */</span></span><br><span class="line">    switch_to(prev, next, prev);</span><br><span class="line">    <span class="comment">//barrier 语句是一个编译器指令，用于保证 switch_to 和 finish_task_switch 的执行顺序不会因为编译阶段优化而改变</span></span><br><span class="line">    barrier();</span><br><span class="line">    <span class="keyword">return</span> finish_task_switch(prev);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>  switch_to()就是寄存器和栈的切换，它调用到了 __switch_to_asm。这是一段汇编代码，主要用于栈的切换， 其中32位使用esp作为栈顶指针，64位使用rsp，其他部分代码一致。通过该段汇编代码我们完成了栈顶指针的切换，并调用__switch_to完成最终TSS的切换。注意switch_to中其实是有三个变量，分别是prev, next, last，而实际在使用时，我们会对last也赋值为prev。这里的设计意图需要结合一个例子来说明。假设有ABC三个任务，从A调度到B，B到C，最后C回到A，我们假设仅保存prev和next，则流程如下</p>
<ul>
<li>A保存内核栈和寄存器，切换至B，此时prev &#x3D; A, next &#x3D; B，该状态会保存在栈里，等下次调用A的时候再恢复。然后调用B的finish_task_switch()继续执行下去，返回B的队列rq，</li>
<li>B保存内核栈和寄存器，切换至C</li>
<li>C保存内核栈和寄存器，切换至A。A从barrier()开始运行，而A从步骤1中保存的prev &#x3D; A, next &#x3D; B则完美的避开了C，丢失了C的信息。因此last指针的重要性就出现了。在执行完__switch_to_asm后，A的内核栈和寄存器重新覆盖了prev和next，但是我们通过返回值提供了C的内存地址，保存在last中，在finish_task_switch中完成清理工作。</li>
</ul>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">define</span> switch_to(prev, next, last)			      \</span></span><br><span class="line"><span class="meta">do &#123;									       \</span></span><br><span class="line"><span class="meta">    prepare_switch_to(next);					\</span></span><br><span class="line"><span class="meta">                                               \</span></span><br><span class="line"><span class="meta">    ((last) = __switch_to_asm((prev), (next)));	  \</span></span><br><span class="line"><span class="meta">&#125; while (0)</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * %eax: prev task</span></span><br><span class="line"><span class="comment"> * %edx: next task</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line">ENTRY(__switch_to_asm)</span><br><span class="line">......</span><br><span class="line">  <span class="comment">/* switch stack */</span></span><br><span class="line">  movl  %esp, TASK_threadsp(%eax)</span><br><span class="line">  movl  <span class="title function_">TASK_threadsp</span><span class="params">(%edx)</span>, %esp</span><br><span class="line">......</span><br><span class="line">  jmp  __switch_to</span><br><span class="line"><span class="title function_">END</span><span class="params">(__switch_to_asm)</span></span><br></pre></td></tr></table></figure>
<p>  最终调用__switch_to()函数。该函数中涉及到一个结构体TSS(Task State Segment)，该结构体存放了所有的寄存器。另外还有一个特殊的寄存器TR（Task Register）会指向TSS，我们通过更改TR的值，会触发硬件保存CPU所有寄存器在当前TSS，并从新的TSS读取寄存器的值加载入CPU，从而完成一次硬中断带来的上下文切换工作。系统初始化的时候，会调用 cpu_init()给每一个 CPU 关联一个 TSS，然后将 TR 指向这个 TSS，然后在操作系统的运行过程中，TR 就不切换了，永远指向这个 TSS。当修改TR的值得时候，则为任务调度。</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> *	switch_to(x,y) should switch tasks from x to y.</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * We fsave/fwait so that an exception goes off at the right time</span></span><br><span class="line"><span class="comment"> * (as a call from the fsave or fwait in effect) rather than to</span></span><br><span class="line"><span class="comment"> * the wrong process. Lazy FP saving no longer makes any sense</span></span><br><span class="line"><span class="comment"> * with modern CPU&#x27;s, and this simplifies a lot of things (SMP</span></span><br><span class="line"><span class="comment"> * and UP become the same).</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * NOTE! We used to use the x86 hardware context switching. The</span></span><br><span class="line"><span class="comment"> * reason for not using it any more becomes apparent when you</span></span><br><span class="line"><span class="comment"> * try to recover gracefully from saved state that is no longer</span></span><br><span class="line"><span class="comment"> * valid (stale segment register values in particular). With the</span></span><br><span class="line"><span class="comment"> * hardware task-switch, there is no way to fix up bad state in</span></span><br><span class="line"><span class="comment"> * a reasonable manner.</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * The fact that Intel documents the hardware task-switching to</span></span><br><span class="line"><span class="comment"> * be slow is a fairly red herring - this code is not noticeably</span></span><br><span class="line"><span class="comment"> * faster. However, there _is_ some room for improvement here,</span></span><br><span class="line"><span class="comment"> * so the performance issues may eventually be a valid point.</span></span><br><span class="line"><span class="comment"> * More important, however, is the fact that this allows us much</span></span><br><span class="line"><span class="comment"> * more flexibility.</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * The return value (in %ax) will be the &quot;prev&quot; task after</span></span><br><span class="line"><span class="comment"> * the task-switch, and shows up in ret_from_fork in entry.S,</span></span><br><span class="line"><span class="comment"> * for example.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line">__visible __notrace_funcgraph <span class="class"><span class="keyword">struct</span> <span class="title">task_struct</span> *</span></span><br><span class="line"><span class="class">__<span class="title">switch_to</span>(<span class="keyword">struct</span> <span class="title">task_struct</span> *<span class="title">prev_p</span>, <span class="keyword">struct</span> <span class="title">task_struct</span> *<span class="title">next_p</span>)</span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">thread_struct</span> *<span class="title">prev</span> =</span> &amp;prev_p-&gt;thread,</span><br><span class="line">                 *next = &amp;next_p-&gt;thread;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">fpu</span> *<span class="title">prev_fpu</span> =</span> &amp;prev-&gt;fpu;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">fpu</span> *<span class="title">next_fpu</span> =</span> &amp;next-&gt;fpu;</span><br><span class="line">    <span class="type">int</span> cpu = smp_processor_id();</span><br><span class="line">    <span class="comment">/* never put a printk in __switch_to... printk() calls wake_up*() indirectly */</span></span><br><span class="line">    switch_fpu_prepare(prev_fpu, cpu);</span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">     * Save away %gs. No need to save %fs, as it was saved on the</span></span><br><span class="line"><span class="comment">     * stack on entry.  No need to save %es and %ds, as those are</span></span><br><span class="line"><span class="comment">     * always kernel segments while inside the kernel.  Doing this</span></span><br><span class="line"><span class="comment">     * before setting the new TLS descriptors avoids the situation</span></span><br><span class="line"><span class="comment">     * where we temporarily have non-reloadable segments in %fs</span></span><br><span class="line"><span class="comment">     * and %gs.  This could be an issue if the NMI handler ever</span></span><br><span class="line"><span class="comment">     * used %fs or %gs (it does not today), or if the kernel is</span></span><br><span class="line"><span class="comment">     * running inside of a hypervisor layer.</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    lazy_save_gs(prev-&gt;gs);</span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">     * Load the per-thread Thread-Local Storage descriptor.</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    load_TLS(next, cpu);</span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">     * Restore IOPL if needed.  In normal use, the flags restore</span></span><br><span class="line"><span class="comment">     * in the switch assembly will handle this.  But if the kernel</span></span><br><span class="line"><span class="comment">     * is running virtualized at a non-zero CPL, the popf will</span></span><br><span class="line"><span class="comment">     * not restore flags, so it must be done in a separate step.</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">if</span> (get_kernel_rpl() &amp;&amp; unlikely(prev-&gt;iopl != next-&gt;iopl))</span><br><span class="line">        set_iopl_mask(next-&gt;iopl);</span><br><span class="line">    switch_to_extra(prev_p, next_p);</span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">     * Leave lazy mode, flushing any hypercalls made here.</span></span><br><span class="line"><span class="comment">     * This must be done before restoring TLS segments so</span></span><br><span class="line"><span class="comment">     * the GDT and LDT are properly updated, and must be</span></span><br><span class="line"><span class="comment">     * done before fpu__restore(), so the TS bit is up</span></span><br><span class="line"><span class="comment">     * to date.</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    arch_end_context_switch(next_p);</span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">     * Reload esp0 and cpu_current_top_of_stack.  This changes</span></span><br><span class="line"><span class="comment">     * current_thread_info().  Refresh the SYSENTER configuration in</span></span><br><span class="line"><span class="comment">     * case prev or next is vm86.</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    update_task_stack(next_p);</span><br><span class="line">    refresh_sysenter_cs(next);</span><br><span class="line">    this_cpu_write(cpu_current_top_of_stack,</span><br><span class="line">               (<span class="type">unsigned</span> <span class="type">long</span>)task_stack_page(next_p) +</span><br><span class="line">               THREAD_SIZE);</span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">     * Restore %gs if needed (which is common)</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">if</span> (prev-&gt;gs | next-&gt;gs)</span><br><span class="line">        lazy_load_gs(next-&gt;gs);</span><br><span class="line">    switch_fpu_finish(next_fpu, cpu);</span><br><span class="line">    this_cpu_write(current_task, next_p);</span><br><span class="line">    <span class="comment">/* Load the Intel cache allocation PQR MSR. */</span></span><br><span class="line">    resctrl_sched_in();</span><br><span class="line">    <span class="keyword">return</span> prev_p;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>  在完成了switch_to()的内核态切换后，还有一个重要的函数finish_task_switch()负责善后清理工作。在前面介绍switch_to三个参数的时候我们已经说明了使用last的重要性。而这里为何让prev和last均赋值为prev，是因为prev在后面没有需要用到，所以节省了一个指针空间来存储last。</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * finish_task_switch - clean up after a task-switch</span></span><br><span class="line"><span class="comment"> * @prev: the thread we just switched away from.</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * finish_task_switch must be called after the context switch, paired</span></span><br><span class="line"><span class="comment"> * with a prepare_task_switch call before the context switch.</span></span><br><span class="line"><span class="comment"> * finish_task_switch will reconcile locking set up by prepare_task_switch,</span></span><br><span class="line"><span class="comment"> * and do any other architecture-specific cleanup actions.</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * Note that we may have delayed dropping an mm in context_switch(). If</span></span><br><span class="line"><span class="comment"> * so, we finish that here outside of the runqueue lock. (Doing it</span></span><br><span class="line"><span class="comment"> * with the lock held can cause deadlocks; see schedule() for</span></span><br><span class="line"><span class="comment"> * details.)</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * The context switch have flipped the stack from under us and restored the</span></span><br><span class="line"><span class="comment"> * local variables which were saved when this task called schedule() in the</span></span><br><span class="line"><span class="comment"> * past. prev == current is still correct but we need to recalculate this_rq</span></span><br><span class="line"><span class="comment"> * because prev may have moved to another CPU.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="type">static</span> <span class="keyword">struct</span> rq *<span class="title function_">finish_task_switch</span><span class="params">(<span class="keyword">struct</span> task_struct *prev)</span></span><br><span class="line">    __<span class="title function_">releases</span><span class="params">(rq-&gt;lock)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">rq</span> *<span class="title">rq</span> =</span> this_rq();</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">mm_struct</span> *<span class="title">mm</span> =</span> rq-&gt;prev_mm;</span><br><span class="line">    <span class="type">long</span> prev_state;</span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">     * The previous task will have left us with a preempt_count of 2</span></span><br><span class="line"><span class="comment">     * because it left us after:</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     *	schedule()</span></span><br><span class="line"><span class="comment">     *	  preempt_disable();			// 1</span></span><br><span class="line"><span class="comment">     *	  __schedule()</span></span><br><span class="line"><span class="comment">     *	    raw_spin_lock_irq(&amp;rq-&gt;lock)	// 2</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * Also, see FORK_PREEMPT_COUNT.</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">if</span> (WARN_ONCE(preempt_count() != <span class="number">2</span>*PREEMPT_DISABLE_OFFSET,</span><br><span class="line">              <span class="string">&quot;corrupted preempt_count: %s/%d/0x%x\n&quot;</span>,</span><br><span class="line">              current-&gt;comm, current-&gt;pid, preempt_count()))</span><br><span class="line">        preempt_count_set(FORK_PREEMPT_COUNT);</span><br><span class="line">    rq-&gt;prev_mm = <span class="literal">NULL</span>;</span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">     * A task struct has one reference for the use as &quot;current&quot;.</span></span><br><span class="line"><span class="comment">     * If a task dies, then it sets TASK_DEAD in tsk-&gt;state and calls</span></span><br><span class="line"><span class="comment">     * schedule one last time. The schedule call will never return, and</span></span><br><span class="line"><span class="comment">     * the scheduled task must drop that reference.</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * We must observe prev-&gt;state before clearing prev-&gt;on_cpu (in</span></span><br><span class="line"><span class="comment">     * finish_task), otherwise a concurrent wakeup can get prev</span></span><br><span class="line"><span class="comment">     * running on another CPU and we could rave with its RUNNING -&gt; DEAD</span></span><br><span class="line"><span class="comment">     * transition, resulting in a double drop.</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    prev_state = prev-&gt;state;</span><br><span class="line">    vtime_task_switch(prev);</span><br><span class="line">    perf_event_task_sched_in(prev, current);</span><br><span class="line">    finish_task(prev);</span><br><span class="line">    finish_lock_switch(rq);</span><br><span class="line">    finish_arch_post_lock_switch();</span><br><span class="line">    kcov_finish_switch(current);</span><br><span class="line">    fire_sched_in_preempt_notifiers(current);</span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">     * When switching through a kernel thread, the loop in</span></span><br><span class="line"><span class="comment">     * membarrier_&#123;private,global&#125;_expedited() may have observed that</span></span><br><span class="line"><span class="comment">     * kernel thread and not issued an IPI. It is therefore possible to</span></span><br><span class="line"><span class="comment">     * schedule between user-&gt;kernel-&gt;user threads without passing though</span></span><br><span class="line"><span class="comment">     * switch_mm(). Membarrier requires a barrier after storing to</span></span><br><span class="line"><span class="comment">     * rq-&gt;curr, before returning to userspace, so provide them here:</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * - a full memory barrier for &#123;PRIVATE,GLOBAL&#125;_EXPEDITED, implicitly</span></span><br><span class="line"><span class="comment">     *   provided by mmdrop(),</span></span><br><span class="line"><span class="comment">     * - a sync_core for SYNC_CORE.</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">if</span> (mm) &#123;</span><br><span class="line">        membarrier_mm_sync_core_before_usermode(mm);</span><br><span class="line">        mmdrop(mm);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (unlikely(prev_state == TASK_DEAD)) &#123;</span><br><span class="line">        <span class="keyword">if</span> (prev-&gt;sched_class-&gt;task_dead)</span><br><span class="line">            prev-&gt;sched_class-&gt;task_dead(prev);</span><br><span class="line">        <span class="comment">/*</span></span><br><span class="line"><span class="comment">         * Remove function-return probe instances associated with this</span></span><br><span class="line"><span class="comment">         * task and put them back on the free list.</span></span><br><span class="line"><span class="comment">         */</span></span><br><span class="line">        kprobe_flush_task(prev);</span><br><span class="line">        <span class="comment">/* Task is done with its stack. */</span></span><br><span class="line">        put_task_stack(prev);</span><br><span class="line">        put_task_struct(prev);</span><br><span class="line">    &#125;</span><br><span class="line">    tick_nohz_task_switch();</span><br><span class="line">    <span class="keyword">return</span> rq;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>  至此，我们完成了内核态的切换工作，也完成了整个主动调度的过程。</p>
<h3 id="4-2-抢占式调度"><a href="#4-2-抢占式调度" class="headerlink" title="4.2 抢占式调度"></a>4.2 抢占式调度</h3><p>  抢占式调度通常发生在两种情况下。一种是某任务执行时间过长，另一种是当某任务被唤醒的时候。首先看看任务执行时间过长的情况。</p>
<h4 id="4-2-1-任务运行时间检测"><a href="#4-2-1-任务运行时间检测" class="headerlink" title="4.2.1 任务运行时间检测"></a>4.2.1 任务运行时间检测</h4><p>  该情况需要衡量一个任务的执行时间长短，执行时间过长则发起抢占。在计算机里面有一个时钟，会过一段时间触发一次时钟中断，通知操作系统时间又过去一个时钟周期，通过这种方式可以查看是否是需要抢占的时间点。</p>
<p>  时钟中断处理函数会调用scheduler_tick()。该函数首先取出当前CPU，并由此获取对应的运行队列rq和当前任务curr。接着调用该任务的调度类sched_class对应的task_tick()函数进行时间事件处理。</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * This function gets called by the timer code, with HZ frequency.</span></span><br><span class="line"><span class="comment"> * We call it with interrupts disabled.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">scheduler_tick</span><span class="params">(<span class="type">void</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">int</span> cpu = smp_processor_id();</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">rq</span> *<span class="title">rq</span> =</span> cpu_rq(cpu);</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">task_struct</span> *<span class="title">curr</span> =</span> rq-&gt;curr;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">rq_flags</span> <span class="title">rf</span>;</span></span><br><span class="line">    sched_clock_tick();</span><br><span class="line">    rq_lock(rq, &amp;rf);</span><br><span class="line">    update_rq_clock(rq);</span><br><span class="line">    curr-&gt;sched_class-&gt;task_tick(rq, curr, <span class="number">0</span>);</span><br><span class="line">    cpu_load_update_active(rq);</span><br><span class="line">    calc_global_load_tick(rq);</span><br><span class="line">    psi_task_tick(rq);</span><br><span class="line">    rq_unlock(rq, &amp;rf);</span><br><span class="line">    perf_event_task_tick();</span><br><span class="line">......</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>  以普通任务队列为例，对应的调度类为fair_sched_class，对应的时钟处理函数为task_tick_fair()，该函数会获取当前的调度实体和运行队列，并调用entity_tick()函数更新时间。</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * scheduler tick hitting a task of our scheduling class.</span></span><br><span class="line"><span class="comment"> * <span class="doctag">NOTE:</span> This function can be called remotely by the tick offload that</span></span><br><span class="line"><span class="comment"> * goes along full dynticks. Therefore no local assumption can be made</span></span><br><span class="line"><span class="comment"> * and everything must be accessed through the @rq and @curr passed in</span></span><br><span class="line"><span class="comment"> * parameters.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="type">static</span> <span class="type">void</span> <span class="title function_">task_tick_fair</span><span class="params">(<span class="keyword">struct</span> rq *rq, <span class="keyword">struct</span> task_struct *curr, <span class="type">int</span> queued)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">cfs_rq</span> *<span class="title">cfs_rq</span>;</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">sched_entity</span> *<span class="title">se</span> =</span> &amp;curr-&gt;se;</span><br><span class="line">    for_each_sched_entity(se) &#123;</span><br><span class="line">        cfs_rq = cfs_rq_of(se);</span><br><span class="line">        entity_tick(cfs_rq, se, queued);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (static_branch_unlikely(&amp;sched_numa_balancing))</span><br><span class="line">        task_tick_numa(rq, curr);</span><br><span class="line">    update_misfit_status(curr, rq);</span><br><span class="line">    update_overutilized_status(task_rq(curr));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>  在entity_tick()中，首先会调用update_curr()更新当前任务的vruntime，然后调用check_preempt_tick()检测现在是否可以发起抢占。</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">static</span> <span class="type">void</span></span><br><span class="line"><span class="title function_">entity_tick</span><span class="params">(<span class="keyword">struct</span> cfs_rq *cfs_rq, <span class="keyword">struct</span> sched_entity *curr, <span class="type">int</span> queued)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">     * Update run-time statistics of the &#x27;current&#x27;.</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    update_curr(cfs_rq);</span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">     * Ensure that runnable average is periodically updated.</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    update_load_avg(cfs_rq, curr, UPDATE_TG);</span><br><span class="line">    update_cfs_group(curr);</span><br><span class="line">......</span><br><span class="line">    <span class="keyword">if</span> (cfs_rq-&gt;nr_running &gt; <span class="number">1</span>)</span><br><span class="line">        check_preempt_tick(cfs_rq, curr);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>  check_preempt_tick() 先是调用 sched_slice() 函数计算出一个调度周期中该任务运行的实际时间 ideal_runtime。sum_exec_runtime 指任务总共执行的实际时间，prev_sum_exec_runtime 指上次该进程被调度时已经占用的实际时间，所以 sum_exec_runtime - prev_sum_exec_runtime 就是这次调度占用实际时间。如果这个时间大于 ideal_runtime，则应该被抢占了。除了这个条件之外，还会通过 __pick_first_entity 取出红黑树中最小的进程。如果当前进程的 vruntime 大于红黑树中最小的进程的 vruntime，且差值大于 ideal_runtime，也应该被抢占了。</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * Preempt the current task with a newly woken task if needed:</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="type">static</span> <span class="type">void</span></span><br><span class="line"><span class="title function_">check_preempt_tick</span><span class="params">(<span class="keyword">struct</span> cfs_rq *cfs_rq, <span class="keyword">struct</span> sched_entity *curr)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">unsigned</span> <span class="type">long</span> ideal_runtime, delta_exec;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">sched_entity</span> *<span class="title">se</span>;</span></span><br><span class="line">    s64 delta;</span><br><span class="line">    ideal_runtime = sched_slice(cfs_rq, curr);</span><br><span class="line">    delta_exec = curr-&gt;sum_exec_runtime - curr-&gt;prev_sum_exec_runtime;</span><br><span class="line">    <span class="keyword">if</span> (delta_exec &gt; ideal_runtime) &#123;</span><br><span class="line">        resched_curr(rq_of(cfs_rq));</span><br><span class="line">        <span class="comment">/*</span></span><br><span class="line"><span class="comment">         * The current task ran long enough, ensure it doesn&#x27;t get</span></span><br><span class="line"><span class="comment">         * re-elected due to buddy favours.</span></span><br><span class="line"><span class="comment">         */</span></span><br><span class="line">        clear_buddies(cfs_rq, curr);</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">     * Ensure that a task that missed wakeup preemption by a</span></span><br><span class="line"><span class="comment">     * narrow margin doesn&#x27;t have to wait for a full slice.</span></span><br><span class="line"><span class="comment">     * This also mitigates buddy induced latencies under load.</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">if</span> (delta_exec &lt; sysctl_sched_min_granularity)</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    se = __pick_first_entity(cfs_rq);</span><br><span class="line">    delta = curr-&gt;vruntime - se-&gt;vruntime;</span><br><span class="line">    <span class="keyword">if</span> (delta &lt; <span class="number">0</span>)</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    <span class="keyword">if</span> (delta &gt; ideal_runtime)</span><br><span class="line">        resched_curr(rq_of(cfs_rq));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>  如果确认需要被抢占，则会调用resched_curr()函数，该函数会调用set_tsk_need_resched()标记该任务为_TIF_NEED_RESCHED，即该任务应该被抢占。</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * resched_curr - mark rq&#x27;s current task &#x27;to be rescheduled now&#x27;.</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * On UP this means the setting of the need_resched flag, on SMP it</span></span><br><span class="line"><span class="comment"> * might also involve a cross-CPU call to trigger the scheduler on</span></span><br><span class="line"><span class="comment"> * the target CPU.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">resched_curr</span><span class="params">(<span class="keyword">struct</span> rq *rq)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">task_struct</span> *<span class="title">curr</span> =</span> rq-&gt;curr;</span><br><span class="line">    <span class="type">int</span> cpu;</span><br><span class="line">.......</span><br><span class="line">    cpu = cpu_of(rq);</span><br><span class="line">    <span class="keyword">if</span> (cpu == smp_processor_id()) &#123;</span><br><span class="line">        set_tsk_need_resched(curr);</span><br><span class="line">        set_preempt_need_resched();</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (set_nr_and_not_polling(curr))</span><br><span class="line">        smp_send_reschedule(cpu);</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">        trace_sched_wake_idle_without_ipi(cpu);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="4-2-2-任务唤醒情况"><a href="#4-2-2-任务唤醒情况" class="headerlink" title="4.2.2 任务唤醒情况"></a>4.2.2 任务唤醒情况</h4><p>  某些任务会因为中断而唤醒，如当 I&#x2F;O 到来的时候，I&#x2F;O进程往往会被唤醒。在这种时候，如果被唤醒的任务优先级高于 CPU 上的当前任务，就会触发抢占。try_to_wake_up() 调用 ttwu_queue() 将这个唤醒的任务添加到队列当中。ttwu_queue() 再调用 ttwu_do_activate() 激活这个任务。ttwu_do_activate() 调用 ttwu_do_wakeup()。这里面调用了 check_preempt_curr() 检查是否应该发生抢占。如果应该发生抢占，也不是直接踢走当前进程，而是将当前进程标记为应该被抢占。</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">static</span> <span class="type">void</span> <span class="title function_">ttwu_do_wakeup</span><span class="params">(<span class="keyword">struct</span> rq *rq, <span class="keyword">struct</span> task_struct *p, <span class="type">int</span> wake_flags,</span></span><br><span class="line"><span class="params">         <span class="keyword">struct</span> rq_flags *rf)</span></span><br><span class="line">&#123;</span><br><span class="line">  check_preempt_curr(rq, p, wake_flags);</span><br><span class="line">  p-&gt;state = TASK_RUNNING;</span><br><span class="line">  trace_sched_wakeup(p);</span><br></pre></td></tr></table></figure>
<h4 id="4-2-3-抢占的发生"><a href="#4-2-3-抢占的发生" class="headerlink" title="4.2.3 抢占的发生"></a>4.2.3 抢占的发生</h4><p>由前面的分析，我们知道了不论是是当前任务执行时间过长还是新任务唤醒，我们均会对现在的任务标记位_TIF_NEED_RESCUED，下面分析实际抢占的发生。真正的抢占还需要一个特定的时机让正在运行中的进程有机会调用一下 __schedule()函数，发起真正的调度。</p>
<p>实际上会调用__schedule()函数共有以下几个时机</p>
<p>从系统调用返回用户态：以64位为例，系统调用的链路为do_syscall_64-&gt;syscall_return_slowpath-&gt;prepare_exit_to_usermode-&gt;exit_to_usermode_loop。在exit_to_usermode_loop中，会检测是否为_TIF_NEED_RESCHED，如果是则调用__schedule()</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">static</span> <span class="type">void</span> <span class="title function_">exit_to_usermode_loop</span><span class="params">(<span class="keyword">struct</span> pt_regs *regs, u32 cached_flags)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">while</span> (<span class="literal">true</span>) &#123;</span><br><span class="line">        <span class="comment">/* We have work to do. */</span></span><br><span class="line">        local_irq_enable();</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (cached_flags &amp; _TIF_NEED_RESCHED)</span><br><span class="line">          schedule();</span><br><span class="line">......</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure>
<p>内核态启动：内核态的执行中，被抢占的时机一般发生在 preempt_enable() 中。在内核态的执行中，有的操作是不能被中断的，所以在进行这些操作之前，总是先调用 preempt_disable() 关闭抢占，当再次打开的时候，就是一次内核态代码被抢占的机会。preempt_enable() 会调用 preempt_count_dec_and_test()，判断 preempt_count 和 TIF_NEED_RESCHED 是否可以被抢占。如果可以，就调用 preempt_schedule-&gt;preempt_schedule_common-&gt;__schedule 进行调度。</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">define</span> preempt_enable() \</span></span><br><span class="line"><span class="meta">do &#123; \</span></span><br><span class="line"><span class="meta">  <span class="keyword">if</span> (unlikely(preempt_count_dec_and_test())) \</span></span><br><span class="line"><span class="meta">    __preempt_schedule(); \</span></span><br><span class="line"><span class="meta">&#125; while (0)</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> preempt_count_dec_and_test() \</span></span><br><span class="line"><span class="meta">(&#123; preempt_count_sub(1); should_resched(0); &#125;)</span></span><br><span class="line"></span><br><span class="line"><span class="type">static</span> __always_inline <span class="type">bool</span> <span class="title function_">should_resched</span><span class="params">(<span class="type">int</span> preempt_offset)</span></span><br><span class="line">&#123;</span><br><span class="line">  <span class="keyword">return</span> unlikely(preempt_count() == preempt_offset &amp;&amp;</span><br><span class="line">      tif_need_resched());</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> tif_need_resched() test_thread_flag(TIF_NEED_RESCHED)</span></span><br><span class="line"></span><br><span class="line"><span class="type">static</span> <span class="type">void</span> __sched notrace <span class="title function_">preempt_schedule_common</span><span class="params">(<span class="type">void</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">  <span class="keyword">do</span> &#123;</span><br><span class="line">......</span><br><span class="line">    __schedule(<span class="literal">true</span>);</span><br><span class="line">......</span><br><span class="line">  &#125; <span class="keyword">while</span> (need_resched())</span><br></pre></td></tr></table></figure>

<ul>
<li>从中断返回内核态&#x2F;用户态：中断处理调用的是 do_IRQ 函数，中断完毕后分为两种情况，一个是返回用户态，一个是返回内核态。<ul>
<li>返回用户态会调用 prepare_exit_to_usermode()，最终调用 exit_to_usermode_loop()</li>
<li>返回内核态会调用preempt_schedule_irq()，最终调用__schedule()</li>
</ul>
</li>
</ul>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">common_interrupt:</span><br><span class="line">        ASM_CLAC</span><br><span class="line">        addq    $<span class="number">-0x80</span>, (%rsp) </span><br><span class="line">        interrupt do_IRQ</span><br><span class="line">ret_from_intr:</span><br><span class="line">        popq    %rsp</span><br><span class="line">        testb   $<span class="number">3</span>, CS(%rsp)</span><br><span class="line">        jz      retint_kernel</span><br><span class="line"><span class="comment">/* Interrupt came from user space */</span></span><br><span class="line">GLOBAL(retint_user)</span><br><span class="line">        mov     %rsp,%rdi</span><br><span class="line">        call    prepare_exit_to_usermode</span><br><span class="line">        TRACE_IRQS_IRETQ</span><br><span class="line">        SWAPGS</span><br><span class="line">        jmp     restore_regs_and_iret</span><br><span class="line"><span class="comment">/* Returning to kernel space */</span></span><br><span class="line">retint_kernel:</span><br><span class="line"><span class="meta">#<span class="keyword">ifdef</span> CONFIG_PREEMPT</span></span><br><span class="line">        bt      $<span class="number">9</span>, EFLAGS(%rsp)  </span><br><span class="line">        jnc     <span class="number">1f</span></span><br><span class="line"><span class="number">0</span>:      cmpl    $<span class="number">0</span>, PER_CPU_VAR(__preempt_count)</span><br><span class="line">        jnz     <span class="number">1f</span></span><br><span class="line">        call    preempt_schedule_irq</span><br><span class="line">        jmp     <span class="number">0b</span></span><br></pre></td></tr></table></figure>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">asmlinkage __visible <span class="type">void</span> __sched <span class="title function_">preempt_schedule_irq</span><span class="params">(<span class="type">void</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">......</span><br><span class="line">  <span class="keyword">do</span> &#123;</span><br><span class="line">    preempt_disable();</span><br><span class="line">    local_irq_enable();</span><br><span class="line">    __schedule(<span class="literal">true</span>);</span><br><span class="line">    local_irq_disable();</span><br><span class="line">    sched_preempt_enable_no_resched();</span><br><span class="line">  &#125; <span class="keyword">while</span> (need_resched());</span><br><span class="line">......</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="五-总结"><a href="#五-总结" class="headerlink" title="五. 总结"></a>五. 总结</h2><p>  <br>  本文分析了任务调度的策略、结构体以及整个调度流程，其中关于内存上下文切换的部分尚未详细叙述，留待内存部分展开剖析。</p>
<h2 id="源码资料"><a href="#源码资料" class="headerlink" title="源码资料"></a>源码资料</h2><p>1、<a href="https://code.woboq.org/linux/linux/kernel/sched/">调度相关结构体及函数实现</a></p>
<p>2、<a href="https://code.woboq.org/linux/linux/kernel/sched/core.c.html#__schedule">schedule核心函数</a></p>
]]></content>
      <categories>
        <category>linux-doc 进程管理</category>
      </categories>
      <tags>
        <tag>Linux</tag>
      </tags>
  </entry>
  <entry>
    <title>进程、线程的创建和派生</title>
    <url>/2023/01/15/linux-docs/%E8%BF%9B%E7%A8%8B%E7%AE%A1%E7%90%86/%E8%BF%9B%E7%A8%8B%E3%80%81%E7%BA%BF%E7%A8%8B%E7%9A%84%E5%88%9B%E5%BB%BA%E5%92%8C%E6%B4%BE%E7%94%9F/</url>
    <content><![CDATA[<h2 id="一-前言"><a href="#一-前言" class="headerlink" title="一. 前言"></a>一. 前言</h2><p>  在前文中，我们分析了内核中进程和线程的统一结构体task_struct，本文将继续分析进程、线程的创建和派生的过程。首先介绍如何将一个程序编辑为执行文件最后成为进程执行，然后会介绍线程的执行，最后会分析如何通过已有的进程、线程实现多进程、多线程。因为进程和线程有诸多相似之处，也有一些不同之处，因此本文会对比进程和线程来加深理解和记忆。</p>
<h2 id="二-进程的创建"><a href="#二-进程的创建" class="headerlink" title="二. 进程的创建"></a>二. 进程的创建</h2><p>以C语言为例，我们在Linux下编写C语言代码，然后通过gcc编译和链接生成可执行文件后直接执行即可完成一个进程的创建和工作。下面将详细展开介绍这个创建进程的过程。在 Linux 下面，二进制的程序也要有严格的格式，这个格式我们称为 ELF（Executable and Linkable Format，可执行与可链接格式）。这个格式可以根据编译的结果不同，分为不同的格式。主要包括</p>
<p>1、可重定位的对象文件(Relocatable file)</p>
<p>由汇编器汇编生成的 .o 文件</p>
<p>2、可执行的对象文件(Executable file)</p>
<p>可执行应用程序</p>
<p>3、可被共享的对象文件(Shared object file)</p>
<p>动态库文件，也即 .so 文件</p>
<p>下面在进程创建过程中会详细说明三种文件。</p>
<h3 id="2-1-编译"><a href="#2-1-编译" class="headerlink" title="2. 1 编译"></a>2. 1 编译</h3><p>写完C程序后第一步就是程序编译（其实还有IDE的预编译，那些属于编辑器操作这里不表）。编译指令如下所示</p>
<pre><code>gcc -c -fPIC xxxx.c
</code></pre>
<p>-c表示编译、汇编指定的源文件，不进行链接。-fPIC表示生成与位置无关（Position-Independent Code）代码，即采用相对地址而非绝对地址，从而满足共享库加载需求。在编译的时候，先做预处理工作，例如将头文件嵌入到正文中，将定义的宏展开，然后就是真正的编译过程，最终编译成为.o 文件，这就是 ELF 的第一种类型，可重定位文件（Relocatable File）。之所以叫做可重定位文件，是因为对于编译好的代码和变量，将来加载到内存里面的时候，都是要加载到一定位置的。比如说，调用一个函数，其实就是跳到这个函数所在的代码位置执行；再比如修改一个全局变量，也是要到变量的位置那里去修改。但是现在这个时候，还是.o 文件，不是一个可以直接运行的程序，这里面只是部分代码片段。因此.o 里面的位置是不确定的，但是必须是可重新定位的以适应需求。</p>
<p><img src="https://user-images.githubusercontent.com/87457873/128132712-dfe308a8-728b-4948-9e8e-f7563484355e.png" alt="image"></p>
<p>ELF 文件的头是用于描述整个文件的。这个文件格式在内核中有定义，分别为 struct elf32_hdr 和struct elf64_hdr。其他各个section作用如下所示</p>
<ul>
<li>.text：放编译好的二进制可执行代码</li>
<li>.rodata：只读数据，例如字符串常量、const 的变量</li>
<li>.data：已经初始化好的全局变量</li>
<li>.bss：未初始化全局变量，运行时会置 0</li>
<li>.symtab：符号表，记录的则是函数和变量</li>
<li>.rel.text： .text部分的重定位表</li>
<li>.rel.data：.data部分的重定位表</li>
<li>.strtab：字符串表、字符串常量和变量名</li>
</ul>
<p>这些节的元数据信息也需要有一个地方保存，就是最后的节头部表（Section Header Table）。在这个表里面，每一个 section 都有一项，在代码里面也有定义 struct elf32_shdr和struct elf64_shdr。在 ELF 的头里面，有描述这个文件的节头部表的位置，有多少个表项等等信息。</p>
<h3 id="2-2-链接"><a href="#2-2-链接" class="headerlink" title="2.2 链接"></a>2.2 链接</h3><p>链接分为静态链接和动态链接。静态链接库会和目标文件通过链接生成一个可执行文件，而动态链接则会通过链接形成动态连接器，在可执行文件执行的时候动态的选择并加载其中的部分或全部函数。二者的各自优缺点如下所示</p>
<ul>
<li><strong>静态链接库的优点</strong></li>
</ul>
<p>(1) 代码装载速度快，执行速度略比动态链接库快；</p>
<p>(2) 只需保证在开发者的计算机中有正确的.LIB文件，在以二进制形式发布程序时不需考虑在用户的计算机上.LIB文件是否存在及版本问题，可避免DLL地狱等问题。</p>
<ul>
<li><strong>静态链接库的缺点</strong></li>
</ul>
<p>使用静态链接生成的可执行文件体积较大，包含相同的公共代码，造成浪费</p>
<ul>
<li><strong>动态链接库的优点</strong></li>
</ul>
<p>(1) 更加节省内存并减少页面交换；</p>
<p>(2) DLL文件与EXE文件独立，只要输出接口不变（即名称、参数、返回值类型和调用约定不变），更换DLL文件不会对EXE文件造成任何影响，因而极大地提高了可维护性和可扩展性；</p>
<p>(3) 不同编程语言编写的程序只要按照函数调用约定就可以调用同一个DLL函数；</p>
<p>(4)适用于大规模的软件开发，使开发过程独立、耦合度小，便于不同开发者和开发组织之间进行开发和测试。</p>
<ul>
<li><strong>动态链接库的缺点</strong></li>
</ul>
<p>使用动态链接库的应用程序不是自完备的，它依赖的DLL模块也要存在，如果使用载入时动态链接，程序启动时发现DLL不存在，系统将终止程序并给出错误信息。而使用运行时动态链接，系统不会终止，但由于DLL中的导出函数不可用，程序会加载失败；速度比静态链接慢。当某个模块更新后，如果新模块与旧的模块不兼容，那么那些需要该模块才能运行的软件均无法执行。这在早期Windows中很常见。</p>
<p>下面分别介绍静态链接和动态链接</p>
<h4 id="2-2-1-静态链接"><a href="#2-2-1-静态链接" class="headerlink" title="2.2.1 静态链接"></a>2.2.1 静态链接</h4><p>静态链接库.a文件（Archives）的执行指令如下</p>
<pre><code>ar cr libXXX.a XXX.o XXXX.o
</code></pre>
<p>  <br>  当需要使用该静态库的时候，会将.o文件从.a文件中依次抽取并链接到程序中，指令如下</p>
<pre><code>gcc -o XXXX XXX.O -L. -lsXXX
</code></pre>
<p>-L表示在当前目录下找.a 文件，-lsXXXX会自动补全文件名，比如加前缀 lib，后缀.a，变成libXXX.a，找到这个.a文件后，将里面的 XXXX.o 取出来，和 XXX.o 做一个链接，形成二进制执行文件XXXX。在这里，重定位会从.o中抽取函数并和.a中的文件抽取的函数进行合并，找到实际的调用位置，形成最终的可执行文件(Executable file)，即ELF的第二种格式文件。</p>
<p><img src="https://user-images.githubusercontent.com/87457873/128132775-685e8de3-396a-432d-8d9b-15f2b5fba643.png" alt="image"></p>
<p>对比ELF第一种格式可重定位文件，这里可执行文件略去了重定位表相关段落。此处将ELF文件分为了代码段、数据段和不加载到内存中的部分，并加上了段头表（Segment Header Table）用以记录管理，在代码中定义为struct elf32_phdr和 struct elf64_phdr，这里面除了有对于段的描述之外，最重要的是 p_vaddr，这个是这个段加载到内存的虚拟地址。这部分会在内存篇章详细介绍。</p>
<h4 id="2-2-2-动态链接"><a href="#2-2-2-动态链接" class="headerlink" title="2.2.2 动态链接"></a>2.2.2 动态链接</h4><p>动态链接库（Shared Libraries)的作用主要是为了解决静态链接大量使用会造成空间浪费的问题，因此这里设计成了可以被多个程序共享的形式，其执行命令如下</p>
<pre><code>gcc -shared -fPIC -o libXXX.so XXX.o
</code></pre>
<p>当一个动态链接库被链接到一个程序文件中的时候，最后的程序文件并不包括动态链接库中的代码，而仅仅包括对动态链接库的引用，并且不保存动态链接库的全路径，仅仅保存动态链接库的名称。</p>
<pre><code>gcc -o XXX XXX.O -L. -lXXX
</code></pre>
<p>当运行这个程序的时候，首先寻找动态链接库，然后加载它。默认情况下，系统在 &#x2F;lib 和&#x2F;usr&#x2F;lib 文件夹下寻找动态链接库。如果找不到就会报错，我们可以设定 LD_LIBRARY_PATH环境变量，程序运行时会在此环境变量指定的文件夹下寻找动态链接库。动态链接库，就是 ELF 的第三种类型，共享对象文件（Shared Object）。</p>
<p>动态链接的ELF相对于静态链接主要多了以下部分</p>
<ul>
<li>.interp段，里面是ld-linux.so，负责运行时的链接动作</li>
<li>.plt（Procedure Linkage Table），过程链接表</li>
<li>.got.plt（Global Offset Table），全局偏移量表</li>
</ul>
<p>当程序编译时，会对每个函数在PLT中建立新的项，如PLT[n]，而动态库中则存有该函数的实际地址，记为GOT[m]。整体寻址过程如下所示</p>
<ul>
<li>PLT[n]向GOT[m]寻求地址</li>
<li>GOT[m]初始并无地址，需要采取以下方式获取地址<ul>
<li>回调PLT[0]</li>
<li>PLT[0]调用GOT[2]，即ld-linux.so</li>
<li>ld-linux.so查找所需函数实际地址并存放在GOT[m]中</li>
</ul>
</li>
</ul>
<p>由此，我们建立了PLT[n]到GOT[m]的对应关系，从而实现了动态链接。</p>
<h3 id="2-3-加载运行"><a href="#2-3-加载运行" class="headerlink" title="2.3 加载运行"></a>2.3 加载运行</h3><p>完成了上述的编译、汇编、链接，我们最终形成了可执行文件，并加载运行。在内核中，有这样一个数据结构，用来定义加载二进制文件的方法。</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">linux_binfmt</span> &#123;</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">list_head</span> <span class="title">lh</span>;</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">module</span> *<span class="title">module</span>;</span></span><br><span class="line">    <span class="type">int</span> (*load_binary)(<span class="keyword">struct</span> linux_binprm *);</span><br><span class="line">    <span class="type">int</span> (*load_shlib)(<span class="keyword">struct</span> file *);</span><br><span class="line">    <span class="type">int</span> (*core_dump)(<span class="keyword">struct</span> coredump_params *cprm);</span><br><span class="line">    <span class="type">unsigned</span> <span class="type">long</span> min_coredump;     <span class="comment">/* minimal dump size */</span></span><br><span class="line">&#125; __randomize_layout;</span><br></pre></td></tr></table></figure>
<p>对于ELF文件格式，其对应实现为</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">static</span> <span class="class"><span class="keyword">struct</span> <span class="title">linux_binfmt</span> <span class="title">elf_format</span> =</span> &#123;</span><br><span class="line">    .module         = THIS_MODULE,</span><br><span class="line">    .load_binary    = load_elf_binary,</span><br><span class="line">    .load_shlib     = load_elf_library,</span><br><span class="line">    .core_dump      = elf_core_dump,</span><br><span class="line">    .min_coredump   = ELF_EXEC_PAGESIZE,</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>其中加载的函数指针指向的函数和内核镜像加载是同一份函数，实际上通过exec函数完成调用。exec 比较特殊，它是一组函数：</p>
<ul>
<li>包含 p 的函数（execvp, execlp）会在 PATH 路径下面寻找程序；不包含 p 的函数需要输入程序的全路径；</li>
<li>包含 v 的函数（execv, execvp, execve）以数组的形式接收参数；</li>
<li>包含 l 的函数（execl, execlp, execle）以列表的形式接收参数；</li>
<li>包含 e 的函数（execve, execle）以数组的形式接收环境变量。</li>
</ul>
<p>当我们通过shell运行可执行文件或者通过fork派生子类，均是通过该类函数实现加载。</p>
<h2 id="三-线程的创建之用户态"><a href="#三-线程的创建之用户态" class="headerlink" title="三. 线程的创建之用户态"></a>三. 线程的创建之用户态</h2><p>线程的创建对应的函数是pthread_create()，线程不是一个完全由内核实现的机制，它是由内核态和用户态合作完成的。pthread_create()不是一个系统调用，是 Glibc 库的一个函数，所以我们还要从 Glibc 说起。但是在开始之前，我们先要提一下，线程的创建到了内核态和进程的派生会使用同一个函数：__do_fork()，这也很容易理解，因为对内核态来说，线程和进程是同样的task_struct结构体。本节介绍线程在用户态的创建，而内核态的创建则会和进程的派生放在一起说明。</p>
<p>在Glibc的ntpl&#x2F;pthread_create.c中定义了__pthread_create_2_1()函数，该函数主要进行了以下操作</p>
<p>处理线程的属性参数。例如前面写程序的时候，我们设置的线程栈大小。如果没有传入线程属性，就取默认值。</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">const</span> <span class="class"><span class="keyword">struct</span> <span class="title">pthread_attr</span> *<span class="title">iattr</span> =</span> (<span class="keyword">struct</span> pthread_attr *) attr;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">pthread_attr</span> <span class="title">default_attr</span>;</span></span><br><span class="line"><span class="comment">//c11 thrd_create</span></span><br><span class="line"><span class="type">bool</span> c11 = (attr == ATTR_C11_THREAD);</span><br><span class="line"><span class="keyword">if</span> (iattr == <span class="literal">NULL</span> || c11)</span><br><span class="line">&#123;</span><br><span class="line">  ......</span><br><span class="line">    iattr = &amp;default_attr;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>就像在内核里每一个进程或者线程都有一个 task_struct 结构，在用户态也有一个用于维护线程的结构，就是这个 pthread 结构。</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">pthread</span> *<span class="title">pd</span> =</span> <span class="literal">NULL</span>;</span><br></pre></td></tr></table></figure>
<p>凡是涉及函数的调用，都要使用到栈。每个线程也有自己的栈，接下来就是创建线程栈了。</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">int</span> err = ALLOCATE_STACK (iattr, &amp;pd);</span><br></pre></td></tr></table></figure>
<p>ALLOCATE_STACK 是一个宏，对应的函数allocate_stack()主要做了以下这些事情：</p>
<ul>
<li>如果在线程属性里面设置过栈的大小，则取出属性值；</li>
<li>为了防止栈的访问越界在栈的末尾添加一块空间 guardsize，一旦访问到这里就会报错；</li>
<li>线程栈是在进程的堆里面创建的。如果一个进程不断地创建和删除线程，我们不可能不断地去申请和清除线程栈使用的内存块，这样就需要有一个缓存。get_cached_stack 就是根据计算出来的 size 大小，看一看已经有的缓存中，有没有已经能够满足条件的。如果缓存里面没有，就需要调用__mmap创建一块新的缓存，系统调用那一节我们讲过，如果要在堆里面 malloc 一块内存，比较大的话，用__mmap；</li>
<li>线程栈也是自顶向下生长的，每个线程要有一个pthread 结构，这个结构也是放在栈的空间里面的。在栈底的位置，其实是地址最高位；</li>
<li>计算出guard内存的位置，调用 setup_stack_prot 设置这块内存的是受保护的；</li>
<li>填充pthread 这个结构里面的成员变量 stackblock、stackblock_size、guardsize、specific。这里的 specific 是用于存放Thread Specific Data 的，也即属于线程的全局变量；</li>
<li>将这个线程栈放到 stack_used 链表中，其实管理线程栈总共有两个链表，一个是 stack_used，也就是这个栈正被使用；另一个是stack_cache，就是上面说的，一旦线程结束，先缓存起来，不释放，等有其他的线程创建的时候，给其他的线程用。</li>
</ul>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta"># <span class="keyword">define</span> ALLOCATE_STACK(attr, pd) allocate_stack (attr, pd, &amp;stackaddr)</span></span><br><span class="line"><span class="type">static</span> <span class="type">int</span></span><br><span class="line"><span class="title function_">allocate_stack</span> <span class="params">(<span class="type">const</span> <span class="keyword">struct</span> pthread_attr *attr, <span class="keyword">struct</span> pthread **pdp,</span></span><br><span class="line"><span class="params">                ALLOCATE_STACK_PARMS)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">pthread</span> *<span class="title">pd</span>;</span></span><br><span class="line">    <span class="type">size_t</span> size;</span><br><span class="line">    <span class="type">size_t</span> pagesize_m1 = __getpagesize () - <span class="number">1</span>;</span><br><span class="line">......</span><br><span class="line">    <span class="comment">/* Get the stack size from the attribute if it is set.  Otherwise we</span></span><br><span class="line"><span class="comment">       use the default we determined at start time.  */</span></span><br><span class="line">    <span class="keyword">if</span> (attr-&gt;stacksize != <span class="number">0</span>)</span><br><span class="line">        size = attr-&gt;stacksize;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">    &#123;</span><br><span class="line">        lll_lock (__default_pthread_attr_lock, LLL_PRIVATE);</span><br><span class="line">        size = __default_pthread_attr.stacksize;</span><br><span class="line">        lll_unlock (__default_pthread_attr_lock, LLL_PRIVATE);</span><br><span class="line">    &#125;</span><br><span class="line">......</span><br><span class="line">    <span class="comment">/* Allocate some anonymous memory.  If possible use the cache.  */</span></span><br><span class="line">    <span class="type">size_t</span> guardsize;</span><br><span class="line">    <span class="type">void</span> *mem;</span><br><span class="line">    <span class="type">const</span> <span class="type">int</span> prot = (PROT_READ | PROT_WRITE</span><br><span class="line">                   | ((GL(dl_stack_flags) &amp; PF_X) ? PROT_EXEC : <span class="number">0</span>));</span><br><span class="line">    <span class="comment">/* Adjust the stack size for alignment.  */</span></span><br><span class="line">    size &amp;= ~__static_tls_align_m1;</span><br><span class="line">    <span class="comment">/* Make sure the size of the stack is enough for the guard and</span></span><br><span class="line"><span class="comment">       eventually the thread descriptor.  */</span></span><br><span class="line">    guardsize = (attr-&gt;guardsize + pagesize_m1) &amp; ~pagesize_m1;</span><br><span class="line">    size += guardsize;</span><br><span class="line">......    </span><br><span class="line">    <span class="comment">/* Try to get a stack from the cache.  */</span>  </span><br><span class="line">    pd = get_cached_stack (&amp;size, &amp;mem);</span><br><span class="line">    <span class="keyword">if</span> (pd == <span class="literal">NULL</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">/* If a guard page is required, avoid committing memory by first</span></span><br><span class="line"><span class="comment">           allocate with PROT_NONE and then reserve with required permission</span></span><br><span class="line"><span class="comment">           excluding the guard page.  */</span></span><br><span class="line">        mem = __mmap (<span class="literal">NULL</span>, size, (guardsize == <span class="number">0</span>) ? prot : PROT_NONE,</span><br><span class="line">        MAP_PRIVATE | MAP_ANONYMOUS | MAP_STACK, <span class="number">-1</span>, <span class="number">0</span>);</span><br><span class="line">        <span class="comment">/* Place the thread descriptor at the end of the stack.  */</span></span><br><span class="line"><span class="meta">#<span class="keyword">if</span> TLS_TCB_AT_TP</span></span><br><span class="line">        pd = (<span class="keyword">struct</span> pthread *) ((<span class="type">char</span> *) mem + size) - <span class="number">1</span>;</span><br><span class="line"><span class="meta">#<span class="keyword">elif</span> TLS_DTV_AT_TP</span></span><br><span class="line">        pd = (<span class="keyword">struct</span> pthread *) ((((<span class="type">uintptr_t</span>) mem + size - __static_tls_size) &amp; ~__static_tls_align_m1) - TLS_PRE_TCB_SIZE);</span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line">        <span class="comment">/* Now mprotect the required region excluding the guard area. */</span></span><br><span class="line">        <span class="type">char</span> *guard = guard_position (mem, size, guardsize, pd, pagesize_m1);</span><br><span class="line">        setup_stack_prot (mem, size, guard, guardsize, prot);</span><br><span class="line">        pd-&gt;stackblock = mem;</span><br><span class="line">        pd-&gt;stackblock_size = size;</span><br><span class="line">        pd-&gt;guardsize = guardsize;</span><br><span class="line">        pd-&gt;specific[<span class="number">0</span>] = pd-&gt;specific_1stblock;</span><br><span class="line">        <span class="comment">/* And add to the list of stacks in use.  */</span></span><br><span class="line">        stack_list_add (&amp;pd-&gt;<span class="built_in">list</span>, &amp;stack_used);</span><br><span class="line">    &#125;</span><br><span class="line">  </span><br><span class="line">    *pdp = pd;</span><br><span class="line">    <span class="type">void</span> *stacktop;</span><br><span class="line"><span class="meta"># <span class="keyword">if</span> TLS_TCB_AT_TP</span></span><br><span class="line">    <span class="comment">/* The stack begins before the TCB and the static TLS block.  */</span></span><br><span class="line">    stacktop = ((<span class="type">char</span> *) (pd + <span class="number">1</span>) - __static_tls_size);</span><br><span class="line"><span class="meta"># <span class="keyword">elif</span> TLS_DTV_AT_TP</span></span><br><span class="line">    stacktop = (<span class="type">char</span> *) (pd - <span class="number">1</span>);</span><br><span class="line"><span class="meta"># <span class="keyword">endif</span></span></span><br><span class="line">    *<span class="built_in">stack</span> = stacktop;</span><br><span class="line">...... </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="四-线程的内核态创建及进程的派生"><a href="#四-线程的内核态创建及进程的派生" class="headerlink" title="四. 线程的内核态创建及进程的派生"></a>四. 线程的内核态创建及进程的派生</h2><p>多进程是一种常见的程序实现方式，采用的系统调用为fork()函数。前文中已经详细叙述了系统调用的整个过程，对于fork()来说，最终会在系统调用表中查找到对应的系统调用sys_fork完成子进程的生成，而sys_fork 会调用 _do_fork()。</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">SYSCALL_DEFINE0(fork)</span><br><span class="line">&#123;</span><br><span class="line">......</span><br><span class="line">    <span class="keyword">return</span> _do_fork(SIGCHLD, <span class="number">0</span>, <span class="number">0</span>, <span class="literal">NULL</span>, <span class="literal">NULL</span>, <span class="number">0</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>关于__do_fork()先按下不表，再接着看看线程。我们接着pthread_create ()看。其实有了用户态的栈，接着需要解决的就是用户态的程序从哪里开始运行的问题。start_routine() 就是给线程的函数，start_routine()， 参数 arg，以及调度策略都要赋值给 pthread。接下来 __nptl_nthreads 加一，说明又多了一个线程。</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">pd-&gt;start_routine = start_routine;</span><br><span class="line">pd-&gt;arg = arg;</span><br><span class="line">pd-&gt;schedpolicy = self-&gt;schedpolicy;</span><br><span class="line">pd-&gt;schedparam = self-&gt;schedparam;</span><br><span class="line"><span class="comment">/* Pass the descriptor to the caller.  */</span></span><br><span class="line">*newthread = (<span class="type">pthread_t</span>) pd;</span><br><span class="line">atomic_increment (&amp;__nptl_nthreads);</span><br><span class="line">retval = create_thread (pd, iattr, &amp;stopped_start, STACK_VARIABLES_ARGS, &amp;thread_ran);</span><br></pre></td></tr></table></figure>
<p>真正创建线程的是调用 create_thread() 函数，这个函数定义如下。同时，这里还规定了当完成了内核态线程创建后回调的位置：start_thread()。</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">static</span> <span class="type">int</span></span><br><span class="line"><span class="title function_">create_thread</span> <span class="params">(<span class="keyword">struct</span> pthread *pd, <span class="type">const</span> <span class="keyword">struct</span> pthread_attr *attr,</span></span><br><span class="line"><span class="params"><span class="type">bool</span> *stopped_start, STACK_VARIABLES_PARMS, <span class="type">bool</span> *thread_ran)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">const</span> <span class="type">int</span> clone_flags = (CLONE_VM | CLONE_FS | CLONE_FILES | CLONE_SYSVSEM | CLONE_SIGHAND | CLONE_THREAD | CLONE_SETTLS | CLONE_PARENT_SETTID | CLONE_CHILD_CLEARTID | <span class="number">0</span>);</span><br><span class="line">    ARCH_CLONE (&amp;start_thread, STACK_VARIABLES_ARGS, clone_flags, pd, &amp;pd-&gt;tid, tp, &amp;pd-&gt;tid)；</span><br><span class="line">    <span class="comment">/* It&#x27;s started now, so if we fail below, we&#x27;ll have to cancel it</span></span><br><span class="line"><span class="comment">       and let it clean itself up.  */</span></span><br><span class="line">    *thread_ran = <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>在 start_thread() 入口函数中，才真正的调用用户提供的函数，在用户的函数执行完毕之后，会释放这个线程相关的数据。例如，线程本地数据 thread_local variables，线程数目也减一。如果这是最后一个线程了，就直接退出进程，另外 __free_tcb() 用于释放 pthread。</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">define</span> START_THREAD_DEFN \</span></span><br><span class="line"><span class="meta">  static int __attribute__ ((noreturn)) start_thread (void *arg)</span></span><br><span class="line"></span><br><span class="line">START_THREAD_DEFN</span><br><span class="line">&#123;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">pthread</span> *<span class="title">pd</span> =</span> START_THREAD_SELF;</span><br><span class="line">    <span class="comment">/* Run the code the user provided.  */</span></span><br><span class="line">    THREAD_SETMEM (pd, result, pd-&gt;start_routine (pd-&gt;arg));</span><br><span class="line">    <span class="comment">/* Call destructors for the thread_local TLS variables.  */</span></span><br><span class="line">    <span class="comment">/* Run the destructor for the thread-local data.  */</span></span><br><span class="line">    __nptl_deallocate_tsd ();</span><br><span class="line">    <span class="keyword">if</span> (__glibc_unlikely (atomic_decrement_and_test (&amp;__nptl_nthreads)))</span><br><span class="line">        <span class="comment">/* This was the last thread.  */</span></span><br><span class="line">        <span class="built_in">exit</span> (<span class="number">0</span>);</span><br><span class="line">    __free_tcb (pd);</span><br><span class="line">    __exit_thread ();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>__free_tcb ()会调用 __deallocate_stack()来释放整个线程栈，这个线程栈要从当前使用线程栈的列表 stack_used 中拿下来，放到缓存的线程栈列表 stack_cache中，从而结束了线程的生命周期。</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">void</span></span><br><span class="line">internal_function</span><br><span class="line">__free_tcb (<span class="keyword">struct</span> pthread *pd)</span><br><span class="line">&#123;</span><br><span class="line">    ......</span><br><span class="line">    __deallocate_stack (pd);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span></span><br><span class="line">internal_function</span><br><span class="line">__deallocate_stack (<span class="keyword">struct</span> pthread *pd)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">/* Remove the thread from the list of threads with user defined</span></span><br><span class="line"><span class="comment">       stacks.  */</span></span><br><span class="line">    stack_list_del (&amp;pd-&gt;<span class="built_in">list</span>);</span><br><span class="line">    <span class="comment">/* Not much to do.  Just free the mmap()ed memory.  Note that we do</span></span><br><span class="line"><span class="comment">       not reset the &#x27;used&#x27; flag in the &#x27;tid&#x27; field.  This is done by</span></span><br><span class="line"><span class="comment">       the kernel.  If no thread has been created yet this field is</span></span><br><span class="line"><span class="comment">       still zero.  */</span></span><br><span class="line">    <span class="keyword">if</span> (__glibc_likely (! pd-&gt;user_stack))</span><br><span class="line">        (<span class="type">void</span>) queue_stack (pd);</span><br><span class="line">&#125;</span><br><span class="line">  ARCH_CLONE其实调用的是 __clone()。</span><br><span class="line"></span><br><span class="line"><span class="meta"># <span class="keyword">define</span> ARCH_CLONE __clone</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/* The userland implementation is:</span></span><br><span class="line"><span class="comment">   int clone (int (*fn)(void *arg), void *child_stack, int flags, void *arg),</span></span><br><span class="line"><span class="comment">   the kernel entry is:</span></span><br><span class="line"><span class="comment">   int clone (long flags, void *child_stack).</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">   The parameters are passed in register and on the stack from userland:</span></span><br><span class="line"><span class="comment">   rdi: fn</span></span><br><span class="line"><span class="comment">   rsi: child_stack</span></span><br><span class="line"><span class="comment">   rdx: flags</span></span><br><span class="line"><span class="comment">   rcx: arg</span></span><br><span class="line"><span class="comment">   r8d: TID field in parent</span></span><br><span class="line"><span class="comment">   r9d: thread pointer</span></span><br><span class="line"><span class="comment">%esp+8: TID field in child</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">   The kernel expects:</span></span><br><span class="line"><span class="comment">   rax: system call number</span></span><br><span class="line"><span class="comment">   rdi: flags</span></span><br><span class="line"><span class="comment">   rsi: child_stack</span></span><br><span class="line"><span class="comment">   rdx: TID field in parent</span></span><br><span class="line"><span class="comment">   r10: TID field in child</span></span><br><span class="line"><span class="comment">   r8:  thread pointer  */</span></span><br><span class="line">    .text</span><br><span class="line"><span class="title function_">ENTRY</span> <span class="params">(__clone)</span></span><br><span class="line">    movq    $-EINVAL,%rax</span><br><span class="line">......</span><br><span class="line">    <span class="comment">/* Insert the argument onto the new stack.  */</span></span><br><span class="line">    subq    $16,%rsi</span><br><span class="line">    movq    %rcx,8<span class="params">(%rsi)</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">/* Save the function pointer.  It will be popped off in the</span></span><br><span class="line"><span class="comment">       child in the ebx frobbing below.  */</span></span><br><span class="line">    movq    %rdi,0<span class="params">(%rsi)</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">/* Do the system call.  */</span></span><br><span class="line">    movq    %rdx, %rdi</span><br><span class="line">    movq    %r8, %rdx</span><br><span class="line">    movq    %r9, %r8</span><br><span class="line">    mov     8<span class="params">(%rsp)</span>, %R10_LP</span><br><span class="line">    movl    $<span class="title function_">SYS_ify</span><span class="params">(clone)</span>,%eax</span><br><span class="line">......</span><br><span class="line">    syscall</span><br><span class="line">......</span><br><span class="line"><span class="title function_">PSEUDO_END</span> <span class="params">(__clone)</span></span><br></pre></td></tr></table></figure>
<p>内核中的clone()定义如下。如果在进程的主线程里面调用其他系统调用，当前用户态的栈是指向整个进程的栈，栈顶指针也是指向进程的栈，指令指针也是指向进程的主线程的代码。此时此刻执行到这里，调用 clone的时候，用户态的栈、栈顶指针、指令指针和其他系统调用一样，都是指向主线程的。但是对于线程来说，这些都要变。因为我们希望当 clone 这个系统调用成功的时候，除了内核里面有这个线程对应的 task_struct，当系统调用返回到用户态的时候，用户态的栈应该是线程的栈，栈顶指针应该指向线程的栈，指令指针应该指向线程将要执行的那个函数。所以这些都需要我们自己做，将线程要执行的函数的参数和指令的位置都压到栈里面，当从内核返回，从栈里弹出来的时候，就从这个函数开始，带着这些参数执行下去。</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">SYSCALL_DEFINE5(clone, <span class="type">unsigned</span> <span class="type">long</span>, clone_flags, <span class="type">unsigned</span> <span class="type">long</span>, newsp,</span><br><span class="line">     <span class="type">int</span> __user *, parent_tidptr,</span><br><span class="line">     <span class="type">int</span> __user *, child_tidptr,</span><br><span class="line">     <span class="type">unsigned</span> <span class="type">long</span>, tls)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">return</span> _do_fork(clone_flags, newsp, <span class="number">0</span>, parent_tidptr, child_tidptr, tls);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>线程和进程到了这里殊途同归，进入了同一个函数__do_fork()工作。其源码如下所示，主要工作包括复制结构copy_process()和唤醒新进程wak_up_new()两部分。其中线程会根据create_thread()函数中的clone_flags完成上文所述的栈顶指针和指令指针的切换，以及一些线程和进程的微妙区别。</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">long</span> _do_fork(<span class="type">unsigned</span> <span class="type">long</span> clone_flags,</span><br><span class="line">        <span class="type">unsigned</span> <span class="type">long</span> stack_start,</span><br><span class="line">        <span class="type">unsigned</span> <span class="type">long</span> stack_size,</span><br><span class="line">        <span class="type">int</span> __user *parent_tidptr,</span><br><span class="line">        <span class="type">int</span> __user *child_tidptr,</span><br><span class="line">        <span class="type">unsigned</span> <span class="type">long</span> tls)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">task_struct</span> *<span class="title">p</span>;</span></span><br><span class="line">    <span class="type">int</span> trace = <span class="number">0</span>;</span><br><span class="line">    <span class="type">long</span> nr;</span><br><span class="line"></span><br><span class="line">......</span><br><span class="line">    p = copy_process(clone_flags, stack_start, stack_size,</span><br><span class="line">       child_tidptr, <span class="literal">NULL</span>, trace, tls, NUMA_NO_NODE);</span><br><span class="line">......</span><br><span class="line">    <span class="keyword">if</span> (IS_ERR(p))</span><br><span class="line">        <span class="keyword">return</span> PTR_ERR(p);</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">pid</span> *<span class="title">pid</span>;</span></span><br><span class="line">    pid = get_task_pid(p, PIDTYPE_PID);</span><br><span class="line">    nr = pid_vnr(pid);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (clone_flags &amp; CLONE_PARENT_SETTID)</span><br><span class="line">        put_user(nr, parent_tidptr);</span><br><span class="line">    <span class="keyword">if</span> (clone_flags &amp; CLONE_VFORK) &#123;</span><br><span class="line">        p-&gt;vfork_done = &amp;vfork;</span><br><span class="line">        init_completion(&amp;vfork);</span><br><span class="line">        get_task_struct(p);</span><br><span class="line">    &#125;</span><br><span class="line">    wake_up_new_task(p);</span><br><span class="line">......</span><br><span class="line">    put_pid(pid);</span><br><span class="line">    <span class="keyword">return</span> nr;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h3 id="4-1-任务结构体复制"><a href="#4-1-任务结构体复制" class="headerlink" title="4.1 任务结构体复制"></a>4.1 任务结构体复制</h3><p>  <br>如下所示为copy_process()函数源码精简版，task_struct结构复杂也注定了复制过程的复杂性，因此此处省略了很多，仅保留了各个部分的主要调用函数</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">static</span> __latent_entropy <span class="keyword">struct</span> task_struct *<span class="title function_">copy_process</span><span class="params">(</span></span><br><span class="line"><span class="params">          <span class="type">unsigned</span> <span class="type">long</span> clone_flags,</span></span><br><span class="line"><span class="params">          <span class="type">unsigned</span> <span class="type">long</span> stack_start,</span></span><br><span class="line"><span class="params">          <span class="type">unsigned</span> <span class="type">long</span> stack_size,</span></span><br><span class="line"><span class="params">          <span class="type">int</span> __user *child_tidptr,</span></span><br><span class="line"><span class="params">          <span class="keyword">struct</span> pid *pid,</span></span><br><span class="line"><span class="params">          <span class="type">int</span> trace,</span></span><br><span class="line"><span class="params">          <span class="type">unsigned</span> <span class="type">long</span> tls,</span></span><br><span class="line"><span class="params">          <span class="type">int</span> node)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">int</span> retval;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">task_struct</span> *<span class="title">p</span>;</span></span><br><span class="line">......</span><br><span class="line">    <span class="comment">//分配task_struct结构</span></span><br><span class="line">    p = dup_task_struct(current, node);  </span><br><span class="line">......</span><br><span class="line">    <span class="comment">//权限处理</span></span><br><span class="line">    retval = copy_creds(p, clone_flags);</span><br><span class="line">......</span><br><span class="line">    <span class="comment">//设置调度相关变量</span></span><br><span class="line">    retval = sched_fork(clone_flags, p);    </span><br><span class="line">......</span><br><span class="line">    <span class="comment">//初始化文件和文件系统相关变量</span></span><br><span class="line">    retval = copy_files(clone_flags, p);</span><br><span class="line">    retval = copy_fs(clone_flags, p);  </span><br><span class="line">......</span><br><span class="line">    <span class="comment">//初始化信号相关变量</span></span><br><span class="line">    init_sigpending(&amp;p-&gt;pending);</span><br><span class="line">    retval = copy_sighand(clone_flags, p);</span><br><span class="line">    retval = copy_signal(clone_flags, p);  </span><br><span class="line">......</span><br><span class="line">    <span class="comment">//拷贝进程内存空间</span></span><br><span class="line">    retval = copy_mm(clone_flags, p);</span><br><span class="line">...... </span><br><span class="line">    <span class="comment">//初始化亲缘关系变量</span></span><br><span class="line">    INIT_LIST_HEAD(&amp;p-&gt;children);</span><br><span class="line">    INIT_LIST_HEAD(&amp;p-&gt;sibling);</span><br><span class="line">......</span><br><span class="line">    <span class="comment">//建立亲缘关系</span></span><br><span class="line">    <span class="comment">//源码放在后面说明  </span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>1、copy_process()首先调用了dup_task_struct()分配task_struct结构，dup_task_struct() 主要做了下面几件事情：</p>
<ul>
<li>调用 alloc_task_struct_node 分配一个 task_struct结构；</li>
<li>调用 alloc_thread_stack_node 来创建内核栈，这里面调用 __vmalloc_node_range 分配一个连续的 THREAD_SIZE 的内存空间，赋值给 task_struct 的 void *stack成员变量；</li>
<li>调用 arch_dup_task_struct(struct task_struct *dst, struct task_struct *src)，将 task_struct 进行复制，其实就是调用 memcpy；</li>
<li>调用setup_thread_stack设置 thread_info。</li>
</ul>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">static</span> <span class="keyword">struct</span> task_struct *<span class="title function_">dup_task_struct</span><span class="params">(<span class="keyword">struct</span> task_struct *orig, <span class="type">int</span> node)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">task_struct</span> *<span class="title">tsk</span>;</span></span><br><span class="line">    <span class="type">unsigned</span> <span class="type">long</span> *<span class="built_in">stack</span>;</span><br><span class="line">......</span><br><span class="line">    tsk = alloc_task_struct_node(node);</span><br><span class="line">    <span class="keyword">if</span> (!tsk)</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">stack</span> = alloc_thread_stack_node(tsk, node);</span><br><span class="line">    <span class="keyword">if</span> (!<span class="built_in">stack</span>)</span><br><span class="line">        <span class="keyword">goto</span> free_tsk; </span><br><span class="line">    <span class="keyword">if</span> (memcg_charge_kernel_stack(tsk))</span><br><span class="line">        <span class="keyword">goto</span> free_stack;</span><br><span class="line"></span><br><span class="line">    stack_vm_area = task_stack_vm_area(tsk);</span><br><span class="line"></span><br><span class="line">    err = arch_dup_task_struct(tsk, orig);</span><br><span class="line">......    </span><br><span class="line">    setup_thread_stack(tsk, orig);</span><br><span class="line">......    </span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>2、接着，调用copy_creds处理权限相关内容</p>
<ul>
<li>调用prepare_creds，准备一个新的 struct cred *new。如何准备呢？其实还是从内存中分配一个新的 struct cred结构，然后调用 memcpy 复制一份父进程的 cred；</li>
<li>接着 p-&gt;cred &#x3D; p-&gt;real_cred &#x3D; get_cred(new)，将新进程的“我能操作谁”和“谁能操作我”两个权限都指向新的 cred。</li>
</ul>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * Copy credentials for the new process created by fork()</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * We share if we can, but under some circumstances we have to generate a new</span></span><br><span class="line"><span class="comment"> * set.</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * The new process gets the current process&#x27;s subjective credentials as its</span></span><br><span class="line"><span class="comment"> * objective and subjective credentials</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="type">int</span> <span class="title function_">copy_creds</span><span class="params">(<span class="keyword">struct</span> task_struct *p, <span class="type">unsigned</span> <span class="type">long</span> clone_flags)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">cred</span> *<span class="title">new</span>;</span></span><br><span class="line">    <span class="type">int</span> ret;</span><br><span class="line">......</span><br><span class="line">    new = prepare_creds();</span><br><span class="line">    <span class="keyword">if</span> (!new)</span><br><span class="line">        <span class="keyword">return</span> -ENOMEM;</span><br><span class="line">......</span><br><span class="line">    <span class="type">atomic_inc</span>(&amp;new-&gt;user-&gt;processes);</span><br><span class="line">    p-&gt;cred = p-&gt;real_cred = get_cred(new);</span><br><span class="line">    alter_cred_subscribers(new, <span class="number">2</span>);</span><br><span class="line">    validate_creds(new);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>3、设置调度相关的变量。该部分源码先不展示，会在进程调度中详细介绍。sched_fork主要做了下面几件事情：</p>
<ul>
<li>调用__sched_fork，在这里面将on_rq设为 0，初始化sched_entity，将里面的 exec_start、sum_exec_runtime、prev_sum_exec_runtime、vruntime 都设为 0。这几个变量涉及进程的实际运行时间和虚拟运行时间。是否到时间应该被调度了，就靠它们几个；</li>
<li>设置进程的状态 p-&gt;state &#x3D; TASK_NEW；</li>
<li>初始化优先级 prio、normal_prio、static_prio；</li>
<li>设置调度类，如果是普通进程，就设置为 p-&gt;sched_class &#x3D; &amp;fair_sched_class；</li>
<li>调用调度类的 task_fork 函数，对于 CFS 来讲，就是调用 task_fork_fair。在这个函数里，先调用 update_curr，对于当前的进程进行统计量更新，然后把子进程和父进程的 vruntime 设成一样，最后调用 place_entity，初始化 sched_entity。这里有一个变量 sysctl_sched_child_runs_first，可以设置父进程和子进程谁先运行。如果设置了子进程先运行，即便两个进程的 vruntime 一样，也要把子进程的 sched_entity 放在前面，然后调用 resched_curr，标记当前运行的进程 TIF_NEED_RESCHED，也就是说，把父进程设置为应该被调度，这样下次调度的时候，父进程会被子进程抢占。</li>
</ul>
<p>4、初始化文件和文件系统相关变量</p>
<ul>
<li>copy_files 主要用于复制一个任务打开的文件信息。<ul>
<li>对于进程来说，这些信息用一个结构 files_struct 来维护，每个打开的文件都有一个文件描述符。在 copy_files 函数里面调用 dup_fd，在这里面会创建一个新的 files_struct，然后将所有的文件描述符数组 fdtable 拷贝一份。</li>
<li>对于线程来说，由于设置了CLONE_FILES 标识位变成将原来的files_struct 引用计数加一，并不会拷贝文件。</li>
</ul>
</li>
</ul>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">static</span> <span class="type">int</span> <span class="title function_">copy_files</span><span class="params">(<span class="type">unsigned</span> <span class="type">long</span> clone_flags, <span class="keyword">struct</span> task_struct *tsk)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">files_struct</span> *<span class="title">oldf</span>, *<span class="title">newf</span>;</span></span><br><span class="line">    <span class="type">int</span> error = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">    * A background process may not have any files ...</span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line">    oldf = current-&gt;files;</span><br><span class="line">    <span class="keyword">if</span> (!oldf)</span><br><span class="line">        <span class="keyword">goto</span> out;</span><br><span class="line">    <span class="keyword">if</span> (clone_flags &amp; CLONE_FILES) &#123;</span><br><span class="line">        <span class="type">atomic_inc</span>(&amp;oldf-&gt;count);</span><br><span class="line">        <span class="keyword">goto</span> out;</span><br><span class="line">    &#125;</span><br><span class="line">    newf = dup_fd(oldf, &amp;error);</span><br><span class="line">    <span class="keyword">if</span> (!newf)</span><br><span class="line">        <span class="keyword">goto</span> out;</span><br><span class="line"></span><br><span class="line">    tsk-&gt;files = newf;</span><br><span class="line">    error = <span class="number">0</span>;</span><br><span class="line">out:</span><br><span class="line">    <span class="keyword">return</span> error;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ul>
<li>copy_fs 主要用于复制一个任务的目录信息。<ul>
<li>对于进程来说，这些信息用一个结构 fs_struct 来维护。一个进程有自己的根目录和根文件系统 root，也有当前目录 pwd 和当前目录的文件系统，都在 fs_struct 里面维护。copy_fs 函数里面调用 copy_fs_struct，创建一个新的 fs_struct，并复制原来进程的 fs_struct。</li>
<li>对于线程来说，由于设置了CLONE_FS 标识位变成将原来的fs_struct 的用户数加一，并不会拷贝文件系统结构。</li>
</ul>
</li>
</ul>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">static</span> <span class="type">int</span> <span class="title function_">copy_fs</span><span class="params">(<span class="type">unsigned</span> <span class="type">long</span> clone_flags, <span class="keyword">struct</span> task_struct *tsk)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">fs_struct</span> *<span class="title">fs</span> =</span> current-&gt;fs;</span><br><span class="line">    <span class="keyword">if</span> (clone_flags &amp; CLONE_FS) &#123;</span><br><span class="line">        <span class="comment">/* tsk-&gt;fs is already what we want */</span></span><br><span class="line">        spin_lock(&amp;fs-&gt;lock);</span><br><span class="line">        <span class="keyword">if</span> (fs-&gt;in_exec) &#123;</span><br><span class="line">            spin_unlock(&amp;fs-&gt;lock);</span><br><span class="line">            <span class="keyword">return</span> -EAGAIN;</span><br><span class="line">        &#125;</span><br><span class="line">        fs-&gt;users++;</span><br><span class="line">        spin_unlock(&amp;fs-&gt;lock);</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    tsk-&gt;fs = copy_fs_struct(fs);</span><br><span class="line">    <span class="keyword">if</span> (!tsk-&gt;fs)</span><br><span class="line">        <span class="keyword">return</span> -ENOMEM;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>5、初始化信号相关变量</p>
<ul>
<li>整个进程里的所有线程共享一个shared_pending，这也是一个信号列表，是发给整个进程的，哪个线程处理都一样。由此我们可以做到发给进程的信号虽然可以被一个线程处理，但是影响范围应该是整个进程的。例如，kill 一个进程，则所有线程都要被干掉。如果一个信号是发给一个线程的 pthread_kill，则应该只有线程能够收到。</li>
<li>copy_sighand<ul>
<li>对于进程来说，会分配一个新的 sighand_struct。这里最主要的是维护信号处理函数，在 copy_sighand 里面会调用 memcpy，将信号处理函数 sighand-&gt;action 从父进程复制到子进程。</li>
<li>对于线程来说，由于设计了CLONE_SIGHAND标记位，会对引用计数加一并退出，没有分配新的信号变量。</li>
</ul>
</li>
</ul>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">static</span> <span class="type">int</span> <span class="title function_">copy_sighand</span><span class="params">(<span class="type">unsigned</span> <span class="type">long</span> clone_flags, <span class="keyword">struct</span> task_struct *tsk)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">sighand_struct</span> *<span class="title">sig</span>;</span></span><br><span class="line">    <span class="keyword">if</span> (clone_flags &amp; CLONE_SIGHAND) &#123;</span><br><span class="line">        refcount_inc(&amp;current-&gt;sighand-&gt;count);</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    sig = kmem_cache_alloc(sighand_cachep, GFP_KERNEL);</span><br><span class="line">    rcu_assign_pointer(tsk-&gt;sighand, sig);</span><br><span class="line">    <span class="keyword">if</span> (!sig)</span><br><span class="line">        <span class="keyword">return</span> -ENOMEM;</span><br><span class="line">    refcount_set(&amp;sig-&gt;count, <span class="number">1</span>);</span><br><span class="line">    spin_lock_irq(&amp;current-&gt;sighand-&gt;siglock);</span><br><span class="line">    <span class="built_in">memcpy</span>(sig-&gt;action, current-&gt;sighand-&gt;action, <span class="keyword">sizeof</span>(sig-&gt;action));</span><br><span class="line">    spin_unlock_irq(&amp;current-&gt;sighand-&gt;siglock);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>init_sigpending 和 copy_signal 用于初始化信号结构体，并且复制用于维护发给这个进程的信号的数据结构。copy_signal 函数会分配一个新的 signal_struct，并进行初始化。对于线程来说也是直接退出并未复制。</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">static</span> <span class="type">int</span> <span class="title function_">copy_signal</span><span class="params">(<span class="type">unsigned</span> <span class="type">long</span> clone_flags, <span class="keyword">struct</span> task_struct *tsk)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">signal_struct</span> *<span class="title">sig</span>;</span></span><br><span class="line">    <span class="keyword">if</span> (clone_flags &amp; CLONE_THREAD)</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    sig = kmem_cache_zalloc(signal_cachep, GFP_KERNEL);</span><br><span class="line">......</span><br><span class="line">    <span class="comment">/* list_add(thread_node, thread_head) without INIT_LIST_HEAD() */</span></span><br><span class="line">    sig-&gt;thread_head = (<span class="keyword">struct</span> list_head)LIST_HEAD_INIT(tsk-&gt;thread_node);</span><br><span class="line">    tsk-&gt;thread_node = (<span class="keyword">struct</span> list_head)LIST_HEAD_INIT(sig-&gt;thread_head);</span><br><span class="line">    init_waitqueue_head(&amp;sig-&gt;wait_chldexit);</span><br><span class="line">    sig-&gt;curr_target = tsk;</span><br><span class="line">    init_sigpending(&amp;sig-&gt;shared_pending);</span><br><span class="line">    INIT_HLIST_HEAD(&amp;sig-&gt;multiprocess);</span><br><span class="line">    seqlock_init(&amp;sig-&gt;stats_lock);</span><br><span class="line">    prev_cputime_init(&amp;sig-&gt;prev_cputime);</span><br><span class="line">......</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>6、复制进程内存空间</p>
<ul>
<li>进程都有自己的内存空间，用 mm_struct 结构来表示。copy_mm() 函数中调用 dup_mm()，分配一个新的 mm_struct 结构，调用 memcpy 复制这个结构。dup_mmap() 用于复制内存空间中内存映射的部分。前面讲系统调用的时候，我们说过，mmap 可以分配大块的内存，其实 mmap 也可以将一个文件映射到内存中，方便可以像读写内存一样读写文件，这个在内存管理那节我们讲。</li>
<li>线程不会复制内存空间，因此因为CLONE_VM标识位而直接指向了原来的mm_struct。</li>
</ul>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">static</span> <span class="type">int</span> <span class="title function_">copy_mm</span><span class="params">(<span class="type">unsigned</span> <span class="type">long</span> clone_flags, <span class="keyword">struct</span> task_struct *tsk)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">mm_struct</span> *<span class="title">mm</span>, *<span class="title">oldmm</span>;</span></span><br><span class="line">    <span class="type">int</span> retval;</span><br><span class="line">......</span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">    * Are we cloning a kernel thread?</span></span><br><span class="line"><span class="comment">    * We need to steal a active VM for that..</span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line">    oldmm = current-&gt;mm;</span><br><span class="line">    <span class="keyword">if</span> (!oldmm)</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    <span class="comment">/* initialize the new vmacache entries */</span></span><br><span class="line">    vmacache_flush(tsk);</span><br><span class="line">    <span class="keyword">if</span> (clone_flags &amp; CLONE_VM) &#123;</span><br><span class="line">        mmget(oldmm);</span><br><span class="line">        mm = oldmm;</span><br><span class="line">        <span class="keyword">goto</span> good_mm;</span><br><span class="line">    &#125;</span><br><span class="line">    retval = -ENOMEM;</span><br><span class="line">    mm = dup_mm(tsk);</span><br><span class="line">    <span class="keyword">if</span> (!mm)</span><br><span class="line">        <span class="keyword">goto</span> fail_nomem;</span><br><span class="line">good_mm:</span><br><span class="line">    tsk-&gt;mm = mm;</span><br><span class="line">    tsk-&gt;active_mm = mm;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">fail_nomem:</span><br><span class="line">    <span class="keyword">return</span> retval;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>7、分配 pid，设置 tid，group_leader，并且建立任务之间的亲缘关系。</p>
<ul>
<li>group_leader：进程的话 group_leader就是它自己，和旧进程分开。线程的话则设置为当前进程的group_leader。</li>
<li>tgid: 对进程来说是自己的pid，对线程来说是当前进程的pid</li>
<li>real_parent : 对进程来说即当前进程，对线程来说则是当前进程的real_parent</li>
</ul>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">static</span> __latent_entropy <span class="keyword">struct</span> task_struct *<span class="title function_">copy_process</span><span class="params">(......)</span> &#123;</span><br><span class="line">......    </span><br><span class="line">    p-&gt;pid = pid_nr(pid);</span><br><span class="line">    <span class="keyword">if</span> (clone_flags &amp; CLONE_THREAD) &#123;</span><br><span class="line">        p-&gt;exit_signal = <span class="number">-1</span>;</span><br><span class="line">        p-&gt;group_leader = current-&gt;group_leader;</span><br><span class="line">        p-&gt;tgid = current-&gt;tgid;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (clone_flags &amp; CLONE_PARENT)</span><br><span class="line">          p-&gt;exit_signal = current-&gt;group_leader-&gt;exit_signal;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">          p-&gt;exit_signal = (clone_flags &amp; CSIGNAL);</span><br><span class="line">        p-&gt;group_leader = p;</span><br><span class="line">        p-&gt;tgid = p-&gt;pid;</span><br><span class="line">    &#125;</span><br><span class="line">......</span><br><span class="line">    <span class="keyword">if</span> (clone_flags &amp; (CLONE_PARENT|CLONE_THREAD)) &#123;</span><br><span class="line">        p-&gt;real_parent = current-&gt;real_parent;</span><br><span class="line">        p-&gt;parent_exec_id = current-&gt;parent_exec_id;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        p-&gt;real_parent = current;</span><br><span class="line">        p-&gt;parent_exec_id = current-&gt;self_exec_id;</span><br><span class="line">    &#125; </span><br><span class="line">......  </span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h3 id="4-2-新进程的唤醒"><a href="#4-2-新进程的唤醒" class="headerlink" title="4.2 新进程的唤醒"></a>4.2 新进程的唤醒</h3><figure class="highlight c"><table><tr><td class="code"><pre><span class="line">_do_fork 做的第二件大事是通过调用 wake_up_new_task()唤醒进程。</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">wake_up_new_task</span><span class="params">(<span class="keyword">struct</span> task_struct *p)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">rq_flags</span> <span class="title">rf</span>;</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">rq</span> *<span class="title">rq</span>;</span></span><br><span class="line">......</span><br><span class="line">    p-&gt;state = TASK_RUNNING;</span><br><span class="line">......</span><br><span class="line">    activate_task(rq, p, ENQUEUE_NOCLOCK);</span><br><span class="line">    trace_sched_wakeup_new(p);</span><br><span class="line">    check_preempt_curr(rq, p, WF_FORK);</span><br><span class="line">......</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>首先，我们需要将进程的状态设置为 TASK_RUNNING。activate_task() 函数中会调用 enqueue_task()。</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">activate_task</span><span class="params">(<span class="keyword">struct</span> rq *rq, <span class="keyword">struct</span> task_struct *p, <span class="type">int</span> flags)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">if</span> (task_contributes_to_load(p))</span><br><span class="line">        rq-&gt;nr_uninterruptible--;</span><br><span class="line"></span><br><span class="line">    enqueue_task(rq, p, flags);</span><br><span class="line"></span><br><span class="line">    p-&gt;on_rq = TASK_ON_RQ_QUEUED;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">static</span> <span class="keyword">inline</span> <span class="type">void</span> <span class="title function_">enqueue_task</span><span class="params">(<span class="keyword">struct</span> rq *rq, <span class="keyword">struct</span> task_struct *p, <span class="type">int</span> flags)</span></span><br><span class="line">&#123;</span><br><span class="line">.....</span><br><span class="line">    p-&gt;sched_class-&gt;enqueue_task(rq, p, flags);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>如果是 CFS 的调度类，则执行相应的 enqueue_task_fair()。在 enqueue_task_fair() 中取出的队列就是 cfs_rq，然后调用 enqueue_entity()。在 enqueue_entity() 函数里面，会调用 update_curr()，更新运行的统计量，然后调用 __enqueue_entity，将 sched_entity 加入到红黑树里面，然后将 se-&gt;on_rq &#x3D; 1 设置在队列上。回到 enqueue_task_fair 后，将这个队列上运行的进程数目加一。然后，wake_up_new_task 会调用 check_preempt_curr，看是否能够抢占当前进程。</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">static</span> <span class="type">void</span></span><br><span class="line"><span class="title function_">enqueue_task_fair</span><span class="params">(<span class="keyword">struct</span> rq *rq, <span class="keyword">struct</span> task_struct *p, <span class="type">int</span> flags)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">cfs_rq</span> *<span class="title">cfs_rq</span>;</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">sched_entity</span> *<span class="title">se</span> =</span> &amp;p-&gt;se;</span><br><span class="line">......</span><br><span class="line">    for_each_sched_entity(se) &#123;</span><br><span class="line">        <span class="keyword">if</span> (se-&gt;on_rq)</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        cfs_rq = cfs_rq_of(se);</span><br><span class="line">        enqueue_entity(cfs_rq, se, flags);</span><br><span class="line"></span><br><span class="line">        cfs_rq-&gt;h_nr_running++;</span><br><span class="line">        cfs_rq-&gt;idle_h_nr_running += idle_h_nr_running;</span><br><span class="line"></span><br><span class="line">        <span class="comment">/* end evaluation on encountering a throttled cfs_rq */</span></span><br><span class="line">        <span class="keyword">if</span> (cfs_rq_throttled(cfs_rq))</span><br><span class="line">            <span class="keyword">goto</span> enqueue_throttle;</span><br><span class="line"></span><br><span class="line">        flags = ENQUEUE_WAKEUP;</span><br><span class="line">    &#125;</span><br><span class="line">......</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>在 check_preempt_curr 中，会调用相应的调度类的 rq-&gt;curr-&gt;sched_class-&gt;check_preempt_curr(rq, p, flags)。对于CFS调度类来讲，调用的是 check_preempt_wakeup。在 check_preempt_wakeup函数中，前面调用 task_fork_fair的时候，设置 sysctl_sched_child_runs_first 了，已经将当前父进程的 TIF_NEED_RESCHED 设置了，则直接返回。否则，check_preempt_wakeup 还是会调用 update_curr 更新一次统计量，然后 wakeup_preempt_entity 将父进程和子进程 PK 一次，看是不是要抢占，如果要则调用 resched_curr 标记父进程为 TIF_NEED_RESCHED。如果新创建的进程应该抢占父进程，在什么时间抢占呢？别忘了 fork 是一个系统调用，从系统调用返回的时候，是抢占的一个好时机，如果父进程判断自己已经被设置为 TIF_NEED_RESCHED，就让子进程先跑，抢占自己。</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">static</span> <span class="type">void</span> <span class="title function_">check_preempt_wakeup</span><span class="params">(<span class="keyword">struct</span> rq *rq, <span class="keyword">struct</span> task_struct *p, <span class="type">int</span> wake_flags)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">task_struct</span> *<span class="title">curr</span> =</span> rq-&gt;curr;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">sched_entity</span> *<span class="title">se</span> =</span> &amp;curr-&gt;se, *pse = &amp;p-&gt;se;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">cfs_rq</span> *<span class="title">cfs_rq</span> =</span> task_cfs_rq(curr);</span><br><span class="line">......</span><br><span class="line">    <span class="keyword">if</span> (test_tsk_need_resched(curr))</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">......</span><br><span class="line">    find_matching_se(&amp;se, &amp;pse);</span><br><span class="line">    update_curr(cfs_rq_of(se));</span><br><span class="line">    <span class="keyword">if</span> (wakeup_preempt_entity(se, pse) == <span class="number">1</span>) &#123;</span><br><span class="line">        <span class="keyword">goto</span> preempt;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span>;</span><br><span class="line">preempt:</span><br><span class="line">    resched_curr(rq);</span><br><span class="line">......</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>至此，我们就完成了任务的整个创建过程，并根据情况唤醒任务开始执行。</p>
<h2 id="五-总结"><a href="#五-总结" class="headerlink" title="五. 总结"></a>五. 总结</h2><p>本文十分之长，因为内容极多，源码复杂，本来想拆分为两篇文章，但是又因为过于紧密的联系因此合在了一起。本文介绍了进程的创建和线程的创建，而多进程的派生因为使用和线程内核态创建一样的函数因此放在了一起变对比边说明。由此，进程、线程的结构体以及创建过程就全部分析完了，下文将继续分析进程、线程的调度。</p>
]]></content>
      <categories>
        <category>linux-doc 进程管理</category>
      </categories>
      <tags>
        <tag>Linux</tag>
      </tags>
  </entry>
  <entry>
    <title>进程的核心——task_truct</title>
    <url>/2023/01/15/linux-docs/%E8%BF%9B%E7%A8%8B%E7%AE%A1%E7%90%86/%E8%BF%9B%E7%A8%8B%E7%9A%84%E6%A0%B8%E5%BF%83%E2%80%94%E2%80%94task_truct/</url>
    <content><![CDATA[<h2 id="一-前言"><a href="#一-前言" class="headerlink" title="一. 前言"></a>一. 前言</h2><p>在前文中，我们分析了内核启动的整个过程以及系统调用的过程，从本文开始我们会介绍Linux系统各个重要的组成部分。这一切就从进程和线程开始，在 Linux 里面，无论是进程，还是线程，到了内核里面，我们统一都叫任务（Task），由一个统一的结构 task_struct 进行管理。这个结构非常复杂，本文将细细分析task_struct结构。主要分析顺序会按照该架构体中的成员变量和函数的作用进行分类，主要包括：</p>
<ul>
<li>任务ID</li>
<li>亲缘关系</li>
<li>任务状态</li>
<li>任务权限</li>
<li>运行统计</li>
<li>进程调度</li>
<li>信号处理</li>
<li>内存管理</li>
<li>文件与文件系统</li>
<li>内核栈</li>
</ul>
<h2 id="二-详细介绍"><a href="#二-详细介绍" class="headerlink" title="二. 详细介绍"></a>二. 详细介绍</h2><h3 id="2-1-任务ID"><a href="#2-1-任务ID" class="headerlink" title="2.1 任务ID"></a>2.1 任务ID</h3><p>任务ID是任务的唯一标识，在tast_struct中，主要涉及以下几个ID</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">pid_t</span> pid;</span><br><span class="line"><span class="type">pid_t</span> tgid;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">task_struct</span> *<span class="title">group_leader</span>;</span></span><br></pre></td></tr></table></figure>

<p>之所以有pid(process id)，tgid(thread group ID)以及group_leader，是因为线程和进程在内核中是统一管理，视为相同的任务（task）。</p>
<p>任何一个进程，如果只有主线程，那 pid 和tgid相同，group_leader 指向自己。但是，如果一个进程创建了其他线程，那就会有所变化了。线程有自己的pid，tgid 就是进程的主线程的 pid，group_leader 指向的进程的主线程。因此根据pid和tgid是否相等我们可以判断该任务是进程还是线程。</p>
<h3 id="2-2-亲缘关系"><a href="#2-2-亲缘关系" class="headerlink" title="2.2 亲缘关系"></a>2.2 亲缘关系</h3><p>除了0号进程以外，其他进程都是有父进程的。全部进程其实就是一颗进程树，相关成员变量如下所示</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">task_struct</span> __<span class="title">rcu</span> *<span class="title">real_parent</span>;</span> <span class="comment">/* real parent process */</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">task_struct</span> __<span class="title">rcu</span> *<span class="title">parent</span>;</span> <span class="comment">/* recipient of SIGCHLD, wait4() reports */</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">list_head</span> <span class="title">children</span>;</span>      <span class="comment">/* list of my children */</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">list_head</span> <span class="title">sibling</span>;</span>       <span class="comment">/* linkage in my parent&#x27;s children list */</span></span><br></pre></td></tr></table></figure>
<ul>
<li>parent 指向其父进程。当它终止时，必须向它的父进程发送信号。</li>
<li>children 指向子进程链表的头部。链表中的所有元素都是它的子进程。</li>
<li>sibling 用于把当前进程插入到兄弟链表中。</li>
</ul>
<p>通常情况下，real_parent 和 parent 是一样的，但是也会有另外的情况存在。例如，bash 创建一个进程，那进程的 parent 和 real_parent 就都是 bash。如果在 bash 上使用 GDB 来 debug 一个进程，这个时候 GDB 是 parent，bash 是这个进程的 real_parent。</p>
<h3 id="2-3-任务状态"><a href="#2-3-任务状态" class="headerlink" title="2.3 任务状态"></a>2.3 任务状态</h3><p>任务状态部分主要涉及以下变量</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="keyword">volatile</span> <span class="type">long</span> state;    <span class="comment">/* -1 unrunnable, 0 runnable, &gt;0 stopped */</span></span><br><span class="line"><span class="type">int</span> exit_state;</span><br><span class="line"><span class="type">unsigned</span> <span class="type">int</span> flags;</span><br></pre></td></tr></table></figure>
<p>其中状态state通过设置比特位的方式来赋值，具体值在include&#x2F;linux&#x2F;sched.h中定义</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">/* Used in tsk-&gt;state: */</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> TASK_RUNNING                    0</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> TASK_INTERRUPTIBLE              1</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> TASK_UNINTERRUPTIBLE            2</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> __TASK_STOPPED                  4</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> __TASK_TRACED                   8</span></span><br><span class="line"><span class="comment">/* Used in tsk-&gt;exit_state: */</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> EXIT_DEAD                       16</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> EXIT_ZOMBIE                     32</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> EXIT_TRACE                      (EXIT_ZOMBIE | EXIT_DEAD)</span></span><br><span class="line"><span class="comment">/* Used in tsk-&gt;state again: */</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> TASK_DEAD                       64</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> TASK_WAKEKILL                   128</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> TASK_WAKING                     256</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> TASK_PARKED                     512</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> TASK_NOLOAD                     1024</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> TASK_NEW                        2048</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> TASK_STATE_MAX                  4096</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> TASK_KILLABLE           (TASK_WAKEKILL | TASK_UNINTERRUPTIBLE)</span></span><br></pre></td></tr></table></figure>
<p>TASK_RUNNING并不是说进程正在运行，而是表示进程在时刻准备运行的状态。当处于这个状态的进程获得时间片的时候，就是在运行中；如果没有获得时间片，就说明它被其他进程抢占了，在等待再次分配时间片。在运行中的进程，一旦要进行一些 I&#x2F;O 操作，需要等待 I&#x2F;O 完毕，这个时候会释放 CPU，进入睡眠状态。</p>
<p>在 Linux 中，有两种睡眠状态。</p>
<ul>
<li>一种是 TASK_INTERRUPTIBLE，可中断的睡眠状态。这是一种浅睡眠的状态，也就是说，虽然在睡眠，等待 I&#x2F;O 完成，但是这个时候一个信号来的时候，进程还是要被唤醒。只不过唤醒后，不是继续刚才的操作，而是进行信号处理。当然程序员可以根据自己的意愿，来写信号处理函数，例如收到某些信号，就放弃等待这个 I&#x2F;O 操作完成，直接退出；或者收到某些信息，继续等待。</li>
<li>另一种睡眠是 TASK_UNINTERRUPTIBLE，不可中断的睡眠状态。这是一种深度睡眠状态，不可被信号唤醒，只能死等 I&#x2F;O 操作完成。一旦 I&#x2F;O 操作因为特殊原因不能完成，这个时候，谁也叫不醒这个进程了。你可能会说，我 kill 它呢？别忘了，kill 本身也是一个信号，既然这个状态不可被信号唤醒，kill 信号也被忽略了。除非重启电脑，没有其他办法。因此，这其实是一个比较危险的事情，除非程序员极其有把握，不然还是不要设置成 TASK_UNINTERRUPTIBLE。</li>
<li>于是，我们就有了一种新的进程睡眠状态，TASK_KILLABLE，可以终止的新睡眠状态。进程处于这种状态中，它的运行原理类似 TASK_UNINTERRUPTIBLE，只不过可以响应致命信号。由于TASK_WAKEKILL 用于在接收到致命信号时唤醒进程，因此TASK_KILLABLE即在TASK_UNINTERUPTIBLE的基础上增加一个TASK_WAKEKILL标记位即可。</li>
</ul>
<p>TASK_STOPPED是在进程接收到 SIGSTOP、SIGTTIN、SIGTSTP或者 SIGTTOU 信号之后进入该状态。</p>
<p>TASK_TRACED 表示进程被 debugger 等进程监视，进程执行被调试程序所停止。当一个进程被另外的进程所监视，每一个信号都会让进程进入该状态。</p>
<p>一旦一个进程要结束，先进入的是 EXIT_ZOMBIE 状态，但是这个时候它的父进程还没有使用wait() 等系统调用来获知它的终止信息，此时进程就成了僵尸进程。EXIT_DEAD 是进程的最终状态。EXIT_ZOMBIE 和 EXIT_DEAD 也可以用于 exit_state。</p>
<p>上面的进程状态和进程的运行、调度有关系，还有其他的一些状态，我们称为标志。放在 flags字段中，这些字段都被定义成为宏，以 PF 开头。</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">define</span> PF_EXITING    0x00000004</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> PF_VCPU      0x00000010</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> PF_FORKNOEXEC    0x00000040</span></span><br></pre></td></tr></table></figure>
<p>PF_EXITING 表示正在退出。当有这个 flag 的时候，在函数 find_alive_thread() 中，找活着的线程，遇到有这个 flag 的，就直接跳过。</p>
<p>PF_VCPU 表示进程运行在虚拟 CPU 上。在函数 account_system_time中，统计进程的系统运行时间，如果有这个 flag，就调用 account_guest_time，按照客户机的时间进行统计。</p>
<p>PF_FORKNOEXEC 表示 fork 完了，还没有 exec。在 _do_fork ()函数里面调用 copy_process()，这个时候把 flag 设置为 PF_FORKNOEXEC()。当 exec 中调用了 load_elf_binary() 的时候，又把这个 flag 去掉。</p>
<p><img src="https://user-images.githubusercontent.com/87457873/128131586-732bef83-436c-4529-9417-10153cef7360.png" alt="image"></p>
<h3 id="2-4-任务权限"><a href="#2-4-任务权限" class="headerlink" title="2.4 任务权限"></a>2.4 任务权限</h3><p>任务权限主要包括以下两个变量，real_cred是指可以操作本任务的对象，而red是指本任务可以操作的对象。</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">/* Objective and real subjective task credentials (COW): */</span></span><br><span class="line"><span class="type">const</span> <span class="class"><span class="keyword">struct</span> <span class="title">cred</span> __<span class="title">rcu</span>         *<span class="title">real_cred</span>;</span></span><br><span class="line"><span class="comment">/* Effective (overridable) subjective task credentials (COW): */</span></span><br><span class="line"><span class="type">const</span> <span class="class"><span class="keyword">struct</span> <span class="title">cred</span> __<span class="title">rcu</span>         *<span class="title">cred</span>;</span></span><br></pre></td></tr></table></figure>
<p>cred定义如下所示</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">cred</span> &#123;</span></span><br><span class="line">......</span><br><span class="line">    <span class="type">kuid_t</span>          uid;            <span class="comment">/* real UID of the task */</span></span><br><span class="line">    <span class="type">kgid_t</span>          gid;            <span class="comment">/* real GID of the task */</span></span><br><span class="line">    <span class="type">kuid_t</span>          suid;           <span class="comment">/* saved UID of the task */</span></span><br><span class="line">    <span class="type">kgid_t</span>          sgid;           <span class="comment">/* saved GID of the task */</span></span><br><span class="line">    <span class="type">kuid_t</span>          euid;           <span class="comment">/* effective UID of the task */</span></span><br><span class="line">    <span class="type">kgid_t</span>          egid;           <span class="comment">/* effective GID of the task */</span></span><br><span class="line">    <span class="type">kuid_t</span>          fsuid;          <span class="comment">/* UID for VFS ops */</span></span><br><span class="line">    <span class="type">kgid_t</span>          fsgid;          <span class="comment">/* GID for VFS ops */</span></span><br><span class="line">......</span><br><span class="line">    <span class="type">kernel_cap_t</span>    cap_inheritable; <span class="comment">/* caps our children can inherit */</span></span><br><span class="line">    <span class="type">kernel_cap_t</span>    cap_permitted;  <span class="comment">/* caps we&#x27;re permitted */</span></span><br><span class="line">    <span class="type">kernel_cap_t</span>    cap_effective;  <span class="comment">/* caps we can actually use */</span></span><br><span class="line">    <span class="type">kernel_cap_t</span>    cap_bset;       <span class="comment">/* capability bounding set */</span></span><br><span class="line">    <span class="type">kernel_cap_t</span>    cap_ambient;    <span class="comment">/* Ambient capability set */</span></span><br><span class="line">......</span><br><span class="line">&#125; __randomize_layout;</span><br></pre></td></tr></table></figure>
<p>从这里的定义可以看出，大部分是关于用户和用户所属的用户组信息。</p>
<ul>
<li>uid和 gid，注释是 real user&#x2F;group id。一般情况下，谁启动的进程，就是谁的 ID。但是权限审核的时候，往往不比较这两个，也就是说不大起作用。</li>
<li>euid 和 egid，注释是 effective user&#x2F;group id。一看这个名字，就知道这个是起“作用”的。当这个进程要操作消息队列、共享内存、信号量等对象的时候，其实就是在比较这个用户和组是否有权限。</li>
<li>fsuid 和fsgid，也就是 filesystem user&#x2F;group id。这个是对文件操作会审核的权限。</li>
</ul>
<p>在Linux中，我们可以通过chmod u+s program命令更改更改euid和fsuid来获取权限。</p>
<p>除了以用户和用户组控制权限，Linux 还有另一个机制就是 capabilities。</p>
<p>原来控制进程的权限，要么是高权限的 root 用户，要么是一般权限的普通用户，这时候的问题是，root 用户权限太大，而普通用户权限太小。有时候一个普通用户想做一点高权限的事情，必须给他整个 root 的权限。这个太不安全了。于是，我们引入新的机制 capabilities，用位图表示权限，在capability.h可以找到定义的权限。我这里列举几个。</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">define</span> CAP_CHOWN            0</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> CAP_KILL             5</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> CAP_NET_BIND_SERVICE 10</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> CAP_NET_RAW          13</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> CAP_SYS_MODULE       16</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> CAP_SYS_RAWIO        17</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> CAP_SYS_BOOT         22</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> CAP_SYS_TIME         25</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> CAP_AUDIT_READ          37</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> CAP_LAST_CAP         CAP_AUDIT_READ</span></span><br></pre></td></tr></table></figure>
<p>对于普通用户运行的进程，当有这个权限的时候，就能做这些操作；没有的时候，就不能做，这样粒度要小很多。</p>
<h3 id="2-5-运行统计"><a href="#2-5-运行统计" class="headerlink" title="2.5 运行统计"></a>2.5 运行统计</h3><p>运行统计从宏观来说也是一种状态变量，但是和任务状态不同，其存储的主要是运行时间相关的成员变量，具体如下所示</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">u64        utime;<span class="comment">//用户态消耗的CPU时间</span></span><br><span class="line">u64        stime;<span class="comment">//内核态消耗的CPU时间</span></span><br><span class="line"><span class="type">unsigned</span> <span class="type">long</span>      nvcsw;<span class="comment">//自愿(voluntary)上下文切换计数</span></span><br><span class="line"><span class="type">unsigned</span> <span class="type">long</span>      nivcsw;<span class="comment">//非自愿(involuntary)上下文切换计数</span></span><br><span class="line">u64        start_time;<span class="comment">//进程启动时间，不包含睡眠时间</span></span><br><span class="line">u64        real_start_time;<span class="comment">//进程启动时间，包含睡眠时间</span></span><br></pre></td></tr></table></figure>
<h3 id="2-6-进程调度"><a href="#2-6-进程调度" class="headerlink" title="2.6 进程调度"></a>2.6 进程调度</h3><p>进程调度部分较为复杂，会单独拆分讲解，这里先简单罗列成员变量。</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">//是否在运行队列上</span></span><br><span class="line"><span class="type">int</span>        on_rq;</span><br><span class="line"><span class="comment">//优先级</span></span><br><span class="line"><span class="type">int</span>        prio;</span><br><span class="line"><span class="type">int</span>        static_prio;</span><br><span class="line"><span class="type">int</span>        normal_prio;</span><br><span class="line"><span class="type">unsigned</span> <span class="type">int</span>      rt_priority;</span><br><span class="line"><span class="comment">//调度器类</span></span><br><span class="line"><span class="type">const</span> <span class="class"><span class="keyword">struct</span> <span class="title">sched_class</span>  *<span class="title">sched_class</span>;</span></span><br><span class="line"><span class="comment">//调度实体</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">sched_entity</span>    <span class="title">se</span>;</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">sched_rt_entity</span>    <span class="title">rt</span>;</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">sched_dl_entity</span>    <span class="title">dl</span>;</span></span><br><span class="line"><span class="comment">//调度策略</span></span><br><span class="line"><span class="type">unsigned</span> <span class="type">int</span>      policy;</span><br><span class="line"><span class="comment">//可以使用哪些CPU</span></span><br><span class="line"><span class="type">int</span>        nr_cpus_allowed;</span><br><span class="line"><span class="type">cpumask_t</span>      cpus_allowed;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">sched_info</span>    <span class="title">sched_info</span>;</span></span><br></pre></td></tr></table></figure>
<h3 id="2-7-信号处理"><a href="#2-7-信号处理" class="headerlink" title="2.7 信号处理"></a>2.7 信号处理</h3><p>信号处理相关的数据结构如下所示</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">/* Signal handlers: */</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">signal_struct</span>    *<span class="title">signal</span>;</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">sighand_struct</span>    *<span class="title">sighand</span>;</span></span><br><span class="line"><span class="type">sigset_t</span>      blocked;</span><br><span class="line"><span class="type">sigset_t</span>      real_blocked;</span><br><span class="line"><span class="type">sigset_t</span>      saved_sigmask;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">sigpending</span>    <span class="title">pending</span>;</span></span><br><span class="line"><span class="type">unsigned</span> <span class="type">long</span>      sas_ss_sp;</span><br><span class="line"><span class="type">size_t</span>        sas_ss_size;</span><br><span class="line"><span class="type">unsigned</span> <span class="type">int</span>      sas_ss_flags;</span><br></pre></td></tr></table></figure>
<p>这里将信号分为三类</p>
<ul>
<li>阻塞暂不处理的信号（blocked）</li>
<li>等待处理的信号（pending）</li>
<li>正在通过信号处理函数处理的信号（sighand）</li>
</ul>
<p>信号处理函数默认使用用户态的函数栈，当然也可以开辟新的栈专门用于信号处理，这就是 sas_ss_xxx 这三个变量的作用。</p>
<h3 id="2-8-内存管理"><a href="#2-8-内存管理" class="headerlink" title="2.8 内存管理"></a>2.8 内存管理</h3><p>内存管理部分成员变量如下所示</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">mm_struct</span>                *<span class="title">mm</span>;</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">mm_struct</span>                *<span class="title">active_mm</span>;</span></span><br></pre></td></tr></table></figure>
<p>由于内存部分较为复杂，会放在后面单独介绍，这里了先不做详细说明。</p>
<h3 id="2-9-文件与文件系统"><a href="#2-9-文件与文件系统" class="headerlink" title="2.9 文件与文件系统"></a>2.9 文件与文件系统</h3><p>文件系统部分也会在后面详细说明，这里先简单列举成员变量</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">/* Filesystem information: */</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">fs_struct</span>                *<span class="title">fs</span>;</span></span><br><span class="line"><span class="comment">/* Open file information: */</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">files_struct</span>             *<span class="title">files</span>;</span></span><br></pre></td></tr></table></figure>
<h3 id="2-10-内核栈"><a href="#2-10-内核栈" class="headerlink" title="2.10 内核栈"></a>2.10 内核栈</h3><p>内核栈相关的成员变量如下所示。为了介绍清楚其作用，我们需要从为什么需要内核栈开始逐步讨论。</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">thread_info</span>    <span class="title">thread_info</span>;</span></span><br><span class="line"><span class="type">void</span>  *<span class="built_in">stack</span>;</span><br></pre></td></tr></table></figure>

<p>当进程产生系统调用时，会利用中断陷入内核态。而内核态中也存在着各种函数的调用，因此我们需要有内核态函数栈。Linux 给每个 task 都分配了内核栈。在 32 位系统上 arch&#x2F;x86&#x2F;include&#x2F;asm&#x2F;page_32_types.h，是这样定义的：一个 PAGE_SIZE是 4K，左移一位就是乘以 2，也就是 8K。</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">define</span> THREAD_SIZE_ORDER  1</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> THREAD_SIZE    (PAGE_SIZE &lt;&lt; THREAD_SIZE_ORDER)</span></span><br></pre></td></tr></table></figure>
<p>内核栈在 64 位系统上 arch&#x2F;x86&#x2F;include&#x2F;asm&#x2F;page_64_types.h，是这样定义的：在 PAGE_SIZE 的基础上左移两位，也即 16K，并且要求起始地址必须是 8192 的整数倍。</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">ifdef</span> CONFIG_KASAN</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> KASAN_STACK_ORDER 1</span></span><br><span class="line"><span class="meta">#<span class="keyword">else</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> KASAN_STACK_ORDER 0</span></span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> THREAD_SIZE_ORDER  (2 + KASAN_STACK_ORDER)</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> THREAD_SIZE  (PAGE_SIZE &lt;&lt; THREAD_SIZE_ORDER)</span></span><br></pre></td></tr></table></figure>
<p>内核栈的结构如下所示，首先是预留的8个字节，然后是存储寄存器，最后存储thread_info结构体。</p>
<p><img src="https://user-images.githubusercontent.com/87457873/128131628-97ac325a-96f2-4535-9c07-b718c1f54515.png" alt="image"></p>
<p>这个结构是对 task_struct 结构的补充。因为 task_struct 结构庞大但是通用，不同的体系结构就需要保存不同的东西，所以往往与体系结构有关的，都放在 thread_info 里面。在内核代码里面采用一个 union将thread_info和stack 放在一起，在 include&#x2F;linux&#x2F;sched.h 中定义用以表示内核栈。由代码可见，这里根据架构不同可能采用旧版的task_struct直接放在内核栈，而新版的均采用thread_info，以节约空间。</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">union</span> <span class="title">thread_union</span> &#123;</span></span><br><span class="line"><span class="meta">#<span class="keyword">ifndef</span> CONFIG_ARCH_TASK_STRUCT_ON_STACK</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">task_struct</span> <span class="title">task</span>;</span></span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">ifndef</span> CONFIG_THREAD_INFO_IN_TASK</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">thread_info</span> <span class="title">thread_info</span>;</span></span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line">    <span class="type">unsigned</span> <span class="type">long</span> <span class="built_in">stack</span>[THREAD_SIZE/<span class="keyword">sizeof</span>(<span class="type">long</span>)];</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>另一个结构 pt_regs，定义如下。其中，32 位和 64 位的定义不一样。</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">ifdef</span> __i386__</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">pt_regs</span> &#123;</span></span><br><span class="line">  <span class="type">unsigned</span> <span class="type">long</span> bx;</span><br><span class="line">  <span class="type">unsigned</span> <span class="type">long</span> cx;</span><br><span class="line">  <span class="type">unsigned</span> <span class="type">long</span> dx;</span><br><span class="line">  <span class="type">unsigned</span> <span class="type">long</span> si;</span><br><span class="line">  <span class="type">unsigned</span> <span class="type">long</span> di;</span><br><span class="line">  <span class="type">unsigned</span> <span class="type">long</span> bp;</span><br><span class="line">  <span class="type">unsigned</span> <span class="type">long</span> ax;</span><br><span class="line">  <span class="type">unsigned</span> <span class="type">long</span> ds;</span><br><span class="line">  <span class="type">unsigned</span> <span class="type">long</span> es;</span><br><span class="line">  <span class="type">unsigned</span> <span class="type">long</span> fs;</span><br><span class="line">  <span class="type">unsigned</span> <span class="type">long</span> gs;</span><br><span class="line">  <span class="type">unsigned</span> <span class="type">long</span> orig_ax;</span><br><span class="line">  <span class="type">unsigned</span> <span class="type">long</span> ip;</span><br><span class="line">  <span class="type">unsigned</span> <span class="type">long</span> cs;</span><br><span class="line">  <span class="type">unsigned</span> <span class="type">long</span> flags;</span><br><span class="line">  <span class="type">unsigned</span> <span class="type">long</span> sp;</span><br><span class="line">  <span class="type">unsigned</span> <span class="type">long</span> ss;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="meta">#<span class="keyword">else</span> </span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">pt_regs</span> &#123;</span></span><br><span class="line">  <span class="type">unsigned</span> <span class="type">long</span> r15;</span><br><span class="line">  <span class="type">unsigned</span> <span class="type">long</span> r14;</span><br><span class="line">  <span class="type">unsigned</span> <span class="type">long</span> r13;</span><br><span class="line">  <span class="type">unsigned</span> <span class="type">long</span> r12;</span><br><span class="line">  <span class="type">unsigned</span> <span class="type">long</span> bp;</span><br><span class="line">  <span class="type">unsigned</span> <span class="type">long</span> bx;</span><br><span class="line">  <span class="type">unsigned</span> <span class="type">long</span> r11;</span><br><span class="line">  <span class="type">unsigned</span> <span class="type">long</span> r10;</span><br><span class="line">  <span class="type">unsigned</span> <span class="type">long</span> r9;</span><br><span class="line">  <span class="type">unsigned</span> <span class="type">long</span> r8;</span><br><span class="line">  <span class="type">unsigned</span> <span class="type">long</span> ax;</span><br><span class="line">  <span class="type">unsigned</span> <span class="type">long</span> cx;</span><br><span class="line">  <span class="type">unsigned</span> <span class="type">long</span> dx;</span><br><span class="line">  <span class="type">unsigned</span> <span class="type">long</span> si;</span><br><span class="line">  <span class="type">unsigned</span> <span class="type">long</span> di;</span><br><span class="line">  <span class="type">unsigned</span> <span class="type">long</span> orig_ax;</span><br><span class="line">  <span class="type">unsigned</span> <span class="type">long</span> ip;</span><br><span class="line">  <span class="type">unsigned</span> <span class="type">long</span> cs;</span><br><span class="line">  <span class="type">unsigned</span> <span class="type">long</span> flags;</span><br><span class="line">  <span class="type">unsigned</span> <span class="type">long</span> sp;</span><br><span class="line">  <span class="type">unsigned</span> <span class="type">long</span> ss;</span><br><span class="line"><span class="comment">/* top of stack page */</span></span><br><span class="line">&#125;;</span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br></pre></td></tr></table></figure>
<p>内核栈和task_struct是可以互相查找的，而这里就需要用到task_struct中的两个内核栈相关成员变量了。</p>
<h4 id="2-10-1-通过task-struct查找内核栈"><a href="#2-10-1-通过task-struct查找内核栈" class="headerlink" title="2.10.1 通过task_struct查找内核栈"></a>2.10.1 通过task_struct查找内核栈</h4><p>如果有一个 task_struct 的 stack 指针在手，即可通过下面的函数找到这个线程内核栈：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">static</span> <span class="keyword">inline</span> <span class="type">void</span> *<span class="title function_">task_stack_page</span><span class="params">(<span class="type">const</span> <span class="keyword">struct</span> task_struct *task)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">return</span> task-&gt;<span class="built_in">stack</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>从 task_struct 如何得到相应的 pt_regs 呢？我们可以通过下面的函数，先从 task_struct找到内核栈的开始位置。然后这个位置加上 THREAD_SIZE 就到了最后的位置，然后转换为 struct pt_regs，再减一，就相当于减少了一个 pt_regs 的位置，就到了这个结构的首地址。</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * TOP_OF_KERNEL_STACK_PADDING reserves 8 bytes on top of the ring0 stack.</span></span><br><span class="line"><span class="comment"> * This is necessary to guarantee that the entire &quot;struct pt_regs&quot;</span></span><br><span class="line"><span class="comment"> * is accessible even if the CPU haven&#x27;t stored the SS/ESP registers</span></span><br><span class="line"><span class="comment"> * on the stack (interrupt gate does not save these registers</span></span><br><span class="line"><span class="comment"> * when switching to the same priv ring).</span></span><br><span class="line"><span class="comment"> * Therefore beware: accessing the ss/esp fields of the</span></span><br><span class="line"><span class="comment"> * &quot;struct pt_regs&quot; is possible, but they may contain the</span></span><br><span class="line"><span class="comment"> * completely wrong values.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> task_pt_regs(task) \</span></span><br><span class="line"><span class="meta">(&#123;                  \</span></span><br><span class="line"><span class="meta">  unsigned long __ptr = (unsigned long)task_stack_page(task);  \</span></span><br><span class="line"><span class="meta">  __ptr += THREAD_SIZE - TOP_OF_KERNEL_STACK_PADDING;    \</span></span><br><span class="line"><span class="meta">  ((struct pt_regs *)__ptr) - 1;          \</span></span><br><span class="line"><span class="meta">&#125;)</span></span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>这里面有一个TOP_OF_KERNEL_STACK_PADDING，这个的定义如下：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">ifdef</span> CONFIG_X86_32</span></span><br><span class="line"><span class="meta"># <span class="keyword">ifdef</span> CONFIG_VM86</span></span><br><span class="line"><span class="meta">#  <span class="keyword">define</span> TOP_OF_KERNEL_STACK_PADDING 16</span></span><br><span class="line"><span class="meta"># <span class="keyword">else</span></span></span><br><span class="line"><span class="meta">#  <span class="keyword">define</span> TOP_OF_KERNEL_STACK_PADDING 8</span></span><br><span class="line"><span class="meta"># <span class="keyword">endif</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">else</span></span></span><br><span class="line"><span class="meta"># <span class="keyword">define</span> TOP_OF_KERNEL_STACK_PADDING 0</span></span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br></pre></td></tr></table></figure>

<p>也就是说，32 位机器上是 8，其他是 0。这是为什么呢？因为压栈 pt_regs 有两种情况。我们知道，CPU 用 ring 来区分权限，从而 Linux 可以区分内核态和用户态。因此，第一种情况，我们拿涉及从用户态到内核态的变化的系统调用来说。因为涉及权限的改变，会压栈保存 SS、ESP 寄存器的，这两个寄存器共占用 8 个 byte。另一种情况是，不涉及权限的变化，就不会压栈这 8 个 byte。这样就会使得两种情况不兼容。如果没有压栈还访问，就会报错，所以还不如预留在这里，保证安全。在 64 位上，修改了这个问题，变成了定长的。</p>
<h4 id="2-10-2-通过内核栈找task-struct"><a href="#2-10-2-通过内核栈找task-struct" class="headerlink" title="2.10.2 通过内核栈找task_struct"></a>2.10.2 通过内核栈找task_struct</h4><p>首先来看看thread_info的定义吧。下面所示为早期版本的thread_info和新版本thread_info的源码</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">thread_info</span> &#123;</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">task_struct</span>  *<span class="title">task</span>;</span>    <span class="comment">/* main task structure */</span></span><br><span class="line">    __u32      flags;    <span class="comment">/* low level flags */</span></span><br><span class="line">    __u32      status;    <span class="comment">/* thread synchronous flags */</span></span><br><span class="line">    __u32      cpu;    <span class="comment">/* current CPU */</span></span><br><span class="line">    <span class="type">mm_segment_t</span>    addr_limit;</span><br><span class="line">    <span class="type">unsigned</span> <span class="type">int</span>    sig_on_uaccess_error:<span class="number">1</span>;</span><br><span class="line">    <span class="type">unsigned</span> <span class="type">int</span>    uaccess_err:<span class="number">1</span>;  <span class="comment">/* uaccess failed */</span></span><br><span class="line">&#125;;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">thread_info</span> &#123;</span></span><br><span class="line">    <span class="type">unsigned</span> <span class="type">long</span> flags;          <span class="comment">/* low level flags */</span></span><br><span class="line">    <span class="type">unsigned</span> <span class="type">long</span> status;    <span class="comment">/* thread synchronous flags */</span>    </span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>老版中采取current_thread_info()-&gt;task 来获取task_struct。thread_info 的位置就是内核栈的最高位置，减去 THREAD_SIZE，就到了 thread_info 的起始地址。</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">static</span> <span class="keyword">inline</span> <span class="keyword">struct</span> thread_info *<span class="title function_">current_thread_info</span><span class="params">(<span class="type">void</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">return</span> (<span class="keyword">struct</span> thread_info *)(current_top_of_stack() - THREAD_SIZE);</span><br><span class="line">&#125;</span><br><span class="line">  而新版本则采用了另一种current_thread_info</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;asm/current.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> current_thread_info() ((struct thread_info *)current)</span></span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br></pre></td></tr></table></figure>
<p>那 current 又是什么呢？在 arch&#x2F;x86&#x2F;include&#x2F;asm&#x2F;current.h 中定义了。</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">task_struct</span>;</span></span><br><span class="line"></span><br><span class="line">DECLARE_PER_CPU(<span class="keyword">struct</span> task_struct *, current_task);</span><br><span class="line"></span><br><span class="line"><span class="type">static</span> __always_inline <span class="keyword">struct</span> task_struct *<span class="title function_">get_current</span><span class="params">(<span class="type">void</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">return</span> this_cpu_read_stable(current_task);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> current get_current</span></span><br></pre></td></tr></table></figure>
<p>新的机制里面，每个 CPU 运行的 task_struct 不通过thread_info 获取了，而是直接放在 Per CPU 变量里面了。多核情况下，CPU 是同时运行的，但是它们共同使用其他的硬件资源的时候，我们需要解决多个 CPU 之间的同步问题。Per CPU 变量是内核中一种重要的同步机制。顾名思义，Per CPU 变量就是为每个 CPU 构造一个变量的副本，这样多个 CPU 各自操作自己的副本，互不干涉。比如，当前进程的变量 current_task 就被声明为 Per CPU 变量。要使用 Per CPU 变量，首先要声明这个变量，在 arch&#x2F;x86&#x2F;include&#x2F;asm&#x2F;current.h 中有：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">DECLARE_PER_CPU(<span class="keyword">struct</span> task_struct *, current_task);</span><br></pre></td></tr></table></figure>
<p>然后是定义这个变量，在 arch&#x2F;x86&#x2F;kernel&#x2F;cpu&#x2F;common.c 中有：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">DEFINE_PER_CPU(<span class="keyword">struct</span> task_struct *, current_task) = &amp;init_task;</span><br></pre></td></tr></table></figure>
<p>也就是说，系统刚刚初始化的时候，current_task 都指向init_task。当某个 CPU 上的进程进行切换的时候，current_task 被修改为将要切换到的目标进程。例如，进程切换函数__switch_to 就会改变 current_task。</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">__visible __notrace_funcgraph <span class="class"><span class="keyword">struct</span> <span class="title">task_struct</span> *</span></span><br><span class="line"><span class="class">__<span class="title">switch_to</span>(<span class="keyword">struct</span> <span class="title">task_struct</span> *<span class="title">prev_p</span>, <span class="keyword">struct</span> <span class="title">task_struct</span> *<span class="title">next_p</span>)</span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">......</span><br><span class="line">    this_cpu_write(current_task, next_p);</span><br><span class="line">......</span><br><span class="line">    <span class="keyword">return</span> prev_p;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>当要获取当前的运行中的 task_struct 的时候，就需要调用 this_cpu_read_stable 进行读取。</p>
<pre><code>#define this_cpu_read_stable(var)       percpu_stable_op(&quot;mov&quot;, var)
</code></pre>
<p>通过这种方式，即可轻松的获得task_struct的地址。</p>
<h2 id="三-总结"><a href="#三-总结" class="headerlink" title="三. 总结"></a>三. 总结</h2><p>本文大体介绍了task_struct的整体结构，对于很多涉及到复杂模块的部分并未展开讲解，在后文中会一一叙述。</p>
<p><img src="https://user-images.githubusercontent.com/87457873/128131666-323cea04-b1ba-4812-b045-b8b6067fbc2c.png" alt="image"></p>
]]></content>
      <categories>
        <category>linux-doc 进程管理</category>
      </categories>
      <tags>
        <tag>Linux</tag>
      </tags>
  </entry>
  <entry>
    <title>进程间通信之信号</title>
    <url>/2023/01/15/linux-docs/%E8%BF%9B%E7%A8%8B%E7%AE%A1%E7%90%86/%E8%BF%9B%E7%A8%8B%E9%97%B4%E9%80%9A%E4%BF%A1%E4%B9%8B%E4%BF%A1%E5%8F%B7/</url>
    <content><![CDATA[<h2 id="一-前言"><a href="#一-前言" class="headerlink" title="一. 前言"></a>一. 前言</h2><p>  众所周知，System V IPC进程间通信机制体系中有着多种多样的进程间通信方式，如管道和有名管道，消息队列，信号，共享内存和信号量，套接字。从本文开始我们就逐个剖析进程间通信的机制和底层原理，就从信号开始讲起吧。</p>
<h2 id="二-信号基本知识"><a href="#二-信号基本知识" class="headerlink" title="二. 信号基本知识"></a>二. 信号基本知识</h2><p>  信号是进程处理紧急情况所用的一种方式，它没有特别复杂的数据结构，就是用一个代号一样的数字。Linux 提供了几十种信号，分别代表不同的意义。我们可以通过kill -l命令查看信号。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"># kill -l</span><br><span class="line"> 1) SIGHUP       2) SIGINT       3) SIGQUIT      4) SIGILL       5) SIGTRAP</span><br><span class="line"> 6) SIGABRT      7) SIGBUS       8) SIGFPE       9) SIGKILL     10) SIGUSR1</span><br><span class="line">11) SIGSEGV     12) SIGUSR2     13) SIGPIPE     14) SIGALRM     15) SIGTERM</span><br><span class="line">16) SIGSTKFLT   17) SIGCHLD     18) SIGCONT     19) SIGSTOP     20) SIGTSTP</span><br><span class="line">21) SIGTTIN     22) SIGTTOU     23) SIGURG      24) SIGXCPU     25) SIGXFSZ</span><br><span class="line">26) SIGVTALRM   27) SIGPROF     28) SIGWINCH    29) SIGIO       30) SIGPWR</span><br><span class="line">31) SIGSYS      34) SIGRTMIN    35) SIGRTMIN+1  36) SIGRTMIN+2  37) SIGRTMIN+3</span><br><span class="line">38) SIGRTMIN+4  39) SIGRTMIN+5  40) SIGRTMIN+6  41) SIGRTMIN+7  42) SIGRTMIN+8</span><br><span class="line">43) SIGRTMIN+9  44) SIGRTMIN+10 45) SIGRTMIN+11 46) SIGRTMIN+12 47) SIGRTMIN+13</span><br><span class="line">48) SIGRTMIN+14 49) SIGRTMIN+15 50) SIGRTMAX-14 51) SIGRTMAX-13 52) SIGRTMAX-12</span><br><span class="line">53) SIGRTMAX-11 54) SIGRTMAX-10 55) SIGRTMAX-9  56) SIGRTMAX-8  57) SIGRTMAX-7</span><br><span class="line">58) SIGRTMAX-6  59) SIGRTMAX-5  60) SIGRTMAX-4  61) SIGRTMAX-3  62) SIGRTMAX-2</span><br><span class="line">63) SIGRTMAX-1  64) SIGRTMAX</span><br></pre></td></tr></table></figure>

<p>信号可以在任何时候发送给某一进程，进程需要为这个信号配置信号处理函数。当某个信号发生的时候，就默认执行这个函数就可以了。通过man 7 signal可以查看各个信号的具体含义和对应的处理方法</p>
<pre><code>Signal     Value     Action   Comment
──────────────────────────────────────────────────────────────────────
SIGHUP        1       Term    Hangup detected on controlling terminal
                              or death of controlling process
SIGINT        2       Term    Interrupt from keyboard
SIGQUIT       3       Core    Quit from keyboard
SIGILL        4       Core    Illegal Instruction

SIGABRT       6       Core    Abort signal from abort(3)
SIGFPE        8       Core    Floating point exception
SIGKILL       9       Term    Kill signal
SIGSEGV      11       Core    Invalid memory reference
SIGPIPE      13       Term    Broken pipe: write to pipe with no
                              readers
SIGALRM      14       Term    Timer signal from alarm(2)
SIGTERM      15       Term    Termination signal
SIGUSR1   30,10,16    Term    User-defined signal 1
SIGUSR2   31,12,17    Term    User-defined signal 2
……
</code></pre>
<p>由上表可见，信号的处理通常分为三种：</p>
<ul>
<li>执行默认操作。Linux 对每种信号都规定了默认操作，例如上面列表中的 Term，就是终止进程的意思。Core 的意思是 Core Dump，也即终止进程后通过 Core Dump 将当前进程的运行状态保存在文件里面，方便程序员事后进行分析问题在哪里。</li>
<li>捕捉信号。我们可以为信号定义一个信号处理函数。当信号发生时，我们就执行相应的信号处理函数。</li>
<li>忽略信号。当我们不希望处理某些信号的时候，就可以忽略该信号，不做任何处理。有两个信号是应用进程无法捕捉和忽略的，即 SIGKILL 和 SEGSTOP，它们用于在任何时候中断或结束某一进程。</li>
</ul>
<h2 id="三-信号和中断"><a href="#三-信号和中断" class="headerlink" title="三. 信号和中断"></a>三. 信号和中断</h2><p>信号和中断有着诸多相似之处：</p>
<ul>
<li>均会注册处理函数</li>
<li>都是用于对当前的任务进行一些处理，如调度、停止等等</li>
</ul>
<p>但是二者实际上是有很多不同的，其不同的用途导致了运行逻辑的不同，最终在代码实现上体现出了不同的设计特点。其主要区别有：</p>
<ul>
<li>中断和信号都可能源于硬件和软件，但是中断处理函数注册于内核之中，由内核中运行，而信号的处理函数注册于用户态，内核收到信号后会根据当前任务task_struct结构体中的信号相关数据结构找寻对应的处理函数并最终在用户态处理</li>
<li>中断作用于内核全局，而信号作用于当前任务（进程）。即信号影响的往往是一个进程，而中断处理如果出现问题则会导致整个Linux内核的崩溃</li>
</ul>
<h2 id="四-注册信号处理函数"><a href="#四-注册信号处理函数" class="headerlink" title="四. 注册信号处理函数"></a>四. 注册信号处理函数</h2><p>  有些时候我们希望能够让信号运行一些特殊功能，所以有了自定义的信号处理函数。注册API主要有signal()和sigaction()两个，其中sigaction()比较推荐使用。</p>
<pre><code>typedef void (*sighandler_t)(int);
sighandler_t signal(int signum, sighandler_t handler);

int sigaction(int signum, const struct sigaction *act,
                     struct sigaction *oldact);
</code></pre>
<p>其主要区别在于sigaction()对于信号signum会绑定对应的结构体sigaction而不仅仅是一个处理函数sighandler_t。这样做的好处是可以更精细的控制信号处理，通过不同参数实现不同的效果。例如sa_flags可以设置如</p>
<ul>
<li>SA_ONESHOT：信号处理函数仅作用一次，之后启用默认行为</li>
<li>SA_NOMASK：该信号处理函数执行过程中允许被其他信号或者相同信号中断，即不屏蔽</li>
<li>SA_INTERRUPT：该信号处理函数若执行过程中被中断，则不会再调度回该函数继续执行，而是直接返回-EINTR，将执行逻辑交还给调用方</li>
<li>SA_RESTART：与SA_INTERRUPT相反，会自动重启该函数</li>
</ul>
<p>sa_restorer保存的是sa_handler 执行完毕之后，马上要执行的函数，即下一个函数地址的位置。</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">sigaction</span> &#123;</span></span><br><span class="line">    <span class="type">__sighandler_t</span> sa_handler;</span><br><span class="line">    <span class="type">unsigned</span> <span class="type">long</span> sa_flags;</span><br><span class="line">    <span class="type">__sigrestore_t</span> sa_restorer;</span><br><span class="line">    <span class="type">sigset_t</span> sa_mask;    <span class="comment">/* mask last for extensibility */</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>sigaction()也是glibc封装的函数，最终系统调用为rt_sigaction()。该函数首先将用户态的 struct sigaction 结构拷贝为内核态的 k_sigaction，然后调用 do_sigaction()设置对应的信号处理动作。</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">SYSCALL_DEFINE4(rt_sigaction, <span class="type">int</span>, sig,</span><br><span class="line">    <span class="type">const</span> <span class="keyword">struct</span> sigaction __user *, act,</span><br><span class="line">    <span class="keyword">struct</span> sigaction __user *, oact,</span><br><span class="line">    <span class="type">size_t</span>, sigsetsize)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">k_sigaction</span> <span class="title">new_sa</span>, <span class="title">old_sa</span>;</span></span><br><span class="line">    <span class="type">int</span> ret = -EINVAL;</span><br><span class="line">......</span><br><span class="line">    <span class="keyword">if</span> (act) &#123;</span><br><span class="line">      <span class="keyword">if</span> (copy_from_user(&amp;new_sa.sa, act, <span class="keyword">sizeof</span>(new_sa.sa)))</span><br><span class="line">        <span class="keyword">return</span> -EFAULT;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    ret = do_sigaction(sig, act ? &amp;new_sa : <span class="literal">NULL</span>, oact ? &amp;old_sa : <span class="literal">NULL</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (!ret &amp;&amp; oact) &#123;</span><br><span class="line">        <span class="keyword">if</span> (copy_to_user(oact, &amp;old_sa.sa, <span class="keyword">sizeof</span>(old_sa.sa)))</span><br><span class="line">            <span class="keyword">return</span> -EFAULT;</span><br><span class="line">    &#125;</span><br><span class="line">out:</span><br><span class="line">    <span class="keyword">return</span> ret;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>do_sigaction()会将用户层传来的信号处理函数赋值给当前任务task_struct currrent对应的sighand-&gt;action[]数组中sig信号对应的位置，以用于之后调用。</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">do_sigaction</span><span class="params">(<span class="type">int</span> sig, <span class="keyword">struct</span> k_sigaction *act, <span class="keyword">struct</span> k_sigaction *oact)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">task_struct</span> *<span class="title">p</span> =</span> current, *t;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">k_sigaction</span> *<span class="title">k</span>;</span></span><br><span class="line">    <span class="type">sigset_t</span> mask;</span><br><span class="line">......</span><br><span class="line">    k = &amp;p-&gt;sighand-&gt;action[sig<span class="number">-1</span>];</span><br><span class="line"></span><br><span class="line">    spin_lock_irq(&amp;p-&gt;sighand-&gt;siglock);</span><br><span class="line">    <span class="keyword">if</span> (oact)</span><br><span class="line">        *oact = *k;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (act) &#123;</span><br><span class="line">        sigdelsetmask(&amp;act-&gt;sa.sa_mask, sigmask(SIGKILL) | sigmask(SIGSTOP));</span><br><span class="line">        *k = *act;</span><br><span class="line">......</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  spin_unlock_irq(&amp;p-&gt;sighand-&gt;siglock);</span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="五-发送信号"><a href="#五-发送信号" class="headerlink" title="五. 发送信号"></a>五. 发送信号</h2><p>信号发送来源广泛，有可能来自于用户态，有可能来自于硬件，也有可能来自于内核。</p>
<ul>
<li>有时候，我们在终端输入某些组合键的时候会给进程发送信号，例如，Ctrl+C 产生 SIGINT 信号，Ctrl+Z 产生 SIGTSTP 信号。再比如， kill -9 pid 可以发送信号给一个进程，杀死它。</li>
<li>有的时候，硬件异常也会产生信号。比如，执行了除以 0 的指令，CPU 就会产生异常，然后把 SIGFPE 信号发送给进程。再如，进程访问了非法内存，内存管理模块就会产生异常，然后把信号 SIGSEGV 发送给进程。</li>
<li>有时候，内核在某些情况下，也会给进程发送信号。例如，向读端已关闭的管道写数据时产生 SIGPIPE 信号，当子进程退出时，我们要给父进程发送 SIG_CHLD 信号等。</li>
</ul>
<p>不论通过kill或者sigqueue系统调用还是通过tkill或者tgkill发送指定线程的信号，其最终调用的均是do_send_sig_info()函数，其调用链如下所示</p>
<pre><code>kill()-&gt;kill_something_info()-&gt;kill_pid_info()-&gt;group_send_sig_info()-&gt;do_send_sig_info()

tkill()-&gt;do_tkill()-&gt;do_send_specific()-&gt;do_send_sig_info()

tgkill()-&gt;do_tkill()-&gt;do_send_specific()-&gt;do_send_sig_info()

rt_sigqueueinfo()-&gt;do_rt_sigqueueinfo()-&gt;kill_proc_info()-&gt;kill_pid_info()-&gt;group_send_sig_info()-&gt;do_send_sig_info()
</code></pre>
<p>do_send_sig_info() 会调用 send_signal()，进而调用 __send_signal()。这里代码比较复杂，主要逻辑如下</p>
<ul>
<li>根据发送信号的类型判断是共享信号还是线程独享信号，由此赋值pending。如果是 kill 发送的，也就是发送给整个进程的，就应该发送给 t-&gt;signal-&gt;shared_pending，这里面是整个进程所有线程共享的信号；如果是 tkill 发送的，也就是发给某个线程的，就应该发给 t-&gt;pending，这里面是这个线程的 task_struct 独享的。</li>
<li>调用 legacy_queue()判断是否为可靠信号，不可靠则直接退出</li>
<li>调用__sigqueue_alloc() 分配一个 struct sigqueue 对象，然后通过 list_add_tail 挂在 struct sigpending 里面的链表上。</li>
<li>调用 complete_signal()分配线程处理该信号</li>
</ul>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">do_send_sig_info</span><span class="params">(<span class="type">int</span> sig, <span class="keyword">struct</span> kernel_siginfo *info, <span class="keyword">struct</span> task_struct *p,</span></span><br><span class="line"><span class="params">            <span class="keyword">enum</span> pid_type type)</span></span><br><span class="line">&#123;</span><br><span class="line">......</span><br><span class="line">    ret = send_signal(sig, info, p, type);</span><br><span class="line">......</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">static</span> <span class="type">int</span> <span class="title function_">send_signal</span><span class="params">(<span class="type">int</span> sig, <span class="keyword">struct</span> kernel_siginfo *info, <span class="keyword">struct</span> task_struct *t,</span></span><br><span class="line"><span class="params">            <span class="keyword">enum</span> pid_type type)</span></span><br><span class="line">&#123;</span><br><span class="line">......</span><br><span class="line">    <span class="keyword">return</span> __send_signal(sig, info, t, type, from_ancestor_ns);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">static</span> <span class="type">int</span> __send_signal(<span class="type">int</span> sig, <span class="keyword">struct</span> kernel_siginfo *info, <span class="keyword">struct</span> task_struct *t,</span><br><span class="line">            <span class="keyword">enum</span> pid_type type, <span class="type">int</span> from_ancestor_ns)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">sigpending</span> *<span class="title">pending</span>;</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">sigqueue</span> *<span class="title">q</span>;</span></span><br><span class="line">......</span><br><span class="line">    pending = (type != PIDTYPE_PID) ? &amp;t-&gt;signal-&gt;shared_pending : &amp;t-&gt;pending;</span><br><span class="line">......</span><br><span class="line">    <span class="keyword">if</span> (legacy_queue(pending, sig))</span><br><span class="line">        <span class="keyword">goto</span> ret;</span><br><span class="line">......</span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">     * Real-time signals must be queued if sent by sigqueue, or</span></span><br><span class="line"><span class="comment">     * some other real-time mechanism.  It is implementation</span></span><br><span class="line"><span class="comment">     * defined whether kill() does so.  We attempt to do so, on</span></span><br><span class="line"><span class="comment">     * the principle of least surprise, but since kill is not</span></span><br><span class="line"><span class="comment">     * allowed to fail with EAGAIN when low on memory we just</span></span><br><span class="line"><span class="comment">     * make sure at least one signal gets delivered and don&#x27;t</span></span><br><span class="line"><span class="comment">     * pass on the info struct.</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">if</span> (sig &lt; SIGRTMIN)</span><br><span class="line">        override_rlimit = (is_si_special(info) || info-&gt;si_code &gt;= <span class="number">0</span>);</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">        override_rlimit = <span class="number">0</span>;</span><br><span class="line">    q = __sigqueue_alloc(sig, t, GFP_ATOMIC, override_rlimit);</span><br><span class="line">    <span class="keyword">if</span> (q) &#123;</span><br><span class="line">        list_add_tail(&amp;q-&gt;<span class="built_in">list</span>, &amp;pending-&gt;<span class="built_in">list</span>);</span><br><span class="line">        <span class="keyword">switch</span> ((<span class="type">unsigned</span> <span class="type">long</span>) info) &#123;</span><br><span class="line">        <span class="keyword">case</span> (<span class="type">unsigned</span> <span class="type">long</span>) SEND_SIG_NOINFO:</span><br><span class="line">            clear_siginfo(&amp;q-&gt;info);</span><br><span class="line">            q-&gt;info.si_signo = sig;</span><br><span class="line">            q-&gt;info.si_errno = <span class="number">0</span>;</span><br><span class="line">            q-&gt;info.si_code = SI_USER;</span><br><span class="line">            q-&gt;info.si_pid = task_tgid_nr_ns(current,</span><br><span class="line">                            task_active_pid_ns(t));</span><br><span class="line">            q-&gt;info.si_uid = from_kuid_munged(current_user_ns(), current_uid());</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        <span class="keyword">case</span> (<span class="type">unsigned</span> <span class="type">long</span>) SEND_SIG_PRIV:</span><br><span class="line">            clear_siginfo(&amp;q-&gt;info);</span><br><span class="line">            q-&gt;info.si_signo = sig;</span><br><span class="line">            q-&gt;info.si_errno = <span class="number">0</span>;</span><br><span class="line">            q-&gt;info.si_code = SI_KERNEL;</span><br><span class="line">            q-&gt;info.si_pid = <span class="number">0</span>;</span><br><span class="line">            q-&gt;info.si_uid = <span class="number">0</span>;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        <span class="keyword">default</span>:</span><br><span class="line">            copy_siginfo(&amp;q-&gt;info, info);</span><br><span class="line">            <span class="keyword">if</span> (from_ancestor_ns)</span><br><span class="line">                q-&gt;info.si_pid = <span class="number">0</span>;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        userns_fixup_signal_uid(&amp;q-&gt;info, t);</span><br><span class="line">    &#125;</span><br><span class="line">......</span><br><span class="line">out_set:</span><br><span class="line">    signalfd_notify(t, sig);</span><br><span class="line">    sigaddset(&amp;pending-&gt;signal, sig);</span><br><span class="line">......</span><br><span class="line">    complete_signal(sig, t, type);</span><br><span class="line">ret:</span><br><span class="line">    trace_signal_generate(sig, info, t, type != PIDTYPE_PID, result);</span><br><span class="line">    <span class="keyword">return</span> ret;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>legacy_queue()中主要是判断是否为可靠信号，判断的依据是当信号小于 SIGRTMIN也即 32 的时候，如果我们发现这个信号已经在集合里面了，就直接退出。这里之所以前32位信号称之为不可靠信号其实是历史遗留问题，早期UNIX系统只定义了32种信号，而这些经过检验被定义为不可靠信号，主要指的是进程可能对信号做出错误的反应以及信号可能丢失：UNIX系统每次信号处理完需要重新安装信号，因此容易出现各种错误。linux也支持不可靠信号，但是对不可靠信号机制做出了改进：在调用完信号处理函数后，不必重新调用该信号的安装函数(信号安装函数是在可靠机制上是实现的)。因此，linux下的不可靠信号问题主要指的是信号可能丢失。</p>
<p>这里之所以会出现信号丢失，是因为这些信号可能会频繁快速出现。这样信号能够处理多少，和信号处理函数什么时候被调用，信号多大频率被发送，都有关系，而信号处理函数的调用时间也是不确定的，因此这种信号称之为不可靠信号。与之相对的，其他信号称之为可靠信号，支持排队执行。</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">static</span> <span class="keyword">inline</span> <span class="type">int</span> <span class="title function_">legacy_queue</span><span class="params">(<span class="keyword">struct</span> sigpending *signals, <span class="type">int</span> sig)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">return</span> (sig &lt; SIGRTMIN) &amp;&amp; sigismember(&amp;signals-&gt;signal, sig);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> SIGRTMIN  32</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> SIGRTMAX  _NSIG</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> _NSIG    64</span></span><br></pre></td></tr></table></figure>

<p>对于可靠信号我们通过__sigqueue_alloc()分配sigqueue对象，并挂载在sigpending中的链表上，最终调用complete_signal()找一个线程处理。其主要逻辑为：</p>
<ul>
<li>首先找是否有可唤醒的线程来执行，如果是主线程或者仅有一个线程，则直接从链表主队并分配</li>
<li>如果没找到可唤醒的线程，则查看当前是否有不需要唤醒的线程可以执行</li>
<li>如果没找到并且该信号为非常重要的信号如SIGKILL，则强行关闭当前线程</li>
<li>调用signal_wake_up()唤醒线程</li>
</ul>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">static</span> <span class="type">void</span> <span class="title function_">complete_signal</span><span class="params">(<span class="type">int</span> sig, <span class="keyword">struct</span> task_struct *p, <span class="keyword">enum</span> pid_type type)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">signal_struct</span> *<span class="title">signal</span> =</span> p-&gt;signal;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">task_struct</span> *<span class="title">t</span>;</span></span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">     * Now find a thread we can wake up to take the signal off the queue.</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * If the main thread wants the signal, it gets first crack.</span></span><br><span class="line"><span class="comment">     * Probably the least surprising to the average bear.</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">if</span> (wants_signal(sig, p))</span><br><span class="line">        t = p;</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span> ((type == PIDTYPE_PID) || thread_group_empty(p))</span><br><span class="line">        <span class="comment">/*</span></span><br><span class="line"><span class="comment">         * There is just one thread and it does not need to be woken.</span></span><br><span class="line"><span class="comment">         * It will dequeue unblocked signals before it runs again.</span></span><br><span class="line"><span class="comment">         */</span></span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="comment">/*</span></span><br><span class="line"><span class="comment">         * Otherwise try to find a suitable thread.</span></span><br><span class="line"><span class="comment">         */</span></span><br><span class="line">        t = signal-&gt;curr_target;</span><br><span class="line">        <span class="keyword">while</span> (!wants_signal(sig, t)) &#123;</span><br><span class="line">            t = next_thread(t);</span><br><span class="line">            <span class="keyword">if</span> (t == signal-&gt;curr_target)</span><br><span class="line">                <span class="comment">/*</span></span><br><span class="line"><span class="comment">                 * No thread needs to be woken.</span></span><br><span class="line"><span class="comment">                 * Any eligible threads will see</span></span><br><span class="line"><span class="comment">                 * the signal in the queue soon.</span></span><br><span class="line"><span class="comment">                 */</span></span><br><span class="line">                <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        signal-&gt;curr_target = t;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">     * Found a killable thread.  If the signal will be fatal,</span></span><br><span class="line"><span class="comment">     * then start taking the whole group down immediately.</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">if</span> (sig_fatal(p, sig) &amp;&amp;</span><br><span class="line">        !(signal-&gt;flags &amp; SIGNAL_GROUP_EXIT) &amp;&amp;</span><br><span class="line">        !sigismember(&amp;t-&gt;real_blocked, sig) &amp;&amp;</span><br><span class="line">        (sig == SIGKILL || !p-&gt;ptrace)) &#123;</span><br><span class="line">        <span class="comment">/*</span></span><br><span class="line"><span class="comment">         * This signal will be fatal to the whole group.</span></span><br><span class="line"><span class="comment">         */</span></span><br><span class="line">        <span class="keyword">if</span> (!sig_kernel_coredump(sig)) &#123;</span><br><span class="line">            <span class="comment">/*</span></span><br><span class="line"><span class="comment">             * Start a group exit and wake everybody up.</span></span><br><span class="line"><span class="comment">             * This way we don&#x27;t have other threads</span></span><br><span class="line"><span class="comment">             * running and doing things after a slower</span></span><br><span class="line"><span class="comment">             * thread has the fatal signal pending.</span></span><br><span class="line"><span class="comment">             */</span></span><br><span class="line">            signal-&gt;flags = SIGNAL_GROUP_EXIT;</span><br><span class="line">            signal-&gt;group_exit_code = sig;</span><br><span class="line">            signal-&gt;group_stop_count = <span class="number">0</span>;</span><br><span class="line">            t = p;</span><br><span class="line">            <span class="keyword">do</span> &#123;</span><br><span class="line">                task_clear_jobctl_pending(t, JOBCTL_PENDING_MASK);</span><br><span class="line">                sigaddset(&amp;t-&gt;pending.signal, SIGKILL);</span><br><span class="line">                signal_wake_up(t, <span class="number">1</span>);</span><br><span class="line">            &#125; while_each_thread(p, t);</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">     * The signal is already in the shared-pending queue.</span></span><br><span class="line"><span class="comment">     * Tell the chosen thread to wake up and dequeue it.</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    signal_wake_up(t, sig == SIGKILL);</span><br><span class="line">    <span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>signal_wake_up()函数主要逻辑为</p>
<ul>
<li>设置TIF_SIGPENDING标记位</li>
<li>尝试唤醒该线程&#x2F;进程</li>
</ul>
<p>信号处理的调度和任务调度类似，均是采用标记位的方式进行。当信号来的时候，内核并不直接处理这个信号，而是设置一个标识位 TIF_SIGPENDING来表示已经有信号等待处理。同样等待系统调用结束，或者中断处理结束，从内核态返回用户态的时候再进行信号的处理。</p>
<p>进程&#x2F;线程的唤醒和任务调度一样最终会调用 try_to_wake_up() ，具体逻辑就不重复分析了。如果 wake_up_state 返回 0，说明进程或者线程已经是 TASK_RUNNING 状态了，如果它在另外一个 CPU 上运行，则调用 kick_process 发送一个处理器间中断，强制那个进程或者线程重新调度，重新调度完毕后，会返回用户态运行。</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">static</span> <span class="keyword">inline</span> <span class="type">void</span> <span class="title function_">signal_wake_up</span><span class="params">(<span class="keyword">struct</span> task_struct *t, <span class="type">bool</span> resume)</span></span><br><span class="line">&#123;</span><br><span class="line">    signal_wake_up_state(t, resume ? TASK_WAKEKILL : <span class="number">0</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">signal_wake_up_state</span><span class="params">(<span class="keyword">struct</span> task_struct *t, <span class="type">unsigned</span> <span class="type">int</span> state)</span></span><br><span class="line">&#123;</span><br><span class="line">    set_tsk_thread_flag(t, TIF_SIGPENDING);</span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">     * TASK_WAKEKILL also means wake it up in the stopped/traced/killable</span></span><br><span class="line"><span class="comment">     * case. We don&#x27;t check t-&gt;state here because there is a race with it</span></span><br><span class="line"><span class="comment">     * executing another processor and just now entering stopped state.</span></span><br><span class="line"><span class="comment">     * By using wake_up_state, we ensure the process will wake up and</span></span><br><span class="line"><span class="comment">     * handle its death signal.</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">if</span> (!wake_up_state(t, state | TASK_INTERRUPTIBLE))</span><br><span class="line">        kick_process(t);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="六-信号的处理"><a href="#六-信号的处理" class="headerlink" title="六. 信号的处理"></a>六. 信号的处理</h2><p>这里我们以一个从tap 网卡中读取数据的例子来分析信号的处理逻辑。这部分涉及到了系统调用、任务调度、中断等知识，对前面的文章也算是一个回顾。从网卡读取数据会通过系统调用进入内核，之后通过函数调用表找到对应的函数执行。在读的过程中，如果没有数据处理则会调用schedule()函数主动让出CPU进入休眠状态并等待再次唤醒。</p>
<p>tap_do_read()主要逻辑为：</p>
<ul>
<li>把当前进程或者线程的状态设置为 TASK_INTERRUPTIBLE，这样才能使这个系统调用可以被中断。</li>
<li>可以被中断的系统调用往往是比较慢的调用，并且会因为数据不就绪而通过 schedule() 让出 CPU 进入等待状态。在发送信号的时候，我们除了设置这个进程和线程的 _TIF_SIGPENDING 标识位之外，还试图唤醒这个进程或者线程，也就是将它从等待状态中设置为 TASK_RUNNING。当这个进程或者线程再次运行的时候，会从 schedule() 函数中返回，然后再次进入 while 循环。由于这个进程或者线程是由信号唤醒的而不是因为数据来了而唤醒的，因而是读不到数据的，但是在 signal_pending() 函数中，我们检测到了 _TIF_SIGPENDING 标识位，这说明系统调用没有真的做完，于是返回一个错误 ERESTARTSYS，然后带着这个错误从系统调用返回。</li>
<li>如果没有信号，则继续调用schedule()让出CPU</li>
</ul>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">static</span> <span class="type">ssize_t</span> <span class="title function_">tap_do_read</span><span class="params">(<span class="keyword">struct</span> tap_queue *q,</span></span><br><span class="line"><span class="params">         <span class="keyword">struct</span> iov_iter *to,</span></span><br><span class="line"><span class="params">         <span class="type">int</span> noblock, <span class="keyword">struct</span> sk_buff *skb)</span></span><br><span class="line">&#123;</span><br><span class="line">......</span><br><span class="line">    <span class="keyword">while</span> (<span class="number">1</span>) &#123;</span><br><span class="line">        <span class="keyword">if</span> (!noblock)</span><br><span class="line">            prepare_to_wait(sk_sleep(&amp;q-&gt;sk), &amp;wait, TASK_INTERRUPTIBLE);</span><br><span class="line"></span><br><span class="line">        <span class="comment">/* Read frames from the queue */</span></span><br><span class="line">        skb = skb_array_consume(&amp;q-&gt;skb_array);</span><br><span class="line">        <span class="keyword">if</span> (skb)</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        <span class="keyword">if</span> (noblock) &#123;</span><br><span class="line">            ret = -EAGAIN;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (signal_pending(current)) &#123;</span><br><span class="line">            ret = -ERESTARTSYS;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">/* Nothing to read, let&#x27;s sleep */</span></span><br><span class="line">        schedule();</span><br><span class="line">    &#125;</span><br><span class="line">......</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>schedule()会在系统调用返回或者中断返回的时刻调用exit_to_usermode_loop()，在任务调度中标记位为_TIF_NEED_RESCHED，而对于信号来说是_TIF_SIGPENDING。</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">static</span> <span class="type">void</span> <span class="title function_">exit_to_usermode_loop</span><span class="params">(<span class="keyword">struct</span> pt_regs *regs, u32 cached_flags)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">while</span> (<span class="literal">true</span>) &#123;</span><br><span class="line">......</span><br><span class="line">        <span class="keyword">if</span> (cached_flags &amp; _TIF_NEED_RESCHED)</span><br><span class="line">            schedule();</span><br><span class="line">......</span><br><span class="line">        <span class="comment">/* deal with pending signal delivery */</span></span><br><span class="line">        <span class="keyword">if</span> (cached_flags &amp; _TIF_SIGPENDING)</span><br><span class="line">            do_signal(regs);</span><br><span class="line">......</span><br><span class="line">        <span class="keyword">if</span> (!(cached_flags &amp; EXIT_TO_USERMODE_LOOP_FLAGS))</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>do_signal()函数会调用 handle_signal()，这里主要存在一个问题使得逻辑变得较为复杂：信号处理函数定义于用户态，而调度过程位于内核态。</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * Note that &#x27;init&#x27; is a special process: it doesn&#x27;t get signals it doesn&#x27;t</span></span><br><span class="line"><span class="comment"> * want to handle. Thus you cannot kill init even with a SIGKILL even by</span></span><br><span class="line"><span class="comment"> * mistake.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">do_signal</span><span class="params">(<span class="keyword">struct</span> pt_regs *regs)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">ksignal</span> <span class="title">ksig</span>;</span></span><br><span class="line">    <span class="keyword">if</span> (get_signal(&amp;ksig)) &#123;</span><br><span class="line">        <span class="comment">/* Whee! Actually deliver the signal.  */</span></span><br><span class="line">        handle_signal(&amp;ksig, regs);</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">/* Did we come from a system call? */</span></span><br><span class="line">    <span class="keyword">if</span> (syscall_get_nr(current, regs) &gt;= <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="comment">/* Restart the system call - no handlers present */</span></span><br><span class="line">        <span class="keyword">switch</span> (syscall_get_error(current, regs)) &#123;</span><br><span class="line">        <span class="keyword">case</span> -ERESTARTNOHAND:</span><br><span class="line">        <span class="keyword">case</span> -ERESTARTSYS:</span><br><span class="line">        <span class="keyword">case</span> -ERESTARTNOINTR:</span><br><span class="line">            regs-&gt;ax = regs-&gt;orig_ax;</span><br><span class="line">            regs-&gt;ip -= <span class="number">2</span>;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        <span class="keyword">case</span> -ERESTART_RESTARTBLOCK:</span><br><span class="line">            regs-&gt;ax = get_nr_restart_syscall(regs);</span><br><span class="line">            regs-&gt;ip -= <span class="number">2</span>;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">     * If there&#x27;s no signal to deliver, we just put the saved sigmask</span></span><br><span class="line"><span class="comment">     * back.</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    restore_saved_sigmask();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>handle_signal()会判断当前是否从系统调用调度而来，当发现错误码为ERESTARTSYS的时候就知道这是从一个没有调用完的系统调用返回的，设置系统错误码为EINTR。由于此处不会直接返回任务调度前记录的用户态状态，而是进入注册好的信号处理函数，因此需要调用setup_rt_frame()构建新的寄存器结构体pt_regs。</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">static</span> <span class="type">void</span></span><br><span class="line"><span class="title function_">handle_signal</span><span class="params">(<span class="keyword">struct</span> ksignal *ksig, <span class="keyword">struct</span> pt_regs *regs)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">bool</span> stepping, failed;</span><br><span class="line">......</span><br><span class="line">    <span class="comment">/* Are we from a system call? */</span></span><br><span class="line">    <span class="keyword">if</span> (syscall_get_nr(current, regs) &gt;= <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="comment">/* If so, check system call restarting.. */</span></span><br><span class="line">        <span class="keyword">switch</span> (syscall_get_error(current, regs)) &#123;</span><br><span class="line">        <span class="keyword">case</span> -ERESTART_RESTARTBLOCK:</span><br><span class="line">        <span class="keyword">case</span> -ERESTARTNOHAND:</span><br><span class="line">            regs-&gt;ax = -EINTR;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        <span class="keyword">case</span> -ERESTARTSYS:</span><br><span class="line">            <span class="keyword">if</span> (!(ksig-&gt;ka.sa.sa_flags &amp; SA_RESTART)) &#123;</span><br><span class="line">                regs-&gt;ax = -EINTR;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        <span class="comment">/* fallthrough */</span></span><br><span class="line">        <span class="keyword">case</span> -ERESTARTNOINTR:</span><br><span class="line">            regs-&gt;ax = regs-&gt;orig_ax;</span><br><span class="line">            regs-&gt;ip -= <span class="number">2</span>;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">......</span><br><span class="line">    failed = (setup_rt_frame(ksig, regs) &lt; <span class="number">0</span>);</span><br><span class="line">......</span><br><span class="line">    signal</span><br></pre></td></tr></table></figure>

<p>setup_rt_frame()主要调用__setup_rt_frame()，主要逻辑为：</p>
<ul>
<li>调用get_sigframe()得到regs中的sp寄存器值，即原进程用户态的栈顶指针，将sp减去sizeof(struct rt_sigframe)从而把该新建栈帧压入栈</li>
<li>调用put_user_ex()，将 sa_restorer 按照函数栈的规则放到了 frame-&gt;pretcode 里面。函数栈里面包含了函数执行完跳回去的地址,当 sa_handler 执行完之后，弹出的函数栈是 frame，也就应该跳到 sa_restorer 的地址</li>
<li>调用setup_sigcontext() 里面，将原来的 pt_regs 保存在了 frame 中的 uc_mcontext 里</li>
<li>填充regs，将regs-&gt;ip设置为自定义的信号处理函数sa_handler，将栈顶regs-&gt;sp设置为新栈帧frame地址</li>
</ul>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">static</span> <span class="type">int</span></span><br><span class="line"><span class="title function_">setup_rt_frame</span><span class="params">(<span class="keyword">struct</span> ksignal *ksig, <span class="keyword">struct</span> pt_regs *regs)</span></span><br><span class="line">&#123;</span><br><span class="line">......</span><br><span class="line">        <span class="keyword">return</span> __setup_rt_frame(ksig-&gt;sig, ksig, <span class="built_in">set</span>, regs);</span><br><span class="line">......</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">static</span> <span class="type">int</span> __setup_rt_frame(<span class="type">int</span> sig, <span class="keyword">struct</span> ksignal *ksig,</span><br><span class="line">                <span class="type">sigset_t</span> *<span class="built_in">set</span>, <span class="keyword">struct</span> pt_regs *regs)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">rt_sigframe</span> __<span class="title">user</span> *<span class="title">frame</span>;</span></span><br><span class="line">    <span class="type">void</span> __user *fp = <span class="literal">NULL</span>;</span><br><span class="line">    <span class="type">int</span> err = <span class="number">0</span>;</span><br><span class="line">    frame = get_sigframe(&amp;ksig-&gt;ka, regs, <span class="keyword">sizeof</span>(<span class="keyword">struct</span> rt_sigframe), &amp;fp);</span><br><span class="line">......</span><br><span class="line">    put_user_try &#123;</span><br><span class="line">......</span><br><span class="line">        <span class="comment">/* Set up to return from userspace.  If provided, use a stub</span></span><br><span class="line"><span class="comment">           already in userspace.  */</span></span><br><span class="line">        <span class="comment">/* x86-64 should always use SA_RESTORER. */</span></span><br><span class="line">        <span class="keyword">if</span> (ksig-&gt;ka.sa.sa_flags &amp; SA_RESTORER) &#123;</span><br><span class="line">            put_user_ex(ksig-&gt;ka.sa.sa_restorer, &amp;frame-&gt;pretcode);</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="comment">/* could use a vstub here */</span></span><br><span class="line">            err |= -EFAULT;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; put_user_catch(err);</span><br><span class="line">    err |= setup_sigcontext(&amp;frame-&gt;uc.uc_mcontext, fp, regs, <span class="built_in">set</span>-&gt;sig[<span class="number">0</span>]);</span><br><span class="line">    err |= __copy_to_user(&amp;frame-&gt;uc.uc_sigmask, <span class="built_in">set</span>, <span class="keyword">sizeof</span>(*<span class="built_in">set</span>));</span><br><span class="line">    <span class="keyword">if</span> (err)</span><br><span class="line">        <span class="keyword">return</span> -EFAULT;</span><br><span class="line">    <span class="comment">/* Set up registers for signal handler */</span></span><br><span class="line">    regs-&gt;di = sig;</span><br><span class="line">    <span class="comment">/* In case the signal handler was declared without prototypes */</span></span><br><span class="line">    regs-&gt;ax = <span class="number">0</span>;</span><br><span class="line">    <span class="comment">/* This also works for non SA_SIGINFO handlers because they expect the</span></span><br><span class="line"><span class="comment">       next argument after the signal number on the stack. */</span></span><br><span class="line">    regs-&gt;si = (<span class="type">unsigned</span> <span class="type">long</span>)&amp;frame-&gt;info;</span><br><span class="line">    regs-&gt;dx = (<span class="type">unsigned</span> <span class="type">long</span>)&amp;frame-&gt;uc;</span><br><span class="line">    regs-&gt;ip = (<span class="type">unsigned</span> <span class="type">long</span>) ksig-&gt;ka.sa.sa_handler;</span><br><span class="line">    regs-&gt;sp = (<span class="type">unsigned</span> <span class="type">long</span>)frame;</span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">     * Set up the CS and SS registers to run signal handlers in</span></span><br><span class="line"><span class="comment">     * 64-bit mode, even if the handler happens to be interrupting</span></span><br><span class="line"><span class="comment">     * 32-bit or 16-bit code.</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * SS is subtle.  In 64-bit mode, we don&#x27;t need any particular</span></span><br><span class="line"><span class="comment">     * SS descriptor, but we do need SS to be valid.  It&#x27;s possible</span></span><br><span class="line"><span class="comment">     * that the old SS is entirely bogus -- this can happen if the</span></span><br><span class="line"><span class="comment">     * signal we&#x27;re trying to deliver is #GP or #SS caused by a bad</span></span><br><span class="line"><span class="comment">     * SS value.  We also have a compatbility issue here: DOSEMU</span></span><br><span class="line"><span class="comment">     * relies on the contents of the SS register indicating the</span></span><br><span class="line"><span class="comment">     * SS value at the time of the signal, even though that code in</span></span><br><span class="line"><span class="comment">     * DOSEMU predates sigreturn&#x27;s ability to restore SS.  (DOSEMU</span></span><br><span class="line"><span class="comment">     * avoids relying on sigreturn to restore SS; instead it uses</span></span><br><span class="line"><span class="comment">     * a trampoline.)  So we do our best: if the old SS was valid,</span></span><br><span class="line"><span class="comment">     * we keep it.  Otherwise we replace it.</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    regs-&gt;cs = __USER_CS;</span><br><span class="line">    <span class="keyword">if</span> (unlikely(regs-&gt;ss != __USER_DS))</span><br><span class="line">        force_valid_ss(regs);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>sa_restorer在__libc_sigaction()函数中被赋值为restore_rt，实际上调用函数调用__NR_rt_sigreturn()</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">RESTORE (restore_rt, __NR_rt_sigreturn)</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> RESTORE(name, syscall) RESTORE2 (name, syscall)</span></span><br><span class="line"><span class="meta"># <span class="keyword">define</span> RESTORE2(name, syscall) \</span></span><br><span class="line"><span class="meta">asm                                     \</span></span><br><span class="line"><span class="meta">  (                                     \</span></span><br><span class="line"><span class="meta">   <span class="string">&quot;.LSTART_&quot;</span> #name <span class="string">&quot;:\n&quot;</span>               \</span></span><br><span class="line"><span class="meta">   <span class="string">&quot;    .type __&quot;</span> #name <span class="string">&quot;,@function\n&quot;</span>  \</span></span><br><span class="line"><span class="meta">   <span class="string">&quot;__&quot;</span> #name <span class="string">&quot;:\n&quot;</span>                     \</span></span><br><span class="line"><span class="meta">   <span class="string">&quot;    movq $&quot;</span> #syscall <span class="string">&quot;, %rax\n&quot;</span>     \</span></span><br><span class="line"><span class="meta">   <span class="string">&quot;    syscall\n&quot;</span>                      \</span></span><br><span class="line"><span class="meta">......</span></span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>__NR_rt_sigreturn()对应的内核函数为sys_rt_sigreturn()，这里会调用restore_sigframe()将pt_regs恢复成原进程的栈帧状态，从而继续执行函数调用后续的内容。</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">asmlinkage <span class="type">int</span> <span class="title function_">sys_rt_sigreturn</span><span class="params">(<span class="keyword">struct</span> pt_regs *regs)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">rt_sigframe</span> __<span class="title">user</span> *<span class="title">frame</span>;</span></span><br><span class="line">    <span class="comment">/* Always make any pending restarted system calls return -EINTR */</span></span><br><span class="line">    current-&gt;restart_block.fn = do_no_restart_syscall;</span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">     * Since we stacked the signal on a 64-bit boundary,</span></span><br><span class="line"><span class="comment">     * then &#x27;sp&#x27; should be word aligned here.  If it&#x27;s</span></span><br><span class="line"><span class="comment">     * not, then the user is trying to mess with us.</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">if</span> (regs-&gt;ARM_sp &amp; <span class="number">7</span>)</span><br><span class="line">        <span class="keyword">goto</span> badframe;</span><br><span class="line">    frame = (<span class="keyword">struct</span> rt_sigframe __user *)regs-&gt;ARM_sp;</span><br><span class="line">    <span class="keyword">if</span> (!access_ok(frame, <span class="keyword">sizeof</span> (*frame)))</span><br><span class="line">        <span class="keyword">goto</span> badframe;</span><br><span class="line">    <span class="keyword">if</span> (restore_sigframe(regs, &amp;frame-&gt;sig))</span><br><span class="line">        <span class="keyword">goto</span> badframe;</span><br><span class="line">    <span class="keyword">if</span> (restore_altstack(&amp;frame-&gt;sig.uc.uc_stack))</span><br><span class="line">        <span class="keyword">goto</span> badframe;</span><br><span class="line">    <span class="keyword">return</span> regs-&gt;ARM_r0;</span><br><span class="line">badframe:</span><br><span class="line">    force_sig(SIGSEGV, current);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>信号的发送与处理是一个复杂的过程，这里来总结一下。</p>
<ul>
<li>假设我们有一个进程 A会从tap 网卡中读取数据，main 函数里面调用系统调用通过中断陷入内核。</li>
<li>按照系统调用的原理，将用户态栈的信息保存在 pt_regs 里面，也即记住原来用户态是运行到了 line A 的地方。</li>
<li>在内核中执行系统调用读取数据。</li>
<li>当发现没有什么数据可读取的时候进入睡眠状态，并且调用 schedule() 让出 CPU。</li>
<li>将进程状态设置为可中断的睡眠状态 TASK_INTERRUPTIBLE，也即如果有信号来的话是可以唤醒它的。</li>
<li>其他的进程或者 shell 通过调用 kill()、tkill()、tgkill()、rt_sigqueueinfo()发送信号。四个发送信号的函数，在内核中最终都是调用 do_send_sig_info()。</li>
<li>do_send_sig_info() 调用 send_signal() 给进程 A 发送一个信号，其实就是找到进程 A 的 task_struct，不可靠信号加入信号集合，可靠信号加入信号链表。</li>
<li>do_send_sig_info() 调用 signal_wake_up() 唤醒进程 A。</li>
<li>进程 A 重新进入运行状态 TASK_RUNNING，接着 schedule() 运行。</li>
<li>进程 A 被唤醒后检查是否有信号到来，如果没有，重新循环到一开始，尝试再次读取数据，如果还是没有数据，再次进入 TASK_INTERRUPTIBLE，即可中断的睡眠状态。</li>
<li>当发现有信号到来的时候，就返回当前正在执行的系统调用，并返回一个错误表示系统调用被中断了。</li>
<li>系统调用返回的时候，会调用 exit_to_usermode_loop()，这是一个处理信号的时机。</li>
<li>调用 do_signal() 开始处理信号。</li>
<li>根据信号得到信号处理函数 sa_handler，然后修改 pt_regs 中的用户态栈的信息让 pt_regs 指向 sa_handler，同时修改用户态的栈，插入一个栈帧 sa_restorer，里面保存了原来的指向 line A 的 pt_regs，并且设置让 sa_handler 运行完毕后跳到 sa_restorer 运行。</li>
<li>返回用户态，由于 pt_regs 已经设置为 sa_handler，则返回用户态执行 sa_handler。</li>
<li>sa_handler 执行完毕后，信号处理函数就执行完了，接着会跳到 sa_restorer 运行。</li>
<li>sa_restorer 会调用系统调用 rt_sigreturn 再次进入内核。</li>
<li>在内核中，rt_sigreturn 恢复原来的 pt_regs，重新指向 line A。</li>
<li>从 rt_sigreturn 返回用户态，还是调用 exit_to_usermode_loop()。</li>
<li>这次因为 pt_regs 已经指向 line A 了，于是就到了进程 A 中接着系统调用之后运行，当然这个系统调用返回的是它被中断了没有执行完的错误。</li>
</ul>
<p><img src="https://user-images.githubusercontent.com/87457873/128118415-42860b64-48e8-4535-9cea-2846c902f653.png" alt="image"></p>
]]></content>
      <categories>
        <category>linux-doc 进程管理</category>
      </categories>
      <tags>
        <tag>Linux</tag>
      </tags>
  </entry>
  <entry>
    <title>进程间通信之共享内存和信号量</title>
    <url>/2023/01/15/linux-docs/%E8%BF%9B%E7%A8%8B%E7%AE%A1%E7%90%86/%E8%BF%9B%E7%A8%8B%E9%97%B4%E9%80%9A%E4%BF%A1%E4%B9%8B%E5%85%B1%E4%BA%AB%E5%86%85%E5%AD%98%E5%92%8C%E4%BF%A1%E5%8F%B7%E9%87%8F/</url>
    <content><![CDATA[<h2 id="一-前言"><a href="#一-前言" class="headerlink" title="一. 前言"></a>一. 前言</h2><p>本文为进程间通信的最后一篇，介绍共享内存和信号量。之所以将二者一起叙述，是因为二者有着密不可分的关系。共享内存会利用虚拟内存和物理内存的映射关系，让不同进程开辟一块虚拟空间映射到相同的物理内存上，从而实现了两个进程对相同区域的读写，即进程间通信。而信号量则实现了互斥锁，可以为共享内存提供数据一致性的保证，因此二者常结合使用。</p>
<h2 id="二-基础知识"><a href="#二-基础知识" class="headerlink" title="二. 基础知识"></a>二. 基础知识</h2><p>共享内存的使用包括</p>
<ul>
<li>调用shmget()创建共享内存</li>
<li>调用shmat()映射共享内存至进程虚拟空间</li>
<li>调用shmdt()接触映射关系</li>
</ul>
<p>信号量有着类似的操作</p>
<ul>
<li>调用semget()创建信号量集合。</li>
<li>调用semctl()，信号量往往代表某种资源的数量，如果用信号量做互斥，那往往将信号量设置为 1。</li>
<li>调用semop()修改信号量数目，即加锁和解锁之用</li>
</ul>
<p>整体通信过程可用如下生产者消费者的模式图来理解。</p>
<p><img src="https://user-images.githubusercontent.com/87457873/128130245-0db62336-12f6-4403-9cb7-a7970bfd867e.png" alt="image"></p>
<h2 id="三-统一封装的接口"><a href="#三-统一封装的接口" class="headerlink" title="三. 统一封装的接口"></a>三. 统一封装的接口</h2><p>消息队列、共享内存和信号量有着统一的封装和管理机制，为此我们提供了对应的名字空间和ipc_ids结构体。根据代码中的定义，第 0 项用于信号量，第 1 项用于消息队列，第 2 项用于共享内存，分别可以通过 sem_ids、msg_ids、shm_ids 来访问。ipc_ids中in_use 表示当前有多少个 ipc，seq 和 next_id 用于一起生成 ipc 唯一的 id，ipcs_idr 是一棵基数树，一旦涉及从一个整数查找一个对象它都是最好的选择。</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">ipc_namespace</span> &#123;</span></span><br><span class="line">......</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">ipc_ids</span>	<span class="title">ids</span>[3];</span></span><br><span class="line">......</span><br><span class="line">&#125; __randomize_layout;</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> IPC_SEM_IDS 0</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> IPC_MSG_IDS 1</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> IPC_SHM_IDS 2</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> sem_ids(ns) ((ns)-&gt;ids[IPC_SEM_IDS])</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> msg_ids(ns) ((ns)-&gt;ids[IPC_MSG_IDS])</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> shm_ids(ns) ((ns)-&gt;ids[IPC_SHM_IDS])</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">ipc_ids</span> &#123;</span></span><br><span class="line">    <span class="type">int</span> in_use;</span><br><span class="line">    <span class="type">unsigned</span> <span class="type">short</span> seq;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">rw_semaphore</span> <span class="title">rwsem</span>;</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">idr</span> <span class="title">ipcs_idr</span>;</span></span><br><span class="line">    <span class="type">int</span> max_idx;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">rhashtable</span> <span class="title">key_ht</span>;</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">idr</span> &#123;</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">radix_tree_root</span>	<span class="title">idr_rt</span>;</span></span><br><span class="line">    <span class="type">unsigned</span> <span class="type">int</span>		idr_base;</span><br><span class="line">    <span class="type">unsigned</span> <span class="type">int</span>		idr_next;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>信号量、消息队列、共享内存的通过基数树来管理各自的对象，三种ipc对应的结构体中第一项均为struct kern_ipc_perm，该结构体对应的id会存储在基数树之中，可以通过ipc_obtain_object_idr()获取。</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">sem_array</span> &#123;</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">kern_ipc_perm</span>  <span class="title">sem_perm</span>;</span>  <span class="comment">/* permissions .. see ipc.h */</span></span><br><span class="line">......</span><br><span class="line">&#125; __randomize_layout;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">msg_queue</span> &#123;</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">kern_ipc_perm</span> <span class="title">q_perm</span>;</span></span><br><span class="line">......</span><br><span class="line">&#125; __randomize_layout;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">shmid_kernel</span> /* <span class="title">private</span> <span class="title">to</span> <span class="title">the</span> <span class="title">kernel</span> */</span></span><br><span class="line"><span class="class">&#123;</span>  </span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">kern_ipc_perm</span>  <span class="title">shm_perm</span>;</span></span><br><span class="line">......</span><br><span class="line">&#125; __randomize_layout;</span><br><span class="line"></span><br><span class="line"><span class="keyword">struct</span> kern_ipc_perm *<span class="title function_">ipc_obtain_object_idr</span><span class="params">(<span class="keyword">struct</span> ipc_ids *ids, <span class="type">int</span> id)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">kern_ipc_perm</span> *<span class="title">out</span>;</span></span><br><span class="line">    <span class="type">int</span> lid = ipcid_to_idx(id);</span><br><span class="line">    out = idr_find(&amp;ids-&gt;ipcs_idr, lid);</span><br><span class="line">    <span class="keyword">return</span> out;</span><br><span class="line">&#125;</span><br><span class="line">  对于这三种不同的通信方式，会对ipc_obtain_object_idr()进行封装</span><br><span class="line"></span><br><span class="line"><span class="type">static</span> <span class="keyword">inline</span> <span class="keyword">struct</span> sem_array *<span class="title function_">sem_obtain_object</span><span class="params">(<span class="keyword">struct</span> ipc_namespace *ns, <span class="type">int</span> id)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">kern_ipc_perm</span> *<span class="title">ipcp</span> =</span> ipc_obtain_object_idr(&amp;sem_ids(ns), id);</span><br><span class="line">    <span class="keyword">return</span> container_of(ipcp, <span class="keyword">struct</span> sem_array, sem_perm);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">static</span> <span class="keyword">inline</span> <span class="keyword">struct</span> msg_queue *<span class="title function_">msq_obtain_object</span><span class="params">(<span class="keyword">struct</span> ipc_namespace *ns, <span class="type">int</span> id)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">kern_ipc_perm</span> *<span class="title">ipcp</span> =</span> ipc_obtain_object_idr(&amp;msg_ids(ns), id);</span><br><span class="line">    <span class="keyword">return</span> container_of(ipcp, <span class="keyword">struct</span> msg_queue, q_perm);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">static</span> <span class="keyword">inline</span> <span class="keyword">struct</span> shmid_kernel *<span class="title function_">shm_obtain_object</span><span class="params">(<span class="keyword">struct</span> ipc_namespace *ns, <span class="type">int</span> id)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">kern_ipc_perm</span> *<span class="title">ipcp</span> =</span> ipc_obtain_object_idr(&amp;shm_ids(ns), id);</span><br><span class="line">    <span class="keyword">return</span> container_of(ipcp, <span class="keyword">struct</span> shmid_kernel, shm_perm);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>由此，我们实现了对这三种进程间通信方式统一的封装抽象。首先用名字空间存储三种ipc，然后对应的ipc_ids会描述该通信方式的特点，并包含一个基数树存储id从而找到其实际运行的多个通信的结构体。</p>
<p><img src="https://user-images.githubusercontent.com/87457873/128130270-237818ba-3923-469a-a97b-ce8ee2ad5b09.png" alt="image"></p>
<h2 id="四-共享内存的创建和映射"><a href="#四-共享内存的创建和映射" class="headerlink" title="四. 共享内存的创建和映射"></a>四. 共享内存的创建和映射</h2><h3 id="4-1-创建共享内存"><a href="#4-1-创建共享内存" class="headerlink" title="4.1 创建共享内存"></a>4.1 创建共享内存</h3><p>共享内存的创建通过shmget()实现。该函数创建对应的ipc_namespaace指针并指向该进程的ipc_ns，初始化共享内存对应的操作shm_ops，并将传参key, size, shmflg封装为传参shm_params，最终调用ipcget()。</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">SYSCALL_DEFINE3(shmget, <span class="type">key_t</span>, key, <span class="type">size_t</span>, size, <span class="type">int</span>, shmflg)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">ipc_namespace</span> *<span class="title">ns</span>;</span></span><br><span class="line">    <span class="type">static</span> <span class="type">const</span> <span class="class"><span class="keyword">struct</span> <span class="title">ipc_ops</span> <span class="title">shm_ops</span> =</span> &#123;</span><br><span class="line">        .getnew = newseg,</span><br><span class="line">        .associate = shm_security,</span><br><span class="line">        .more_checks = shm_more_checks,</span><br><span class="line">    &#125;;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">ipc_params</span> <span class="title">shm_params</span>;</span></span><br><span class="line">    ns = current-&gt;nsproxy-&gt;ipc_ns;</span><br><span class="line">    shm_params.key = key;</span><br><span class="line">    shm_params.flg = shmflg;</span><br><span class="line">    shm_params.u.size = size;</span><br><span class="line">    <span class="keyword">return</span> ipcget(ns, &amp;shm_ids(ns), &amp;shm_ops, &amp;shm_params);</span><br><span class="line">&#125;</span><br><span class="line">  ipcget()会根据传参key的类型是否是IPC_PRIVATE选择调用ipcget_new()创建或者调用ipcget_public()打开对应的共享内存。</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">ipcget</span><span class="params">(<span class="keyword">struct</span> ipc_namespace *ns, <span class="keyword">struct</span> ipc_ids *ids,</span></span><br><span class="line"><span class="params">            <span class="type">const</span> <span class="keyword">struct</span> ipc_ops *ops, <span class="keyword">struct</span> ipc_params *params)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">if</span> (params-&gt;key == IPC_PRIVATE)</span><br><span class="line">        <span class="keyword">return</span> ipcget_new(ns, ids, ops, params);</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">        <span class="keyword">return</span> ipcget_public(ns, ids, ops, params);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>ipcget_new()会根据定义的ops-&gt;getnew()创建新的ipc对象，即上面定义的newseg()。ipcget_public()会按照 key查找 struct kern_ipc_perm。如果没有找到，那就看是否设置了 IPC_CREAT，如果设置了，就调用ops-&gt;getnew()创建一个新的，否则返回错误ENOENT。如果找到了，就将对应的 id 返回。</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">static</span> <span class="type">int</span> <span class="title function_">ipcget_new</span><span class="params">(<span class="keyword">struct</span> ipc_namespace *ns, <span class="keyword">struct</span> ipc_ids *ids,</span></span><br><span class="line"><span class="params">        <span class="type">const</span> <span class="keyword">struct</span> ipc_ops *ops, <span class="keyword">struct</span> ipc_params *params)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">int</span> err;</span><br><span class="line">    down_write(&amp;ids-&gt;rwsem);</span><br><span class="line">    err = ops-&gt;getnew(ns, params);</span><br><span class="line">    up_write(&amp;ids-&gt;rwsem);</span><br><span class="line">    <span class="keyword">return</span> err;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">static</span> <span class="type">int</span> <span class="title function_">ipcget_public</span><span class="params">(<span class="keyword">struct</span> ipc_namespace *ns, <span class="keyword">struct</span> ipc_ids *ids,</span></span><br><span class="line"><span class="params">        <span class="type">const</span> <span class="keyword">struct</span> ipc_ops *ops, <span class="keyword">struct</span> ipc_params *params)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">kern_ipc_perm</span> *<span class="title">ipcp</span>;</span></span><br><span class="line">    <span class="type">int</span> flg = params-&gt;flg;</span><br><span class="line">    <span class="type">int</span> err;</span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">     * Take the lock as a writer since we are potentially going to add</span></span><br><span class="line"><span class="comment">     * a new entry + read locks are not &quot;upgradable&quot;</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    down_write(&amp;ids-&gt;rwsem);</span><br><span class="line">    ipcp = ipc_findkey(ids, params-&gt;key);</span><br><span class="line">    <span class="keyword">if</span> (ipcp == <span class="literal">NULL</span>) &#123;</span><br><span class="line">        <span class="comment">/* key not used */</span></span><br><span class="line">        <span class="keyword">if</span> (!(flg &amp; IPC_CREAT))</span><br><span class="line">            err = -ENOENT;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">            err = ops-&gt;getnew(ns, params);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">......</span><br><span class="line">            <span class="keyword">if</span> (!err)</span><br><span class="line">                <span class="comment">/*</span></span><br><span class="line"><span class="comment">                 * ipc_check_perms returns the IPC id on</span></span><br><span class="line"><span class="comment">                 * success</span></span><br><span class="line"><span class="comment">                 */</span></span><br><span class="line">                err = ipc_check_perms(ns, ipcp, ops, params);</span><br><span class="line">        &#125;</span><br><span class="line">        ipc_unlock(ipcp);</span><br><span class="line">    &#125;</span><br><span class="line">    up_write(&amp;ids-&gt;rwsem);</span><br><span class="line">    <span class="keyword">return</span> err;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>所以新的创建最后都会走到注册的newseg()函数。该函数主要逻辑为</p>
<ul>
<li>通过 kvmalloc() 在直接映射区分配一个 struct shmid_kernel 结构体，该结构体用于描述共享内存。</li>
<li>调用hugetlb_file_setup()或shmem_kernel_file_setup()关联文件。虚拟地址空间可以和物理内存关联，但是页表的申请条件中会避开已分配的映射，即物理内存是某个进程独享的。所以如何实现物理内存向多个进程的虚拟内存映射呢？这里就要靠文件来实现了：虚拟地址空间也可以映射到一个文件，文件是可以跨进程共享的。这里我们并不是映射到硬盘上存储的文件，而是映射到内存文件系统上的文件。这里定要注意区分 shmem 和 shm ，前者是一个文件系统，后者是进程通信机制。</li>
<li>通过 ipc_addid() 将新创建的 struct shmid_kernel 结构挂到 shm_ids 里面的基数树上，返回相应的 id，并且将 struct shmid_kernel 挂到当前进程的 sysvshm 队列中。<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * newseg - Create a new shared memory segment</span></span><br><span class="line"><span class="comment"> * @ns: namespace</span></span><br><span class="line"><span class="comment"> * @params: ptr to the structure that contains key, size and shmflg</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * Called with shm_ids.rwsem held as a writer.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="type">static</span> <span class="type">int</span> <span class="title function_">newseg</span><span class="params">(<span class="keyword">struct</span> ipc_namespace *ns, <span class="keyword">struct</span> ipc_params *params)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">key_t</span> key = params-&gt;key;</span><br><span class="line">    <span class="type">int</span> shmflg = params-&gt;flg;</span><br><span class="line">    <span class="type">size_t</span> size = params-&gt;u.size;</span><br><span class="line">    <span class="type">int</span> error;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">shmid_kernel</span> *<span class="title">shp</span>;</span></span><br><span class="line">    <span class="type">size_t</span> numpages = (size + PAGE_SIZE - <span class="number">1</span>) &gt;&gt; PAGE_SHIFT;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">file</span> *<span class="title">file</span>;</span></span><br><span class="line">    <span class="type">char</span> name[<span class="number">13</span>];</span><br><span class="line">......</span><br><span class="line">    shp = kvmalloc(<span class="keyword">sizeof</span>(*shp), GFP_KERNEL);</span><br><span class="line">......</span><br><span class="line">    shp-&gt;shm_perm.key = key;</span><br><span class="line">    shp-&gt;shm_perm.mode = (shmflg &amp; S_IRWXUGO);</span><br><span class="line">    shp-&gt;mlock_user = <span class="literal">NULL</span>;</span><br><span class="line">    shp-&gt;shm_perm.security = <span class="literal">NULL</span>;</span><br><span class="line">......</span><br><span class="line">    <span class="keyword">if</span> (shmflg &amp; SHM_HUGETLB) &#123;</span><br><span class="line">......</span><br><span class="line">        file = hugetlb_file_setup(name, hugesize, acctflag,</span><br><span class="line">                  &amp;shp-&gt;mlock_user, HUGETLB_SHMFS_INODE,</span><br><span class="line">                (shmflg &gt;&gt; SHM_HUGE_SHIFT) &amp; SHM_HUGE_MASK);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">......</span><br><span class="line">        file = shmem_kernel_file_setup(name, size, acctflag);</span><br><span class="line">    &#125;</span><br><span class="line">......</span><br><span class="line">    shp-&gt;shm_cprid = get_pid(task_tgid(current));</span><br><span class="line">    shp-&gt;shm_lprid = <span class="literal">NULL</span>;</span><br><span class="line">    shp-&gt;shm_atim = shp-&gt;shm_dtim = <span class="number">0</span>;</span><br><span class="line">    shp-&gt;shm_ctim = ktime_get_real_seconds();</span><br><span class="line">    shp-&gt;shm_segsz = size;</span><br><span class="line">    shp-&gt;shm_nattch = <span class="number">0</span>;</span><br><span class="line">    shp-&gt;shm_file = file;</span><br><span class="line">    shp-&gt;shm_creator = current;</span><br><span class="line">    <span class="comment">/* ipc_addid() locks shp upon success. */</span></span><br><span class="line">    error = ipc_addid(&amp;shm_ids(ns), &amp;shp-&gt;shm_perm, ns-&gt;shm_ctlmni);</span><br><span class="line">......</span><br><span class="line">    list_add(&amp;shp-&gt;shm_clist, &amp;current-&gt;sysvshm.shm_clist);</span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">     * shmid gets reported as &quot;inode#&quot; in /proc/pid/maps.</span></span><br><span class="line"><span class="comment">     * proc-ps tools use this. Changing this will break them.</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    file_inode(file)-&gt;i_ino = shp-&gt;shm_perm.id;</span><br><span class="line">    ns-&gt;shm_tot += numpages;</span><br><span class="line">    error = shp-&gt;shm_perm.id;</span><br><span class="line">......</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
实际上<code>shmem_kernel_file_setup()</code>会在shmem文件系统里面创建一个文件：<code>__shmem_file_setup()</code> 会创建新的 shmem 文件对应的 dentry 和 inode，并将它们两个关联起来，然后分配一个 struct file 结构来表示新的 shmem 文件，并且指向独特的 shmem_file_operations。<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * shmem_kernel_file_setup - get an unlinked file living in tmpfs which must be kernel internal.  </span></span><br><span class="line"><span class="comment"> * @name: name for dentry (to be seen in /proc/&lt;pid&gt;/maps</span></span><br><span class="line"><span class="comment"> * @size: size to be set for the file</span></span><br><span class="line"><span class="comment"> * @flags: VM_NORESERVE suppresses pre-accounting of the entire object size */</span></span><br><span class="line"><span class="keyword">struct</span> file *<span class="title function_">shmem_kernel_file_setup</span><span class="params">(<span class="type">const</span> <span class="type">char</span> *name, <span class="type">loff_t</span> size, <span class="type">unsigned</span> <span class="type">long</span> flags)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">return</span> __shmem_file_setup(name, size, flags, S_PRIVATE);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">static</span> <span class="class"><span class="keyword">struct</span> <span class="title">file</span> *__<span class="title">shmem_file_setup</span>(<span class="title">const</span> <span class="title">char</span> *<span class="title">name</span>, <span class="title">loff_t</span> <span class="title">size</span>,</span></span><br><span class="line"><span class="class">               <span class="title">unsigned</span> <span class="title">long</span> <span class="title">flags</span>, <span class="title">unsigned</span> <span class="title">int</span> <span class="title">i_flags</span>)</span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">file</span> *<span class="title">res</span>;</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">inode</span> *<span class="title">inode</span>;</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">path</span> <span class="title">path</span>;</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">super_block</span> *<span class="title">sb</span>;</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">qstr</span> <span class="title">this</span>;</span></span><br><span class="line">......</span><br><span class="line">    this.name = name;</span><br><span class="line">    this.len = <span class="built_in">strlen</span>(name);</span><br><span class="line">    this.hash = <span class="number">0</span>; <span class="comment">/* will go */</span></span><br><span class="line">    sb = shm_mnt-&gt;mnt_sb;</span><br><span class="line">    path.mnt = mntget(shm_mnt);</span><br><span class="line">    path.dentry = d_alloc_pseudo(sb, &amp;this);</span><br><span class="line">    d_set_d_op(path.dentry, &amp;anon_ops);</span><br><span class="line">......</span><br><span class="line">    inode = shmem_get_inode(sb, <span class="literal">NULL</span>, S_IFREG | S_IRWXUGO, <span class="number">0</span>, flags);</span><br><span class="line">    inode-&gt;i_flags |= i_flags;</span><br><span class="line">    d_instantiate(path.dentry, inode);</span><br><span class="line">    inode-&gt;i_size = size;</span><br><span class="line">......</span><br><span class="line">    res = alloc_file(&amp;path, FMODE_WRITE | FMODE_READ,</span><br><span class="line">        &amp;shmem_file_operations);</span><br><span class="line">    <span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br><span class="line">```  </span><br><span class="line">### <span class="number">4.2</span> 共享内存的映射</span><br><span class="line">  </span><br><span class="line">从上面的代码解析中我们知道，共享内存的数据结构 <span class="class"><span class="keyword">struct</span> <span class="title">shmid_kernel</span>通过它的成员 <span class="keyword">struct</span> <span class="title">file</span> *<span class="title">shm_file</span>来管理内存文件系统 <span class="title">shmem</span> 上的内存文件。无论这个共享内存是否被映射，<span class="title">shm_file</span> 都是存在的。</span></span><br><span class="line"><span class="class"></span></span><br><span class="line"><span class="class">对于用户来说，共享内存的映射通过调用<span class="title">shmat</span>()完成。该函数主要逻辑为：</span></span><br><span class="line"><span class="class"></span></span><br><span class="line"><span class="class">* 调用<span class="title">shm_obtain_object_check</span>()通过共享内存的 <span class="title">id</span>，在基数树中找到对应的 <span class="keyword">struct</span> <span class="title">shmid_kernel</span> 结构，通过它找到 <span class="title">shmem</span> 上的内存文件<span class="title">base</span>。</span></span><br><span class="line"><span class="class">* 分配结构体<span class="keyword">struct</span> <span class="title">shm_file_data</span> <span class="title">sfd</span>表示该内存文件<span class="title">base</span>。</span></span><br><span class="line"><span class="class">* 创建<span class="title">base</span>的备份文件<span class="title">file</span>，指向该内存文件<span class="title">base</span>，并将<span class="title">private_data</span>保存为<span class="title">sfd</span>。在源码中注释部分已经叙述了为什么要再创建一个文件而不是直接使用<span class="title">base</span>，简而言之就是<span class="title">base</span>是共享内存文件系统<span class="title">shmem</span>中的<span class="title">shm_file</span>，用于管理内存文件，是一个中立、独立于任何一个进程的文件。新创建的 <span class="keyword">struct</span> <span class="title">file</span> 则专门用于做内存映射。</span></span><br><span class="line"><span class="class">* 调用<span class="title">do_mmap_pgoff</span>()，分配<span class="title">vm_area_struct</span>指向虚拟地址空间中未分配区域，其<span class="title">vm_file</span>指向文件<span class="title">file</span>，接着调用<span class="title">shm_file_operations</span>中的<span class="title">mmap</span>()函数，即<span class="title">shm_mmap</span>()完成映射。</span></span><br><span class="line"><span class="class">```<span class="title">c</span></span></span><br><span class="line"><span class="class"><span class="title">SYSCALL_DEFINE3</span>(<span class="title">shmat</span>, <span class="title">int</span>, <span class="title">shmid</span>, <span class="title">char</span> __<span class="title">user</span> *, <span class="title">shmaddr</span>, <span class="title">int</span>, <span class="title">shmflg</span>)</span></span><br><span class="line"><span class="class">&#123;</span> </span><br><span class="line">    <span class="type">unsigned</span> <span class="type">long</span> ret; </span><br><span class="line">    <span class="type">long</span> err; </span><br><span class="line">    err = do_shmat(shmid, shmaddr, shmflg, &amp;ret, SHMLBA); </span><br><span class="line">    force_successful_syscall_return(); </span><br><span class="line">    <span class="keyword">return</span> (<span class="type">long</span>)ret;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">long</span> <span class="title function_">do_shmat</span><span class="params">(<span class="type">int</span> shmid, <span class="type">char</span> __user *shmaddr, <span class="type">int</span> shmflg,</span></span><br><span class="line"><span class="params">          ulong *raddr, <span class="type">unsigned</span> <span class="type">long</span> shmlba)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">shmid_kernel</span> *<span class="title">shp</span>;</span></span><br><span class="line">    <span class="type">unsigned</span> <span class="type">long</span> addr = (<span class="type">unsigned</span> <span class="type">long</span>)shmaddr;</span><br><span class="line">    <span class="type">unsigned</span> <span class="type">long</span> size;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">file</span> *<span class="title">file</span>, *<span class="title">base</span>;</span></span><br><span class="line">    <span class="type">int</span>    err;</span><br><span class="line">    <span class="type">unsigned</span> <span class="type">long</span> flags = MAP_SHARED;</span><br><span class="line">    <span class="type">unsigned</span> <span class="type">long</span> prot;</span><br><span class="line">    <span class="type">int</span> acc_mode;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">ipc_namespace</span> *<span class="title">ns</span>;</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">shm_file_data</span> *<span class="title">sfd</span>;</span></span><br><span class="line">    <span class="type">int</span> f_flags;</span><br><span class="line">    <span class="type">unsigned</span> <span class="type">long</span> populate = <span class="number">0</span>;</span><br><span class="line">......</span><br><span class="line">    <span class="keyword">if</span> (shmflg &amp; SHM_RDONLY) &#123;</span><br><span class="line">        prot = PROT_READ;</span><br><span class="line">        acc_mode = S_IRUGO;</span><br><span class="line">        f_flags = O_RDONLY;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        prot = PROT_READ | PROT_WRITE;</span><br><span class="line">        acc_mode = S_IRUGO | S_IWUGO;</span><br><span class="line">        f_flags = O_RDWR;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (shmflg &amp; SHM_EXEC) &#123;</span><br><span class="line">        prot |= PROT_EXEC;</span><br><span class="line">        acc_mode |= S_IXUGO;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">     * We cannot rely on the fs check since SYSV IPC does have an</span></span><br><span class="line"><span class="comment">     * additional creator id...</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    ns = current-&gt;nsproxy-&gt;ipc_ns;</span><br><span class="line">    shp = shm_obtain_object_check(ns, shmid);</span><br><span class="line">......</span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">     * We need to take a reference to the real shm file to prevent the</span></span><br><span class="line"><span class="comment">     * pointer from becoming stale in cases where the lifetime of the outer</span></span><br><span class="line"><span class="comment">     * file extends beyond that of the shm segment.  It&#x27;s not usually</span></span><br><span class="line"><span class="comment">     * possible, but it can happen during remap_file_pages() emulation as</span></span><br><span class="line"><span class="comment">     * that unmaps the memory, then does -&gt;mmap() via file reference only.</span></span><br><span class="line"><span class="comment">     * We&#x27;ll deny the -&gt;mmap() if the shm segment was since removed, but to</span></span><br><span class="line"><span class="comment">     * detect shm ID reuse we need to compare the file pointers.</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    base = get_file(shp-&gt;shm_file);</span><br><span class="line">    shp-&gt;shm_nattch++;</span><br><span class="line">    size = i_size_read(file_inode(base));</span><br><span class="line">    ipc_unlock_object(&amp;shp-&gt;shm_perm);</span><br><span class="line">    rcu_read_unlock();</span><br><span class="line">    err = -ENOMEM;</span><br><span class="line">    sfd = kzalloc(<span class="keyword">sizeof</span>(*sfd), GFP_KERNEL);</span><br><span class="line">......</span><br><span class="line">    file = alloc_file_clone(base, f_flags,</span><br><span class="line">              is_file_hugepages(base) ?</span><br><span class="line">                &amp;shm_file_operations_huge :</span><br><span class="line">                &amp;shm_file_operations);</span><br><span class="line">......</span><br><span class="line">    sfd-&gt;id = shp-&gt;shm_perm.id;</span><br><span class="line">    sfd-&gt;ns = get_ipc_ns(ns);</span><br><span class="line">    sfd-&gt;file = base;</span><br><span class="line">    sfd-&gt;vm_ops = <span class="literal">NULL</span>;</span><br><span class="line">    file-&gt;private_data = sfd;</span><br><span class="line">......</span><br><span class="line">    addr = do_mmap_pgoff(file, addr, size, prot, flags, <span class="number">0</span>, &amp;populate, <span class="literal">NULL</span>);</span><br><span class="line">    *raddr = addr;</span><br><span class="line">    err = <span class="number">0</span>;</span><br><span class="line">......</span><br><span class="line">&#125;</span><br><span class="line">  shm_mmap() 中调用了 shm_file_data 中的 file 的 mmap() 函数，这次调用的是 shmem_file_operations 的 mmap，也即 shmem_mmap()。</span><br><span class="line"></span><br><span class="line"><span class="type">static</span> <span class="type">int</span> <span class="title function_">shm_mmap</span><span class="params">(<span class="keyword">struct</span> file *file, <span class="keyword">struct</span> vm_area_struct *vma)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">shm_file_data</span> *<span class="title">sfd</span> =</span> shm_file_data(file);</span><br><span class="line">    <span class="type">int</span> ret;</span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">     * In case of remap_file_pages() emulation, the file can represent an</span></span><br><span class="line"><span class="comment">     * IPC ID that was removed, and possibly even reused by another shm</span></span><br><span class="line"><span class="comment">     * segment already.  Propagate this case as an error to caller.</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    ret = __shm_open(vma);</span><br><span class="line">    <span class="keyword">if</span> (ret)</span><br><span class="line">        <span class="keyword">return</span> ret;</span><br><span class="line">    ret = call_mmap(sfd-&gt;file, vma);</span><br><span class="line">    <span class="keyword">if</span> (ret) &#123;</span><br><span class="line">        shm_close(vma);</span><br><span class="line">        <span class="keyword">return</span> ret;</span><br><span class="line">    &#125;</span><br><span class="line">    sfd-&gt;vm_ops = vma-&gt;vm_ops;</span><br><span class="line">    vma-&gt;vm_ops = &amp;shm_vm_ops;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">static</span> <span class="type">int</span> <span class="title function_">shmem_mmap</span><span class="params">(<span class="keyword">struct</span> file *file, <span class="keyword">struct</span> vm_area_struct *vma)</span></span><br><span class="line">&#123; </span><br><span class="line">    file_accessed(file); </span><br><span class="line">    vma-&gt;vm_ops = &amp;shmem_vm_ops; </span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
这里vm_area_struct 的 vm_ops 指向 shmem_vm_ops。等从 call_mmap() 中返回之后，shm_file_data 的 vm_ops 指向了 shmem_vm_ops，而 vm_area_struct 的 vm_ops 改为指向 shm_vm_ops。<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">static</span> <span class="type">const</span> <span class="class"><span class="keyword">struct</span> <span class="title">vm_operations_struct</span> <span class="title">shm_vm_ops</span> =</span> &#123;</span><br><span class="line">    .open  = shm_open,  <span class="comment">/* callback for a new vm-area open */</span></span><br><span class="line">    .close  = shm_close,  <span class="comment">/* callback for when the vm-area is released */</span></span><br><span class="line">    .fault  = shm_fault,</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="type">static</span> <span class="type">const</span> <span class="class"><span class="keyword">struct</span> <span class="title">vm_operations_struct</span> <span class="title">shmem_vm_ops</span> =</span> &#123;</span><br><span class="line">    .fault    = shmem_fault,</span><br><span class="line">    .map_pages  = filemap_map_pages,</span><br><span class="line">&#125;;</span><br><span class="line">```  </span><br><span class="line">在前文内存映射中，我们提到了实际物理内存的分配不是在映射关系建立时就分配，而是当实际访问的时候通过缺页异常再进行分配。对于共享内存也是一样。当访问不到的时候，先调用 vm_area_struct 的 vm_ops，也即 shm_vm_ops 的 fault 函数 shm_fault()。然后它会转而调用 shm_file_data 的 vm_ops，也即 shmem_vm_ops 的 fault 函数 shmem_fault()。</span><br><span class="line">```c</span><br><span class="line"><span class="title function_">shmem_fault</span><span class="params">()</span> 会调用 <span class="title function_">shmem_getpage_gfp</span><span class="params">()</span> 在 page cache 和 swap 中找一个空闲页，如果找不到就通过 <span class="title function_">shmem_alloc_and_acct_page</span><span class="params">()</span> 分配一个新的页，他最终会调用内存管理系统的 alloc_page_vma 在物理内存中分配一个页。</span><br><span class="line"></span><br><span class="line"><span class="type">static</span> <span class="type">int</span> <span class="title function_">shm_fault</span><span class="params">(<span class="keyword">struct</span> vm_fault *vmf)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">file</span> *<span class="title">file</span> =</span> vmf-&gt;vma-&gt;vm_file;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">shm_file_data</span> *<span class="title">sfd</span> =</span> shm_file_data(file);</span><br><span class="line">    <span class="keyword">return</span> sfd-&gt;vm_ops-&gt;fault(vmf);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">static</span> <span class="type">int</span> <span class="title function_">shmem_fault</span><span class="params">(<span class="keyword">struct</span> vm_fault *vmf)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">vm_area_struct</span> *<span class="title">vma</span> =</span> vmf-&gt;vma;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">inode</span> *<span class="title">inode</span> =</span> file_inode(vma-&gt;vm_file);</span><br><span class="line">    <span class="type">gfp_t</span> gfp = mapping_gfp_mask(inode-&gt;i_mapping);</span><br><span class="line">......</span><br><span class="line">    error = shmem_getpage_gfp(inode, vmf-&gt;pgoff, &amp;vmf-&gt;page, sgp,</span><br><span class="line">          gfp, vma, vmf, &amp;ret);</span><br><span class="line">......</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * shmem_getpage_gfp - find page in cache, or get from swap, or allocate</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * If we allocate a new one we do not mark it dirty. That&#x27;s up to the</span></span><br><span class="line"><span class="comment"> * vm. If we swap it in we mark it dirty since we also free the swap</span></span><br><span class="line"><span class="comment"> * entry since a page cannot live in both the swap and page cache.</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * fault_mm and fault_type are only supplied by shmem_fault:</span></span><br><span class="line"><span class="comment"> * otherwise they are NULL.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="type">static</span> <span class="type">int</span> <span class="title function_">shmem_getpage_gfp</span><span class="params">(<span class="keyword">struct</span> inode *inode, <span class="type">pgoff_t</span> index,</span></span><br><span class="line"><span class="params">    <span class="keyword">struct</span> page **pagep, <span class="keyword">enum</span> sgp_type sgp, <span class="type">gfp_t</span> gfp,</span></span><br><span class="line"><span class="params">    <span class="keyword">struct</span> vm_area_struct *vma, <span class="keyword">struct</span> vm_fault *vmf, <span class="type">int</span> *fault_type)</span></span><br><span class="line">&#123;</span><br><span class="line">......</span><br><span class="line">    page = shmem_alloc_and_acct_page(gfp, info, sbinfo,</span><br><span class="line">          index, <span class="literal">false</span>);</span><br><span class="line">......</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
至此，共享内存才真的映射到了虚拟地址空间中，进程可以像访问本地内存一样访问共享内存。</li>
</ul>
<h2 id="五-信号量的创建和使用"><a href="#五-信号量的创建和使用" class="headerlink" title="五. 信号量的创建和使用"></a>五. 信号量的创建和使用</h2><h3 id="5-1-信号量的创建"><a href="#5-1-信号量的创建" class="headerlink" title="5.1 信号量的创建"></a>5.1 信号量的创建</h3><p>信号量的创建和共享内存类似，实际调用semget()，操作也大同小异：创建对应的ipc_namespaace指针并指向该进程的ipc_ns，初始化共享内存对应的操作sem_ops，并将传参key, size, semflg封装为传参sem_params，最终调用ipcget()。</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">SYSCALL_DEFINE3(semget, <span class="type">key_t</span>, key, <span class="type">int</span>, nsems, <span class="type">int</span>, semflg)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">ipc_namespace</span> *<span class="title">ns</span>;</span></span><br><span class="line">    <span class="type">static</span> <span class="type">const</span> <span class="class"><span class="keyword">struct</span> <span class="title">ipc_ops</span> <span class="title">sem_ops</span> =</span> &#123;</span><br><span class="line">        .getnew = newary,</span><br><span class="line">        .associate = sem_security,</span><br><span class="line">        .more_checks = sem_more_checks,</span><br><span class="line">    &#125;;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">ipc_params</span> <span class="title">sem_params</span>;</span></span><br><span class="line">    ns = current-&gt;nsproxy-&gt;ipc_ns;</span><br><span class="line">    sem_params.key = key;</span><br><span class="line">    sem_params.flg = semflg;</span><br><span class="line">    sem_params.u.nsems = nsems;</span><br><span class="line">    <span class="keyword">return</span> ipcget(ns, &amp;sem_ids(ns), &amp;sem_ops, &amp;sem_params);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>共享内存最终走到newseg()函数，而信号量则调用newary()，该函数也有着类似的逻辑：</p>
<ul>
<li>通过kvmalloc()在直接映射区分配struct sem_array结构体描述该信号量。在该结构体中会有多个信号量保存在struct sem sems[]中，通过semval表示当前信号量。</li>
<li>初始化sem_array和sems中的各个链表</li>
<li>通过ipc_addid()将创建的sem_array挂载到基数树上，并返回对应id</li>
</ul>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">static</span> <span class="type">int</span> <span class="title function_">newary</span><span class="params">(<span class="keyword">struct</span> ipc_namespace *ns, <span class="keyword">struct</span> ipc_params *params)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">int</span> retval;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">sem_array</span> *<span class="title">sma</span>;</span></span><br><span class="line">    <span class="type">key_t</span> key = params-&gt;key;</span><br><span class="line">    <span class="type">int</span> nsems = params-&gt;u.nsems;</span><br><span class="line">    <span class="type">int</span> semflg = params-&gt;flg;</span><br><span class="line">    <span class="type">int</span> i;</span><br><span class="line">......</span><br><span class="line">    sma = sem_alloc(nsems);</span><br><span class="line">......</span><br><span class="line">    sma-&gt;sem_perm.mode = (semflg &amp; S_IRWXUGO);</span><br><span class="line">    sma-&gt;sem_perm.key = key;</span><br><span class="line">    sma-&gt;sem_perm.security = <span class="literal">NULL</span>;</span><br><span class="line">......</span><br><span class="line">    <span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; nsems; i++) &#123;</span><br><span class="line">        INIT_LIST_HEAD(&amp;sma-&gt;sems[i].pending_alter);</span><br><span class="line">        INIT_LIST_HEAD(&amp;sma-&gt;sems[i].pending_const);</span><br><span class="line">        spin_lock_init(&amp;sma-&gt;sems[i].lock);</span><br><span class="line">    &#125;</span><br><span class="line">    sma-&gt;complex_count = <span class="number">0</span>;</span><br><span class="line">    sma-&gt;use_global_lock = USE_GLOBAL_LOCK_HYSTERESIS;</span><br><span class="line">    INIT_LIST_HEAD(&amp;sma-&gt;pending_alter);</span><br><span class="line">    INIT_LIST_HEAD(&amp;sma-&gt;pending_const);</span><br><span class="line">    INIT_LIST_HEAD(&amp;sma-&gt;list_id);</span><br><span class="line">    sma-&gt;sem_nsems = nsems;</span><br><span class="line">    sma-&gt;sem_ctime = ktime_get_real_seconds();</span><br><span class="line">    <span class="comment">/* ipc_addid() locks sma upon success. */</span></span><br><span class="line">    retval = ipc_addid(&amp;sem_ids(ns), &amp;sma-&gt;sem_perm, ns-&gt;sc_semmni);</span><br><span class="line">......</span><br><span class="line">    ns-&gt;used_sems += nsems;</span><br><span class="line">    sem_unlock(sma, <span class="number">-1</span>);</span><br><span class="line">    rcu_read_unlock();</span><br><span class="line">    <span class="keyword">return</span> sma-&gt;sem_perm.id;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">sem_array</span> &#123;</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">kern_ipc_perm</span>	<span class="title">sem_perm</span>;</span>	<span class="comment">/* permissions .. see ipc.h */</span></span><br><span class="line">    <span class="type">time64_t</span>		sem_ctime;	<span class="comment">/* create/last semctl() time */</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">list_head</span>	<span class="title">pending_alter</span>;</span>	<span class="comment">/* pending operations */</span></span><br><span class="line">                        <span class="comment">/* that alter the array */</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">list_head</span>	<span class="title">pending_const</span>;</span>	<span class="comment">/* pending complex operations */</span></span><br><span class="line">                        <span class="comment">/* that do not alter semvals */</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">list_head</span>	<span class="title">list_id</span>;</span>	<span class="comment">/* undo requests on this array */</span></span><br><span class="line">    <span class="type">int</span>			sem_nsems;	<span class="comment">/* no. of semaphores in array */</span></span><br><span class="line">    <span class="type">int</span>			complex_count;	<span class="comment">/* pending complex operations */</span></span><br><span class="line">    <span class="type">unsigned</span> <span class="type">int</span>		use_global_lock;<span class="comment">/* &gt;0: global lock required */</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">sem</span>		<span class="title">sems</span>[];</span></span><br><span class="line">&#125; __randomize_layout;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">sem</span> &#123;</span></span><br><span class="line">    <span class="type">int</span>	semval;		<span class="comment">/* current value */</span></span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">     * PID of the process that last modified the semaphore. For</span></span><br><span class="line"><span class="comment">     * Linux, specifically these are:</span></span><br><span class="line"><span class="comment">     *  - semop</span></span><br><span class="line"><span class="comment">     *  - semctl, via SETVAL and SETALL.</span></span><br><span class="line"><span class="comment">     *  - at task exit when performing undo adjustments (see exit_sem).</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">pid</span> *<span class="title">sempid</span>;</span></span><br><span class="line">    <span class="type">spinlock_t</span>	lock;	<span class="comment">/* spinlock for fine-grained semtimedop */</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">list_head</span> <span class="title">pending_alter</span>;</span> <span class="comment">/* pending single-sop operations */</span></span><br><span class="line">                    <span class="comment">/* that alter the semaphore */</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">list_head</span> <span class="title">pending_const</span>;</span> <span class="comment">/* pending single-sop operations */</span></span><br><span class="line">                    <span class="comment">/* that do not alter the semaphore*/</span></span><br><span class="line">    <span class="type">time64_t</span>	 sem_otime;	<span class="comment">/* candidate for sem_otime */</span></span><br><span class="line">&#125; ____cacheline_aligned_in_smp;</span><br><span class="line">```  </span><br><span class="line">### <span class="number">5.2</span> 信号量的初始化</span><br><span class="line">信号量通过semctl()实现初始化，主要使用semctl_main()和semctl_setval()函数。</span><br><span class="line">```c</span><br><span class="line"><span class="title function_">SYSCALL_DEFINE4</span><span class="params">(semctl, <span class="type">int</span>, semid, <span class="type">int</span>, semnum, <span class="type">int</span>, cmd, <span class="type">unsigned</span> <span class="type">long</span>, arg)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">int</span> version;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">ipc_namespace</span> *<span class="title">ns</span>;</span></span><br><span class="line">    <span class="type">void</span> __user *p = (<span class="type">void</span> __user *)arg;</span><br><span class="line">    ns = current-&gt;nsproxy-&gt;ipc_ns;</span><br><span class="line">    <span class="keyword">switch</span> (cmd) &#123;</span><br><span class="line">    <span class="keyword">case</span> IPC_INFO:</span><br><span class="line">    <span class="keyword">case</span> SEM_INFO:</span><br><span class="line">    <span class="keyword">case</span> IPC_STAT:</span><br><span class="line">    <span class="keyword">case</span> SEM_STAT:</span><br><span class="line">        <span class="keyword">return</span> semctl_nolock(ns, semid, cmd, version, p);</span><br><span class="line">    <span class="keyword">case</span> GETALL:</span><br><span class="line">    <span class="keyword">case</span> GETVAL:</span><br><span class="line">    <span class="keyword">case</span> GETPID:</span><br><span class="line">    <span class="keyword">case</span> GETNCNT:</span><br><span class="line">    <span class="keyword">case</span> GETZCNT:</span><br><span class="line">    <span class="keyword">case</span> SETALL:</span><br><span class="line">        <span class="keyword">return</span> semctl_main(ns, semid, semnum, cmd, p);</span><br><span class="line">    <span class="keyword">case</span> SETVAL:</span><br><span class="line">        <span class="keyword">return</span> semctl_setval(ns, semid, semnum, arg);</span><br><span class="line">    <span class="keyword">case</span> IPC_RMID:</span><br><span class="line">    <span class="keyword">case</span> IPC_SET:</span><br><span class="line">        <span class="keyword">return</span> semctl_down(ns, semid, cmd, version, p);</span><br><span class="line">    <span class="keyword">default</span>:</span><br><span class="line">        <span class="keyword">return</span> -EINVAL;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>SETALL操作调用semctl_main()，传参为 union semun 里面的 unsigned short *array，会设置整个信号量集合。semctl_main() 函数中，先是通过 sem_obtain_object_check()根据信号量集合的 id 在基数树里面找到 struct sem_array 对象，发现如果是 SETALL 操作，就将用户的参数中的 unsigned short *array 通过 copy_from_user() 拷贝到内核里面的 sem_io 数组，然后是一个循环，对于信号量集合里面的每一个信号量，设置 semval，以及修改这个信号量值的 pid。</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">static</span> <span class="type">int</span> <span class="title function_">semctl_main</span><span class="params">(<span class="keyword">struct</span> ipc_namespace *ns, <span class="type">int</span> semid, <span class="type">int</span> semnum,</span></span><br><span class="line"><span class="params">    <span class="type">int</span> cmd, <span class="type">void</span> __user *p)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">sem_array</span> *<span class="title">sma</span>;</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">sem</span> *<span class="title">curr</span>;</span></span><br><span class="line">    <span class="type">int</span> err, nsems;</span><br><span class="line">    ushort fast_sem_io[SEMMSL_FAST];</span><br><span class="line">    ushort *sem_io = fast_sem_io;</span><br><span class="line">    DEFINE_WAKE_Q(wake_q);</span><br><span class="line">    sma = sem_obtain_object_check(ns, semid);</span><br><span class="line">    nsems = sma-&gt;sem_nsems;</span><br><span class="line">......</span><br><span class="line">    <span class="keyword">switch</span> (cmd) &#123;</span><br><span class="line">......</span><br><span class="line">    <span class="keyword">case</span> SETALL:</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="type">int</span> i;</span><br><span class="line">        <span class="class"><span class="keyword">struct</span> <span class="title">sem_undo</span> *<span class="title">un</span>;</span></span><br><span class="line">......</span><br><span class="line">        <span class="keyword">if</span> (copy_from_user(sem_io, p, nsems*<span class="keyword">sizeof</span>(ushort))) &#123;</span><br><span class="line">......</span><br><span class="line">        &#125;</span><br><span class="line">......</span><br><span class="line">        <span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; nsems; i++) &#123;</span><br><span class="line">            sma-&gt;sems[i].semval = sem_io[i];</span><br><span class="line">            sma-&gt;sems[i].sempid = task_tgid_vnr(current);</span><br><span class="line">        &#125;</span><br><span class="line">......</span><br><span class="line">        sma-&gt;sem_ctime = get_seconds();</span><br><span class="line">        <span class="comment">/* maybe some queued-up processes were waiting for this */</span></span><br><span class="line">        do_smart_update(sma, <span class="literal">NULL</span>, <span class="number">0</span>, <span class="number">0</span>, &amp;wake_q);</span><br><span class="line">        err = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">goto</span> out_unlock;</span><br><span class="line">    &#125;</span><br><span class="line">    &#125;</span><br><span class="line">......</span><br><span class="line">    wake_up_q(&amp;wake_q);</span><br><span class="line">......</span><br><span class="line">&#125;</span><br><span class="line">```  </span><br><span class="line">SETVAL 操作调用semctl_setval()函数，传进来的参数 <span class="class"><span class="keyword">union</span> <span class="title">semun</span> 里面的 <span class="title">int</span> <span class="title">val</span>仅仅会设置某个信号量。在 <span class="title">semctl_setval</span>() 函数中，我们先是通过 <span class="title">sem_obtain_object_check</span>()根据信号量集合的 <span class="title">id</span> 在基数树里面找到 <span class="keyword">struct</span> <span class="title">sem_array</span> 对象，对于 <span class="title">SETVAL</span> 操作，直接根据参数中的 <span class="title">val</span> 设置 <span class="title">semval</span>，以及修改这个信号量值的 <span class="title">pid</span>。</span></span><br><span class="line"><span class="class">```<span class="title">c</span></span></span><br><span class="line"><span class="class"><span class="title">static</span> <span class="title">int</span> <span class="title">semctl_setval</span>(<span class="keyword">struct</span> <span class="title">ipc_namespace</span> *<span class="title">ns</span>, <span class="title">int</span> <span class="title">semid</span>, <span class="title">int</span> <span class="title">semnum</span>,</span></span><br><span class="line"><span class="class">    <span class="title">unsigned</span> <span class="title">long</span> <span class="title">arg</span>)</span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">sem_undo</span> *<span class="title">un</span>;</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">sem_array</span> *<span class="title">sma</span>;</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">sem</span> *<span class="title">curr</span>;</span></span><br><span class="line">    <span class="type">int</span> err, val;</span><br><span class="line">    DEFINE_WAKE_Q(wake_q);</span><br><span class="line">......</span><br><span class="line">    sma = sem_obtain_object_check(ns, semid);</span><br><span class="line">......</span><br><span class="line">    curr = &amp;sma-&gt;sems[semnum];</span><br><span class="line">......</span><br><span class="line">    curr-&gt;semval = val;</span><br><span class="line">    curr-&gt;sempid = task_tgid_vnr(current);</span><br><span class="line">    sma-&gt;sem_ctime = get_seconds();</span><br><span class="line">    <span class="comment">/* maybe some queued-up processes were waiting for this */</span></span><br><span class="line">    do_smart_update(sma, <span class="literal">NULL</span>, <span class="number">0</span>, <span class="number">0</span>, &amp;wake_q);</span><br><span class="line">......</span><br><span class="line">    wake_up_q(&amp;wake_q);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="5-3-信号量的操作"><a href="#5-3-信号量的操作" class="headerlink" title="5.3 信号量的操作"></a>5.3 信号量的操作</h3><p>信号量的操作通过semop()实现，实际调用sys_emtimedop()，最终调用为do_semtimedop()</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">SYSCALL_DEFINE3(semop, <span class="type">int</span>, semid, <span class="keyword">struct</span> sembuf __user *, tsops, <span class="type">unsigned</span>, nsops)</span><br><span class="line">&#123; </span><br><span class="line">    <span class="keyword">return</span> sys_semtimedop(semid, tsops, nsops, <span class="literal">NULL</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>do_semtimedop()是一个很较长的函数，逻辑比较复杂，主要为：</p>
<ul>
<li>调用copy_from_user()拷贝用户参数至内核态，如对信号量的操作struct sembuf。</li>
<li>如果需要进入等待状态，，则需要设置超时</li>
<li>调用sem_obtain_object_check()根据id获取对应的信号量集合sma</li>
<li>创建struct sem_queue queue表示当前信号量操作。这里之所以称之为queue是因为操作的执行不可预期，因此排在队列之中等待信号量满足条件时再调用perform_atomic_semop()实施信号量操作。</li>
<li>如果不需要等待，则说明信号量操作已完成，也改变了信号量的值。接下来，就是一个标准流程。首先通过 DEFINE_WAKE_Q(wake_q) 声明一个 wake_q，调用 do_smart_update()看这次对于信号量的值的改变可以影响并可以激活等待队列中的哪些 struct sem_queue，然后把它们都放在 wake_q 里面，调用 wake_up_q() 唤醒这些进程。</li>
<li>如果需要等待，则会根据信号量操作是对单个信号量还是整个信号量集合，将queue挂载至信号量链表pending_alter或者信号量集合的链表pending_alter中</li>
<li>进入do-while循环等待，如果没有时间限制则调用schedule()让出CPU资源，如果有则调用schedule_timeout()让出资源并过一段时间后回来。当回来的时候，判断是否等待超时，如果没有等待超时则进入下一轮循环，再次等待，如果超时则退出循环，返回错误。在让出 CPU 的时候，设置进程的状态为 TASK_INTERRUPTIBLE，并且循环的结束会通过 signal_pending 查看是否收到过信号，这说明这个等待信号量的进程是可以被信号中断的，也即一个等待信号量的进程是可以通过 kill 杀掉的。</li>
</ul>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">static</span> <span class="type">long</span> <span class="title function_">do_semtimedop</span><span class="params">(<span class="type">int</span> semid, <span class="keyword">struct</span> sembuf __user *tsops,</span></span><br><span class="line"><span class="params">        <span class="type">unsigned</span> nsops, <span class="type">const</span> <span class="keyword">struct</span> timespec64 *timeout)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">int</span> error = -EINVAL;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">sem_array</span> *<span class="title">sma</span>;</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">sembuf</span> <span class="title">fast_sops</span>[<span class="title">SEMOPM_FAST</span>];</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">sembuf</span> *<span class="title">sops</span> =</span> fast_sops, *sop;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">sem_undo</span> *<span class="title">un</span>;</span></span><br><span class="line">    <span class="type">int</span> max, locknum;</span><br><span class="line">    <span class="type">bool</span> undos = <span class="literal">false</span>, alter = <span class="literal">false</span>, dupsop = <span class="literal">false</span>;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">sem_queue</span> <span class="title">queue</span>;</span></span><br><span class="line">    <span class="type">unsigned</span> <span class="type">long</span> dup = <span class="number">0</span>, jiffies_left = <span class="number">0</span>;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">ipc_namespace</span> *<span class="title">ns</span>;</span></span><br><span class="line">    ns = current-&gt;nsproxy-&gt;ipc_ns;</span><br><span class="line">......</span><br><span class="line">    <span class="keyword">if</span> (copy_from_user(sops, tsops, nsops * <span class="keyword">sizeof</span>(*tsops))) &#123;</span><br><span class="line">        error =  -EFAULT;</span><br><span class="line">        <span class="keyword">goto</span> out_free;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (timeout) &#123;</span><br><span class="line">        <span class="keyword">if</span> (timeout-&gt;tv_sec &lt; <span class="number">0</span> || timeout-&gt;tv_nsec &lt; <span class="number">0</span> ||</span><br><span class="line">            timeout-&gt;tv_nsec &gt;= <span class="number">1000000000L</span>) &#123;</span><br><span class="line">            error = -EINVAL;</span><br><span class="line">            <span class="keyword">goto</span> out_free;</span><br><span class="line">        &#125;</span><br><span class="line">        jiffies_left = timespec64_to_jiffies(timeout);</span><br><span class="line">    &#125;</span><br><span class="line">......</span><br><span class="line">    un = find_alloc_undo(ns, semid);</span><br><span class="line">......</span><br><span class="line">    sma = sem_obtain_object_check(ns, semid);</span><br><span class="line">......</span><br><span class="line">    <span class="built_in">queue</span>.sops = sops;</span><br><span class="line">    <span class="built_in">queue</span>.nsops = nsops;</span><br><span class="line">    <span class="built_in">queue</span>.undo = un;</span><br><span class="line">    <span class="built_in">queue</span>.pid = task_tgid(current);</span><br><span class="line">    <span class="built_in">queue</span>.alter = alter;</span><br><span class="line">    <span class="built_in">queue</span>.dupsop = dupsop;</span><br><span class="line">    error = perform_atomic_semop(sma, &amp;<span class="built_in">queue</span>);</span><br><span class="line">    <span class="keyword">if</span> (error == <span class="number">0</span>) &#123; <span class="comment">/* non-blocking succesfull path */</span></span><br><span class="line">        DEFINE_WAKE_Q(wake_q);</span><br><span class="line">        <span class="comment">/*</span></span><br><span class="line"><span class="comment">         * If the operation was successful, then do</span></span><br><span class="line"><span class="comment">         * the required updates.</span></span><br><span class="line"><span class="comment">         */</span></span><br><span class="line">        <span class="keyword">if</span> (alter)</span><br><span class="line">            do_smart_update(sma, sops, nsops, <span class="number">1</span>, &amp;wake_q);</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">            set_semotime(sma, sops);</span><br><span class="line">......</span><br><span class="line">    &#125;</span><br><span class="line">......</span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">     * We need to sleep on this operation, so we put the current</span></span><br><span class="line"><span class="comment">     * task into the pending queue and go to sleep.</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">if</span> (nsops == <span class="number">1</span>) &#123;</span><br><span class="line">        <span class="class"><span class="keyword">struct</span> <span class="title">sem</span> *<span class="title">curr</span>;</span></span><br><span class="line">        <span class="type">int</span> idx = array_index_nospec(sops-&gt;sem_num, sma-&gt;sem_nsems);</span><br><span class="line">        curr = &amp;sma-&gt;sems[idx];</span><br><span class="line">        <span class="keyword">if</span> (alter) &#123;</span><br><span class="line">            <span class="keyword">if</span> (sma-&gt;complex_count) &#123;</span><br><span class="line">                list_add_tail(&amp;<span class="built_in">queue</span>.<span class="built_in">list</span>,</span><br><span class="line">                        &amp;sma-&gt;pending_alter);</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                list_add_tail(&amp;<span class="built_in">queue</span>.<span class="built_in">list</span>,</span><br><span class="line">                        &amp;curr-&gt;pending_alter);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            list_add_tail(&amp;<span class="built_in">queue</span>.<span class="built_in">list</span>, &amp;curr-&gt;pending_const);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (!sma-&gt;complex_count)</span><br><span class="line">            merge_queues(sma);</span><br><span class="line">        <span class="keyword">if</span> (alter)</span><br><span class="line">            list_add_tail(&amp;<span class="built_in">queue</span>.<span class="built_in">list</span>, &amp;sma-&gt;pending_alter);</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">            list_add_tail(&amp;<span class="built_in">queue</span>.<span class="built_in">list</span>, &amp;sma-&gt;pending_const);</span><br><span class="line">        sma-&gt;complex_count++;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">do</span> &#123;</span><br><span class="line">        WRITE_ONCE(<span class="built_in">queue</span>.status, -EINTR);</span><br><span class="line">        <span class="built_in">queue</span>.sleeper = current;</span><br><span class="line">        __set_current_state(TASK_INTERRUPTIBLE);</span><br><span class="line">......</span><br><span class="line">        <span class="keyword">if</span> (timeout)</span><br><span class="line">            jiffies_left = schedule_timeout(jiffies_left);</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">            schedule();</span><br><span class="line">......</span><br><span class="line">        <span class="comment">/*</span></span><br><span class="line"><span class="comment">         * If an interrupt occurred we have to clean up the queue.</span></span><br><span class="line"><span class="comment">         */</span></span><br><span class="line">        <span class="keyword">if</span> (timeout &amp;&amp; jiffies_left == <span class="number">0</span>)</span><br><span class="line">            error = -EAGAIN;</span><br><span class="line">    &#125; <span class="keyword">while</span> (error == -EINTR &amp;&amp; !signal_pending(current)); <span class="comment">/* spurious */</span></span><br><span class="line">......</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>do_smart_update() 会调用 update_queue()，update_queue() 会依次循环整个信号量集合的等待队列 pending_alter或者某个信号量的等待队列，试图在信号量的值变了的情况下，再次尝试 perform_atomic_semop 进行信号量操作。如果不成功，则尝试队列中的下一个；如果尝试成功，则调用 unlink_queue() 从队列上取下来，然后调用 wake_up_sem_queue_prepare()将 q-&gt;sleeper 加到 wake_q 上去。q-&gt;sleeper 是一个 task_struct，是等待在这个信号量操作上的进程。</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">static</span> <span class="type">int</span> <span class="title function_">update_queue</span><span class="params">(<span class="keyword">struct</span> sem_array *sma, <span class="type">int</span> semnum, <span class="keyword">struct</span> wake_q_head *wake_q)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">sem_queue</span> *<span class="title">q</span>, *<span class="title">tmp</span>;</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">list_head</span> *<span class="title">pending_list</span>;</span></span><br><span class="line">    <span class="type">int</span> semop_completed = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (semnum == <span class="number">-1</span>)</span><br><span class="line">        pending_list = &amp;sma-&gt;pending_alter;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">        pending_list = &amp;sma-&gt;sems[semnum].pending_alter;</span><br><span class="line"></span><br><span class="line">again:</span><br><span class="line">    list_for_each_entry_safe(q, tmp, pending_list, <span class="built_in">list</span>) &#123;</span><br><span class="line">        <span class="type">int</span> error, restart;</span><br><span class="line">......</span><br><span class="line">        error = perform_atomic_semop(sma, q);</span><br><span class="line"></span><br><span class="line">        <span class="comment">/* Does q-&gt;sleeper still need to sleep? */</span></span><br><span class="line">        <span class="keyword">if</span> (error &gt; <span class="number">0</span>)</span><br><span class="line">            <span class="keyword">continue</span>;</span><br><span class="line"></span><br><span class="line">        unlink_queue(sma, q);</span><br><span class="line">......</span><br><span class="line">        wake_up_sem_queue_prepare(q, error, wake_q);</span><br><span class="line">......</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> semop_completed;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">static</span> <span class="keyword">inline</span> <span class="type">void</span> <span class="title function_">wake_up_sem_queue_prepare</span><span class="params">(<span class="keyword">struct</span> sem_queue *q, <span class="type">int</span> error,</span></span><br><span class="line"><span class="params">               <span class="keyword">struct</span> wake_q_head *wake_q)</span></span><br><span class="line">&#123;</span><br><span class="line">    wake_q_add(wake_q, q-&gt;sleeper);</span><br><span class="line">......</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>接下来wake_up_q 就依次唤醒 wake_q 上的所有 task_struct，调用的是进程调度中分析过的 wake_up_process()方法。</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">wake_up_q</span><span class="params">(<span class="keyword">struct</span> wake_q_head *head)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">wake_q_node</span> *<span class="title">node</span> =</span> head-&gt;first;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span> (node != WAKE_Q_TAIL) &#123;</span><br><span class="line">        <span class="class"><span class="keyword">struct</span> <span class="title">task_struct</span> *<span class="title">task</span>;</span></span><br><span class="line"></span><br><span class="line">        task = container_of(node, <span class="keyword">struct</span> task_struct, wake_q);</span><br><span class="line"></span><br><span class="line">        node = node-&gt;next;</span><br><span class="line">        task-&gt;wake_q.next = <span class="literal">NULL</span>;</span><br><span class="line"></span><br><span class="line">        wake_up_process(task);</span><br><span class="line">        put_task_struct(task);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>perform_atomic_semop() 函数对于所有信号量操作都进行两次循环。在第一次循环中，如果发现计算出的 result 小于 0，则说明必须等待，于是跳到 would_block 中，设置 q-&gt;blocking &#x3D; sop 表示这个 queue 是 block 在这个操作上，然后如果需要等待，则返回 1。如果第一次循环中发现无需等待，则第二个循环实施所有的信号量操作，将信号量的值设置为新的值，并且返回 0。</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">static</span> <span class="type">int</span> <span class="title function_">perform_atomic_semop</span><span class="params">(<span class="keyword">struct</span> sem_array *sma, <span class="keyword">struct</span> sem_queue *q)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">int</span> result, sem_op, nsops;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">sembuf</span> *<span class="title">sop</span>;</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">sem</span> *<span class="title">curr</span>;</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">sembuf</span> *<span class="title">sops</span>;</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">sem_undo</span> *<span class="title">un</span>;</span></span><br><span class="line"></span><br><span class="line">    sops = q-&gt;sops;</span><br><span class="line">    nsops = q-&gt;nsops;</span><br><span class="line">    un = q-&gt;undo;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (sop = sops; sop &lt; sops + nsops; sop++) &#123;</span><br><span class="line">        curr = &amp;sma-&gt;sems[sop-&gt;sem_num];</span><br><span class="line">        sem_op = sop-&gt;sem_op;</span><br><span class="line">        result = curr-&gt;semval;</span><br><span class="line">......</span><br><span class="line">        result += sem_op;</span><br><span class="line">        <span class="keyword">if</span> (result &lt; <span class="number">0</span>)</span><br><span class="line">            <span class="keyword">goto</span> would_block;</span><br><span class="line">......</span><br><span class="line">        <span class="keyword">if</span> (sop-&gt;sem_flg &amp; SEM_UNDO) &#123;</span><br><span class="line">            <span class="type">int</span> undo = un-&gt;semadj[sop-&gt;sem_num] - sem_op;</span><br><span class="line">.....</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (sop = sops; sop &lt; sops + nsops; sop++) &#123;</span><br><span class="line">        curr = &amp;sma-&gt;sems[sop-&gt;sem_num];</span><br><span class="line">        sem_op = sop-&gt;sem_op;</span><br><span class="line">        result = curr-&gt;semval;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (sop-&gt;sem_flg &amp; SEM_UNDO) &#123;</span><br><span class="line">            <span class="type">int</span> undo = un-&gt;semadj[sop-&gt;sem_num] - sem_op;</span><br><span class="line">            un-&gt;semadj[sop-&gt;sem_num] = undo;</span><br><span class="line">        &#125;</span><br><span class="line">        curr-&gt;semval += sem_op;</span><br><span class="line">        curr-&gt;sempid = q-&gt;pid;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">would_block:</span><br><span class="line">    q-&gt;blocking = sop;</span><br><span class="line">    <span class="keyword">return</span> sop-&gt;sem_flg &amp; IPC_NOWAIT ? -EAGAIN : <span class="number">1</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="5-4-SEM-UNDO机制"><a href="#5-4-SEM-UNDO机制" class="headerlink" title="5.4 SEM_UNDO机制"></a>5.4 SEM_UNDO机制</h3><p>信号量是整个 Linux 可见的全局资源，而不是某个进程独占的资源，好处是可以跨进程通信，坏处就是如果一个进程通过操作拿到了一个信号量，但是不幸异常退出了，如果没有来得及归还这个信号量，可能所有其他的进程都阻塞了。为此，Linux设计了SEM_UNDO机制解决该问题。</p>
<p>该机制简而言之就是每一个 semop 操作都会保存一个反向 struct sem_undo 操作，当因为某个进程异常退出的时候，这个进程做的所有的操作都会回退，从而保证其他进程可以正常工作。在sem_flg标记位设置SUM_UNDO即可开启该功能。</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">sem_queue</span> &#123;</span></span><br><span class="line">......</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">sem_undo</span>    *<span class="title">undo</span>;</span>   <span class="comment">/* undo structure */</span></span><br><span class="line">......</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>  在进程的 task_struct 里面对于信号量有一个成员 struct sysv_sem，里面是一个 struct sem_undo_list将这个进程所有的 semop 所带来的 undo 操作都串起来。</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">task_struct</span> &#123;</span></span><br><span class="line">......</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">sysv_sem</span>      <span class="title">sysvsem</span>;</span></span><br><span class="line">......</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">sysv_sem</span> &#123;</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">sem_undo_list</span> *<span class="title">undo_list</span>;</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">sem_undo</span> &#123;</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">list_head</span>  <span class="title">list_proc</span>;</span>  <span class="comment">/* per-process list: *</span></span><br><span class="line"><span class="comment">                                   * all undos from one process</span></span><br><span class="line"><span class="comment">                                   * rcu protected */</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">rcu_head</span>    <span class="title">rcu</span>;</span>       <span class="comment">/* rcu struct for sem_undo */</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">sem_undo_list</span>  *<span class="title">ulp</span>;</span>   <span class="comment">/* back ptr to sem_undo_list */</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">list_head</span>  <span class="title">list_id</span>;</span>    <span class="comment">/* per semaphore array list:</span></span><br><span class="line"><span class="comment">                                   * all undos for one array */</span></span><br><span class="line">    <span class="type">int</span>      semid;               <span class="comment">/* semaphore set identifier */</span></span><br><span class="line">    <span class="type">short</span>      *semadj;           <span class="comment">/* array of adjustments */</span></span><br><span class="line">                                  <span class="comment">/* one per semaphore */</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">sem_undo_list</span> &#123;</span></span><br><span class="line">    <span class="type">atomic_t</span>    refcnt;</span><br><span class="line">    <span class="type">spinlock_t</span>    lock;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">list_head</span>  <span class="title">list_proc</span>;</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>这种设计思想较为常见，在MySQL的innodb的日志系统中也有着类似的实现。</p>
<h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>共享内存和信号量是有着相似性有可以共同使用从而完成进程通信的手段。下面引用极客时间中的两幅图来总结二者的整个过程。</p>
<p><img src="https://user-images.githubusercontent.com/87457873/128130352-475c7ec7-e6d9-4dc2-b8dd-f1e5086d5fdd.png" alt="image"></p>
<p><img src="https://user-images.githubusercontent.com/87457873/128130345-26d8d420-1a10-4f02-8b6e-5fd26822f788.png" alt="image"></p>
]]></content>
      <categories>
        <category>linux-doc 进程管理</category>
      </categories>
      <tags>
        <tag>Linux</tag>
      </tags>
  </entry>
  <entry>
    <title>进程间通信之管道</title>
    <url>/2023/01/15/linux-docs/%E8%BF%9B%E7%A8%8B%E7%AE%A1%E7%90%86/%E8%BF%9B%E7%A8%8B%E9%97%B4%E9%80%9A%E4%BF%A1%E4%B9%8B%E7%AE%A1%E9%81%93/</url>
    <content><![CDATA[<h2 id="一-前言"><a href="#一-前言" class="headerlink" title="一. 前言"></a>一. 前言</h2><p>上文中我们介绍了进程间通信的方法之一：信号，本文将继续介绍另一种进程间通信的方法，即管道。管道是Linux中使用shell经常用到的一个技术，本文将深入剖析管道的实现和运行逻辑。</p>
<h2 id="二-管道简介"><a href="#二-管道简介" class="headerlink" title="二. 管道简介"></a>二. 管道简介</h2><p>在Linux的日常使用中，我们常常会用到管道，如下所示</p>
<pre><code>ps -ef | grep 关键字 | awk &#39;&#123;print $2&#125;&#39; | xargs kill -9
</code></pre>
<p>这里面的竖线|就是一个管道。它会将前一个命令的输出，作为后一个命令的输入。从管道的这个名称可以看出来，管道是一种单向传输数据的机制，它其实是一段缓存，里面的数据只能从一端写入，从另一端读出。如果想互相通信，我们需要创建两个管道才行。</p>
<p>管道分为两种类型，| 表示的管道称为匿名管道，意思就是这个类型的管道没有名字，用完了就销毁了。就像上面那个命令里面的一样，竖线代表的管道随着命令的执行自动创建、自动销毁。用户甚至都不知道自己在用管道这种技术，就已经解决了问题。另外一种类型是命名管道。这个类型的管道需要通过 mkfifo 命令显式地创建。</p>
<pre><code>mkfifo hello
</code></pre>
<p>我们可以往管道里面写入东西。例如，写入一个字符串。</p>
<pre><code># echo &quot;hello world&quot; &gt; hello
</code></pre>
<p>这个时候管道里面的内容没有被读出，这个命令就会停在这里。这个时候，我们就需要重新连接一个终端。在终端中用下面的命令读取管道里面的内容：</p>
<pre><code># cat &lt; hello hello world
</code></pre>
<p>一方面，我们能够看到，管道里面的内容被读取出来，打印到了终端上；另一方面，echo 那个命令正常退出了。这就是有名管道的执行流程。</p>
<h2 id="三-匿名管道创建"><a href="#三-匿名管道创建" class="headerlink" title="三. 匿名管道创建"></a>三. 匿名管道创建</h2><p>实际管道的创建调用的是系统调用pipe()，该函数建了一个管道 pipe，返回了两个文件描述符，这表示管道的两端，一个是管道的读取端描述符 fd[0]，另一个是管道的写入端描述符 fd[1]。</p>
<pre><code>int pipe(int fd[2])
</code></pre>
<p>其内核实现如下所示，pipe2 ()调用 __do_pipe_flags() 创建一个数组 files来存放管道的两端的打开文件，另一个数组 fd 存放管道的两端的文件描述符。如果 __do_pipe_flags() 没有错误，那就调用 fd_install()将两个 fd 和两个 struct file 关联起来，这一点和打开一个文件的过程类似。</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">SYSCALL_DEFINE1(pipe, <span class="type">int</span> __user *, fildes)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">return</span> sys_pipe2(fildes, <span class="number">0</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">SYSCALL_DEFINE2(pipe2, <span class="type">int</span> __user *, fildes, <span class="type">int</span>, flags)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">file</span> *<span class="title">files</span>[2];</span></span><br><span class="line">    <span class="type">int</span> fd[<span class="number">2</span>];</span><br><span class="line">    <span class="type">int</span> error;</span><br><span class="line"></span><br><span class="line">    error = __do_pipe_flags(fd, files, flags);</span><br><span class="line">    <span class="keyword">if</span> (!error) &#123;</span><br><span class="line">        <span class="keyword">if</span> (unlikely(copy_to_user(fildes, fd, <span class="keyword">sizeof</span>(fd)))) &#123;</span><br><span class="line">......</span><br><span class="line">            error = -EFAULT;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            fd_install(fd[<span class="number">0</span>], files[<span class="number">0</span>]);</span><br><span class="line">            fd_install(fd[<span class="number">1</span>], files[<span class="number">1</span>]);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> error;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>__do_pipe_flags()调用了create_pipe_files()生成fd，然后调用get_unused_fd_flags()赋值fdr和fdw，即读文件描述符和写文件描述符。由此也可以看出管道的特性：由一端写入，由另一端读出。</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">static</span> <span class="type">int</span> __do_pipe_flags(<span class="type">int</span> *fd, <span class="keyword">struct</span> file **files, <span class="type">int</span> flags)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">int</span> error;</span><br><span class="line">    <span class="type">int</span> fdw, fdr;</span><br><span class="line">......</span><br><span class="line">    error = create_pipe_files(files, flags);</span><br><span class="line">......</span><br><span class="line">    error = get_unused_fd_flags(flags);</span><br><span class="line">......</span><br><span class="line">    fdr = error;</span><br><span class="line">    error = get_unused_fd_flags(flags);</span><br><span class="line">......</span><br><span class="line">    fdw = error;</span><br><span class="line">    audit_fd_pair(fdr, fdw);</span><br><span class="line">    fd[<span class="number">0</span>] = fdr;</span><br><span class="line">    fd[<span class="number">1</span>] = fdw;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">......</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>create_pipe_files()是管道创建的关键逻辑，从这里可以看出来管道实际上也是一种抽象的文件系统pipefs，有着对应的特殊文件以及inode。这里首先通过get_pipe_inode()获取特殊inode，然后调用alloc_file_pseudo()通过inode以及对应的挂载结构体pipe_mnt，文件操作结构体pipefifo_fops创建关联的dentry并以此创建文件结构体并分配内存，通过alloc_file_clone()创建一份新的file后将两个文件分别保存在res[0]和res[1]中。</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">create_pipe_files</span><span class="params">(<span class="keyword">struct</span> file **res, <span class="type">int</span> flags)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">inode</span> *<span class="title">inode</span> =</span> get_pipe_inode();</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">file</span> *<span class="title">f</span>;</span></span><br><span class="line">    <span class="keyword">if</span> (!inode)</span><br><span class="line">        <span class="keyword">return</span> -ENFILE;</span><br><span class="line">    f = alloc_file_pseudo(inode, pipe_mnt, <span class="string">&quot;&quot;</span>,</span><br><span class="line">                O_WRONLY | (flags &amp; (O_NONBLOCK | O_DIRECT)),</span><br><span class="line">                &amp;pipefifo_fops);</span><br><span class="line">    <span class="keyword">if</span> (IS_ERR(f)) &#123;</span><br><span class="line">        free_pipe_info(inode-&gt;i_pipe);</span><br><span class="line">        iput(inode);</span><br><span class="line">        <span class="keyword">return</span> PTR_ERR(f);</span><br><span class="line">    &#125;</span><br><span class="line">    f-&gt;private_data = inode-&gt;i_pipe;</span><br><span class="line">    res[<span class="number">0</span>] = alloc_file_clone(f, O_RDONLY | (flags &amp; O_NONBLOCK),</span><br><span class="line">                  &amp;pipefifo_fops);</span><br><span class="line">    <span class="keyword">if</span> (IS_ERR(res[<span class="number">0</span>])) &#123;</span><br><span class="line">        put_pipe_info(inode, inode-&gt;i_pipe);</span><br><span class="line">        fput(f);</span><br><span class="line">        <span class="keyword">return</span> PTR_ERR(res[<span class="number">0</span>]);</span><br><span class="line">    &#125;</span><br><span class="line">    res[<span class="number">0</span>]-&gt;private_data = inode-&gt;i_pipe;</span><br><span class="line">    res[<span class="number">1</span>] = f;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>其虚拟文件系统pipefs对应的结构体和操作如下：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">static</span> <span class="class"><span class="keyword">struct</span> <span class="title">file_system_type</span> <span class="title">pipe_fs_type</span> =</span> &#123;</span><br><span class="line">  .name    = <span class="string">&quot;pipefs&quot;</span>,</span><br><span class="line">  .mount    = pipefs_mount,</span><br><span class="line">  .kill_sb  = kill_anon_super,</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="type">static</span> <span class="type">int</span> __init <span class="title function_">init_pipe_fs</span><span class="params">(<span class="type">void</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">int</span> err = register_filesystem(&amp;pipe_fs_type);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (!err) &#123;</span><br><span class="line">        pipe_mnt = kern_mount(&amp;pipe_fs_type);</span><br><span class="line">    &#125;</span><br><span class="line">......</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">const</span> <span class="class"><span class="keyword">struct</span> <span class="title">file_operations</span> <span class="title">pipefifo_fops</span> =</span> &#123;</span><br><span class="line">    .open    = fifo_open,</span><br><span class="line">    .llseek    = no_llseek,</span><br><span class="line">    .read_iter  = pipe_read,</span><br><span class="line">    .write_iter  = pipe_write,</span><br><span class="line">    .poll    = pipe_poll,</span><br><span class="line">    .unlocked_ioctl  = pipe_ioctl,</span><br><span class="line">    .release  = pipe_release,</span><br><span class="line">    .fasync    = pipe_fasync,</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="type">static</span> <span class="keyword">struct</span> inode * <span class="title function_">get_pipe_inode</span><span class="params">(<span class="type">void</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">inode</span> *<span class="title">inode</span> =</span> new_inode_pseudo(pipe_mnt-&gt;mnt_sb);</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">pipe_inode_info</span> *<span class="title">pipe</span>;</span></span><br><span class="line">......</span><br><span class="line">    inode-&gt;i_ino = get_next_ino();</span><br><span class="line"></span><br><span class="line">    pipe = alloc_pipe_info();</span><br><span class="line">......</span><br><span class="line">    inode-&gt;i_pipe = pipe;</span><br><span class="line">    pipe-&gt;files = <span class="number">2</span>;</span><br><span class="line">    pipe-&gt;readers = pipe-&gt;writers = <span class="number">1</span>;</span><br><span class="line">    inode-&gt;i_fop = &amp;pipefifo_fops;</span><br><span class="line">    inode-&gt;i_state = I_DIRTY;</span><br><span class="line">    inode-&gt;i_mode = S_IFIFO | S_IRUSR | S_IWUSR;</span><br><span class="line">    inode-&gt;i_uid = current_fsuid();</span><br><span class="line">    inode-&gt;i_gid = current_fsgid();</span><br><span class="line">    inode-&gt;i_atime = inode-&gt;i_mtime = inode-&gt;i_ctime = current_time(inode);</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> inode;</span><br><span class="line">......</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>至此，一个匿名管道就创建成功了。如果对于 fd[1]写入，调用的是 pipe_write()，向 pipe_buffer 里面写入数据；如果对于 fd[0]的读入，调用的是 pipe_read()，也就是从 pipe_buffer 里面读取数据。至此，我们在一个进程内创建了管道，但是尚未实现进程间通信。</p>
<h2 id="四-匿名管道通信"><a href="#四-匿名管道通信" class="headerlink" title="四. 匿名管道通信"></a>四. 匿名管道通信</h2><p>在上文中我们提到了匿名管道通过|符号实现进程间的通信，传递输入给下一个进程作为输出，其实现原理如下：</p>
<ul>
<li>利用fork创建子进程，复制file_struct会同样复制fd输入输出数组，但是fd指向的文件仅有一份，即两个进程间可以通过fd数组实现对同一个管道文件的跨进程读写操作</li>
<li>禁用父进程的读，禁用子进程的写，即从父进程写入从子进程读出，从而实现了单向管道，避免了混乱</li>
<li>对于A|B来说，shell首先创建子进程A，接着创建子进程B，由于二者均从shell创建，因此共用fd数组。shell关闭读写，A开写B开读，从而实现了A 和B之间的通信。</li>
</ul>
<p><img src="https://user-images.githubusercontent.com/87457873/128118954-23f78086-e7fa-498c-8759-c897097b7f8c.png" alt="image"></p>
<p>接着我们需要调用dup2()实现输入输出和管道两端的关联，该函数会将fd赋值给fd2</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">/* Duplicate FD to FD2, closing the old FD2 and making FD2 be</span></span><br><span class="line"><span class="comment">   open the same file as FD is.  Return FD2 or -1.  */</span></span><br><span class="line"><span class="type">int</span></span><br><span class="line">__dup2 (<span class="type">int</span> fd, <span class="type">int</span> fd2)</span><br><span class="line">&#123;</span><br><span class="line">  <span class="keyword">if</span> (fd &lt; <span class="number">0</span> || fd2 &lt; <span class="number">0</span>)</span><br><span class="line">    &#123;</span><br><span class="line">      __set_errno (EBADF);</span><br><span class="line">      <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">  <span class="keyword">if</span> (fd == fd2)</span><br><span class="line">    <span class="comment">/* No way to check that they are valid.  */</span></span><br><span class="line">    <span class="keyword">return</span> fd2;</span><br><span class="line">  __set_errno (ENOSYS);</span><br><span class="line">  <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>在 files_struct 里面，有这样一个表，下标是 fd，内容指向一个打开的文件 struct file。在这个表里面，前三项是定下来的，其中第零项 STDIN_FILENO 表示标准输入，第一项 STDOUT_FILENO 表示标准输出，第三项 STDERR_FILENO 表示错误输出。</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">files_struct</span> &#123;</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">file</span> __<span class="title">rcu</span> * <span class="title">fd_array</span>[<span class="title">NR_OPEN_DEFAULT</span>];</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li>在 A 进程写入端通过dup2(fd[1],STDOUT_FILENO)将 STDOUT_FILENO（也即第一项）不再指向标准输出，而是指向创建的管道文件，那么以后往标准输出写入的任何东西，都会写入管道文件。</li>
<li>在 B 进程中读取端通过dup2(fd[0],STDIN_FILENO)将 STDIN_FILENO 也即第零项不再指向标准输入，而是指向创建的管道文件，那么以后从标准输入读取的任何东西，都来自于管道文件。</li>
</ul>
<p>至此，我们将 A|B 的功能完成。</p>
<p><img src="https://user-images.githubusercontent.com/87457873/128119058-30b537b4-d630-47f8-8dd9-0aaf60911d59.png" alt="image"></p>
<h2 id="五-有名管道"><a href="#五-有名管道" class="headerlink" title="五. 有名管道"></a>五. 有名管道</h2><p>对于有名管道，我们需要通过mkfifo创建，实际调用__xmknod()函数，最终调用mknod()，和字符设备创建一样。</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">/* Create a named pipe (FIFO) named PATH with protections MODE.  */</span></span><br><span class="line"><span class="type">int</span></span><br><span class="line"><span class="title function_">mkfifo</span> <span class="params">(<span class="type">const</span> <span class="type">char</span> *path, <span class="type">mode_t</span> mode)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">dev_t</span> dev = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">return</span> __xmknod (_MKNOD_VER, path, mode | S_IFIFO, &amp;dev);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* Create a device file named PATH, with permission and special bits MODE</span></span><br><span class="line"><span class="comment">   and device number DEV (which can be constructed from major and minor</span></span><br><span class="line"><span class="comment">   device numbers with the `makedev&#x27; macro above).  */</span></span><br><span class="line"><span class="type">int</span></span><br><span class="line">__xmknod (<span class="type">int</span> vers, <span class="type">const</span> <span class="type">char</span> *path, <span class="type">mode_t</span> mode, <span class="type">dev_t</span> *dev)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">unsigned</span> <span class="type">long</span> <span class="type">long</span> <span class="type">int</span> k_dev;</span><br><span class="line">    <span class="keyword">if</span> (vers != _MKNOD_VER)</span><br><span class="line">        <span class="keyword">return</span> INLINE_SYSCALL_ERROR_RETURN_VALUE (EINVAL);</span><br><span class="line">    <span class="comment">/* We must convert the value to dev_t type used by the kernel.  */</span></span><br><span class="line">    k_dev =  (*dev) &amp; ((<span class="number">1ULL</span> &lt;&lt; <span class="number">32</span>) - <span class="number">1</span>);</span><br><span class="line">    <span class="keyword">if</span> (k_dev != *dev)</span><br><span class="line">        <span class="keyword">return</span> INLINE_SYSCALL_ERROR_RETURN_VALUE (EINVAL);</span><br><span class="line">    <span class="keyword">return</span> INLINE_SYSCALL (mknod, <span class="number">3</span>, path, mode, (<span class="type">unsigned</span> <span class="type">int</span>) k_dev);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>mknod 在字符设备那一节已经解析过了，先是通过 user_path_create() 对于这个管道文件创建一个 dentry，然后因为是 S_IFIFO，所以调用 vfs_mknod()。由于这个管道文件是创建在一个普通文件系统上的，假设是在 ext4 文件上，于是 vfs_mknod 会调用 ext4_dir_inode_operations 的 mknod，也即会调用 ext4_mknod()。</p>
<p>在 ext4_mknod() 中，ext4_new_inode_start_handle() 会调用 __ext4_new_inode()，在 ext4 文件系统上真的创建一个文件，但是会调用 init_special_inode()，创建一个内存中特殊的 inode，这个函数我们在字符设备文件中也遇到过，只不过当时 inode 的 i_fop 指向的是 def_chr_fops，这次换成管道文件了，inode 的 i_fop 变成指向 pipefifo_fops，这一点和匿名管道是一样的。这样，管道文件就创建完毕了。</p>
<p>接下来，要打开这个管道文件，我们还是会调用文件系统的 open() 函数。还是沿着文件系统的调用方式，一路调用到 pipefifo_fops 的 open() 函数，也就是 fifo_open()。在 fifo_open() 里面会创建 pipe_inode_info，这一点和匿名管道也是一样的。这个结构里面有个成员是 struct pipe_buffer *bufs。我们可以知道，所谓的命名管道，其实是也是内核里面的一串缓存。接下来，对于命名管道的写入，我们还是会调用 pipefifo_fops 的 pipe_write() 函数，向 pipe_buffer 里面写入数据。对于命名管道的读入，我们还是会调用 pipefifo_fops 的 pipe_read()，也就是从 pipe_buffer 里面读取数据。</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">static</span> <span class="type">int</span> <span class="title function_">fifo_open</span><span class="params">(<span class="keyword">struct</span> inode *inode, <span class="keyword">struct</span> file *filp)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">pipe_inode_info</span> *<span class="title">pipe</span>;</span></span><br><span class="line">    <span class="type">bool</span> is_pipe = inode-&gt;i_sb-&gt;s_magic == PIPEFS_MAGIC;</span><br><span class="line">    <span class="type">int</span> ret;</span><br><span class="line">    filp-&gt;f_version = <span class="number">0</span>;</span><br><span class="line">    spin_lock(&amp;inode-&gt;i_lock);</span><br><span class="line">    <span class="keyword">if</span> (inode-&gt;i_pipe) &#123;</span><br><span class="line">        pipe = inode-&gt;i_pipe;</span><br><span class="line">        pipe-&gt;files++;</span><br><span class="line">        spin_unlock(&amp;inode-&gt;i_lock);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        spin_unlock(&amp;inode-&gt;i_lock);</span><br><span class="line">        pipe = alloc_pipe_info();</span><br><span class="line">        <span class="keyword">if</span> (!pipe)</span><br><span class="line">            <span class="keyword">return</span> -ENOMEM;</span><br><span class="line">        pipe-&gt;files = <span class="number">1</span>;</span><br><span class="line">        spin_lock(&amp;inode-&gt;i_lock);</span><br><span class="line">        <span class="keyword">if</span> (unlikely(inode-&gt;i_pipe)) &#123;</span><br><span class="line">            inode-&gt;i_pipe-&gt;files++;</span><br><span class="line">            spin_unlock(&amp;inode-&gt;i_lock);</span><br><span class="line">            free_pipe_info(pipe);</span><br><span class="line">            pipe = inode-&gt;i_pipe;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            inode-&gt;i_pipe = pipe;</span><br><span class="line">            spin_unlock(&amp;inode-&gt;i_lock);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    filp-&gt;private_data = pipe;</span><br><span class="line">    <span class="comment">/* OK, we have a pipe and it&#x27;s pinned down */</span></span><br><span class="line">    __pipe_lock(pipe);</span><br><span class="line">    <span class="comment">/* We can only do regular read/write on fifos */</span></span><br><span class="line">    filp-&gt;f_mode &amp;= (FMODE_READ | FMODE_WRITE);</span><br><span class="line">    <span class="keyword">switch</span> (filp-&gt;f_mode) &#123;</span><br><span class="line">    <span class="keyword">case</span> FMODE_READ:</span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">     *  O_RDONLY</span></span><br><span class="line"><span class="comment">     *  POSIX.1 says that O_NONBLOCK means return with the FIFO</span></span><br><span class="line"><span class="comment">     *  opened, even when there is no process writing the FIFO.</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">        pipe-&gt;r_counter++;</span><br><span class="line">        <span class="keyword">if</span> (pipe-&gt;readers++ == <span class="number">0</span>)</span><br><span class="line">            wake_up_partner(pipe);</span><br><span class="line">        <span class="keyword">if</span> (!is_pipe &amp;&amp; !pipe-&gt;writers) &#123;</span><br><span class="line">            <span class="keyword">if</span> ((filp-&gt;f_flags &amp; O_NONBLOCK)) &#123;</span><br><span class="line">                <span class="comment">/* suppress EPOLLHUP until we have</span></span><br><span class="line"><span class="comment">                 * seen a writer */</span></span><br><span class="line">                filp-&gt;f_version = pipe-&gt;w_counter;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="keyword">if</span> (wait_for_partner(pipe, &amp;pipe-&gt;w_counter))</span><br><span class="line">                    <span class="keyword">goto</span> err_rd;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">case</span> FMODE_WRITE:</span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">     *  O_WRONLY</span></span><br><span class="line"><span class="comment">     *  POSIX.1 says that O_NONBLOCK means return -1 with</span></span><br><span class="line"><span class="comment">     *  errno=ENXIO when there is no process reading the FIFO.</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">        ret = -ENXIO;</span><br><span class="line">        <span class="keyword">if</span> (!is_pipe &amp;&amp; (filp-&gt;f_flags &amp; O_NONBLOCK) &amp;&amp; !pipe-&gt;readers)</span><br><span class="line">            <span class="keyword">goto</span> err;</span><br><span class="line">        pipe-&gt;w_counter++;</span><br><span class="line">        <span class="keyword">if</span> (!pipe-&gt;writers++)</span><br><span class="line">            wake_up_partner(pipe);</span><br><span class="line">        <span class="keyword">if</span> (!is_pipe &amp;&amp; !pipe-&gt;readers) &#123;</span><br><span class="line">            <span class="keyword">if</span> (wait_for_partner(pipe, &amp;pipe-&gt;r_counter))</span><br><span class="line">                <span class="keyword">goto</span> err_wr;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">case</span> FMODE_READ | FMODE_WRITE:</span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">     *  O_RDWR</span></span><br><span class="line"><span class="comment">     *  POSIX.1 leaves this case &quot;undefined&quot; when O_NONBLOCK is set.</span></span><br><span class="line"><span class="comment">     *  This implementation will NEVER block on a O_RDWR open, since</span></span><br><span class="line"><span class="comment">     *  the process can at least talk to itself.</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">        pipe-&gt;readers++;</span><br><span class="line">        pipe-&gt;writers++;</span><br><span class="line">        pipe-&gt;r_counter++;</span><br><span class="line">        pipe-&gt;w_counter++;</span><br><span class="line">        <span class="keyword">if</span> (pipe-&gt;readers == <span class="number">1</span> || pipe-&gt;writers == <span class="number">1</span>)</span><br><span class="line">            wake_up_partner(pipe);</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">    <span class="keyword">default</span>:</span><br><span class="line">        ret = -EINVAL;</span><br><span class="line">        <span class="keyword">goto</span> err;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">/* Ok! */</span></span><br><span class="line">    __pipe_unlock(pipe);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">......</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>无论是匿名管道还是命名管道，在内核都是一个文件。只要是文件就要有一个 inode。在这种特殊的 inode 里面，file_operations 指向管道特殊的 pipefifo_fops，这个 inode 对应内存里面的缓存。当我们用文件的 open 函数打开这个管道设备文件的时候，会调用 pipefifo_fops 里面的方法创建 struct file 结构，他的 inode 指向特殊的 inode，也对应内存里面的缓存，file_operations 也指向管道特殊的 pipefifo_fops。写入一个 pipe 就是从 struct file 结构找到缓存写入，读取一个 pipe 就是从 struct file 结构找到缓存读出。匿名管道和命名管道区别就在于匿名管道会通过dup2()指定输入输出源，完成之后立即释放，而命名管道通过mkfifo创建挂载后，需要手动调用pipe_read()和pipe_write()来完成其功能，表现到用户端即为前面提到的例子。</p>
]]></content>
      <categories>
        <category>linux-doc 进程管理</category>
      </categories>
      <tags>
        <tag>Linux</tag>
      </tags>
  </entry>
  <entry>
    <title>进程间通信，管道，socket，XSI(System V)</title>
    <url>/2023/01/15/linux-docs/%E8%BF%9B%E7%A8%8B%E7%AE%A1%E7%90%86/%E8%BF%9B%E7%A8%8B%E9%97%B4%E9%80%9A%E4%BF%A1%EF%BC%8C%E7%AE%A1%E9%81%93%EF%BC%8Csocket%EF%BC%8CXSI(System%20V)/</url>
    <content><![CDATA[<p>进程通信(IPC)分为PIPE(管道)、Socket(套接字)和XSI(System_V)。XSI又分为msg(消息队列)、sem(信号量数组)和shm(共享内存)。这些手段都是用于进程间通信的，只有进程间通讯才需要借助第三方机制，线程之间通讯是不需要借助第三方机制，因为线程之间的地址空间是共享的。线程之间可以通过互斥量，死锁，唤醒，信号等来进行通讯。</p>
<h2 id="管道-PIPE-FIFO-内核帮你创建和维护"><a href="#管道-PIPE-FIFO-内核帮你创建和维护" class="headerlink" title="管道(PIPE-&gt;FIFO) 内核帮你创建和维护"></a>管道(PIPE-&gt;FIFO) 内核帮你创建和维护</h2><h3 id="管道的特点"><a href="#管道的特点" class="headerlink" title="管道的特点:"></a>管道的特点:</h3><ul>
<li>管道是半双工的，也就是同一时间数据只能从一端流向另一段。就像水一样，两端水同时流入管道，那么数据就会乱</li>
<li>管道的两端一端作为读端，一端是写端</li>
<li>管道具有自适应的特点， 默认会适应速度比较慢的一方，管道被写满或读空时速度快的一方会自动阻塞</li>
</ul>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">pipe - create pipe</span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="type">int</span> <span class="title function_">pipe</span><span class="params">(<span class="type">int</span> pipefd[<span class="number">2</span>])</span>;</span><br><span class="line"><span class="comment">// 也就只有两端，一端读，一端写</span></span><br></pre></td></tr></table></figure>

<p>pipe用于创建管道，pipefd是一个数组，表示管道的两端文件描述符，pipefd[0]端作为读端，pipefd[1]作为写端。</p>
<p>pipe产生的是匿名管道，在磁盘的任何位置上找不到这个管道文件，而且匿名管道只能用于具有亲缘关系的进程之间通信(还要分亲缘关系)</p>
<p>一般情况下有亲缘关系的进程之间使用管道进行通信时，会把自己不用的一端文件描述符关闭</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;../include/apue.h&quot;</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> BUFSIZE 1024</span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span>&#123;</span><br><span class="line">    <span class="type">int</span> pd[<span class="number">2</span>];</span><br><span class="line">    <span class="type">char</span> buf[BUFSIZE];</span><br><span class="line">    <span class="type">pid_t</span> pid;</span><br><span class="line">    <span class="type">int</span> len;</span><br><span class="line">    <span class="comment">// 创建匿名管道</span></span><br><span class="line">    <span class="keyword">if</span>(pipe(pd)&lt;<span class="number">0</span>)</span><br><span class="line">        err_sys(<span class="string">&quot;pipe()&quot;</span>);</span><br><span class="line"></span><br><span class="line">    pid = fork();</span><br><span class="line">    <span class="keyword">if</span>(pid == <span class="number">0</span>)&#123; <span class="comment">// 子进程 读取管道数据</span></span><br><span class="line">        <span class="comment">// 关闭写端</span></span><br><span class="line">        close(pd[<span class="number">1</span>]);</span><br><span class="line">        <span class="comment">// 从管道中读取数据，如果子进程比父进程先被调度会阻塞等待数据写入</span></span><br><span class="line">        len = read(pd[<span class="number">0</span>],buf,BUFSIZE);</span><br><span class="line">        <span class="built_in">puts</span>(buf);</span><br><span class="line">        <span class="comment">/***</span></span><br><span class="line"><span class="comment">         * 管道fork之前创建</span></span><br><span class="line"><span class="comment">         * 父子进程都有一份</span></span><br><span class="line"><span class="comment">         * 所有退出之前要确保管道两端都关闭</span></span><br><span class="line"><span class="comment">         * ***/</span></span><br><span class="line">        close(pd[<span class="number">0</span>]);</span><br><span class="line">        <span class="built_in">exit</span>(<span class="number">0</span>);</span><br><span class="line">    &#125;<span class="keyword">else</span>&#123; <span class="comment">// 父进程 向管道写入数据</span></span><br><span class="line">        <span class="comment">// 关闭读端</span></span><br><span class="line">        close(pd[<span class="number">0</span>]);</span><br><span class="line">        <span class="comment">// 写端</span></span><br><span class="line">        write(pd[<span class="number">1</span>],<span class="string">&quot;Hello,world!&quot;</span>,<span class="number">100</span>);</span><br><span class="line">        close(pd[<span class="number">1</span>]);</span><br><span class="line">        wait(<span class="literal">NULL</span>);</span><br><span class="line">        <span class="built_in">exit</span>(<span class="number">0</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>创建了一个匿名的管道，在pd[2]数组中凑齐了读写双方，子进程同样继承了具有读写双方的数组pd[2]</p>
<p>当关闭之后就是取决于我们需要对管道的数据流方向做准备。要么从子进程流向父进程，要么从父进程流向子进程。</p>
<p><img src="https://user-images.githubusercontent.com/87457873/127452218-fee35e85-718a-4303-92bc-965065e3eac9.png" alt="image"></p>
<p>mkfifo函数</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">mkfifo - make a FIFO special <span class="title function_">file</span> <span class="params">(a named pipe)</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span>  <span class="string">&lt;sys/types.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/stat.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">mkfifo</span><span class="params">(<span class="type">const</span> <span class="type">char</span> *pathname,<span class="type">mode_t</span> mode)</span>;</span><br><span class="line"><span class="comment">// pathname: 管道文件的路径和文件名</span></span><br><span class="line"><span class="comment">// mode: 创建管道文件的权限。还是老规矩，传入的mode值要与系统的umask值做运算(mode&amp;~umask)</span></span><br><span class="line"><span class="comment">// 成功返回0，失败返回-1并设置errno</span></span><br></pre></td></tr></table></figure>

<p>mkfifo函数用于创建命名管道，作用与匿名管道相同，不过可以在不同的进程之间使用，相当于对一个普通文件进行写操作就可以了。</p>
<p>这个管道文件是任何有权限的进程都可以使用的，两端都像操作一个普通文件一样对它进行打开、读写、关闭动作就可以了，只要一端写入数据另一端就可以读出来。</p>
<p>命名管道文件</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;../include/apue.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;fcntl.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> PATHNAME <span class="string">&quot;./mkfifof.txt&quot;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">(<span class="type">void</span>)</span>&#123;</span><br><span class="line">    <span class="type">pid_t</span> pid;</span><br><span class="line">    <span class="type">int</span> fd = <span class="number">-1</span>;</span><br><span class="line">    <span class="type">char</span> buf[BUFSIZ] = <span class="string">&quot;&quot;</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 创建一个命名管道，通过ls -l查看这个管道的属性</span></span><br><span class="line">    <span class="keyword">if</span>(mkfifo(PATHNAME,<span class="number">0664</span>)&lt;<span class="number">0</span>)&#123;</span><br><span class="line">        err_sys(<span class="string">&quot;mkfifo&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    fflush(<span class="literal">NULL</span>); <span class="comment">// 刷新缓冲区</span></span><br><span class="line">    pid = fork();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span>(pid&lt;<span class="number">0</span>)</span><br><span class="line">        err_sys(<span class="string">&quot;fork()&quot;</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span>(!pid)&#123;</span><br><span class="line">        pid = fork(); <span class="comment">// 继续fork 三个进程了</span></span><br><span class="line">        <span class="keyword">if</span>(pid&lt;<span class="number">0</span>)err_sys(<span class="string">&quot;fork()2&quot;</span>);</span><br><span class="line">        <span class="keyword">if</span>(!pid) <span class="built_in">exit</span>(<span class="number">0</span>); <span class="comment">// 爸爸走了</span></span><br><span class="line">       <span class="comment">// child2</span></span><br><span class="line">        fd = open(PATHNAME,O_RDWR);</span><br><span class="line">        <span class="keyword">if</span>(fd&lt;<span class="number">0</span>) err_sys(<span class="string">&quot;open()&quot;</span>);</span><br><span class="line">        <span class="comment">// 阻塞，等待条件满足</span></span><br><span class="line">        read(fd,buf,BUFSIZ);</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;%s\n&quot;</span>,buf);</span><br><span class="line">        write(fd,<span class="string">&quot; World!&quot;</span>,<span class="number">8</span>);</span><br><span class="line">        close(fd);</span><br><span class="line">        <span class="built_in">exit</span>(<span class="number">0</span>);</span><br><span class="line">    &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">        fd = open(PATHNAME,O_RDWR);</span><br><span class="line">        <span class="keyword">if</span>(fd &lt; <span class="number">0</span>) err_sys(<span class="string">&quot;open()&quot;</span>);</span><br><span class="line">        <span class="comment">// 写</span></span><br><span class="line">        write(fd,<span class="string">&quot;hello&quot;</span>,<span class="number">6</span>);</span><br><span class="line">        sleep(<span class="number">1</span>); <span class="comment">// 要是不休眠就没有给另一个进程机会写，最后自娱自乐，第二个进程也打不开文件</span></span><br><span class="line">        read(fd,buf,BUFSIZ);</span><br><span class="line">        close(fd);</span><br><span class="line">        <span class="built_in">puts</span>(buf);</span><br><span class="line">        <span class="comment">// 这个进程最后退出，所以把管道文件删除，不然下次在创建的时候会报文件已存在的错误</span></span><br><span class="line">        remove(PATHNAME);</span><br><span class="line">        <span class="built_in">exit</span>(<span class="number">0</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>看到了下面的创建，不是普通的文件，而是管道文件</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">prw-r--r--  <span class="number">1</span> transcheung  staff      <span class="number">0</span>  <span class="number">2</span> <span class="number">14</span> <span class="number">11</span>:<span class="number">41</span> mkfifof.txt</span><br></pre></td></tr></table></figure>

<h3 id="协同进程-管道是半双工的-两进程一个只能读，一个只能写"><a href="#协同进程-管道是半双工的-两进程一个只能读，一个只能写" class="headerlink" title="协同进程 管道是半双工的 两进程一个只能读，一个只能写"></a>协同进程 管道是半双工的 两进程一个只能读，一个只能写</h3><p>要实现双工通信，必须采用两个管道，一个进程对一个管道只读，对另一个管道只写。</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;../include/apue.h&quot;</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> BUFSIZE 1024</span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span>&#123;</span><br><span class="line">    <span class="type">int</span> pd[<span class="number">2</span>];</span><br><span class="line">    <span class="type">int</span> ipd[<span class="number">2</span>];</span><br><span class="line">    <span class="type">char</span> buf[BUFSIZE];</span><br><span class="line">    <span class="type">char</span> dbuf[BUFSIZE];</span><br><span class="line">    <span class="type">pid_t</span> pid;</span><br><span class="line">    <span class="type">int</span> len;</span><br><span class="line">    <span class="comment">// 创建匿名管道</span></span><br><span class="line">    <span class="keyword">if</span>(pipe(pd)&lt;<span class="number">0</span>)</span><br><span class="line">        err_sys(<span class="string">&quot;pipe()&quot;</span>);</span><br><span class="line">    <span class="keyword">if</span>(pipe(ipd)&lt;<span class="number">0</span>) err_sys(<span class="string">&quot;pipe2&quot;</span>);</span><br><span class="line">    pid = fork();</span><br><span class="line">    <span class="keyword">if</span>(pid == <span class="number">0</span>)&#123; <span class="comment">// 子进程 读取管道数据</span></span><br><span class="line">        <span class="comment">// 关闭写端</span></span><br><span class="line">       <span class="comment">// close(pd[1]);</span></span><br><span class="line">        <span class="comment">// 从管道中读取数据，如果子进程比父进程先被调度会阻塞等待数据写入</span></span><br><span class="line">        <span class="comment">//len = read(pd[0],buf,BUFSIZE);</span></span><br><span class="line">       <span class="comment">// puts(buf);</span></span><br><span class="line">        <span class="comment">/***</span></span><br><span class="line"><span class="comment">         * 管道fork之前创建</span></span><br><span class="line"><span class="comment">         * 父子进程都有一份</span></span><br><span class="line"><span class="comment">         * 所有退出之前要确保管道两端都关闭</span></span><br><span class="line"><span class="comment">         * ***/</span></span><br><span class="line">        close(pd[<span class="number">0</span>]);</span><br><span class="line">        write(pd[<span class="number">1</span>],<span class="string">&quot;hello,child!&quot;</span>,<span class="number">15</span>);</span><br><span class="line">        <span class="comment">// sleep(10)；</span></span><br><span class="line">        <span class="comment">//sleep(10);</span></span><br><span class="line">        len = read(ipd[<span class="number">0</span>],dbuf,BUFSIZE);</span><br><span class="line">        <span class="built_in">puts</span>(dbuf);</span><br><span class="line">        close(pd[<span class="number">1</span>]);</span><br><span class="line">        close(ipd[<span class="number">0</span>]);</span><br><span class="line">        <span class="built_in">exit</span>(<span class="number">0</span>);</span><br><span class="line">    &#125;<span class="keyword">else</span>&#123; <span class="comment">// 父进程 向管道写入数据</span></span><br><span class="line">        <span class="comment">// 关闭读端</span></span><br><span class="line">        <span class="comment">//close(pd[0]);</span></span><br><span class="line">        <span class="comment">// 写端</span></span><br><span class="line">       <span class="comment">// write(pd[1],&quot;Hello,world!&quot;,15);</span></span><br><span class="line">        close(pd[<span class="number">1</span>]);</span><br><span class="line">        len = read(pd[<span class="number">0</span>],buf,BUFSIZE);</span><br><span class="line">        <span class="built_in">puts</span>(buf);</span><br><span class="line">        <span class="comment">// 关闭读端</span></span><br><span class="line">        <span class="comment">// sleep(5);</span></span><br><span class="line">        write(ipd[<span class="number">1</span>],<span class="string">&quot;hello parent!&quot;</span>,BUFSIZE);</span><br><span class="line">        close(pd[<span class="number">0</span>]);</span><br><span class="line">        close(ipd[<span class="number">1</span>]);</span><br><span class="line">        wait(<span class="literal">NULL</span>);</span><br><span class="line">        <span class="built_in">exit</span>(<span class="number">0</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>两个管道，实现你来我往，mkfifo同理，两个文件就好了。</p>
<h2 id="popen与pclose"><a href="#popen与pclose" class="headerlink" title="popen与pclose"></a>popen与pclose</h2><p>popen和pclose提供了原子操作，创建一个管道，fork一个子进程，关闭未使用的管道端，执行一个个shell运行命令，然后等待命令终止</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line">FILE *<span class="title function_">popen</span><span class="params">(<span class="type">const</span> <span class="type">char</span> *cmdstring,<span class="type">const</span> <span class="type">char</span> *type)</span>;</span><br><span class="line"><span class="comment">// 成功返回文件指针，出错，返回NULL</span></span><br><span class="line"><span class="type">int</span> <span class="title function_">pclose</span><span class="params">(FILE *fp)</span>;</span><br></pre></td></tr></table></figure>

<p>popen先执行fork，然后调用exec执行cmdstring，并且返回一个标准IO文件指针。如果type是”r”，则文件指针连接到cmdstring的标准输出；如果是”w”，则文件指针连接到cmfstring的标准输入</p>
<p><img src="https://user-images.githubusercontent.com/87457873/127452540-8c4dd73b-68b1-4357-a4c0-015667790601.png" alt="image"></p>
<p>由图可以看出，stdout和stdin是较于子进程而言的。</p>
<p>pclose关闭标准IO流，等待命令终止，返回shell的终止状态。如果shell不能被执行，则pclose返回的终止状态与shell已执行exit一样。</p>
<pre><code>cmdstring
fp = popen(&quot;ls *.c&quot;,&quot;r&quot;)
fp = popen(&quot;cmd 2&gt;&amp;1&quot;,&quot;r&quot;) 
</code></pre>
<h2 id="XSI-IPC-System-V规范的进程间通信手段，而不是POSIX标准"><a href="#XSI-IPC-System-V规范的进程间通信手段，而不是POSIX标准" class="headerlink" title="XSI IPC System V规范的进程间通信手段，而不是POSIX标准"></a>XSI IPC System V规范的进程间通信手段，而不是POSIX标准</h2><h2 id="多进程与多线程"><a href="#多进程与多线程" class="headerlink" title="多进程与多线程"></a>多进程与多线程</h2><p>多线程使用的基本是POSIZ标准提供的接口函数，而多进程则是基于System V。在信号量这种常用的同步互斥手段方面，POSIX在无竞争条件下是不会陷入内核的，而SystemV即无论何时都会陷入内核。这就给多线程每次调用都会陷入内核，丧失了线程的清亮优势。所以多线程之间的通信不是用System V。</p>
<ul>
<li>ipcs命令可以查看CSI IPC的使用情况</li>
<li>ipcrm 命令可以删除指定的XSI IPC</li>
</ul>
<p>通过查看ipcs</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">IPC status from &lt;running system&gt; as of Fri Feb 15 10:31:54 CST 2019T     ID     KEY        MODE       OWNER    GROUP</span><br><span class="line">Message Queues:</span><br><span class="line"></span><br><span class="line">T     ID     KEY        MODE       OWNER    GROUP</span><br><span class="line">Shared Memory:</span><br><span class="line"></span><br><span class="line">T     ID     KEY        MODE       OWNER    GROUP</span><br><span class="line">Semaphores:</span><br></pre></td></tr></table></figure>

<p>第一部分是消息队列，第二部分是共享内存，第三部分是信号量数组</p>
<p>每一列都有一列叫做”key”，使用XSI IPC通信的进程就是通过同一个key值操作同一个共享资源的。key是一个正整数，与文件描述符不同的是，生成一个新key值时，不采用当前可用的数值的最小值，而是类似生成进程ID的方式，key的值连续➕1，直到达到一个整数的最大正值，然后回转到0从头开始累加。</p>
<h2 id="XSI消息队列-让通信双方传送结构体数据，提高传送数据灵活性"><a href="#XSI消息队列-让通信双方传送结构体数据，提高传送数据灵活性" class="headerlink" title="XSI消息队列 让通信双方传送结构体数据，提高传送数据灵活性"></a>XSI消息队列 让通信双方传送结构体数据，提高传送数据灵活性</h2><p>通信，就需要在通信之前双方约定通信协议，协议就是通信双方约定的数据交换格式。</p>
<p>从消息队列开始一直到Socket，都会看到类似的程序架构，无论是消息队列还是Socket，都需要约定通信协议，而且都是按照一定的步骤才能实现通讯。</p>
<p>消息队列在约定协议的时候，需要自定义结构体里要强制添加一个long mtype成员 这个成员的作用是用于区分多种消息类型中的不同类型的数据包，当只有一种类型的包时这个成员没什么作用，但是也要一定必须带上。</p>
<p>既然时通讯也要区分 主动端(先发包的一方) 和 被动端(先收包的一方，先运行)，它们运行的时机不同，作用不同甚至调用函数也不同，所以我们的后面的每个例子几乎都要编译处2个不同的可执行程序来测试。</p>
<h2 id="msg、sem和shm都有一系列函数遵循"><a href="#msg、sem和shm都有一系列函数遵循" class="headerlink" title="msg、sem和shm都有一系列函数遵循"></a>msg、sem和shm都有一系列函数遵循</h2><ul>
<li>xxxget() &#x2F;&#x2F; 创建</li>
<li>xxxop() &#x2F;&#x2F; 相关操作</li>
<li>xxxctl() &#x2F;&#x2F; 其他的控制或销毁</li>
</ul>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">msgget - get a Syatem V message <span class="built_in">queue</span> identifier</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/types.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/ipc.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/msg.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">msgget</span><span class="params">(<span class="type">key_t</span> key,<span class="type">int</span> msgflg)</span>;</span><br></pre></td></tr></table></figure>

<p>msgget函数的作用是创建一个消息队列，消息读列是双工的，两边都可以读写。</p>
<ul>
<li>key相当于通信双方的街头暗号，拥有相同key的双方才可以通信</li>
</ul>
<p>key值必须是唯一的，系统中有个ftok函数可以用于获取key，通过文件inode和salt进行hash运算来生成唯一的key， 只要两个进程使用相同的文件和salt就可以生成一样的key值了。</p>
<ul>
<li>msgflg: 特殊要求。无论有多少特殊要求，只要使用了IPC_CREAT，就必须按位或一个权限，权限不是想指定多大就能多大，要用它&amp;&#x3D;~umask。</li>
</ul>
<p>同一个消息队列只需要创建一次，所以谁先运行起来谁有责任创建消息队列，后运行起来的就不需要创建了。</p>
<p>同理，对于后启动的进程来说，消息队列不是他创建的，就没必要销毁了。</p>
<h2 id="msgrcv函数和msgsnd函数-从msgid这个消息队列中接收数据"><a href="#msgrcv函数和msgsnd函数-从msgid这个消息队列中接收数据" class="headerlink" title="msgrcv函数和msgsnd函数 从msgid这个消息队列中接收数据"></a>msgrcv函数和msgsnd函数 从msgid这个消息队列中接收数据</h2><figure class="highlight c"><table><tr><td class="code"><pre><span class="line">msgrcv,msgsnd - message operations</span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/types.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/ipc.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/msg.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">msgsnd</span><span class="params">(<span class="type">int</span> msgid, <span class="type">const</span> <span class="type">void</span> *msgp,<span class="type">size_t</span> msgsz,<span class="type">int</span> msgflg)</span>;</span><br><span class="line"></span><br><span class="line"><span class="type">ssize_t</span> <span class="title function_">msgrcv</span><span class="params">(<span class="type">int</span> msgid,<span class="type">void</span> *msgp,<span class="type">size_t</span> msgsz,<span class="type">long</span> msgtyp,<span class="type">int</span> msgflg)</span>;</span><br><span class="line"><span class="comment">// msgp成员的定义要类似msgbuf这个结构体，第一成员必须是long类型的mtype，并且必须是&gt;0的值</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">msgbuf</span>&#123;</span></span><br><span class="line">    <span class="type">long</span> mtype; <span class="comment">// 消息类型 必须&gt;0</span></span><br><span class="line">    <span class="type">char</span> mtext[<span class="number">1</span>]; <span class="comment">// 消息数据字段</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<ul>
<li>msgrcv函数从msgid这个消息队列中接收数据，并将接收到的数据放到msgp结构体中，这段空间有msgsz这个字节的大小，msgsz的值要减掉强制的成员mtype的大小(sizeof(long))。</li>
<li>msgtyp是msgp结构体中的mtype的成员，表示需要接收那种类型的消息。虽然msg是消息队列，但是 它并不完全遵循队列的形式，可以让接收者挑消息接收。 如果不挑消息可以填写0，这样就按照队列中的消息顺序返回。</li>
<li>msgflg是特殊要求位图，没有写0</li>
<li>msgsnd函数向msgid这个消息队列发送msgp结构体数据，msgp的大小是msgsz，msgflg是特殊要求没有写0。</li>
</ul>
<h2 id="msgctl函数-跟iocrtl、fcntl函数用法类似"><a href="#msgctl函数-跟iocrtl、fcntl函数用法类似" class="headerlink" title="msgctl函数 跟iocrtl、fcntl函数用法类似"></a>msgctl函数 跟iocrtl、fcntl函数用法类似</h2><figure class="highlight c"><table><tr><td class="code"><pre><span class="line">msgctl - message control operations</span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/types.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/ipc.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/msg.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">msgctl</span><span class="params">(<span class="type">int</span> msgid,<span class="type">int</span> cmd,<span class="keyword">struct</span> msqid_ds *buf)</span>;</span><br><span class="line"><span class="comment">// 通过cmd指定具体命令，然后通过buf为cmd命令设定参数，当然有些命令是需要参数的，有些命令则不需要参数</span></span><br></pre></td></tr></table></figure>

<p>最常用的cmd就是IPC_RMID，表示删除(结束)某个IPC通信，并且这个命令不需要buf参数，直接传入NULL即可。</p>
<p>buf结构体里面的成员很多。</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">/***</span></span><br><span class="line"><span class="comment"> * 共同的协议proto.h</span></span><br><span class="line"><span class="comment"> * ***/</span></span><br><span class="line"><span class="comment">/*定义双方都需要使用的数据或对象*/</span></span><br><span class="line"><span class="meta">#<span class="keyword">ifndef</span> PROTO_H__</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> PROTO_H__</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> NAMESIZE 32</span></span><br><span class="line"><span class="comment">// 通讯双方生成key值共同使用的文件</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> KEYPATH <span class="string">&quot;./test.txt&quot;</span></span></span><br><span class="line"><span class="comment">// 通讯双方生成key值共同使用的salt值</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> KEYPROJ <span class="string">&#x27;a&#x27;</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 消息类型，只要是大于0的合法整数即可</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> MSGTYPE 10</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 通讯双方约定的协议</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">msg_st</span>&#123;</span></span><br><span class="line">    <span class="type">long</span> mtype;</span><br><span class="line">    <span class="type">char</span> name[NAMESIZE];</span><br><span class="line">    <span class="type">int</span> math;</span><br><span class="line">    <span class="type">int</span> chinese;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="meta">#<span class="keyword">endif</span> <span class="comment">//  PROTO_H__</span></span></span><br></pre></td></tr></table></figure>

<p>接收端要先运行，先创建接收端的消息队列</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;../include/apue.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/ipc.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/msg.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;proto.h&quot;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">(<span class="type">void</span>)</span>&#123;</span><br><span class="line">    <span class="type">key_t</span> key;</span><br><span class="line">    <span class="type">int</span> msgid;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">msg_st</span> <span class="title">rbuf</span>;</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 通过/tmp/out文件和字符&#x27;a&#x27;生成唯一的key，文件必须真实存在</span></span><br><span class="line">    key = ftok(KEYPATH,KEYPROJ); <span class="comment">// 来自proto.h</span></span><br><span class="line">    <span class="keyword">if</span>(key&lt;<span class="number">0</span>) err_sys(<span class="string">&quot;ftok()&quot;</span>);</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 接收端先启动，所以消息队列由接收端创建</span></span><br><span class="line">    <span class="keyword">if</span>((msgid = msgget(key,IPC_CREAT|<span class="number">0600</span>))&lt;<span class="number">0</span>) err_sys(<span class="string">&quot;msgget&quot;</span>);</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 不停的接收消息 轮询</span></span><br><span class="line">    <span class="keyword">while</span>(<span class="number">1</span>)&#123;</span><br><span class="line">        <span class="comment">// 没有消息就会阻塞等待</span></span><br><span class="line">        <span class="keyword">if</span>(msgrcv(msgid,&amp;rbuf,<span class="keyword">sizeof</span>(rbuf)-<span class="keyword">sizeof</span>(<span class="type">long</span>),<span class="number">0</span>,<span class="number">0</span>)&lt;<span class="number">0</span>) err_sys(<span class="string">&quot;msgrcv&quot;</span>);</span><br><span class="line"></span><br><span class="line">        <span class="comment">/***</span></span><br><span class="line"><span class="comment">         * 用结构体中强制添加的成员判断消息类型</span></span><br><span class="line"><span class="comment">         * 当然这个栗子只有一种消息类型，所以不判断也可以</span></span><br><span class="line"><span class="comment">         * 如果包含多种消息类型就可以协议组switch ...case结构</span></span><br><span class="line"><span class="comment">         * ***/</span></span><br><span class="line">        <span class="keyword">if</span>(rbuf.mtype == MSGTYPE)&#123;</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">&quot;Name = %s\n&quot;</span>,rbuf.name);</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">&quot;Math = %d\n&quot;</span>,rbuf.math);</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">&quot;Chinese = %d\n&quot;</span>,rbuf.chinese);</span><br><span class="line"></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">/***</span></span><br><span class="line"><span class="comment">     * 谁创建谁销毁</span></span><br><span class="line"><span class="comment">     * 这个程序无法正常结束只能等信号杀死</span></span><br><span class="line"><span class="comment">     * 使用信号杀死之后可以用ipcs命令查看，消息队列应该没有被销毁</span></span><br><span class="line"><span class="comment">     * 使用ipcrm删掉</span></span><br><span class="line"><span class="comment">     * ***/</span></span><br><span class="line">    msgctl(msgid,IPC_RMID,<span class="literal">NULL</span>); <span class="comment">// 销毁</span></span><br><span class="line">    <span class="built_in">exit</span>(<span class="number">0</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>发送端</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;../include/apue.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/ipc.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/msg.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;time.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;proto.h&quot;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span>&#123;</span><br><span class="line">    <span class="type">key_t</span> key;</span><br><span class="line">    <span class="type">int</span> msgid;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">msg_st</span> <span class="title">sbuf</span>;</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 设置随机数种子</span></span><br><span class="line">    srand(time(<span class="literal">NULL</span>));</span><br><span class="line">    <span class="comment">// 用于接收方相同的文件和salt生成一样的key</span></span><br><span class="line">    key = ftok(KEYPATH,KEYPROJ);</span><br><span class="line">    <span class="keyword">if</span>(key&lt;<span class="number">0</span>) err_sys(<span class="string">&quot;ftok()&quot;</span>);</span><br><span class="line">    <span class="comment">// 取得消息队列</span></span><br><span class="line">    msgid = msgget(key,<span class="number">0</span>);</span><br><span class="line">    <span class="keyword">if</span>(msgid&lt;<span class="number">0</span>) err_sys(<span class="string">&quot;msgget&quot;</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 要发送的结构体赋值</span></span><br><span class="line">    sbuf.mtype = MSGTYPE;</span><br><span class="line">    <span class="built_in">strcpy</span>(sbuf.name,<span class="string">&quot;Trans&quot;</span>);</span><br><span class="line">    sbuf.math = rand()%<span class="number">100</span>;</span><br><span class="line">    sbuf.chinese = rand()%<span class="number">100</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span>(msgsnd(msgid,&amp;sbuf,<span class="keyword">sizeof</span>(sbuf)-<span class="keyword">sizeof</span>(<span class="type">long</span>),<span class="number">0</span>)&lt;<span class="number">0</span>) err_sys(<span class="string">&quot;msgsnd&quot;</span>);</span><br><span class="line">    </span><br><span class="line">    <span class="built_in">puts</span>(<span class="string">&quot;ok!&quot;</span>);</span><br><span class="line">    <span class="built_in">exit</span>(<span class="number">0</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>最后使用ipcs查看，消息队列显式</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">IPC status from &lt;running system&gt; as of Fri Feb 15 12:21:02 CST 2019</span><br><span class="line">T     ID     KEY        MODE       OWNER    GROUP</span><br><span class="line">Message Queues:</span><br><span class="line">q  65536 0x6104a0ae --rw------- transcheung    staff</span><br><span class="line"></span><br><span class="line">T     ID     KEY        MODE       OWNER    GROUP</span><br><span class="line">Shared Memory:</span><br><span class="line"></span><br><span class="line">T     ID     KEY        MODE       OWNER    GROUP</span><br><span class="line">Semaphores:</span><br></pre></td></tr></table></figure>

<p>KEYPROJ直接充当salt值，接收方先运行，所以接收方先创建消息队列，发送方要使用相同的文件和salt生成于接收方相同的key值，这样才能使用同一个消息队列。</p>
<p>发送方发送一个结构体，接收方接收结构体并解析打印，所以这个结构体保证了数据能够正常被解析，所以 这个结构体就是我们所说的”协议”。 所以协议就是要保证一样的，所以写了一个proto.h文件，让发送方共同引用，就保证是相同的结构体了。</p>
<h2 id="信号量-semget-按部就班，步骤与消息队列差不多"><a href="#信号量-semget-按部就班，步骤与消息队列差不多" class="headerlink" title="信号量(semget) 按部就班，步骤与消息队列差不多"></a>信号量(semget) 按部就班，步骤与消息队列差不多</h2><figure class="highlight c"><table><tr><td class="code"><pre><span class="line">semget - get a semaphore <span class="built_in">set</span> identifier</span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/types.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/ipc.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/sem.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">semget</span><span class="params">(<span class="type">key_t</span> key,<span class="type">int</span> nsems,<span class="type">int</span> semflg)</span>;</span><br><span class="line"><span class="comment">// 用于创建信号量，成功返回sem ID，失败返回-1并设置errnp</span></span><br></pre></td></tr></table></figure>

<ul>
<li>key: 具有亲缘关系的进程之间可以使用一个匿名的key值，key使用宏IPC_PRIVATE即可</li>
<li>nsems:表示你到底有多少个sem。信号量其实是一个计数器，如果设置为1可以用来模拟互斥量</li>
<li>semflg:IPC_CREAT表示创建sem，同时需要按位或一个权限，如果是匿名IPC则无需执行这个宏，直接给权限就好</li>
</ul>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">semctl - semaphore control operations</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/types.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/ipc.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/sem.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">semctl</span><span class="params">(<span class="type">int</span> semid, <span class="type">int</span> semnum, <span class="type">int</span> cmd, ...)</span>;</span><br><span class="line"><span class="comment">// 用来控制或销毁信号量</span></span><br></pre></td></tr></table></figure>

<ul>
<li>semnum:信号量数组下标</li>
<li>cmd: 可选的宏。常用的由IPC_RMID，表示从系统中删除该信号量集合，SETVAL可以为第几个成员设置值。</li>
<li>…: 根据不同命令设置不同的参数，后面的参数是变长的</li>
</ul>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">semop - semaphore operations</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/types.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/ipc.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/sem.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">semop</span><span class="params">(<span class="type">int</span> semid, <span class="keyword">struct</span> sembuf *sops, <span class="type">unsigned</span> nsops)</span>;</span><br><span class="line"><span class="comment">// 操作信号量。由于多个信号量可以组成数组。sops参数是数组的起始位置，nspos是指定数组的长度</span></span><br><span class="line"><span class="comment">// 成功返回0，失败返回-1并设置errno</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">sembuf</span> &#123;</span></span><br><span class="line">    <span class="type">unsigned</span> <span class="type">short</span> sem_num; <span class="comment">/* 对第几个资源（数组下标）操作 */</span></span><br><span class="line">    <span class="type">short</span> sem_op; <span class="comment">/* 取几个资源写负数几(不要写减等于)，归还几个资源就写正数几 */</span></span><br><span class="line">    <span class="type">short</span> sem_flg; <span class="comment">/* 特殊要求 */</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>信号量实际上是一个计数器，所以每次在使用资源之前，我们需要扣减信号量，当信号量被减到0时会阻塞等待。每次使用完成资源后，归还信号量，也就是增加信号量的数值</p>
<p>通过操作信号量的函数实现一个通过信号量实现互斥量的例子</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;../include/apue.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/wait.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/types.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/ipc.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/sem.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;errno.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> PROCNUM 20</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> FNAME <span class="string">&quot;./test.txt&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> BUFSIZE 1024</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 多个函数都要使用这个信号量ID，所以定义为全局变量</span></span><br><span class="line"><span class="type">static</span> <span class="type">int</span> semid;</span><br><span class="line"></span><br><span class="line"><span class="comment">// P操作</span></span><br><span class="line"><span class="type">static</span> <span class="type">void</span> <span class="title function_">P</span><span class="params">(<span class="type">void</span>)</span>&#123;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">sembuf</span> <span class="title">op</span>;</span></span><br><span class="line">    op.sem_num = <span class="number">0</span>; <span class="comment">// 只有一个资源所以数组下标是0</span></span><br><span class="line">    op.sem_op = <span class="number">-1</span>; <span class="comment">// 取一个资源就减1</span></span><br><span class="line">    op.sem_flg = <span class="number">0</span>; <span class="comment">// 没有特殊要求</span></span><br><span class="line">    <span class="keyword">while</span>(semop(semid,&amp;op,<span class="number">1</span>)&lt;<span class="number">0</span>)&#123;</span><br><span class="line">        <span class="keyword">if</span>(errno != EINTR &amp;&amp; errno!=EAGAIN) err_sys(<span class="string">&quot;semop()&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// V操作</span></span><br><span class="line"><span class="type">static</span> <span class="type">void</span> <span class="title function_">V</span><span class="params">(<span class="type">void</span>)</span>&#123;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">sembuf</span> <span class="title">op</span>;</span></span><br><span class="line">    op.sem_num = <span class="number">0</span>;</span><br><span class="line">    op.sem_op = <span class="number">1</span>;</span><br><span class="line">    op.sem_flg = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">while</span>(semop(semid,&amp;op,<span class="number">1</span>)&lt;<span class="number">0</span>)&#123;</span><br><span class="line">        <span class="keyword">if</span>(errno != EINTR &amp;&amp; errno != EAGAIN) err_sys(<span class="string">&quot;semop()&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">static</span> <span class="type">void</span> <span class="title function_">func_add</span><span class="params">()</span>&#123;</span><br><span class="line">    FILE *fp;</span><br><span class="line">    <span class="type">char</span> buf[BUFSIZE];</span><br><span class="line">    fp = fopen(FNAME,<span class="string">&quot;r+&quot;</span>);</span><br><span class="line">    <span class="keyword">if</span>(fp == <span class="literal">NULL</span>) err_sys(<span class="string">&quot;fopen()&quot;</span>);</span><br><span class="line">    <span class="comment">// 先取得信号量再操作文件，取不到就阻塞等待，避免发生竞争</span></span><br><span class="line">    P();</span><br><span class="line">    fgets(buf,BUFSIZE,fp); <span class="comment">// 获取一行字符串</span></span><br><span class="line">    rewind(fp); <span class="comment">// 从头指针开始</span></span><br><span class="line">    sleep(<span class="number">1</span>); <span class="comment">// 放大竞争</span></span><br><span class="line">    <span class="built_in">fprintf</span>(fp,<span class="string">&quot;%d\n&quot;</span>,atoi(buf)+<span class="number">1</span>);</span><br><span class="line">    fflush(fp);</span><br><span class="line">    <span class="comment">// 操作结束，归还信号量，让其他进程可以取得信号量</span></span><br><span class="line">    V();</span><br><span class="line">    fclose(fp);</span><br><span class="line">    <span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span>&#123;</span><br><span class="line">    <span class="type">int</span> i;</span><br><span class="line">    <span class="type">pid_t</span> pid;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 在具有亲缘关系的进程之间使用，所以设置为IPC_PRIVATE</span></span><br><span class="line">    <span class="comment">// 另外想要实现互斥量的效果，所以信号量数量设置为1个即可</span></span><br><span class="line">    semid = semget(IPC_PRIVATE,<span class="number">1</span>,<span class="number">0600</span>);</span><br><span class="line">    <span class="keyword">if</span>(semid&lt;<span class="number">0</span>) err_sys(<span class="string">&quot;semget()&quot;</span>);</span><br><span class="line">    <span class="comment">// 将union semun.val的值设置为1</span></span><br><span class="line">    <span class="keyword">if</span>(semctl(semid,<span class="number">0</span>,SETVAL,<span class="number">1</span>)&lt;<span class="number">0</span>) err_sys(<span class="string">&quot;semctl()&quot;</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 创建20个子进程</span></span><br><span class="line">    <span class="keyword">for</span>(i = <span class="number">0</span>;i&lt;PROCNUM;i++)&#123;</span><br><span class="line">        pid = fork();</span><br><span class="line">        <span class="keyword">if</span>(pid&lt;<span class="number">0</span>) err_sys(<span class="string">&quot;fork()&quot;</span>);</span><br><span class="line">        <span class="keyword">if</span>(pid == <span class="number">0</span>)&#123;</span><br><span class="line">            func_add();</span><br><span class="line">            <span class="built_in">exit</span>(<span class="number">0</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span>(i = <span class="number">0</span>;i&lt;PROCNUM;i++) wait(<span class="literal">NULL</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 销毁信号量</span></span><br><span class="line">    semctl(semid,<span class="number">0</span>,IPC_RMID);</span><br><span class="line">    <span class="built_in">exit</span>(<span class="number">0</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="共享存储-shmget"><a href="#共享存储-shmget" class="headerlink" title="共享存储 shmget"></a>共享存储 shmget</h2><p>XSI的共享内存，一样按命名规则来</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">shmget - allocates a shared memory segment</span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/ipc.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/shm.h&gt;</span></span></span><br><span class="line"><span class="type">int</span> <span class="title function_">shmget</span><span class="params">(<span class="type">key_t</span> key,<span class="type">size_t</span> size,<span class="type">int</span> shmflg)</span>;</span><br><span class="line"><span class="comment">// 成功返回shm ID；失败，返回-1</span></span><br></pre></td></tr></table></figure>

<ul>
<li>key: 共享内存的唯一标识，具有亲缘关系的进程之间使用共享内存可以使用IPC_PRIVATE宏代替</li>
<li>size: 是共享内存大小</li>
<li>shmflg: IPC_CREAT表示创建shm，同时需要按位或一个权限，如果是&#x3D;匿名IPC就无须指定这个宏，直接给权限就好</li>
</ul>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">shmat - shared memory operations</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/types.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/shm.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">void</span> *<span class="title function_">shmat</span><span class="params">(<span class="type">int</span> shmid, <span class="type">const</span> <span class="type">void</span> *shmaddr, <span class="type">int</span> shmflg)</span>;</span><br><span class="line"><span class="type">int</span> <span class="title function_">shmdt</span><span class="params">(<span class="type">const</span> <span class="type">void</span> *shmaddr)</span>;</span><br></pre></td></tr></table></figure>

<p>shmat使进程与共享内存关联起来。shmat函数中的shmaddr参数是共享内存的起始地址，传入NULL由内核帮我们寻找合适的地址。一般情况我们都是传入NULL值。</p>
<p>shmdt函数用于使进程分离共享内存，共享内存使用完毕之后需要用这个函数分离。分离不代表释放了这块空间，使用共享内存的双方依然要遵守”谁申请，谁释放“的原则。没有申请的一方是不需要释放的，但是双方都需要分离。</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">shmctl - shared memory control</span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/ipc.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/shm.h&gt;</span></span></span><br><span class="line"><span class="type">int</span> <span class="title function_">shmctl</span><span class="params">(<span class="type">int</span> shmid,<span class="type">int</span> cmd,<span class="keyword">struct</span> shmid_ds *buf)</span>;</span><br><span class="line"><span class="comment">// 控制或删除共享内存</span></span><br></pre></td></tr></table></figure>

<p>cmd设置IPC_RMID并且buf参数设置为NULL，就可以删除共享内存</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;../include/apue.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/mman.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;fcntl.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/ipc.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/shm.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/wait.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> MEMSIZE 1024</span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span>&#123;</span><br><span class="line">    <span class="type">char</span> *str;</span><br><span class="line">    <span class="type">pid_t</span> pid;</span><br><span class="line">    <span class="type">int</span> shmid;</span><br><span class="line">    <span class="comment">// 有亲缘关系的进程key参数可以使用IPC_PRIVATE宏，并且创建共享内存</span></span><br><span class="line">    <span class="comment">// shmflg参数不需要使用IPC_CREAT宏</span></span><br><span class="line">    shmid = shmget(IPC_PRIVATE,MEMSIZE,<span class="number">0600</span>);</span><br><span class="line">    <span class="keyword">if</span>(shmid &lt; <span class="number">0</span>) err_sys(<span class="string">&quot;shmget()&quot;</span>);</span><br><span class="line">    <span class="keyword">if</span>((pid = fork())&lt;<span class="number">0</span>) err_sys(<span class="string">&quot;fork()&quot;</span>);</span><br><span class="line">    <span class="keyword">if</span>(pid==<span class="number">0</span>)&#123;<span class="comment">// 子进程</span></span><br><span class="line">        <span class="comment">// 关联共享内存</span></span><br><span class="line">        str = shmat(shmid,<span class="literal">NULL</span>,<span class="number">0</span>);</span><br><span class="line">        <span class="keyword">if</span>(str == (<span class="type">void</span>*)<span class="number">-1</span>) err_sys(<span class="string">&quot;shmat()&quot;</span>);</span><br><span class="line">        <span class="comment">// 向共享内存写入数据</span></span><br><span class="line">        <span class="built_in">strcpy</span>(str,<span class="string">&quot;hello!&quot;</span>);</span><br><span class="line">        <span class="comment">// 分离共享内存</span></span><br><span class="line">        shmdt(str);</span><br><span class="line">        <span class="comment">// 无需释放</span></span><br><span class="line">        <span class="built_in">exit</span>(<span class="number">0</span>);</span><br><span class="line">    &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">        <span class="comment">// 等待子进程结束后再运行，需要读取子进程写入的共享内存的数据</span></span><br><span class="line">        wait(<span class="literal">NULL</span>);</span><br><span class="line">        <span class="comment">// 关联共享内存</span></span><br><span class="line">        str = shmat(shmid,<span class="literal">NULL</span>,<span class="number">0</span>);</span><br><span class="line">        <span class="keyword">if</span>(str == (<span class="type">void</span> *)<span class="number">-1</span>) err_sys(<span class="string">&quot;shmat()&quot;</span>);</span><br><span class="line">        <span class="comment">// 打印读出来的数据</span></span><br><span class="line">        <span class="built_in">puts</span>(str);</span><br><span class="line">        <span class="comment">// 分离共享内存</span></span><br><span class="line">        shmdt(str);</span><br><span class="line">        <span class="comment">// 释放共享内存 回收寺院</span></span><br><span class="line">        shmctl(shmid,IPC_RMID,<span class="literal">NULL</span>);</span><br><span class="line">        <span class="built_in">exit</span>(<span class="number">0</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">exit</span>(<span class="number">0</span>);</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>




]]></content>
      <categories>
        <category>linux-doc 进程管理</category>
      </categories>
      <tags>
        <tag>Linux</tag>
      </tags>
  </entry>
  <entry>
    <title>Linux 常用查看系统信息命令</title>
    <url>/2023/01/15/%E5%B5%8C%E5%85%A5%E5%BC%8F/linux%E5%BC%80%E5%8F%91/Linux-%E5%B8%B8%E7%94%A8%E6%9F%A5%E7%9C%8B%E7%B3%BB%E7%BB%9F%E4%BF%A1%E6%81%AF%E5%91%BD%E4%BB%A4/</url>
    <content><![CDATA[<h2 id="常用命令"><a href="#常用命令" class="headerlink" title="常用命令"></a>常用命令</h2><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="built_in">uname</span> -a <span class="comment"># 查看内核/操作系统/CPU信息</span></span><br><span class="line"><span class="built_in">head</span> -n 1 /etc/issue <span class="comment"># 查看操作系统版本 </span></span><br><span class="line"><span class="built_in">cat</span> /proc/cpuinfo <span class="comment"># 查看CPU信息 </span></span><br><span class="line">hostname <span class="comment"># 查看计算机名 </span></span><br><span class="line">lspci -tv <span class="comment"># 列出所有PCI设备 </span></span><br><span class="line">lsusb -tv <span class="comment"># 列出所有USB设备 </span></span><br><span class="line">lsmod <span class="comment"># 列出加载的内核模块 </span></span><br><span class="line"><span class="built_in">env</span> <span class="comment"># 查看环境变量资源 </span></span><br><span class="line">free -m <span class="comment"># 查看内存使用量和交换区使用量 </span></span><br><span class="line"><span class="built_in">df</span> -h <span class="comment"># 查看各分区使用情况 </span></span><br><span class="line"><span class="built_in">du</span> -sh &lt;目录名&gt; <span class="comment"># 查看指定目录的大小 </span></span><br><span class="line">grep MemTotal /proc/meminfo <span class="comment"># 查看内存总量 </span></span><br><span class="line">grep MemFree /proc/meminfo <span class="comment"># 查看空闲内存量 </span></span><br><span class="line"><span class="built_in">uptime</span> <span class="comment"># 查看系统运行时间、用户数、负载 </span></span><br><span class="line"><span class="built_in">cat</span> /proc/loadavg <span class="comment"># 查看系统负载磁盘和分区 </span></span><br><span class="line">mount | column -t <span class="comment"># 查看挂接的分区状态 </span></span><br><span class="line">fdisk -l <span class="comment"># 查看所有分区 </span></span><br><span class="line">swapon -s <span class="comment"># 查看所有交换分区 </span></span><br><span class="line">hdparm -i /dev/hda <span class="comment"># 查看磁盘参数(仅适用于IDE设备) </span></span><br><span class="line">dmesg | grep IDE <span class="comment"># 查看启动时IDE设备检测状况网络 </span></span><br><span class="line">ifconfig <span class="comment"># 查看所有网络接口的属性 </span></span><br><span class="line">iptables -L <span class="comment"># 查看防火墙设置 </span></span><br><span class="line">route -n <span class="comment"># 查看路由表 </span></span><br><span class="line">netstat -lntp <span class="comment"># 查看所有监听端口 </span></span><br><span class="line">netstat -antp <span class="comment"># 查看所有已经建立的连接 </span></span><br><span class="line">netstat -s <span class="comment"># 查看网络统计信息进程 </span></span><br><span class="line">ps -ef <span class="comment"># 查看所有进程 </span></span><br><span class="line">top <span class="comment"># 实时显示进程状态用户 </span></span><br><span class="line">w <span class="comment"># 查看活动用户 </span></span><br><span class="line"><span class="built_in">id</span> &lt;用户名&gt; <span class="comment"># 查看指定用户信息 </span></span><br><span class="line">last <span class="comment"># 查看用户登录日志 </span></span><br><span class="line"><span class="built_in">cut</span> -d: -f1 /etc/passwd <span class="comment"># 查看系统所有用户 </span></span><br><span class="line"><span class="built_in">cut</span> -d: -f1 /etc/group <span class="comment"># 查看系统所有组 </span></span><br><span class="line">crontab -l <span class="comment"># 查看当前用户的计划任务服务 </span></span><br><span class="line">chkconfig –list <span class="comment"># 列出所有系统服务 </span></span><br><span class="line">chkconfig –list | grep on <span class="comment"># 列出所有启动的系统服务程序 </span></span><br><span class="line">rpm -qa <span class="comment"># 查看所有安装的软件包</span></span><br></pre></td></tr></table></figure>

<h4 id="查看linux系统版本信息（Oracle-Linux、Centos-Linux、Redhat-Linux、Debian、Ubuntu）"><a href="#查看linux系统版本信息（Oracle-Linux、Centos-Linux、Redhat-Linux、Debian、Ubuntu）" class="headerlink" title="查看linux系统版本信息（Oracle Linux、Centos Linux、Redhat Linux、Debian、Ubuntu）"></a>查看linux系统版本信息（Oracle Linux、Centos Linux、Redhat Linux、Debian、Ubuntu）</h4><p>一、查看Linux系统版本的命令（3种方法）</p>
<p>1、此命令也适用于所有的Linux发行版：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="built_in">cat</span> /etc/issue</span><br></pre></td></tr></table></figure>
<p>2、这种方法只适合Redhat系的Linux：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="built_in">cat</span> /etc/redhat-release</span><br></pre></td></tr></table></figure>
<p> 3、列出所有版本信息：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">lsb_release -a</span><br></pre></td></tr></table></figure>

<p> 二、查看Linux内核版本命令（两种方法）：</p>
<p>1、此命令也适用于所有的Linux发行版：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="built_in">cat</span> /proc/version</span><br></pre></td></tr></table></figure>
<p>2、此命令也适用于所有的Linux发行版：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="built_in">uname</span> -a</span><br></pre></td></tr></table></figure>

<p>一、linux CPU大小</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="built_in">cat</span> /proc/cpuinfo |grep <span class="string">&quot;model name&quot;</span> &amp;&amp; <span class="built_in">cat</span> /proc/cpuinfo |grep <span class="string">&quot;physical id&quot;</span></span><br></pre></td></tr></table></figure>
<blockquote>
<p>说明：Linux下可以在&#x2F;proc&#x2F;cpuinfo中看到每个cpu的详细信息。但是对于双核的cpu，在cpuinfo中会看到两个cpu。常常会让人误以为是两个单核的cpu。<br>其实应该通过Physical Processor ID来区分单核和双核。而Physical Processor ID可以从cpuinfo或者dmesg中找到. flags 如果有 ht 说明支持超线程技术 判断物理CPU的个数可以查看physical id 的值</p>
</blockquote>
<p>二、内存大小</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="built_in">cat</span> /proc/meminfo |grep MemTotal</span><br></pre></td></tr></table></figure>

<p>三、硬盘大小</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">fdisk -l |grep Disk</span><br></pre></td></tr></table></figure>

<p>四、查看内核&#x2F;操作系统&#x2F;CPU信息的linux系统信息命令 </p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="built_in">uname</span> -a </span><br></pre></td></tr></table></figure>

<p>五、查看操作系统版本，是数字1不是字母L</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="built_in">head</span> -n 1 /etc/issue </span><br></pre></td></tr></table></figure>

<p>六、查看CPU信息的linux系统信息命令</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="built_in">cat</span> /proc/cpuinfo </span><br></pre></td></tr></table></figure>

<p>七、查看计算机名的linux系统信息命令</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">hostname</span><br></pre></td></tr></table></figure>

<p>八、列出所有PCI设备</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">lspci -tv </span><br></pre></td></tr></table></figure>

<p>九、列出所有USB设备的linux系统信息命令</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">lsusb -tv </span><br></pre></td></tr></table></figure>

<p>十、列出加载的内核模块</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">lsmod </span><br></pre></td></tr></table></figure>

<p>十一、查看环境变量资源</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="built_in">env</span></span><br></pre></td></tr></table></figure>

<p>十二、查看内存使用量和交换区使用量</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">free -m</span><br></pre></td></tr></table></figure>

<p>十三、查看各分区使用情况</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="built_in">df</span> -h</span><br></pre></td></tr></table></figure>

<p>十四、查看指定目录的大小</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="built_in">du</span> -sh</span><br></pre></td></tr></table></figure>

<p>十五、查看内存总量</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">grep MemTotal /proc/meminfo</span><br></pre></td></tr></table></figure>

<p>十六、查看空闲内存量</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">grep MemFree /proc/meminfo </span><br></pre></td></tr></table></figure>

<p>十七、查看系统运行时间、用户数、负载</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="built_in">uptime</span></span><br></pre></td></tr></table></figure>

<p>十八、查看系统负载磁盘和分区</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="built_in">cat</span> /proc/loadavg</span><br></pre></td></tr></table></figure>

<p>十九、查看挂接的分区状态</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">mount | column -t</span><br></pre></td></tr></table></figure>

<p>二十、查看所有分区</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">fdisk -l</span><br></pre></td></tr></table></figure>

<p>二十一、查看所有交换分区</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">swapon -s</span><br></pre></td></tr></table></figure>

<p>二十二、查看磁盘参数(仅适用于IDE设备)</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">hdparm -i /dev/hda</span><br></pre></td></tr></table></figure>

<p>二十三、查看启动时IDE设备检测状况网络</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">dmesg | grep IDE</span><br></pre></td></tr></table></figure>

<p>二十四、查看所有网络接口的属性</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">ifconfig</span><br></pre></td></tr></table></figure>

<p>二十五、查看防火墙设置</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">iptables -L</span><br></pre></td></tr></table></figure>

<p>二十六、查看路由表</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">route -n</span><br></pre></td></tr></table></figure>

<p>二十七、查看所有监听端口</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">netstat -lntp </span><br></pre></td></tr></table></figure>

<p>二十八、查看所有已经建立的连接</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">netstat -antp</span><br></pre></td></tr></table></figure>

<p>二十九、查看网络统计信息进程</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">netstat -s</span><br></pre></td></tr></table></figure>

<p>三十、查看所有进程</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">ps -ef</span><br></pre></td></tr></table></figure>

<p>三十一、实时显示进程状态用户</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">top</span><br></pre></td></tr></table></figure>

<p>三十二、查看活动用户</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">w </span><br></pre></td></tr></table></figure>

<p>三十三、查看指定用户信息</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="built_in">id</span> </span><br></pre></td></tr></table></figure>

<p>三十四、查看用户登录日志</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">last</span><br></pre></td></tr></table></figure>

<p>三十五、查看系统所有用户</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="built_in">cut</span> -d: -f1 /etc/passwd</span><br></pre></td></tr></table></figure>

<p>三十六、查看系统所有组</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="built_in">cut</span> -d: -f1 /etc/group</span><br></pre></td></tr></table></figure>

<p>三十七、查看当前用户的计划任务服务</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">crontab -l </span><br></pre></td></tr></table></figure>

<p>三十七、列出所有系统服务</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">chkconfig –list</span><br></pre></td></tr></table></figure>

<p>三十八、列出所有启动的系统服务程序</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">chkconfig –list | grep on</span><br></pre></td></tr></table></figure>

<p>三十九、查看所有安装的软件包</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">rpm -qa</span><br></pre></td></tr></table></figure>

<p>四十、查看CPU相关参数的linux系统命令</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="built_in">cat</span> /proc/cpuinfo</span><br></pre></td></tr></table></figure>

<p>四十一、查看linux硬盘和分区信息的系统信息命令</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="built_in">cat</span> /proc/partitions</span><br></pre></td></tr></table></figure>

<p>四十二、查看linux系统内存信息的linux系统命令</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="built_in">cat</span> /proc/meminfo</span><br></pre></td></tr></table></figure>

<p>四十三、查看版本，类似uname -r</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="built_in">cat</span> /proc/version</span><br></pre></td></tr></table></figure>

<p>四十四、查看设备io端口</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="built_in">cat</span> /proc/ioports</span><br></pre></td></tr></table></figure>

<p>四十五、查看中断</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="built_in">cat</span> /proc/interrupts </span><br></pre></td></tr></table></figure>

<p>四十六、查看pci设备的信息</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="built_in">cat</span> /proc/pci</span><br></pre></td></tr></table></figure>

<p>四十七、查看所有swap分区的信息</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="built_in">cat</span> /proc/swaps</span><br></pre></td></tr></table></figure>

<p>系统	发行版本	–	内核版本、位数<br>RedHat	</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="built_in">cat</span> /etc/issue	<span class="built_in">cat</span> /etc/redhat-release	lsb_release -a</span><br></pre></td></tr></table></figure>
<p>CentOS	</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="built_in">cat</span> /etc/issue	<span class="built_in">cat</span> /etc/centos-release	<span class="built_in">cat</span> /proc/version</span><br></pre></td></tr></table></figure>
<p>Debian	</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="built_in">cat</span> /etc/issue	<span class="built_in">cat</span> /etc/debian_version	<span class="built_in">cat</span> /proc/version</span><br></pre></td></tr></table></figure>
<p>Ubuntu	</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="built_in">cat</span> /etc/issue	<span class="built_in">cat</span> /etc/lsb_release	<span class="built_in">cat</span> /proc/version</span><br></pre></td></tr></table></figure>
<p>Oracle	</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="built_in">cat</span> /etc/issue	<span class="built_in">cat</span> /etc/oracle-release	lsb_release -a</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>嵌入式</category>
        <category>linux开发</category>
      </categories>
      <tags>
        <tag>Linux常用命令</tag>
      </tags>
  </entry>
  <entry>
    <title>x86 Ubuntu上建立aarch64/arm64 Ubuntu的交叉编译链</title>
    <url>/2023/01/15/%E5%B5%8C%E5%85%A5%E5%BC%8F/linux%E5%BC%80%E5%8F%91/x86%20Ubuntu%E4%B8%8A%E5%BB%BA%E7%AB%8Baarch64&amp;arm64%20Ubuntu%E7%9A%84%E4%BA%A4%E5%8F%89%E7%BC%96%E8%AF%91%E9%93%BE/</url>
    <content><![CDATA[<h2 id="注意：x86-Ubuntu下构建的aarch64-Ubuntu版本需要和程序最终运行的aarch64-Ubuntu的版本保持一致（如果x86-Ubuntu版本和构建的aarch64-Ubuntu版本一致，安装aarch64的编译工具会简单一些，直接apt-install。本文以Ubuntu-20-04-03举例）。"><a href="#注意：x86-Ubuntu下构建的aarch64-Ubuntu版本需要和程序最终运行的aarch64-Ubuntu的版本保持一致（如果x86-Ubuntu版本和构建的aarch64-Ubuntu版本一致，安装aarch64的编译工具会简单一些，直接apt-install。本文以Ubuntu-20-04-03举例）。" class="headerlink" title="注意：x86 Ubuntu下构建的aarch64 Ubuntu版本需要和程序最终运行的aarch64 Ubuntu的版本保持一致（如果x86 Ubuntu版本和构建的aarch64 Ubuntu版本一致，安装aarch64的编译工具会简单一些，直接apt install。本文以Ubuntu 20.04.03举例）。"></a>注意：x86 Ubuntu下构建的aarch64 Ubuntu版本需要和程序最终运行的aarch64 Ubuntu的版本保持一致（如果x86 Ubuntu版本和构建的aarch64 Ubuntu版本一致，安装aarch64的编译工具会简单一些，直接apt install。本文以Ubuntu 20.04.03举例）。</h2><p>准备aarch64（即arm64）的文件系统rootfs；<br>从<a href="http://cdimage.ubuntu.com/ubuntu-base/releases/%E4%B8%8B%E8%BD%BD%E5%AF%B9%E5%BA%94%E7%89%88%E6%9C%AC%E7%9A%84base%E9%95%9C%E5%83%8F%EF%BC%8C%E4%B9%8B%E5%90%8E%E5%B0%86%E5%9F%BA%E4%BA%8E%E6%AD%A4%E9%95%9C%E5%83%8F%E6%9E%84%E5%BB%BA%E7%BC%96%E8%AF%91%E7%8E%AF%E5%A2%83%EF%BC%9B">http://cdimage.ubuntu.com/ubuntu-base/releases/下载对应版本的base镜像，之后将基于此镜像构建编译环境；</a></p>
<p>在x86 Ubuntu上新建一个rootfs目录，并将下载的base镜像解压到该目录；</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ <span class="built_in">mkdir</span> /path/to/rootfs</span><br><span class="line">$ tar -zxf ubuntu-base-20.04.3-base-arm64.tar.gz -C /path/to/rootfs</span><br></pre></td></tr></table></figure>

<p>在x86 Ubuntu上安装chroot到&#x2F;path&#x2F;to&#x2F;rootfs所必须的软件（正常情况，因为可执行程序被编译目标架构不同，在x86 Ubuntu上无法执行aarch64 Ubuntu上的命令，也就无法在x86 Ubuntu上给aarch64 Ubuntu以apt的方式安装程序。然而qemu可以在x86 Ubuntu上构建一个aarch64 Ubuntu的运行环境，帮我们解决这个问题）；</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ sudo apt-get install qemu qemu-user-static binfmt-support debootstrap</span><br></pre></td></tr></table></figure>

<p>注册aarch64的运行环境（可以通过update-binfmts –display查看当前x86 Ubuntu上的注册情况）；</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ sudo update-binfmts --<span class="built_in">enable</span> qemu-aarch64</span><br></pre></td></tr></table></figure>

<p>为了能在x86 Ubuntu上chroot到&#x2F;path&#x2F;to&#x2F;rootfs并执行aarch64的程序，还需要将qemu-aarch64-static拷贝到&#x2F;path&#x2F;to&#x2F;rootfs&#x2F;usr&#x2F;bin&#x2F;；</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ sudo <span class="built_in">cp</span> -av /usr/bin/qemu-aarch64-static /path/to/rootfs/usr/bin/</span><br></pre></td></tr></table></figure>

<p>配置arrch64 Ubuntu的网关；</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ <span class="built_in">cp</span> /etc/resolv.conf /path/to/rootfs/etc/resolv.conf</span><br></pre></td></tr></table></figure>
<p>chroot到aarch64 Ubuntu的rootfs，并安装开发库。</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ sudo <span class="built_in">chroot</span> /path/to/rootfs</span><br><span class="line"><span class="comment"># apt update &amp;&amp; apt install -y libopencv-dev</span></span><br></pre></td></tr></table></figure>

<p>准备x86上aarch64的编译工具。</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">sudo apt-get install gcc-aarch64-linux-gnu g++-aarch64-linux-gnu</span><br></pre></td></tr></table></figure>

<h4 id="之后做arm程序开发，需要使用第三方库，只需要chroot到rootfs中安装，并通过配置CMakeLists-txt告诉CLion去-path-to-rootfs寻库和去-寻aarch64的编译工具gcc、g-就OK了。这样，在x86-Ubuntu上编译的aarch64程序就能在对应版本的aarch64-Ubuntu上运行了。"><a href="#之后做arm程序开发，需要使用第三方库，只需要chroot到rootfs中安装，并通过配置CMakeLists-txt告诉CLion去-path-to-rootfs寻库和去-寻aarch64的编译工具gcc、g-就OK了。这样，在x86-Ubuntu上编译的aarch64程序就能在对应版本的aarch64-Ubuntu上运行了。" class="headerlink" title="之后做arm程序开发，需要使用第三方库，只需要chroot到rootfs中安装，并通过配置CMakeLists.txt告诉CLion去&#x2F;path&#x2F;to&#x2F;rootfs寻库和去&#x2F;寻aarch64的编译工具gcc、g++就OK了。这样，在x86 Ubuntu上编译的aarch64程序就能在对应版本的aarch64 Ubuntu上运行了。"></a>之后做arm程序开发，需要使用第三方库，只需要chroot到rootfs中安装，并通过配置CMakeLists.txt告诉CLion去&#x2F;path&#x2F;to&#x2F;rootfs寻库和去&#x2F;寻aarch64的编译工具gcc、g++就OK了。这样，在x86 Ubuntu上编译的aarch64程序就能在对应版本的aarch64 Ubuntu上运行了。</h4>]]></content>
      <categories>
        <category>嵌入式</category>
        <category>linux开发</category>
      </categories>
      <tags>
        <tag>Linux交叉编译</tag>
      </tags>
  </entry>
  <entry>
    <title>Git 快速入门指南</title>
    <url>/2023/03/22/%E5%B7%A5%E5%85%B7/git/git%E5%BF%AB%E9%80%9F%E5%85%A5%E9%97%A8/</url>
    <content><![CDATA[<h4 id="列表"><a href="#列表" class="headerlink" title="列表"></a>列表</h4><ul>
<li><a href="#init">init</a></li>
<li><a href="#add">add</a></li>
<li><a href="#status">status</a></li>
<li><a href="#diff">diff</a></li>
<li><a href="#show">show</a></li>
<li><a href="#log">log</a></li>
<li><a href="#difftool">difftool</a></li>
<li><a href="#apply">apply</a></li>
<li><a href="#cherry-pick">cherry-pick</a></li>
<li><a href="#merge">merge</a></li>
<li><a href="#rebase">rebase</a></li>
<li><a href="#commit">commit</a></li>
<li><a href="#reset">reset</a></li>
<li><a href="#stash">stash</a></li>
<li><a href="#worktree">worktree</a></li>
<li><a href="#revert">revert</a></li>
<li><a href="#clone">clone</a></li>
<li><a href="#remote">remote</a></li>
<li><a href="#fetch">fetch</a></li>
<li><a href="#pull">pull</a></li>
<li><a href="#push">push</a></li>
<li><a href="#branch">branch</a></li>
<li><a href="#checkout">checkout</a></li>
<li><a href="#restore">restore</a></li>
<li><a href="#tag">tag</a></li>
<li><a href="#rerere">rerere</a></li>
<li><a href="#bisect">bisect</a></li>
<li><a href="#blame">blame</a></li>
<li><a href="#clean">clean</a></li>
<li><a href="#%E5%92%8C">~和^</a></li>
</ul>
<h2 id="init"><a href="#init" class="headerlink" title="init"></a>init</h2><p>创建一个空的Git仓库或重新<a href="https://so.csdn.net/so/search?q=%E5%88%9D%E5%A7%8B%E5%8C%96&spm=1001.2101.3001.7020">初始化</a>已有仓库<br>该命令创建一个空的Git存储库 - 本质上是一个 .git 目录，其中包含 objects、<a href="https://so.csdn.net/so/search?q=refs&spm=1001.2101.3001.7020">refs</a>&#x2F;heads、refs&#x2F;tags 和模板文件的子目录。将创建一个没有任何提交的初始分支，还将创建一个引用master分支 HEAD 的初始 HEAD 文件。<br>如果设置了 $GIT_DIR 环境变量，则会指定一个路径，而不是 .&#x2F;.git 作为版本库的基础。<br>如果通过 $GIT_OBJECT_DIRECTORY 环境变量指定了对象存储目录，那么 sha1 目录就会在其下创建；否则，就会使用默认的 $GIT_DIR&#x2F;objects 目录。<br>在现有版本库中运行 git init 是安全的。它不会覆盖已有的内容。重新运行 git init 的主要原因是为了拾取新添加的模板（或者如果给定了 –separate-git-dir 则是为了将仓库移到另一个地方）。<br><code>--bare</code>创建裸仓库。如果未设置 GIT_DIR 环境，则将其设置为当前工作目录。<br><code>--object-format=&lt;format&gt;</code>指定存储库的对象格式（哈希算法）。有效值为 sha1 和（如果启用）sha256。sha1 是默认值。<br><code>--template=&lt;template-directory&gt;</code>指定要使用模板的目录，默认模板目录：&#x2F;usr&#x2F;share&#x2F;git-core&#x2F;templates。模板目录中名称不以点开头的文件和目录将在创建后复制到 $GIT_DIR 中。默认模板目录包括一些目录结构、建议的 “排除模式” 和示例钩子文件；默认情况下，所有示例钩子都是禁用的。要启用其中一个示例钩子，可移除其 .sample 后缀，重命名该示例钩子。<br><code>[-b &lt;branch-name&gt; | --initial-branch=&lt;branch-name&gt;]</code>在新创建的仓库中为初始分支指定名称。如果没有指定，则使用默认名称：master。</p>
<pre><code>git init /* 初始化目录的版本控制，当前目录创建一个名为.git的子目录 */
git init demo /* 指定目录完成创建 */
</code></pre>
<h2 id="add"><a href="#add" class="headerlink" title="add"></a>add</h2><p>该命令使用工作树中的当前内容更新索引，为下一次提交做好准备。它通常会将现有路径的当前内容作为一个整体添加到索引中，但也可以通过一些选项，在添加内容时只应用对工作树文件所做的部分修改，或删除工作树中已不存在的路径。<br><code>[--interactive | -i]</code>以交互方式将工作树中修改过的内容添加到索引中。可以提供可选的路径参数，将操作限制在工作树的子集。详情请参阅 “交互模式”。<br><code>[--patch | -p]</code>交互地在索引和工作树之间选择补丁块并将它们添加到索引中。这让用户有机会在将修改后的内容添加到索引之前查看差异。这实际上是运行 <code>add --interactive</code> 命令，但绕过了初始命令菜单，直接跳转到 patch 子命令。<br><code>[--update | -u]</code>只更新索引中已匹配 <code>&lt;pathspec&gt;</code> 的条目。这将删除和修改索引条目以匹配工作树，但不会添加新文件。如果使用 -u 选项时没有给出 <code>&lt;pathspec&gt;</code>，则会更新整个工作树中的所有跟踪文件（旧版本的 Git 将更新限制在当前目录及其子目录）。<br><code>[-A |--all |all | --no-ignore-removal]</code><br>不仅在工作树中有与 匹配的文件的地方更新索引，而且在索引中已有条目的地方也更新索引。这将添加、修改和删除索引条目，以匹配工作树。如果在使用 -A 选项时没有 ，则会更新整个工作树中的所有文件（旧版本的 Git 将更新限制在当前目录及其子目录）。<br><code>[--]</code>–此选项可用于分离命令行选项和文件列表（当文件名可能被误认为命令行选项时非常有用）。</p>
<pre><code>git add hello.c /* 将仓库中hello.c添加至暂存区 */
git add . /* 添加当前目录及其子目录下所有文件到暂存区 */
git add -u /* 所有修改，删除的文件加入暂存区 */
git add -A /* 本地修改，删除，新增文件都加入暂存区 */
</code></pre>
<h2 id="status"><a href="#status" class="headerlink" title="status"></a>status</h2><p>显示索引文件和当前 HEAD 提交之间存在差异的路径、工作树和索引文件之间存在差异的路径，以及工作树中未被 Git 跟踪（也未被 gitignore忽略）的路径。<br><code>[-s | --short]</code>以简短的形式给出输出。<br><code>--show-stash</code>显示当前藏匿的条目数量。<br><code>[-v | --verbose]</code>除了显示被修改的文件名外，还显示要已暂存将要提交的文本更改（即类似于 git diff –cached 的输出）。如果<code>-v</code>被指定了两次，那么还显示工作树中尚未暂存的更改（即类似 git diff 的输出）。</p>
<pre><code>git status /* 检查当前文件状态 */
git status -s  /* 简洁的方式查看文件状态 */
</code></pre>
<h2 id="diff"><a href="#diff" class="headerlink" title="diff"></a>diff</h2><p>显示工作树和索引或树之间的变化，索引和树之间的变化，两个树之间的变化，合并产生的变化，两个blob对象之间的变化，或者磁盘上两个文件之间的变化。<br><code>git diff [&lt;options&gt;] [--] [&lt;path&gt;…​]</code>该表单用于查看相对于索引（下一次提交的暂存区域）所做的更改。换句话说，这些差异就是你可以告诉 Git 进一步添加到索引中但尚未添加的内容。您可以使用 <code>git-add</code> 来暂存这些改动。<br><code>git diff [&lt;options&gt;] --cached [--merge-base] [&lt;commit&gt;] [--] [&lt;path&gt;…​]</code>此表单用于查看相对于命名的 <code>&lt;commit&gt;</code> 下次提交的暂存更改。通常情况下，您希望与最新提交进行比较，因此如果您没有给出 <code>&lt;commit&gt;</code>，它就会默认为 HEAD。如果 HEAD 不存在（例如未出生的分支），也没有给出 <code>&lt;commit&gt;</code>，则会显示所有已暂存的变更。<code>--staged</code> 是 <code>--cached</code> 的同义词。<br>如果给出 <code>--merge-base</code>，则不使用 <code>&lt;commit&gt;</code>，而使用 <code>&lt;commit&gt;</code> 和 HEAD 的合并基数。 <code>git diff --cached --merge-base A</code> 等同于 <code>git diff --cached $(git merge-base A HEAD)</code>。<br><code>git diff [&lt;options&gt;] [--merge-base] &lt;commit&gt; [--] [&lt;path&gt;…​]</code>这个表格是用来查看你的工作树中相对于命名为的修改。 您可以使用 HEAD 来与最新的提交进行比较，或者使用分支名称来与不同分支的顶端进行比较。<br>如果给出 <code>--merge-base</code>，则不使用 <code>&lt;commit&gt;</code>，而使用 <code>&lt;commit&gt;</code> 和 HEAD 的合并基数。 <code>git diff --cached --merge-base A</code> 等同于 <code>git diff --cached $(git merge-base A HEAD)</code>。<br><code>git diff [&lt;options&gt;] &lt;commit&gt;..&lt;commit&gt; [--] [&lt;path&gt;…​]</code>这与早先用于查看两个任意 之间的更改的形式（不带 …）是同义的。如果省略一侧的 ，其效果与使用 HEAD 相同。<br><code>git diff [&lt;options&gt;] &lt;blob&gt; &lt;blob&gt;</code>这种形式是为了查看两个blob对象的原始内容之间的差异。<br><code>-p | -u | --patch</code>生成补丁。 这是默认设置。<br><code>-s | --no-patch</code>抑制差异（diff）工具的所有输出。 对于默认显示补丁的 <code>git show</code> 等命令，可以压制其输出，或在别名中取消命令行中的 <code>--patch、--stat</code> 等选项的效果。<br><code>U&lt;n&gt; | --unified=&lt;n&gt;</code>生成带有 <code>&lt;n&gt;</code> 行上下文的差异，而不是通常的 <code>3</code> 行。暗含 <code>--patch</code> 选项。<br><code>--output=&lt;file&gt;</code>输出到一个特定的文件，而不是标准输出。<br><code>--stat[=&lt;width&gt;[,&lt;name-width&gt;[,&lt;count&gt;]]]</code>生成差异统计（diffstat）。默认情况下，文件名部分将使用尽可能多的空间，其余空间用于图表部分。最大宽度默认为终端宽度，如果未连接终端，则为 80 列，可以用 <code>&lt;width&gt;</code>改写。文件名部分的宽度可以通过在逗号后添加宽度 <code>&lt;name-width&gt;</code> 或设置 <code>diff.statNameWidth=&lt;width&gt;</code> 来限制。图形部分的宽度可以通过使用 <code>--stat-graph-width=&lt;width&gt;</code> 或设置 <code>diff.statGraphWidth=&lt;width&gt;</code> 来限制。使用 <code>--stat</code> 或 <code>--stat-graph-width</code> 会影响所有生成统计图的命令，而设置 <code>diff.statNameWidth 或 diff.statGraphWidth</code> 不会影响 <code>git format-patch</code>。通过给出第三个参数 <code>&lt;count&gt;</code>，可以将输出限制在前 <code>&lt;count&gt;</code> 行，如果行数更多，则在后面加上<code>...</code>。<br>这些参数也可以通过 <code>--stat-width=&lt;width&gt;</code>, <code>--stat-name-width=&lt;name-width&gt;</code> 和 <code>--stat-count=&lt;count&gt;</code> 单独设置。<br><code>--numstat</code>与 <code>--stat</code> 类似，但会以十进制形式显示添加和删除的行数，并且路径名不带缩写，使其对机器更友好。对于二进制文件，会输出两个”-“，而不是 0 0。<br><code>ignore-space-at-eol</code>忽略行尾空格的变化。<br><code>ignore-space-change</code>忽略空格数量的变化。这会忽略行尾的空格，并认为包含一个或多个空格字符的其他序列都是等同的。<br><code>ignore-all-space</code>比较行时忽略空格。即使一行有空格而另一行没有空格，也会忽略差异。<br><code>--ignore-cr-at-eol</code>在进行比较时，忽略行末的回车。<br><code>--full-index</code>在生成补丁格式输出时，在 “索引 “行显示完整的图像前和图像后 blob 对象名称，而不是显示前几个字符。<br><code>--binary</code>除了 <code>--full-index</code> 之外，还输出二进制差异，可以用 <code>git-apply</code> 应用。意味着 <code>--patch</code>。<br><code>-S&lt;string&gt;</code>查找改变文件中指定字符串出现次数（即增加&#x2F;删除）的差异。供脚本编写者使用。<br>当您要查找一个精确的代码块（如结构体），并想了解该代码块自首次出现以来的历史时，该功能非常有用：通过 <code>-S</code> 选项迭代，将原文件中的感兴趣的块显示出，并继续进行，直到获得该块的第一个版本。二进制文件也会被搜索到。<br><code>-G&lt;regex&gt;</code>查找补丁文本中包含符合 <code>&lt;regex&gt;</code> 的添加&#x2F;删除行的差异。<br>为了说明 <code>-S&lt;regex&gt; --pickaxe-regex</code> 和 <code>-G&lt;regex&gt;</code> 之间的区别，请考虑同一文件中包含以下差异的提交：</p>
<pre><code>git diff  /* 默认情况下workspace与index的差别 */
git diff --cached /* index和当前分支最新的提交（HEAD）比较 */
git diff HEAD /* workspace和当前分支最新的提交（HEAD）比较 */
git diff --stat=200 HEAD^ /* 显示与上次提交已更改文件的名称和行数，并指定文件名显示宽度 */
git diff origin/master /* 本地master分支与origin/master分支比较，一般在fetch后用 */
/* git diff可以传递Git refs以提交到diff。一些示例引用是、HEAD、标签和分支名称 */
git diff branch1 other-feature-branch /* 两个分支差异 */
git diff main new_branch ./diff_test.txt /* 跨分支比较特定文件，后跟文件路径 */
git diff -p --output=a.diff /* 生成补丁，-p是默认的，可不加；--output=file，也可用重定向&quot;&gt;&quot; */
</code></pre>
<h2 id="show"><a href="#show" class="headerlink" title="show"></a>show</h2><p>显示各种类型（blobs, trees, tags and commits）一个或多个对象<br><code>git show [&lt;options&gt;] [&lt;object&gt;…​]</code></p>
<pre><code>git show commit /* 显示特定提交中更改的代码 */
git show stash@&#123;0&#125; /* 查看一个 stash 中的内容 */
git show commit  --stat /* 显示差异文件的统计 */
</code></pre>
<h2 id="log"><a href="#log" class="headerlink" title="log"></a>log</h2><p>查看历史提交记录</p>
<pre><code>git log /* 查看提交记录 */
git log --stat /* 查看每次提交的文件变更 */
git log -p /* 显示每次提交所引入的差异（按补丁的格式输出 */
git log --pretty=oneline /* 精简输出来显示日志，每个提交放在一行显示*/
git log --pretty=--graph /* ASCII 图形显示分支与合并历史 */
git log --pretty=fuller /* 更完整的格式显示 */
git log --author=&quot;abc&quot; /* 显示指定的作者的提交 */
git log --committer=&quot;abc&quot; /* 显示指定的提交者的提交 */
git log --after=&quot;2020.01.01 00:00:00&quot; --before=&quot;2020.01.03 00:00:00&quot;/* 显示指定时间段的提交 */
git log &lt;since&gt;..&lt;until&gt; /* 显示在&lt;since&gt;和&lt;until&gt;之间发生的提交 */
git log -S &quot;function&quot; /* 显示添加或删除内容当中有function字符串的提交 */
git log --grep &quot;socket&quot; /* 显示提交说明中包含socket字符串的提交 */
git log --reverse /* 以相反的顺序输出要显示的提交 */
git log --format=fuller /* 以更全的方式显示log */
</code></pre>
<h2 id="difftool"><a href="#difftool" class="headerlink" title="difftool"></a>difftool</h2><p>difftool是git版本管理工具中的一个内容差异比较器，通过参数设置可以配置调用其它可视化工具</p>
<pre><code>git difftool --tool-help /* 查看支持的git diff的插件*/
git mergetool --tool-help /* 查看支持的git merge插件 */
git difftool t bc4 /* 以指定工具对比 */
git config --global merge.tool bc4 /* mergetool 的默认工具配置成 bc4 */
/* 指定了工具 bc4 的调用路径和参数 依次代表本地修改，被合并分支修改，两端未修改前版本文件，最终合并导出的文本文件 */
git config --global mergetool.bc4.cmd &#39;\&quot;D:\Beyond Compare 4\BComp.exe\&quot; &quot;$LOCAL&quot; &quot;$REMOTE&quot; &quot;$BASE&quot; &quot;$MERGED&quot;&#39;
 /* 设置为 true 表示信任软件的返回码，并依据返回码确定合并是否成功，如果设置成 false 就会在合并完成后问你是否解决完冲突*/
git config --global mergetool.bc4.trustExitCode true
git config --global mergetool.keepBackup false /* 指定在合并完成后删除调用 git mergetool 是产生 *.orig 备份文件 */
git config --global diff.tool bc4
/* $LOCAL和$REMOTE的顺序控制，即左窗格显示哪个文件，右窗格显示哪个文件 */
git config --global difftool.bc4.cmd &#39;&quot;D:\Beyond Compare 4\BComp.exe&quot; &quot;$LOCAL&quot; &quot;$REMOTE&quot;&#39;
git config --global difftool.prompt false /* 每次使用git difftool时会有二次提示，设置可以取消 */
git config --global difftool.trustExitCode true
tips：注意不是&quot;BCompare.exe&quot;这个东西，BCompare.exe 是主程序，BComp.exe 用在版本控制工具中更加优秀
git difftool /* 提交时查看差异修改了什么 */
git mergetool /* 合并时冲突修改 */
</code></pre>
<h2 id="apply"><a href="#apply" class="headerlink" title="apply"></a>apply</h2><p>将修补程序应用于文件或索引，此命令应用修补程序，但不创建提交，推荐使用<code>git-am</code>从<code>git-format-patch</code>生成的补丁或通过电子邮件接收的补丁创建提交。</p>
<pre><code>git apply a.diff --check /* 检测补丁是否适用于当前工作区或索引并检测错误 */
git apply -p1 a.diff /* 应用该补丁， -p1表示忽略/标识的前导目录，与patch -p1 &lt; a.diff 命令几乎相同 */
git apply --cached -p1 a.diff /* 修补程序仅应用于索引 */
</code></pre>
<h2 id="cherry-pick"><a href="#cherry-pick" class="headerlink" title="cherry-pick"></a>cherry-pick</h2><p>遴选，它可以在当前分支应用其他已经存在的 commit 修改，并对每一个合并过来的 commit 产生一个新的提交记录（commit hash）。<br>cherry-pick 的一些常用配置项:<br><code>-n, --no-commit</code> 只更新工作区和暂存区。不产生新的提交<br><code>-x</code> 在提交信息末尾追加一行（cherry picked from commit…）方便以后查到这个提交是如何产生的<br><code>-m parent-number, --mainline parent-number</code> 如果原始分支是一个合并节点，那么 cherry-pick 默认会失败，因为不知道应该采用哪个分支的代码变动。 -m 配置项告诉 git 应该采用哪个分支分变动，parent-number 代表原始提交的父分支编号<br><code>git cherry-pick -m 1 &lt;commit&gt;</code><br>一般1号父分支是接受变动分支（the branch being merged into），2号父分支是作为变动来源的分支（the branch being merged from)</p>
<pre><code>git cherry-pick &lt;commit&gt; /* 指定任何本地分支上的某个存在的提交 */
git cherry-pick &lt;commit1&gt; &lt;commit2&gt; /* 多个不连续的提交，提交之间用空格相隔 */
git cherry-pick &lt;start-commit&gt;..&lt;end-commit&gt; /* 连续的提交（左开右闭），使用`..`注意中间没有任何空格 */
git cherry-pick &lt;branchName&gt; /* 会将指定分支的最后一次提交应用到当前分支 */
/* 转移另一个代码库的提交 */
/* 其实 cherry-pick 的奥义就是，只要是在一个.git仓库管理下的本地代码，任何提交都可以被应用到任何可访问的本地分支，哪怕是跨代码库：*/
git remote add repo2 git@xxx.git /* 添加另一个代码库 */
git fetch repo2 /* 抓取新代码库到本地 */
git log repo2/master /* 查看新代码库master分支的提交记录 */
git cherry-pick &lt;commitInRepo2&gt; /* 将新的代码库的某个提交应用到当前分支（跨代码库的合并） */
</code></pre>
<h2 id="merge"><a href="#merge" class="headerlink" title="merge"></a>merge</h2><p>将两个或多个分叉历史合并在一起，最常见用于组合两个分支。</p>
<pre><code>git merge debug /* 将 debug 分支合并到当前分支 */
git merge debug fixup /* 合并分支 debug 和 fixup 到当前分支之上 */
git merge --no-commit debug /* 合并分支 debug 到当前分支，但是不自动创建新提交，快进是合并不适用 */
git merge --no-ff debug /* 非快进式合并，产生合并提交  */
git merge -Xours debug /* 不用手动解决冲突，在那个分支（debug）上所有其他非冲突的改动都可以被成功地合并入，有冲突的区别，选择特定的一边（当前分支）并忽略另外一边（debug分支）*/

如果想要做类似的事情但是甚至并不想让 Git 尝试合并另外一边的修改， 有一个更严格的选项，它是 “ours”
合并 策略。 这与 “ours” recursive 合并选项不同
git merge -s ours debug /* 这本质上会做一次假的合并。 它会记录一个以两边分支作为父结点的新合并提交，但是它甚至根本不关注你正合并入的分支。 它只会简单地把当前分支的代码当作合并结果记录下来 */
git merge -s theirs debug /* 用 debug 的修改作为合并策略 */
</code></pre>
<h2 id="rebase"><a href="#rebase" class="headerlink" title="rebase"></a>rebase</h2><p>变基是将一系列提交移动或组合到新的基础提交的过程，变基的主要原因是保持线性项目历史记录。</p>
<pre><code>git rebase &lt;base&gt; /* 将当前分支重定向到 &lt;base&gt;，&lt;base&gt; 可以是提交 ID、分支名、标签，或者 HEAD 的相对引用，然后获取当前分支中的提交，并将它们应用于分支的头部 */
git rebase -i &lt;base&gt; /* 以交互方式将当前分支重设为&lt;base&gt;的基础。启动编辑器，输入 命令，说明如何将每个提交转移到新的分支 */
git rebase --interactive &lt;base&gt; /* 交互式变基 */
 git rebase --onto &lt;newbase&gt; &lt;oldbase&gt; /* 类似于切片变基，以newbase为新的基点，将以oldbase基点的下一个提交到该分支的顶端 */
git rebase master debug /* 以master分支为基点应用debug分支的提交（这样写不必在变基前签出debug分支） */
git rebase --onto=&lt;new_base&gt; &lt;old_base&gt; [&lt;branch&gt;]
git rebase --onto=&lt;new_base&gt; &lt;old_base&gt; /* 如果现在是在分支上，可以省略 */
git rebase &lt;new_old_base&gt; /* 如果new_base与old_base相同，我们可以省略--onto参数 */
(事实上，&lt;old_base&gt;是我们用来比较分支的东西。如果它是一个分支，那么 git 就会寻找一个共同的祖先（参见 --fork-point）；如果它是当前分支上的一个提交，就会使用之后的提交；如果它是一个与当前分支没有共同祖先的提交，就会使用当前分支的所有提交。&lt;new_base&gt;也可以是一个提交。因此，举例来说，git rebase --onto HEAD~ HEAD 会把旧基地 HEAD 和当前 HEAD 之间的提交放在 HEAD~ 的上面，有效地删除了最后一个提交）。
</code></pre>
<p><code>git rebase branch</code></p>
<pre><code>           Before                           After
    A---B---C---F---G (branch)        A---B---C---F---G (branch)
             \                                         \
              D---E (HEAD)                              D---E (HEAD)
</code></pre>
<p><code>git rebase --onto F D</code> 将父级为D的HEAD的可达提交重置于F之上</p>
<pre><code>          Before                           After
    A---B---C---F---G (branch)        A---B---C---F---G (branch)
             \                                     \
              D---E---H---I (HEAD)                  E---H---I (HEAD)
</code></pre>
<p><code>git rebase --onto B E</code> 删除一些提交时不要交互式变基</p>
<pre><code>          Before                       After
    A---B---C---E---F (HEAD)        A---B---F (HEAD)
</code></pre>
<p><a href="https://so.csdn.net/so/search?q=git%20rebase&spm=1001.2101.3001.7020">git rebase</a> –onto有3个参数<br>git rebase –onto 可以在精度方面更进一步。事实上，它允许您在另一个提交的基础上重设一个任意范围的提交<br><code>git rebase --onto F D H</code> 把 E–H 的切片放在 F 的上面，忽略 HEAD 当前指向的位置</p>
<pre><code>          Before                                     After
    A---B---C---F---G (branch)                A---B---C---F---G (branch)
             \                                             \
              D---E---H---I (HEAD)                          E---H (HEAD)
</code></pre>
<p>git rebase时产生冲突标记</p>
<pre><code>&lt;&lt;&lt;&lt;&lt;&lt;&lt; - ||||||| /* 变动来源的分支的修改 */
||||||| - ======= /* 基线 */
======= - &gt;&gt;&gt;&gt;&gt;&gt;&gt; /* 接受变动分支的修改 */
</code></pre>
<h2 id="commit"><a href="#commit" class="headerlink" title="commit"></a>commit</h2><p>提交暂存的更改到仓库</p>
<pre><code>git commit /* 默认编辑器打开，提示添加一条新的提交消息 */
git commit -m &#39;first commit&#39; /* 将所有暂存的文件提交至仓库 */
git comm --allow-empty /* 创建空提交 */
git commit --amend / 使用当前暂存的修改更新之前的提交，并提供一个新的提交消息 */
git commit --amend --date=&quot;$(date -R)&quot; /* 将commit的时间改为当前时间 */
</code></pre>
<h2 id="reset"><a href="#reset" class="headerlink" title="reset"></a>reset</h2><p>重置当前HEAD到指定的状态</p>
<pre><code>git reset --hard HEAD^ /* HEAD和branch切换到上一条commit，且工作区和暂存区也重置为上一次commit状态 */
git reset --hard /* 工作区和暂存区重置为HEAD新位置，branch和HEAD也切换 */
git reset --soft HEAD^ /* HEAD切换到HEAD^,工作区不改变，暂存区不改变 */
git reset --mixed /* git reset缺省默认，重置暂存区，工作区不改变，更改引用 */
git reset HEAD filename /* 将文件filename撤出暂存区，相当于对命令git add filename的反向操作 */
git reset --merge ORIG_HEAD /* 移除当前分支中所有在最近一次合并中引入的提交，保留工作树尚未添加的更改 */
</code></pre>
<p>重置命令的一个用途就是修改引用（如master）的游标，重置命令的时候没有使用任何参数对所要重置的分支名进行设置，这是因为重置命名实际上所针对的是头指针HEAD，之所以没有改变HEAD的内容是因为HEAD指向了一个引用<code>refs/heads/master</code>,所以重置命令体现为分支“游标”的变更，HEAD本身一直指向的是<code>refs/heads/master</code>，并没有在重置时改变。</p>
<h2 id="stash"><a href="#stash" class="headerlink" title="stash"></a>stash</h2><p>将本地修改保存到一个新的 stash 条目，并将其回滚到 HEAD（工作树和索引中）。 部分是可选的，它给出了描述和储藏状态。</p>
<pre><code>git stash push /* 保存当前工作区和暂存区未提交的改动，最新保存的永远都是stash@&#123;0&#125;，回到干净目录，push可省略 */
git stash save message /* 保存备注的信息（已弃用）改用 git stash push */
git stash push -m message /* 代替 save */
git stash push -k /* 所有已添加到索引中的更改将保持不变，将所有其他改动保存到储藏室中 */
git stash push --staged /* 仅存储当前暂存的更改。这与基本的 git commit 类似，只是将状态提交到储藏库，而不是当前分支 */
git stash push [--] &lt;pathspec&gt;…​ /* 部分存储，指定缓存哪些路径文件 */
git stash push work/bsp/ -m message /* 存储work/bsp/目录下的文件，不符合路径规范的文件不存储 */
git stash list /* 列出存储的stash */
git stash pop /* 从最近存储的进度(stash@&#123;0&#125;)进行恢复将其应用到当前并从储藏列表移除，但当前工作区要与暂存区保持一致 */
git stash pop stash@&#123;0&#125; /* 恢复指定索引的进度 */
git stash drop stash@&#123;0&#125; /* 从储藏条目列表中删除一个单一的储藏条目 */
git stash clear /* 删除所有储藏条目列表 */
git stash show -p stash@&#123;1&#125; /* 以补丁形式查看指定的暂存 */
</code></pre>
<h2 id="worktree"><a href="#worktree" class="headerlink" title="worktree"></a>worktree</h2><p>一个 git 仓库可以支持多个工作树，允许你一次签出多个分支。用git worktree添加一个新的工作树与版本库相关联，同时添加额外的元数据，以区分该工作树与同一版本库中的其他工作树。工作树，连同这些元数据，被称为 “工作树”。</p>
<p>这个新的工作树被称为 “链接工作树”，而不是由 git-init 或 git-clone 准备的 “主工作树”。一个版本库有一个主工作树（如果它不是一个裸版本库）和零个或多个链接工作树。当你用完一个链接的工作树后，用 git worktree remove 删除它。</p>
<p>在其最简单的形式中，git worktree add 会自动创建一个新的分支，其名称是 的最后一个组成部分，如果你计划在一个新的主题上工作，这很方便。例如，git worktree add …&#x2F;hotfix 创建了新的分支 hotfix，并在路径 …&#x2F;hotfix 处检查。如果要在新的工作树中处理现有的分支，可以使用 git worktree add 。另一方面，如果你只是打算做一些实验性的修改，或者在不影响现有开发的情况下进行测试，创建一个不与任何分支相关联的废弃工作树往往很方便。例如，git worktree add -d 在与当前分支相同的提交处创建一个带有分离的 HEAD 的新工作树。</p>
<p>如果没有使用 git worktree remove 就删除了工作树，那么它相关的管理文件，即驻留在仓库中的文件，最终会被自动删除（见 gc.worktreePruneExpire in git-config），或者你可以在主工作树或任何链接工作树中运行 git worktree prune 来清理任何过时的管理文件。</p>
<p>假如我们正在dev开发分支进行工作，这个时候遇到紧急情况，我们需要在master分支工作，暂停在dev分支的工作，但在dev分支工作还没做完，我们不想产生新的提交，除了使用<code>stash</code>，还可以使用<code>worktree</code>，创建新工作树链接到当前存储库，从而实现签出多个分支</p>
<pre><code>git worktree add path commit /* 在 &lt;path&gt; 创建一个工作树，并将 &lt;commit-ish&gt; 签出到其中。新的工作树被链接到当前的版本库，共享除每个工作树文件（如 HEAD、索引等）之外的一切 */

如果 &lt;commit-ish&gt; 是一个分支名（称其为 &lt;branch&gt;），并且没有找到，也没有使用 -b、-B 或 --detach，但在恰好一个远程（称其为 &lt;remote&gt;）中确实存在一个名称匹配的跟踪分支，则视作等同于：
git worktree add --track -b &lt;branch&gt; &lt;path&gt; &lt;remote&gt;/&lt;branch&gt;
如果 &lt;commit-ish&gt; 被省略，而且既没有使用 -b 也没有使用 --detach，那么为了方便起见，新的工作树将与一个以 $(basename &lt;path&gt;) 命名的分支（称之为 &lt;branch&gt;）相关联。如果 &lt;branch&gt; 不存在，就会自动创建一个基于 HEAD 的新分支，就像给出 -b &lt;branch&gt; 一样。

git worktree add -b emergency-fix ../temp master /* 创建一个名为 emergency-fix 的新分支，如果 &lt;commit-ish&gt; 被省略，它默认为 HEAD。默认情况下，如果一个新的分支已经存在，-b 会拒绝创建它，-B 覆盖这一保护措施，将 &lt;new-branch&gt; 重置为 &lt;commit-ish&gt;*/

git worktree remove ../temp /* 删除工作树 */
git woektree list /* 列出工作树，首先列出主工作树，在列出worktree链接的工作树 */
</code></pre>
<h2 id="revert"><a href="#revert" class="headerlink" title="revert"></a>revert</h2><p>本地分支中使用<code>git reset</code>很方便，但是这种“改写历史”的方法对大家一起使用的远程分支是无效的，<code>revert</code>是用来撤销一个指定提交的操作，<code>revert</code>之后就可以把你的更改推送到远程仓库</p>
<pre><code>git revert &lt;commit&gt; /* 产生一个新提交，新的提交相当于撤销&lt;commit&gt;这个提交 */
git revert HEAD~3..HEAD~1 /* 将HEAD~2到HEAD~1的两次提交的改动还原，并连续创建（弹出提交消息框）HEAD~1和HEAD~2的提交 */
git revert -n HEAD~3..HEAD~1 /* 作用同上，但不创建任何包含还原改动的提交。还原只会修改工作区和索引 */
</code></pre>
<h2 id="clone"><a href="#clone" class="headerlink" title="clone"></a>clone</h2><p><code>git clone &lt;repository&gt; &lt;directory&gt;</code>将<code>&lt;repository&gt;</code>指向的版本库创建一个克隆到<code>&lt;directory&gt;</code>目录，<code>&lt;directory&gt;</code>相当于克隆版本库的工作区，文件都会检出，版本库位于工作区下的<code>.git</code>目录中。它通常会自动地创建一个跟踪origin&#x2F;master的master分支，<code>git clone</code>实际上是一个封装了其他几个命令的命令。 它创建了一个名为“linux”的新目录，切换到新的目录，然后<code>git init</code>来初始化一个空的Git仓库， 然后为你指定的URL添加一个（默认名称为origin的）远程仓库（git remote add），再针对远程仓库执行<code>git fetch</code>，最后通过<code>git checkout</code>将远程仓库的最新提交检出到本地的工作目录</p>
<pre><code>git clone https://github.com/torvalds/linux.git /* 没有指定目录，存储库最后一级的目录名去掉后缀作为新克隆的目录名 */
</code></pre>
<h2 id="remote"><a href="#remote" class="headerlink" title="remote"></a>remote</h2><p>管理远程仓库，将一个远程连接加入到仓库中时，必须为它分配一个别名。默认情况下，这个别名是 <code>origin</code>。<br><code>git remote add &lt;name&gt; &lt;URL&gt;</code><br>为位于 <code>&lt;URL&gt;</code> 的版本库添加名为 <code>&lt;name&gt;</code> 的远程。然后就可以使用 <code>git fetch &lt;name&gt;</code> 命令来创建和更新远程跟踪分支 <code>&lt;name&gt;/&lt;branch&gt;</code>。</p>
<pre><code>git remote /* 列出本地已添加的远程仓库 */
git remote -v /* 列出本地已添加的远程仓库并显示url(--verbose) */
git remote add &lt;name&gt; &lt;url&gt; / * 创建一个连接到远程软件仓库的新连接。添加远程仓库后、 可以在其他命令中使用 &lt;name&gt; 作为 &lt;url&gt; 的快捷方式 */
git remote add origin https://github.com/torvalds/linux.git /* 在config添加一个指向远程仓库的引用 */
git remote rm origin /* 删除名为 origin 的远程。远程的所有远程跟踪分支和配置设置都会被删除 */
git remote -v update --prune origin /* 获取远程仓更新，并清理所有过时的远程跟踪分支 */
git remote show /* 显示远程仓库名 */
git remote show origin /* 连接origin远程仓库检查远程仓库所有分支和本地分支关联情况，这个命令列出了当你在特定的分支上执行 git push 会自动地推送到哪一个远程分支。 它也同样地列出了哪些 远程分支不在你的本地，哪些远程分支已经从服务器上移除了， 还有当你执行 git pull 时哪些本地分支可以与它跟踪的远程分支自动合并。 */
git remote update /* 关联多个远程仓全部更新，相当于每个远程仓执行git fetch */
git remote rename origin new_name /* 将origin远程仓重命名new_name */
git remote set-url origin &lt;NEW_URL&gt; /* 重设origin远程仓的地址 */
git remote set-url --push origin &lt;NEW_URL&gt; /* 给git push设置origin远程仓的url地址 */
git show-ref /* 查看全部本地引用 */
</code></pre>
<h2 id="fetch"><a href="#fetch" class="headerlink" title="fetch"></a>fetch</h2><p>访问远程仓库，从中获取本地版本库没有的数据。 执行完成后拥有那个远程仓库中所有分支的引用，可以随时合并或查看。本地远程分支列表不会自动更新，<code>fetch</code>命令可以更新，但如果远程仓库有删除的分支，那么在更新时本地远程分支列表并不会将其删除。</p>
<pre><code>git fetch &lt;remote&gt; &lt;branch&gt; /* 从 仓库 抓取特定的 &lt;branch&gt;。不使用&lt;branch&gt; 来获取所有远程参考  */
git fetch origin /* 获取更新的列表和所有远程分支的内容，远程分支列表不会自动更新 */
</code></pre>
<p><code>git fetch origin</code>操作时使用的默认引用表达式，fetch参数相当于执行了<code>git fetch origin +refs/heads/*:refs/remotes/origin/*</code>命令<code>+</code>号告诉Git即使在不能快进的情况下也要（强制）更新引用。引用表达式中使用了通配符，冒号前面的含有通配符的引用指的是远程版本库的所有分支（远程库上所有的以refs&#x2F;heads&#x2F;开头的引用），冒号后面的引用含义是复制到本地的远程分支目录（本地的refs&#x2F;remotes&#x2F;origin开头的引用）中。<br>注意：<code>git fetch</code>命令只会将数据下载到的本地仓库——它并不会自动合并或修改当前的工作，必须手动将其合并。</p>
<h2 id="pull"><a href="#pull" class="headerlink" title="pull"></a>pull</h2><p>拉取后合并</p>
<pre><code>git pull /* 在一个跟踪分支上输入 git pull，Git 能自动地识别去哪个服务器上抓取、合并到哪个分支 */
git pull --rebase /* 通过变基来更新自己的本地分支，默认merge */
git pull --rebase &lt;remote&gt;/* 获取当前分支的远程副本，并将其重定为本地副本。使用 git rebase 代替 merge 来整合分支 */
git pull upstream master:tgmaster /* 将 upstream 远程版本的 master 分支合并到本地的 tgmaster 分支 */
git pull &lt;remote&gt; /* 获取当前分支的指定远程副本，并立即将其合并到本地副本中 */
</code></pre>
<blockquote>
<ul>
<li>如果为当前分支设置了，即由配置branch..remote给出了远程版本库代号，则不带参数执行:command:<code>git pull</code>相当于执行了:command:<code>git pull &lt;remote&gt;</code>。</li>
<li>如果没有为当前分支设置，则不带参数执行:command:<code>git pull</code>相当于执行了:command:<code>git pull origin</code>。</li>
<li>要获取的远程版本库的URL地址由remote..url给出。</li>
<li>如果为注册的远程版本库设置了fetch参数，即通过remote..fetch配置了一个引用表达式，则使用该引用表达式执行获取操作。</li>
<li>接下来要确定合并的分支。如果设定了branch..merge，则对其设定的分支执行合并，否则报错退出。</li>
</ul>
</blockquote>
<h2 id="push"><a href="#push" class="headerlink" title="push"></a>push</h2><p><code>[--no-verify] [&lt;repository&gt; [&lt;refspec&gt;…​]]</code><br>切换 pre-push 钩子。 默认是 –verify，给钩子一个机会来阻止推送。 如果使用 –no-verify，钩子会被完全绕过。</p>
<p>当命令行没有用 <code>&lt;repository&gt;</code> 参数指定推送位置时，会参考当前分支的 <code>branch.*.remote</code>配置来决定推送位置。 如果配置丢失，则默认为 <code>origin</code>。<br>当命令行没有用 <code>&lt;refspec&gt;...</code> 参数或 <code>--all、--mirror、--tags</code> 选项指定推送内容时，命令通过查阅 <code>remote.*.push</code> 配置找到默认的 <code>&lt;refspec&gt;</code>，如果没有找到，则以 <code>push.default</code> 配置决定推送内容。<br>当命令行和配置都没有指定推送的内容时，将使用默认行为，这与 <code>push.default</code> 的 simple 值相对应：当前分支被推送到相应的上游分支，但作为一项安全措施，如果上游分支的名称与本地分支不一致，推送将被中止。</p>
<p>指定用哪个源对象更新哪个目标引用。<code>&lt;refspec&gt;</code> 参数的格式是一个可选的加号 <code>+</code>，后面是源对象 <code>&lt;src&gt;</code>，后面是冒号 <code>:</code> ，后面是目标引用 <code>&lt;dst&gt;</code>。<br><code>+</code>等同于<code>--force</code>，通常情况下，命令会拒绝更新一个不属于用来覆盖它的本地引用祖先的远程引用，这个标志禁用了这些检查。例：<code>git push origin +master</code>，强制推送到 <code>master</code> 分支。<br><code>&lt;src&gt;</code> 通常是你想推送的分支的名字，但它可以是任何任意的“SHA-1 表达式”，比如 <code>master~4</code> 或 <code>HEAD</code>。<br><code>&lt;dst&gt;</code> 远程仓库的哪个引用被这个推送更新。这里不能使用任意的表达式，必须命名一个实际的引用。</p>
<p><code>git push origin :experimental</code>在 <code>origin</code> 仓库（例如<code>refs/heads/experimental</code>）中找到一个与 <code>experimental</code> 相匹配的引用，并将其删除。<br>推送一个空的 <code>&lt;src&gt;</code> 允许你从远程版本库中删除 <code>&lt;dst&gt;</code> 的引用。除非配置或钩子禁止，否则在引用规范中没有前面的 <code>+</code> (或 <code>--force</code>) ，删除总是被接受的。</p>
<pre><code>git push
</code></pre>
<p>如果 <code>git push [&lt;repository&gt;]</code> 没有任何 <code>&lt;refspec&gt;</code> 参数被设置用 <code>remote.&lt;repository&gt;.push</code> 配置变量更新目的地 <code>&lt;src&gt;</code> 的某个引用，则<code>:&lt;dst&gt;</code> 部分可以省略 —— 这样的推送将更新 <code>&lt;src&gt;</code> 通常更新的引用，命令行上没有任何 <code>&lt;refspec&gt;</code>。 否则，缺少 <code>:&lt;dst&gt;</code> 意味着更新与 <code>&lt;src&gt;</code> 相同的引用。</p>
<blockquote>
<ul>
<li>如果为当前分支设置了，即由配置branch..remote给出了远程版本库代号，则不带参数执行:command:<code>git push</code>相当于执行了:command:<code>git push &lt;remote&gt;</code>。</li>
<li>如果没有为当前分支设置，则不带参数执行:command:<code>git push</code>相当于执行了:command:<code>git push origin</code>。</li>
<li>要推送的远程版本库的URL地址由remote..pushurl给出。如果没有配置，则使用remote..url配置的URL地址。</li>
<li>如果为注册的远程版本库设置了push参数，即通过remote..push配置了一个引用表达式，则使用该引用表达式执行推送。</li>
<li>否则使用“:”作为引用表达式。该表达式的含义是同名分支推送，即对所有在远程版本库有同名分支的本地分支执行推送。<br>这也就是为什么在一个本地新建分支中执行:command:<code>git push</code>推送操作不会推送也不会报错的原因，因为远程不存在同名分支，所以根本就没有对该分支执行推送，而推送的是其他分支（如果远程版本库有同名分支的话）。</li>
</ul>
</blockquote>
<pre><code>git push &lt;remote&gt; &lt;branch&gt; /* 推送&lt;branch&gt;分支到&lt;remote&gt;远程仓，以及必要的提交和对象。如果远程仓库不存在，则在远程仓库中创建&lt;branch&gt;命名分支 */
git push &lt;remote&gt; --all /* 将所有本地分支推送到指定的远程分支 */
git push origin new_branch /* 将new_branch分支推送到origin服务器， 并创建new_branch分支，但不会建立跟踪*/
git push --set-upstream remote_name local_branch remote_branch /* 将本地分支local_branch的副本推送至远程仓remote_name，并设置跟踪上游分支remote_branch */
git push -u origin master /* 上条命令简写，将master 支推送到origin远程仓，本地分支master跟踪远程分支master */
git push origin --delete serverfix /* 删除一个远程分支， 从服务器上删除serverfix分支 */
</code></pre>
<h2 id="branch"><a href="#branch" class="headerlink" title="branch"></a>branch</h2><p>Git 中的分支本质上是一个指向某个特定提交的命名可变指针</p>
<pre><code>git branch /* 显示本地分支列表，当前分支用星号 “*” 标识出来 */
git branch -r /* 显示远程分支(--remotes) */
git branch -a /* 显示所有分支(--all) */
git branch -v /* 查看每一个分支的最后一次提交 */
git branch -vv /* 查看所有分支，正在跟踪哪个远程分支与本地分支是否是领先、落后或是都有，需要先fetch */
git branch develop  /* 基于当前头指针（HEAD）指向的提交，创建一个develop分支 */
git branch bugfix ab1afef /* 基于提交ab1afef创建bugfix分支 */
git branch -d hotfix /* 删除分支。该分支必须完全合并到其上游分支中，如果没有使用 --track 或 --set-upstream-to 设置上游，则在合在HEAD中 */
git branch -D hotfix /* 强制删除hotfix分支，即使hotfix 支没有合并到上游分支 */
git branch | grep &#39;^feature/&#39; | xargs git branch -d /* 除所有以feature/开头的分支，可以使用 */
git branch -d -r origin/branch_name /* 删除删除远程跟踪的分支branch_name，下一次的 &quot;fetch &quot;或 &quot;pull &quot;会再次创建它 */
git branch -m &lt;oldbranch&gt; &lt;newbranch&gt; /* 重命名分支 */
git branch -f master HEAD~3 /* -f 选项让分支指向另一个提交，将master分支强制移动到HEAD的第3级父提交 */
git branch --merged /* 查看哪些分支已经合并到当前分支 */
git branch --no-merged /* 查看所有包含未合并工作的分支 */
git branch --no-merged master /* 尚未合并到master的分支 */
git branch (--set-upstream-to=&lt;upstream&gt; | -u &lt;upstream&gt;) [&lt;branchname&gt;] /* 设置 &lt;branchname&gt; 的跟踪信息，使 &lt;upstream&gt; 被视为 &lt;branchname&gt; 的上游分支。如果没有指定 &lt;branchname&gt;，则默认为当前分支 */
git branch -u origin/serverfix /* 设置或修改已有的本地分支serverfix跟踪一个刚刚拉取下来的远程分支 */
git branch [--track[=(direct|inherit)] &lt;branchname&gt; [&lt;start-point&gt;]
/* -t、--track 或 --track=direct 表示使用起点分支本身作为上游;--track=inherit 表示复制起点分支的上游配置 */
git reflog show --date=iso bugfix /* 指定bugfix分支的历次更改记录,最下面一条的时间即是分支创建时间 */
git branch --contains commit /* 列出所有包含指定提交对象的分支 */
</code></pre>
<h2 id="checkout"><a href="#checkout" class="headerlink" title="checkout"></a>checkout</h2><p>检出命令，改变HEAD本身</p>
<pre><code>git checkout /* 汇总显示工作区、暂存区与HEAD的差异 */
git checkout branch -- filename /* 暂存区和工作区中的filename文件被branch所指向的提交的filename文件直接覆盖 */
git checkout -- test.c /* 暂存区的test.c文件覆盖工作区的test.c文件 */
git checkout . /* 取消所有本地的修改（相对于暂存区），相当于将暂存区的所有文件直接覆盖工作区 */
git checkout ab1afef  test.c /* 用指定提交ab1afef中的文件覆盖暂存区和工作区中对应的文件 */
git checkout develop  /* 换到一个已存在的develop分支 */
git checkout -b hotfix /* 建立一个hotfix分支并切换 */
git checkout -b serverfix origin/serverfix /* 基于远程分支创建本地跟踪分支serverfix ，并且起点位于origin/serverfix */
git checkout -b sf origin/serverfix /* 基于远程分支创建本地跟踪分支sf，并且起点位于origin/serverfix */
git checkout --track origin/serverfix /* 基于远程分支创建本地跟踪分支serverfix ，并且起点位于origin/serverfix */
git checkout --conflict=merge hello.rb /* 重新恢复到冲突时候的文件状态 */
</code></pre>
<h2 id="restore"><a href="#restore" class="headerlink" title="restore"></a>restore</h2><p>用还原源中的某些内容还原工作树中的指定路径。如果跟踪到的路径在还原源中并不存在，它将被移除以匹配还原源。<br>使用 <code>--staged --worktree</code> 同时恢复工作树和索引，如果两个选项都未指定，默认情况下会还原工作树，指定<code>--staged</code> 只还原索引。指定两者则同时还原两者。<br>默认情况下，如果给了<code>--staged</code>，内容将从<code>HEAD</code>恢复，否则从索引恢复。使用<code>--source</code>来恢复不同的提交。</p>
<pre><code>git restore --staged hello.c /* 恢复索引中的文件以匹配 HEAD 中的版本，工作区不变 */
git restore --source=HEAD --staged --worktree hello.c /* 同时恢复索引和工作树（这与使用 git-checkout[1]相同）*/
git restore &#39;*.c&#39; /* 恢复所有的C源文件，使之与索引中的版本一致 */
</code></pre>
<h2 id="tag"><a href="#tag" class="headerlink" title="tag"></a>tag</h2><p>有没有什么可以永远指向某个提交记录的标识呢，比如软件发布新的大版本，或者是修正一些重要的 Bug或是增加了某些新特性，有没有比分支更好的可以永远指向这些提交的方法呢，<code>tag</code>永久地将某个特定的提交命名为里程碑，然后就可以像分支一样引用了。更难得的是，它们并不会随着新的提交而移动。你也不能切换到某个标签上面进行修改提交，它就像是提交树上的一个锚点，标识了某个特定的位置。<br>远程版本库中的里程碑同步到本地版本库，会使用同样的名称，而不会像分支那样移动到另外的命名空间（远程分支）中，推送时，默认不会将本地创建的里程碑带入远程版本库，这样可以避免远程版本库上里程碑的泛滥。<br>Git 支持两种里程碑（标签）：轻量里程碑（lightweight）与附注里程碑（annotated）</p>
<pre><code>git tag &lt;tagname&gt; [&lt;commit&gt;] /* 创建轻量级里程碑 */
git tag -a &lt;tagname&gt; [&lt;commit&gt;] /* 创建带说明的里程碑 */
git tag -m &lt;msg&gt; &lt;tagname&gt; [&lt;commit&gt;] /* 直接通过-m参数提供里程碑创建说明 */
git tag /* 列出所有标签 */
git show tag /* 输出所有带标签提交的详细信息 */
</code></pre>
<p>创建里程碑需要输入里程碑的名字<code>&lt;tagname&gt;</code>和一个可选的提交ID<code>&lt;commit&gt;</code>。如果没有提供提交ID，则基于头指针HEAD创建里程碑。</p>
<h2 id="rerere"><a href="#rerere" class="headerlink" title="rerere"></a>rerere</h2><p>git rerere 功能是一个隐藏的功能。 正如它的名字，重新使用记录的解决方案（reuse recorded resolution）：会记住文件冲突时用户的解决方案，当再次出现同样冲突时自动解决。</p>
<pre><code>git config --global rerere.enabled true /* 全局配置，冲突的解决会被记录下来以便以后再遇到时自动复用 */
git config --global rerere.enabled fasle /* 关闭重新使用记录的解决方案的配置，防止一些冲突没被发现 */
git checkout --conflict=merge file_path /* 文件恢复到未自动解决冲突时的状态 */
git rerere /* 恢复未解决冲突的状态后，又想用回之前的合并冲突策略 */
git merge --rerere-autoupdate /* 自动解决一个文件时，并没有把它标记为已解决（例如用git add），允许rerere机制用自动冲突解决的结果来更新索引 */
git rebase --no-rerere-autoupdate /* git rerere有rerere.autoupdate配置，但没有办法从命令行中取消它；不会停止自动重用已记录的决议，在用单独的git add将结果提交给索引之前，可以仔细检查rerere的工作，并抓住潜在的错误合并 */
</code></pre>
<h2 id="bisect"><a href="#bisect" class="headerlink" title="bisect"></a>bisect</h2><p>使用二分搜索查找引入错误的提交<br>第一个<code>git bisect</code>子命令是<code>git bisect start</code>来开始搜索。然后必须设置边界以限制提交空间。通常的做法是给出一个 “坏”提交和至少一个 “好”提交。可以像这样在调用<code>git bisect start</code>时传递它们：</p>
<pre><code>git bisect start [BAD [GOOD...]]
或 git bisect bad [COMMIT]
和 git bisect good [COMMIT...]
在搜索的每一步，用户都必须测试当前的提交，并分别使用上文所述的 &quot;git bisect good&quot; 或 &quot;git bisect bad&quot; 命令说它是 &quot;好 &quot;还是 &quot;坏&quot;。
&quot;git bisect&quot; 最终会找到第一个坏提交：git show HEAD 可以看到提交的内容
git bisect reset /* 回到我们开始二分前所在的分支 */
</code></pre>
<h2 id="blame"><a href="#blame" class="headerlink" title="blame"></a>blame</h2><p>查询文件历史版本信息<br><code>-L</code>选项将限制行范围</p>
<pre><code>git blame -L 40,60 file1.c /* 第40-60行修改的记录 */
git blame -L 40,+21 file1.c /* 从第40行开始的21行修改的记录 */
</code></pre>
<h2 id="clean"><a href="#clean" class="headerlink" title="clean"></a>clean</h2><p>从当前目录开始，通过递归删除不在版本控制之下的文件来清理工作区,clean 后，删除的文件无法找回。<br>通常情况下，只有 Git 未知的文件会被删除，但如果指定了 -x 选项，被忽略的文件也会被删除。例如，这对删除所有构建产品很有用。<br>如果给出任何可选的<code>&lt;路径规范&gt;…​</code>参数，只有那些与路径规范相匹配的路径会受到影响。<br><code>-d</code><br>通常，当没有指定 &lt;路径规范&gt; 时，git clean 不会递归到未追踪的目录，以避免删除太多。 指定 -d 可以让它也递归到这些目录。 如果指定了&lt;路径规范&gt;，-d 就不重要了；所有符合指定路径的未追踪文件（–force 下提到的嵌套的 git 目录除外）将被删除。<br><code>-f 或 --force</code><br>如果 Git 配置变量 clean.requireForce 没有设置为 false，git clean 将拒绝删除文件或目录，除非给出 -f 或 -i。 除非给出第二个 -f，否则 Git 将拒绝修改未跟踪的嵌套 git 仓库（有.git子目录的目录）。<br><code>-i</code><br>显示会做什么，并以交互方式清理文件。</p>
<pre><code>git clean -f -d /* git clean -fd 移除工作目录中所有未追踪的文件以及空的子目录 */ 
</code></pre>
<h2 id="和"><a href="#和" class="headerlink" title="~和^"></a>~和^</h2><pre><code>~2 表示沿着commit树向上搜索两层，并获得该层的第一个commit（如果该层有多个commit的话）
^2 表示获得某个commit的第2个父commit（merge两个分支后产生的merge commit就拥有两个父commit）
</code></pre>
]]></content>
      <categories>
        <category>工具</category>
        <category>Git</category>
      </categories>
      <tags>
        <tag>Git 快速入门</tag>
      </tags>
  </entry>
</search>
